(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-transition"), require("d3-zoom"), require("d3-ease"), require("d3-color"), require("d3-shape"), require("d3-interpolate"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-brush", "d3-axis", "d3-scale", "d3-dsv", "d3-drag", "d3-transition", "d3-zoom", "d3-ease", "d3-color", "d3-shape", "d3-interpolate"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-transition"), require("d3-zoom"), require("d3-ease"), require("d3-color"), require("d3-shape"), require("d3-interpolate")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__36__, __WEBPACK_EXTERNAL_MODULE__37__, __WEBPACK_EXTERNAL_MODULE__38__, __WEBPACK_EXTERNAL_MODULE__39__, __WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__41__, __WEBPACK_EXTERNAL_MODULE__42__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__45__, __WEBPACK_EXTERNAL_MODULE__46__, __WEBPACK_EXTERNAL_MODULE__47__, __WEBPACK_EXTERNAL_MODULE__48__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(32);
module.exports = __webpack_require__(49);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(3);

var socket = __webpack_require__(5);

var overlay = __webpack_require__(9);

var _require = __webpack_require__(15),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(17);

var reloadApp = __webpack_require__(18);

var createSocketUrl = __webpack_require__(21);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(30);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost:8080"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(4)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(6);
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(7);

var BaseClient = __webpack_require__(8);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(6);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* sockjs-client v1.4.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.4.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(10);

var _require = __webpack_require__(11),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_entities_1 = __webpack_require__(12);
exports.XmlEntities = xml_entities_1.XmlEntities;
var html4_entities_1 = __webpack_require__(13);
exports.Html4Entities = html4_entities_1.Html4Entities;
var html5_entities_1 = __webpack_require__(14);
exports.Html5Entities = html5_entities_1.Html5Entities;
exports.AllHtmlEntities = html5_entities_1.Html5Entities;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};
var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};
var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};
var XmlEntities = /** @class */ (function () {
    function XmlEntities() {
    }
    XmlEntities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/[<>"'&]/g, function (s) {
            return CHAR_S_INDEX[s];
        });
    };
    XmlEntities.encode = function (str) {
        return new XmlEntities().encode(str);
    };
    XmlEntities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {
            if (s.charAt(1) === '#') {
                var code = s.charAt(2).toLowerCase() === 'x' ?
                    parseInt(s.substr(3), 16) :
                    parseInt(s.substr(2));
                if (isNaN(code) || code < -32768 || code > 65535) {
                    return '';
                }
                return String.fromCharCode(code);
            }
            return ALPHA_INDEX[s] || s;
        });
    };
    XmlEntities.decode = function (str) {
        return new XmlEntities().decode(str);
    };
    XmlEntities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var alpha = CHAR_INDEX[c];
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
            if (c < 32 || c > 126) {
                result += '&#' + c + ';';
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonUTF = function (str) {
        return new XmlEntities().encodeNonUTF(str);
    };
    XmlEntities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLenght = str.length;
        var result = '';
        var i = 0;
        while (i < strLenght) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonASCII = function (str) {
        return new XmlEntities().encodeNonASCII(str);
    };
    return XmlEntities;
}());
exports.XmlEntities = XmlEntities;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];
var alphaIndex = {};
var numIndex = {};
(function () {
    var i = 0;
    var length = HTML_ALPHA.length;
    while (i < length) {
        var a = HTML_ALPHA[i];
        var c = HTML_CODES[i];
        alphaIndex[a] = String.fromCharCode(c);
        numIndex[c] = a;
        i++;
    }
})();
var Html4Entities = /** @class */ (function () {
    function Html4Entities() {
    }
    Html4Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1).toLowerCase() === 'x' ?
                    parseInt(entity.substr(2), 16) :
                    parseInt(entity.substr(1));
                if (!(isNaN(code) || code < -32768 || code > 65535)) {
                    chr = String.fromCharCode(code);
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html4Entities.decode = function (str) {
        return new Html4Entities().decode(str);
    };
    Html4Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var alpha = numIndex[str.charCodeAt(i)];
            result += alpha ? "&" + alpha + ";" : str.charAt(i);
            i++;
        }
        return result;
    };
    Html4Entities.encode = function (str) {
        return new Html4Entities().encode(str);
    };
    Html4Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var cc = str.charCodeAt(i);
            var alpha = numIndex[cc];
            if (alpha) {
                result += "&" + alpha + ";";
            }
            else if (cc < 32 || cc > 126) {
                result += "&#" + cc + ";";
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonUTF = function (str) {
        return new Html4Entities().encodeNonUTF(str);
    };
    Html4Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonASCII = function (str) {
        return new Html4Entities().encodeNonASCII(str);
    };
    return Html4Entities;
}());
exports.Html4Entities = Html4Entities;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];
var alphaIndex = {};
var charIndex = {};
createIndexes(alphaIndex, charIndex);
var Html5Entities = /** @class */ (function () {
    function Html5Entities() {
    }
    Html5Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1) === 'x' ?
                    parseInt(entity.substr(2).toLowerCase(), 16) :
                    parseInt(entity.substr(1));
                if (!(isNaN(code) || code < -32768 || code > 65535)) {
                    chr = String.fromCharCode(code);
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html5Entities.decode = function (str) {
        return new Html5Entities().decode(str);
    };
    Html5Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var charInfo = charIndex[str.charCodeAt(i)];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            result += str.charAt(i);
            i++;
        }
        return result;
    };
    Html5Entities.encode = function (str) {
        return new Html5Entities().encode(str);
    };
    Html5Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var charInfo = charIndex[c];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            if (c < 32 || c > 126) {
                result += '&#' + c + ';';
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html5Entities.encodeNonUTF = function (str) {
        return new Html5Entities().encodeNonUTF(str);
    };
    Html5Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    Html5Entities.encodeNonASCII = function (str) {
        return new Html5Entities().encodeNonASCII(str);
    };
    return Html5Entities;
}());
exports.Html5Entities = Html5Entities;
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo = void 0;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            addChar && (charInfo[chr2] = alpha);
        }
        else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            addChar && (charInfo[''] = alpha);
        }
    }
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(16).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(15),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(19);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(20);
module.exports = new EventEmitter();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(22);

var getCurrentScriptSource = __webpack_require__(29);

function createSocketUrl(resourceQuery, currentLocation) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL
    .substr(1) // replace first `&` with `?` to have a valid query string
    .replace('&', '?'), true);
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();
    urlParts = url.parse(scriptHost || '/', true, true);
  } // Use parameter to allow passing location in unit tests


  if (typeof currentLocation === 'string' && currentLocation !== '') {
    currentLocation = url.parse(currentLocation);
  } else {
    currentLocation = self.location;
  }

  return getSocketUrl(urlParts, currentLocation);
}
/*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */


function getSocketUrl(urlParts, loc) {
  var auth = urlParts.auth,
      query = urlParts.query;
  var hostname = urlParts.hostname,
      protocol = urlParts.protocol,
      port = urlParts.port;

  if (!port || port === '0') {
    port = loc.port;
  } // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384


  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {
    hostname = loc.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = loc.protocol;
  } // all of these sock url params are optionally passed in through
  // resourceQuery, so we need to fall back to the default if
  // they are not provided


  var sockHost = query.sockHost || hostname;
  var sockPath = query.sockPath || '/sockjs-node';
  var sockPort = query.sockPort || port;

  if (sockPort === 'location') {
    sockPort = loc.port;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(23);
var util = __webpack_require__(25);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(26);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)(module)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(27);
exports.encode = exports.stringify = __webpack_require__(28);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 31
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 30;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(33);
            var content = __webpack_require__(34);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(35);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px sans-serif;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc rect {\n  stroke: #fff;\n  stroke-width: 1; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused, .bb-circles.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step, .bb-circles.bb-focused path.bb-line, .bb-circles.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused, .bb-circles.bb-defocused {\n  opacity: 0.3 !important; }\n  .bb-target.bb-defocused .text-overlapping, .bb-circles.bb-defocused .text-overlapping {\n    opacity: .05 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px sans-serif; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10;\n  user-select: none; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: #fff; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__36__;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__37__;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__38__;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__39__;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__41__;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__42__;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__46__;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__48__;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "bb", function() { return /* binding */ bb; });
__webpack_require__.d(__webpack_exports__, "default", function() { return /* binding */ bb; });

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(36);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(37);

// CONCATENATED MODULE: ./src/config/classes.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcLabelLine: "bb-arc-label-line",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartCircles: "bb-chart-circles",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridFocus: "bb-ygrid-focus",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_",
  TextOverlapping: "text-overlapping"
});
// CONCATENATED MODULE: ./src/config/Store/Element.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Elements class.
 * @class Elements
 * @ignore
 * @private
 */
var Element = function () {
  return {
    chart: null,
    main: null,
    svg: null,
    axis: {
      // axes
      x: null,
      y: null,
      y2: null,
      subX: null
    },
    defs: null,
    tooltip: null,
    legend: null,
    title: null,
    subchart: {
      main: null,
      // $$.context
      bar: null,
      // $$.contextBar
      line: null,
      // $$.contextLine
      area: null // $$.contextArea

    },
    arcs: null,
    bar: null,
    // mainBar,
    line: null,
    // mainLine,
    area: null,
    // mainArea,
    circle: null,
    // mainCircle,
    radar: null,
    text: null,
    // mainText,
    grid: {
      main: null,
      // grid (also focus)
      x: null,
      // xgrid,
      y: null // ygrid,

    },
    gridLines: {
      main: null,
      // gridLines
      x: null,
      // xgridLines,
      y: null // ygridLines

    },
    region: {
      main: null,
      // region
      list: null // mainRegion

    },
    eventRect: null
  };
};


// CONCATENATED MODULE: ./src/config/Store/State.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * State class.
 * @class State
 * @ignore
 * @private
 */
var State = function () {
  return {
    width: 0,
    width2: 0,
    height: 0,
    height2: 0,
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin2: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin3: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    arcWidth: 0,
    arcHeight: 0,
    xAxisHeight: 0,
    hasAxis: !1,
    hasRadar: !1,
    current: {
      width: 0,
      height: 0,
      dataMax: 0,
      maxTickWidths: {
        x: {
          size: 0,
          ticks: [],
          clipPath: 0,
          domain: ""
        },
        y: {
          size: 0,
          domain: ""
        },
        y2: {
          size: 0,
          domain: ""
        }
      },
      // current used chart type list
      types: []
    },
    // legend
    isLegendRight: !1,
    isLegendInset: !1,
    isLegendTop: !1,
    isLegendLeft: !1,
    legendStep: 0,
    legendItemWidth: 0,
    legendItemHeight: 0,
    legendHasRendered: !1,
    axis: {
      x: {
        padding: {
          left: 0,
          right: 0
        },
        tickCount: 0
      }
    },
    rotatedPadding: {
      left: 30,
      right: 0,
      top: 5
    },
    withoutFadeIn: {},
    inputType: "",
    datetimeId: "",
    // clip id string
    clip: {
      id: "",
      idXAxis: "",
      idYAxis: "",
      idXAxisTickTexts: "",
      idGrid: "",
      idSubchart: "",
      // clipIdForSubchart
      path: "",
      pathXAxis: "",
      pathYAxis: "",
      pathXAxisTickTexts: "",
      pathGrid: ""
    },
    // status
    dragStart: null,
    dragging: !1,
    flowing: !1,
    cancelClick: !1,
    mouseover: !1,
    rendered: !1,
    transiting: !1,
    resizing: !1,
    // resize event called
    hasNegativeValue: !1,
    hasPositiveValue: !0,
    orgAreaOpacity: "0.2",
    // ID strings
    hiddenTargetIds: [],
    hiddenLegendIds: [],
    focusedTargetIds: [],
    defocusedTargetIds: [],
    // value for Arc
    radius: 0,
    innerRadius: 0,
    innerRadiusRatio: 0,
    gaugeArcWidth: 0,
    radiusExpanded: 0,
    // xgrid attribute
    xgridAttr: {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }
  };
};


// CONCATENATED MODULE: ./src/config/Store/Store.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

 // mapping

var Store_classes = {
  element: Element,
  state: State
};
/**
 * Internal store class.
 * @class Store
 * @ignore
 * @private
 */

var Store = /*#__PURE__*/function () {
  function Store() {
    var _this = this;

    Object.keys(Store_classes).forEach(function (v) {
      _this[v] = new Store_classes[v]();
    });
  }

  var _proto = Store.prototype;
  return _proto.getStore = function getStore(name) {
    return this[name];
  }, Store;
}();


// CONCATENATED MODULE: ./src/config/Options/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data config options
 */
/* harmony default export */ var data_data = ({
  /**
   * Converts data id value
   * @name data․idConverter
   * @memberof Options
   * @type {Function}
   * @default function(id) { return id; }
   * @example
   * data: {
   *    idConverter: function(id) {
   *       // when id is 'data1', converts to be 'data2'
   *       // 'data2' should be given as the initial data value
   *       if (id === "data1") {
   *          return "data2";
   *       } else {
   *          return id;
   *       }
   *    }
   * }
   */
  data_idConverter: function data_idConverter(id) {
    return id;
  },

  /**
   * Set custom data name.
   * @name data․names
   * @memberof Options
   * @type {object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
   * @example
   * data: {
   *   names: {
   *     data1: "Data Name 1",
   *     data2: "Data Name 2"
   *   }
   * }
   */
  data_names: {},

  /**
   * Set custom data class.<br><br>
   * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
   * @name data․classes
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   classes: {
   *     data1: "additional-data1-class",
   *     data2: "additional-data2-class"
   *   }
   * }
   */
  data_classes: {},

  /**
   * Set chart type at once.<br><br>
   * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
   * **Available Values:**
   * - area
   * - area-line-range
   * - area-spline
   * - area-spline-range
   * - area-step
   * - bar
   * - bubble
   * - donut
   * - gauge
   * - line
   * - pie
   * - radar
   * - scatter
   * - spline
   * - step
   * @name data․type
   * @memberof Options
   * @type {string}
   * @default line
   * @example
   * data: {
   *    type: "bar"
   * }
   */
  data_type: undefined,

  /**
   * Set chart type for each data.<br>
   * This setting overwrites data.type setting.
   * - **NOTE:** `radar` type can't be combined with other types.
   * @name data․types
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   types: {
   *     data1: "bar",
   *     data2: "spline"
   *   }
   * }
   */
  data_types: {},

  /**
   *  This option changes the order of stacking data and pieces of pie/donut.
   *  - If `null` specified, it will be the order the data loaded.
   *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
   *
   *  **Available Values:**
   *  - `desc`: In descending order
   *  - `asc`: In ascending order
   *  - `null`: It keeps the data load order
   *  - `function(data1, data2) { ... }`: Array.sort compareFunction
   * @name data․order
   * @memberof Options
   * @type {string|Function|null}
   * @default desc
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
   * @example
   * data: {
   *   // in descending order (default)
   *   order: "desc"
   *
   *   // in ascending order
   *   order: "asc"
   *
   *   // keeps data input order
   *   order: null
   *
   *   // specifying sort function
   *   order: function(a, b) {
   *       // param data passed format
   *       {
   *          id: "data1", id_org: "data1", values: [
   *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
   *              ...
   *          ]
   *       }
   *   }
   * }
   */
  data_order: "desc",

  /**
   * Set color converter function.<br><br>
   * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
   * @name data․color
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
   * @example
   * data: {
   *   color: function(color, d) { ... }
   * }
   */
  data_color: undefined,

  /**
   * Set color for each data.
   * @name data․colors
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   colors: {
   *     data1: "#ff0000",
   *     data2: function(d) {
   *        return "#000";
   *     }
   *     ...
   *   }
   * }
   */
  data_colors: {},

  /**
   * Hide each data when the chart appears.<br><br>
   * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
   * @name data․hide
   * @memberof Options
   * @type {boolean|Array}
   * @default false
   * @example
   * data: {
   *   // all of data will be hidden
   *   hide: true
   *
   *   // specified data will be hidden
   *   hide: ["data1", ...]
   * }
   */
  data_hide: !1,

  /**
   * Filter values to be shown
   * The data value is the same as the returned by `.data()`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
   * @name data․filter
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * data: {
   *   // filter for id value
   *   filter: function(v) {
   *      // v: [{id: "data1", id_org: "data1", values: [
   *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
   *      //    }, ...]
   *      return v.id !== "data1";
   *   }
   */
  data_filter: undefined,

  /**
   * Set a callback for click event on each data point.<br><br>
   * This callback will be called when each data point clicked and will receive `d` and element as the arguments.
   * - `d` is the data clicked and element is the element clicked.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onclick
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onclick: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onclick: function data_onclick() {},

  /**
   * Set a callback for mouse/touch over event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.
   * - `d` is the data where mouse cursor moves onto.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onover
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onover: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onover: function data_onover() {},

  /**
   * Set a callback for mouse/touch out event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.
   * - `d` is the data where mouse cursor moves out.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onout
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onout: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onout: function data_onout() {},

  /**
   * Set a callback for minimum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmin
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmin: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmin: undefined,

  /**
   * Set a callback for maximum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmax
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmax: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmax: undefined,

  /**
   * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
   * @name data․url
   * @memberof Options
   * @type {string}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
   * @example
   * data: {
   *     url: "/data/test.csv"
   * }
   */
  data_url: undefined,

  /**
   * XHR header value
   * - **NOTE:** Should be used with `data.url` option
   * @name data․headers
   * @memberof Options
   * @type {string}
   * @default undefined
   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
   * @example
   * data: {
   *     url: "/data/test.csv",
   *     headers: {
   *        "Content-Type": "text/xml",
   *        ...
   *     }
   * }
   */
  data_headers: undefined,

  /**
   * Parse a JSON object for data. See also data.keys.
   * @name data․json
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [data․keys](#.data%25E2%2580%25A4keys)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_json: undefined,

  /**
   * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
   * @name data․rows
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
   * @example
   * data: {
   *   rows: [
   *     ["A", "B", "C"],
   *     [90, 120, 300],
   *     [40, 160, 240],
   *     [50, 200, 290],
   *     [120, 160, 230],
   *     [80, 130, 300],
   *     [90, 220, 320]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {high:150, mid: 140, low: 110}, 120
   *        [150, 140, 110], 120
   *      ],
   *      [[155, 130, 115], 55],
   *      [[160, 135, 120], 60]
   *   ],
   *   types: {
   *       data1: "area-line-range",
   *       data2: "line"
   *   }
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {y:10, z: 140}, 120
   *        [10, 140], 120
   *      ],
   *      [[100, 30], 55],
   *      [[50, 100], 60]
   *   ],
   *   types: {
   *       data1: "bubble",
   *       data2: "line"
   *   }
   * }
   */
  data_rows: undefined,

  /**
   * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
   * @name data․columns
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
   * @example
   * data: {
   *   columns: [
   *      ["data1", 30, 20, 50, 40, 60, 50],
   *      ["data2", 200, 130, 90, 240, 130, 220],
   *      ["data3", 300, 200, 160, 400, 250, 250]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   columns: [
   *      ["data1",
   *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
   *          [150, 140, 110],
   *          [150, 140, 110]
   *      ]
   *   ],
   *   type: "area-line-range"
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   columns: [
   *      ["data1",
   *          [10, 140],  // or {y:10, z: 140}
   *          [100, 30],
   *          [50, 100]
   *      ]
   *   ],
   *   type: "bubble"
   * }
   */
  data_columns: undefined,

  /**
   * Used if loading JSON via data.url.
   * - **Available Values:**
   *   - json
   *   - csv
   *   - tsv
   * @name data․mimeType
   * @memberof Options
   * @type {string}
   * @default csv
   * @example
   * data: {
   *     mimeType: "json"
   * }
   */
  data_mimeType: "csv",

  /**
   * Choose which JSON object keys correspond to desired data.
   * - **NOTE:** Only for JSON object given as array.
   * @name data․keys
   * @memberof Options
   * @type {string}
   * @default undefined
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_keys: undefined,

  /**
   * Set text label to be displayed when there's no data to show.
   * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
   * @name data․empty․label․text
   * @memberof Options
   * @type {string}
   * @default ""
   * @example
   * data: {
   *   empty: {
   *     label: {
   *       text: "No Data"
   *     }
   *   }
   * }
   */
  data_empty_label_text: ""
});
// CONCATENATED MODULE: ./src/config/Options/common/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * color config options
 */
/* harmony default export */ var common_color = ({
  /**
   * Set color of the data values
   * @name color
   * @memberof Options
   * @type {object}
   * @property {object} color color object
   * @property {string|object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
   * @property {Array|null} [color.pattern=[]] Set custom color pattern. Passing `null` will not set a color for these elements, which requires the usage of custom CSS-based theming to work.
   * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
   *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
   *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
   *    - `bb-colorize-pattern-red`
   *    - `bb-colorize-pattern-fff`
   * @property {object} [color.threshold] color threshold for gauge and tooltip color
   * @property {string} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
   * @property {Array} [color.threshold.values] Threshold values for each steps
   * @property {number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
   * @example
   *  color: {
   *      pattern: ["#1f77b4", "#aec7e8", ...],
   *
   *      // Set colors' patterns
   *      // it should return an array of SVGPatternElement
   *      tiles: function() {
   *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
   *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
   *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
   *
   *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
   *         pattern.setAttribute("width", "32");
   *         pattern.setAttribute("height", "32");
   *
   *         g.style.fill = "#000";
   *         g.style.opacity = "0.2";
   *
   *         circle1.setAttribute("cx", "3");
   *         circle1.setAttribute("cy", "3");
   *         circle1.setAttribute("r", "3");
   *
   *         g.appendChild(circle1);
   *         pattern.appendChild(g);
   *
   *         return [pattern];
   *      },
   *
   *      // for threshold usage, pattern values should be set for each steps
   *      pattern: ["grey", "green", "yellow", "orange", "red"],
   *      threshold: {
   *          unit: "value",
   *
   *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
   *          values: [10, 20, 30, 40, 50],
   *
   *          // the equation for max:
   *          // - unit == 'value': max => 30
   *          // - unit != 'value': max => value*100/30
   *          max: 30
   *      },
   *
   *      // set all data to 'red'
   *      onover: "red",
   *
   *      // set different color for data
   *      onover: {
   *          data1: "red",
   *          data2: "yellow"
   *      },
   *
   *      // will pass data object to the callback
   *      onover: function(d) {
   *          return d.id === "data1" ? "red" : "green";
   *      }
   *  }
   */
  color_pattern: [],
  color_tiles: undefined,
  color_threshold: {},
  color_onover: undefined
});
// CONCATENATED MODULE: ./src/config/Options/common/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * interaction config options
 */
/* harmony default export */ var interaction = ({
  /**
   * Interaction options
   * @name interaction
   * @memberof Options
   * @type {object}
   * @property {object} interaction Intersection object
   * @property {boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
   *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
   * @property {boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
   * @property {boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
   * @property {boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
   * @property {boolean|number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
   * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
   * @example
   * interaction: {
   *    enabled: false,
   *    brighten: false,
   *    inputType: {
   *        mouse: true,
   *        touch: false
   *
   *        // or declare preventDefault explicitly.
   *        // In this case touch inputType is enabled by default
   *        touch: {
   *            preventDefault: true
   *
   *            // or threshold pixel value (pixel moved from touchstart to touchmove)
   *            preventDefault: 5
   *        }
   *    }
   * }
   */
  interaction_enabled: !0,
  interaction_brighten: !0,
  interaction_inputType_mouse: !0,
  interaction_inputType_touch: {}
});
// CONCATENATED MODULE: ./src/config/Options/common/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * legend config options
 */
/* harmony default export */ var common_legend = ({
  /**
   * Legend options
   * @name legend
   * @memberof Options
   * @type {object}
   * @property {object} legend Legend object
   * @property {boolean} [legend.show=true] Show or hide legend.
   * @property {boolean} [legend.hide=false] Hide legend
   *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
   * @property {string|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
   * @property {string|Function} [legend.contents.template=undefined] Set item's template.<br>
   *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
   *    - {=COLOR}: data color value
   *    - {=TITLE}: data title value
   *  - If set `function` value, will pass following arguments to the given function:
   *   - title {string}: data's id value
   *   - color {string}: color string
   *   - data {Array}: data array
   * @property {string} [legend.position=bottom] Change the position of legend.<br>
   *  Available values are: `bottom`, `right` and `inset` are supported.
   * @property {object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
   *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
   *  - **anchor** decides the position of the legend:
   *   - top-left
   *   - top-right
   *   - bottom-left
   *   - bottom-right
   *  - **x** and **y**:
   *   - set the position of the legend based on the anchor.
   *  - **step**:
   *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
   * @property {boolean} [legend.equally=false] Set to all items have same width size.
   * @property {boolean} [legend.padding=0] Set padding value
   * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
   * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
   * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
   * @property {number} [legend.item.tile.width=10] Set width of item tile element
   * @property {number} [legend.item.tile.height=10] Set height of item tile element
   * @property {boolean} [legend.usePoint=false] Whether to use custom points in legend.
   * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
   * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
   * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
   * @example
   *  legend: {
   *      show: true,
   *      hide: true,
   *      //or hide: "data1"
   *      //or hide: ["data1", "data2"]
   *      contents: {
   *          bindto: "#legend",   // <ul id='legend'></ul>
   *
   *          // will be as: <li style='background-color:#1f77b4'>data1</li>
   *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
   *
   *          // or using function
   *          template: function(id, color, data) {
   *               // if you want omit some legend, return falsy value
   *               if (id !== "data1") {
   *                    return "<li style='background-color:"+ color +">"+ id +"</li>";
   *               }
   *          }
   *      },
   *      position: "bottom",  // bottom, right, inset
   *      inset: {
   *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
   *          x: 20,
   *          y: 10,
   *          step: 2
   *      },
   *      equally: false,
   *      padding: 10,
   *      item: {
   *          onclick: function(id) { ... },
   *          onover: function(id) { ... },
   *          onout: function(id) { ... },
   *
   *          // set tile's size
   *          tile: {
   *              width: 20,
   *              height: 15
   *          }
   *      },
   *      usePoint: true
   *  }
   */
  legend_show: !0,
  legend_hide: !1,
  legend_contents_bindto: undefined,
  legend_contents_template: undefined,
  legend_position: "bottom",
  legend_inset_anchor: "top-left",
  legend_inset_x: 10,
  legend_inset_y: 0,
  legend_inset_step: undefined,
  legend_item_onclick: undefined,
  legend_item_onover: undefined,
  legend_item_onout: undefined,
  legend_equally: !1,
  legend_padding: 0,
  legend_item_tile_width: 10,
  legend_item_tile_height: 10,
  legend_usePoint: !1
});
// CONCATENATED MODULE: ./src/config/Options/common/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * title config options
 */
/* harmony default export */ var common_title = ({
  /**
   * Set title options
   * @name title
   * @memberof Options
   * @type {object}
   * @property {object} title Title object
   * @property {string} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
   * @property {number} [title.padding.top=0] Top padding value.
   * @property {number} [title.padding.right=0] Right padding value.
   * @property {number} [title.padding.bottom=0] Bottom padding value.
   * @property {number} [title.padding.left=0] Left padding value.
   * @property {string} [title.position=center] Available values are: 'center', 'right' and 'left'.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
   * @example
   *  title: {
   *      text: "Title Text",
   *
   *      // or Multiline title text
   *      text: "Main title text\nSub title text",
   *
   *      padding: {
   *          top: 10,
   *          right: 10,
   *          bottom: 10,
   *          left: 10
   *      },
   *      position: "center"
   *  }
   */
  title_text: undefined,
  title_padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  title_position: "center"
});
// CONCATENATED MODULE: ./src/config/Options/common/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * tooltip config options
 */
/* harmony default export */ var common_tooltip = ({
  /**
   * Tooltip options
   * @name tooltip
   * @memberof Options
   * @type {object}
   * @property {object} tooltip Tooltip object
   * @property {boolean} [tooltip.show=true] Show or hide tooltip.
   * @property {boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
   * @property {boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
   *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
   * @property {boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
   * @property {string} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
   * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
   *  Specified function receives x of the data point to show.
   * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   *  If undefined returned, the row of that value will be skipped.
   * @property {Function} [tooltip.position] Set custom position function for the tooltip.<br>
   *  This option can be used to modify the tooltip position by returning object that has top and left.
   * @property {Function|object} [tooltip.contents] Set custom HTML for the tooltip.<br>
   *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
   * @property {string|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
   *  - **NOTE:** When is specified, will not be updating tooltip's position.
   * @property {string} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
   *  Within template, below syntax will be replaced using template-like syntax string:
   *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
   *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
   *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
   *    - **{=TITLE}**: title value.
   *    - **{=COLOR}**: data color.
   *    - **{=VALUE}**: data value.
   * @property {object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
   *  - **NOTE:** It should contain `{ key: Array, ... }` value
   *    - 'key' name is used as substitution within template as '{=KEY}'
   *    - The value array length should match with the data length
   * @property {boolean} [tooltip.init.show=false] Show tooltip at the initialization.
   * @property {number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
   * @property {object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
   * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
   * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
   * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
   * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
   * @property {string|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
   *  **Available Values:**
   *  - `desc`: In descending data value order
   *  - `asc`: In ascending data value order
   *  - `null`: It keeps the data display order<br>
   *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
   *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
   *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
   * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
   * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
   * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
   * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
   * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
   * @example
   *  tooltip: {
   *      show: true,
   *      doNotHide: true,
   *      grouped: false,
   *      format: {
   *          title: function(x) { return "Data " + x; },
   *          name: function(name, ratio, id, index) { return name; },
   *          value: function(value, ratio, id, index) { return ratio; }
   *      },
   *      position: function(data, width, height, element) {
   *          return {top: 0, left: 0}
   *      },
   *
   *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
   *          return ... // formatted html as you want
   *      },
   *
   *       // specify tooltip contents using template
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
   *      		'}}</ul>'
   *      }
   *
   *       // with additional text value
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	text: {
   *      		// a) 'key' name is used as substitution within template as '{=KEY}'
   *      		// b) the length should match with the data length
   *      		VAR1: ["text1", "text2"],
   *      		VAR2: ["comment1", "comment2"],
   *      	},
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
   *      		'}}</ul>'
   *      }
   *
   *      // sort tooltip data value display in ascending order
   *      order: "asc",
   *
   *      // specifying sort function
   *      order: function(a, b) {
   *         // param data passed format
   *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
   *           ...
   *      },
   *
   *      // show at the initialization
   *      init: {
   *          show: true,
   *          x: 2,
   *          position: {
   *              top: "150px",
   *              left: "250px"
   *          }
   *      },
   *
   *      // fires prior tooltip is shown
   *      onshow: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires prior tooltip is hidden
   *      onhide: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is shown
   *      onshown: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is hidden
   *      onhidden: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
   *      // Useful for timeseries correlation
   *      linked: true,
   *
   *      // Specify name to interact those with the same name only.
   *      linked: {
   *          name: "some-group"
   *      }
   *  }
   */
  tooltip_show: !0,
  tooltip_doNotHide: !1,
  tooltip_grouped: !0,
  tooltip_format_title: undefined,
  tooltip_format_name: undefined,
  tooltip_format_value: undefined,
  tooltip_position: undefined,
  tooltip_contents: {},
  tooltip_init_show: !1,
  tooltip_init_x: 0,
  tooltip_init_position: {
    top: "0px",
    left: "50px"
  },
  tooltip_linked: !1,
  tooltip_linked_name: "",
  tooltip_onshow: function tooltip_onshow() {},
  tooltip_onhide: function tooltip_onhide() {},
  tooltip_onshown: function tooltip_onshown() {},
  tooltip_onhidden: function tooltip_onhidden() {},
  tooltip_order: null
});
// CONCATENATED MODULE: ./src/config/Options/data/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Axis based chart data config options
 */
/* harmony default export */ var data_axis = ({
  /**
   * Specify the key of x values in the data.<br><br>
   * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
   * @name data․x
   * @memberof Options
   * @type {string}
   * @default undefined
   * @example
   * data: {
   *   x: "date"
   * }
   */
  data_x: undefined,

  /**
   * Specify the keys of the x values for each data.<br><br>
   * This option can be used if we want to show the data that has different x values.
   * @name data․xs
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   xs: {
   *      data1: "x1",
   *      data2: "x2"
   *   }
   * }
   */
  data_xs: {},

  /**
   * Set a format specifier to parse string specifed as x.
   * @name data․xFormat
   * @memberof Options
   * @type {string}
   * @default %Y-%m-%d
   * @example
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "01012019", "02012019", "03012019"],
   *        ["data1", 30, 200, 100]
   *    ],
   *    // Format specifier to parse as datetime for given 'x' string value
   *    xFormat: "%m%d%Y"
   * },
   * axis: {
   *    x: {
   *        type: "timeseries"
   *    }
   * }
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   */
  data_xFormat: "%Y-%m-%d",

  /**
   * Set localtime format to parse x axis.
   * @name data․xLocaltime
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *   xLocaltime: false
   * }
   */
  data_xLocaltime: !0,

  /**
   * Sort on x axis.
   * @name data․xSort
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *   xSort: false
   * }
   */
  data_xSort: !0,

  /**
   * Set groups for the data for stacking.
   * @name data․groups
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * data: {
   *   groups: [
   *     ["data1", "data2"],
   *     ["data3"]
   *   ]
   * }
   */
  data_groups: [],

  /**
   * Set y axis the data related to. y and y2 can be used.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @name data․axes
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   axes: {
   *     data1: "y",
   *     data2: "y2"
   *   }
   * }
   */
  data_axes: {},

  /**
   * Set labels options
   * @name data․labels
   * @memberof Options
   * @type {object}
   * @property {object} data Data object
   * @property {boolean} [data.labels=false] Show or hide labels on each data points
   * @property {boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
   * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
   * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
   *  - `v` is the value of the data point where the label is shown.
   *  - `id` is the id of the data where the label is shown.
   *  - `i` is the index of the data point where the label is shown.
   *  - `j` is the sub index of the data point where the label is shown.<br><br>
   * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
   * @property {string|object} [data.labels.colors] Set label text colors.
   * @property {object} [data.labels.position] Set each dataset position, relative the original.
   * @property {number} [data.labels.position.x=0] x coordinate position, relative the original.
   * @property {number} [data.labels.position.y=0] y coordinate position, relative the original.
   * @memberof Options
   * @type {object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
   * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
   * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
   * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
   * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
   * @example
   * data: {
   *   labels: true,
   *
   *   // or set specific options
   *   labels: {
   *     format: function(v, id, i, j) { ... },
   *
   *     // it's possible to set for each data
   *     format: {
   *         data1: function(v, id, i, j) { ... },
   *         ...
   *     },
   *
   *     // align text to center of the 'bar' shape (works only for 'bar' type)
   *     centered: true,
   *
   *     // apply for all label texts
   *     colors: "red",
   *
   *     // or set different colors per dataset
   *     // for not specified dataset, will have the default color value
   *     colors: {
   *        data1: "yellow",
   *        data3: "green"
   *     },
   *
   *     // set x, y coordinate position
   *     position: {
   *        x: -10,
   *        y: 10
   *     },
   *
   *     // or set x, y coordinate position by each dataset
   *     position: {
   *        data1: {x: 5, y: 5},
   *        data2: {x: 10, y: -20}
   *     }
   *   }
   * }
   */
  data_labels: {},
  data_labels_colors: undefined,
  data_labels_position: {},

  /**
   * Define regions for each data.<br>
   * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
   * - The object type should be as:
   *   - start {number}: Start data point number. If not set, the start will be the first data point.
   *   - [end] {number}: End data point number. If not set, the end will be the last data point.
   *   - [style.dasharray="2 2"] {object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
   * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
   * @name data․regions
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   regions: {
   *     data1: [{
   *         start: 1,
   *         end: 2,
   *         style: {
   *             dasharray: "5 2"
   *         }
   *     }, {
   *         start: 3
   *     }],
   *     ...
   *   }
   * }
   */
  data_regions: {},

  /**
   * Set the stacking to be normalized
   * - **NOTE:**
   *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
   *   - y Axis will be set in percentage value (0 ~ 100%)
   *   - Must have postive values
   * @name data․stack․normalize
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
   * @example
   * data: {
   *   stack: {
   *      normalize: true
   *   }
   * }
   */
  data_stack_normalize: !1
});
// CONCATENATED MODULE: ./src/config/Options/data/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data.selection config options
 */
/* harmony default export */ var data_selection = ({
  /**
   * Set data selection enabled<br><br>
   * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
   * @name data․selection․enabled
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
   * @example
   * data: {
   *    selection: {
   *       enabled: true
   *    }
   * }
   */
  data_selection_enabled: !1,

  /**
   * Set grouped selection enabled.<br><br>
   * If this option set true, multiple data points that have same x value will be selected by one selection.
   * @name data․selection․grouped
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       grouped: true
   *    }
   * }
   */
  data_selection_grouped: !1,

  /**
   * Set a callback for each data point to determine if it's selectable or not.<br><br>
   * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
   * @name data․selection․isselectable
   * @memberof Options
   * @type {Function}
   * @default function() { return true; }
   * @example
   * data: {
   *    selection: {
   *       isselectable: function(d) { ... }
   *    }
   * }
   */
  data_selection_isselectable: function data_selection_isselectable() {
    return !0;
  },

  /**
   * Set multiple data points selection enabled.<br><br>
   * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
   * @name data․selection․multiple
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *    selection: {
   *       multiple: false
   *    }
   * }
   */
  data_selection_multiple: !0,

  /**
   * Enable to select data points by dragging.
   * If this option set true, data points can be selected by dragging.
   * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
   * @name data․selection․draggable
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       draggable: true
   *   }
   * }
   */
  data_selection_draggable: !1,

  /**
   * Set a callback for on data selection.
   * @name data․onselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onselected: function data_onselected() {},

  /**
   * Set a callback for on data un-selection.
   * @name data․onunselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onunselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onunselected: function data_onunselected() {}
});
// CONCATENATED MODULE: ./src/config/Options/axis/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var axis_x = ({
  /**
   * Set clip-path attribute for x axis element
   * @name axis․x․clipPath
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo]()
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_x_clipPath: !0,

  /**
   * Show or hide x axis.
   * @name axis․x․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     show: false
   *   }
   * }
   */
  axis_x_show: !0,

  /**
   * Set type of x axis.<br><br>
   * **Available Values:**
   * - timeseries
   * - category
   * - indexed
   * @name axis․x․type
   * @memberof Options
   * @type {string}
   * @default indexed
   * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
   * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
   * @example
   * axis: {
   *   x: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_x_type: "indexed",

  /**
   * Set how to treat the timezone of x values.<br>
   * If true, treat x value as localtime. If false, convert to UTC internally.
   * @name axis․x․localtime
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     localtime: false
   *   }
   * }
   */
  axis_x_localtime: !0,

  /**
   * Set category names on category axis.
   * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @name axis․x․categories
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * axis: {
   *   x: {
   *     categories: ["Category 1", "Category 2", ...]
   *   }
   * }
   */
  axis_x_categories: [],

  /**
   * centerize ticks on category axis.
   * @name axis․x․tick․centered
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       centered: true
   *     }
   *   }
   * }
   */
  axis_x_tick_centered: !1,

  /**
   * A function to format tick value. Format string is also available for timeseries data.
   * @name axis․x․tick․format
   * @memberof Options
   * @type {Function|string}
   * @default undefined
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *        // for timeseries, a 'datetime' object is given as parameter
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *
   *       // for category, index(Number) and categoryName(String) are given as parameter
   *       format: function(index, categoryName) {
   *           return categoryName.substr(0, 10);
   *       },
   *
   *        // for timeseries format specifier
   *        format: "%Y-%m-%d %H:%M:%S"
   *     }
   *   }
   * }
   */
  axis_x_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.x.tick.culling.max.
   * @name axis․x․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default
   * - true for indexed axis and timeseries axis
   * - false for category axis
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_x_tick_culling: {},

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․x․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 10
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_culling_max: 10,

  /**
   * The number of x axis ticks to show.<br><br>
   * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
   * @name axis․x․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_x_tick_count: undefined,

  /**
   * Show or hide x axis tick line.
   * @name axis․x․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_x_tick_show: !0,

  /**
   * Show or hide x axis tick text.
   * @name axis․x․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_show: !0,

  /**
   * Set the x Axis tick text's position relatively its original position
   * @name axis․x․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Fit x axis ticks.
   * - **true**: ticks will be positioned nicely to have same intervals.
   * - **false**: ticks will be positioned according to x value of the data points.
   * @name axis․x․tick․fit
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
   * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       fit: false
   *     }
   *   }
   * }
   */
  axis_x_tick_fit: !0,

  /**
   * Set the x values of ticks manually.<br><br>
   * If this option is provided, the position of the ticks will be determined based on those values.<br>
   * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.
   * @name axis․x․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       values: [1, 2, 4, 8, 16, 32, ...],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_values: null,

  /**
   * Rotate x axis tick text if there is not enough space for 'category' and 'timeseries' type axis.
   * - **NOTE:** The conditions where `autorotate` is enabled are:
   *   - axis.x.type='category' or 'timeseries
   *   - axis.x.tick.multiline=false
   *   - axis.x.tick.culling=false
   *   - axis.x.tick.fit=true
   * @name axis․x․tick․autorotate
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickAutorotate)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 15,
   *       autorotate: true,
   *       multiline: false,
   *       culling: false,
   *       fit: true
   *     }
   *   }
   * }
   */
  axis_x_tick_autorotate: !1,

  /**
   * Rotate x axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.
   * - As long as `axis_x_tick_fit` is set to `true` it will calculate an overflow for the y2 axis and add this value to the right padding.
   * @name axis․x․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_x_tick_rotate: 0,

  /**
   * Show x axis outer tick.
   * @name axis․x․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_x_tick_outer: !0,

  /**
   * Set tick text to be multiline
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
   * @name axis․x․tick․multiline
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       multiline: false
   *     }
   *   }
   * }
   * @example
   * // example of line break with '\n'
   * // In this case, 'axis.x.tick.width' is ignored
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "long\ntext", "Another\nLong\nText"],
   *        ...
   *    ],
   * }
   */
  axis_x_tick_multiline: !0,

  /**
   * Set tick width
   * - **NOTE:**
   *  > When x tick text contains `\n`, this option is ignored.
   * @name axis․x․tick․width
   * @memberof Options
   * @type {number}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       width: 50
   *     }
   *   }
   * }
   */
  axis_x_tick_width: null,

  /**
   * Set to display system tooltip(via 'title' attribute) for tick text
   * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
   * @name axis․x․tick․tooltip
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       tooltip: true
   *     }
   *   }
   * }
   */
  axis_x_tick_tooltip: !1,

  /**
   * Set max value of x axis range.
   * @name axis․x․max
   * @memberof Options
   * @property {number} max Set the max value
   * @property {boolean} [max.fit=false] When specified `max.value` is greater than the bound data value, setting `true` will make x axis max to be fitted to the bound data max value.
   * - **NOTE:** If the bound data max value is greater than the `max.value`, the x axis max will be limited as the given `max.value`.
   * @property {number} [max.value] Set the max value
   * @example
   * axis: {
   *   x: {
   *     max: 100,
   *
   *     max: {
   *       // 'fit=true' will make x axis max to be limited as the bound data value max when 'max.value' is greater.
   *       // - when bound data max is '10' and max.value: '100' ==>  x axis max will be '10'
   *       // - when bound data max is '1000' and max.value: '100' ==> x axis max will be '100'
   *       fit: true,
   *       value: 100
   *     }
   *   }
   * }
   */
  axis_x_max: undefined,

  /**
   * Set min value of x axis range.
   * @name axis․x․min
   * @memberof Options
   * @property {number} min Set the min value
   * @property {boolean} [min.fit=false] When specified `min.value` is lower than the bound data value, setting `true` will make x axis min to be fitted to the bound data min value.
   * - **NOTE:** If the bound data min value is lower than the `min.value`, the x axis min will be limited as the given `min.value`.
   * @property {number} [min.value] Set the min value
   * @example
   * axis: {
   *   x: {
   *     min: -100,
   *
   *     min: {
   *       // 'fit=true' will make x axis min to be limited as the bound data value min when 'min.value' is lower.
   *       // - when bound data min is '-10' and min.value: '-100' ==>  x axis min will be '-10'
   *       // - when bound data min is '-1000' and min.value: '-100' ==> x axis min will be '-100'
   *       fit: true,
   *       value: -100
   *     }
   *   }
   * }
   */
  axis_x_min: undefined,

  /**
   * Set padding for x axis.<br><br>
   * If this option is set, the range of x axis will increase/decrease according to the values.
   * If no padding is needed in the rage of x axis, 0 should be set.
   * - **NOTE:**
   *   The padding values aren't based on pixels. It differs according axis types<br>
   *   - **category:** The unit of tick value
   *     ex. the given value `1`, is same as the width of 1 tick width
   *   - **timeseries:** Numeric time value
   *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
   * @name axis․x․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   x: {
   *     padding: {
   *       // when axis type is 'category'
   *       left: 1,  // set left padding width of equivalent value of a tick's width
   *       right: 0.5  // set right padding width as half of equivalent value of tick's width
   *
   *       // when axis type is 'timeseries'
   *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
   *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_x_padding: {},

  /**
   * Set height of x axis.<br><br>
   * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
   * @name axis․x․height
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     height: 20
   *   }
   * }
   */
  axis_x_height: undefined,

  /**
   * Set default extent for subchart and zoom. This can be an array or function that returns an array.
   * @name axis․x․extent
   * @memberof Options
   * @type {Array|Function}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     // extent range as a pixel value
   *     extent: [0, 200],
   *
   *     // when axis is 'timeseries', parsable datetime string
   *     extent: ["2019-03-01", "2019-03-05"],
   *
   *     // return extent value
   *     extent: function(domain, scale) {
   *    	 var extent = domain.map(function(v) {
   *     	    return scale(v);
   *     	 });
   *
   *   	 // it should return a format of array
   *   	 // ex) [0, 584]
   *     	 return extent;
   *     }
   *   }
   * }
   */
  axis_x_extent: undefined,

  /**
   * Set label on x axis.<br><br>
   * You can set x axis label and change its position by this option.
   * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
   * Available position differs according to the axis direction (vertical or horizontal).
   * If string set, the position will be the default.
   *
   *  - **If it's horizontal axis:**
   *    - inner-right [default]
   *    - inner-center
   *    - inner-left
   *    - outer-right
   *    - outer-center
   *    - outer-left
   *  - **If it's vertical axis:**
   *    - inner-top [default]
   *    - inner-middle
   *    - inner-bottom
   *    - outer-top
   *    - outer-middle
   *    - outer-bottom
   * @name axis․x․label
   * @memberof Options
   * @type {string|object}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     label: "Your X Axis"
   *   }
   * }
   *
   * axis: {
   *   x: {
   *     label: {
   *        text: "Your X Axis",
   *        position: "outer-center"
   *     }
   *   }
   * }
   */
  axis_x_label: {},

  /**
   * Set additional axes for x Axis.
   * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․x․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * x: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main x Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_x_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y Axis  config options
 */
/* harmony default export */ var axis_y = ({
  /**
   * Set clip-path attribute for y axis element
   * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.
   * @name axis․y․clipPath
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_y_clipPath: !0,

  /**
   * Show or hide y axis.
   * @name axis․y․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     show: false
   *   }
   * }
   */
  axis_y_show: !0,

  /**
   * Set type of y axis.<br><br>
   * **Available Values:**
   *   - timeseries
   *   - indexed
   * @name axis․y․type
   * @memberof Options
   * @type {string}
   * @default "indexed"
   * @example
   * axis: {
   *   y: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_y_type: undefined,

  /**
   * Set max value of y axis.
   * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․max
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     max: 1000
   *   }
   * }
   */
  axis_y_max: undefined,

  /**
   * Set min value of y axis.
   * - **NOTE:**
   *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․min
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     min: 1000
   *   }
   * }
   */
  axis_y_min: undefined,

  /**
   * Change the direction of y axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y․inverted
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inverted: true
   *   }
   * }
   */
  axis_y_inverted: !1,

  /**
   * Set center value of y axis.
   * @name axis․y․center
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     center: 0
   *   }
   * }
   */
  axis_y_center: undefined,

  /**
   * Show y axis inside of the chart.
   * @name axis․y․inner
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inner: true
   *   }
   * }
   */
  axis_y_inner: !1,

  /**
   * Set label on y axis.<br><br>
   * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y․label
   * @memberof Options
   * @type {string|object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y: {
   *     label: "Your Y Axis"
   *   }
   * }
   *
   * axis: {
   *   y: {
   *     label: {
   *        text: "Your Y Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y_label: {},

  /**
   * Set formatter for y axis tick text.<br><br>
   * This option accepts d3.format object as well as a function you define.
   * @name axis․y․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 5
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_culling_max: 5,

  /**
   * Show y axis outer tick.
   * @name axis․y․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y_tick_outer: !0,

  /**
   * Set y axis tick values manually.
   * @name axis․y․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_values: null,

  /**
   * Rotate y axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y_tick_rotate: 0,

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y_tick_count: undefined,

  /**
   * Show or hide y axis tick line.
   * @name axis․y․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.
   * @name axis․y․tick․stepSize
   * @memberof Options
   * @type {number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y_tick_stepSize: null,

  /**
   * Show or hide y axis tick text.
   * @name axis․y․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_show: !0,

  /**
   * Set the y Axis tick text's position relatively its original position
   * @name axis․y․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․time
   * @memberof Options
   * @private
   * @type {object}
   * @property {object} time time object
   * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       time: {
   *          // ticks at 15-minute intervals
   *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
   *          value: d3.timeMinute.every(15)
   *       }
   *     }
   *   }
   * }
   */
  // @TODO: not fully implemented yet
  axis_y_tick_time_value: undefined,

  /**
   * Set padding for y axis.<br><br>
   * You can set padding for y axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:**
   *   - Given values are translated relative to the y Axis domain value for padding
   *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axis․y․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   y: {
   *     padding: {
   *       top: 0,
   *       bottom: 0
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_y_padding: {},

  /**
   * Set default range of y axis.<br><br>
   * This option set the default value for y axis when there is no data on init.
   * @name axis․y․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y_default: undefined,

  /**
   * Set additional axes for y Axis.
   * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y2.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y2 Axis  config options
 */
/* harmony default export */ var axis_y2 = ({
  /**
   * Show or hide y2 axis.
   * - **NOTE**:
   *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
   *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
   * @name axis․y2․show
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     show: true
   *   }
   * }
   */
  axis_y2_show: !1,

  /**
   * Set max value of y2 axis.
   * @name axis․y2․max
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     max: 1000
   *   }
   * }
   */
  axis_y2_max: undefined,

  /**
   * Set min value of y2 axis.
   * @name axis․y2․min
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     min: -1000
   *   }
   * }
   */
  axis_y2_min: undefined,

  /**
   * Change the direction of y2 axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y2․inverted
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inverted: true
   *   }
   * }
   */
  axis_y2_inverted: !1,

  /**
   * Set center value of y2 axis.
   * @name axis․y2․center
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     center: 0
   *   }
   * }
   */
  axis_y2_center: undefined,

  /**
   * Show y2 axis inside of the chart.
   * @name axis․y2․inner
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inner: true
   *   }
   * }
   */
  axis_y2_inner: !1,

  /**
   * Set label on y2 axis.<br><br>
   * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y2․label
   * @memberof Options
   * @type {string|object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y2: {
   *     label: "Your Y2 Axis"
   *   }
   * }
   *
   * axis: {
   *   y2: {
   *     label: {
   *        text: "Your Y2 Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y2_label: {},

  /**
   * Set formatter for y2 axis tick text.<br><br>
   * This option works in the same way as axis.y.format.
   * @name axis․y2․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       format: d3.format("$,")
   *       //or format: function(d) { return "$" + d; }
   *     }
   *   }
   * }
   */
  axis_y2_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y2․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y2․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 5
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling_max: 5,

  /**
   * Show or hide y2 axis outer tick.
   * @name axis․y2․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_outer: !0,

  /**
   * Set y2 axis tick values manually.
   * @name axis․y2․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_values: null,

  /**
   * Rotate y2 axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y2․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y2_tick_rotate: 0,

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axis․y2․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y2_tick_count: undefined,

  /**
   * Show or hide y2 axis tick line.
   * @name axis․y2․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.
   * @name axis․y2․tick․stepSize
   * @memberof Options
   * @type {number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y2_tick_stepSize: null,

  /**
   * Show or hide y2 axis tick text.
   * @name axis․y2․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_show: !0,

  /**
   * Set the y2 Axis tick text's position relatively its original position
   * @name axis․y2․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set padding for y2 axis.<br><br>
   * You can set padding for y2 axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:**
   *   - Given values are translated relative to the y2 Axis domain value for padding
   *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axis․y2․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   y2: {
   *     padding: {
   *       top: 100,
   *       bottom: 100
   *     }
   *
   *     // or set both values at once.
   *     padding: 10
   * }
   */
  axis_y2_padding: {},

  /**
   * Set default range of y2 axis.<br><br>
   * This option set the default value for y2 axis when there is no data on init.
   * @name axis․y2․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y2_default: undefined,

  /**
   * Set additional axes for y2 Axis.
   * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y2․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y2: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y2 Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y2_axes: []
});
// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(38);

// CONCATENATED MODULE: ./src/module/browser.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @private
 */

/* eslint-disable no-new-func, no-undef */


var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    browser_doc = win && win.document;
/* eslint-enable no-new-func, no-undef */
// CONCATENATED MODULE: ./src/module/util.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */






var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isboolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof v === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return Array.isArray(arr);
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
};

/**
 * Get specified key value from object
 * If default value is given, will return if given key value not found
 * @param {object} options Source object
 * @param {string} key Key value
 * @param {*} defaultValue Default value
 * @returns {*}
 * @private
 */
function getOption(options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
}
/**
 * Check if value exist in the given object
 * @param {object} dict Target object to be checked
 * @param {*} value Value to be checked
 * @returns {boolean}
 * @private
 */


function hasValue(dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
}
/**
 * Call function with arguments
 * @param {Function} fn Function to be called
 * @param {*} args Arguments
 * @returns {boolean} true: fn is function, false: fn is not function
 * @private
 */


function callFn(fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
}
/**
 * Call function after all transitions ends
 * @param {d3.transition} transition Transition
 * @param {Fucntion} cb Callback function
 * @private
 */


function endall(transition, cb) {
  var n = 0;
  transition.each(function () {
    return ++n;
  }).on("end", function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];

    --n || cb.apply.apply(cb, [this].concat(args));
  });
}
/**
 * Replace tag sign to html entity
 * @param {string} str Target string value
 * @returns {string}
 * @private
 */


function sanitise(str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
}
/**
 * Set text value. If there's multiline add nodes.
 * @param {d3Selection} node Text node
 * @param {string} text Text value string
 * @param {Array} dy dy value for multilined text
 * @param {boolean} toMiddle To be alingned vertically middle
 * @private
 */


function setTextValue(node, text, dy, toMiddle) {
  if (dy === void 0 && (dy = [-1, 1]), toMiddle === void 0 && (toMiddle = !1), node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"),
          len = toMiddle ? multiline.length - 1 : 1;
      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", (i === 0 ? dy[0] * len : dy[1]) + "em").text(v);
      });
    }
  }
}
/**
 * Substitution of SVGPathSeg API polyfill
 * @param {SVGGraphicsElement} path Target svg element
 * @returns {Array}
 * @private
 */


function getRectSegList(path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height
  } // seg3
  ];
}
/**
 * Get svg bounding path box dimension
 * @param {SVGGraphicsElement} path Target svg element
 * @returns {object}
 * @private
 */


function getPathBox(path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Return brush selection array
 * @param {object} $el Selection object
 * @returns {d3.brushSelection}
 * @private
 */


function getBrushSelection(_ref) {
  var selection,
      $el = _ref.$el,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = $el.subchart.main || $el.main;
  return event && event.type === "brush" ? selection = event.selection : main && (selection = main.select("." + config_classes.brush).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
}
/**
 * Get boundingClientRect.
 * Cache the evaluated value once it was called.
 * @param {HTMLElement} node Target element
 * @returns {object}
 * @private
 */


var getBoundingRect = function (node) {
  return node.rect || (node.rect = node.getBoundingClientRect());
};
/**
 * Retrun random number
 * @param {boolean} asStr Convert returned value as string
 * @returns {number|string}
 * @private
 */


function getRandom(asStr) {
  asStr === void 0 && (asStr = !0);
  var rand = Math.random();
  return asStr ? rand + "" : rand;
}
/**
 * Check if brush is empty
 * @param {object} ctx Bursh context
 * @returns {boolean}
 * @private
 */


function brushEmpty(ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
}
/**
 * Extend target from source object
 * @param {object} target Target object
 * @param {object} source Source object
 * @returns {object}
 * @private
 */


function extend(target, source) {
  // exclude name with only numbers
  for (var p in target === void 0 && (target = {}), isArray(source) && source.forEach(function (v) {
    return extend(target, v);
  }), source) /^\d+$/.test(p) || (target[p] = source[p]);

  return target;
}
/**
 * Return first letter capitalized
 * @param {string} str Target string
 * @returns {string} capitalized string
 * @private
 */


var capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
};
/**
 * Convert to array
 * @param {object} v Target to be converted
 * @returns {Array}
 * @private
 */


/**
 * Get css rules for specified stylesheets
 * @param {Array} styleSheets The stylesheets to get the rules from
 * @returns {Array}
 * @private
 */
function getCssRules(styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from " + sheet.href + ": " + e.toString());
    }
  }), rules;
}
/**
 * Gets the SVGMatrix of an SVGGElement
 * @param {SVGElement} node Node element
 * @returns {SVGMatrix} matrix
 * @private
 */


var getTranslation = function (node) {
  var transform = node ? node.transform : null,
      baseVal = transform && transform.baseVal;
  return baseVal && baseVal.numberOfItems ? baseVal.getItem(0).matrix : {
    a: 0,
    b: 0,
    c: 0,
    d: 0,
    e: 0,
    f: 0
  };
};
/**
 * Get unique value from array
 * @param {Array} data Source data
 * @returns {Array} Unique array value
 * @private
 */


function getUnique(data) {
  var isDate = data[0] instanceof Date,
      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
  return isDate ? d.map(function (v) {
    return new Date(v);
  }) : d;
}
/**
 * Merge array
 * @param {Array} arr Source array
 * @returns {Array}
 * @private
 */


function mergeArray(arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
}
/**
 * Merge object returning new object
 * @param {object} target Target object
 * @param {object} objectN Source object
 * @returns {object} merged target object
 * @private
 */


function mergeObj(target) {
  for (var _len3 = arguments.length, objectN = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) objectN[_key3 - 1] = arguments[_key3];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}
/**
 * Sort value
 * @param {Array} data value to be sorted
 * @param {boolean} isAsc true: asc, false: desc
 * @returns {number|string|Date} sorted date
 * @private
 */


function util_sortValue(data, isAsc) {
  isAsc === void 0 && (isAsc = !0);
  var fn;
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
}
/**
 * Get min/max value
 * @param {string} type 'min' or 'max'
 * @param {Array} data Array data value
 * @returns {number|Date|undefined}
 * @private
 */


function getMinMax(type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, res) : res[0] instanceof Date && (res = util_sortValue(res, type === "min")[0]) : res = undefined, res;
}
/**
 * Get range
 * @param {number} start Start number
 * @param {number} end End number
 * @param {number} step Step number
 * @returns {Array}
 * @private
 */


var getRange = function (start, end, step) {
  step === void 0 && (step = 1);
  var res = [],
      n = Math.max(0, Math.ceil((end - start) / step)) | 0;

  for (var i = start; i < n; i++) res.push(start + i * step);

  return res;
},
    emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType, params) {
        params === void 0 && (params = getParams()), el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType, params) {
        params === void 0 && (params = getParams());
        var mouseEvent = browser_doc.createEvent("MouseEvent"); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent

        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, win, 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(mergeObj({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
}; // emulate event


/**
 * Process the template  & return bound string
 * @param {string} tpl Template string
 * @param {object} data Data value to be replaced
 * @returns {string}
 * @private
 */
function tplProcess(tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=" + x + "}", "g"), data[x]);

  return res;
}
/**
 * Get parsed date value
 * (It must be called in 'ChartInternal' context)
 * @param {Date|string|number} date Value of date to be parsed
 * @returns {Date}
 * @private
 */


function parseDate(date) {
  var parsedDate;
  if (date instanceof Date) parsedDate = date;else if (isString(date)) {
    var config = this.config,
        format = this.format;
    parsedDate = format.dataTime(config.data_xFormat)(date);
  } else isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date));
  return (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '" + date + "' to Date object"), parsedDate;
}
/**
 * Return if the current doc is visible or not
 * @returns {boolean}
 * @private
 */


function isTabVisible() {
  return !browser_doc.hidden;
}
/**
 * Get the current input type
 * @param {boolean} mouse Config value: interaction.inputType.mouse
 * @param {boolean} touch Config value: interaction.inputType.touch
 * @returns {string} "mouse" | "touch" | null
 * @private
 */


function convertInputType(mouse, touch) {
  var isMobile = !1; // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop

  if (/Mobi/.test(win.navigator.userAgent) && touch) {
    // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
    var hasTouchPoints = win.navigator && "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0,
        hasTouch = "ontouchmove" in win || win.DocumentTouch && browser_doc instanceof win.DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
    // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

    isMobile = hasTouchPoints || hasTouch;
  }

  var hasMouse = !(!mouse || isMobile) && "onmouseover" in win;
  return hasMouse && "mouse" || isMobile && "touch" || null;
}
// CONCATENATED MODULE: ./src/config/Options/axis/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * y Axis  config options
 */

/* harmony default export */ var axis_axis = (mergeObj({
  /**
   * Switch x and y axis position.
   * @name axis․rotated
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   rotated: true
   * }
   */
  axis_rotated: !1
}, axis_x, axis_y, axis_y2));
// CONCATENATED MODULE: ./src/config/Options/common/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * grid config options
 */
/* harmony default export */ var common_grid = ({
  /**
   * Set related options
   * @name grid
   * @memberof Options
   * @type {object}
   * @property {boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
   * @property {object} x Grid x object
   * @property {boolean} [x.show=false] Show grids along x axis.
   * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
   *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
   *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
   * @property {object} y Grid y object
   * @property {boolean} [y.show=false] Show grids along x axis.
   * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
   *  This option accepts array including object that has value, text, position and class.
   * @property {number} [y.ticks=10] Number of y grids to be shown.
   * @property {object} focus Grid focus object
   * @property {boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {boolean} [focus.show=true] Show grid line when focus.
   * @property {boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {object} lines Grid lines object
   * @property {boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
   * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
   * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
   * @example
   * grid: {
   *   x: {
   *     show: true,
   *     lines: [
   *       {value: 2, text: "Label on 2"},
   *       {value: 5, text: "Label on 5", class: "label-5"},
   *       {value: 6, text: "Label on 6", position: "start"}
   *     ]
   *   },
   *   y: {
   *     show: true,
   *     lines: [
   *       {value: 100, text: "Label on 100"},
   *       {value: 200, text: "Label on 200", class: "label-200"},
   *       {value: 300, text: "Label on 300", position: 'middle'}
   *     ],
   *     ticks: 5
   *   },
   *   front: true,
   *   focus: {
   *      show: false,
   *
   *      // Below options are available when 'tooltip.grouped=false' option is set
   *      edge: true,
   *      y: true
   *   },
   *   lines: {
   *      front: false
   *   }
   * }
   */
  grid_x_show: !1,
  grid_x_type: "tick",
  grid_x_lines: [],
  grid_y_show: !1,
  grid_y_lines: [],
  grid_y_ticks: 10,
  grid_focus_edge: !1,
  grid_focus_show: !0,
  grid_focus_y: !1,
  grid_front: !1,
  grid_lines_front: !0
});
// CONCATENATED MODULE: ./src/config/Options/common/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * point config options
 */
/* harmony default export */ var common_point = ({
  /**
   * Set point options
   * @name point
   * @memberof Options
   * @type {object}
   * @property {object} point Point object
   * @property {boolean} [point.show=true] Whether to show each point in line.
   * @property {number|Function} [point.r=2.5] The radius size of each point.
   *  - **NOTE:** Disabled for 'bubble' type
   * @property {boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
   * @property {number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
   *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
   * @property {boolean} [point.focus.only=false] Show point only when is focused.
   * @property {number} [point.sensitivity=10] The senstivity value for interaction boundary.
   * @property {number} [point.select.r=point.r*4] The radius size of each point on selected.
   * @property {string} [point.type="circle"] The type of point to be drawn
   * - **NOTE:**
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
   * - **NOTE:**
   *   - This is an `experimental` feature and can have some unexpected behaviors.
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   *   - svg shape tag interpreted as string<br>
   *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
   * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
   * @see [Demo: point focus only](https://naver.github.io/billboard.js/demo/#Point.FocusOnly)
   * @example
   *  point: {
   *      show: false,
   *      r: 5,
   *
   *      // or customize the radius
   *      r: function(d) {
   *          ...
   *          return r;
   *      },
   *
   *      focus: {
   *          expand: {
   *              enabled: true,
   *              r: 1
   *          },
   *          only: true
   *      },
   *      select: {
   *          r: 3
   *      },
   *
   *      // having lower value, means how closer to be for interaction
   *      sensitivity: 3,
   *
   *      // valid values are "circle" or "rectangle"
   *      type: "rectangle",
   *
   *      // or indicate as pattern
   *      pattern: [
   *        "circle",
   *        "rectangle",
   *        "<polygon points='0 6 4 0 -4 0'></polygon>"
   *     ],
   *  }
   */
  point_show: !0,
  point_r: 2.5,
  point_sensitivity: 10,
  point_focus_expand_enabled: !0,
  point_focus_expand_r: undefined,
  point_focus_only: !1,
  point_pattern: [],
  point_select_r: undefined,
  point_type: "circle"
});
// CONCATENATED MODULE: ./src/config/Options/common/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var common_subchart = ({
  /**
   * Set subchart options
   * @name subchart
   * @memberof Options
   * @type {object}
   * @property {object} subchart Subchart object
   * @property {boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
   * @property {boolean} [subchart.axis.x.show=true] Show or hide x axis.
   * @property {boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
   * @property {boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
   * @property {number} [subchart.size.height] Change the height of the subchart.
   * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
   *  Specified function receives the current zoomed x domain.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
   * @example
   *  subchart: {
   *      axis: {
   *      	x: {
   *      	  show: true,
   *      	    tick: {
   *      	      show: true,
   *      	      text: {
   *      	        show: false
   *      	      }
   *      	    }
   *      	}
   *      },
   *      show: true,
   *      size: {
   *          height: 20
   *      },
   *      onbrush: function(domain) { ... }
   *  }
   */
  subchart_show: !1,
  subchart_size_height: 60,
  subchart_axis_x_show: !0,
  subchart_axis_x_tick_show: !0,
  subchart_axis_x_tick_text_show: !0,
  subchart_onbrush: function subchart_onbrush() {}
});
// CONCATENATED MODULE: ./src/config/Options/common/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * zoom config options
 */
/* harmony default export */ var common_zoom = ({
  /**
   * Set zoom options
   * @name zoom
   * @memberof Options
   * @type {object}
   * @property {object} zoom Zoom object
   * @property {boolean} [zoom.enabled=false] Enable zooming.
   * @property {string} [zoom.enabled.type='wheel'] Set zoom interaction type.
   *  - **Available types:**
   *    - wheel
   *    - drag
   * @property {boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
   *  If true set, y domain will be updated according to the zoomed region.
   * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
   * @property {number|Date} [zoom.x.min] Set x Axis minimum zoom range
   * @property {number|Date} [zoom.x.max] Set x Axis maximum zoom range
   * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
   *  Specified function receives the zoom event.
   * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
   *  Specified function receives the zoomed domain.
   * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
   *  Specified function receives the zoomed domain.
   * @property {boolean|object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
   * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.
   * @property {string} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
   * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
   * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
   * @example
   *  zoom: {
   *      enabled: {
   *          type: "drag"
   *      },
   *      rescale: true,
   *      extent: [1, 100]  // enable more zooming
   *      x: {
   *          min: -1,  // set min range
   *          max: 10  // set max range
   *      },
   *      onzoomstart: function(event) { ... },
   *      onzoom: function(domain) { ... },
   *      onzoomend: function(domain) { ... },
   *
   *      // show reset button when is zoomed-in
   *      resetButton: true,
   *
   *      resetButton: {
   *          // onclick callback when reset button is clicked
   *          onclick: function(button) {
   *            button; // Reset button element reference
   *            ...
   *          },
   *
   *          // customized text value for reset zoom button
   *          text: "Unzoom"
   *      }
   *  }
   */
  zoom_enabled: undefined,
  zoom_extent: undefined,
  zoom_privileged: !1,
  zoom_rescale: !1,
  zoom_onzoom: undefined,
  zoom_onzoomstart: undefined,
  zoom_onzoomend: undefined,
  zoom_resetButton: !0,
  zoom_x_min: undefined,
  zoom_x_max: undefined
});
// CONCATENATED MODULE: ./src/config/Options/shape/area.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * area config options
 */
/* harmony default export */ var shape_area = ({
  /**
   * Set area options
   * @name area
   * @memberof Options
   * @type {object}
   * @property {object} area Area object
   * @property {boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
   * @property {boolean} [area.above=false] Set background area above the data chart line.
   * @property {boolean|object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
   * Or customize by giving below object value:
   *  - x {Array}: `x1`, `x2` value
   *  - y {Array}: `y1`, `y2` value
   *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
   * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
   * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
   * @example
   *  area: {
   *      zerobased: false,
   *      above: true,
   *
   *      // will generate follwing linearGradient:
   *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
   *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
   *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
   *      // </linearGradient>
   *      linearGradient: true,
   *
   *      // Or customized gradient
   *      linearGradient: {
   *      	x: [0, 0],  // x1, x2 attributes
   *      	y: [0, 0],  // y1, y2 attributes
   *      	stops: [
   *      	  // offset, stop-color, stop-opacity
   *      	  [0, "#7cb5ec", 1],
   *
   *      	  // setting 'null' for stop-color, will set its original data color
   *      	  [0.5, null, 0],
   *
   *      	  // setting 'function' for stop-color, will pass data id as argument.
   *      	  // It should return color string or null value
   *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
   *      	]
   *      }
   *  }
   */
  area_zerobased: !0,
  area_above: !1,
  area_linearGradient: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bar config options
 */
/* harmony default export */ var shape_bar = ({
  /**
   * Set bar options
   * @name bar
   * @memberof Options
   * @type {object}
   * @property {object} bar Bar object
   * @property {number} [bar.padding=0] The padding pixel value between each bar.
   * @property {number} [bar.radius] Set the radius of bar edge in pixel.
   * - **NOTE:** Works only for non-stacked bar
   * @property {number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
   * @property {number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
   * @property {number} [bar.width] Change the width of bar chart.
   * @property {number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
   * @property {number} [bar.width.max] The maximum width value for ratio.
   * @property {number} [bar.width.dataname] Change the width of bar for indicated dataset only.
   * - **NOTE:**
   *   - Works only for non-stacked bar
   *   - Bars are centered accoding its total width value
   * @property {number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
   * @property {number} [bar.width.dataname.max] The maximum width value for ratio.
   * @property {boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
   * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
   * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
   * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
   * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
   * @example
   *  bar: {
   *      padding: 1,
   *
   *      // the 'radius' option can be used only for non-stacking bars
   *      radius: 10,
   *      // or
   *      radius: {
   *          ratio: 0.5
   *      }
   *
   *      // will not have offset between each bar elements for interaction
   *      sensitivity: 0,
   *
   *      width: 10,
   *
   *      // or
   *      width: {
   *          ratio: 0.2,
   *          max: 20
   *      },
   *
   *      // or specify width per dataset
   *      width: {
   *          data1: 20,
   *          data2: {
   *              ratio: 0.2,
   *              max: 20
   *          }
   *      },
   *
   *      zerobased: false
   *  }
   */
  bar_padding: 0,
  bar_radius: undefined,
  bar_radius_ratio: undefined,
  bar_sensitivity: 2,
  bar_width: undefined,
  bar_width_ratio: .6,
  bar_width_max: undefined,
  bar_zerobased: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bubble config options
 */
/* harmony default export */ var bubble = ({
  /**
   * Set bubble options
   * @name bubble
   * @memberof Options
   * @type {object}
   * @property {object} bubble bubble object
   * @property {number|Function} [bubble.maxR=35] Set the max bubble radius value
   * @property {boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.
   * @example
   *  bubble: {
   *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
   *      // And the lesser will have radius relatively from tha max value.
   *      maxR: 50,
   *
   *      // or set radius callback
   *      maxR: function(d) {
   *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
   *          ...
   *          return Math.sqrt(d.value * 2);
   *      },
   *      zerobased: false
   *  }
   */
  bubble_maxR: 35,
  bubble_zerobased: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * line config options
 */
/* harmony default export */ var shape_line = ({
  /**
   * Set line options
   * @name line
   * @memberof Options
   * @type {object}
   * @property {object} line Line object
   * @property {boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
   *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
   * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
   * @property {boolean} [line.step.type=step] Change step type for step chart.<br>
   * **Available values:**
   * - step
   * - step-before
   * - step-after
   * @property {boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
   * @property {boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.
   * @example
   *  line: {
   *      connectNull: true,
   *      classes: [
   *          "line-class1",
   *          "line-class2"
   *      ],
   *      step: {
   *          type: "step-after"
   *      },
   *
   *      // hide all data points ('point.show=false' also has similar effect)
   *      point: false,
   *
   *      // show data points for only indicated datas
   *      point: [
   *          "data1", "data3"
   *      ],
   *
   *      zerobased: false
   *  }
   */
  line_connectNull: !1,
  line_step_type: "step",
  line_zerobased: !1,
  line_classes: undefined,
  line_point: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/spline.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var spline = ({
  /**
   * Set spline options
   * - **Available interpolation type values:**
   *  - basis (d3.curveBasis)
   *  - basis-closed (d3.curveBasisClosed)
   *  - basis-open (d3.curveBasisOpen)
   *  - bundle (d3.curveBundle)
   *  - cardinal (d3.curveCardinal)
   *  - cardinal-closed (d3.curveCardinalClosed)
   *  - cardinal-open (d3.curveCardinalOpen)
   *  - catmull-rom (d3.curveCatmullRom)
   *  - catmull-rom-closed (d3.curveCatmullRomClosed)
   *  - catmull-rom-open (d3.curveCatmullRomOpen)
   *  - monotone-x (d3.curveMonotoneX)
   *  - monotone-y (d3.curveMonotoneY)
   *  - natural (d3.curveNatural)
   *  - linear-closed (d3.curveLinearClosed)
   *  - linear (d3.curveLinear)
   *  - step (d3.curveStep)
   *  - step-after (d3.curveStepAfter)
   *  - step-before (d3.curveStepBefore)
   * @name spline
   * @memberof Options
   * @type {object}
   * @property {object} spline Spline object
   * @property {object} spline.interpolation Spline interpolation object
   * @property {string} [spline.interpolation.type="cardinal"] Interpolation type
   * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
   * @example
   *  spline: {
   *      interpolation: {
   *          type: "cardinal"
   *      }
   *  }
   */
  spline_interpolation_type: "cardinal"
});
// CONCATENATED MODULE: ./src/config/Options/shape/donut.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * donut config options
 */
/* harmony default export */ var donut = ({
  /**
   * Set donut options
   * @name donut
   * @memberof Options
   * @type {object}
   * @property {object} donut Donut object
   * @property {boolean} [donut.label.show=true] Show or hide label on each donut piece.
   * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
   * @property {number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
   * @property {boolean} [donut.expand=true] Enable or disable expanding donut pieces.
   * @property {number} [donut.expand.rate=0.98] Set expand rate.
   * @property {number} [donut.expand.duration=50] Set expand transition time in ms.
   * @property {number} [donut.width] Set width of donut chart.
   * @property {string} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
   * @property {number} [donut.padAngle=0] Set padding between data.
   * @property {number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  donut: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *          	...
   *          	return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      width: 10,
   *      padAngle: 0.2,
   *      startingAngle: 1,
   *      title: "Donut Title"
   *
   *      // title with line break
   *      title: "Title1\nTitle2"
   *  }
   */
  donut_label_show: !0,
  donut_label_format: undefined,
  donut_label_threshold: .05,
  donut_label_ratio: undefined,
  donut_width: undefined,
  donut_title: "",
  donut_expand: {},
  donut_expand_rate: .98,
  donut_expand_duration: 50,
  donut_padAngle: 0,
  donut_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/gauge.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * gauge config options
 */
/* harmony default export */ var gauge = ({
  /**
   * Set gauge options
   * @name gauge
   * @memberof Options
   * @type {object}
   * @property {object} gauge Gauge object
   * @property {boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
   * @property {boolean} [gauge.label.show=true] Show or hide label on gauge.
   * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
   * @property {Function} [gauge.label.extents] Set customized min/max label text.
   * @property {boolean} [gauge.expand=true] Enable or disable expanding gauge.
   * @property {number} [gauge.expand.rate=0.98] Set expand rate.
   * @property {number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
   * @property {number} [gauge.min=0] Set min value of the gauge.
   * @property {number} [gauge.max=100] Set max value of the gauge.
   * @property {number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.
   * @property {string} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
   * @property {string} [gauge.units] Set units of the gauge.
   * @property {number} [gauge.width] Set width of gauge chart.
   * @property {string} [gauge.type="single"] Set type of gauge to be displayed.<br><br>
   * **Available Values:**
   * - single
   * - multi
   * @property {string} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.
   * @example
   *  gauge: {
   *      fullCircle: false,
   *      label: {
   *          show: false,
   *          format: function(value, ratio) {
   *              return value;
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          extents: function(value, isMax) {
   *              return (isMax ? "Max:" : "Min:") + value;
   *          }
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      min: -100,
   *      max: 200,
   *      type: "single"  // or 'multi'
   *      title: "Title Text",
   *      units: "%",
   *      width: 10,
   *      arcs: {
   *          minWidth: 5
   *      }
   *  }
   */
  gauge_fullCircle: !1,
  gauge_label_show: !0,
  gauge_label_format: undefined,
  gauge_label_extents: undefined,
  gauge_min: 0,
  gauge_max: 100,
  gauge_type: "single",
  gauge_startingAngle: -1 * Math.PI / 2,
  gauge_title: "",
  gauge_units: undefined,
  gauge_width: undefined,
  gauge_arcs_minWidth: 5,
  gauge_expand: {},
  gauge_expand_rate: .98,
  gauge_expand_duration: 50
});
// CONCATENATED MODULE: ./src/config/Options/shape/pie.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var pie = ({
  /**
   * Set pie options
   * @name pie
   * @memberof Options
   * @type {object}
   * @property {object} pie Pie object
   * @property {boolean} [pie.label.show=true] Show or hide label on each pie piece.
   * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
   * @property {number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
   * @property {boolean|object} [pie.expand=true] Enable or disable expanding pie pieces.
   * @property {number} [pie.expand.rate=0.98] Set expand rate.
   * @property {number} [pie.expand.duration=50] Set expand transition time in ms.
   * @property {number|object} [pie.innerRadius=0] Sets the inner radius of pie arc.
   * @property {number} [pie.padAngle=0] Set padding between data.
   * @property {number} [pie.padding=0] Sets the gap between pie arcs.
   * @property {object} donut Donut object
   * @property {number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  pie: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *              ...
   *              return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      innerRadius: 0,
   *
   *      // set different innerRadius for each data
   *      innerRadius: {
   *      	data1: 10,
   *      	data2: 0
   *      }
   *
   *      padAngle: 0.1,
   *      padding: 0,
   *      startingAngle: 1
   *  }
   */
  pie_label_show: !0,
  pie_label_format: undefined,
  pie_label_threshold: .05,
  pie_label_ratio: undefined,
  pie_expand: {},
  pie_expand_rate: .98,
  pie_expand_duration: 50,
  pie_innerRadius: 0,
  pie_padAngle: 0,
  pie_padding: 0,
  pie_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var shape_radar = ({
  /**
   * Set radar options
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break.
   * @name radar
   * @memberof Options
   * @type {object}
   * @property {object} radar Radar object
   * @property {number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
   * @property {boolean} [radar.axis.line.show=true] Show or hide axis line.
   * @property {number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
   * @property {number} [radar.axis.text.position.y=0] y coordinate position, relative the original.
   * @property {boolean} [radar.axis.text.show=true] Show or hide axis text.
   * @property {boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
   * @property {number} [radar.level.depth=3] Set the level depth.
   * @property {boolean} [radar.level.show=true] Show or hide level.
   * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
   * @property {boolean} [radar.level.text.show=true] Show or hide level text.
   * @property {number} [radar.size.ratio=0.87] Set size ratio.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
   * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
   * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
   * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
   * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
   * @example
   *  radar: {
   *      axis: {
   *          max: 50,
   *          line: {
   *              show: false
   *          },
   *          text: {
   *              position: {
   *              	x: 0,
   *              	y: 0
   *              },
   *              show: false
   *          }
   *      },
   *      direction: {
   *          clockwise: true
   *      },
   *      level: {
   *          show: false,
   *          text: {
   *              format: function(x) {
   *                  return x + "%";
   *              },
   *              show: true
   *          }
   *      },
   *      size: {
   *          ratio: 0.7
   *      }
   *  }
   */
  radar_axis_max: undefined,
  radar_axis_line_show: !0,
  radar_axis_text_show: !0,
  radar_axis_text_position: {},
  radar_level_depth: 3,
  radar_level_show: !0,
  radar_level_text_format: function radar_level_text_format(x) {
    return x % 1 === 0 ? x : x.toFixed(2);
  },
  radar_level_text_show: !0,
  radar_size_ratio: .87,
  radar_direction_clockwise: !1
});
// CONCATENATED MODULE: ./src/config/Options/Options.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
// common





 // Axis based












 // Non-Axis based






/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */

var Options = function () {
  var config = [data_data, common_color, interaction, common_legend, common_title, common_tooltip].concat([donut, gauge, pie, shape_radar], [data_axis, data_selection, axis_axis, common_grid, common_point, common_subchart, common_zoom], [shape_area, shape_bar, bubble, shape_line, spline]);
  return mergeObj.apply(void 0, [{
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {string|HTMLElement|d3.selection|object} [bindto="#chart"] Specify the element where chart will be drawn.
     * @property {string|HTMLElement|d3.selection} bindto.element="#chart" Specify the element where chart will be drawn.
     * @property {string} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set chart background.
     * @name background
     * @memberof Options
     * @property {object} background background object
     * @property {string} background.class Specify the class name for background element.
     * @property {string} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.
     * @property {string} background.imgUrl Specify the image url string for background.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)
     * @example
     * background: {
     *    class: "myClass",
     *    color: "red",
     *
     *    // Set image url for background.
     *    // If specified, 'color' option will be ignored.
     *    imgUrl: "https://naver.github.io/billboard.js/img/logo/billboard.js.svg",
     * }
     */
    background: {},

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {object}
     * @property {object} [svg] svg object
     * @property {string} [svg.classname] class name for svg element
     * @example
     * svg: {
     *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {object}
     * @property {object} [size] size object
     * @property {number} [size.width] width of the chart element
     * @property {number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
     *   width: 640,
     *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {object}
     * @property {object} [padding] padding object
     * @property {number} [padding.top] padding on the top of chart
     * @property {number} [padding.right] padding on the right of chart
     * @property {number} [padding.bottom] padding on the bottom of chart
     * @property {number} [padding.left] padding on the left of chart
     * @example
     * padding: {
     *   top: 20,
     *   right: 20,
     *   bottom: 20,
     *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {object}
     * @property {object} [resize] resize object
     * @property {boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onover: function(ctx) {
     *   ...
     * }
     */
    onover: undefined,

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onout: function(ctx) {
     *   ...
     * }
     */
    onout: undefined,

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresize: function(ctx) {
     *   ...
     * }
     */
    onresize: undefined,

    /**
     * Set a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresized: function(ctx) {
     *   ...
     * }
     */
    onresized: undefined,

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onbeforeinit: function(ctx) {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * oninit: function(ctx) {
     *   ...
     * }
     */
    oninit: undefined,

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onafterinit: function(ctx) {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onrendered: function(ctx) {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {object}
     * @property {object} [transition] transition object
     * @property {number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
     * Set scatter options
     * @name scatter
     * @memberof Options
     * @type {object}
     * @property {object} [scatter] scatter object
     * @property {boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.
     * @example
     *  scatter: {
     *      connectNull: true,
     *      step: {
     *          type: "step-after"
     *      },
     *
     *      // hide all data points ('point.show=false' also has similar effect)
     *      point: false,
     *
     *      // show data points for only indicated datas
     *      point: [
     *          "data1", "data3"
     *      ],
     *
     *      zerobased: false
     *  }
     */
    scatter_zerobased: !1,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Control the render timing
     * @name render
     * @memberof Options
     * @type {object}
     * @property {object} [render] render object
     * @property {boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
     * @property {boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
     * @example
     *  render: {
     *    lazy: true,
     *    observe: true
     * }
     *
     * @example
     *	// <!-- render.lazy will detect visibility defined -->
     *  // (a) <div id='chart' class='hide'></div>
     *  // (b) <div id='chart' style='display:none'></div>
     *
     *  // render.lazy enabled by default when element is hidden
     *  var chart = bb.generate({ ... });
     *
     *  // chart will be rendered automatically when element's visibility changes
     *  // Note: works only for inlined css property or class attribute changes
     *  document.getElementById('chart').classList.remove('hide')  // (a)
     *  document.getElementById('chart').style.display = 'block';  // (b)
     *
     * @example
     *	// chart won't be rendered and not observing bind element's visiblity changes
     *  var chart = bb.generate({
     *     render: {
     *          lazy: true,
     *          observe: false
     *     }
     *  });
     *
     *  // call at any point when you want to render
     *  chart.flush();
     */
    render: {},

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class.
     * The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end.
     * If not specified, the edge values will be used.
     * If timeseries x axis, date string, Date object and unixtime integer can be used.
     * If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: []
  }].concat(config));
};


// CONCATENATED MODULE: ./src/module/Cache.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Constant for cache key
 * - NOTE: Prefixed with '$', will be resetted when .load() is called
 * @private
 */
var KEY = {
  bubbleBaseLength: "$baseLength",
  colorPattern: "__colorPattern__",
  dataMinMax: "$dataMinMax",
  dataTotalSum: "$dataTotalSum",
  dataTotalPerIndex: "$totalPerIndex",
  legendItemTextBox: "legendItemTextBox",
  radarPoints: "$radarPoints",
  setOverOut: "setOverOut",
  callOverOutForTouch: "callOverOutForTouch",
  textRect: "textRect"
};

var Cache_Cache = /*#__PURE__*/function () {
  function Cache() {
    _defineProperty(this, "cache", {});
  }

  var _proto = Cache.prototype;
  return _proto.add =
  /**
   * Add cache
   * @param {string} key Cache key
   * @param {*} value Value to be stored
   * @param {boolean} isDataType Weather the cache is data typed '{id:'data', id_org: 'data', values: [{x:0, index:0,...}, ...]}'
   * @returns {*} Added data value
   * @private
   */
  function add(key, value, isDataType) {
    return isDataType === void 0 && (isDataType = !1), this.cache[key] = isDataType ? this.cloneTarget(value) : value, this.cache[key];
  }
  /**
   * Remove cache
   * @param {string|Array} key Cache key
   * @private
   */
  , _proto.remove = function remove(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  }
  /**
   * Get cahce
   * @param {string|Array} key Cache key
   * @param {boolean} isDataType Weather the cache is data typed '{id:'data', id_org: 'data', values: [{x:0, index:0,...}, ...]}'
   * @returns {*}
   * @private
   */
  , _proto.get = function get(key, isDataType) {
    if (isDataType === void 0 && (isDataType = !1), isDataType) {
      for (var id, targets = [], i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    var value = this.cache[key];
    return isValue(value) ? value : null;
  }
  /**
   * Reset cached data
   * @param {boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
   */
  , _proto.reset = function reset(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }
  /**
   * Clone data target object
   * @param {object} target Data object
   * @returns {object}
   * @private
   */
  // eslint-disable-next-line camelcase
  , _proto.cloneTarget = function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  }, Cache;
}();


// CONCATENATED MODULE: ./src/module/generator.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


var generator_setTimeout = win.setTimeout,
    generator_clearTimeout = win.clearTimeout;
/**
 * Generate resize queue function
 * @returns {Fucntion}
 * @private
 */

function generateResize() {
  var timeout,
      fn = [],
      callResizeFn = function () {
    callResizeFn.clear(), timeout = generator_setTimeout(function () {
      fn.forEach(function (f) {
        return f();
      });
    }, 200);
  };

  return callResizeFn.clear = function () {
    timeout && (generator_clearTimeout(timeout), timeout = null);
  }, callResizeFn.add = function (f) {
    return fn.push(f);
  }, callResizeFn.remove = function (f) {
    return fn.splice(fn.indexOf(f), 1);
  }, callResizeFn;
}
/**
 * Generate transition queue function
 * @returns {Function}
 * @private
 */

function generateWait() {
  var transitionsToWait = [],
      f = function (t, callback) {
    // eslint-disable-next-line
    function loop() {
      for (var _t, done = 0, i = 0; _t = transitionsToWait[i]; i++) {
        if (_t === !0 || _t.empty && _t.empty()) {
          done++;
          continue;
        }

        try {
          _t.transition();
        } catch (e) {
          done++;
        }
      }

      timer && generator_clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = generator_setTimeout(loop, 50);
    }

    var timer;
    loop();
  };

  return f.add = function (t) {
    isArray(t) ? transitionsToWait = transitionsToWait.concat(t) : transitionsToWait.push(t);
  }, f;
}
// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(39);

// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(40);

// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRendererHelper.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper = /*#__PURE__*/function () {
  function AxisRendererHelper(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "scale", void 0);
    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])(),
        config = owner.config,
        params = owner.params;
    this.owner = owner, this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node <g class=tick> node
   * @returns {{w: number, h: number}}
   * @private
   */


  AxisRendererHelper.getSizeFor1Char = function getSizeFor1Char(node) {
    // default size for one character
    var size = {
      w: 5.5,
      h: 11.5
    };
    return node.empty() || node.select("text").text("0").call(function (el) {
      try {
        var _el$node$getBBox = el.node().getBBox(),
            width = _el$node$getBBox.width,
            height = _el$node$getBBox.height;

        width && height && (size.w = width, size.h = height);
      } catch (e) {} finally {
        el.text("");
      }
    }), this.getSizeFor1Char = function () {
      return size;
    }, size;
  }
  /**
   * Get tick transform setter function
   * @param {string} id Axis id
   * @returns {Function} transfrom setter function
   * @private
   */
  ;

  var _proto = AxisRendererHelper.prototype;
  return _proto.getTickTransformSetter = function getTickTransformSetter(id) {
    var config = this.config,
        fn = id === "x" ? function (value) {
      return "translate(" + (value + config.tickOffset) + ",0)";
    } : function (value) {
      return "translate(0," + value + ")";
    };
    return function (selection, scale) {
      selection.attr("transform", function (d) {
        return fn(Math.ceil(scale(d)));
      });
    };
  }, _proto.scaleExtent = function scaleExtent(domain) {
    var start = domain[0],
        stop = domain[domain.length - 1];
    return start < stop ? [start, stop] : [stop, start];
  }, _proto.generateTicks = function generateTicks(scale, isYAxes) {
    var tickStepSize = this.owner.params.tickStepSize,
        ticks = [];
    // When 'axis[y|y2].tick.stepSize' option is set
    if (isYAxes && tickStepSize) for (var _scale$domain = scale.domain(), start = _scale$domain[0], end = _scale$domain[1], interval = start; interval <= end;) ticks.push(interval), interval += tickStepSize;else if (scale.ticks) ticks = scale.ticks.apply(scale, this.config.tickArguments || []).map(function (v) {
      return (// round the tick value if is number
        isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
      );
    });else {
      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
    }
    return ticks;
  }, _proto.copyScale = function copyScale() {
    var newScale = this.scale.copy();
    return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
  }, _proto.textFormatted = function textFormatted(v) {
    var tickFormat = this.config.tickFormat,
        value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
        formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
    // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
    // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

    return isDefined(formatted) ? formatted : "";
  }, _proto.transitionise = function transitionise(selection) {
    var config = this.config;
    return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
  }, AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRenderer.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer = /*#__PURE__*/function () {
  function AxisRenderer(params) {
    params === void 0 && (params = {}), _defineProperty(this, "helper", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "params", void 0), _defineProperty(this, "g", void 0);
    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.config = config, this.params = params, this.helper = new AxisRendererHelper_AxisRendererHelper(this);
  }
  /**
   * Create axis element
   * @param {d3.selection} g Axis selection
   * @private
   */


  var _proto = AxisRenderer.prototype;
  return _proto.create = function create(g) {
    var ctx = this,
        config = this.config,
        helper = this.helper,
        params = this.params,
        scale = helper.scale,
        orient = config.orient,
        splitTickText = this.splitTickText.bind(this),
        isLeftRight = /^(left|right)$/.test(orient),
        isTopBottom = /^(top|bottom)$/.test(orient),
        tickTransform = helper.getTickTransformSetter(isTopBottom ? "x" : "y"),
        axisPx = tickTransform === helper.axisX ? "y" : "x",
        sign = /^(top|left)$/.test(orient) ? -1 : 1,
        rotate = params.tickTextRotate;
    this.config.range = scale.rangeExtent ? scale.rangeExtent() : helper.scaleExtent((params.orgXScale || scale).range());
    var $g,
        _config2 = config,
        innerTickSize = _config2.innerTickSize,
        tickLength = _config2.tickLength,
        range = _config2.range,
        id = params.id,
        tickTextPos = id && /^(x|y|y2)$/.test(id) ? params.config["axis_" + id + "_tick_text_position"] : {
      x: 0,
      y: 0
    },
        prefix = id === "subX" ? "subchart_axis_x" : "axis_" + id,
        axisShow = params.config[prefix + "_show"],
        tickShow = {
      tick: !!axisShow && params.config[prefix + "_tick_show"],
      text: !!axisShow && params.config[prefix + "_tick_text_show"]
    }; // // get the axis' tick position configuration

    g.each(function () {
      var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          scale0 = this.__chart__ || scale,
          scale1 = helper.copyScale();
      $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
      // update selection - data join
      var path = g.selectAll(".domain").data([0]); // enter + update selection

      if (path.enter().append("path").attr("class", "domain").merge(helper.transitionise(path)).attr("d", function () {
        var outerTickSized = config.outerTickSize * sign;
        return isTopBottom ? "M" + range[0] + "," + outerTickSized + "V0H" + range[1] + "V" + outerTickSized : "M" + outerTickSized + "," + range[0] + "H0V" + range[1] + "H" + outerTickSized;
      }), tickShow.tick || tickShow.text) {
        // count of tick data in array
        var ticks = config.tickValues || helper.generateTicks(scale1, isLeftRight),
            tick = g.selectAll(".tick").data(ticks, scale1),
            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
            tickExit = tick.exit().remove(); // update selection

        tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
        var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
            counts = [],
            tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
          var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helper.textFormatted(d)) ? helper.textFormatted(d).concat() : [helper.textFormatted(d)];
          return counts[index] = split.length, split.map(function (splitted) {
            return {
              index: index,
              splitted: splitted
            };
          });
        });
        tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
          return d.splitted;
        }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
          var dx = 0;
          return /(top|bottom)/.test(orient) && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180)) * (orient === "top" ? -1 : 1)), dx + (tickTextPos.x || 0);
        }()).attr("dy", function (d, i) {
          var dy = 0;
          return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
        });
        var lineUpdate = tick.select("line"),
            textUpdate = tick.select("text");

        // Append <title> for tooltip display
        if (tickEnter.select("line").attr(axisPx + "2", innerTickSize * sign), tickEnter.select("text").attr(axisPx, tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle) {
          var title = textUpdate.select("title");
          (title.empty() ? textUpdate.append("title") : title).text(function (index) {
            return params.tickTitle[index];
          });
        }

        if (scale1.bandwidth) {
          var x = scale1,
              dx = x.bandwidth() / 2;
          scale0 = function (d) {
            return x(d) + dx;
          }, scale1 = scale0;
        } else scale0.bandwidth ? scale0 = scale1 : tickTransform(tickExit, scale1);

        tickTransform(tickEnter, scale0), tickTransform(helper.transitionise(tick).style("opacity", "1"), scale1);
      }
    }), this.g = $g;
  }
  /**
   * Get tick x/y coordinate
   * @returns {{x: number, y: number}}
   * @private
   */
  , _proto.getTickXY = function getTickXY() {
    var config = this.config,
        pos = {
      x: 0,
      y: 0
    };
    return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
  }
  /**
   * Get tick size
   * @param {object} d data object
   * @returns {number}
   * @private
   */
  , _proto.getTickSize = function getTickSize(d) {
    var scale = this.helper.scale,
        config = this.config,
        _config3 = config,
        innerTickSize = _config3.innerTickSize,
        range = _config3.range,
        tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
    return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
  }
  /**
   * Set tick's line & text position
   * @param {d3.selection} lineUpdate Line selection
   * @param {d3.selection} textUpdate Text selection
   * @private
   */
  , _proto.setTickLineTextPosition = function setTickLineTextPosition(lineUpdate, textUpdate) {
    var tickPos = this.getTickXY(),
        _this$config = this.config,
        innerTickSize = _this$config.innerTickSize,
        orient = _this$config.orient,
        tickLength = _this$config.tickLength,
        tickOffset = _this$config.tickOffset,
        rotate = this.params.tickTextRotate,
        textAnchorForText = function (r) {
      var value = ["start", "end"];
      return orient === "top" && value.reverse(), r ? r > 0 ? value[0] : value[1] : "middle";
    },
        textTransform = function (r) {
      return r ? "rotate(" + r + ")" : null;
    },
        yForText = function (r) {
      var r2 = r / (orient === "bottom" ? 15 : 23);
      return r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;
    };

    orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -yForText(rotate) * 2).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
  } // this should be called only when category axis
  , _proto.splitTickText = function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
    // split given text by tick width size
    // eslint-disable-next-line
    function split(splitted, text) {
      for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
      if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

      return splitted.concat(text);
    }

    var params = this.params,
        tickText = this.helper.textFormatted(d),
        splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
    if (splitted.length) return splitted;
    if (isArray(tickText)) return tickText;
    var tickWidth = params.tickWidth;
    return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
  }, _proto.scale = function scale(x) {
    return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
  }, _proto.orient = function orient(x) {
    return arguments.length ? (this.config.orient = x in {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    } ? x + "" : "bottom", this) : this.config.orient;
  }, _proto.tickFormat = function tickFormat(format) {
    var config = this.config;
    return arguments.length ? (config.tickFormat = format, this) : config.tickFormat;
  }, _proto.tickCentered = function tickCentered(isCentered) {
    var config = this.config;
    return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
  }
  /**
   * Return tick's offset value.
   * The value will be set for 'category' axis type.
   * @returns {number}
   * @private
   */
  , _proto.tickOffset = function tickOffset() {
    return this.config.tickOffset;
  }
  /**
   * Get tick interval count
   * @private
   * @param {number} size Total data size
   * @returns {number}
   */
  , _proto.tickInterval = function tickInterval(size) {
    var interval;
    if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
      var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
      interval = length / (size || this.g.selectAll("line").size());
    }
    return interval === Infinity ? 0 : interval;
  }, _proto.ticks = function ticks() {
    for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
  }, _proto.tickCulling = function tickCulling(culling) {
    var config = this.config;
    return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
  }, _proto.tickValues = function tickValues(x) {
    var _this = this,
        config = this.config;

    if (isFunction(x)) config.tickValues = function () {
      return x(_this.helper.scale.domain());
    };else {
      if (!arguments.length) return config.tickValues;
      config.tickValues = x;
    }
    return this;
  }, _proto.setTransition = function setTransition(t) {
    return this.config.transition = t, this;
  }, AxisRenderer;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/Axis.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






var Axis_Axis = /*#__PURE__*/function () {
  function Axis(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "x", void 0), _defineProperty(this, "subX", void 0), _defineProperty(this, "y", void 0), _defineProperty(this, "y2", void 0), _defineProperty(this, "axesList", {}), _defineProperty(this, "tick", {
      x: null,
      y: null,
      y2: null
    }), _defineProperty(this, "xs", []), _defineProperty(this, "orient", {
      x: "bottom",
      y: "left",
      y2: "right",
      subX: "bottom"
    }), this.owner = owner, this.setOrient();
  }

  var _proto = Axis.prototype;
  return _proto.getAxisClassName = function getAxisClassName(id) {
    return config_classes.axis + " " + config_classes["axis" + capitalize(id)];
  }, _proto.isHorizontal = function isHorizontal($$, forHorizontal) {
    var isRotated = $$.config.axis_rotated;
    return forHorizontal ? isRotated : !isRotated;
  }, _proto.isCategorized = function isCategorized() {
    var _this$owner = this.owner,
        config = _this$owner.config,
        state = _this$owner.state;
    return config.axis_x_type.indexOf("category") >= 0 || state.hasRadar;
  }, _proto.isCustomX = function isCustomX() {
    var config = this.owner.config;
    return !this.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
  }, _proto.isTimeSeries = function isTimeSeries(id) {
    id === void 0 && (id = "x");
    var config = this.owner.config;
    return config["axis_" + id + "_type"] === "timeseries";
  }, _proto.isTimeSeriesY = function isTimeSeriesY() {
    return this.isTimeSeries("y");
  }, _proto.init = function init() {
    var _this = this,
        $$ = this.owner,
        config = $$.config,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        axis = _$$$$el.axis,
        clip = $$.state.clip,
        isRotated = config.axis_rotated,
        target = ["x", "y"];

    config.axis_y2_show && target.push("y2"), target.forEach(function (v) {
      var classAxis = _this.getAxisClassName(v),
          classLabel = config_classes["axis" + v.toUpperCase() + "Label"];

      axis[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
        var res = null;
        return v === "x" ? res = clip.pathXAxis : v === "y" && config.axis_y_inner && (res = clip.pathYAxis), res;
      }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_" + v + "_show"] ? "visible" : "hidden"), axis[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", function () {
        return _this.textAnchorForAxisLabel(v);
      }), _this.generateAxes(v);
    });
  }
  /**
   * Set axis orient according option value
   * @private
   */
  , _proto.setOrient = function setOrient() {
    var $$ = this.owner,
        _$$$config = $$.config,
        isRotated = _$$$config.axis_rotated,
        yInner = _$$$config.axis_y_inner,
        y2Inner = _$$$config.axis_y2_inner;
    this.orient = {
      x: isRotated ? "left" : "bottom",
      y: isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left",
      y2: isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right",
      subX: isRotated ? "left" : "bottom"
    };
  }
  /**
   * Generate axes
   * It's used when axis' axes option is set
   * @param {string} id Axis id
   * @private
   */
  , _proto.generateAxes = function generateAxes(id) {
    var d3Axis,
        $$ = this.owner,
        config = $$.config,
        axes = [],
        axesConfig = config["axis_" + id + "_axes"],
        isRotated = config.axis_rotated;
    id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
      var tick = v.tick || {},
          scale = $$.scale[id].copy();
      v.domain && scale.domain(v.domain), axes.push(d3Axis(scale).ticks(tick.count).tickFormat(isFunction(tick.format) ? tick.format.bind($$.api) : function (x) {
        return x;
      }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
    }), this.axesList[id] = axes;
  }
  /**
   * Update axes nodes
   * @private
   */
  , _proto.updateAxes = function updateAxes() {
    var _this2 = this,
        $$ = this.owner,
        config = $$.config,
        main = $$.$el.main;

    Object.keys(this.axesList).forEach(function (id) {
      var axesConfig = config["axis_" + id + "_axes"],
          scale = $$.scale[id].copy(),
          range = scale.range();

      _this2.axesList[id].forEach(function (v, i) {
        var axisRange = v.scale().range(); // adjust range value with the current
        // https://github.com/naver/billboard.js/issues/859

        range.every(function (v, i) {
          return v === axisRange[i];
        }) || v.scale().range(range);
        var className = _this2.getAxisClassName(id) + "-" + (i + 1),
            g = main.select("." + className.replace(/\s/, "."));
        g.empty() ? g = main.append("g").attr("class", className).style("visibility", config["axis_" + id + "_show"] ? "visible" : "hidden").call(v) : (axesConfig[i].domain && scale.domain(axesConfig[i].domain), _this2.x.helper.transitionise(g).call(v.scale(scale))), g.attr("transform", $$.getTranslate(id, i + 1));
      });
    });
  }
  /**
   * Set Axis & tick values
   * called from: updateScales()
   * @param {string} id Axis id string
   * @param {Array} args Arguments
   * @private
   */
  , _proto.setAxis = function setAxis(id) {
    id !== "subX" && (this.tick[id] = this.getTickValues(id));

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

    this[id] = this.getAxis.apply(this, [id].concat(args));
  } // called from : getMaxTickWidth()
  , _proto.getAxis = function getAxis(id, scale, outerTick, noTransition, noTickTextRotate) {
    var tickFormat,
        $$ = this.owner,
        config = $$.config,
        isX = /^(x|subX)$/.test(id),
        type = isX ? "x" : id,
        isCategory = isX && this.isCategorized(),
        orient = this.orient[id],
        tickTextRotate = noTickTextRotate ? 0 : $$.getAxisTickRotate(type);
    if (isX) tickFormat = $$.format.xAxisTick;else {
      var fn = config["axis_" + id + "_tick_format"];
      isFunction(fn) && (tickFormat = fn.bind($$.api));
    }
    var tickValues = this.tick[type],
        axisParams = mergeObj({
      outerTick: outerTick,
      noTransition: noTransition,
      config: config,
      id: id,
      tickTextRotate: tickTextRotate
    }, isX && {
      isCategory: isCategory,
      tickMultiline: config.axis_x_tick_multiline,
      tickWidth: config.axis_x_tick_width,
      tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
      orgXScale: $$.scale.x
    });
    isX || (axisParams.tickStepSize = config["axis_" + type + "_tick_stepSize"]);
    var axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.scale.zoom || scale).orient(orient);

    if (isX && this.isTimeSeries() && tickValues && !isFunction(tickValues)) {
      var _fn = parseDate.bind($$);

      tickValues = tickValues.map(function (v) {
        return _fn(v);
      });
    } else !isX && this.isTimeSeriesY() && ( // https://github.com/d3/d3/blob/master/CHANGES.md#time-intervals-d3-time
    axis.ticks(config.axis_y_tick_time_value), tickValues = null);

    tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
      return x + "%";
    }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1));
    var tickCount = config["axis_" + type + "_tick_count"];
    return tickCount && axis.ticks(tickCount), axis;
  }, _proto.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
    var values,
        $$ = this.owner,
        config = $$.config,
        fit = config.axis_x_tick_fit,
        count = config.axis_x_tick_count;
    return (fit || count && fit) && (values = $$.mapTargetsToUniqueXs(targets), this.isCategorized() && count > values.length && (count = values.length), values = this.generateTickValues(values, count, this.isTimeSeries())), axis ? axis.tickValues(values) : this.x && (this.x.tickValues(values), this.subX && this.subX.tickValues(values)), values;
  }, _proto.getId = function getId(id) {
    var _this$owner2 = this.owner,
        config = _this$owner2.config,
        scale = _this$owner2.scale,
        axis = config.data_axes[id];
    return axis && scale[axis] || (axis = "y"), axis;
  }, _proto.getXAxisTickFormat = function getXAxisTickFormat() {
    var currFormat,
        $$ = this.owner,
        config = $$.config,
        format = $$.format,
        tickFormat = config.axis_x_tick_format,
        isTimeSeries = this.isTimeSeries(),
        isCategorized = this.isCategorized();
    return tickFormat ? isFunction(tickFormat) ? currFormat = tickFormat.bind($$.api) : isTimeSeries && (currFormat = function (date) {
      return date ? format.axisTime(tickFormat)(date) : "";
    }) : currFormat = isTimeSeries ? format.defaultAxisTime : isCategorized ? $$.categoryName : function (v) {
      return v < 0 ? v.toFixed(0) : v;
    }, isFunction(currFormat) ? function (v) {
      return currFormat.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
    } : currFormat;
  }, _proto.getTickValues = function getTickValues(id) {
    var $$ = this.owner,
        tickValues = $$.config["axis_" + id + "_tick_values"],
        axis = $$[id + "Axis"];
    return (isFunction(tickValues) ? tickValues.call($$.api) : tickValues) || (axis ? axis.tickValues() : undefined);
  }, _proto.getLabelOptionByAxisId = function getLabelOptionByAxisId(id) {
    return this.owner.config["axis_" + id + "_label"];
  }, _proto.getLabelText = function getLabelText(id) {
    var option = this.getLabelOptionByAxisId(id);
    return isString(option) ? option : option ? option.text : null;
  }, _proto.setLabelText = function setLabelText(id, text) {
    var $$ = this.owner,
        config = $$.config,
        option = this.getLabelOptionByAxisId(id);
    isString(option) ? config["axis_" + id + "_label"] = text : option && (option.text = text);
  }, _proto.getLabelPosition = function getLabelPosition(id, defaultPosition) {
    var isRotated = this.owner.config.axis_rotated,
        option = this.getLabelOptionByAxisId(id),
        position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
        has = function (v) {
      return !!~position.indexOf(v);
    };

    return {
      isInner: has("inner"),
      isOuter: has("outer"),
      isLeft: has("left"),
      isCenter: has("center"),
      isRight: has("right"),
      isTop: has("top"),
      isMiddle: has("middle"),
      isBottom: has("bottom")
    };
  }, _proto.getAxisLabelPosition = function getAxisLabelPosition(id) {
    return this.getLabelPosition(id, id === "x" ? ["inner-top", "inner-right"] : ["inner-right", "inner-top"]);
  }, _proto.getLabelPositionById = function getLabelPositionById(id) {
    return this.getAxisLabelPosition(id);
  }, _proto.xForAxisLabel = function xForAxisLabel(id) {
    var $$ = this.owner,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        position = this.getAxisLabelPosition(id),
        x = position.isMiddle ? -height / 2 : 0;
    return this.isHorizontal($$, id !== "x") ? x = position.isLeft ? 0 : position.isCenter ? width / 2 : width : position.isBottom && (x = -height), x;
  }, _proto.dxForAxisLabel = function dxForAxisLabel(id) {
    var $$ = this.owner,
        position = this.getAxisLabelPosition(id),
        dx = position.isBottom ? "0.5em" : "0";
    return this.isHorizontal($$, id !== "x") ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
  }, _proto.textAnchorForAxisLabel = function textAnchorForAxisLabel(id) {
    var $$ = this.owner,
        position = this.getAxisLabelPosition(id),
        anchor = position.isMiddle ? "middle" : "end";
    return this.isHorizontal($$, id !== "x") ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
  }, _proto.dyForAxisLabel = function dyForAxisLabel(id) {
    var dy,
        $$ = this.owner,
        config = $$.config,
        isRotated = config.axis_rotated,
        isInner = this.getAxisLabelPosition(id).isInner,
        tickRotate = config["axis_" + id + "_tick_rotate"] ? $$.getHorizontalAxisHeight(id) : 0,
        maxTickWidth = this.getMaxTickWidth(id);

    if (id === "x") {
      var xHeight = config.axis_x_height;
      dy = isRotated ? isInner ? "1.2em" : -25 - maxTickWidth : isInner ? "-0.5em" : xHeight ? xHeight - 10 : tickRotate ? tickRotate - 10 : "3em";
    } else dy = {
      y: ["-0.5em", 10, "3em", "1.2em", 10],
      y2: ["1.2em", -20, "-2.2em", "-0.5em", 15]
    }[id], dy = isRotated ? isInner ? dy[0] : tickRotate ? tickRotate * (id === "y2" ? -1 : 1) - dy[1] : dy[2] : isInner ? dy[3] : (dy[4] + (config["axis_" + id + "_inner"] ? 0 : maxTickWidth + dy[4])) * (id === "y" ? -1 : 1);

    return dy;
  }, _proto.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
    var $$ = this.owner,
        config = $$.config,
        current = $$.state.current,
        _$$$$el2 = $$.$el,
        svg = _$$$$el2.svg,
        chart = _$$$$el2.chart,
        currentTickMax = current.maxTickWidths[id],
        maxWidth = 0;
    if (withoutRecompute || !config["axis_" + id + "_show"] || $$.filterTargetsToShow().length === 0) return currentTickMax.size;

    if (svg) {
      var isYAxis = /^y2?$/.test(id),
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          scale = $$.scale[id].copy().domain($$["get" + (isYAxis ? "Y" : "X") + "Domain"](targetsToShow, id)),
          domain = scale.domain();
      // do not compute if domain is same
      if (domain[0] === domain[1] || isArray(currentTickMax.domain) && currentTickMax.domain[0] === currentTickMax.domain[1]) return currentTickMax.size;
      currentTickMax.domain = domain;
      var axis = this.getAxis(id, scale, !1, !1, !0),
          tickCount = config["axis_" + id + "_tick_count"],
          tickValues = config["axis_" + id + "_tick_values"];
      !tickValues && tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? this.isTimeSeriesY() : this.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
      var dummy = chart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
      axis.create(dummy), dummy.selectAll("text").each(function (d, i) {
        var currentTextWidth = this.getBoundingClientRect().width;
        maxWidth = Math.max(maxWidth, currentTextWidth), id === "x" && (currentTickMax.ticks[i] = currentTextWidth);
      }), dummy.remove();
    }

    return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
  }, _proto.getXAxisTickTextY2Overflow = function getXAxisTickTextY2Overflow(defaultPadding) {
    var $$ = this.owner,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        xAxisTickRotate = $$.getAxisTickRotate("x");

    if ((axis.isCategorized() || axis.isTimeSeries()) && config.axis_x_tick_fit && !config.axis_x_tick_culling && !config.axis_x_tick_multiline && xAxisTickRotate > 0 && xAxisTickRotate < 90) {
      var widthWithoutCurrentPaddingLeft = state.current.width - $$.getCurrentPaddingLeft(),
          maxOverflow = this.getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft - defaultPadding),
          xAxisTickTextY2Overflow = Math.max(0, maxOverflow) + defaultPadding;
      // for display inconsistencies between browsers
      return Math.min(xAxisTickTextY2Overflow, widthWithoutCurrentPaddingLeft / 2);
    }

    return 0;
  }, _proto.getXAxisTickMaxOverflow = function getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft) {
    for (var $$ = this.owner, axis = $$.axis, config = $$.config, state = $$.state, isTimeSeries = axis.isTimeSeries(), tickTextWidths = state.current.maxTickWidths.x.ticks, tickCount = tickTextWidths.length, _state$axis$x$padding = state.axis.x.padding, left = _state$axis$x$padding.left, right = _state$axis$x$padding.right, maxOverflow = 0, remaining = tickCount - (isTimeSeries && config.axis_x_tick_fit ? .5 : 0), i = 0; i < tickCount; i++) {
      var tickIndex = i + 1,
          rotatedTickTextWidth = Math.cos(Math.PI * xAxisTickRotate / 180) * tickTextWidths[i],
          ticksBeforeTickText = tickIndex - (isTimeSeries ? 1 : .5) + left;

      // Skip ticks if there are no ticks before them
      if (!(ticksBeforeTickText <= 0)) {
        var tickLength = (widthWithoutCurrentPaddingLeft - rotatedTickTextWidth) / ticksBeforeTickText;
        maxOverflow = Math.max(maxOverflow, rotatedTickTextWidth - tickLength / 2 - ((remaining - tickIndex) * tickLength + right * tickLength));
      }
    }

    var tickOffset = 0;

    if (!isTimeSeries) {
      var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])().domain([left * -1, $$.getXDomainMax($$.data.targets) + 1 + right]).range([0, widthWithoutCurrentPaddingLeft - maxOverflow]);
      tickOffset = Math.ceil((scale(1) - scale(0)) / 2);
    }

    return maxOverflow + tickOffset;
  }
  /**
   * Get x Axis padding
   * @param {number} tickCount Tick count
   * @returns {object} Padding object values with 'left' & 'right' key
   * @private
   */
  , _proto.getXAxisPadding = function getXAxisPadding(tickCount) {
    var $$ = this.owner,
        padding = $$.config.axis_x_padding;

    if (isEmpty(padding) ? padding = {
      left: 0,
      right: 0
    } : (padding.left = padding.left || 0, padding.right = padding.right || 0), $$.axis.isTimeSeries()) {
      var firstX = +$$.getXDomainMin($$.data.targets),
          lastX = +$$.getXDomainMax($$.data.targets),
          timeDiff = lastX - firstX,
          range = timeDiff + padding.left + padding.right,
          relativeTickWidth = timeDiff / tickCount / range,
          left = padding.left / range / relativeTickWidth || 0,
          _right = padding.right / range / relativeTickWidth || 0;

      padding = {
        left: left,
        right: _right
      };
    }

    return padding;
  }, _proto.updateLabels = function updateLabels(withTransition) {
    var _this3 = this,
        $$ = this.owner,
        main = $$.$el.main,
        labels = {
      x: main.select("." + config_classes.axisX + " ." + config_classes.axisXLabel),
      y: main.select("." + config_classes.axisY + " ." + config_classes.axisYLabel),
      y2: main.select("." + config_classes.axisY2 + " ." + config_classes.axisY2Label)
    };

    Object.keys(labels).filter(function (id) {
      return !labels[id].empty();
    }).forEach(function (v) {
      var node = labels[v];
      (withTransition ? node.transition() : node).attr("x", function () {
        return _this3.xForAxisLabel(v);
      }).attr("dx", function () {
        return _this3.dxForAxisLabel(v);
      }).attr("dy", function () {
        return _this3.dyForAxisLabel(v);
      }).text(function () {
        return _this3.getLabelText(v);
      });
    });
  }, _proto.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
    var p = isNumber(padding) ? padding : padding[key];
    return isValue(p) ? this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
  }, _proto.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
    var $$ = this.owner,
        config = $$.config,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        length = config.axis_rotated ? width : height;
    return domainLength * (pixels / length);
  }, _proto.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
    var tickValues = values;

    if (tickCount) {
      var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

      if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
        var tickValue,
            isCategorized = this.isCategorized(),
            count = targetCount - 2,
            start = values[0],
            end = values[values.length - 1];
        tickValues = [start];

        for (var i = 0; i < count; i++) tickValue = +start + (end - start) / (count + 1) * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : isCategorized ? Math.round(tickValue) : tickValue);

        tickValues.push(end);
      }
    }

    return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
      return a - b;
    })), tickValues;
  }, _proto.generateTransitions = function generateTransitions(duration) {
    var $$ = this.owner,
        axis = $$.$el.axis,
        _map = ["x", "y", "y2", "subX"].map(function (v) {
      var ax = axis[v];
      return ax && duration && (ax = ax.transition().duration(duration)), ax;
    }),
        axisX = _map[0],
        axisY = _map[1],
        axisY2 = _map[2],
        axisSubX = _map[3];

    return {
      axisX: axisX,
      axisY: axisY,
      axisY2: axisY2,
      axisSubX: axisSubX
    };
  }, _proto.redraw = function redraw(transitions, isHidden, isInit) {
    var _this4 = this,
        $$ = this.owner,
        config = $$.config,
        $el = $$.$el,
        opacity = isHidden ? "0" : "1";

    ["x", "y", "y2", "subX"].forEach(function (id) {
      var axis = _this4[id],
          $axis = $el.axis[id];
      axis && $axis && (!isInit && (axis.config.withoutTransition = !config.transition_duration), $axis.style("opacity", opacity), axis.create(transitions["axis" + capitalize(id)]));
    }), this.updateAxes();
  }
  /**
   * Redraw axis
   * @param {Array} targetsToShow targets data to be shown
   * @param {object} wth option object
   * @param {d3.Transition} transitions Transition object
   * @param {object} flow flow object
   * @param {boolean} isInit called from initialization
   * @private
   */
  , _proto.redrawAxis = function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
    var xDomainForZoom,
        _this5 = this,
        $$ = this.owner,
        config = $$.config,
        scale = $$.scale,
        $el = $$.$el,
        hasZoom = !!scale.zoom;

    !hasZoom && this.isCategorized() && targetsToShow.length === 0 && scale.x.domain([0, $el.axis.x.selectAll(".tick").size()]), scale.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : this.x && (this.x.tickValues([]), this.subX && this.subX.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = scale.x.orgDomain()), ["y", "y2"].forEach(function (key) {
      var axisScale = scale[key];

      if (axisScale) {
        var tickValues = config["axis_" + key + "_tick_values"],
            tickCount = config["axis_" + key + "_tick_count"];

        if (axisScale.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
          var _axis = $$.axis[key],
              domain = axisScale.domain();

          _axis.tickValues(_this5.generateTickValues(domain, domain.every(function (v) {
            return v === 0;
          }) ? 1 : tickCount, _this5.isTimeSeriesY()));
        }
      }
    }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length && this.setCulling(), wth.Y && (scale.subY && scale.subY.domain($$.getYDomain(targetsToShow, "y")), scale.subY2 && scale.subY2.domain($$.getYDomain(targetsToShow, "y2")));
  }
  /**
   * Set manual culling
   * @private
   */
  , _proto.setCulling = function setCulling() {
    var $$ = this.owner,
        config = $$.config,
        _$$$state3 = $$.state,
        clip = _$$$state3.clip,
        current = _$$$state3.current,
        $el = $$.$el;
    ["subX", "x", "y", "y2"].forEach(function (type) {
      var axis = $el.axis[type],
          id = type === "subX" ? "x" : type,
          toCull = config["axis_" + id + "_tick_culling"]; // subchart x axis should be aligned with x axis culling

      if (axis && toCull) {
        var intervalForCulling,
            tickText = axis.selectAll(".tick text"),
            tickValues = util_sortValue(tickText.data()),
            tickSize = tickValues.length,
            cullingMax = config["axis_" + id + "_tick_culling_max"];

        if (tickSize) {
          for (var i = 1; i < tickSize; i++) if (tickSize / i < cullingMax) {
            intervalForCulling = i;
            break;
          }

          tickText.each(function (d) {
            this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
          });
        } else tickText.style("display", "block"); // set/unset x_axis_tick_clippath


        if (type === "x") {
          var clipPath = current.maxTickWidths.x.clipPath ? clip.pathXAxisTickTexts : null;
          $el.svg.selectAll("." + config_classes.axisX + " .tick text").attr("clip-path", clipPath);
        }
      }
    });
  }, Axis;
}();


// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(41);

// CONCATENATED MODULE: ./src/ChartInternal/data/data.convert.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Data convert
 * @memberof ChartInternal
 * @private
 */

/* harmony default export */ var data_convert = ({
  /**
   * Convert data according its type
   * @param {object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @returns {object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_" + v;
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) this.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = this.convertJsonToData(data.json, data.keys);else if (data.rows) data = this.convertRowsToData(data.rows);else if (data.columns) data = this.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return isArray(data) && data;
  },

  /**
   * Convert URL data
   * @param {string} url Remote URL
   * @param {string} mimeType MIME type string: json | csv | tsv
   * @param {object} headers Header object
   * @param {object} keys Key object
   * @param {Function} done Callback function
   * @private
   */
  convertUrlToData: function convertUrlToData(url, mimeType, headers, keys, done) {
    var _this = this;

    mimeType === void 0 && (mimeType = "csv");
    var req = new XMLHttpRequest();
    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert" + capitalize(mimeType) + "ToData"](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error(url + ": Something went wrong loading!");
    }, req.send();
  },

  /**
   * Convert CSV/TSV data
   * @param {object} parser Parser object
   * @param {object} xsv Data
   * @private
   * @returns {object}
   */
  convertCsvTsvToData: function convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];
    return rows.forEach(function (row, i) {
      if (i > 0) {
        var newRow = {};
        row.forEach(function (v, j) {
          if (isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRow[keys[j]] = v;
        }), newRows.push(newRow);
      }
    }), newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];
    return columns.forEach(function (col, i) {
      var key = col[0];
      col.forEach(function (v, j) {
        if (j > 0) {
          if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRows[j - 1][key] = v;
        }
      });
    }), newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var _this3 = this,
        $$ = this,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        isCategorized = !1,
        isTimeSeries = !1,
        isCustomX = !1;

    axis && (isCategorized = axis.isCategorized(), isTimeSeries = axis.isTimeSeries(), isCustomX = axis.isCustomX());
    var xsData,
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];
    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      isCustomX || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"" + id + "\".");
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter.bind($$.api)(id),
          xKey = $$.getXKey(id),
          isCategory = isCustomX && isCategorized,
          hasCategory = isCategory && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +value, (isCategory || state.hasRadar) && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(value) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), state.hasNegativeValue = $$.hasNegativeValueInTargets(targets), state.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.cache.add(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_data_data = ({
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return !!(config.data_stack_normalize && config.data_groups.length);
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|number|string} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @returns {number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this,
        config = $$.config;
    Object.keys(xs).forEach(function (id) {
      config.data_xs[id] = xs[id];
    });
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this,
        config = $$.config;
    return data && (name = config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },

  /**
   * Get all values on given index
   * @param {number} index Index
   * @param {boolean} filterNull Filter nullish value
   * @returns {Array}
   * @private
   */
  getAllValuesOnIndex: function getAllValuesOnIndex(index, filterNull) {
    filterNull === void 0 && (filterNull = !1);
    var $$ = this,
        value = $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
    return filterNull && (value = value.filter(function (v) {
      return isValue(v.value);
    })), value;
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        axis = $$.axis,
        x = axis && axis.isCategorized() ? index : rawX || index;

    if (axis && axis.isTimeSeries()) {
      var fn = parseDate.bind($$);
      x = rawX ? fn(rawX) : fn($$.getXValue(id, index));
    } else axis && axis.isCustomX() && !axis.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index));

    return x;
  },
  updateXs: function updateXs(values) {
    values.length && (this.axis.xs = values.map(function (v) {
      return v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.axis.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.axis.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param {object} data Data object
   * @returns {number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        hasAxis = $$.state.hasAxis,
        value = data.value;
    return value && hasAxis && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @returns {{min: {number}, max: {number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(value)), max = Math.max.apply(Math, [i ? max : -Infinity].concat(value));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @returns {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = KEY.dataMinMax,
        minMaxData = $$.cache.get(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.cache.add(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @returns {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        cacheKey = KEY.dataTotalPerIndex,
        sum = $$.cache.get(cacheKey);
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @param {boolean} subtractHidden Subtract hidden data from total
   * @returns {number}
   * @private
   */
  getTotalDataSum: function getTotalDataSum(subtractHidden) {
    var $$ = this,
        cacheKey = KEY.dataTotalSum,
        total = $$.cache.get(cacheKey);

    if (!isNumber(total)) {
      var sum = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.cache.add(cacheKey, total = sum);
    }

    return subtractHidden && (total -= $$.getHiddenTotalDataSum()), total;
  },

  /**
   * Get total hidden data sum
   * @returns {number}
   * @private
   */
  getHiddenTotalDataSum: function getHiddenTotalDataSum() {
    var $$ = this,
        api = $$.api,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        total = 0;
    return hiddenTargetIds.length && (total = api.data.values.bind(api)(hiddenTargetIds).reduce(function (p, c) {
      return p + c;
    })), total;
  },

  /**
   * Get filtered data by value
   * @param {object} data Data
   * @param {number} value Value to be filtered
   * @returns {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @returns {number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, this.data.targets.map(function (t) {
      return t.values.length;
    }));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget() {
    var target = this.filterTargetsToShow() || [],
        length = target.length;
    return length > 1 ? (target = target.map(function (t) {
      return t.values;
    }).reduce(function (a, b) {
      return a.concat(b);
    }).map(function (v) {
      return v.x;
    }), target = util_sortValue(getUnique(target)).map(function (x, index) {
      return {
        x: x,
        index: index
      };
    })) : length && (target = target[0].values), target;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.state.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.state.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        axis = $$.axis,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = axis && axis.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), util_sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        hasAxis = $$.state.hasAxis,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, value) : isObject(value) && "high" in value ? data.push.apply(data, Object.values(value)) : $$.isBubbleZType(v) ? data.push(hasAxis && $$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue Target value
   * @returns {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = [].concat(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();
    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order.bind($$.api)), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isboolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.$el.chart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        data = values.filter(function (v) {
      return v && isValue(v.value);
    }),
        minDist = config.point_sensitivity;
    return data.filter(function (v) {
      return $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = main.select("." + config_classes.bars + $$.getTargetSelectorSuffix(v.id) + " ." + config_classes.bar + "-" + v.index).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), data.filter(function (v) {
      return !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        scale = $$.scale,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = (scale.zoom || scale.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @returns {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = !!axis && axis.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length - 1, value = converted[x].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_" + name];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {string} type Ratio for given type
   * @param {object} d Data value object
   * @param {boolean} asPercent Convert the return as percent or not
   * @returns {number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        api = $$.api,
        ratio = 0;
    if (d && api.data.shown().length) if (ratio = d.ratio || d.value, type === "arc") ratio = $$.pie.padAngle()() ? d.value / $$.getTotalDataSum(!0) : (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));else if (type === "index") {
      var dataValues = api.data.values.bind(api),
          total = this.getTotalPerIndex();

      if (state.hiddenTargetIds.length) {
        var hiddenSum = dataValues(state.hiddenTargetIds, !1);
        hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
          return acc.map(function (v, i) {
            return (isNumber(v) ? v : 0) + curr[i];
          });
        }), total = total.map(function (v, i) {
          return v - hiddenSum[i];
        }));
      }

      d.ratio = isNumber(d.value) && total && total[d.index] > 0 ? d.value / total[d.index] : 0, ratio = d.ratio;
    } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0) + "") / state.current.dataMax * config.radar_size_ratio);
    return asPercent && ratio ? ratio * 100 : ratio;
  },

  /**
   * Sort data index to be aligned with x axis.
   * @param {Array} tickValues Tick array values
   * @private
   */
  updateDataIndexByX: function updateDataIndexByX(tickValues) {
    var $$ = this,
        tickValueMap = tickValues.reduce(function (out, tick, index) {
      return out[+tick.x] = index, out;
    }, {});
    $$.data.targets.forEach(function (t) {
      t.values.forEach(function (value, valueIndex) {
        var index = tickValueMap[+value.x];
        index === undefined && (index = valueIndex), value.index = index;
      });
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var data_load = ({
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    // Update current state chart type and elements list after redraw
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), $$.updateTypesElements(), args.done && args.done.call($$.api);
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.cache.reset();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      data && $$.load($$.convertDataToTargets(data), args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        state = $$.state,
        $el = $$.$el,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.cache.reset(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ( // Update current state chart type and elements list after redraw
    $el.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call(endall, done), targetIds.forEach(function (id) {
      state.withoutFadeIn[id] = !1, $el.legend && $el.legend.selectAll("." + config_classes.legendItem + $$.getTargetSelectorSuffix(id)).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    }), $$.updateTypesElements()) : void done();
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(42);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var interactions_interaction = ({
  /**
   * Handle data.onover/out callback options
   * @param {boolean} isOver Over or not
   * @param {number|object} d data object
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        hasRadar = $$.state.hasRadar,
        main = $$.$el.main,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      if (config.color_onover && $$.setOverColor(isOver, d, isArc), isArc) callback(d, main.select("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).node());else if (!config.tooltip_grouped) {
        var last = $$.cache.get(KEY.setOverOut) || [],
            shape = main.selectAll("." + config_classes.shape + "-" + d).filter(function (d) {
          return $$.isWithinShape(this, d);
        });
        shape.each(function (d) {
          var _this = this;

          (last.length === 0 || last.every(function (v) {
            return v !== _this;
          })) && (callback(d, this), last.push(this));
        }), last.length > 0 && shape.empty() && (callback = config.data_onout.bind($$.api), last.forEach(function (v) {
          return callback(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(v).datum(), v);
        }), last = []), $$.cache.add(KEY.setOverOut, last);
      } else isOver && (config.point_focus_only && hasRadar ? $$.showCircleFocus($$.getAllValuesOnIndex(d, !0)) : $$.expandCirclesBars(d, null, !0)), $$.isMultipleX() || main.selectAll("." + config_classes.shape + "-" + d).each(function (d) {
        callback(d, this);
      });
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {number|object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        last = $$.cache.get(KEY.callOverOutForTouch);
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), $$.cache.add(KEY.callOverOutForTouch, d));
  },

  /**
   * Return draggable selection function
   * @returns {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      // @ts-ignore
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      // @ts-ignore
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {string} type event type
   * @param {number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        hasRadar = $$.state.hasRadar,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        radar = _$$$$el.radar,
        isMultipleX = $$.isMultipleX(),
        selector = hasRadar ? "." + config_classes.axis + "-" + index + " text" : "." + (isMultipleX ? config_classes.eventRect : config_classes.eventRect + "-" + index),
        eventRect = (hasRadar ? radar.axes : main).select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX || $$.config.axis_rotated ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/class.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_class = ({
  generateClass: function generateClass(prefix, targetId) {
    return " " + prefix + " " + (prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return this.generateClass(config_classes.region, i) + " " + ("class" in d ? d.class : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " " + config_classes.target + "-" + additionalClassSuffix), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " " + (this.state.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " " + (this.state.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? ("-" + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    var pfx = prefix || "",
        target = this.getTargetSelectorSuffix(id);
    // select target & circle
    return pfx + "." + (config_classes.target + target) + ", " + pfx + "." + (config_classes.circles + target);
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return "." + (config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var category = ({
  /**
   * Category Name
   * @param {number} i Index number
   * @returns {string} category Name
   * @private
   */
  categoryName: function categoryName(i) {
    var categories = this.config.axis_x_categories;
    return i < categories.length ? categories[i] : i;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {string} color Color string
 * @param {string} id ID to be set
 * @returns {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


/* harmony default export */ var internals_color = ({
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @returns {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var cacheKey = KEY.colorPattern,
        body = browser_doc.body,
        pattern = body[cacheKey];

    if (!pattern) {
      var span = browser_doc.createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = win.getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body[cacheKey] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles.bind($$.api)(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = $$.state.datetimeId + "-pattern-" + color + "-" + index;
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#" + p.id + ")";
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id].bind($$.api)(d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback.bind($$.api)(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restate in its previous color value
   * @param {boolean} isOver true: set overed color, false: restore
   * @param {number|object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (_ref) {
      var id = _ref.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) ? color = function () {
      return onover;
    } : isFunction(onover) && (color = color.bind($$.api)), isObject(d) ? main.selectAll("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).style("fill", color(d)) : main.selectAll("." + config_classes.shape + "-" + d).style("fill", color);
  }
});
// CONCATENATED MODULE: ./src/config/const.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Chart type constant
 * @private
 */
var TYPE = {
  AREA: "area",
  AREA_LINE_RANGE: "area-line-range",
  AREA_SPLINE: "area-spline",
  AREA_SPLINE_RANGE: "area-spline-range",
  AREA_STEP: "area-step",
  BAR: "bar",
  BUBBLE: "bubble",
  DONUT: "donut",
  GAUGE: "gauge",
  LINE: "line",
  PIE: "pie",
  RADAR: "radar",
  SCATTER: "scatter",
  SPLINE: "spline",
  STEP: "step"
};
/**
 * chart types by category
 * @private
 */

var TYPE_BY_CATEGORY = {
  Area: [TYPE.AREA, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE, TYPE.AREA_STEP],
  AreaRange: [TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE],
  Arc: [TYPE.PIE, TYPE.DONUT, TYPE.GAUGE, TYPE.RADAR],
  Line: [TYPE.LINE, TYPE.SPLINE, TYPE.AREA, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE, TYPE.STEP, TYPE.AREA_STEP],
  Step: [TYPE.STEP, TYPE.AREA_STEP],
  Spline: [TYPE.SPLINE, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE]
};
// CONCATENATED MODULE: ./src/ChartInternal/internals/domain.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_domain = ({
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has" + (isMin ? "Negative" : "Positive") + "ValueInTargets"](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },

  /**
   * Check if hidden targets bound to the given axis id
   * @param {string} id ID to be checked
   * @returns {boolean}
   * @private
   */
  isHiddenTargetWithYDomain: function isHiddenTargetWithYDomain(id) {
    var $$ = this;
    return $$.state.hiddenTargetIds.some(function (v) {
      return $$.axis.getId(v) === id;
    });
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        scale = $$.scale,
        pfx = "axis_" + axisId;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;
    if (yTargets.length === 0) // use domain of the other axis if target of axisId is none
      return $$.isHiddenTargetWithYDomain(axisId) ? scale[axisId].domain() : axisId === "y2" ? scale.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.
      // So, it needs to call to get y2 domain here
      $$.getYDomain(targets, "y2", xDomain);
    var yMin = config[pfx + "_min"],
        yMax = config[pfx + "_max"],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config[pfx + "_center"],
        isZeroBased = [TYPE.BAR, TYPE.BUBBLE, TYPE.SCATTER].concat(TYPE_BY_CATEGORY.Line).some(function (v) {
      var type = v.indexOf("area") > -1 ? "area" : v;
      return $$.hasType(v, yTargets) && config[type + "_zerobased"];
    }),
        isInverted = config[pfx + "_inverted"],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain(scale.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    } // if padding is set, the domain will be updated relative the current domain value
    // ex) $$.height=300, padding.top=150, domainLength=4  --> domain=6


    var p = config[pfx + "_padding"];
    notEmpty(p) && ["bottom", "top"].forEach(function (v) {
      padding[v] = axis.getPadding(p, v, padding[v], domainLength);
    }), isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        configValue = $$.config["axis_x_" + type],
        dataValue = getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    })),
        value = isObject(configValue) ? configValue.value : configValue;
    return value = isDefined(value) && $$.axis.isTimeSeries() ? parseDate(value) : value, isObject(configValue) && configValue.fit && (type === "min" && value < dataValue || type === "max" && value > dataValue) && (value = undefined), isDefined(value) ? value : dataValue;
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        axis = $$.axis,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    axis.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        isCategorized = $$.axis.isCategorized(),
        isTimeSeries = $$.axis.isTimeSeries(),
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        padding = $$.getXDomainPadding(xDomain),
        _xDomain = xDomain,
        firstX = _xDomain[0],
        lastX = _xDomain[1],
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || isCategorized || (isTimeSeries ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = isTimeSeries ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = isTimeSeries ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        subX = _$$$scale.subX,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && (x.domain(domain || util_sortValue($$.getXDomain(targets))), org.xDomain = x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), subX.domain(x.domain()), $$.brush && $$.brush.scale(subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? org.xDomain : getBrushSelection($$).map(subX.invert);
      x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && x.domain($$.trimXDomain(x.orgDomain())), x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        min = zoomDomain[0],
        max = zoomDomain[1];
    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/format.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get formatted
 * @param {object} $$ Context
 * @param {string} typeValue Axis type
 * @param {number} v Value to be formatted
 * @returns {number | string}
 * @private
 */
function getFormat($$, typeValue, v) {
  var config = $$.config,
      type = "axis_" + typeValue + "_tick_format",
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
}

/* harmony default export */ var internals_format = ({
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        yFormat = $$.yFormat,
        y2Format = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (yFormat = $$.defaultArcValueFormat, y2Format = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis && $$.axis.getId(id) === "y2" ? y2Format : yFormat;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return (ratio * 100).toFixed(1) + "%";
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format.bind($$.api);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var internals_legend = ({
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.legendItemTextBox = {}, $$.state.legendHasRendered = !1, config.legend_show ? (!config.legend_contents_bindto && ($el.legend = $$.$el.svg.append("g").attr("transform", $$.getTranslate("legend"))), $$.updateLegend()) : $$.state.hiddenLegendIds = $$.mapToIds($$.data.targets);
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        scale = $$.scale,
        $el = $$.$el,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !scale.zoom), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), state.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.bind($$.api)(v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $el.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @param {Obejct} size Size object
   * @private
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        isLegendTop = _$$$state.isLegendTop,
        isLegendLeft = _$$$state.isLegendLeft,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        current = _$$$state.current,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : current.height - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : current.width - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.state.margin3 = {
      top: isLegendRight ? 0 : isLegendInset ? insetLegendPosition.top : current.height - height,
      right: NaN,
      bottom: 0,
      left: isLegendRight ? current.width - width : isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @param {boolean} withTransition whether or not to transition.
   * @private
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this,
        legend = $$.$el.legend;
    (withTransition ? legend.transition() : legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @param {number} step Step value
   * @private
   */
  updateLegendStep: function updateLegendStep(step) {
    this.state.legendStep = step;
  },

  /**
   * Update legend item width
   * @param {number} width Width value
   * @private
   */
  updateLegendItemWidth: function updateLegendItemWidth(width) {
    this.state.legendItemWidth = width;
  },

  /**
   * Update legend item height
   * @param {number} height Height value
   * @private
   */
  updateLegendItemHeight: function updateLegendItemHeight(height) {
    this.state.legendItemHeight = height;
  },

  /**
   * Update legend item color
   * @param {string} id Corresponding data ID value
   * @param {string} color Color value
   * @private
   */
  updateLegendItemColor: function updateLegendItemColor(id, color) {
    this.$el.legend.select("." + config_classes.legendItem + "-" + id + " line").style("stroke", color);
  },

  /**
   * Get the width of the legend
   * @returns {number} width
   * @private
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this,
        _$$$state2 = $$.state,
        width = _$$$state2.current.width,
        isLegendRight = _$$$state2.isLegendRight,
        isLegendInset = _$$$state2.isLegendInset,
        legendItemWidth = _$$$state2.legendItemWidth,
        legendStep = _$$$state2.legendStep;
    return $$.config.legend_show ? isLegendRight || isLegendInset ? legendItemWidth * (legendStep + 1) : width : 0;
  },

  /**
   * Get the height of the legend
   * @returns {number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this,
        _$$$state3 = $$.state,
        current = _$$$state3.current,
        isLegendRight = _$$$state3.isLegendRight,
        legendItemHeight = _$$$state3.legendItemHeight,
        legendStep = _$$$state3.legendStep;
    return $$.config.legend_show ? isLegendRight ? current.height : Math.max(20, legendItemHeight) * (legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @param {d3.selection} legendItem Legend item node
   * @returns {string|null} opacity
   * @private
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @param {d3.selection} legendItem Legend item node
   * @returns {string|null} opacity
   * @private
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @param {Array} targetIds ID's of target
   * @param {boolean} focus whether or not to focus.
   * @private
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        legend = $$.$el.legend,
        targetIdz = $$.mapToTargetIds(targetIds);
    legend && legend.selectAll("." + config_classes.legendItem).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this,
        legend = $$.$el.legend;
    legend && legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @param {Array} targetIds ID's of target
   * @private
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    config.legend_show || (config.legend_show = !0, $el.legend ? $el.legend.style("visibility", "visible") : $$.initLegend(), !$$.state.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), $el.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @param {Array} targetIds ID's of target
   * @private
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Get legend item textbox dimension
   * @param {string} id Data ID
   * @param {HTMLElement|d3.selection} textElement Text node element
   * @returns {object} Bounding rect
   * @private
   */
  getLegendItemTextBox: function getLegendItemTextBox(id, textElement) {
    var data,
        $$ = this,
        cache = $$.cache,
        cacheKey = KEY.legendItemTextBox;
    return id && (data = cache.get(cacheKey) || {}, !data[id] && (data[id] = $$.getTextRect(textElement, config_classes.legendItem), cache.add(cacheKey, data)), data = data[id]), data;
  },

  /**
   * Set legend item style & bind events
   * @param {d3.selection} item Item node
   * @private
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        hasGauge = $$.hasType("gauge");
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, api, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? (api.hide(), api.show(id)) : (api.toggle(id), !isTouch && $$.isTargetToShow(id) ? api.focus(id) : api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, api, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), hasGauge && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, api, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), hasGauge && $$.markOverlapped(id, $$, "." + config_classes.gaugeValue), !state.transiting && $$.isTargetToShow(id) && api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = state.isLegendRight || state.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = $$.getLegendItemTextBox(id, textElement),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = state.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    state.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), state.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : state.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        l = legend.selectAll("." + config_classes.legendItem).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#" + state.datetimeId + "-point-" + data : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = legend.select("." + config_classes.legendBackground + " rect"), state.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = legend.insert("g", "." + config_classes.legendItem).attr("class", config_classes.legendBackground).append("rect"));
    var texts = legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = legend.selectAll("rect." + config_classes.legendItemEvent).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = legend.selectAll("." + config_classes.legendItemPoint).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = legend.selectAll("line." + config_classes.legendItemTile).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.levelColor ? function (id) {
        return $$.levelColor($$.cache.get(id).values[0].value);
      } : $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(43);

// CONCATENATED MODULE: ./src/ChartInternal/internals/redraw.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_redraw = ({
  redraw: function redraw(options, transitionsValue) {
    options === void 0 && (options = {});
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        main = $el.main,
        targetsToShow = $$.filterTargetsToShow($$.data.targets),
        initializing = options.initializing,
        flow = options.flow,
        wth = $$.getWithOption(options),
        duration = wth.Transition ? config.transition_duration : 0,
        durationForExit = wth.TransitionForExit ? duration : 0,
        durationForAxis = wth.TransitionForAxis ? duration : 0,
        transitions = transitionsValue || $$.axis && $$.axis.generateTransitions(durationForAxis);
    // text
    // title
    $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.hasDataLabel() && $$.updateText(durationForExit), (!$$.hasArcType() || state.hasRadar) && $$.updateCircleY(), !state.resizing && ($$.hasPointType() || state.hasRadar) && $$.updateCircle(), state.hasAxis ? ($$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), config.data_empty_label_text && main.select("text." + config_classes.text + "." + config_classes.empty).attr("x", state.width / 2).attr("y", state.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.hasGrid() && $$.updateGrid(duration), config.regions.length && $$.updateRegion(duration), $$.hasType("bar") && $$.updateBar(durationForExit), $$.hasTypeOf("Line") && $$.updateLine(durationForExit), $$.hasTypeOf("Area") && $$.updateArea(durationForExit), $el.text && main.selectAll("." + config_classes.selectedCircles).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && $$.bindZoomEvent()) : ($el.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $el.radar && $$.redrawRadar(durationForExit)), $$.redrawTitle && $$.redrawTitle(), initializing && $$.updateTypesElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
  },

  /**
   * Generate redraw list
   * @param {object} targets targets data to be shown
   * @param {object} flow flow object
   * @param {number} duration duration value
   * @param {boolean} withSubchart whether or not to show subchart
   * @private
   */
  generateRedrawList: function generateRedrawList(targets, flow, duration, withSubchart) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        shape = $$.getDrawShape();
    state.hasAxis && config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
    // generate flow
    var flowFn = flow && $$.generateFlow({
      targets: targets,
      flow: flow,
      duration: flow.duration,
      shape: shape,
      xv: $$.xv.bind($$)
    }),
        isTransition = (duration || flowFn) && isTabVisible(),
        redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
        afterRedraw = flow || config.onrendered ? function () {
      flowFn && flowFn(), callFn(config.onrendered, $$.api);
    } : null;
    if (afterRedraw) // Only use transition when current tab is visible.
      if (isTransition && redrawList.length) {
        // Wait for end of transitions for callback
        var waitForDraw = generateWait(); // transition should be derived from one transition

        Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
          redrawList.reduce(function (acc, t1) {
            return acc.concat(t1);
          }, []).forEach(function (t) {
            return waitForDraw.add(t);
          });
        }).call(waitForDraw, afterRedraw);
      } else state.transiting || afterRedraw(); // update fadein condition

    $$.mapToIds($$.data.targets).forEach(function (id) {
      state.withoutFadeIn[id] = !0;
    });
  },
  getRedrawList: function getRedrawList(shape, flow, flowFn, isTransition) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        hasAxis = _$$$state.hasAxis,
        hasRadar = _$$$state.hasRadar,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        list = [];

    if (hasAxis) {
      var _shape$type = shape.type,
          area = _shape$type.area,
          bar = _shape$type.bar,
          line = _shape$type.line;
      (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition)), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), flow || list.push($$.updateGridFocus());
    }

    return (!$$.hasArcType() || hasRadar) && notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition)), ($$.hasPointType() || hasRadar) && !config.point_focus_only && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
  },
  updateAndRedraw: function updateAndRedraw(options) {
    options === void 0 && (options = {});
    var transitions,
        $$ = this,
        config = $$.config,
        state = $$.state;
    // same with redraw
    // NOT same with redraw
    // Draw with new sizes & scales
    options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (state.hasAxis && (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0)), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
  },
  redrawWithoutRescale: function redrawWithoutRescale() {
    this.redraw({
      withY: !1,
      withSubchart: !1,
      withEventRect: !1,
      withTransitionForAxis: !1
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/scale.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_scale = ({
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {number} min Min value
   * @param {number} max Max value
   * @param {Array} domain Domain value
   * @param {Function} offset The offset getter to be sum
   * @returns {Function} scale
   * @private
   */
  getXScale: function getXScale(min, max, domain, offset) {
    var $$ = this,
        scale = $$.scale.zoom || $$.getScale(min, max, $$.axis.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {number} min Min value
   * @param {number} max Max value
   * @param {Array} domain Domain value
   * @returns {Function} Scale function
   * @private
   */
  getYScale: function getYScale(min, max, domain) {
    var $$ = this,
        scale = $$.getScale(min, max, $$.axis.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get y Axis scale
   * @param {string} id Axis id
   * @param {boolean} isSub Weather is sub Axis
   * @returns {Function} Scale function
   * @private
   */
  getYScaleById: function getYScaleById(id, isSub) {
    isSub === void 0 && (isSub = !1);
    var isY2 = this.axis.getId(id) === "y2",
        key = isSub ? isY2 ? "subY2" : "subY" : isY2 ? "y2" : "y";
    return this.scale[key];
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue Scale function
   * @param {Function} offsetValue Offset getter to be sum
   * @returns {Function} Scale function
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.axis.x.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.axis.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },

  /**
   * Update scale
   * @param {boolean} isInit Param is given at the init rendering
   * @param {boolean} updateXDomain If update x domain
   * @private
   */
  updateScales: function updateScales(isInit, updateXDomain) {
    updateXDomain === void 0 && (updateXDomain = !0);
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        format = $$.format,
        org = $$.org,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        width2 = _$$$state.width2,
        height2 = _$$$state.height2,
        hasAxis = _$$$state.hasAxis;

    if (hasAxis) {
      var isRotated = config.axis_rotated,
          min = {
        x: isRotated ? 1 : 0,
        y: isRotated ? 0 : height,
        subX: isRotated ? 1 : 0,
        subY: isRotated ? 0 : height2
      },
          max = {
        x: isRotated ? height : width,
        y: isRotated ? width : 1,
        subX: isRotated ? height : width,
        subY: isRotated ? width2 : 1
      },
          xDomain = updateXDomain && scale.x && scale.x.orgDomain(),
          xSubDomain = updateXDomain && org.xDomain; // update edges

      // y Axis
      scale.x = $$.getXScale(min.x, max.x, xDomain, function () {
        return axis.x.tickOffset();
      }), scale.subX = $$.getXScale(min.x, max.x, xSubDomain, function (d) {
        return d % 1 ? 0 : axis.subX.tickOffset();
      }), format.xAxisTick = axis.getXAxisTickFormat(), axis.setAxis("x", scale.x, config.axis_x_tick_outer, isInit), config.subchart_show && axis.setAxis("subX", scale.subX, config.axis_x_tick_outer, isInit), scale.y = $$.getYScale(min.y, max.y, scale.y ? scale.y.domain() : config.axis_y_default), scale.subY = $$.getYScale(min.subY, max.subY, scale.subY ? scale.subY.domain() : config.axis_y_default), axis.setAxis("y", scale.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && (scale.y2 = $$.getYScale(min.y, max.y, scale.y2 ? scale.y2.domain() : config.axis_y2_default), scale.subY2 = $$.getYScale(min.subY, max.subY, scale.subY2 ? scale.subY2.domain() : config.axis_y2_default), axis.setAxis("y2", scale.y2, config.axis_y2_tick_outer, isInit));
    } else // update for arc
    $$.updateArc && $$.updateArc();
  },

  /**
   * Get the zoom or unzoomed scaled value
   * @param {Date|number|object} d Data value
   * @returns {number|null}
   * @private
   */
  xx: function xx(d) {
    var $$ = this,
        config = $$.config,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom,
        fn = config.zoom_enabled && zoom ? zoom : x;
    return d ? fn(isValue(d.x) ? d.x : d) : null;
  },
  xv: function xv(d) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        x = $$.scale.x,
        value = $$.getBaseValue(d);
    return axis.isTimeSeries() ? value = parseDate.call($$, value) : axis.isCategorized() && isString(value) && (value = config.axis_x_categories.indexOf(value)), Math.ceil(x(value));
  },
  yv: function yv(d) {
    var $$ = this,
        _$$$scale2 = $$.scale,
        y = _$$$scale2.y,
        y2 = _$$$scale2.y2,
        yScale = d.axis && d.axis === "y2" ? y2 : y;
    return Math.ceil(yScale($$.getBaseValue(d)));
  },
  subxx: function subxx(d) {
    return d ? this.scale.subX(d.x) : null;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/size.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_size = ({
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this,
        state = $$.state;
    state.current.width = $$.getCurrentWidth(), state.current.height = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {string} id Axis id value - x, y or y2
   * @returns {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        isRotated = $$.config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $el.title && $el.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_" + axisId + "_axes"].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_" + axisId + "_axes"].length,
        axisWidth = hasAxis ? $$.getAxisWidthByAxisId(axisId, withoutRecompute) : 0;
    return padding = isValue(config.padding_left) ? config.padding_left : hasAxis && isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : hasAxis && (!config.axis_y_show || config.axis_y_inner) ? $$.axis.getAxisLabelPosition("y").isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight(withoutTickTextOverflow) {
    withoutTickTextOverflow === void 0 && (withoutTickTextOverflow = !1);
    var padding,
        $$ = this,
        config = $$.config,
        defaultPadding = 10,
        legendWidthOnRight = $$.state.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2"),
        xAxisTickTextOverflow = withoutTickTextOverflow ? 0 : $$.axis.getXAxisTickTextY2Overflow(defaultPadding);
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : $$.axis && config.axis_rotated ? defaultPadding + legendWidthOnRight : $$.axis && (!config.axis_y2_show || config.axis_y2_inner) ? Math.max(2 + legendWidthOnRight + ($$.axis.getAxisLabelPosition("y2").isOuter ? 20 : 0), xAxisTickTextOverflow) : Math.max(ceil10(axisWidth) + legendWidthOnRight, xAxisTickTextOverflow), padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {string} key property/attribute name
   * @returns {number}
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset" + capitalize(key), parent = this.$el.chart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser_doc.body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.$el.chart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $el.main.select("." + leftAxisClass).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $el.chart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this;

    if ($$.axis) {
      var position = $$.axis && $$.axis.getLabelPositionById(id);
      return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
    }

    return 40;
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        _state = state,
        current = _state.current,
        rotatedPadding = _state.rotatedPadding,
        isLegendRight = _state.isLegendRight,
        isLegendInset = _state.isLegendInset,
        isRotated = config.axis_rotated,
        h = 30;
    if (id === "x" && !config.axis_x_show) return 8;
    if (id === "x" && config.axis_x_height) return config.axis_x_height;
    if (id === "y" && !config.axis_y_show) return !config.legend_show || isLegendRight || isLegendInset ? 1 : 10;
    if (id === "y2" && !config.axis_y2_show) return rotatedPadding.top;
    var rotate = $$.getAxisTickRotate(id); // Calculate x/y axis height when tick rotated

    return (id === "x" && !isRotated || /y2?/.test(id) && isRotated) && rotate && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - rotate) / 180), !config.axis_x_tick_multiline && current.height && h > current.height / 2 && (h = current.height / 2)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10);
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.axis.x.tickInterval());
  },

  /**
   * Get axis tick test rotate value
   * @param {string} id Axis id
   * @returns {number} rotate value
   * @private
   */
  getAxisTickRotate: function getAxisTickRotate(id) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        rotate = config["axis_" + id + "_tick_rotate"];

    if (id === "x") {
      var isCategorized = axis.isCategorized(),
          isTimeSeries = axis.isTimeSeries(),
          allowedXAxisTypes = isCategorized || isTimeSeries,
          tickCount = 0;
      config.axis_x_tick_fit && allowedXAxisTypes && (tickCount = state.current.maxTickWidths.x.ticks.length + (isTimeSeries ? -1 : 1), tickCount !== state.axis.x.tickCount && (state.axis.x.padding = $$.axis.getXAxisPadding(tickCount)), state.axis.x.tickCount = tickCount), $el.svg && config.axis_x_tick_fit && !config.axis_x_tick_multiline && !config.axis_x_tick_culling && config.axis_x_tick_autorotate && allowedXAxisTypes && (rotate = $$.needToRotateXAxisTickTexts() ? config.axis_x_tick_rotate : 0);
    }

    return rotate;
  },

  /**
   * Check weather axis tick text needs to be rotated
   * @returns {boolean}
   * @private
   */
  needToRotateXAxisTickTexts: function needToRotateXAxisTickTexts() {
    var $$ = this,
        _$$$state = $$.state,
        axis = _$$$state.axis,
        current = _$$$state.current,
        xAxisLength = current.width - $$.getCurrentPaddingLeft(!1) - $$.getCurrentPaddingRight(!0),
        tickCountWithPadding = axis.x.tickCount + axis.x.padding.left + axis.x.padding.right,
        maxTickWidth = $$.axis.getMaxTickWidth("x");
    return maxTickWidth > (xAxisLength / tickCountWithPadding || 0);
  },
  updateDimension: function updateDimension(withoutAxis) {
    var $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        $el = $$.$el;
    // pass 'withoutAxis' param to not animate at the init rendering
    hasAxis && !withoutAxis && ($$.axis.x && config.axis_rotated ? ($$.axis.x.create($el.axis.x), $$.axis.subX && $$.axis.subX.create($el.axis.subX)) : ($$.axis.y && $$.axis.y.create($el.axis.y), $$.axis.y2 && $$.axis.y2.create($el.axis.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
  },
  updateSvgSize: function updateSvgSize() {
    var $$ = this,
        state = $$.state,
        svg = $$.$el.svg;

    if (svg.attr("width", state.current.width).attr("height", state.current.height), state.hasAxis) {
      var brush = svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), svg.selectAll(["#" + state.clip.id, "#" + state.clip.idGrid]).select("rect").attr("width", state.width).attr("height", state.height), svg.select("#" + state.clip.idXAxis).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), svg.select("#" + state.clip.idYAxis).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), state.clip.idSubchart && svg.select("#" + state.clip.idSubchart).select("rect").attr("width", state.width).attr("height", brushSize.height), svg.select("." + config_classes.zoomRect).attr("width", state.width).attr("height", state.height);
    }
  },

  /**
   * Update size values
   * @param {boolean} isInit If is called at initialization
   * @private
   */
  updateSizes: function updateSizes(isInit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        isRotated = config.axis_rotated,
        hasArc = $$.hasArcType();
    isInit || $$.setContainerSize();
    var currLegend = {
      width: legend ? $$.getLegendWidth() : 0,
      height: legend ? $$.getLegendHeight() : 0
    },
        legendHeightForBottom = state.isLegendRight || state.isLegendInset ? 0 : currLegend.height,
        xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
        subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
        subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
    // for main
    // for subchart
    // for legend
    // for arc
    state.margin = isRotated ? {
      top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
    } : {
      top: 4 + $$.getCurrentPaddingTop(),
      // for top tick text
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: hasArc ? 0 : $$.getCurrentPaddingLeft()
    }, state.margin2 = isRotated ? {
      top: state.margin.top,
      right: NaN,
      bottom: 20 + legendHeightForBottom,
      left: $$.state.rotatedPadding.left
    } : {
      top: state.current.height - subchartHeight - legendHeightForBottom,
      right: NaN,
      bottom: subchartXAxisHeight + legendHeightForBottom,
      left: state.margin.left
    }, state.margin3 = {
      top: 0,
      right: NaN,
      bottom: 0,
      left: 0
    }, $$.updateSizeForLegend && $$.updateSizeForLegend(currLegend), state.width = state.current.width - state.margin.left - state.margin.right, state.height = state.current.height - state.margin.top - state.margin.bottom, state.width < 0 && (state.width = 0), state.height < 0 && (state.height = 0), state.width2 = isRotated ? state.margin.left - state.rotatedPadding.left - state.rotatedPadding.right : state.width, state.height2 = isRotated ? state.height : state.current.height - state.margin2.top - state.margin2.bottom, state.width2 < 0 && (state.width2 = 0), state.height2 < 0 && (state.height2 = 0), state.arcWidth = state.width - (state.isLegendRight ? currLegend.width + 10 : 0), state.arcHeight = state.height - (state.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && (state.arcHeight += state.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), state.isLegendRight && hasArc && (state.margin3.left = state.arcWidth / 2 + state.radiusExpanded * 1.1);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/text.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_text = ({
  opacityForText: function opacityForText() {
    return this.hasDataLabel() ? "1" : "0";
  },

  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $el = this.$el;
    $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartTexts);
  },

  /**
   * Update chartText
   * @param {object} targets $$.data.targets
   * @private
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.$el.main.select("." + config_classes.chartTexts).selectAll("." + config_classes.chartText).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").style("opacity", "0").attr("class", classChartText).style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $el.text = $el.main.selectAll("." + config_classes.texts).selectAll("." + config_classes.text).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $el.text.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $el.text = $el.text.enter().append("text").merge($$.$el.text).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {boolean} forFlow Weather is flow
   * @param {boolean} withTransition transition is enabled
   * @returns {Array}
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    // need to return 'true' as of being pushed to the redraw list
    // ref: getRedrawList()
    return $$.$el.text.each(function (d, i) {
      var _this2 = this,
          text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x.bind(this)(d, i)).attr("y", function (d) {
        return y.bind(_this2)(d, i);
      }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    }), !0;
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @param {HTMLElement|d3.selection} element Target element
   * @param {string} className Class name
   * @returns {object} value of element.getBoundingClientRect()
   * @private
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = KEY.textRect + "-" + text.replace(/\W/g, "_"),
        rect = $$.cache.get(cacheKey);
    return rect || ($$.$el.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = getBoundingRect(v.node());
    }).remove(), $$.cache.add(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {object} indices Indices values
   * @param {boolean} forX whether or not to x
   * @returns {number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet" + capitalize(v) + "Points"](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @param {object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} Position value
   * @private
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = getBoundingRect(textElement),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Get data.labels.position value
   * @param {string} id Data id value
   * @param {string} type x | y
   * @returns {number} Position value
   * @private
   */
  getTextPos: function getTextPos(id, type) {
    var pos = this.config.data_labels_position;
    return (id in pos ? pos[id] : pos)[type] || 0;
  },

  /**
   * Gets the x coordinate of the text
   * @param {object} points Data points position
   * @param {object} d Data object
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} x coordinate
   * @private
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated;
    // show labels regardless of the domain if value is null
    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > state.width) {
      var _getBoundingRect = getBoundingRect(textElement),
          width = _getBoundingRect.width;

      xPos = state.width - width;
    } else xPos < 0 && (xPos = 4);
    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + $$.getTextPos(d.id, "x");
  },

  /**
   * Gets the y coordinate of the text
   * @param {object} points Data points position
   * @param {object} d Data object
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} y coordinate
   * @private
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = getBoundingRect(textElement),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !state.hasPositiveValue && state.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > state.height && (yPos = state.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + $$.getTextPos(d.id, "y");
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Mark overlapping text nodes with "text-overlapping" class
   * @param {string} id Axis id
   * @param {ChartInternal} $$ ChartInternal context
   * @param {string} selector Selector string
   * @private
   */
  markOverlapped: function markOverlapped(id, $$, selector) {
    var textNodes = $$.$el.arcs.selectAll(selector),
        filteredTextNodes = textNodes.filter(function (node) {
      return node.data.id !== id;
    }),
        textNode = textNodes.filter(function (node) {
      return node.data.id === id;
    }),
        translate = getTranslation(textNode.node()),
        calcHypo = function (x, y) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    textNode.node() && filteredTextNodes.each(function () {
      var coordinate = getTranslation(this),
          filteredTextNode = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          nodeForWidth = calcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ? textNode : filteredTextNode,
          overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) < Math.ceil(nodeForWidth.node().getComputedTextLength()),
          overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) < parseInt(textNode.style("font-size"), 0);
      filteredTextNode.classed(config_classes.TextOverlapping, overlapsX && overlapsY);
    });
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Remove "text-overlapping" class on selected text nodes
   * @param {ChartInternal} $$ ChartInternal context
   * @param {string} selector Selector string
   * @private
   */
  undoMarkOverlapped: function undoMarkOverlapped($$, selector) {
    $$.$el.arcs.selectAll(selector).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([this, this.previousSibling]).classed(config_classes.TextOverlapping, !1);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get the text position
 * @param {string} pos right, left or center
 * @param {number} width chart width
 * @returns {string|number} text-anchor value or position in pixel
 * @private
 */

function getTextPos(pos, width) {
  pos === void 0 && (pos = "left");
  var position,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
}

/* harmony default export */ var internals_title = ({
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.title_text) {
      $el.title = $el.svg.append("g");
      var text = $el.title.append("text").style("text-anchor", getTextPos(config.title_position)).attr("class", config_classes.title);
      setTextValue(text, config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        title = $$.$el.title;

    if (title) {
      var y = $$.yForTitle.call($$);
      /g/i.test(title.node().tagName) ? title.attr("transform", "translate(" + getTextPos(config.title_position, current.width) + ", " + y + ")") : title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @returns {number} x attribute value
   * @private
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        current = $$.state.current,
        position = config.title_position || "left",
        textRectWidth = $$.getTextRect($$.$el.title, config_classes.title).width;
    return /(right|center)/.test(position) ? (x = current.width - textRectWidth, position.indexOf("right") >= 0 ? x = current.width - textRectWidth - config.title_padding.right : position.indexOf("center") >= 0 && (x = (current.width - textRectWidth) / 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @returns {number} y attribute value
   * @private
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.$el.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @returns {number} padding value
   * @private
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_tooltip = ({
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($el.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $el.tooltip.empty() && ($el.tooltip = $el.chart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.axis.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = parseDate.call($$, config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $el.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $el.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }

    $$.bindTooltipResizePos();
  },

  /**
   * Get the tooltip HTML string
   * @param  {Array} args Arguments
   * @returns {string} Formatted HTML string
   * @private
   */
  getTooltipHTML: function getTooltipHTML() {
    var $$ = this,
        api = $$.api,
        config = $$.config;
    return isFunction(config.tooltip_contents) ? config.tooltip_contents.bind(api).apply(void 0, arguments) : $$.getTooltipContent.apply($$, arguments);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {string} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        _map = ["title", "name", "value"].map(function (v) {
      var fn = config["tooltip_format_" + v];
      return isFunction(fn) ? fn.bind(api) : fn;
    }),
        titleFormat = _map[0],
        nameFormat = _map[1],
        valueFormat = _map[2];

    titleFormat = titleFormat || defaultTitleFormat, nameFormat = nameFormat || function (name) {
      return name;
    }, valueFormat = valueFormat || ($$.isStackNormalized() ? function (v, ratio) {
      return (ratio * 100).toFixed(2) + "%";
    } : defaultValueFormat);

    var order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.axis && $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template,
        targetIds = $$.mapToTargetIds();

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order.bind(api));

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr),
        len = d.length;

    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">" + title + "</th></tr>" : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(param))), $$.isAreaRangeType(row)) {
        var _map2 = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(param)));
        }),
            high = _map2[0],
            low = _map2[1];

        value = "<b>Mid:</b> " + value + " <b>High:</b> " + high + " <b>Low:</b> " + low;
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(param))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:" + color + "\" width=\"10\" height=\"10\"></rect></svg>",
            NAME: name,
            VALUE: value
          };

          if (tplStr && isObject(contents.text)) {
            var index = targetIds.indexOf(row.id);
            Object.keys(contents.text).forEach(function (key) {
              contentValue[key] = contents.text[key][index];
            });
          }

          text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return text + "</table>";
  },

  /**
   * Get the content template string
   * @param {string} tplStr Tempalte string
   * @returns {Array} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">" + (this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>") + "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>").replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {object} dataToShow data
   * @param {string} tWidth Width value of tooltip element
   * @param {string} tHeight Height value of tooltip element
   * @param {HTMLElement} element Tooltip element
   * @returns {object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        current = _$$$state.current,
        isLegendRight = _$$$state.isLegendRight,
        inputType = _$$$state.inputType,
        hasGauge = $$.hasType("gauge") && !config.gauge_fullCircle,
        svgLeft = $$.getSvgLeft(!0),
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        left = _d3Mouse[0],
        top = _d3Mouse[1],
        chartRight = svgLeft + current.width - $$.getCurrentPaddingRight(!0),
        chartLeft = $$.getCurrentPaddingLeft(!0),
        size = 20;

    // Determine tooltip position
    if (top += size, $$.hasArcType()) {
      var raw = inputType === "touch" || $$.hasType("radar");
      raw || (top += hasGauge ? height : height / 2, left += (width - (isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = scale.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + size, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + chartLeft + size + ($$.zoomScale ? left : dataScale));
    } // when tooltip left + tWidth > chart's width


    return left + tWidth + 15 > chartRight && (left -= tWidth + chartLeft), top + tHeight > current.height && (top -= hasGauge ? tHeight * 3 : tHeight + 30), top < 0 && (top = 0), {
      top: top,
      left: left
    };
  },

  /**
   * Show the tooltip
   * @param {object} selectedData Data object
   * @param {HTMLElement} element Tooltip element
   * @private
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        tooltip = $$.$el.tooltip,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = tooltip.datum(),
          _ref = datum || {},
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 0 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 0 : _ref$height,
          dataStr = JSON.stringify(selectedData);

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$.api, selectedData), tooltip.html($$.getTooltipHTML(selectedData, // data
        $$.axis ? $$.axis.getXAxisTickFormat() : $$.categoryName.bind($$), // defaultTitleFormat
        $$.getYFormat(forArc), // defaultValueFormat
        $$.color // color
        )).style("display", null).style("visibility", null) // for IE9
        .datum(datum = {
          index: index,
          current: dataStr,
          width: width = tooltip.property("offsetWidth"),
          height: height = tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$.api, selectedData), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        var fnPos = config.tooltip_position || $$.tooltipPosition,
            pos = fnPos.call(this, dataToShow, width, height, element); // Get tooltip dimensions

        ["top", "left"].forEach(function (v) {
          var value = pos[v];
          tooltip.style(v, value + "px"), v !== "left" || datum.xPosInPercent || (datum.xPosInPercent = value / state.current.width * 100);
        });
      }
    }
  },

  /**
   * Adjust tooltip position on resize event
   * @private
   */
  bindTooltipResizePos: function bindTooltipResizePos() {
    var $$ = this,
        resizeFunction = $$.resizeFunction,
        state = $$.state,
        tooltip = $$.$el.tooltip;
    resizeFunction.add(function () {
      if (tooltip.style("display") === "block") {
        var current = state.current,
            _tooltip$datum = tooltip.datum(),
            width = _tooltip$datum.width,
            xPosInPercent = _tooltip$datum.xPosInPercent,
            _value = current.width / 100 * xPosInPercent,
            diff = current.width - (_value + width);

        diff < 0 && (_value += diff), tooltip.style("left", _value + "px");
      }
    });
  },

  /**
   * Hide the tooltip
   * @param {boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        tooltip = $$.$el.tooltip;

    if (tooltip.style("display") !== "none" && (!config.tooltip_doNotHide || force)) {
      var selectedData = JSON.parse(tooltip.datum().current);
      // hide tooltip
      callFn(config.tooltip_onhide, api, selectedData), tooltip.style("display", "none").style("visibility", "hidden") // for IE9
      .datum(null), callFn(config.tooltip_onhidden, api, selectedData);
    }
  },

  /**
   * Toggle display for linked chart instances
   * @param {boolean} show true: show, false: hide
   * @param {number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this,
        charts = $$.charts,
        config = $$.config;

    if (config.tooltip_linked && charts.length > 1) {
      var linkedName = config.tooltip_linked_name;
      charts.forEach(function (c) {
        if (c !== $$.api) {
          var _c$internal = c.internal,
              _config = _c$internal.config,
              $el = _c$internal.$el,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser_doc.body.contains($el.chart.node());

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.$el.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/transform.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_transform = ({
  getTranslate: function getTranslate(target, index) {
    index === void 0 && (index = 0);
    var x,
        y,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        hasGauge = $$.hasType("gauge"),
        padding = 0;
    if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel(state.margin.left), y = asHalfPixel(state.margin.top);else if (target === "context") x = asHalfPixel(state.margin2.left), y = asHalfPixel(state.margin2.top);else if (target === "legend") x = state.margin3.left, y = state.margin3.top + (hasGauge ? 10 : 0);else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : state.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? state.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : state.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subX") x = 0, y = isRotated ? 0 : state.height2;else if (target === "arc") x = state.arcWidth / 2, y = state.arcHeight / 2;else if (target === "radar") {
      var _$$$getRadarSize = $$.getRadarSize(),
          width = _$$$getRadarSize[0];

      x = state.width / 2 - width, y = asHalfPixel(state.margin.top);
    }
    return "translate(" + x + ", " + y + ")";
  },
  transformMain: function transformMain(withTransition, transitions) {
    var xAxis,
        yAxis,
        y2Axis,
        $$ = this,
        main = $$.$el.main;
    transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = main.select("." + config_classes.axisX), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = main.select("." + config_classes.axisY), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = main.select("." + config_classes.axisY2), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? main.transition() : main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), main.select("." + config_classes.chartArcs).attr("transform", $$.getTranslate("arc"));
  },
  transformAll: function transformAll(withTransition, transitions) {
    var $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        $el = $$.$el;
    $$.transformMain(withTransition, transitions), hasAxis && config.subchart_show && $$.transformContext(withTransition, transitions), $el.legend && $$.transformLegend(withTransition);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/type.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_type = ({
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config,
        withoutFadeIn = $$.state.withoutFadeIn;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },

  /**
   * Updte current used chart types
   * @private
   */
  updateTypesElements: function updateTypesElements() {
    var $$ = this,
        current = $$.state.current;
    // Update current chart elements reference
    Object.keys(TYPE).forEach(function (v) {
      var t = TYPE[v],
          has = $$.hasType(t, null, !0),
          idx = current.types.indexOf(t);
      idx === -1 && has ? current.types.push(t) : idx > -1 && !has && current.types.splice(idx, 1);
    }), $$.setChartElements();
  },

  /**
   * Check if given chart types exists
   * @param {string} type Chart type
   * @param {Array} targetsValue Data array
   * @param {boolean} checkFromData Force to check type cotains from data targets
   * @returns {boolean}
   * @private
   */
  hasType: function hasType(type, targetsValue, checkFromData) {
    checkFromData === void 0 && (checkFromData = !1);
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        types = config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return !checkFromData && current.types.length && current.types.indexOf(type) > -1 ? has = !0 : targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      t !== type && (t || type !== "line") || (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @param {string} type Type key
   * @param {object} targets Target data
   * @param {Array} exclude Excluded types
   * @returns {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets, exclude) {
    var _this = this;

    // 실제 노드 존재 여부도 확인필요
    return exclude === void 0 && (exclude = []), !TYPE_BY_CATEGORY[type] // @ts-ignore
    .filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {object} d Data object
   * @param {string|Array} type chart type
   * @returns {boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },
  hasPointType: function hasPointType() {
    var $$ = this;
    return $$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter");
  },

  /**
   * Check if contains arc types chart
   * @param {object} targets Target data
   * @param {Array} exclude Excluded types
   * @returns {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  hasMultiArcGauge: function hasMultiArcGauge() {
    return this.hasType("gauge") && this.config.gauge_type === "multi";
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPE_BY_CATEGORY.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint(node) {
    var config = this.config,
        pattern = config.point_pattern,
        isCircle = !1;
    return isCircle = !!(node && node.tagName === "circle") || config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0), isCircle;
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {object} d Data object
   * @returns {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Set the min/max value
 * @param {Chart} $$ Chart instance
 * @param {string} type Set type 'min' or 'max'
 * @param {object} value Value to be set
 * @private
 */

function setMinMax($$, type, value) {
  var config = $$.config,
      axisY = "axis_y_" + type,
      axisY2 = "axis_y2_" + type;
  isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config["axis_x_" + type] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  }));
}
/**
 * Get the min/max value
 * @param {Chart} $$ Chart instance
 * @param {string} type Set type 'min' or 'max'
 * @returns {{x, y, y2}}
 * @private
 */


function axis_getMinMax($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_" + type],
    y: config["axis_y_" + type],
    y2: config["axis_y2_" + type]
  };
}
/**
 * Define axis
 * @ignore
 */


var api_axis_axis = {
  /**
   * Get and set axis labels.
   * @function axis․labels
   * @instance
   * @memberof Chart
   * @param {object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @function axis․min
   * @instance
   * @memberof Chart
   * @param {object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @returns {object|undefined}
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return isValue(_min) ? setMinMax($$, "min", _min) : axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @function axis․max
   * @instance
   * @memberof Chart
   * @param {object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @returns {object|undefined}
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @function axis․range
   * @instance
   * @memberof Chart
   * @param {object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @returns {object|undefined}
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
};
/* harmony default export */ var api_axis = ({
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/Chart/api/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_category = ({
  /**
   * Set specified category name on category axis.
   * @function category
   * @instance
   * @memberof Chart
   * @param {number} i index of category to be changed
   * @param {string} category category value to be changed
   * @returns {string}
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @function categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @returns {Array}
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_flow = ({
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @function flow
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [data․json](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [data․rows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [data․columns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
   *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0),
          isTimeSeries = $$.axis.isTimeSeries();
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, isTimeSeries || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: isTimeSeries ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: isTimeSeries ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, isTimeSeries || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = isTimeSeries ? parseDate.call($$, args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && isTimeSeries && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = isTimeSeries ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
});
// CONCATENATED MODULE: ./src/Chart/api/grid.x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update x grid lines.
 * @function xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @returns {object}
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 * // --> Returns: [{value: 1, text: "Label 1"}, {value: 4, text: "Label 4"}]
 */
function xgrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
}

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @function xgrids․add
   * @instance
   * @memberof Chart
   * @param {Array|object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @returns {object}
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @function xgrids․remove
   * @instance
   * @memberof Chart
   * @param {object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});
/* harmony default export */ var grid_x = ({
  xgrids: xgrids
});
// CONCATENATED MODULE: ./src/Chart/api/grid.y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update y grid lines.
 * @function ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @returns {object}
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 * // --> Returns: [{value: 100, text: "Label 1"}, {value: 400, text: "Label 4"}]
 */

function ygrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
}

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @function ygrids․add
   * @instance
   * @memberof Chart
   * @param {Array|object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @returns {object}
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @function ygrids․remove
   * @instance
   * @memberof Chart
   * @param {object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
});
/* harmony default export */ var grid_y = ({
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/Chart/api/group.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var group = ({
  /**
   * Update groups for the targets.
   * @function groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @returns {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/Chart/api/regions.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Update regions.
 * @function regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @returns {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */
function regions_regions(regions) {
  var $$ = this.internal,
      config = $$.config;
  return regions ? (config.regions = regions, $$.redrawWithoutRescale(), regions) : config.regions;
}

extend(regions_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @function regions․add
   * @instance
   * @memberof Chart
   * @param {Array|object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @returns {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @function regions․remove
   * @instance
   * @memberof Chart
   * @param {object} optionsValue This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @returns {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.$el.main.select("." + config_classes.regions).selectAll(classes.map(function (c) {
      return "." + c;
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region.class || (region.class.split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
});
/* harmony default export */ var api_regions = ({
  regions: regions_regions
});
// CONCATENATED MODULE: ./src/Chart/api/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var api_selection = ({
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @function selected
   * @instance
   * @memberof Chart
   * @param {string} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @returns {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.$el.main.selectAll("." + (config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll("." + config_classes.shape).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @function select
   * @instance
   * @memberof Chart
   * @param {string|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable.bind($$.api)(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @function unselect
   * @instance
   * @memberof Chart
   * @param {string|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable.bind($$.api)(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/Chart/api/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_x = ({
  /**
   * Get and set x values for the chart.
   * @function x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @returns {object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        axis = $$.axis,
        data = $$.data,
        isCategorized = axis.isCustomX() && axis.isCategorized();
    return isArray(_x) && (isCategorized ? this.categories(_x) : ($$.updateTargetX(data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? this.categories() : data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @function xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @returns {object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(44);

// CONCATENATED MODULE: ./src/Chart/api/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Check if the given domain is within zoom range
 * @param {Array} domain domain value
 * @param {Array} range zoom range value
 * @returns {boolean}
 * @private
 */

function withinRange(domain, range) {
  var min = range[0],
      max = range[1];
  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
}
/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @function zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @returns {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */


var zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      config = $$.config,
      scale = $$.scale,
      domain = domainValue;

  if (config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.axis.isTimeSeries();

    if (isTimeSeries) {
      var fn = parseDate.bind($$);
      domain = domain.map(function (x) {
        return fn(x);
      });
    }

    if (config.subchart_show) {
      var xScale = scale.zoom || scale.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else scale.x.domain(domain), scale.zoom = scale.x, $$.axis.x.scale(scale.zoom), resultDomain = scale.zoom.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn(config.zoom_onzoom, $$.api, resultDomain);
  } else resultDomain = scale.zoom ? scale.zoom.domain() : scale.x.orgDomain();

  return resultDomain;
};

extend(zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @function zoom․enable
   * @instance
   * @memberof Chart
   * @param {string|boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable(enabled) {
    var $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @function zoom․max
   * @instance
   * @memberof Chart
   * @param {number} [max] maximum value to set for zoom
   * @returns {number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [xDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @function zoom․min
   * @instance
   * @memberof Chart
   * @param {number} [min] minimum value to set for zoom
   * @returns {number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [xDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @function zoom․range
   * @instance
   * @memberof Chart
   * @param {object} [range] zoom range
   * @returns {object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range) {
    var zoom = this.zoom;

    if (isObject(_range)) {
      var min = _range.min,
          max = _range.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
});
/* harmony default export */ var api_zoom = ({
  zoom: zoom_zoom,

  /**
   * Unzoom zoomed area
   * @function unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.scale.zoom) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.$el.main.select("." + config_classes.eventRects);
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/drag.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var interactions_drag = ({
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _state$dragStart = state.dragStart,
            sx = _state$dragStart[0],
            sy = _state$dragStart[1],
            mx = mouse[0],
            my = mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? state.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? state.height : Math.max(sy, my);
        main.select("." + config_classes.dragarea).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).filter(function (d) {
          return config.data_selection_isselectable.bind($$.api)(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = +shape.attr("cx") * 1,
                y = +shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return; // @ts-ignore


          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (state.dragStart = mouse, main.select("." + config_classes.chart).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (main.select("." + config_classes.dragarea).transition().duration(100).style("opacity", "0").remove(), main.selectAll("." + config_classes.shape).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.state.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(45);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var interactions_flow = ({
  /**
   * Generate flow
   * @param {object} args option object
   * @returns {Function}
   * @private
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        data = $$.data,
        state = $$.state,
        $el = $$.$el;
    return function () {
      var flowLength = args.flow.length; // set flag

      state.flowing = !0, data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      }), $$.updateXGrid && $$.updateXGrid(!0);
      // target elements
      var elements = {};
      ["axis.x", "grid.x", "gridLines.x", "region.list", "text", "bar", "line", "area", "circle"].forEach(function (v) {
        var name = v.split("."),
            node = $el[name[0]];
        node && name.length > 1 && (node = node[name[1]]), node && node.size() && (elements[v] = node);
      }), $$.hideGridFocus(), $$.setFlowList(elements, args);
    };
  },

  /**
   * Set flow list
   * @param {object} elements Target elements
   * @param {object} args option object
   * @private
   */
  setFlowList: function setFlowList(elements, args) {
    var $$ = this,
        flow = args.flow,
        targets = args.targets,
        _flow = flow,
        _flow$duration = _flow.duration,
        duration = _flow$duration === void 0 ? args.duration : _flow$duration,
        flowIndex = _flow.index,
        flowLength = _flow.length,
        orgDataCount = _flow.orgDataCount,
        transform = $$.getFlowTransform(targets, orgDataCount, flowIndex, flowLength),
        wait = generateWait(),
        gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(duration);
    wait.add(Object.keys(elements).map(function (v) {
      var n = elements[v];
      return n = v === "axis.x" ? n.transition(gt).call(function (g) {
        return $$.axis.x.setTransition(gt).create(g);
      }) : v === "region.list" ? n.filter($$.isRegionOnX).transition(gt).attr("transform", transform) : n.transition(gt).attr("transform", transform), n;
    })), gt.call(wait, function () {
      $$.cleanUpFlow(elements, args);
    });
  },

  /**
   * Clean up flow
   * @param {object} elements Target elements
   * @param {object} args option object
   * @private
   */
  cleanUpFlow: function cleanUpFlow(elements, args) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        svg = $$.$el.svg,
        isRotated = config.axis_rotated,
        flow = args.flow,
        shape = args.shape,
        xv = args.xv,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        _flow2 = flow,
        _flow2$done = _flow2.done,
        done = _flow2$done === void 0 ? function () {} : _flow2$done,
        flowLength = _flow2.length;
    // draw again for removing flowed elements and reverting attr
    // callback for end of flow
    flowLength && (["circle", "text", "shape", "eventRect"].forEach(function (v) {
      var target = [];

      for (var i = 0; i < flowLength; i++) target.push("." + config_classes[v] + "-" + i);

      svg.selectAll("." + config_classes[v + "s"]) // circles, shapes, texts, eventRects
      .selectAll(target).remove();
    }), svg.select("." + config_classes.xgrid).remove()), Object.keys(elements).forEach(function (v) {
      var n = elements[v];
      if (v !== "axis.x" && n.attr("transform", null), v === "grid.x") n.attr(state.xgridAttr);else if (v === "gridLines.x") n.attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv);else if (v === "gridLines.x") n.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv), n.select("text").attr("x", isRotated ? state.width : 0).attr("y", xv);else if (/^(area|bar|line)$/.test(v)) n.attr("d", shape.type[v]);else if (v === "text") n.attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$));else if (v !== "circle") v === "region.list" && n.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));else if ($$.isCirclePoint()) n.attr("cx", cx).attr("cy", cy);else {
        var xFunc = function (d) {
          return cx(d) - config.point_r;
        },
            yFunc = function (d) {
          return cy(d) - config.point_r;
        };

        n.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
        .attr("cy", cy);
      }
    }), config.interaction_enabled && $$.redrawEventRect(), done.call($$.api), state.flowing = !1;
  },

  /**
   * Get flow transform value
   * @param {object} targets target
   * @param {number} orgDataCount original data count
   * @param {number} flowIndex flow index
   * @param {number} flowLength flow length
   * @returns {string}
   * @private
   */
  getFlowTransform: function getFlowTransform(targets, orgDataCount, flowIndex, flowLength) {
    var translateX,
        $$ = this,
        data = $$.data,
        x = $$.scale.x,
        dataValues = data.targets[0].values,
        flowStart = $$.getValueOnIndex(dataValues, flowIndex),
        flowEnd = $$.getValueOnIndex(dataValues, flowIndex + flowLength),
        orgDomain = x.domain(),
        domain = $$.updateXDomain(targets, !0, !0);
    orgDataCount ? orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = x(orgDomain[0]) - x(domain[0]) : translateX = $$.axis.isTimeSeries() ? x(orgDomain[0]) - x(domain[0]) : x(flowStart.x) - x(flowEnd.x) : dataValues.length === 1 ? $$.axis.isTimeSeries() ? (flowStart = $$.getValueOnIndex(dataValues, 0), flowEnd = $$.getValueOnIndex(dataValues, dataValues.length - 1), translateX = x(flowStart.x) - x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = x(orgDomain[0]) - x(domain[0]);
    var scaleX = diffDomain(orgDomain) / diffDomain(domain);
    return "translate(" + translateX + ",0) scale(" + scaleX + ",1)";
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/eventrect.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var eventrect = ({
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.$el.main.select("." + config_classes.eventRects).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll("." + config_classes.eventRect).remove(), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), isMultipleX) eventRectUpdate = $el.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $el.eventRect
      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), eventRectUpdate = $el.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $el.eventRect = eventRectUpdate, $$.updateEventRect(eventRectUpdate), $$.state.inputType !== "touch" || $el.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        state = $$.state,
        svg = $$.$el.svg,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(" + config_classes.eventRect + "-?|s)", "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isboolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client" + (config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect(),
          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
        if (state.dragging || state.flowing || $$.hasArcType() || event.touches.length > 1) return;
        preventEvent(event), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }, !0).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || state.cancelClick) && state.cancelClick && (state.cancelClick = !1);
    }, !0);
  },

  /**
   * Updates the location and size of the eventRect.
   * @param {object} eventRectUpdate d3.select(CLASS.eventRects) object.
   * @private
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        xScale = scale.zoom || scale.x,
        eventRectData = eventRectUpdate || $$.$el.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = state.width, h = state.height;else {
      var rectW, rectX;
      if ($$.axis.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? state.height : state.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = d.x;
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? state.width : rectW, h = isRotated ? rectW : state.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || main.selectAll("." + config_classes.shape + "-" + index).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable.bind($$.api)(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config,
        _$$$$el = $$.$el,
        bar = _$$$$el.bar,
        circle = _$$$$el.circle;
    circle && config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), bar && $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if (state.mouseover && (!closest || closest.id !== state.mouseover.id) && (config.data_onout.call($$.api, state.mouseover), state.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.$el.svg.select("." + config_classes.eventRect).style("cursor", "pointer"), !state.mouseover && (config.data_onover.call($$.api, closest), state.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this,
        config = $$.config,
        _$$$$el2 = $$.$el,
        bar = _$$$$el2.bar,
        circle = _$$$$el2.circle,
        tooltip = _$$$$el2.tooltip;
    $$.$el.svg.select("." + config_classes.eventRect).style("cursor", null), $$.hideGridFocus(), tooltip && ($$.hideTooltip(), $$._handleLinkedCharts(!1)), circle && !config.point_focus_only && $$.unexpandCircles(), bar && $$.unexpandBars();
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @param {object} eventRectEnter d3.select(CLASS.eventRects) object.
   * @returns {object} d3.select(CLASS.eventRects) object.
   * @private
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return state.inputType === "mouse" && rect.on("mouseover", function (d) {
      state.dragging || state.flowing || $$.hasArcType() || config.tooltip_grouped && $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!(state.dragging || state.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.$el.svg.select("." + config_classes.eventRect + "-" + index);
        $$.isStepType(d) && config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.scale.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index), config.tooltip_grouped || $$.setOverOut(index !== -1, d.index);
      }
    }).on("mouseout", function (d) {
      !config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    if ($$.hasArcType() || !$$.toggleShape || state.cancelClick) return void (state.cancelClick && (state.cancelClick = !1));
    var index = d.index;
    main.selectAll("." + config_classes.shape + "-" + index).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.bind($$.api)(d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @param {object} eventRectEnter d3.select(CLASS.eventRects) object.
   * @returns {object} d3.select(CLASS.eventRects) object.
   * @private
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        inputType = _$$$state.inputType,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", width).attr("height", height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.$el.main.selectAll("." + config_classes.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll("." + config_classes.shape + "-" + closest.index).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.bind($$.api)(closest, this));
      });
    } // select if selection enabled

  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_subchart = ({
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        subchart = $$.$el.subchart,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.$el.svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.state.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = scale.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map(scale.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && subchart.main && subchart.main.select("." + config_classes.brush).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return (// @ts-ignore
        subchart.main ? subchart.main.select("." + config_classes.brush) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([])
      );
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        clip = _$$$state.clip,
        hasAxis = _$$$state.hasAxis,
        _$$$$el = $$.$el,
        defs = _$$$$el.defs,
        svg = _$$$$el.svg,
        subchart = _$$$$el.subchart,
        axis = _$$$$el.axis;

    if (hasAxis) {
      var visibility = config.subchart_show ? "visible" : "hidden",
          clipId = clip.id + "-subchart",
          clipPath = $$.getClipPath(clipId);
      clip.idSubchart = clipId, $$.appendClip(defs, clipId), $$.initBrush(), subchart.main = svg.append("g").attr("transform", $$.getTranslate("context"));
      var main = subchart.main;
      main.style("visibility", visibility), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars), main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), axis.subX = main.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subX")).attr("clip-path", config.axis_rotated ? "" : clip.pathXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
    }
  },

  /**
   * Update sub chart
   * @param {object} targets $$.data.targets
   * @private
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.subchart.main,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var barUpdate = main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", classChartBar),
          barEnter = barUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(barUpdate);
      barEnter.append("g").attr("class", classBars);
      // -- Line --//
      var lineUpdate = main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", classChartLine),
          lineEnter = lineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(lineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      lineEnter.append("g").attr("class", classLines), $$.hasType("area") && lineEnter.append("g").attr("class", classAreas), main.selectAll("." + config_classes.brush + " rect").attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? state.width2 : state.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @param {object} durationForExit Transition duration
   * @private
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.bar = subchart.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data($$.barData.bind($$)), subchart.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.bar = subchart.bar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge(subchart.bar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @param {string} drawBarOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   * @private
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var bar = this.$el.subchart.bar;
    (withTransition ? bar.transition(getRandom()).duration(duration) : bar).attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.line = subchart.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), subchart.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.line = subchart.line.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge(subchart.line).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {string} drawLineOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var line = this.$el.subchart.line;
    (withTransition ? line.transition(getRandom()).duration(duration) : line).attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.area = subchart.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), subchart.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.area = subchart.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge(subchart.area).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {string} drawAreaOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var area = this.$el.subchart.area;
    (withTransition ? area.transition(getRandom()).duration(duration) : area).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.state.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {boolean} withSubchart whether or not to show subchart
   * @param {number} duration duration
   * @param {object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.subchart.main;
    main.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw" + name](shape.indices[v], !0);
      $$["update" + name + "ForSubchart"](duration), $$["redraw" + name + "ForSubchart"](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this,
        _$$$config = $$.config,
        onBrush = _$$$config.subchart_onbrush,
        withY = _$$$config.zoom_rescale,
        scale = $$.scale;
    $$.redraw({
      withTransition: !1,
      withY: withY,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), onBrush.bind($$.api)(scale.x.orgDomain());
  },

  /**
   * Transform context
   * @param {boolean} withTransition indicates transition is enabled
   * @param {object} transitions The return value of the generateTransitions method of Axis.
   * @private
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this,
        main = $$.$el.subchart.main;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = main.select("." + config_classes.axisX), withTransition && (subXAxis = subXAxis.transition())), main.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subX"));
  },

  /**
   * Get extent value
   * @returns {Array} default extent
   * @private
   */
  getExtent: function getExtent() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        extent = config.axis_x_extent;
    if (extent) if (isFunction(extent)) extent = extent.bind($$.api)($$.getXDomain($$.data.targets), scale.subX);else if ($$.axis.isTimeSeries() && extent.every(isNaN)) {
      var fn = parseDate.bind($$);
      extent = extent.map(function (v) {
        return scale.subX(fn(v));
      });
    }
    return extent;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var interactions_zoom = ({
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.scale.zoom = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent(bind) {
    bind === void 0 && (bind = !0);
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        zoomEnabled = config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = main.select("." + config_classes.eventRects);
    zoomEnabled && bind ? !config.subchart_show && $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        scale = $$.scale,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent
    // @ts-ignore
    // @ts-ignore

    /**
     * Update scale according zoom transform value
     * @param {object} transform transform object
     * @private
     */
    // @ts-ignore
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.scale.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      org.xScale && org.xScale.range(scale.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"](org.xScale || scale.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, org.xDomain), scale.zoom = $$.getCustomizedScale(newScale), $$.axis.x.scale(scale.zoom), rescale && (!org.xScale && (org.xScale = scale.x.copy()), scale.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        org = $$.org,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
        sourceEvent = event.sourceEvent;

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && (scale.zoom || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
      var isMousemove = sourceEvent.type === "mousemove",
          isZoomOut = sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && scale.x.domain().every(function (v, i) {
        return v !== org.xDomain[i];
      }) && scale.x.domain(org.xDomain), $$.zoom.updateTransformScale(transform), $$.axis.isCategorized() && scale.x.orgDomain()[0] === org.xDomain[0] && scale.x.domain([org.xDomain[0] - 1e-10, scale.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.state.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, scale.zoom.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        startEvent = $$.zoom.startEvent,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn(config.zoom_onzoomend, $$.api, scale[scale.zoom ? "zoom" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
   * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _org$xDomain = org.xDomain,
        min = _org$xDomain[0],
        max = _org$xDomain[1];
    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this,
        _$$$scale = $$.scale,
        subX = _$$$scale.subX,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom;

    if (zoom) {
      var zoomDomain = zoom.domain(),
          xDomain = subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.axis.x.scale(subX), x.domain(subX.orgDomain()), $$.scale.zoom = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @param {d3.selection} eventRects evemt <rect> element
   * @param {string} type zoom type
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var zoomRect,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      // @ts-ignore
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.$el.main.append("rect").attr("clip-path", state.clip.path).attr("class", config_classes.zoomBrush).attr("width", isRotated ? state.width : 0).attr("height", isRotated ? 0 : state.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      // @ts-ignore
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.scale.zoom || $$.scale.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event3 = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event3 ? [_event3.clientX, _event3.clientY] : [_event3.x, _event3.y],
            x = _ref2[0],
            y = _ref2[1],
            target = browser_doc.elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.$el.chart.append("div").classed(config_classes.button, !0).append("span").on("click", function () {
      isFunction(resetButton.onclick) && resetButton.onclick.bind($$.api)(this), $$.api.unzoom();
    }).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/clip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_clip = ({
  initClip: function initClip() {
    var $$ = this,
        clip = $$.state.clip;
    // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
    // Define 'clip-path' attribute values
    clip.id = $$.state.datetimeId + "-clip", clip.idXAxis = clip.id + "-xaxis", clip.idYAxis = clip.id + "-yaxis", clip.idGrid = clip.id + "-grid", clip.path = $$.getClipPath(clip.id), clip.pathXAxis = $$.getClipPath(clip.idXAxis), clip.pathYAxis = $$.getClipPath(clip.idYAxis), clip.pathGrid = $$.getClipPath(clip.idGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!win.navigator && win.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(" + (isIE9 ? "" : browser_doc.URL.split("#")[0]) + "#" + id + ")";
  },
  appendClip: function appendClip(parent, id) {
    id && parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    var margin = this.state.margin,
        left = Math.max(30, margin.left); // axis line width + padding for left

    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    var margin = this.state.margin;
    return forHorizontal ? -20 : -margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        _$$$state = $$.state,
        margin = _$$$state.margin,
        width = _$$$state.width,
        left = Math.max(30, margin.left),
        right = Math.max(30, margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? width + 2 + left + right : margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    var _this$state = this.state,
        margin = _this$state.margin,
        height = _this$state.height; // less than 20 is not enough to show the axis label 'outer' without legend

    return (forHorizontal ? margin.bottom : margin.top + height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  },
  updateXAxisTickClip: function updateXAxisTickClip() {
    var $$ = this,
        _$$$state2 = $$.state,
        clip = _$$$state2.clip,
        xAxisHeight = _$$$state2.xAxisHeight,
        newXAxisHeight = $$.getHorizontalAxisHeight("x");
    clip.idXAxisTickTexts = clip.id + "-xaxisticktexts", clip.pathXAxisTickTexts = $$.getClipPath(clip.idXAxisTickTexts), !$$.config.axis_x_tick_multiline && $$.getAxisTickRotate("x") && newXAxisHeight !== xAxisHeight && ($$.setXAxisTickClipWidth(), $$.setXAxisTickTextClipPathWidth()), $$.state.xAxisHeight = newXAxisHeight;
  },
  setXAxisTickClipWidth: function setXAxisTickClipWidth() {
    var $$ = this,
        config = $$.config,
        maxTickWidths = $$.state.current.maxTickWidths,
        xAxisTickRotate = $$.getAxisTickRotate("x");

    if (!config.axis_x_tick_multiline && xAxisTickRotate) {
      var sinRotation = Math.sin(Math.PI / 180 * Math.abs(xAxisTickRotate));
      maxTickWidths.x.clipPath = ($$.getHorizontalAxisHeight("x") - 20) / sinRotation;
    } else maxTickWidths.x.clipPath = null;
  },
  setXAxisTickTextClipPathWidth: function setXAxisTickTextClipPathWidth() {
    var $$ = this,
        _$$$state3 = $$.state,
        clip = _$$$state3.clip,
        current = _$$$state3.current,
        svg = $$.$el.svg;
    svg && svg.select("#" + clip.idXAxisTickTexts + " rect").attr("width", current.maxTickWidths.x.clipPath).attr("height", 30);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
};

/**
 * Get grid text x value getter function
 * @param {boolean} isX Is x Axis
 * @param {number} width Width value
 * @param {number} height Height value
 * @returns {Function}
 * @private
 */
function getGridTextX(isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
}
/**
 * Update coordinate attributes value
 * @param {d3.selection} el Target node
 * @param {string} type Type
 * @private
 */


function smoothLines(el, type) {
  type === "grid" && el.each(function () {
    var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
    ["x1", "x2", "y1", "y2"].forEach(function (v) {
      return g.attr(v, Math.ceil(+g.attr(v)));
    });
  });
}

/* harmony default export */ var internals_grid = ({
  hasGrid: function hasGrid() {
    var config = this.config;
    return ["x", "y"].some(function (v) {
      return config["grid_" + v + "_show"] || config["grid_" + v + "_lines"].length;
    });
  },
  initGrid: function initGrid() {
    var $$ = this;
    $$.hasGrid() && $$.initGridLines(), $$.initFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el;
    (config.grid_x_lines.length || config.grid_y_lines.length) && ($el.gridLines.main = $el.main.insert("g", "." + config_classes.chart + (config.grid_lines_front ? " + *" : "")).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid + " " + config_classes.gridLines), $el.gridLines.main.append("g").attr("class", config_classes.xgridLines), $el.gridLines.main.append("g").attr("class", config_classes.ygridLines), $el.gridLines.x = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        grid = _$$$$el.grid,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, scale.x),
        tickOffset = $$.axis.isCategorized() ? $$.axis.x.tickOffset() : 0,
        pos = function (d) {
      return ((scale.zoom || scale.x)(d) + tickOffset) * (isRotated ? -1 : 1);
    };

    state.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": state.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": state.height
    }, grid.x = main.select("." + config_classes.xgrids).selectAll("." + config_classes.xgrid).data(xgridData), grid.x.exit().remove(), grid.x = grid.x.enter().append("line").attr("class", config_classes.xgrid).merge(grid.x), withoutUpdate || grid.x.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys(state.xgridAttr).forEach(function (id) {
        grid.attr(id, state.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? state.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el2 = $$.$el,
        grid = _$$$$el2.grid,
        main = _$$$$el2.main,
        isRotated = config.axis_rotated,
        gridValues = $$.axis.y.tickValues() || $$.scale.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.scale.y(d));
    };

    grid.y = main.select("." + config_classes.ygrids).selectAll("." + config_classes.ygrid).data(gridValues), grid.y.exit().remove(), grid.y = grid.y.enter().append("line").attr("class", config_classes.ygrid).merge(grid.y), grid.y.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : state.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? state.height : pos), smoothLines(grid.y, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this,
        _$$$$el3 = $$.$el,
        grid = _$$$$el3.grid,
        gridLines = _$$$$el3.gridLines;
    // hide if arc type
    gridLines.main || $$.initGridLines(), grid.main.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.hideGridFocus(), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {number} duration Dration value
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$$el4 = $$.$el,
        gridLines = _$$$$el4.gridLines,
        main = _$$$$el4.main,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid();
    var xLines = main.select("." + config_classes.xgridLines).selectAll("." + config_classes.xgridLine).data(config.grid_x_lines); // exit

    xLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = xLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), xLines = xgridLine.merge(xLines), xLines.attr("class", function (d) {
      return (config_classes.xgridLine + " " + (d.class || "")).trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), gridLines.x = xLines;
  },

  /**
   * Update Y Grid lines
   * @param {number} duration Duration value
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        $el = $$.$el,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid();
    var ygridLines = $el.main.select("." + config_classes.ygridLines).selectAll("." + config_classes.ygridLine).data(config.grid_y_lines); // exit

    ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), ygridLines = ygridLine.merge(ygridLines);
    // update
    var yv = $$.yv.bind($$);
    ygridLines.attr("class", function (d) {
      return (config_classes.ygridLine + " " + (d.class || "")).trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? height : yv).transition().style("opacity", "1"), ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, width, height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), $el.gridLines.y = ygridLines;
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        gridLines = $$.$el.gridLines,
        xv = $$.xv.bind($$),
        lines = gridLines.x.select("line"),
        texts = gridLines.x.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, width, height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initFocusGrid: function initFocusGrid() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el,
        isFront = config.grid_front,
        className = "." + config_classes[isFront && $el.gridLines.main ? "gridLines" : "chart"] + (isFront ? " + *" : ""),
        grid = $el.main.insert("g", className).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid);
    $el.grid.main = grid, config.grid_x_show && grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && (grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus), config.grid_focus_y && !config.tooltip_grouped && grid.append("g").attr("class", config_classes.ygridFocus).append("line").attr("class", config_classes.ygridFocus));
  },

  /**
   * Show grid focus line
   * @param {Array} data Selected data
   * @private
   */
  showGridFocus: function showGridFocus(data) {
    var $$ = this,
        config = $$.config,
        _$$$state3 = $$.state,
        width = _$$$state3.width,
        height = _$$$state3.height,
        isRotated = config.axis_rotated,
        focusEl = $$.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus),
        dataToShow = (data || [focusEl.datum()]).filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    // Hide when bubble/scatter/stanford plot exists
    if (!(!config.tooltip_show || dataToShow.length === 0 || $$.hasType("bubble") || $$.hasArcType())) {
      var isEdge = config.grid_focus_edge && !config.tooltip_grouped,
          xx = $$.xx.bind($$);
      focusEl.style("visibility", "visible").data(dataToShow.concat(dataToShow)).each(function (d) {
        var xy,
            el = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            pos = {
          x: xx(d),
          y: $$.getYScaleById(d.id)(d.value)
        };
        if (el.classed(config_classes.xgridFocus)) xy = isRotated ? [null, // x1
        pos.x, // y1
        isEdge ? pos.y : width, // x2
        pos.x // y2
        ] : [pos.x, isEdge ? pos.y : null, pos.x, height];else {
          var isY2 = $$.axis.getId(d.id) === "y2";
          xy = isRotated ? [pos.y, // x1
          isEdge && !isY2 ? pos.x : null, // y1
          pos.y, // x2
          isEdge && isY2 ? pos.x : height // y2
          ] : [isEdge && isY2 ? pos.x : null, pos.y, isEdge && !isY2 ? pos.x : width, pos.y];
        }
        ["x1", "y1", "x2", "y2"].forEach(function (v, i) {
          return el.attr(v, xy[i]);
        });
      }), smoothLines(focusEl, "grid"), $$.showCircleFocus(data);
    }
  },
  hideGridFocus: function hideGridFocus() {
    var $$ = this,
        inputType = $$.state.inputType,
        main = $$.$el.main;
    inputType === "mouse" && (main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus).style("visibility", "hidden"), $$.hideCircleFocus());
  },
  updateGridFocus: function updateGridFocus() {
    var $$ = this,
        _$$$state4 = $$.state,
        inputType = _$$$state4.inputType,
        width = _$$$state4.width,
        height = _$$$state4.height,
        resizing = _$$$state4.resizing,
        grid = $$.$el.grid,
        xgridFocus = grid.main.select("line." + config_classes.xgridFocus);
    if (inputType === "touch") xgridFocus.empty() ? resizing && $$.showCircleFocus() : $$.showGridFocus();else {
      var _isRotated = $$.config.axis_rotated;
      xgridFocus.attr("x1", _isRotated ? 0 : -10).attr("x2", _isRotated ? width : -10).attr("y1", _isRotated ? -10 : 0).attr("y2", _isRotated ? -10 : height);
    } // need to return 'true' as of being pushed to the redraw list
    // ref: getRedrawList()

    return !0;
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.$el.main.select("." + config_classes.axisX).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date(i + "-01-01 00:00:00"));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line.class === param.class) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.$el.main.select("." + classLines).selectAll("." + classLine).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_" + (forX ? "x" : "y") + "_lines";
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/region.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection



/* harmony default export */ var region = ({
  initRegion: function initRegion() {
    var $$ = this,
        $el = $$.$el;
    $el.region.main = $el.main.append("g").attr("clip-path", $$.state.clip.path).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $el.region.main || $$.initRegion(), $el.region.main.style("visibility", $$.hasArcType() ? "hidden" : "visible");
    // select <g> element
    var list = $el.main.select("." + config_classes.regions).selectAll("." + config_classes.region).data(config.regions);
    list.exit().transition().duration(duration).style("opacity", "0").remove(), list = list.enter().append("g").merge(list).attr("class", $$.classRegion.bind($$)), list.append("rect").style("fill-opacity", "0"), $el.region.list = list;
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.$el.region.list.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], pos = currScale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, pos = currScale($$.axis.isTimeSeries() ? parseDate.call($$, d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = state[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], end = currScale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, end = currScale($$.axis.isTimeSeries() ? parseDate.call($$, d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(46);

// CONCATENATED MODULE: ./src/ChartInternal/internals/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_selection = ({
  /**
   * Select a point
   * @param {object} target Target point
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @param {object} target Target point
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    // remove selected-circle from low layer g
    callFn(config.data_onunselected, $$.api, d, target.node()), $el.main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @param {boolean} selected whether or not to select.
   * @param {object} target Target object
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = (selected ? "" : "un") + "selectPoint";
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @param {object} target Target path
   * @param {object} d Data object
   * @private
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$.api, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {object} target Target path
   * @param {object} d Data object
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$.api, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @param {boolean} selected whether or not to select.
   * @param {object} target Target object
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  togglePath: function togglePath(selected, target, d, i) {
    this[(selected ? "" : "un") + "selectPath"](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @param {object} that shape
   * @param {object} d Data object
   * @returns {Function} toggle method
   * @private
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @param {object} that shape
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable.bind($$.api)(d)) {
      if (!config.data_selection_multiple) {
        var selector = "." + config_classes.shapes;
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), main.selectAll(selector).selectAll("." + config_classes.shape).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_shape_bar = ({
  initBar: function initBar() {
    var $el = this.$el;
    $el.bar = $el.main.select("." + config_classes.chart) // should positioned at the beginning of the shape node to not overlap others
    .insert("g", ":first-child").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$);
    $el.bar || $$.initBar();
    var mainBarUpdate = $$.$el.main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        $el = $$.$el,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $el.bar = $el.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data(barData), $el.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.bar = $el.bar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($el.bar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    var bar = this.$el.bar;
    return [(withTransition ? bar.transition(getRandom()) : bar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        maxDataCount = $$.getMaxDataCount(),
        isGrouped = config.data_groups.length,
        tickInterval = (scale.zoom || $$) && !$$.axis.isCategorized() ? $$.xx(scale.subX.domain()[1]) / maxDataCount : axis.tickInterval(maxDataCount),
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        main = $$.$el.main,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? main.selectAll("." + config_classes.bars + $$.getTargetSelectorSuffix(id)) : main).selectAll("." + config_classes.bar + suffix);
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a" + radius + "," + radius + " " + (isNegative ? "1 0 0" : "0 0 1") + " ";
        pathRadius[+!isRotated] = "" + arc + radius + "," + radius, pathRadius[+isRotated] = "" + arc + [-radius, radius][isRotated ? "sort" : "reverse"](), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H" + (points[1][indexX] - radius) + " " + pathRadius[0] + "V" + (points[2][indexY] - radius) + " " + pathRadius[1] + "H" + points[3][indexX] : "V" + (points[1][indexY] + (isNegative ? -radius : radius)) + " " + pathRadius[0] + "H" + (points[2][indexX] - radius) + " " + pathRadius[1] + "V" + points[3][indexY];
      return "M" + points[0][indexX] + "," + points[0][indexY] + path + "z";
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        axis = isSub ? $$.axis.subX : $$.axis.x,
        barTargetsNum = $$.getIndicesMax(barIndices) + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list = list,
        seg0 = _list[0],
        seg1 = _list[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var shape_bubble = ({
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value
   * @returns {number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        cacheKey = KEY.bubbleBaseLength,
        baseLength = $$.cache.get(cacheKey);
    return baseLength || $$.cache.add(cacheKey, baseLength = getMinMax("min", [width, height])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR.bind($$.api)(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  },

  /**
   * Get bubble dimension data
   * @param {object|Array} d data value
   * @param {string} type - y or z
   * @returns {number}
   * @private
   */
  getBubbleZData: function getBubbleZData(d, type) {
    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
  },

  /**
   * Determine if bubble has dimension data
   * @param {object|Array} d data value
   * @returns {boolean}
   * @private
   */
  isBubbleZType: function isBubbleZType(d) {
    var $$ = this;
    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(47);

// CONCATENATED MODULE: ./src/ChartInternal/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var ChartInternal_shape_line = ({
  initLine: function initLine() {
    var $el = this.$el;
    $el.line = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        $el = $$.$el,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classFocus = $$.classFocus.bind($$);
    $el.line || $$.initLine();
    var mainLineUpdate = $el.main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    mainLineEnter.append("g").attr("class", classLines), $$.hasTypeOf("Area") && mainLineEnter.append("g").attr("class", $$.classAreas.bind($$));
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this,
        extraLineClasses = $$.format.extraLineClasses,
        $el = $$.$el;
    $el.line = $el.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), $el.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.line = $el.line.enter().append("path").attr("class", function (d) {
      return $$.classLine.bind($$)(d) + " " + (extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($el.line).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    var line = this.$el.line;
    return [(withTransition ? line.transition(getRandom()) : line).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @returns {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScale = $$.getYScaleById.bind($$),
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? scale.subX : scale.x;
    return function (d) {
      var path,
          y = yScale(d.id, isSub),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.axis.isTimeSeries(),
        xOffset = $$.axis.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? parseDate.call($$, v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M" + points[0][0] + "," + points[0][1] + "L" + points[1][0] + "," + points[1][1];
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          hasPrevData = prevData && isValue(prevData.value),
          style = isWithinRegions(data.x, regions);
      // https://github.com/naver/billboard.js/issues/1172
      if (isValue(data.value)) // Draw as normal
        if (isUndefined(regions) || !style || !hasPrevData) path += "" + (_i && hasPrevData ? "L" : "M") + xValue(data) + "," + yValue(data);else if (hasPrevData) {
          try {
            style = style.dasharray.split(" ");
          } catch (e) {
            style = dasharray.split(" ");
          } // Draw with region // TODO: Fix for horizotal charts


          xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
          var dx = x(data.x) - x(prevData.x),
              dy = y(data.value) - y(prevData.value),
              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = style[0] / dd, diffx2 = diff * style[1];

          for (var _j = diff; _j <= 1; _j += diffx2) path += sWithRegion(prevData, data, _j, diff), _j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
        }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        defs = $$.$el.defs;
    $$.data.targets.forEach(function (d) {
      var id = datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id);

      if ($$.isAreaType(d) && defs.select("#" + id).empty()) {
        var color = $$.color(d),
            _config$area_linearGr = config.area_linearGradient,
            _config$area_linearGr2 = _config$area_linearGr.x,
            x = _config$area_linearGr2 === void 0 ? [0, 0] : _config$area_linearGr2,
            _config$area_linearGr3 = _config$area_linearGr.y,
            y = _config$area_linearGr3 === void 0 ? [0, 1] : _config$area_linearGr3,
            _config$area_linearGr4 = _config$area_linearGr.stops,
            stops = _config$area_linearGr4 === void 0 ? [[0, color, 1], [1, color, 0]] : _config$area_linearGr4,
            linearGradient = defs.append("linearGradient").attr("id", "" + id).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1].bind($$.api)(d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#" + $$.state.datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id) + ")" : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    config.area_linearGradient && $$.updateAreaGradient(), $el.area = $el.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), $el.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.area = $el.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($el.area), $el.area.style("opacity", state.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this,
        orgAreaOpacity = $$.state.orgAreaOpacity;
    return [(withTransition ? $$.$el.area.transition(getRandom()) : $$.$el.area).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? orgAreaOpacity / 1.75 : orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param {object} areaIndices Indices
   * @param {boolean} isSub Weather is sub axis
   * @returns {Function}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScale = $$.getYScaleById.bind($$),
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : $$.getShapeYMin(d.id));
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScale(d.id, isSub)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue) // @ts-ignore
        .y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.scale.x(values[0].x), y0 = $$.getYScaleById(d.id)(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        x = $$.getShapeX(0, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var getTransitionName = function () {
  return getRandom();
};

/* harmony default export */ var shape_point = ({
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  initialOpacityForCircle: function initialOpacityForCircle(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
  },
  opacityForCircle: function opacityForCircle(d) {
    var config = this.config,
        opacity = config.point_show && !config.point_focus_only ? "1" : "0";
    return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
  },
  initCircle: function initCircle() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.point = $$.generatePoint(), config.point_show && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartCircles);
  },
  updateTargetForCircle: function updateTargetForCircle(t) {
    var $$ = this,
        config = $$.config,
        data = $$.data,
        $el = $$.$el,
        targets = t || data.targets,
        classCircles = $$.classCircles.bind($$);
    !$el.circle && config.point_show && $$.initCircle();
    var mainCircle = $el.main.select("." + config_classes.chartCircles).style("pointer-events", "none").selectAll("." + config_classes.circles).data(targets).attr("class", classCircles),
        mainCircleEnter = mainCircle.enter();
    // Circles for each data point on lines
    // Update date for selected circles
    config.data_selection_enabled && mainCircleEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainCircleEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    }), targets.forEach(function (t) {
      $el.main.selectAll("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll("" + config_classes.selectedCircle).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateCircle: function updateCircle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        focusOnly = config.point_focus_only;

    if (config.point_show) {
      var circles = $el.main.selectAll("." + config_classes.circles).selectAll("." + config_classes.circle).data(function (d) {
        var data = !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
        return focusOnly ? [data[0]] : data;
      });
      circles.exit().remove();
      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
      circles.enter().append(fn).merge(circles).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$)), $el.circle = $el.main.selectAll("." + config_classes.circles + " ." + config_classes.circle);
    }
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        rendered = $$.state.rendered,
        _$$$$el = $$.$el,
        circle = _$$$$el.circle,
        main = _$$$$el.main,
        selectedCircles = main.selectAll("." + config_classes.selectedCircle);
    if (!$$.config.point_show) return [];
    var fn = $$.point("update", $$, cx, cy, $$.color, withTransition, flow, selectedCircles),
        posAttr = $$.isCirclePoint() ? "c" : "",
        t = getRandom(),
        opacityStyleFn = $$.opacityForCircle.bind($$),
        mainCircles = [];
    return circle.each(function (d) {
      var result = fn.bind(this)(d);
      result = (withTransition || !rendered ? result.transition(t) : result).style("opacity", opacityStyleFn), mainCircles.push(result);
    }), [mainCircles, selectedCircles.attr(posAttr + "x", cx).attr(posAttr + "y", cy)];
  },

  /**
   * Show focused data point circle
   * @param {object} d Selected data
   * @private
   */
  showCircleFocus: function showCircleFocus(d) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;

    if (state.transiting === !1 && config.point_focus_only) {
      var circle = $el.circle,
          hasRadar = state.hasRadar,
          cx = (hasRadar ? $$.radarCircleX : $$.circleX).bind($$),
          cy = (hasRadar ? $$.radarCircleY : $$.circleY).bind($$),
          fn = $$.point("update", $$, cx, cy, $$.color, !1);
      d && (circle = circle.filter(function (t) {
        return d.some(function (v) {
          return v.id === t.id;
        });
      }).data(d)), circle.attr("class", this.updatePointClass.bind(this)).style("opacity", "1").each(function (d) {
        isValue(d.value) ? (fn.bind(this)(d), $$.expandCircles(d.index, d.id), this.style.visibility = "") : (this.style.visibility = "hidden", $$.unexpandCircles(d.index));
      });
    }
  },

  /**
   * Hide focused data point circle
   * @private
   */
  hideCircleFocus: function hideCircleFocus() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    config.point_focus_only && ($$.unexpandCircles(), $el.circle.style("visibility", "hidden"));
  },
  circleX: function circleX(d) {
    return this.xx(d);
  },
  updateCircleY: function updateCircleY() {
    var $$ = this,
        getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), !1);

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? getPoints(d, i)[0][1] : $$.getYScaleById(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? $$.$el.main.selectAll("." + config_classes.circles + $$.getTargetSelectorSuffix(id)) : $$.$el.main).selectAll("." + config_classes.circle + suffix);
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(" + x + " " + y + ") scale(" + scale + ")");
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(" + r(circles) / $$.config.point_r + ")");
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR.bind($$.api)(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint(node) ? "c" : "",
        cx = +element.attr(prefix + "x"),
        cy = +element.attr(prefix + "y");

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _getBoundingRect = getBoundingRect(node),
          x = _getBoundingRect.x,
          y = _getBoundingRect.y;

      cx = x, cy = y;
    }

    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.$el.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.$el.defs.select("#" + id);
  },
  updatePointClass: function updatePointClass(d) {
    var $$ = this,
        circle = $$.$el.circle,
        pointClass = !1;
    return (isObject(d) || circle) && (pointClass = d === !0 ? circle.each(function (d) {
      var className = $$.classCircle.bind($$)(d);
      this.getAttribute("class").indexOf(config_classes.EXPANDED) > -1 && (className += " " + config_classes.EXPANDED), this.setAttribute("class", className);
    }) : $$.classCircle(d)), pointClass;
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ids.indexOf(id) < 0 && ids.push(id);
        var point = pattern[ids.indexOf(id) % pattern.length];
        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = datetimeId + "-point-" + id,
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  custom: {
    create: function create(element, id, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#" + id).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
        return yPosFn(d) - height / 2;
      }).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
        return yPosFn(d) - r;
      }).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/shape.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var shape_shape = ({
  /**
   * Get the shape draw function
   * @returns {object}
   * @private
   */
  getDrawShape: function getDrawShape() {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        hasRadar = $$.state.hasRadar,
        shape = {
      type: {},
      indices: {},
      pos: {}
    };

    // setup drawer - MEMO: these must be called after axis updated
    if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
      var indices = $$.getShapeIndices($$.isLineType);

      if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
        var _indices = $$.getShapeIndices($$.isAreaType);

        shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
      }
    }

    if ($$.hasType("bar")) {
      var _indices2 = $$.getShapeIndices($$.isBarType);

      shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
    }

    return (!$$.hasArcType() || hasRadar) && (shape.pos = {
      xForText: $$.generateXYForText(shape.indices, !0),
      yForText: $$.generateXYForText(shape.indices, !1),
      // generate circle x/y functions depending on updated params
      cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
      cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
    }), shape;
  },
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        xs = config.data_xs,
        hasXs = notEmpty(xs),
        indices = {},
        i = hasXs ? {} : 0;
    return hasXs && getUnique(Object.keys(xs).map(function (v) {
      return xs[v];
    })).forEach(function (v) {
      i[v] = 0, indices[v] = {};
    }), $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, xKey = (d.id in xs) ? xs[d.id] : "", ind = xKey ? indices[xKey] : indices, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in ind) {
        ind[d.id] = ind[_row4];
        break;
      }

      isUndefined(ind[d.id]) && (ind[d.id] = xKey ? i[xKey]++ : i++, ind.__max__ = (xKey ? i[xKey] : i) - 1);
    }), indices;
  },

  /**
   * Get indices value based on data ID value
   * @param {object} indices Indices object
   * @param {string} id Data id value
   * @returns {object} Indices object
   * @private
   */
  getIndices: function getIndices(indices, id) {
    var xs = this.config.data_xs;
    return notEmpty(xs) ? indices[xs[id]] : indices;
  },

  /**
   * Get indices max number
   * @param {object} indices Indices object
   * @returns {number} Max number
   * @private
   */
  getIndicesMax: function getIndicesMax(indices) {
    return notEmpty(this.config.data_xs) ? // if is multiple xs, return total sum of xs' __max__ value
    Object.keys(indices).map(function (v) {
      return indices[v].__max__ || 0;
    }).reduce(function (acc, curr) {
      return acc + curr;
    }) : indices.__max__;
  },
  getShapeX: function getShapeX(offset, indices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        currScale = isSub ? scale.subX : scale.zoom || scale.x,
        barPadding = config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var ind = $$.getIndices(indices, d.id),
          index = d.id in ind ? ind[d.id] : 0,
          targetsNum = (ind.__max__ || 0) + 1,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = currScale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
      return $$.getYScaleById(d.id, isSub)(value);
    };
  },

  /**
   * Get shape based y Axis min value
   * @param {string} id Data id
   * @returns {number}
   * @private
   */
  getShapeYMin: function getShapeYMin(id) {
    var $$ = this,
        _$$$scale$$$$axis$get = $$.scale[$$.axis.getId(id)].domain(),
        yMin = _$$$scale$$$$axis$get[0];

    return !$$.isGrouped(id) && yMin > 0 ? yMin : 0;
  },

  /**
   * Get Shape's offset data
   * @param {Function} typeFilter Type filter function
   * @returns {object}
   * @private
   */
  getShapeOffsetData: function getShapeOffsetData(typeFilter) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        isStackNormalized = $$.isStackNormalized(),
        shapeOffsetTargets = targets.map(function (target) {
      var rowValues = target.values,
          values = {};
      $$.isStepType(target) && (rowValues = $$.convertValuesToStep(rowValues));
      var rowValueMapByXValue = rowValues.reduce(function (out, d) {
        var key = +d.x;
        return out[key] = d, values[key] = isStackNormalized ? $$.getRatio("index", d, !0) : d.value, out;
      }, {});
      return {
        id: target.id,
        rowValues: rowValues,
        rowValueMapByXValue: rowValueMapByXValue,
        values: values
      };
    }),
        indexMapByTargetId = targets.reduce(function (out, _ref, index) {
      var id = _ref.id;
      return out[id] = index, out;
    }, {});
    return {
      indexMapByTargetId: indexMapByTargetId,
      shapeOffsetTargets: shapeOffsetTargets
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        _$$$getShapeOffsetDat = $$.getShapeOffsetData(typeFilter),
        shapeOffsetTargets = _$$$getShapeOffsetDat.shapeOffsetTargets,
        indexMapByTargetId = _$$$getShapeOffsetDat.indexMapByTargetId;

    return function (d, idx) {
      var ind = $$.getIndices(indices, d.id),
          scale = $$.getYScaleById(d.id, isSub),
          y0 = scale($$.getShapeYMin(d.id)),
          dataXAsNumber = +d.x,
          offset = y0;
      return shapeOffsetTargets.filter(function (t) {
        return t.id !== d.id;
      }).forEach(function (t) {
        if (ind[t.id] === ind[d.id] && indexMapByTargetId[t.id] < indexMapByTargetId[d.id]) {
          var row = t.rowValues[idx]; // check if the x values line up

          row && +row.x === dataXAsNumber || (row = t.rowValueMapByXValue[dataXAsNumber]), row && row.value * d.value >= 0 && (offset += scale(t.values[dataXAsNumber]) - y0);
        }
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScaleById(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        config = $$.config,
        type = config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? config.line_step_type : "linear";
  }
});
// CONCATENATED MODULE: ./src/config/resolver/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Axis based chart
 */
// Chart









 // ChartInternal















var axis_api = [api_axis, api_category, api_flow, grid_x, grid_y, group, api_regions, api_selection, api_x, api_zoom];
var internal = [interactions_drag, interactions_flow, interactions_subchart, interactions_zoom, internals_clip, internals_grid, region, internals_selection, eventrect, ChartInternal_shape_bar, shape_bubble, ChartInternal_shape_line, shape_point, shape_shape];
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(48);

// CONCATENATED MODULE: ./src/ChartInternal/shape/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var shape_arc = ({
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        dataType = config.data_type,
        padding = config.pie_padding,
        startingAngle = config[dataType + "_startingAngle"] || 0,
        padAngle = ($$.hasType("pie") && padding ? padding * .01 : config[dataType + "_padAngle"]) || 0,
        sortValue = $$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().startAngle(startingAngle).endAngle(startingAngle + 2 * Math.PI).padAngle(padAngle).sortValues(sortValue).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width,
        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * config.gauge_arcs_minWidth;
    state.radiusExpanded = Math.min(state.arcWidth, state.arcHeight) / 2 * ($$.hasMultiArcGauge() ? .85 : 1), state.radius = state.radiusExpanded * .95, state.innerRadiusRatio = w ? (state.radius - w) / state.radius : .6, state.gaugeArcWidth = w || (gaugeArcWidth <= state.radius - state.innerRadius ? state.radius - state.innerRadius : gaugeArcWidth <= state.radius ? gaugeArcWidth : state.radius);
    var innerRadius = radius || (padding ? padding * (state.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    state.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? state.radius * state.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        innerRadius = $$.state.innerRadius;
    return !isNumber(innerRadius) && d && (innerRadius = innerRadius[d.data.id] || 0), innerRadius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded();
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;
    var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
        gStart = config.gauge_startingAngle;

    if (d.data && $$.isGaugeType(d.data) && !$$.hasMultiArcGauge()) {
      // to prevent excluding total data sum during the init(when data.hide option is used), use $$.rendered state value
      var totalSum = $$.getTotalDataSum(state.rendered); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    if (pie($$.filterTargetsToShow()).forEach(function (t, i) {
      found || t.data.id !== d.data.id || (found = !0, d = t, d.index = i);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), d.data && $$.hasMultiArcGauge()) {
      var maxValue = $$.getMinMaxData().max[0].value; // if gauge_max less than maxValue, make maxValue to max value

      maxValue > config.gauge_max && (config.gauge_max = maxValue);
      var gMin = config.gauge_min,
          gMax = config.gauge_max,
          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
      d.startAngle = gStart, d.endAngle = gStart + radius / (gMax - gMin) * gValue;
    }

    return found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        state = $$.state,
        ir = $$.getInnerRadius(),
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index : state.radius;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : isNumber(ir) ? ir : 0;
    }),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        state = $$.state,
        newRate = rate || 1,
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        expandWidth = Math.min(state.radiusExpanded * newRate - state.radius, singleArcWidth * .8 - (1 - newRate) * 100),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index + expandWidth : state.radiusExpanded * newRate;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : state.innerRadius;
    });
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? (hasMultiArcGauge ? arc : arc.innerRadius($$.getInnerRadius(d)))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        radius = _$$$state.radius,
        radiusExpanded = _$$$state.radiusExpanded,
        updated = $$.updateAngle(d),
        translate = "";
    if (updated) if ($$.hasMultiArcGauge()) {
      var y1 = Math.sin(updated.endAngle - Math.PI / 2),
          x = Math.cos(updated.endAngle - Math.PI / 2) * (radiusExpanded + 25),
          y = y1 * (radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
      translate = "translate(" + x + "," + y + ")";
    } else if (!$$.hasType("gauge") || $$.data.targets.length > 1) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio.bind($$.api)(d, radius, h) : ratio : radius && (h ? (36 / radius > .375 ? 1.175 - 36 / radius : .8) * radius / h : 0), translate = "translate(" + x * ratio + "," + y * ratio + ")";
    }
    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this,
        hasGauge = $$.hasType("gauge");
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          ratio = $$.getRatio("arc", updated),
          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var value = (updated || d).value,
            text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, d.data.id).toString();
        setTextValue(node, text, [-1, 1], hasGauge);
      } else node.text("");
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var $$ = this,
        config = $$.config,
        format = config.gauge_label_extents;
    return isFunction(format) ? format.bind($$.api)(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        $el = $$.$el;

    // MEMO: avoid to cancel transition
    if (transiting) {
      var interval = setInterval(function () {
        transiting || (clearInterval(interval), $el.legend.selectAll("." + config_classes.legendItemFocused).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $el.svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).each(function (d) {
      if ($$.shouldExpand(d.data.id)) {
        var expandDuration = $$.getExpandConfig(d.data.id, "duration"),
            svgArcExpandedSub = $$.getSvgArcExpanded($$.getExpandConfig(d.data.id, "rate"));
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        svg = $$.$el.svg;

    if (!transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).selectAll("path").transition().duration(function (d) {
        return $$.getExpandConfig(d.data.id, "duration");
      }).attr("d", $$.svgArc), svg.selectAll("" + config_classes.arc).style("opacity", "1");
    }
  },

  /**
   * Get expand config value
   * @param {string} id data ID
   * @param {string} key config key: 'duration | rate'
   * @returns {number}
   * @private
   */
  getExpandConfig: function getExpandConfig(id, key) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config[type + "_expand_" + key] : {
      duration: 50,
      rate: .98
    }[key];
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config[v + "_label_show"];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), isFunction(format) ? format.bind($$.api) : format;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config[type + "_title"] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.$el.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select("." + config_classes.chartArcs).selectAll("." + config_classes.chartArc).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this,
        $el = $$.$el;
    $el.arcs = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.$el.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arc).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), $$.hasMultiArcGauge() && $$.redrawMultiArcGauge(), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      state.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      var color;
      return $$.levelColor ? (color = $$.levelColor(d.data.values[0].value), config.data_colors[d.data.id] = color) : color = $$.color(d.data.id), color;
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call(endall, function () {
      if ($$.levelColor) {
        var path = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            d = path.datum();
        $$.updateLegendItemColor(d.data.id, path.style("fill"));
      }

      state.transiting = !1, callFn(config.onrendered, $$.api);
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  redrawMultiArcGauge: function redrawMultiArcGauge() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        arcLabelLines = $el.main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arcLabelLine).data($$.arcData.bind($$)),
        mainArcLabelLine = arcLabelLines.enter().append("rect").attr("class", function (d) {
      return config_classes.arcLabelLine + " " + config_classes.target + " " + config_classes.target + "-" + d.data.id;
    }).merge(arcLabelLines);
    mainArcLabelLine.style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
    }).style("display", config.gauge_label_show ? "" : "none").each(function (d) {
      var lineLength = 0,
          lineThickness = 2,
          x = 0,
          y = 0,
          transform = "";

      if (hiddenTargetIds.indexOf(d.data.id) < 0) {
        var updated = $$.updateAngle(d),
            innerLineLength = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
            lineAngle = updated.endAngle - Math.PI / 2,
            arcInnerRadius = state.radius - innerLineLength,
            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
        lineLength = state.radiusExpanded - state.radius + innerLineLength, x = Math.cos(linePositioningAngle) * arcInnerRadius, y = Math.sin(linePositioningAngle) * arcInnerRadius, transform = "rotate(" + lineAngle * 180 / Math.PI + ", " + x + ", " + y + ")";
      }

      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr("x", x).attr("y", y).attr("width", lineLength).attr("height", lineThickness).attr("transform", transform).style("stroke-dasharray", "0, " + (lineLength + lineThickness) + ", 0");
    });
  },
  bindArcEvent: function bindArcEvent(arc) {
    // eslint-disable-next-line
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    } // eslint-disable-next-line


    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        isMouse = state.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), config.data_onclick.bind($$.api)(arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!state.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.$el.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var text,
        $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        arcs = _$$$$el.arcs,
        hasGauge = $$.hasType("gauge"),
        hasMultiArcGauge = $$.hasMultiArcGauge();

    if (hasGauge && $$.data.targets.length === 1 && config.gauge_title || (text = main.selectAll("." + config_classes.chartArc).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ? Math.round(state.radius / 5) + "px" : null;
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    }), hasMultiArcGauge && text.attr("dy", "-.1em")), main.select("." + config_classes.chartArcsTitle).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          startAngle = -1 * Math.PI / 2,
          endAngle = (isFullCircle ? -4 : -1) * startAngle;
      isFullCircle && text && text.attr("dy", "" + Math.round(state.radius / 14));
      var backgroundArc = $$.$el.arcs.select((hasMultiArcGauge ? "g" : "") + "." + config_classes.chartArcsBackground);

      if (hasMultiArcGauge) {
        var index = 0;
        backgroundArc = backgroundArc.selectAll("path." + config_classes.chartArcsBackground).data($$.data.targets), backgroundArc.enter().append("path").attr("class", function (d, i) {
          return config_classes.chartArcsBackground + " " + config_classes.chartArcsBackground + "-" + i;
        }).merge(backgroundArc).attr("d", function (d1) {
          if (state.hiddenTargetIds.indexOf(d1.id) >= 0) return "M 0 0";
          var d = {
            data: [{
              value: config.gauge_max
            }],
            startAngle: startAngle,
            endAngle: endAngle,
            index: index++
          };
          return $$.getArc(d, !0, !0);
        }), backgroundArc.exit().remove();
      } else backgroundArc.attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: startAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      });

      arcs.select("." + config_classes.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && (arcs.select("." + config_classes.chartArcsGaugeMin).attr("dx", -1 * (state.innerRadius + (state.radius - state.innerRadius) / (isFullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && arcs.select("." + config_classes.chartArcsGaugeMax).attr("dx", state.innerRadius + (state.radius - state.innerRadius) / 2 + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.$el.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append($$.hasMultiArcGauge() ? "g" : "path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Get the position value
 * @param {boolean} isClockwise If the direction is clockwise
 * @param {string} type Coordinate type 'x' or 'y'
 * @param {number} edge Number of edge
 * @param {number} pos The indexed position
 * @param {number} range Range value
 * @param {number} ratio Ratio value
 * @returns {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = KEY.radarPoints;
/* harmony default export */ var ChartInternal_shape_radar = ({
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        $el = $$.$el;
    $$.hasType("radar") && ($el.radar = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartRadars), $el.radar.levels = $el.radar.append("g").attr("class", config_classes.levels), $el.radar.axes = $el.radar.append("g").attr("class", config_classes.axis), $el.radar.shapes = $el.radar.append("g").attr("class", config_classes.shapes), current.dataMax = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        arcWidth = _$$$state.arcWidth,
        arcHeight = _$$$state.arcHeight,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min(arcWidth, arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        width = _$$$getRadarSize[0],
        height = _$$$getRadarSize[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize2 = $$.getRadarSize(),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        points = $$.cache.get(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.cache.add(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(durationForExit) {
    var $$ = this,
        _$$$$el = $$.$el,
        radar = _$$$$el.radar,
        main = _$$$$el.main,
        translate = $$.getTranslate("radar");
    translate && (radar.attr("transform", translate), main.selectAll("." + config_classes.circles).attr("transform", translate), main.select("." + config_classes.chartTexts).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var points = this.cache.get(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radar = $$.$el.radar,
        _$$$getRadarSize3 = $$.getRadarSize(),
        width = _$$$getRadarSize3[0],
        height = _$$$getRadarSize3[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = radar.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = (config.radar_level_text_format || function () {}).bind($$.api),
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll("." + config_classes.level).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return config_classes.level + " " + config_classes.level + "-" + i;
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat(state.current.dataMax / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(" + (width - levelRatio[d]) + ", " + (height - levelRatio[d]) + ")";
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        radar = $$.$el.radar,
        _$$$getRadarSize4 = $$.getRadarSize(),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        categories = config.axis_x_categories,
        axis = radar.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return config_classes.axis + "-" + i;
    });

    // axis text
    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show) {
      var _config$radar_axis_te = config.radar_axis_text_position,
          _config$radar_axis_te2 = _config$radar_axis_te.x,
          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
          _config$radar_axis_te3 = _config$radar_axis_te.y,
          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
        selection.each(function (d) {
          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
        });
      }).datum(function (d, i) {
        return {
          index: i
        };
      }).attr("transform", function (d) {
        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(" + posX + " " + posY + ")";
      });
    }

    $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var $$ = this,
        config = $$.config,
        _$$$state2 = $$.state,
        inputType = _$$$state2.inputType,
        transiting = _$$$state2.transiting,
        _$$$$el2 = $$.$el,
        radar = _$$$$el2.radar,
        svg = _$$$$el2.svg,
        focusOnly = config.point_focus_only;

    if (config.interaction_enabled) {
      var isMouse = inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && ($$.hideTooltip(), focusOnly ? $$.hideCircleFocus() : $$.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      radar.axes.selectAll("text").on(isMouse ? "mouseover " : "touchstart", function () {
        if (!transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle(svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.cache.get(radar_cacheKey),
        areas = $$.$el.radar.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).style("fill", $$.color).style("stroke", $$.color).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/config/resolver/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Arc based chart
 */
// shape


var arc_internal = [shape_arc, ChartInternal_shape_radar];
// CONCATENATED MODULE: ./src/ChartInternal/ChartInternal.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */








 // Axis

 // data



 // interactions

 // internals


 // used to retrieve radar Axis name















/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */

var ChartInternal_ChartInternal = /*#__PURE__*/function () {
  // API interface
  // config object
  // cache instance
  // elements
  // state variables
  // all Chart instances array within page (equivalent of 'bb.instances')
  // data object
  // Axis
  // Axis
  // scales
  // original values
  // formatter function
  // format function
  function ChartInternal(api) {
    _defineProperty(this, "api", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "cache", void 0), _defineProperty(this, "$el", void 0), _defineProperty(this, "state", void 0), _defineProperty(this, "charts", void 0), _defineProperty(this, "data", {
      xs: {},
      targets: []
    }), _defineProperty(this, "axis", void 0), _defineProperty(this, "scale", {
      x: null,
      y: null,
      y2: null,
      subX: null,
      subY: null,
      subY2: null,
      zoom: null
    }), _defineProperty(this, "org", {
      xScale: null,
      xDomain: null
    }), _defineProperty(this, "color", void 0), _defineProperty(this, "patterns", void 0), _defineProperty(this, "levelColor", void 0), _defineProperty(this, "point", void 0), _defineProperty(this, "brush", void 0), _defineProperty(this, "format", {
      extraLineClasses: null,
      xAxisTick: null,
      dataTime: null,
      // dataTimeFormat
      defaultAxisTime: null,
      // defaultAxisTimeFormat
      axisTime: null // axisTimeFormat

    });
    var $$ = this;
    $$.api = api, $$.config = new Options(), $$.cache = new Cache_Cache();
    var store = new Store();
    $$.$el = store.getStore("element"), $$.state = store.getStore("state");
  }

  var _proto = ChartInternal.prototype;
  return _proto.beforeInit = function beforeInit() {
    var $$ = this;
    $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$.api);
  }, _proto.afterInit = function afterInit() {
    var $$ = this;
    $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$.api);
  }, _proto.init = function init() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    state.hasAxis = !$$.hasArcType(), state.hasRadar = !state.hasAxis && $$.hasType("radar"), $$.initParams();
    var bindto = {
      element: config.bindto,
      classname: "bb"
    };
    isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $el.chart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $el.chart.empty() && ($el.chart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.body.appendChild(browser_doc.createElement("div")))), $el.chart.html("").classed(bindto.classname, !0), $$.initToRender();
  }
  /**
   * Initialize the rendering process
   * @param {boolean} forced Force to render process
   * @private
   */
  , _proto.initToRender = function initToRender(forced) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        chart = $$.$el.chart,
        isHidden = function () {
      return chart.style("display") === "none" || chart.style("visibility") === "hidden";
    },
        isLazy = config.render.lazy || isHidden(),
        MutationObserver = win.MutationObserver;

    if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
      isHidden() || (observer.disconnect(), !state.rendered && $$.initToRender(!0));
    }).observe(chart.node(), {
      attributes: !0,
      attributeFilter: ["class", "style"]
    }), !isLazy || forced) {
      var convertedData = $$.convertData(config, $$.initWithData);
      convertedData && $$.initWithData(convertedData), $$.afterInit();
    }
  }, _proto.initParams = function initParams() {
    var $$ = this,
        _ref = $$,
        config = _ref.config,
        format = _ref.format,
        state = _ref.state,
        isRotated = config.axis_rotated;

    if (state.datetimeId = "bb-" + +new Date(), $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.hasPointType() && ($$.point = $$.generatePoint()), state.hasAxis) {
      $$.initClip(), format.extraLineClasses = $$.generateExtraLineClass(), format.dataTime = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], format.axisTime = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";

      format.defaultAxisTime = function (d) {
        var _$$$scale = $$.scale,
            x = _$$$scale.x,
            zoom = _$$$scale.zoom,
            isZoomed = isDragZoom ? zoom : zoom && x.orgDomain().toString() !== zoom.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return format.axisTime(specifier)(d);
      };
    }

    state.isLegendRight = config.legend_position === "right", state.isLegendInset = config.legend_position === "inset", state.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", state.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", state.rotatedPaddingRight = isRotated && !config.axis_x_show ? 0 : 30, state.inputType = convertInputType(config.interaction_inputType_mouse, config.interaction_inputType_touch);
  }, _proto.initWithData = function initWithData(data) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        $el = $$.$el,
        org = $$.org,
        hasAxis = state.hasAxis;
    hasAxis && ($$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom()), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter.bind($$.api))), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.updateSizes(), $$.updateScales(!0);
    // retrieve scale after the 'updateScales()' is called
    var x = scale.x,
        y = scale.y,
        y2 = scale.y2,
        subX = scale.subX,
        subY = scale.subY,
        subY2 = scale.subY2; // Set domains for each scale

    if (x && (x.domain(util_sortValue($$.getXDomain($$.data.targets))), subX.domain(x.domain()), org.xDomain = x.domain()), y && (y.domain($$.getYDomain($$.data.targets, "y")), subY.domain(y.domain())), y2 && (y2.domain($$.getYDomain($$.data.targets, "y2")), subY2 && subY2.domain(y2.domain())), $el.svg = $el.chart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && state.inputType) {
      var isTouch = state.inputType === "touch";
      $el.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
        return callFn(config.onover, $$.api);
      }).on(isTouch ? "touchend" : "mouseleave", function () {
        return callFn(config.onout, $$.api);
      });
    }

    config.svg_classname && $el.svg.attr("class", config.svg_classname);
    // Define defs
    var hasColorPatterns = isFunction(config.color_tiles) && $$.patterns;
    (hasAxis || hasColorPatterns) && ($el.defs = $el.svg.append("defs"), hasAxis && ["id", "idXAxis", "idYAxis", "idXAxisTickTexts", "idGrid"].forEach(function (v) {
      $$.appendClip($el.defs, state.clip[v]);
    }), hasColorPatterns && $$.patterns.forEach(function (p) {
      return $el.defs.append(function () {
        return p.node;
      });
    })), $$.updateSvgSize(), $$.bindResize();
    // Define regions
    var main = $el.svg.append("g").attr("transform", $$.getTranslate("main"));

    // data.onmin/max callback
    if ($el.main = main, config.subchart_show && $$.initSubchart(), config.tooltip_show && $$.initTooltip(), config.title_text && $$.initTitle(), config.legend_show && $$.initLegend(), config.data_empty_label_text && main.append("text").attr("class", config_classes.text + " " + config_classes.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
    .attr("dominant-baseline", "middle"), hasAxis && (config.regions.length && $$.initRegion(), !config.clipPath && $$.axis.init()), main.append("g").attr("class", config_classes.chart).attr("clip-path", state.clip.path), $$.callPluginHook("$init"), hasAxis && ($$.initEventRect && $$.initEventRect(), $$.initGrid(), config.clipPath && $$.axis && $$.axis.init()), $$.initChartElements(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$.api), $$.setBackground(), $$.redraw({
      withTransition: !1,
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withTransitionForAxis: !1,
      initializing: !0
    }), config.data_onmin || config.data_onmax) {
      var minMax = $$.getMinMaxData();
      callFn(config.data_onmin, $$.api, minMax.min), callFn(config.data_onmax, $$.api, minMax.max);
    }

    state.rendered = !0;
  }, _proto.initChartElements = function initChartElements() {
    var $$ = this,
        _$$$state = $$.state,
        hasAxis = _$$$state.hasAxis,
        hasRadar = _$$$state.hasRadar,
        types = [];
    hasAxis ? ($$.hasType("bar") && types.push("Bar"), $$.hasType("bubble") && types.push("Bubble"), $$.hasTypeOf("Line") && types.push("Line")) : (!hasRadar && types.push("Arc", "Pie"), $$.hasType("gauge") ? types.push("Gauge") : hasRadar && types.push("Radar")), types.forEach(function (v) {
      $$["init" + v]();
    }), notEmpty($$.config.data_labels) && $$.initText();
  }, _proto.setChartElements = function setChartElements() {
    var $$ = this,
        _$$$$el = $$.$el,
        chart = _$$$$el.chart,
        svg = _$$$$el.svg,
        defs = _$$$$el.defs,
        main = _$$$$el.main,
        tooltip = _$$$$el.tooltip,
        legend = _$$$$el.legend,
        title = _$$$$el.title,
        grid = _$$$$el.grid,
        arc = _$$$$el.arcs,
        circles = _$$$$el.circle,
        bars = _$$$$el.bar,
        lines = _$$$$el.line,
        areas = _$$$$el.area,
        texts = _$$$$el.text;
    $$.api.$ = {
      chart: chart,
      svg: svg,
      defs: defs,
      main: main,
      tooltip: tooltip,
      legend: legend,
      title: title,
      grid: grid,
      arc: arc,
      circles: circles,
      bar: {
        bars: bars
      },
      line: {
        lines: lines,
        areas: areas
      },
      text: {
        texts: texts
      }
    };
  }
  /**
   * Set background element/image
   * @private
   */
  , _proto.setBackground = function setBackground() {
    var $$ = this,
        bg = $$.config.background,
        state = $$.state,
        svg = $$.$el.svg;

    if (notEmpty(bg)) {
      var element = svg.select("g").insert(bg.imgUrl ? "image" : "rect", ":first-child");
      bg.imgUrl ? element.attr("href", bg.imgUrl) : bg.color && element.style("fill", bg.color).attr("clip-path", state.clip.path), element.attr("class", bg.class || null).attr("width", "100%").attr("height", "100%");
    }
  }
  /**
   * Update targeted element with given data
   * @param {object} targets Data object formatted as 'target'
   * @private
   */
  , _proto.updateTargets = function updateTargets(targets) {
    var $$ = this,
        _$$$state2 = $$.state,
        hasAxis = _$$$state2.hasAxis,
        hasRadar = _$$$state2.hasRadar;
    $$.updateTargetsForText(targets), ($$.hasPointType() || hasRadar) && $$.updateTargetForCircle(), hasAxis ? ($$.hasType("bar") && $$.updateTargetsForBar(targets), $$.hasTypeOf("Line") && $$.updateTargetsForLine(targets), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets)) : $$.hasArcType(targets) && (hasRadar ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.showTargets();
  }
  /**
   * Display targeted elements
   * @private
   */
  , _proto.showTargets = function showTargets() {
    var $$ = this,
        config = $$.config,
        svg = $$.$el.svg;
    svg.selectAll("." + config_classes.target).filter(function (d) {
      return $$.isTargetToShow(d.id);
    }).transition().duration(config.transition_duration).style("opacity", "1");
  }, _proto.getWithOption = function getWithOption(options) {
    var withOptions = {
      Y: !0,
      Subchart: !0,
      Transition: !0,
      EventRect: !0,
      Dimension: !0,
      TrimXDomain: !0,
      Transform: !1,
      UpdateXDomain: !1,
      UpdateOrgXDomain: !1,
      Legend: !1,
      UpdateXAxis: "UpdateXDomain",
      TransitionForExit: "Transition",
      TransitionForAxis: "Transition"
    };
    return Object.keys(withOptions).forEach(function (key) {
      var defVal = withOptions[key];
      isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with" + key, defVal);
    }), withOptions;
  }, _proto.initialOpacity = function initialOpacity(d) {
    var $$ = this,
        withoutFadeIn = $$.state.withoutFadeIn;
    return $$.getBaseValue(d) !== null && withoutFadeIn[d.id] ? "1" : "0";
  }, _proto.bindResize = function bindResize() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        resizeFunction = generateResize(),
        list = [];
    list.push(function () {
      return callFn(config.onresize, $$, $$.api);
    }), config.resize_auto && list.push(function () {
      state.resizing = !0, $$.api.flush(!1);
    }), list.push(function () {
      callFn(config.onresized, $$, $$.api), state.resizing = !1;
    }), list.forEach(function (v) {
      return resizeFunction.add(v);
    }), $$.resizeFunction = resizeFunction, win.addEventListener("resize", $$.resizeFunction = resizeFunction);
  }
  /**
   * Call plugin hook
   * @param {string} phase The lifecycle phase
   * @param {Array} args Arguments
   * @private
   */
  , _proto.callPluginHook = function callPluginHook(phase) {
    for (var _this = this, _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

    this.config.plugins.forEach(function (v) {
      phase === "$beforeInit" && (v.$$ = _this, _this.api.plugins.push(v)), v[phase].apply(v, args);
    });
  }, ChartInternal;
}();


extend(ChartInternal_ChartInternal.prototype, [// common
data_convert, ChartInternal_data_data, data_load, category, internals_class, internals_color, internals_domain, interactions_interaction, internals_format, internals_legend, internals_redraw, internals_scale, internals_size, internals_text, internals_title, internals_tooltip, internals_transform, internals_type].concat(arc_internal, internal));
// CONCATENATED MODULE: ./src/config/config.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Load configuration option
 * @param {object} config User's generation config value
 * @private
 */
function loadConfig(config) {
  var target,
      keys,
      read,
      thisConfig = this.config,
      find = function () {
    var key = keys.shift();
    return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
  };

  Object.keys(thisConfig).forEach(function (key) {
    target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
  });
}
// CONCATENATED MODULE: ./src/Chart/api/chart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_chart = ({
  /**
   * Resize the chart.
   * @function resize
   * @instance
   * @memberof Chart
   * @param {object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state;
    state.rendered && (config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0), $$.resizeFunction());
  },

  /**
   * Force to redraw.
   * @function flush
   * @instance
   * @memberof Chart
   * @param {boolean} [soft] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft) {
    var $$ = this.internal,
        state = $$.state;
    state.rendered ? (state.resizing ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.scale.zoom = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    })) : $$.initToRender(!0);
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @function destroy
   * @instance
   * @memberof Chart
   * @returns {null}
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal,
        _$$$$el = $$.$el,
        chart = _$$$$el.chart,
        svg = _$$$$el.svg;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), svg.select("*").interrupt(), $$.resizeFunction.clear(), win.removeEventListener("resize", $$.resizeFunction), chart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @function config
   * @instance
   * @memberof Chart
   * @param {string} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @returns {*}
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function (name, value, redraw) {
    var res,
        $$ = this.internal,
        config = $$.config,
        key = name && name.replace(/\./g, "_");
    return key in config && (isDefined(value) ? (config[key] = value, res = value, redraw && this.flush()) : res = config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_color = ({
  /**
   * Get the color
   * @function color
   * @instance
   * @memberof Chart
   * @param {string} id id to get the color
   * @returns {string}
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/Chart/api/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get data loaded in the chart.
 * @function data
 * @instance
 * @memberof Chart
 * @param {string|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @returns {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */
function api_data_data(targetIds) {
  var targets = this.internal.data.targets;

  if (!isUndefined(targetIds)) {
    var ids = isArray(targetIds) ? targetIds : [targetIds];
    return targets.filter(function (t) {
      return ids.some(function (v) {
        return v === t.id;
      });
    });
  }

  return targets;
}

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @function data․shown
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @returns {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @function data․values
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @param {boolean} [flat=true] Get flatten values
   * @returns {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetIds, flat) {
    flat === void 0 && (flat = !0);
    var values = null;

    if (targetIds) {
      var targets = this.data(targetIds);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @function data․names
   * @instance
   * @memberof Chart
   * @param {object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @returns {object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    var $$ = this.internal; // reset existing legend item dimension cache data

    return $$.cache.remove(KEY.legendItemTextBox), $$.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @function data․colors
   * @instance
   * @memberof Chart
   * @param {object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @returns {object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @function data․axes
   * @instance
   * @memberof Chart
   * @param {object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @returns {object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @function data․min
   * @instance
   * @memberof Chart
   * @returns {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @function data․max
   * @instance
   * @memberof Chart
   * @returns {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
});
/* harmony default export */ var api_data = ({
  data: api_data_data
});
// CONCATENATED MODULE: ./src/Chart/api/export.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Encode to base64
 * @param {string} str string to be encoded
 * @returns {string}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode(+("0x" + p));
  }));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node target node
 * @param {object} size object containing {width, height}
 * @returns {string}
 * @private
 */


function nodeToSvgDataUrl(node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser_doc.styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser_doc.createElement("style"); // escape css for XML

  style.appendChild(browser_doc.createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = ("<svg xmlns=\"" + external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg + "\" width=\"" + size.width + "\" height=\"" + size.height + "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t" + styleXml + "\n\t\t\t\t" + nodeXml.replace(/(url\()[^#]+/g, "$1") + "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64," + b64EncodeUnicode(dataStr);
}

/* harmony default export */ var api_export = ({
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @function export
   * @instance
   * @memberof Chart
   * @param {string} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @returns {string} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  export: function _export(mimeType, callback) {
    var _this = this,
        $$ = this.internal,
        state = $$.state,
        chart = $$.$el.chart,
        _state$current = state.current,
        width = _state$current.width,
        height = _state$current.height,
        svgDataUrl = nodeToSvgDataUrl(chart.node(), {
      width: width,
      height: height
    });

    if (callback && isFunction(callback)) {
      var img = new Image();
      img.crossOrigin = "Anonymous", img.onload = function () {
        var canvas = browser_doc.createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = width, canvas.height = height, ctx.drawImage(img, 0, 0), callback.bind(_this)(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/focus.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_focus = ({
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @function focus
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && !state.hasRadar && ($$.expandArc(targetIds), $$.hasType("gauge") && $$.markOverlapped(targetIdsValue, $$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !0), state.focusedTargetIds = targetIds, state.defocusedTargetIds = state.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @function defocus
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && ($$.unexpandArc(targetIds), $$.hasType("gauge") && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !1), state.focusedTargetIds = state.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), state.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @function revert
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $el.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $el.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), state.focusedTargetIds = [], state.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/Chart/api/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define legend
 * @ignore
 */
var legend_legend = {
  /**
   * Show legend for each target.
   * @function legend․show
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @function legend․hide
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
};
/* harmony default export */ var api_legend = ({
  legend: legend_legend
});
// CONCATENATED MODULE: ./src/Chart/api/load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var load = ({
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @function load
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded. Checkout the example. |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set request header if loading via `data.url`.<br>@see [data․headers](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [data․keys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [data․mimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json",
   *
   *     // set request header if is needed
   *     headers: {
   *       "Content-Type": "text/json"
   *     }
   * });
   * @example
   * chart.load({
   *     data: [
   *       // equivalent as: columns: [["data1", 30, 200, 100]]
   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
   *
   *       // or
   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
   *     ]
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.axis.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @function unload
   * @instance
   * @memberof Chart
   * @param {object} argsValue
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var _this = this,
        $$ = this.internal,
        args = argsValue || {};

    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.cache.remove(ids), args.done && args.done.call(_this);
    });
  }
});
// CONCATENATED MODULE: ./src/Chart/api/show.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Show/Hide data series
 * @param {boolean} show Show or hide
 * @param {Array} targetIdsValue Target id values
 * @param {object} options Options
 * @private
 */

function showHide(show, targetIdsValue, options) {
  var $$ = this.internal,
      targetIds = $$.mapToTargetIds(targetIdsValue);
  $$[(show ? "remove" : "add") + "HiddenTargetIds"](targetIds);
  var targets = $$.$el.svg.selectAll($$.selectorTargets(targetIds)),
      opacity = show ? "1" : "0";
  targets.transition().style("opacity", opacity, "important").call(endall, function () {
    targets.style("opacity", null).style("opacity", opacity);
  }), options.withLegend && $$[(show ? "show" : "hide") + "Legend"](targetIds), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0,
    withLegend: !0
  });
}

/* harmony default export */ var api_show = ({
  /**
   * Show data series on chart
   * @function show
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIdsValue] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @function hide
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIdsValue] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @function toggle
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIds] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds, options) {
    var _this = this;

    options === void 0 && (options = {});
    var $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };
    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/Chart/api/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define tooltip
 * @ignore
 */

var tooltip_tooltip = {
  /**
   * Show tooltip
   * @function tooltip․show
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {number &verbar; Date}: x Axis value<br>- index {number}: x Axis index (useless for data.xs)<br>- id {string}: data id<br>- value {number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.
   *  chart.tooltip.show({
   *    x: 2,
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show(args) {
    var index,
        mouse,
        $$ = this.internal,
        config = $$.config,
        inputType = $$.state.inputType;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var data = args.data,
          y = $$.getYScaleById(data.id)(data.value);
      $$.isMultipleX() ? mouse = [$$.scale.x(data.x), y] : (!config.tooltip_grouped && (mouse = [0, y]), index = isValue(data.index) ? data.index : $$.getIndexByX(data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    (inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @function tooltip․hide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal; // reset last touch point index

    $$.inputType === "touch" && $$.callOverOutForTouch(), $$.hideTooltip(!0), $$.hideGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
};
/* harmony default export */ var api_tooltip = ({
  tooltip: tooltip_tooltip
});
// CONCATENATED MODULE: ./src/Chart/Chart.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */













/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
 */

/**
 * Access instance's primary node elements
 * @member {object} $
 * @property {object} $ Access instance's primary node elements
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {d3.selection} $.circles Data point circle elements
 * @property {object} $.bar Bar element object
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {object} $.line Line element object
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {object} $.text Text element object
 * @property {d3.selection} $.text.texts Data label text elements
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

/**
 * Plugin instance array
 * @member {Array} plugins
 * @memberof Chart
 * @example
 *  var chart = bb.generate({
 *     ...
 *     plugins: [
 *        new bb.plugin.stanford({ ... }),
 *        new PluginA()
 *     ]
 *  });
 *
 *  chart.plugins; // [Stanford, PluginA] - instance array
 */

var Chart_Chart = function Chart(options) {
  _defineProperty(this, "plugins", []), _defineProperty(this, "internal", void 0);
  var ctx = this,
      $$ = new ChartInternal_ChartInternal(ctx); // const {type, types} = options.data;
  // let isArc = false;
  // if (type) {
  // 	isArc = TYPES.Arc.indexOf(type) > -1;
  // } else if (types) {
  // 	for (const x in types) {
  // 		if (TYPES.Arc.indexOf(types[x]) > -1) {
  // 			isArc = true;
  // 			break;
  // 		}
  // 	}
  // }

  // bind to namespaced APIs
  this.internal = $$, function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      var isFunc = isFunction(fn[key]),
          isChild = target !== argThis,
          hasChild = Object.keys(fn[key]).length > 0;
      isFunc && (!isChild && hasChild || isChild) ? target[key] = fn[key].bind(argThis) : !isFunc && (target[key] = {}), hasChild && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this), loadConfig.call($$, options), $$.beforeInit(), $$.init();
}; // extend common APIs as part of Chart class



extend(Chart_Chart.prototype, [api_chart, api_color, api_data, api_export, api_focus, api_legend, load, api_show, api_tooltip].concat(axis_api));
// CONCATENATED MODULE: ./src/index.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */

 // eslint-disable-next-line no-use-before-define


var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {string} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "2.0.0-alpha",

  /**
   * Generate chart
   * @param {Options} config chart options
   * @memberof bb
   * @returns {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @returns {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {}
};
/**
 * @namespace bb
 * @version 2.0.0-alpha
 */

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi94bWwtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc2VuZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvZ2V0Q3VycmVudFNjcmlwdFNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdCBzeW5jIG5vbnJlY3Vyc2l2ZSBeXFwuXFwvbG9nJCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYmlsbGJvYXJkLnNjc3M/MWI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYmlsbGJvYXJkLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJjb21tb25qczJcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJhbWRcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNlbGVjdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy1zZWxlY3Rpb25cIixcImFtZFwiOlwiZDMtc2VsZWN0aW9uXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWJydXNoXCIsXCJjb21tb25qczJcIjpcImQzLWJydXNoXCIsXCJhbWRcIjpcImQzLWJydXNoXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWF4aXNcIixcImNvbW1vbmpzMlwiOlwiZDMtYXhpc1wiLFwiYW1kXCI6XCJkMy1heGlzXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNjYWxlXCIsXCJjb21tb25qczJcIjpcImQzLXNjYWxlXCIsXCJhbWRcIjpcImQzLXNjYWxlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWRzdlwiLFwiY29tbW9uanMyXCI6XCJkMy1kc3ZcIixcImFtZFwiOlwiZDMtZHN2XCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWRyYWdcIixcImNvbW1vbmpzMlwiOlwiZDMtZHJhZ1wiLFwiYW1kXCI6XCJkMy1kcmFnXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXRyYW5zaXRpb25cIixcImNvbW1vbmpzMlwiOlwiZDMtdHJhbnNpdGlvblwiLFwiYW1kXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXpvb21cIixcImNvbW1vbmpzMlwiOlwiZDMtem9vbVwiLFwiYW1kXCI6XCJkMy16b29tXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWVhc2VcIixcImNvbW1vbmpzMlwiOlwiZDMtZWFzZVwiLFwiYW1kXCI6XCJkMy1lYXNlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWNvbG9yXCIsXCJjb21tb25qczJcIjpcImQzLWNvbG9yXCIsXCJhbWRcIjpcImQzLWNvbG9yXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNoYXBlXCIsXCJjb21tb25qczJcIjpcImQzLXNoYXBlXCIsXCJhbWRcIjpcImQzLXNoYXBlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWludGVycG9sYXRlXCIsXCJjb21tb25qczJcIjpcImQzLWludGVycG9sYXRlXCIsXCJhbWRcIjpcImQzLWludGVycG9sYXRlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jbGFzc2VzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvU3RvcmUvRWxlbWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL1N0b3JlL1N0YXRlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvU3RvcmUvU3RvcmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2RhdGEvZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL2NvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vaW50ZXJhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9sZWdlbmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi90aXRsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2RhdGEvYXhpcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvZGF0YS9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2F4aXMveC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy95LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9heGlzL3kyLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvYnJvd3Nlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlL3V0aWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2F4aXMvYXhpcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL2dyaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9wb2ludC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3N1YmNoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvYXJlYS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvYmFyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9idWJibGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL2xpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL3NwbGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvZG9udXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL2dhdWdlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9waWUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL3JhZGFyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9PcHRpb25zLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvQ2FjaGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZS9nZW5lcmF0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzUmVuZGVyZXJIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzUmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvZGF0YS5jb252ZXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9kYXRhL2RhdGEubG9hZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NsYXNzLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25zdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvZG9tYWluLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9mb3JtYXQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2xlZ2VuZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvcmVkcmF3LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zY2FsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvc2l6ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdGV4dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdGl0bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3RyYW5zZm9ybS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdHlwZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2Zsb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncmlkLngudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncmlkLnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncm91cC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3JlZ2lvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS94LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZHJhZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZmxvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZXZlbnRyZWN0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9zdWJjaGFydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2xpcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvcmVnaW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYmFyLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL2J1YmJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9saW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL3BvaW50LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL3NoYXBlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvcmVzb2x2ZXIvYXhpcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9hcmMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcmFkYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9yZXNvbHZlci9hcmMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQ2hhcnRJbnRlcm5hbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2NoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvZXhwb3J0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvZm9jdXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9sZWdlbmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9sb2FkLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvc2hvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L0NoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJhcmMiLCJhcmNMYWJlbExpbmUiLCJhcmNzIiwiYXJlYSIsImFyZWFzIiwiYXhpcyIsImF4aXNYIiwiYXhpc1hMYWJlbCIsImF4aXNZIiwiYXhpc1kyIiwiYXhpc1kyTGFiZWwiLCJheGlzWUxhYmVsIiwiYmFyIiwiYmFycyIsImJydXNoIiwiYnV0dG9uIiwiYnV0dG9uWm9vbVJlc2V0IiwiY2hhcnQiLCJjaGFydEFyYyIsImNoYXJ0QXJjcyIsImNoYXJ0QXJjc0JhY2tncm91bmQiLCJjaGFydEFyY3NHYXVnZU1heCIsImNoYXJ0QXJjc0dhdWdlTWluIiwiY2hhcnRBcmNzR2F1Z2VVbml0IiwiY2hhcnRBcmNzVGl0bGUiLCJjaGFydEFyY3NHYXVnZVRpdGxlIiwiY2hhcnRCYXIiLCJjaGFydEJhcnMiLCJjaGFydENpcmNsZXMiLCJjaGFydExpbmUiLCJjaGFydExpbmVzIiwiY2hhcnRSYWRhciIsImNoYXJ0UmFkYXJzIiwiY2hhcnRUZXh0IiwiY2hhcnRUZXh0cyIsImNpcmNsZSIsImNpcmNsZXMiLCJjb2xvclBhdHRlcm4iLCJjb2xvclNjYWxlIiwiZGVmb2N1c2VkIiwiZHJhZ2FyZWEiLCJlbXB0eSIsImV2ZW50UmVjdCIsImV2ZW50UmVjdHMiLCJldmVudFJlY3RzTXVsdGlwbGUiLCJldmVudFJlY3RzU2luZ2xlIiwiZm9jdXNlZCIsImdhdWdlVmFsdWUiLCJncmlkIiwiZ3JpZExpbmVzIiwibGVnZW5kQmFja2dyb3VuZCIsImxlZ2VuZEl0ZW0iLCJsZWdlbmRJdGVtRXZlbnQiLCJsZWdlbmRJdGVtRm9jdXNlZCIsImxlZ2VuZEl0ZW1IaWRkZW4iLCJsZWdlbmRJdGVtUG9pbnQiLCJsZWdlbmRJdGVtVGlsZSIsImxldmVsIiwibGV2ZWxzIiwibGluZSIsImxpbmVzIiwicmVnaW9uIiwicmVnaW9ucyIsInNlbGVjdGVkQ2lyY2xlIiwic2VsZWN0ZWRDaXJjbGVzIiwic2hhcGUiLCJzaGFwZXMiLCJzdGFuZm9yZEVsZW1lbnRzIiwic3RhbmZvcmRMaW5lIiwic3RhbmZvcmRMaW5lcyIsInN0YW5mb3JkUmVnaW9uIiwic3RhbmZvcmRSZWdpb25zIiwidGFyZ2V0IiwidGV4dCIsInRleHRzIiwidGl0bGUiLCJ0b29sdGlwIiwidG9vbHRpcENvbnRhaW5lciIsInRvb2x0aXBOYW1lIiwieGdyaWQiLCJ4Z3JpZEZvY3VzIiwieGdyaWRMaW5lIiwieGdyaWRMaW5lcyIsInhncmlkcyIsInlncmlkIiwieWdyaWRGb2N1cyIsInlncmlkTGluZSIsInlncmlkTGluZXMiLCJ5Z3JpZHMiLCJ6b29tQnJ1c2giLCJ6b29tUmVjdCIsIkVYUEFOREVEIiwiU0VMRUNURUQiLCJJTkNMVURFRCIsIlRleHRPdmVybGFwcGluZyIsIkVsZW1lbnQiLCJtYWluIiwic3ZnIiwieCIsInkiLCJ5MiIsInN1YlgiLCJkZWZzIiwibGVnZW5kIiwic3ViY2hhcnQiLCJyYWRhciIsImxpc3QiLCJTdGF0ZSIsIndpZHRoIiwid2lkdGgyIiwiaGVpZ2h0IiwiaGVpZ2h0MiIsIm1hcmdpbiIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsIm1hcmdpbjIiLCJtYXJnaW4zIiwiYXJjV2lkdGgiLCJhcmNIZWlnaHQiLCJ4QXhpc0hlaWdodCIsImhhc0F4aXMiLCJoYXNSYWRhciIsImN1cnJlbnQiLCJkYXRhTWF4IiwibWF4VGlja1dpZHRocyIsInNpemUiLCJ0aWNrcyIsImNsaXBQYXRoIiwiZG9tYWluIiwidHlwZXMiLCJpc0xlZ2VuZFJpZ2h0IiwiaXNMZWdlbmRJbnNldCIsImlzTGVnZW5kVG9wIiwiaXNMZWdlbmRMZWZ0IiwibGVnZW5kU3RlcCIsImxlZ2VuZEl0ZW1XaWR0aCIsImxlZ2VuZEl0ZW1IZWlnaHQiLCJsZWdlbmRIYXNSZW5kZXJlZCIsInBhZGRpbmciLCJ0aWNrQ291bnQiLCJyb3RhdGVkUGFkZGluZyIsIndpdGhvdXRGYWRlSW4iLCJpbnB1dFR5cGUiLCJkYXRldGltZUlkIiwiY2xpcCIsImlkIiwiaWRYQXhpcyIsImlkWUF4aXMiLCJpZFhBeGlzVGlja1RleHRzIiwiaWRHcmlkIiwiaWRTdWJjaGFydCIsInBhdGgiLCJwYXRoWEF4aXMiLCJwYXRoWUF4aXMiLCJwYXRoWEF4aXNUaWNrVGV4dHMiLCJwYXRoR3JpZCIsImRyYWdTdGFydCIsImRyYWdnaW5nIiwiZmxvd2luZyIsImNhbmNlbENsaWNrIiwibW91c2VvdmVyIiwicmVuZGVyZWQiLCJ0cmFuc2l0aW5nIiwicmVzaXppbmciLCJoYXNOZWdhdGl2ZVZhbHVlIiwiaGFzUG9zaXRpdmVWYWx1ZSIsIm9yZ0FyZWFPcGFjaXR5IiwiaGlkZGVuVGFyZ2V0SWRzIiwiaGlkZGVuTGVnZW5kSWRzIiwiZm9jdXNlZFRhcmdldElkcyIsImRlZm9jdXNlZFRhcmdldElkcyIsInJhZGl1cyIsImlubmVyUmFkaXVzIiwiaW5uZXJSYWRpdXNSYXRpbyIsImdhdWdlQXJjV2lkdGgiLCJyYWRpdXNFeHBhbmRlZCIsInhncmlkQXR0ciIsIngxIiwieDIiLCJ5MSIsImNsYXNzZXMiLCJlbGVtZW50Iiwic3RhdGUiLCJTdG9yZSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidiIsImdldFN0b3JlIiwibmFtZSIsImRhdGFfaWRDb252ZXJ0ZXIiLCJkYXRhX25hbWVzIiwiZGF0YV9jbGFzc2VzIiwiZGF0YV90eXBlIiwidW5kZWZpbmVkIiwiZGF0YV90eXBlcyIsImRhdGFfb3JkZXIiLCJkYXRhX2NvbG9yIiwiZGF0YV9jb2xvcnMiLCJkYXRhX2hpZGUiLCJkYXRhX2ZpbHRlciIsImRhdGFfb25jbGljayIsImRhdGFfb25vdmVyIiwiZGF0YV9vbm91dCIsImRhdGFfb25taW4iLCJkYXRhX29ubWF4IiwiZGF0YV91cmwiLCJkYXRhX2hlYWRlcnMiLCJkYXRhX2pzb24iLCJkYXRhX3Jvd3MiLCJkYXRhX2NvbHVtbnMiLCJkYXRhX21pbWVUeXBlIiwiZGF0YV9rZXlzIiwiZGF0YV9lbXB0eV9sYWJlbF90ZXh0IiwiY29sb3JfcGF0dGVybiIsImNvbG9yX3RpbGVzIiwiY29sb3JfdGhyZXNob2xkIiwiY29sb3Jfb25vdmVyIiwiaW50ZXJhY3Rpb25fZW5hYmxlZCIsImludGVyYWN0aW9uX2JyaWdodGVuIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoIiwibGVnZW5kX3Nob3ciLCJsZWdlbmRfaGlkZSIsImxlZ2VuZF9jb250ZW50c19iaW5kdG8iLCJsZWdlbmRfY29udGVudHNfdGVtcGxhdGUiLCJsZWdlbmRfcG9zaXRpb24iLCJsZWdlbmRfaW5zZXRfYW5jaG9yIiwibGVnZW5kX2luc2V0X3giLCJsZWdlbmRfaW5zZXRfeSIsImxlZ2VuZF9pbnNldF9zdGVwIiwibGVnZW5kX2l0ZW1fb25jbGljayIsImxlZ2VuZF9pdGVtX29ub3ZlciIsImxlZ2VuZF9pdGVtX29ub3V0IiwibGVnZW5kX2VxdWFsbHkiLCJsZWdlbmRfcGFkZGluZyIsImxlZ2VuZF9pdGVtX3RpbGVfd2lkdGgiLCJsZWdlbmRfaXRlbV90aWxlX2hlaWdodCIsImxlZ2VuZF91c2VQb2ludCIsInRpdGxlX3RleHQiLCJ0aXRsZV9wYWRkaW5nIiwidGl0bGVfcG9zaXRpb24iLCJ0b29sdGlwX3Nob3ciLCJ0b29sdGlwX2RvTm90SGlkZSIsInRvb2x0aXBfZ3JvdXBlZCIsInRvb2x0aXBfZm9ybWF0X3RpdGxlIiwidG9vbHRpcF9mb3JtYXRfbmFtZSIsInRvb2x0aXBfZm9ybWF0X3ZhbHVlIiwidG9vbHRpcF9wb3NpdGlvbiIsInRvb2x0aXBfY29udGVudHMiLCJ0b29sdGlwX2luaXRfc2hvdyIsInRvb2x0aXBfaW5pdF94IiwidG9vbHRpcF9pbml0X3Bvc2l0aW9uIiwidG9vbHRpcF9saW5rZWQiLCJ0b29sdGlwX2xpbmtlZF9uYW1lIiwidG9vbHRpcF9vbnNob3ciLCJ0b29sdGlwX29uaGlkZSIsInRvb2x0aXBfb25zaG93biIsInRvb2x0aXBfb25oaWRkZW4iLCJ0b29sdGlwX29yZGVyIiwiZGF0YV94IiwiZGF0YV94cyIsImRhdGFfeEZvcm1hdCIsImRhdGFfeExvY2FsdGltZSIsImRhdGFfeFNvcnQiLCJkYXRhX2dyb3VwcyIsImRhdGFfYXhlcyIsImRhdGFfbGFiZWxzIiwiZGF0YV9sYWJlbHNfY29sb3JzIiwiZGF0YV9sYWJlbHNfcG9zaXRpb24iLCJkYXRhX3JlZ2lvbnMiLCJkYXRhX3N0YWNrX25vcm1hbGl6ZSIsImRhdGFfc2VsZWN0aW9uX2VuYWJsZWQiLCJkYXRhX3NlbGVjdGlvbl9ncm91cGVkIiwiZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlIiwiZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUiLCJkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUiLCJkYXRhX29uc2VsZWN0ZWQiLCJkYXRhX29udW5zZWxlY3RlZCIsImF4aXNfeF9jbGlwUGF0aCIsImF4aXNfeF9zaG93IiwiYXhpc194X3R5cGUiLCJheGlzX3hfbG9jYWx0aW1lIiwiYXhpc194X2NhdGVnb3JpZXMiLCJheGlzX3hfdGlja19jZW50ZXJlZCIsImF4aXNfeF90aWNrX2Zvcm1hdCIsImF4aXNfeF90aWNrX2N1bGxpbmciLCJheGlzX3hfdGlja19jdWxsaW5nX21heCIsImF4aXNfeF90aWNrX2NvdW50IiwiYXhpc194X3RpY2tfc2hvdyIsImF4aXNfeF90aWNrX3RleHRfc2hvdyIsImF4aXNfeF90aWNrX3RleHRfcG9zaXRpb24iLCJheGlzX3hfdGlja19maXQiLCJheGlzX3hfdGlja192YWx1ZXMiLCJheGlzX3hfdGlja19hdXRvcm90YXRlIiwiYXhpc194X3RpY2tfcm90YXRlIiwiYXhpc194X3RpY2tfb3V0ZXIiLCJheGlzX3hfdGlja19tdWx0aWxpbmUiLCJheGlzX3hfdGlja193aWR0aCIsImF4aXNfeF90aWNrX3Rvb2x0aXAiLCJheGlzX3hfbWF4IiwiYXhpc194X21pbiIsImF4aXNfeF9wYWRkaW5nIiwiYXhpc194X2hlaWdodCIsImF4aXNfeF9leHRlbnQiLCJheGlzX3hfbGFiZWwiLCJheGlzX3hfYXhlcyIsImF4aXNfeV9jbGlwUGF0aCIsImF4aXNfeV9zaG93IiwiYXhpc195X3R5cGUiLCJheGlzX3lfbWF4IiwiYXhpc195X21pbiIsImF4aXNfeV9pbnZlcnRlZCIsImF4aXNfeV9jZW50ZXIiLCJheGlzX3lfaW5uZXIiLCJheGlzX3lfbGFiZWwiLCJheGlzX3lfdGlja19mb3JtYXQiLCJheGlzX3lfdGlja19jdWxsaW5nIiwiYXhpc195X3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3lfdGlja19vdXRlciIsImF4aXNfeV90aWNrX3ZhbHVlcyIsImF4aXNfeV90aWNrX3JvdGF0ZSIsImF4aXNfeV90aWNrX2NvdW50IiwiYXhpc195X3RpY2tfc2hvdyIsImF4aXNfeV90aWNrX3N0ZXBTaXplIiwiYXhpc195X3RpY2tfdGV4dF9zaG93IiwiYXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeV90aWNrX3RpbWVfdmFsdWUiLCJheGlzX3lfcGFkZGluZyIsImF4aXNfeV9kZWZhdWx0IiwiYXhpc195X2F4ZXMiLCJheGlzX3kyX3Nob3ciLCJheGlzX3kyX21heCIsImF4aXNfeTJfbWluIiwiYXhpc195Ml9pbnZlcnRlZCIsImF4aXNfeTJfY2VudGVyIiwiYXhpc195Ml9pbm5lciIsImF4aXNfeTJfbGFiZWwiLCJheGlzX3kyX3RpY2tfZm9ybWF0IiwiYXhpc195Ml90aWNrX2N1bGxpbmciLCJheGlzX3kyX3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3kyX3RpY2tfb3V0ZXIiLCJheGlzX3kyX3RpY2tfdmFsdWVzIiwiYXhpc195Ml90aWNrX3JvdGF0ZSIsImF4aXNfeTJfdGlja19jb3VudCIsImF4aXNfeTJfdGlja19zaG93IiwiYXhpc195Ml90aWNrX3N0ZXBTaXplIiwiYXhpc195Ml90aWNrX3RleHRfc2hvdyIsImF4aXNfeTJfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc195Ml9wYWRkaW5nIiwiYXhpc195Ml9kZWZhdWx0IiwiYXhpc195Ml9heGVzIiwid2luIiwiZGVmIiwibyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJnbG9iYWxUaGlzIiwiRnVuY3Rpb24iLCJkb2MiLCJkb2N1bWVudCIsImlzVmFsdWUiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzVW5kZWZpbmVkIiwiaXNEZWZpbmVkIiwiaXNib29sZWFuIiwiY2VpbDEwIiwiTWF0aCIsImNlaWwiLCJhc0hhbGZQaXhlbCIsIm4iLCJkaWZmRG9tYWluIiwiZCIsImlzT2JqZWN0VHlwZSIsImlzRW1wdHkiLCJsZW5ndGgiLCJEYXRlIiwiaXNOYU4iLCJub3RFbXB0eSIsImlzQXJyYXkiLCJhcnIiLCJBcnJheSIsImlzT2JqZWN0Iiwib2JqIiwibm9kZVR5cGUiLCJnZXRPcHRpb24iLCJvcHRpb25zIiwia2V5IiwiZGVmYXVsdFZhbHVlIiwiaGFzVmFsdWUiLCJkaWN0IiwidmFsdWUiLCJmb3VuZCIsImNhbGxGbiIsImZuIiwiaXNGbiIsImFyZ3MiLCJjYWxsIiwiZW5kYWxsIiwidHJhbnNpdGlvbiIsImNiIiwiZWFjaCIsIm9uIiwiYXBwbHkiLCJzYW5pdGlzZSIsInN0ciIsInJlcGxhY2UiLCJzZXRUZXh0VmFsdWUiLCJub2RlIiwiZHkiLCJ0b01pZGRsZSIsImluZGV4T2YiLCJkaWZmIiwibWFwIiwibXVsdGlsaW5lIiwic3BsaXQiLCJsZW4iLCJodG1sIiwiaSIsImFwcGVuZCIsImF0dHIiLCJnZXRSZWN0U2VnTGlzdCIsImdldEJCb3giLCJnZXRQYXRoQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaXRlbXMiLCJtaW4iLCJnZXRCcnVzaFNlbGVjdGlvbiIsInNlbGVjdGlvbiIsIiRlbCIsImV2ZW50IiwiZDNFdmVudCIsInR5cGUiLCJzZWxlY3QiLCJDTEFTUyIsImQzQnJ1c2hTZWxlY3Rpb24iLCJnZXRCb3VuZGluZ1JlY3QiLCJyZWN0IiwiZ2V0UmFuZG9tIiwiYXNTdHIiLCJyYW5kIiwicmFuZG9tIiwiYnJ1c2hFbXB0eSIsImN0eCIsImV4dGVuZCIsInNvdXJjZSIsInAiLCJ0ZXN0IiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ0b0FycmF5IiwiZ2V0Q3NzUnVsZXMiLCJzdHlsZVNoZWV0cyIsInJ1bGVzIiwic2hlZXQiLCJjc3NSdWxlcyIsImNvbmNhdCIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJocmVmIiwidG9TdHJpbmciLCJnZXRUcmFuc2xhdGlvbiIsInRyYW5zZm9ybSIsImJhc2VWYWwiLCJudW1iZXJPZkl0ZW1zIiwiZ2V0SXRlbSIsIm1hdHJpeCIsImEiLCJiIiwiYyIsImYiLCJnZXRVbmlxdWUiLCJkYXRhIiwiaXNEYXRlIiwiTnVtYmVyIiwiZmlsdGVyIiwibWVyZ2VBcnJheSIsInJlZHVjZSIsIm1lcmdlT2JqIiwib2JqZWN0TiIsInNoaWZ0Iiwic29ydFZhbHVlIiwiaXNBc2MiLCJldmVyeSIsInNvcnQiLCJnZXRNaW5NYXgiLCJyZXMiLCJnZXRSYW5nZSIsInN0YXJ0IiwiZW5kIiwic3RlcCIsIm1heCIsInB1c2giLCJlbXVsYXRlRXZlbnQiLCJtb3VzZSIsImdldFBhcmFtcyIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsIk1vdXNlRXZlbnQiLCJlbCIsImV2ZW50VHlwZSIsInBhcmFtcyIsImRpc3BhdGNoRXZlbnQiLCJtb3VzZUV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInRvdWNoIiwidG91Y2hPYmoiLCJUb3VjaCIsImlkZW50aWZpZXIiLCJub3ciLCJyYWRpdXNYIiwicmFkaXVzWSIsInJvdGF0aW9uQW5nbGUiLCJmb3JjZSIsIlRvdWNoRXZlbnQiLCJzaGlmdEtleSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJ0cGxQcm9jZXNzIiwidHBsIiwiUmVnRXhwIiwicGFyc2VEYXRlIiwiZGF0ZSIsInBhcnNlZERhdGUiLCJjb25maWciLCJmb3JtYXQiLCJkYXRhVGltZSIsImlzVGFiVmlzaWJsZSIsImhpZGRlbiIsImNvbnZlcnRJbnB1dFR5cGUiLCJpc01vYmlsZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImhhc1RvdWNoUG9pbnRzIiwibWF4VG91Y2hQb2ludHMiLCJoYXNUb3VjaCIsIkRvY3VtZW50VG91Y2giLCJoYXNNb3VzZSIsImF4aXNfcm90YXRlZCIsImdyaWRfeF9zaG93IiwiZ3JpZF94X3R5cGUiLCJncmlkX3hfbGluZXMiLCJncmlkX3lfc2hvdyIsImdyaWRfeV9saW5lcyIsImdyaWRfeV90aWNrcyIsImdyaWRfZm9jdXNfZWRnZSIsImdyaWRfZm9jdXNfc2hvdyIsImdyaWRfZm9jdXNfeSIsImdyaWRfZnJvbnQiLCJncmlkX2xpbmVzX2Zyb250IiwicG9pbnRfc2hvdyIsInBvaW50X3IiLCJwb2ludF9zZW5zaXRpdml0eSIsInBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkIiwicG9pbnRfZm9jdXNfZXhwYW5kX3IiLCJwb2ludF9mb2N1c19vbmx5IiwicG9pbnRfcGF0dGVybiIsInBvaW50X3NlbGVjdF9yIiwicG9pbnRfdHlwZSIsInN1YmNoYXJ0X3Nob3ciLCJzdWJjaGFydF9zaXplX2hlaWdodCIsInN1YmNoYXJ0X2F4aXNfeF9zaG93Iiwic3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdyIsInN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdyIsInN1YmNoYXJ0X29uYnJ1c2giLCJ6b29tX2VuYWJsZWQiLCJ6b29tX2V4dGVudCIsInpvb21fcHJpdmlsZWdlZCIsInpvb21fcmVzY2FsZSIsInpvb21fb256b29tIiwiem9vbV9vbnpvb21zdGFydCIsInpvb21fb256b29tZW5kIiwiem9vbV9yZXNldEJ1dHRvbiIsInpvb21feF9taW4iLCJ6b29tX3hfbWF4IiwiYXJlYV96ZXJvYmFzZWQiLCJhcmVhX2Fib3ZlIiwiYXJlYV9saW5lYXJHcmFkaWVudCIsImJhcl9wYWRkaW5nIiwiYmFyX3JhZGl1cyIsImJhcl9yYWRpdXNfcmF0aW8iLCJiYXJfc2Vuc2l0aXZpdHkiLCJiYXJfd2lkdGgiLCJiYXJfd2lkdGhfcmF0aW8iLCJiYXJfd2lkdGhfbWF4IiwiYmFyX3plcm9iYXNlZCIsImJ1YmJsZV9tYXhSIiwiYnViYmxlX3plcm9iYXNlZCIsImxpbmVfY29ubmVjdE51bGwiLCJsaW5lX3N0ZXBfdHlwZSIsImxpbmVfemVyb2Jhc2VkIiwibGluZV9jbGFzc2VzIiwibGluZV9wb2ludCIsInNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGUiLCJkb251dF9sYWJlbF9zaG93IiwiZG9udXRfbGFiZWxfZm9ybWF0IiwiZG9udXRfbGFiZWxfdGhyZXNob2xkIiwiZG9udXRfbGFiZWxfcmF0aW8iLCJkb251dF93aWR0aCIsImRvbnV0X3RpdGxlIiwiZG9udXRfZXhwYW5kIiwiZG9udXRfZXhwYW5kX3JhdGUiLCJkb251dF9leHBhbmRfZHVyYXRpb24iLCJkb251dF9wYWRBbmdsZSIsImRvbnV0X3N0YXJ0aW5nQW5nbGUiLCJnYXVnZV9mdWxsQ2lyY2xlIiwiZ2F1Z2VfbGFiZWxfc2hvdyIsImdhdWdlX2xhYmVsX2Zvcm1hdCIsImdhdWdlX2xhYmVsX2V4dGVudHMiLCJnYXVnZV9taW4iLCJnYXVnZV9tYXgiLCJnYXVnZV90eXBlIiwiZ2F1Z2Vfc3RhcnRpbmdBbmdsZSIsIlBJIiwiZ2F1Z2VfdGl0bGUiLCJnYXVnZV91bml0cyIsImdhdWdlX3dpZHRoIiwiZ2F1Z2VfYXJjc19taW5XaWR0aCIsImdhdWdlX2V4cGFuZCIsImdhdWdlX2V4cGFuZF9yYXRlIiwiZ2F1Z2VfZXhwYW5kX2R1cmF0aW9uIiwicGllX2xhYmVsX3Nob3ciLCJwaWVfbGFiZWxfZm9ybWF0IiwicGllX2xhYmVsX3RocmVzaG9sZCIsInBpZV9sYWJlbF9yYXRpbyIsInBpZV9leHBhbmQiLCJwaWVfZXhwYW5kX3JhdGUiLCJwaWVfZXhwYW5kX2R1cmF0aW9uIiwicGllX2lubmVyUmFkaXVzIiwicGllX3BhZEFuZ2xlIiwicGllX3BhZGRpbmciLCJwaWVfc3RhcnRpbmdBbmdsZSIsInJhZGFyX2F4aXNfbWF4IiwicmFkYXJfYXhpc19saW5lX3Nob3ciLCJyYWRhcl9heGlzX3RleHRfc2hvdyIsInJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbiIsInJhZGFyX2xldmVsX2RlcHRoIiwicmFkYXJfbGV2ZWxfc2hvdyIsInJhZGFyX2xldmVsX3RleHRfZm9ybWF0IiwidG9GaXhlZCIsInJhZGFyX2xldmVsX3RleHRfc2hvdyIsInJhZGFyX3NpemVfcmF0aW8iLCJyYWRhcl9kaXJlY3Rpb25fY2xvY2t3aXNlIiwiT3B0aW9ucyIsImNvbG9yIiwiaW50ZXJhY3Rpb24iLCJkb251dCIsImdhdWdlIiwicGllIiwiZGF0YUF4aXMiLCJkYXRhU2VsZWN0aW9uIiwicG9pbnQiLCJ6b29tIiwiYnViYmxlIiwic3BsaW5lIiwiYmluZHRvIiwiYmFja2dyb3VuZCIsInN2Z19jbGFzc25hbWUiLCJzaXplX3dpZHRoIiwic2l6ZV9oZWlnaHQiLCJwYWRkaW5nX2xlZnQiLCJwYWRkaW5nX3JpZ2h0IiwicGFkZGluZ190b3AiLCJwYWRkaW5nX2JvdHRvbSIsInJlc2l6ZV9hdXRvIiwib25vdmVyIiwib25vdXQiLCJvbnJlc2l6ZSIsIm9ucmVzaXplZCIsIm9uYmVmb3JlaW5pdCIsIm9uaW5pdCIsIm9uYWZ0ZXJpbml0Iiwib25yZW5kZXJlZCIsInRyYW5zaXRpb25fZHVyYXRpb24iLCJzY2F0dGVyX3plcm9iYXNlZCIsInBsdWdpbnMiLCJyZW5kZXIiLCJLRVkiLCJidWJibGVCYXNlTGVuZ3RoIiwiZGF0YU1pbk1heCIsImRhdGFUb3RhbFN1bSIsImRhdGFUb3RhbFBlckluZGV4IiwibGVnZW5kSXRlbVRleHRCb3giLCJyYWRhclBvaW50cyIsInNldE92ZXJPdXQiLCJjYWxsT3Zlck91dEZvclRvdWNoIiwidGV4dFJlY3QiLCJDYWNoZSIsImFkZCIsImlzRGF0YVR5cGUiLCJjYWNoZSIsImNsb25lVGFyZ2V0IiwicmVtb3ZlIiwiZ2V0IiwidGFyZ2V0cyIsInJlc2V0IiwiYWxsIiwiJCQiLCJpZF9vcmciLCJ2YWx1ZXMiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2VuZXJhdGVSZXNpemUiLCJ0aW1lb3V0IiwiY2FsbFJlc2l6ZUZuIiwiY2xlYXIiLCJzcGxpY2UiLCJnZW5lcmF0ZVdhaXQiLCJ0cmFuc2l0aW9uc1RvV2FpdCIsInQiLCJjYWxsYmFjayIsImxvb3AiLCJkb25lIiwidGltZXIiLCJBeGlzUmVuZGVyZXJIZWxwZXIiLCJvd25lciIsInNjYWxlIiwiZDNTY2FsZUxpbmVhciIsIm5vVHJhbnNpdGlvbiIsIndpdGhvdXRUcmFuc2l0aW9uIiwicmFuZ2UiLCJzY2FsZUV4dGVudCIsIm9yZ1hTY2FsZSIsImdldFNpemVGb3IxQ2hhciIsInciLCJoIiwiZ2V0VGlja1RyYW5zZm9ybVNldHRlciIsInRpY2tPZmZzZXQiLCJzdG9wIiwiZ2VuZXJhdGVUaWNrcyIsImlzWUF4ZXMiLCJ0aWNrU3RlcFNpemUiLCJpbnRlcnZhbCIsInRpY2tBcmd1bWVudHMiLCJyb3VuZCIsInVuc2hpZnQiLCJjb3B5U2NhbGUiLCJuZXdTY2FsZSIsImNvcHkiLCJ0ZXh0Rm9ybWF0dGVkIiwidGlja0Zvcm1hdCIsImZvcm1hdHRlZCIsInRyYW5zaXRpb25pc2UiLCJpbnRlcnJ1cHQiLCJBeGlzUmVuZGVyZXIiLCJpbm5lclRpY2tTaXplIiwib3V0ZXJUaWNrU2l6ZSIsIm91dGVyVGljayIsIm9yaWVudCIsInRpY2tDZW50ZXJlZCIsInRpY2tDdWxsaW5nIiwidGlja0xlbmd0aCIsInRpY2tQYWRkaW5nIiwidGlja1ZhbHVlcyIsImhlbHBlciIsIkhlbHBlciIsImNyZWF0ZSIsImciLCJzcGxpdFRpY2tUZXh0IiwiYmluZCIsImlzTGVmdFJpZ2h0IiwiaXNUb3BCb3R0b20iLCJ0aWNrVHJhbnNmb3JtIiwiYXhpc1B4Iiwic2lnbiIsInJvdGF0ZSIsInRpY2tUZXh0Um90YXRlIiwicmFuZ2VFeHRlbnQiLCIkZyIsInRpY2tUZXh0UG9zIiwicHJlZml4IiwiYXhpc1Nob3ciLCJ0aWNrU2hvdyIsInRpY2siLCJkM1NlbGVjdCIsInNjYWxlMCIsIl9fY2hhcnRfXyIsInNjYWxlMSIsImlzQ2F0ZWdvcnkiLCJzZWxlY3RBbGwiLCJlbnRlciIsIm1lcmdlIiwib3V0ZXJUaWNrU2l6ZWQiLCJ0aWNrRW50ZXIiLCJpbnNlcnQiLCJzdHlsZSIsInRpY2tFeGl0IiwiZXhpdCIsInNpemVGb3IxQ2hhciIsImNvdW50cyIsInRzcGFuIiwiaW5kZXgiLCJ0aWNrTXVsdGlsaW5lIiwic3BsaXR0ZWQiLCJkeCIsInNpbiIsImxpbmVVcGRhdGUiLCJ0ZXh0VXBkYXRlIiwic2V0VGlja0xpbmVUZXh0UG9zaXRpb24iLCJ0aWNrVGl0bGUiLCJiYW5kd2lkdGgiLCJnZXRUaWNrWFkiLCJwb3MiLCJnZXRUaWNrU2l6ZSIsInRpY2tQb3NpdGlvbiIsInRpY2tQb3MiLCJ0ZXh0QW5jaG9yRm9yVGV4dCIsInIiLCJyZXZlcnNlIiwidGV4dFRyYW5zZm9ybSIsInlGb3JUZXh0IiwicjIiLCJjaGFyV2lkdGgiLCJzdWJ0ZXh0Iiwic3BhY2VJbmRleCIsInRleHRXaWR0aCIsInN1YnN0ciIsInRpY2tXaWR0aCIsInRpY2tUZXh0IiwiYXJndW1lbnRzIiwiaXNDZW50ZXJlZCIsInRpY2tJbnRlcnZhbCIsImdldFRvdGFsTGVuZ3RoIiwiSW5maW5pdHkiLCJjdWxsaW5nIiwic2V0VHJhbnNpdGlvbiIsIkF4aXMiLCJzZXRPcmllbnQiLCJnZXRBeGlzQ2xhc3NOYW1lIiwiaXNIb3Jpem9udGFsIiwiZm9ySG9yaXpvbnRhbCIsImlzUm90YXRlZCIsImlzQ2F0ZWdvcml6ZWQiLCJpc0N1c3RvbVgiLCJpc1RpbWVTZXJpZXMiLCJpc1RpbWVTZXJpZXNZIiwiaW5pdCIsImNsYXNzQXhpcyIsImNsYXNzTGFiZWwiLCJnZXRUcmFuc2xhdGUiLCJ0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsIiwiZ2VuZXJhdGVBeGVzIiwieUlubmVyIiwieTJJbm5lciIsImQzQXhpcyIsImF4ZXMiLCJheGVzQ29uZmlnIiwiZDNBeGlzTGVmdCIsImQzQXhpc0JvdHRvbSIsImQzQXhpc1RvcCIsImQzQXhpc1JpZ2h0IiwiY291bnQiLCJhcGkiLCJ0aWNrU2l6ZU91dGVyIiwib3V0ZXIiLCJheGVzTGlzdCIsInVwZGF0ZUF4ZXMiLCJheGlzUmFuZ2UiLCJjbGFzc05hbWUiLCJzZXRBeGlzIiwiZ2V0VGlja1ZhbHVlcyIsImdldEF4aXMiLCJub1RpY2tUZXh0Um90YXRlIiwiaXNYIiwiZ2V0QXhpc1RpY2tSb3RhdGUiLCJ4QXhpc1RpY2siLCJheGlzUGFyYW1zIiwiY2F0ZWdvcmllcyIsImlzU3RhY2tOb3JtYWxpemVkIiwidXBkYXRlWEF4aXNUaWNrVmFsdWVzIiwiZml0IiwibWFwVGFyZ2V0c1RvVW5pcXVlWHMiLCJnZW5lcmF0ZVRpY2tWYWx1ZXMiLCJnZXRJZCIsImdldFhBeGlzVGlja0Zvcm1hdCIsImN1cnJGb3JtYXQiLCJheGlzVGltZSIsImRlZmF1bHRBeGlzVGltZSIsImNhdGVnb3J5TmFtZSIsImdldExhYmVsT3B0aW9uQnlBeGlzSWQiLCJnZXRMYWJlbFRleHQiLCJvcHRpb24iLCJzZXRMYWJlbFRleHQiLCJnZXRMYWJlbFBvc2l0aW9uIiwiZGVmYXVsdFBvc2l0aW9uIiwicG9zaXRpb24iLCJoYXMiLCJpc0lubmVyIiwiaXNPdXRlciIsImlzTGVmdCIsImlzQ2VudGVyIiwiaXNSaWdodCIsImlzVG9wIiwiaXNNaWRkbGUiLCJpc0JvdHRvbSIsImdldEF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0TGFiZWxQb3NpdGlvbkJ5SWQiLCJ4Rm9yQXhpc0xhYmVsIiwiZHhGb3JBeGlzTGFiZWwiLCJhbmNob3IiLCJkeUZvckF4aXNMYWJlbCIsInRpY2tSb3RhdGUiLCJnZXRIb3Jpem9udGFsQXhpc0hlaWdodCIsIm1heFRpY2tXaWR0aCIsImdldE1heFRpY2tXaWR0aCIsInhIZWlnaHQiLCJ3aXRob3V0UmVjb21wdXRlIiwiY3VycmVudFRpY2tNYXgiLCJtYXhXaWR0aCIsImZpbHRlclRhcmdldHNUb1Nob3ciLCJpc1lBeGlzIiwidGFyZ2V0c1RvU2hvdyIsImR1bW15IiwiY3VycmVudFRleHRXaWR0aCIsImdldFhBeGlzVGlja1RleHRZMk92ZXJmbG93IiwiZGVmYXVsdFBhZGRpbmciLCJ4QXhpc1RpY2tSb3RhdGUiLCJ3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQiLCJnZXRDdXJyZW50UGFkZGluZ0xlZnQiLCJtYXhPdmVyZmxvdyIsImdldFhBeGlzVGlja01heE92ZXJmbG93IiwieEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3ciLCJ0aWNrVGV4dFdpZHRocyIsInJlbWFpbmluZyIsInRpY2tJbmRleCIsInJvdGF0ZWRUaWNrVGV4dFdpZHRoIiwiY29zIiwidGlja3NCZWZvcmVUaWNrVGV4dCIsImdldFhEb21haW5NYXgiLCJnZXRYQXhpc1BhZGRpbmciLCJmaXJzdFgiLCJnZXRYRG9tYWluTWluIiwibGFzdFgiLCJ0aW1lRGlmZiIsInJlbGF0aXZlVGlja1dpZHRoIiwidXBkYXRlTGFiZWxzIiwid2l0aFRyYW5zaXRpb24iLCJsYWJlbHMiLCJnZXRQYWRkaW5nIiwiZG9tYWluTGVuZ3RoIiwiY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmciLCJwaXhlbHMiLCJmb3JUaW1lU2VyaWVzIiwidGFyZ2V0Q291bnQiLCJ0aWNrVmFsdWUiLCJnZW5lcmF0ZVRyYW5zaXRpb25zIiwiZHVyYXRpb24iLCJheCIsImF4aXNTdWJYIiwicmVkcmF3IiwidHJhbnNpdGlvbnMiLCJpc0hpZGRlbiIsImlzSW5pdCIsIm9wYWNpdHkiLCIkYXhpcyIsInJlZHJhd0F4aXMiLCJ3dGgiLCJmbG93IiwieERvbWFpbkZvclpvb20iLCJoYXNab29tIiwidXBkYXRlWERvbWFpbiIsIlVwZGF0ZVhEb21haW4iLCJVcGRhdGVPcmdYRG9tYWluIiwiVHJpbVhEb21haW4iLCJvcmdEb21haW4iLCJheGlzU2NhbGUiLCJnZXRZRG9tYWluIiwiaGFzQXJjVHlwZSIsIlRyYW5zaXRpb24iLCJVcGRhdGVYQXhpcyIsIlkiLCJzZXRDdWxsaW5nIiwic3ViWSIsInN1YlkyIiwidG9DdWxsIiwiaW50ZXJ2YWxGb3JDdWxsaW5nIiwidGlja1NpemUiLCJjdWxsaW5nTWF4IiwiZGlzcGxheSIsImNvbnZlcnREYXRhIiwidXJsIiwiY29udmVydFVybFRvRGF0YSIsIm1pbWVUeXBlIiwiaGVhZGVycyIsImpzb24iLCJjb252ZXJ0SnNvblRvRGF0YSIsInJvd3MiLCJjb252ZXJ0Um93c1RvRGF0YSIsImNvbHVtbnMiLCJjb252ZXJ0Q29sdW1uc1RvRGF0YSIsIkVycm9yIiwicmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsIkpTT04iLCJwYXJzZSIsInNlbmQiLCJjb252ZXJ0Q3N2VHN2VG9EYXRhIiwicGFyc2VyIiwieHN2IiwiY29udmVydENzdlRvRGF0YSIsImQzQ3N2UGFyc2VSb3dzIiwiZDNDc3ZQYXJzZSIsImNvbnZlcnRUc3ZUb0RhdGEiLCJ0c3YiLCJkM1RzdlBhcnNlUm93cyIsImQzVHN2UGFyc2UiLCJrZXlzUGFyYW0iLCJ0YXJnZXRLZXlzIiwibmV3Um93cyIsIm5ld1JvdyIsImZpbmRWYWx1ZUluSnNvbiIsInRtcCIsIm9iamVjdCIsImNvbnZlcnRlZFBhdGgiLCJwYXRoQXJyYXkiLCJzb21lIiwiayIsInJvdyIsImoiLCJjb2wiLCJjb252ZXJ0RGF0YVRvVGFyZ2V0cyIsImFwcGVuZFhzIiwieHNEYXRhIiwiZGF0YUtleXMiLCJpZHMiLCJpc05vdFgiLCJ4cyIsInhLZXkiLCJnZXRYS2V5IiwicmF3WCIsImdlbmVyYXRlVGFyZ2V0WCIsImdldE90aGVyVGFyZ2V0WHMiLCJnZXRYVmFsdWVzT2ZYS2V5IiwiY29udmVydGVkSWQiLCJoYXNDYXRlZ29yeSIsInYxIiwidjIiLCJoYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzIiwiaGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyIsInNldFRhcmdldFR5cGUiLCJtYXBUb0lkcyIsImRhdGFLZXkiLCJleGlzdFZhbHVlIiwiaXNHcm91cGVkIiwieFZhbHVlcyIsImdldEluZGV4QnlYIiwiYmFzZWRYIiwiZmlsdGVyQnlYIiwiZ2V0WFZhbHVlIiwiaWRzRm9yWCIsImdldE90aGVyVGFyZ2V0WCIsImFkZFhzIiwiaXNNdWx0aXBsZVgiLCJoYXNUeXBlIiwiYWRkTmFtZSIsImdldEFsbFZhbHVlc09uSW5kZXgiLCJmaWx0ZXJOdWxsIiwiZ2V0VmFsdWVPbkluZGV4IiwidmFsdWVPbkluZGV4IiwidXBkYXRlVGFyZ2V0WCIsInVwZGF0ZVRhcmdldFhzIiwidXBkYXRlWHMiLCJnZXRQcmV2WCIsImdldE5leHRYIiwiZ2V0QmFzZVZhbHVlIiwiaXNBcmVhUmFuZ2VUeXBlIiwiZ2V0QXJlYVJhbmdlRGF0YSIsImlzQnViYmxlWlR5cGUiLCJnZXRCdWJibGVaRGF0YSIsImdldE1pbk1heFZhbHVlIiwiZ2V0TWluTWF4RGF0YSIsImNhY2hlS2V5IiwibWluTWF4RGF0YSIsIm1pbk1heCIsIm1pbkRhdGEiLCJnZXRGaWx0ZXJlZERhdGFCeVZhbHVlIiwibWF4RGF0YSIsImdldFRvdGFsUGVySW5kZXgiLCJzdW0iLCJnZXRUb3RhbERhdGFTdW0iLCJzdWJ0cmFjdEhpZGRlbiIsInRvdGFsIiwiZ2V0SGlkZGVuVG90YWxEYXRhU3VtIiwiZ2V0TWF4RGF0YUNvdW50IiwiZ2V0TWF4RGF0YUNvdW50VGFyZ2V0IiwibWFwVG9UYXJnZXRJZHMiLCJoYXNUYXJnZXQiLCJ2YWwiLCJpc1RhcmdldFRvU2hvdyIsInRhcmdldElkIiwiaXNMZWdlbmRUb1Nob3ciLCJhZGRIaWRkZW5UYXJnZXRJZHMiLCJ0YXJnZXRJZHMiLCJyZW1vdmVIaWRkZW5UYXJnZXRJZHMiLCJhZGRIaWRkZW5MZWdlbmRJZHMiLCJyZW1vdmVIaWRkZW5MZWdlbmRJZHMiLCJnZXRWYWx1ZXNBc0lkS2V5ZWQiLCJ5cyIsImNoZWNrVmFsdWVJblRhcmdldHMiLCJjaGVja2VyIiwiaGFzTXVsdGlUYXJnZXRzIiwiX2NoZWNrT3JkZXIiLCJvcmRlciIsInRvTG93ZXJDYXNlIiwiaXNPcmRlckRlc2MiLCJpc09yZGVyQXNjIiwib3JkZXJUYXJnZXRzIiwidGFyZ2V0c1ZhbHVlIiwib3JkZXJBc2MiLCJvcmRlckRlc2MiLCJ0MSIsInQyIiwicmVkdWNlciIsImFicyIsInQxU3VtIiwidDJTdW0iLCJmaWx0ZXJSZW1vdmVOdWxsIiwiZmlsdGVyQnlYRG9tYWluIiwieERvbWFpbiIsImhhc0RhdGFMYWJlbCIsImRhdGFMYWJlbHMiLCJnZXREYXRhTGFiZWxMZW5ndGgiLCJsZW5ndGhzIiwiZGF0YUxhYmVsRm9ybWF0IiwiaXNOb25lQXJjIiwiaXNBcmMiLCJmaW5kU2FtZVhPZlZhbHVlcyIsInRhcmdldFgiLCJzYW1lcyIsImZpbmRDbG9zZXN0RnJvbVRhcmdldHMiLCJjYW5kaWRhdGVzIiwiZmluZENsb3Nlc3QiLCJjbG9zZXN0IiwibWluRGlzdCIsImlzQmFyVHlwZSIsImdldFRhcmdldFNlbGVjdG9yU3VmZml4IiwiaXNXaXRoaW5CYXIiLCJkaXN0IiwieEluZGV4IiwieUluZGV4IiwiY2lyY2xlWSIsInNxcnQiLCJwb3ciLCJjb252ZXJ0VmFsdWVzVG9TdGVwIiwic3RlcFR5cGUiLCJjb252ZXJ0ZWQiLCJjb252ZXJ0VmFsdWVzVG9SYW5nZSIsInJhbmdlcyIsInVwZGF0ZURhdGFBdHRyaWJ1dGVzIiwiYXR0cnMiLCJ3aXRoTGVnZW5kIiwiZ2V0UmF0aW8iLCJhc1BlcmNlbnQiLCJyYXRpbyIsInNob3duIiwicGFkQW5nbGUiLCJlbmRBbmdsZSIsInN0YXJ0QW5nbGUiLCJkYXRhVmFsdWVzIiwiaGlkZGVuU3VtIiwiYWNjIiwiY3VyciIsInBhcnNlRmxvYXQiLCJ1cGRhdGVEYXRhSW5kZXhCeVgiLCJ0aWNrVmFsdWVNYXAiLCJvdXQiLCJ2YWx1ZUluZGV4IiwibG9hZCIsInJhd1RhcmdldHMiLCJ1cGRhdGVUYXJnZXRzIiwid2l0aFVwZGF0ZU9yZ1hEb21haW4iLCJ3aXRoVXBkYXRlWERvbWFpbiIsInVwZGF0ZVR5cGVzRWxlbWVudHMiLCJsb2FkRnJvbUFyZ3MiLCJ1bmxvYWQiLCJyYXdUYXJnZXRJZHMiLCJjdXN0b21Eb25lQ2IiLCJzZWxlY3RvclRhcmdldCIsImlzT3ZlciIsInNldE92ZXJDb2xvciIsImxhc3QiLCJpc1dpdGhpblNoYXBlIiwiZGF0dW0iLCJzaG93Q2lyY2xlRm9jdXMiLCJleHBhbmRDaXJjbGVzQmFycyIsImdldERyYWdnYWJsZVNlbGVjdGlvbiIsImRyYWciLCJkM0RyYWciLCJkM01vdXNlIiwiZHJhZ3N0YXJ0IiwiZHJhZ2VuZCIsInNlbGVjdG9yIiwiZ2VuZXJhdGVDbGFzcyIsImNsYXNzVGV4dCIsImNsYXNzVGV4dHMiLCJjbGFzc1NoYXBlIiwiY2xhc3NTaGFwZXMiLCJnZW5lcmF0ZUV4dHJhTGluZUNsYXNzIiwiY2xhc3NMaW5lIiwiY2xhc3NMaW5lcyIsImNsYXNzQ2lyY2xlIiwiY2xhc3NDaXJjbGVzIiwiY2xhc3NCYXIiLCJjbGFzc0JhcnMiLCJjbGFzc0FyYyIsImNsYXNzQXJjcyIsImNsYXNzQXJlYSIsImNsYXNzQXJlYXMiLCJjbGFzc1JlZ2lvbiIsImNsYXNzIiwiY2xhc3NFdmVudCIsImNsYXNzVGFyZ2V0IiwiYWRkaXRpb25hbENsYXNzU3VmZml4IiwiYWRkaXRpb25hbENsYXNzIiwiY2xhc3NGb2N1cyIsImNsYXNzRm9jdXNlZCIsImNsYXNzRGVmb2N1c2VkIiwiY2xhc3NDaGFydFRleHQiLCJjbGFzc0NoYXJ0TGluZSIsImNsYXNzQ2hhcnRCYXIiLCJjbGFzc0NoYXJ0QXJjIiwiY2xhc3NDaGFydFJhZGFyIiwicGZ4Iiwic2VsZWN0b3JUYXJnZXRzIiwiaWRzVmFsdWUiLCJzZWxlY3RvckxlZ2VuZCIsInNlbGVjdG9yTGVnZW5kcyIsImNvbG9yaXplUGF0dGVybiIsInBhdHRlcm4iLCJjbG9uZU5vZGUiLCJzY2hlbWVDYXRlZ29yeTEwIiwiZ2V0Q29sb3JGcm9tQ3NzIiwiYm9keSIsInNwYW4iLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJjb250ZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImJhY2tncm91bmRJbWFnZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInRyaW0iLCJCb29sZWFuIiwiZ2VuZXJhdGVDb2xvciIsImNvbG9ycyIsImQzU2NhbGVPcmRpbmFsIiwib3JpZ2luYWxDb2xvclBhdHRlcm4iLCJ0aWxlcyIsImNvbG9yaXplZFBhdHRlcm5zIiwicGF0dGVybnMiLCJpc0xpbmUiLCJpc1R5cGVPZiIsImdlbmVyYXRlTGV2ZWxDb2xvciIsInRocmVzaG9sZCIsImFzVmFsdWUiLCJ1bml0IiwibCIsIlRZUEUiLCJBUkVBIiwiQVJFQV9MSU5FX1JBTkdFIiwiQVJFQV9TUExJTkUiLCJBUkVBX1NQTElORV9SQU5HRSIsIkFSRUFfU1RFUCIsIkJBUiIsIkJVQkJMRSIsIkRPTlVUIiwiR0FVR0UiLCJMSU5FIiwiUElFIiwiUkFEQVIiLCJTQ0FUVEVSIiwiU1BMSU5FIiwiU1RFUCIsIlRZUEVfQllfQ0FURUdPUlkiLCJBcmVhIiwiQXJlYVJhbmdlIiwiQXJjIiwiTGluZSIsIlN0ZXAiLCJTcGxpbmUiLCJnZXRZRG9tYWluTWluTWF4IiwiaXNNaW4iLCJkYXRhR3JvdXBzIiwiaWRzSW5Hcm91cCIsImJhc2VJZCIsImJhc2VBeGlzSWQiLCJheGlzSWQiLCJtZWV0Q29uZGl0aW9uIiwiZ2V0WURvbWFpbk1pbiIsImdldFlEb21haW5NYXgiLCJpc0hpZGRlblRhcmdldFdpdGhZRG9tYWluIiwidGFyZ2V0c0J5QXhpc0lkIiwieVRhcmdldHMiLCJ5TWluIiwieU1heCIsInlEb21haW5NaW4iLCJ5RG9tYWluTWF4IiwiY2VudGVyIiwiaXNaZXJvQmFzZWQiLCJpc0ludmVydGVkIiwic2hvd0hvcml6b250YWxEYXRhTGFiZWwiLCJzaG93VmVydGljYWxEYXRhTGFiZWwiLCJpc0FsbFBvc2l0aXZlIiwiaXNBbGxOZWdhdGl2ZSIsInlEb21haW5BYnMiLCJnZXRYRG9tYWluTWluTWF4IiwiY29uZmlnVmFsdWUiLCJkYXRhVmFsdWUiLCJnZXRYRG9tYWluUGFkZGluZyIsIm1heERhdGFDb3VudCIsInhQYWRkaW5nIiwiZ2V0WERvbWFpbiIsImdldFRpbWUiLCJ3aXRoVHJpbSIsIm9yZyIsInpvb21FbmFibGVkIiwidXBkYXRlU2NhbGVFeHRlbnQiLCJkb21haW5WYWx1ZSIsImludmVydCIsInRyaW1YRG9tYWluIiwiem9vbURvbWFpbiIsImdldFpvb21Eb21haW4iLCJnZXRGb3JtYXQiLCJ0eXBlVmFsdWUiLCJkZWZhdWx0VmFsdWVGb3JtYXQiLCJnZXRZRm9ybWF0IiwiZm9yQXJjIiwieUZvcm1hdCIsInkyRm9ybWF0IiwiZGVmYXVsdEFyY1ZhbHVlRm9ybWF0IiwiZGVmYXVsdEZvcm1hdCIsImluaXRMZWdlbmQiLCJ1cGRhdGVMZWdlbmQiLCJvcHRpb256Iiwid2l0aFRyYW5zZm9ybSIsIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtIiwidXBkYXRlTGVnZW5kVGVtcGxhdGUiLCJ1cGRhdGVMZWdlbmRFbGVtZW50IiwiY2xhc3NlZCIsInVwZGF0ZVNjYWxlcyIsInVwZGF0ZVN2Z1NpemUiLCJ0cmFuc2Zvcm1BbGwiLCJ3cmFwcGVyIiwidGVtcGxhdGUiLCJDT0xPUiIsIlRJVExFIiwiY2hpbGROb2RlcyIsInNldExlZ2VuZEl0ZW0iLCJ1cGRhdGVTaXplRm9yTGVnZW5kIiwiaW5zZXRMZWdlbmRQb3NpdGlvbiIsImdldEN1cnJlbnRQYWRkaW5nVG9wIiwiZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20iLCJnZXRDdXJyZW50UGFkZGluZ1JpZ2h0IiwiTmFOIiwidHJhbnNmb3JtTGVnZW5kIiwidXBkYXRlTGVnZW5kU3RlcCIsInVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aCIsInVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCJ1cGRhdGVMZWdlbmRJdGVtQ29sb3IiLCJnZXRMZWdlbmRXaWR0aCIsImdldExlZ2VuZEhlaWdodCIsIm9wYWNpdHlGb3JMZWdlbmQiLCJvcGFjaXR5Rm9yVW5mb2N1c2VkTGVnZW5kIiwidG9nZ2xlRm9jdXNMZWdlbmQiLCJmb2N1cyIsInRhcmdldElkeiIsInJldmVydExlZ2VuZCIsInNob3dMZWdlbmQiLCJoaWRlTGVnZW5kIiwiZ2V0TGVnZW5kSXRlbVRleHRCb3giLCJ0ZXh0RWxlbWVudCIsImdldFRleHRSZWN0IiwiaXRlbSIsImlzVG91Y2giLCJoYXNHYXVnZSIsIml0ZW1DbGFzcyIsImFsdEtleSIsImhpZGUiLCJzaG93IiwidG9nZ2xlIiwicmV2ZXJ0IiwiaGlkZVRvb2x0aXAiLCJ1bmRvTWFya092ZXJsYXBwZWQiLCJtYXJrT3ZlcmxhcHBlZCIsInhGb3JMZWdlbmQiLCJ5Rm9yTGVnZW5kIiwicG9zTWluIiwidGlsZVdpZHRoIiwibWF4SGVpZ2h0IiwidG90YWxMZW5ndGgiLCJvZmZzZXRzIiwid2lkdGhzIiwiaGVpZ2h0cyIsIm1hcmdpbnMiLCJzdGVwcyIsImlzTGVnZW5kUmlnaHRPckluc2V0IiwidXBkYXRlUG9zaXRpb25zIiwiaXNMYXN0IiwiYm94IiwiaXRlbVdpZHRoIiwiaXRlbUhlaWdodCIsIml0ZW1MZW5ndGgiLCJhcmVhTGVuZ3RoIiwidXBkYXRlVmFsdWVzIiwiaWQyIiwid2l0aG91dFN0ZXAiLCJtYXhMZW5ndGgiLCJ4Rm9yTGVnZW5kVGV4dCIsInhGb3JMZWdlbmRSZWN0IiwieDFGb3JMZWdlbmRUaWxlIiwieDJGb3JMZWdlbmRUaWxlIiwieUZvckxlZ2VuZFRleHQiLCJ5Rm9yTGVnZW5kUmVjdCIsInlGb3JMZWdlbmRUaWxlIiwidXNlUG9pbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJkM05hbWVzcGFjZXMiLCJoYXNWYWxpZFBvaW50VHlwZSIsImlkeCIsIm5vZGVOYW1lIiwicmVjdHMiLCJwb2ludFIiLCJ4T2Zmc2V0IiwieU9mZnNldCIsImxldmVsQ29sb3IiLCJ0cmFuc2l0aW9uc1ZhbHVlIiwiaW5pdGlhbGl6aW5nIiwiZ2V0V2l0aE9wdGlvbiIsImR1cmF0aW9uRm9yRXhpdCIsIlRyYW5zaXRpb25Gb3JFeGl0IiwiZHVyYXRpb25Gb3JBeGlzIiwiVHJhbnNpdGlvbkZvckF4aXMiLCJ1cGRhdGVTaXplcyIsIkxlZ2VuZCIsIkRpbWVuc2lvbiIsInVwZGF0ZURpbWVuc2lvbiIsInVwZGF0ZVRleHQiLCJ1cGRhdGVDaXJjbGVZIiwiaGFzUG9pbnRUeXBlIiwidXBkYXRlQ2lyY2xlIiwiaGFzR3JpZCIsInVwZGF0ZUdyaWQiLCJ1cGRhdGVSZWdpb24iLCJ1cGRhdGVCYXIiLCJoYXNUeXBlT2YiLCJ1cGRhdGVMaW5lIiwidXBkYXRlQXJlYSIsIkV2ZW50UmVjdCIsImJpbmRab29tRXZlbnQiLCJyZWRyYXdBcmMiLCJUcmFuc2Zvcm0iLCJyZWRyYXdSYWRhciIsInJlZHJhd1RpdGxlIiwiZ2VuZXJhdGVSZWRyYXdMaXN0IiwiU3ViY2hhcnQiLCJjYWxsUGx1Z2luSG9vayIsIndpdGhTdWJjaGFydCIsImdldERyYXdTaGFwZSIsInJlZHJhd1N1YmNoYXJ0IiwiZmxvd0ZuIiwiZ2VuZXJhdGVGbG93IiwieHYiLCJpc1RyYW5zaXRpb24iLCJyZWRyYXdMaXN0IiwiZ2V0UmVkcmF3TGlzdCIsImFmdGVyUmVkcmF3Iiwid2FpdEZvckRyYXciLCJkM1RyYW5zaXRpb24iLCJjeCIsImN5IiwieEZvclRleHQiLCJyZWRyYXdHcmlkIiwicmVkcmF3UmVnaW9uIiwicmVkcmF3TGluZSIsInJlZHJhd0FyZWEiLCJyZWRyYXdCYXIiLCJ1cGRhdGVHcmlkRm9jdXMiLCJyZWRyYXdUZXh0IiwicmVkcmF3Q2lyY2xlIiwidXBkYXRlQW5kUmVkcmF3Iiwid2l0aFRyYW5zaXRpb25Gb3JFeGl0Iiwid2l0aFRyYW5zaXRpb25Gb3JBeGlzIiwicmVkcmF3V2l0aG91dFJlc2NhbGUiLCJ3aXRoWSIsIndpdGhFdmVudFJlY3QiLCJnZXRTY2FsZSIsImZvclRpbWVzZXJpZXMiLCJkM1NjYWxlVGltZSIsImdldFhTY2FsZSIsIm9mZnNldCIsImdldEN1c3RvbWl6ZWRTY2FsZSIsImdldFlTY2FsZSIsImdldFlTY2FsZUJ5SWQiLCJpc1N1YiIsImlzWTIiLCJzY2FsZVZhbHVlIiwib2Zmc2V0VmFsdWUiLCJyYXciLCJvcmdTY2FsZSIsInhTdWJEb21haW4iLCJ1cGRhdGVBcmMiLCJ4eCIsInl2IiwieVNjYWxlIiwic3VieHgiLCJzZXRDb250YWluZXJTaXplIiwiZ2V0Q3VycmVudFdpZHRoIiwiZ2V0Q3VycmVudEhlaWdodCIsImdldFBhcmVudFdpZHRoIiwiZ2V0UGFyZW50SGVpZ2h0IiwiZ2V0QXhpc1NpemUiLCJnZXRBeGlzV2lkdGhCeUF4aXNJZCIsImF4ZXNMZW4iLCJnZXRUaXRsZVBhZGRpbmciLCJheGlzV2lkdGgiLCJ3aXRob3V0VGlja1RleHRPdmVyZmxvdyIsImxlZ2VuZFdpZHRoT25SaWdodCIsInhBeGlzVGlja1RleHRPdmVyZmxvdyIsImdldFBhcmVudFJlY3RWYWx1ZSIsIm9mZnNldE5hbWUiLCJwYXJlbnQiLCJ0YWdOYW1lIiwiYm9keVdpZHRoIiwib2Zmc2V0V2lkdGgiLCJwYXJzZUludCIsImdldFN2Z0xlZnQiLCJoYXNMZWZ0QXhpc1JlY3QiLCJsZWZ0QXhpc0NsYXNzIiwibGVmdEF4aXMiLCJzdmdSZWN0IiwiY2hhcnRSZWN0IiwiaGFzQXJjIiwic3ZnTGVmdCIsImdldEV2ZW50UmVjdFdpZHRoIiwiYWxsb3dlZFhBeGlzVHlwZXMiLCJuZWVkVG9Sb3RhdGVYQXhpc1RpY2tUZXh0cyIsInhBeGlzTGVuZ3RoIiwidGlja0NvdW50V2l0aFBhZGRpbmciLCJ3aXRob3V0QXhpcyIsImJydXNoU2l6ZSIsImdldFhBeGlzQ2xpcFgiLCJnZXRYQXhpc0NsaXBZIiwiZ2V0WEF4aXNDbGlwV2lkdGgiLCJnZXRYQXhpc0NsaXBIZWlnaHQiLCJnZXRZQXhpc0NsaXBYIiwiZ2V0WUF4aXNDbGlwWSIsImdldFlBeGlzQ2xpcFdpZHRoIiwiZ2V0WUF4aXNDbGlwSGVpZ2h0IiwiY3VyckxlZ2VuZCIsImxlZ2VuZEhlaWdodEZvckJvdHRvbSIsInN1YmNoYXJ0WEF4aXNIZWlnaHQiLCJzdWJjaGFydEhlaWdodCIsImdldEdhdWdlTGFiZWxIZWlnaHQiLCJ1cGRhdGVSYWRpdXMiLCJvcGFjaXR5Rm9yVGV4dCIsImluaXRUZXh0IiwidXBkYXRlVGFyZ2V0c0ZvclRleHQiLCJtYWluVGV4dFVwZGF0ZSIsIm1haW5UZXh0RW50ZXIiLCJkYXRhRm4iLCJsYWJlbGlzaERhdGEiLCJpc1JhZGFyVHlwZSIsInVwZGF0ZVRleHRDb2xvciIsImxhYmVsQ29sb3JzIiwiZm9yRmxvdyIsImJhc2UiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJnZW5lcmF0ZVhZRm9yVGV4dCIsImluZGljZXMiLCJmb3JYIiwicG9pbnRzIiwiZ2V0dGVyIiwiZ2V0WEZvclRleHQiLCJnZXRZRm9yVGV4dCIsImlzQXJlYVR5cGUiLCJnZXRDZW50ZXJlZFRleHRQb3MiLCJjZW50ZXJlZCIsImlzUG9zaXRpdmUiLCJnZXRUZXh0UG9zIiwieFBvcyIsInlQb3MiLCJiYXNlWSIsImlzTGluZVR5cGUiLCJpc1NjYXR0ZXJUeXBlIiwiaXNCdWJibGVUeXBlIiwiYm94SGVpZ2h0IiwidGV4dE5vZGVzIiwiZmlsdGVyZWRUZXh0Tm9kZXMiLCJ0ZXh0Tm9kZSIsInRyYW5zbGF0ZSIsImNhbGNIeXBvIiwiY29vcmRpbmF0ZSIsImZpbHRlcmVkVGV4dE5vZGUiLCJub2RlRm9yV2lkdGgiLCJvdmVybGFwc1giLCJnZXRDb21wdXRlZFRleHRMZW5ndGgiLCJvdmVybGFwc1kiLCJkM1NlbGVjdEFsbCIsInByZXZpb3VzU2libGluZyIsImlzTnVtIiwiaW5pdFRpdGxlIiwieUZvclRpdGxlIiwieEZvclRpdGxlIiwidGV4dFJlY3RXaWR0aCIsImluaXRUb29sdGlwIiwiZ2V0VG9vbHRpcEhUTUwiLCJiaW5kVG9vbHRpcFJlc2l6ZVBvcyIsImdldFRvb2x0aXBDb250ZW50IiwiZGVmYXVsdFRpdGxlRm9ybWF0IiwidGl0bGVGb3JtYXQiLCJuYW1lRm9ybWF0IiwidmFsdWVGb3JtYXQiLCJnZXRSb3dWYWx1ZSIsImdldEJnQ29sb3IiLCJjb250ZW50cyIsInRwbFN0ciIsImkyIiwicGFyYW0iLCJnZXRUb29sdGlwQ29udGVudFRlbXBsYXRlIiwiQ0xBU1NfVE9PTFRJUCIsImhpZ2giLCJsb3ciLCJjb250ZW50VmFsdWUiLCJDTEFTU19UT09MVElQX05BTUUiLCJOQU1FIiwiVkFMVUUiLCJ0b29sdGlwUG9zaXRpb24iLCJkYXRhVG9TaG93IiwidFdpZHRoIiwidEhlaWdodCIsImNoYXJ0UmlnaHQiLCJjaGFydExlZnQiLCJkYXRhU2NhbGUiLCJ6b29tU2NhbGUiLCJzaG93VG9vbHRpcCIsInNlbGVjdGVkRGF0YSIsImRhdGFTdHIiLCJzdHJpbmdpZnkiLCJwcm9wZXJ0eSIsIl9oYW5kbGVMaW5rZWRDaGFydHMiLCJmblBvcyIsInhQb3NJblBlcmNlbnQiLCJyZXNpemVGdW5jdGlvbiIsImNoYXJ0cyIsImxpbmtlZE5hbWUiLCJpbnRlcm5hbCIsImlzTGlua2VkIiwiaXNJbkRvbSIsImNvbnRhaW5zIiwiaXNOb3RTYW1lSW5kZXgiLCJnZXRSYWRhclNpemUiLCJ0cmFuc2Zvcm1NYWluIiwieEF4aXMiLCJ5QXhpcyIsInkyQXhpcyIsInRyYW5zZm9ybUNvbnRleHQiLCJzZXRDaGFydEVsZW1lbnRzIiwiY2hlY2tGcm9tRGF0YSIsImV4Y2x1ZGUiLCJkYXRhVHlwZSIsImhhc011bHRpQXJjR2F1Z2UiLCJpc1N0ZXBUeXBlIiwiaXNTcGxpbmVUeXBlIiwiaXNQaWVUeXBlIiwiaXNHYXVnZVR5cGUiLCJpc0RvbnV0VHlwZSIsImlzQXJjVHlwZSIsImlzQ2lyY2xlUG9pbnQiLCJpc0NpcmNsZSIsImxpbmVEYXRhIiwiYXJjRGF0YSIsImJhckRhdGEiLCJiYXJMaW5lQnViYmxlRGF0YSIsImlzSW50ZXJwb2xhdGlvblR5cGUiLCJzZXRNaW5NYXgiLCJjYXRlZ29yeSIsInRvIiwidGFpbCIsIm5vdGZvdW5kSWRzIiwib3JnRGF0YUNvdW50IiwibWlzc2luZyIsImJhc2VUYXJnZXQiLCJiYXNlVmFsdWUiLCJ3aXRoVHJpbVhEb21haW4iLCJ3aXRoVXBkYXRlWEF4aXMiLCJncmlkcyIsInJlbW92ZUdyaWRMaW5lcyIsImdyb3VwcyIsIm9wdGlvbnNWYWx1ZSIsInNlbGVjdGVkIiwiZGF0YVBvaW50IiwicmVzZXRPdGhlciIsImdldFRvZ2dsZSIsImlzVGFyZ2V0SWQiLCJpc1RhcmdldEluZGV4IiwiaXNTZWxlY3RlZCIsInVuc2VsZWN0Iiwid2l0aGluUmFuZ2UiLCJyZXN1bHREb21haW4iLCJ4U2NhbGUiLCJnZXRTZWxlY3Rpb24iLCJtb3ZlIiwid2l0aERpbWVuc2lvbiIsInNldFpvb21SZXNldEJ1dHRvbiIsImVuYWJsZSIsImVuYWJsZWQiLCJlbmFibGVUeXBlIiwiaW5pdFpvb20iLCJ1bnpvb20iLCJ1cGRhdGVUcmFuc2Zvcm1TY2FsZSIsImQzWm9vbUlkZW50aXR5IiwidXBkYXRlWm9vbSIsInJlc2V0QnRuIiwiZDNab29tVHJhbnNmb3JtIiwiYWx0RG9tYWluIiwic3giLCJzeSIsIm14IiwibXkiLCJtaW5YIiwibWF4WCIsIm1pblkiLCJtYXhZIiwiaXNJbmNsdWRlZCIsImlzV2l0aGluIiwidG9nZ2xlUG9pbnQiLCJ0b2dnbGVQYXRoIiwic2V0RHJhZ1N0YXR1cyIsImlzRHJhZ2dpbmciLCJmbG93TGVuZ3RoIiwidXBkYXRlWEdyaWQiLCJlbGVtZW50cyIsImhpZGVHcmlkRm9jdXMiLCJzZXRGbG93TGlzdCIsImZsb3dJbmRleCIsImdldEZsb3dUcmFuc2Zvcm0iLCJ3YWl0IiwiZ3QiLCJlYXNlIiwiZDNFYXNlTGluZWFyIiwiaXNSZWdpb25PblgiLCJjbGVhblVwRmxvdyIsInJlZ2lvblgiLCJyZWdpb25XaWR0aCIsInhGdW5jIiwieUZ1bmMiLCJyZWRyYXdFdmVudFJlY3QiLCJ0cmFuc2xhdGVYIiwiZmxvd1N0YXJ0IiwiZmxvd0VuZCIsInNjYWxlWCIsImluaXRFdmVudFJlY3QiLCJldmVudFJlY3RVcGRhdGUiLCJnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzIiwieEF4aXNUaWNrVmFsdWVzIiwidXBkYXRlUG9pbnRDbGFzcyIsImdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgiLCJ1cGRhdGVFdmVudFJlY3QiLCJiaW5kVG91Y2hPbkV2ZW50UmVjdCIsInN0YXJ0UHgiLCJnZXRFdmVudFJlY3QiLCJlbGVtZW50RnJvbVBvaW50IiwiZ2V0SW5kZXgiLCJzZWxlY3RSZWN0IiwiY29udGV4dCIsInNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzIiwidW5zZWxlY3RSZWN0Iiwic2VsZWN0UmVjdEZvclNpbmdsZSIsInByZXZlbnREZWZhdWx0IiwiaXNQcmV2ZW50ZWQiLCJwcmV2ZW50VGhyZXNob2xkIiwicHJldmVudEV2ZW50IiwiY3VycmVudFhZIiwidG9nZ2xlU2hhcGUiLCJldmVudFJlY3REYXRhIiwicmVjdFciLCJyZWN0WCIsImdldFByZXZOZXh0WCIsInByZXYiLCJuZXh0IiwidGhpc1giLCJpc1NlbGVjdGlvbkVuYWJsZWQiLCJpc1NlbGVjdGlvbkdyb3VwZWQiLCJpc1Rvb2x0aXBHcm91cGVkIiwic2hvd0dyaWRGb2N1cyIsInVuZXhwYW5kQ2lyY2xlcyIsImV4cGFuZENpcmNsZXMiLCJleHBhbmRCYXJzIiwic2FtZVhEYXRhIiwidW5leHBhbmRCYXJzIiwiZXZlbnRSZWN0RW50ZXIiLCJjbGlja0hhbmRsZXJGb3JTaW5nbGVYIiwiZDIiLCJjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTIiwiaW5pdEJydXNoIiwiZDNCcnVzaFkiLCJkM0JydXNoWCIsImxhc3REb21haW4iLCJicnVzaEhhbmRsZXIiLCJyZWRyYXdGb3JCcnVzaCIsImdldEJydXNoU2l6ZSIsInVwZGF0ZVJlc2l6ZSIsInVwZGF0ZSIsImV4dGVudCIsImdldEV4dGVudCIsImluaXRTdWJjaGFydCIsInZpc2liaWxpdHkiLCJjbGlwSWQiLCJnZXRDbGlwUGF0aCIsImFwcGVuZENsaXAiLCJ1cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQiLCJiYXJVcGRhdGUiLCJiYXJFbnRlciIsImxpbmVFbnRlciIsInVwZGF0ZUJhckZvclN1YmNoYXJ0IiwiaW5pdGlhbE9wYWNpdHkiLCJyZWRyYXdCYXJGb3JTdWJjaGFydCIsImRyYXdCYXJPblN1YiIsInVwZGF0ZUxpbmVGb3JTdWJjaGFydCIsInJlZHJhd0xpbmVGb3JTdWJjaGFydCIsImRyYXdMaW5lT25TdWIiLCJ1cGRhdGVBcmVhRm9yU3ViY2hhcnQiLCJyZWRyYXdBcmVhRm9yU3ViY2hhcnQiLCJkcmF3QXJlYU9uU3ViIiwiZHJhdyIsIm9uQnJ1c2giLCJzdWJYQXhpcyIsImdlbmVyYXRlWm9vbSIsImluaXRab29tQmVoYXZpb3VyIiwiYmluZFpvb21PbkV2ZW50UmVjdCIsImQzWm9vbSIsIm9uWm9vbVN0YXJ0Iiwib25ab29tIiwib25ab29tRW5kIiwib3JnU2NhbGVFeHRlbnQiLCJyZXNjYWxlIiwic291cmNlRXZlbnQiLCJzdGFydEV2ZW50IiwiaXNNb3VzZW1vdmUiLCJpc1pvb21PdXQiLCJ3aGVlbERlbHRhIiwiZGVsdGEiLCJpc2Z1bGx5U2hvd24iLCJiZWhhdmlvdXIiLCJ6b29tQmVoYXZpb3VyIiwicHJvcCIsImNsaWNrRGlzdGFuY2UiLCJyZXNldEJ1dHRvbiIsIm9uY2xpY2siLCJpbml0Q2xpcCIsImlzSUU5IiwiYXBwVmVyc2lvbiIsIlVSTCIsImdldEF4aXNDbGlwWCIsImdldEF4aXNDbGlwWSIsImdldEF4aXNDbGlwV2lkdGgiLCJnZXRBeGlzQ2xpcEhlaWdodCIsInVwZGF0ZVhBeGlzVGlja0NsaXAiLCJuZXdYQXhpc0hlaWdodCIsInNldFhBeGlzVGlja0NsaXBXaWR0aCIsInNldFhBeGlzVGlja1RleHRDbGlwUGF0aFdpZHRoIiwic2luUm90YXRpb24iLCJnZXRHcmlkVGV4dEFuY2hvciIsImdldEdyaWRUZXh0RHgiLCJnZXRHcmlkVGV4dFgiLCJzbW9vdGhMaW5lcyIsImluaXRHcmlkIiwiaW5pdEdyaWRMaW5lcyIsImluaXRGb2N1c0dyaWQiLCJ3aXRob3V0VXBkYXRlIiwieGdyaWREYXRhIiwiZ2VuZXJhdGVHcmlkRGF0YSIsInVwZGF0ZVlHcmlkIiwiZ3JpZFZhbHVlcyIsInVwZGF0ZVhHcmlkTGluZXMiLCJ1cGRhdGVZR3JpZExpbmVzIiwieExpbmVzIiwiaXNGcm9udCIsImZvY3VzRWwiLCJpc0VkZ2UiLCJ4eSIsImhpZGVDaXJjbGVGb2N1cyIsInRpY2tOdW0iLCJncmlkRGF0YSIsImZpcnN0WWVhciIsImdldEZ1bGxZZWFyIiwibGFzdFllYXIiLCJnZXRHcmlkRmlsdGVyVG9SZW1vdmUiLCJ0b1JlbW92ZSIsImluaXRSZWdpb24iLCJyZWdpb25ZIiwicmVnaW9uSGVpZ2h0IiwiZ2V0UmVnaW9uWFkiLCJjdXJyU2NhbGUiLCJnZXRSZWdpb25TaXplIiwiaXNXaWR0aCIsInNlbGVjdFBvaW50IiwiY2lyY2xlWCIsInBvaW50U2VsZWN0UiIsInVuc2VsZWN0UG9pbnQiLCJtZXRob2QiLCJzZWxlY3RQYXRoIiwiZDNSZ2IiLCJicmlnaHRlciIsInVuc2VsZWN0UGF0aCIsInRoYXQiLCJ0b2dnbGVkU2hhcGUiLCJpbml0QmFyIiwidXBkYXRlVGFyZ2V0c0ZvckJhciIsIm1haW5CYXJVcGRhdGUiLCJtYWluQmFyRW50ZXIiLCJkcmF3QmFyIiwiZ2V0QmFyVyIsImJhclRhcmdldHNOdW0iLCJyZXN1bHQiLCJnZXRXaWR0aCIsImdldEJhcnMiLCJzdWZmaXgiLCJnZW5lcmF0ZURyYXdCYXIiLCJiYXJJbmRpY2VzIiwiZ2V0UG9pbnRzIiwiZ2VuZXJhdGVHZXRCYXJQb2ludHMiLCJiYXJSYWRpdXMiLCJiYXJSYWRpdXNSYXRpbyIsImdldFJhZGl1cyIsImluZGV4WCIsImluZGV4WSIsImlzTmVnYXRpdmUiLCJwYXRoUmFkaXVzIiwiYmFyVyIsImdldEluZGljZXNNYXgiLCJiYXJYIiwiZ2V0U2hhcGVYIiwiYmFyWSIsImdldFNoYXBlWSIsImJhck9mZnNldCIsImdldFNoYXBlT2Zmc2V0IiwieTAiLCJnZXRTaGFwZVlNaW4iLCJwb3NYIiwicG9zWSIsInNlZzAiLCJzZWcxIiwiaW5pdEJ1YmJsZSIsImdldEJhc2VMZW5ndGgiLCJiYXNlTGVuZ3RoIiwiZ2V0QnViYmxlUiIsIm1heFIiLCJtaWQiLCJtYXhBcmVhIiwiaW5pdExpbmUiLCJ1cGRhdGVUYXJnZXRzRm9yTGluZSIsIm1haW5MaW5lVXBkYXRlIiwibWFpbkxpbmVFbnRlciIsImV4dHJhTGluZUNsYXNzZXMiLCJkcmF3TGluZSIsImdldEN1cnZlIiwiaXNSb3RhdGVkU3RlcFR5cGUiLCJnZXRJbnRlcnBvbGF0ZSIsIm9yZ1BvaW50IiwicG9pbnRSb3RhdGVkIiwiX3BvaW50IiwiX3kiLCJfdCIsIl9jb250ZXh0IiwibGluZVRvIiwiX3giLCJnZW5lcmF0ZURyYXdMaW5lIiwibGluZUluZGljZXMiLCJsaW5lQ29ubmVjdE51bGwiLCJnZW5lcmF0ZUdldExpbmVQb2ludHMiLCJ4VmFsdWUiLCJ5VmFsdWUiLCJkM0xpbmUiLCJkZWZpbmVkIiwieDAiLCJsaW5lV2l0aFJlZ2lvbnMiLCJjdXJ2ZSIsImlzU3ViVmFsdWUiLCJsaW5lT2Zmc2V0IiwiX3JlZ2lvbnMiLCJ4cCIsInlwIiwiZGlmZngyIiwiZGFzaGFycmF5IiwiaXNXaXRoaW5SZWdpb25zIiwid2l0aGluWCIsIndpdGhpblJlZ2lvbnMiLCJyZWciLCJnZXRWYWx1ZSIsImR0IiwiZ2VuZXJhdGVNIiwic1dpdGhSZWdpb24iLCJkMCIsImQxIiwidGltZXNlcmllc0RpZmYiLCJ4RGlmZiIsInh2MCIsInh2MSIsIm90aGVyRGlmZiIsInByZXZEYXRhIiwiaGFzUHJldkRhdGEiLCJkZCIsInVwZGF0ZUFyZWFHcmFkaWVudCIsInN0b3BzIiwibGluZWFyR3JhZGllbnQiLCJzdG9wQ29sb3IiLCJ1cGRhdGVBcmVhQ29sb3IiLCJkcmF3QXJlYSIsImdlbmVyYXRlRHJhd0FyZWEiLCJhcmVhSW5kaWNlcyIsImdlbmVyYXRlR2V0QXJlYVBvaW50cyIsInZhbHVlMCIsInZhbHVlMSIsImQzQXJlYSIsImFyZWFPZmZzZXQiLCJpc1dpdGhpblN0ZXAiLCJzaG91bGREcmF3UG9pbnRzRm9yTGluZSIsImxpbmVQb2ludCIsImdldFRyYW5zaXRpb25OYW1lIiwiaGFzVmFsaWRQb2ludERyYXdNZXRob2RzIiwicG9pbnRUeXBlIiwiaW5pdGlhbE9wYWNpdHlGb3JDaXJjbGUiLCJvcGFjaXR5Rm9yQ2lyY2xlIiwiaW5pdENpcmNsZSIsImdlbmVyYXRlUG9pbnQiLCJ1cGRhdGVUYXJnZXRGb3JDaXJjbGUiLCJtYWluQ2lyY2xlIiwibWFpbkNpcmNsZUVudGVyIiwiZm9jdXNPbmx5IiwicG9zQXR0ciIsIm9wYWNpdHlTdHlsZUZuIiwibWFpbkNpcmNsZXMiLCJyYWRhckNpcmNsZVgiLCJyYWRhckNpcmNsZVkiLCJnZXRTaGFwZUluZGljZXMiLCJnZXRDaXJjbGVzIiwicG9pbnRFeHBhbmRlZFIiLCJzZWxlY3RSIiwiaXNXaXRoaW5DaXJjbGUiLCJpbnNlcnRQb2ludEluZm9EZWZzIiwiY29weUF0dHIiLCJmcm9tIiwiYXR0cmlicyIsImF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJjbG9uZSIsImZpbGwiLCJzdHJva2UiLCJpbm5lckhUTUwiLCJwb2ludEZyb21EZWZzIiwicG9pbnRDbGFzcyIsInBvaW50SWQiLCJjdXN0b20iLCJzaXplRm4iLCJmaWxsU3R5bGVGbiIsInhQb3NGbiIsInlQb3NGbiIsInhQb3NGbjIiLCJ0cmFuc2l0aW9uTmFtZSIsInJlY3RhbmdsZSIsInJlY3RTaXplRm4iLCJyZWN0WFBvc0ZuIiwidHlwZUZpbHRlciIsImhhc1hzIiwiaW5kIiwiX19tYXhfXyIsImdldEluZGljZXMiLCJiYXJQYWRkaW5nIiwiaGFsZldpZHRoIiwidGFyZ2V0c051bSIsImdldFNoYXBlT2Zmc2V0RGF0YSIsInNoYXBlT2Zmc2V0VGFyZ2V0cyIsInJvd1ZhbHVlcyIsInJvd1ZhbHVlTWFwQnlYVmFsdWUiLCJpbmRleE1hcEJ5VGFyZ2V0SWQiLCJkYXRhWEFzTnVtYmVyIiwiaW50ZXJwb2xhdGlvbiIsImdldEludGVycG9sYXRlVHlwZSIsImQzQ3VydmVCYXNpcyIsImQzQ3VydmVCYXNpc0Nsb3NlZCIsImQzQ3VydmVCYXNpc09wZW4iLCJkM0N1cnZlQnVuZGxlIiwiZDNDdXJ2ZUNhcmRpbmFsIiwiZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkIiwiZDNDdXJ2ZUNhcmRpbmFsT3BlbiIsImQzQ3VydmVDYXRtdWxsUm9tIiwiZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQiLCJkM0N1cnZlQ2F0bXVsbFJvbU9wZW4iLCJkM0N1cnZlTW9ub3RvbmVYIiwiZDNDdXJ2ZU1vbm90b25lWSIsImQzQ3VydmVOYXR1cmFsIiwiZDNDdXJ2ZUxpbmVhckNsb3NlZCIsImQzQ3VydmVMaW5lYXIiLCJkM0N1cnZlU3RlcCIsImQzQ3VydmVTdGVwQWZ0ZXIiLCJkM0N1cnZlU3RlcEJlZm9yZSIsImFwaUF4aXMiLCJhcGlDYXRlZ29yeSIsImFwaUZsb3ciLCJhcGlYR3JpZCIsImFwaVlHcmlkIiwiYXBpR3JvdXAiLCJhcGlSZWdpb24iLCJhcGlTZWxlY3Rpb24iLCJhcGlYIiwiYXBpWm9vbSIsImV2ZW50cmVjdCIsImluaXRQaWUiLCJzdGFydGluZ0FuZ2xlIiwiZDNQaWUiLCJzb3J0VmFsdWVzIiwiZ2V0SW5uZXJSYWRpdXMiLCJzdmdBcmMiLCJnZXRTdmdBcmMiLCJzdmdBcmNFeHBhbmRlZCIsImdldFN2Z0FyY0V4cGFuZGVkIiwidXBkYXRlQW5nbGUiLCJkVmFsdWUiLCJnU3RhcnQiLCJ0b3RhbFN1bSIsImdFbmQiLCJtYXhWYWx1ZSIsImdNaW4iLCJnTWF4IiwiZ1ZhbHVlIiwiaXIiLCJzaW5nbGVBcmNXaWR0aCIsImQzQXJjIiwib3V0ZXJSYWRpdXMiLCJuZXdBcmMiLCJ1cGRhdGVkIiwiY2VudHJvaWQiLCJyYXRlIiwibmV3UmF0ZSIsImV4cGFuZFdpZHRoIiwiZ2V0QXJjIiwidHJhbnNmb3JtRm9yQXJjTGFiZWwiLCJjb252ZXJ0VG9BcmNEYXRhIiwidGV4dEZvckFyY0xhYmVsIiwic2hvdWxkU2hvd0FyY0xhYmVsIiwiaXNVbmRlclRocmVzaG9sZCIsIm1lZXRzQXJjTGFiZWxUaHJlc2hvbGQiLCJnZXRBcmNMYWJlbEZvcm1hdCIsInRleHRGb3JHYXVnZU1pbk1heCIsImlzTWF4IiwiZXhwYW5kQXJjIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibmV3VGFyZ2V0SWRzIiwic2hvdWxkRXhwYW5kIiwiZXhwYW5kRHVyYXRpb24iLCJnZXRFeHBhbmRDb25maWciLCJzdmdBcmNFeHBhbmRlZFN1YiIsInVuZXhwYW5kQXJjIiwiZ2V0QXJjVGl0bGUiLCJ1cGRhdGVUYXJnZXRzRm9yQXJjIiwibWFpblBpZVVwZGF0ZSIsIm1haW5QaWVFbnRlciIsImluaXRBcmMiLCJzZXRBcmNUaXRsZSIsImhhc0ludGVyYWN0aW9uIiwibWFpbkFyYyIsIl9jdXJyZW50IiwicmVkcmF3TXVsdGlBcmNHYXVnZSIsImF0dHJUd2VlbiIsImludGVycG9sYXRlIiwiZDNJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImJpbmRBcmNFdmVudCIsInJlZHJhd0FyY1RleHQiLCJhcmNMYWJlbExpbmVzIiwibWFpbkFyY0xhYmVsTGluZSIsImxpbmVMZW5ndGgiLCJsaW5lVGhpY2tuZXNzIiwiaW5uZXJMaW5lTGVuZ3RoIiwibGluZUFuZ2xlIiwiYXJjSW5uZXJSYWRpdXMiLCJsaW5lUG9zaXRpb25pbmdBbmdsZSIsInNlbGVjdEFyYyIsIl90aGlzIiwidW5zZWxlY3RBcmMiLCJpc01vdXNlIiwicmFkYXJzIiwiZ2V0RXZlbnRBcmMiLCJldmVudEFyYyIsImhhbmRsZXIiLCJpc0Z1bGxDaXJjbGUiLCJiYWNrZ3JvdW5kQXJjIiwiaW5pdEdhdWdlIiwiYXBwZW5kVGV4dCIsImdldFBvc2l0aW9uIiwiaXNDbG9ja3dpc2UiLCJlZGdlIiwiZnVuYyIsImluaXRSYWRhciIsInVwZGF0ZVRhcmdldHNGb3JSYWRhciIsImdlbmVyYXRlUmFkYXJQb2ludHMiLCJnZXRSYWRhclBvc2l0aW9uIiwiX3NpemUiLCJ1cGRhdGVSYWRhckxldmVsIiwidXBkYXRlUmFkYXJBeGVzIiwidXBkYXRlUmFkYXJTaGFwZSIsImdlbmVyYXRlR2V0UmFkYXJQb2ludHMiLCJkZXB0aCIsInNob3dUZXh0IiwicmFkYXJMZXZlbHMiLCJsZXZlbERhdGEiLCJsZXZlbFJhdGlvIiwibGV2ZWxUZXh0Rm9ybWF0Iiwiam9pbiIsImxldmVsRW50ZXIiLCJheGlzRW50ZXIiLCJmaXJzdENoaWxkIiwiYmluZEV2ZW50Iiwibm9JbmRleCIsImFyZWFzRW50ZXIiLCJDaGFydEludGVybmFsIiwic3RvcmUiLCJiZWZvcmVJbml0IiwiYWZ0ZXJJbml0IiwiaW5pdFBhcmFtcyIsImNsYXNzbmFtZSIsImluaXRUb1JlbmRlciIsImZvcmNlZCIsImlzTGF6eSIsImxhenkiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsIm11dGF0aW9uIiwib2JzZXJ2ZXIiLCJkaXNjb25uZWN0IiwiYXR0cmlidXRlRmlsdGVyIiwiY29udmVydGVkRGF0YSIsImluaXRXaXRoRGF0YSIsImQzVGltZVBhcnNlIiwiZDNVdGNQYXJzZSIsImQzVGltZUZvcm1hdCIsImQzVXRjRm9ybWF0IiwiaXNEcmFnWm9vbSIsImlzWm9vbWVkIiwic3BlY2lmaWVyIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ2V0U2Vjb25kcyIsImdldE1pbnV0ZXMiLCJnZXRIb3VycyIsImdldERhdGUiLCJnZXRNb250aCIsInJvdGF0ZWRQYWRkaW5nUmlnaHQiLCJoYXNDb2xvclBhdHRlcm5zIiwiYmluZFJlc2l6ZSIsImluaXRDaGFydEVsZW1lbnRzIiwic2V0QmFja2dyb3VuZCIsIiQiLCJiZyIsImltZ1VybCIsInNob3dUYXJnZXRzIiwid2l0aE9wdGlvbnMiLCJkZWZWYWwiLCJmbHVzaCIsImFkZEV2ZW50TGlzdGVuZXIiLCJwaGFzZSIsInByb3RvdHlwZSIsImRhdGFDb252ZXJ0IiwiZGF0YUxvYWQiLCJjbGFzc01vZHVsZSIsImFyY0ludGVybmFsIiwiYXhpc0ludGVybmFsIiwibG9hZENvbmZpZyIsInJlYWQiLCJ0aGlzQ29uZmlnIiwiZmluZCIsInJlc2l6ZSIsInNvZnQiLCJkZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImZsYXQiLCJuYW1lcyIsImI2NEVuY29kZVVuaWNvZGUiLCJidG9hIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwibWF0Y2giLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJub2RlVG9TdmdEYXRhVXJsIiwic2VyaWFsaXplciIsIlhNTFNlcmlhbGl6ZXIiLCJjc3NUZXh0IiwieGh0bWwiLCJub2RlWG1sIiwic2VyaWFsaXplVG9TdHJpbmciLCJjcmVhdGVUZXh0Tm9kZSIsInN0eWxlWG1sIiwiZXhwb3J0Iiwic3ZnRGF0YVVybCIsImltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJvbmxvYWQiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwiZHJhd0ltYWdlIiwidG9EYXRhVVJMIiwic3JjIiwidGFyZ2V0SWRzVmFsdWUiLCJkZWZvY3VzIiwiYXJnc1ZhbHVlIiwic2hvd0hpZGUiLCJldmVudE5hbWUiLCJDaGFydCIsImJpbmRUaGlzIiwiYXJnVGhpcyIsImlzRnVuYyIsImlzQ2hpbGQiLCJoYXNDaGlsZCIsImFwaUNoYXJ0IiwiYXBpQ29sb3IiLCJhcGlEYXRhIiwiYXBpRXhwb3J0IiwiYXBpRm9jdXMiLCJhcGlMZWdlbmQiLCJhcGlMb2FkIiwiYXBpU2hvdyIsImFwaVRvb2x0aXAiLCJkZWZhdWx0cyIsImJiIiwidmVyc2lvbiIsImdlbmVyYXRlIiwiaW5zdCIsImluc3RhbmNlIiwicGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztRQ1ZBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbEZBLHVEQUFhO0FBQ2I7O0FBRUE7O0FBRUEsZ0JBQWdC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QUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxnQ0FBZ0M7QUFDbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsRUFBRSwwQkFBMEI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLCtCQUErQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx1SUFBdUk7QUFDMUk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG1FQUFtRTtBQUN0RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxzRkFBc0Y7QUFDekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHNIQUFzSDtBQUN6SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHdOQUF3TjtBQUMzTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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QTBRO0FBQzdRO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxnRkFBZ0Y7QUFDbkY7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSx3R0FBd0c7QUFDM0c7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLHFGQUFxRjtBQUN4RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsK0lBQStJO0FBQ2xKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLG1GQUFtRjtBQUN0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHFFQUFxRTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGOztBQUV6Rjs7QUFFQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUscURBQXFEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9DQUFvQztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0ZBQW9GO0FBQ3ZGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLHFEQUFxRDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUseUdBQXlHO0FBQzVHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwwQkFBMEIscURBQXFELG1CQUFt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QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLFdBQVc7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsY0FBYztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0RBQW9EO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztB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QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDakhhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7Ozs7Ozs7QUM3R2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ2xKYTs7QUFFYixVQUFVLG1CQUFPLENBQUMsRUFBVTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEU7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUEwQztBQUNsRCxRQUFRLG9DQUFPLFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQSxvR0FBQztBQUMxQixLQUFLLE1BQU0sRUFJTjtBQUNMLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QixTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCO0FBQ3JCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7Ozs7Ozs7QUMzUVk7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx5Qjs7Ozs7OztBQ2JhO0FBQ2I7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLEVBQU87QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLEVBQXFCOztBQUVsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkI7Ozs7OztBQ3REQSxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFRO0FBQ25DOzs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMvRGE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUEsd0M7Ozs7OztBQ3JCQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Qjs7Ozs7O0FDdEJBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7Ozs7O0FDMURBLFVBQVUsbUJBQU8sQ0FBQyxF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RkEsS0FBS0EsUUFBTCxDQUFjL3pELElBQWQsQ0FBbUI4ekQsSUFBbkIsQ0FFQSxFQUFPQSxJQUFQO0FBQ0EsR0E1Q1M7O0FBOENWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JBSixVQXBFVSxvQkFvRUR2NkQsT0FwRUMsRUFvRVM7QUFLbEIsV0FKSUosUUFBUSxDQUFDSSxPQUFELENBSVosS0FIQ3U2RCxTQUFRLEdBQUd2NkQsT0FHWixHQUFPdTZELFNBQVA7QUFDQSxHQTFFUzs7QUE0RVY7Ozs7Ozs7Ozs7O0FBV0FLLFVBQVEsRUFBRSxFQXZGQTs7QUF5RlY7Ozs7Ozs7O0FBUUFDLFFBQU0sRUFBRTtBQWpHRSxDO0FBSlgiLCJmaWxlIjoiYmlsbGJvYXJkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwiZDMtdGltZS1mb3JtYXRcIiksIHJlcXVpcmUoXCJkMy1zZWxlY3Rpb25cIiksIHJlcXVpcmUoXCJkMy1icnVzaFwiKSwgcmVxdWlyZShcImQzLWF4aXNcIiksIHJlcXVpcmUoXCJkMy1zY2FsZVwiKSwgcmVxdWlyZShcImQzLWRzdlwiKSwgcmVxdWlyZShcImQzLWRyYWdcIiksIHJlcXVpcmUoXCJkMy10cmFuc2l0aW9uXCIpLCByZXF1aXJlKFwiZDMtem9vbVwiKSwgcmVxdWlyZShcImQzLWVhc2VcIiksIHJlcXVpcmUoXCJkMy1jb2xvclwiKSwgcmVxdWlyZShcImQzLXNoYXBlXCIpLCByZXF1aXJlKFwiZDMtaW50ZXJwb2xhdGVcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiZDMtdGltZS1mb3JtYXRcIiwgXCJkMy1zZWxlY3Rpb25cIiwgXCJkMy1icnVzaFwiLCBcImQzLWF4aXNcIiwgXCJkMy1zY2FsZVwiLCBcImQzLWRzdlwiLCBcImQzLWRyYWdcIiwgXCJkMy10cmFuc2l0aW9uXCIsIFwiZDMtem9vbVwiLCBcImQzLWVhc2VcIiwgXCJkMy1jb2xvclwiLCBcImQzLXNoYXBlXCIsIFwiZDMtaW50ZXJwb2xhdGVcIl0sIGZhY3RvcnkpO1xuXHRlbHNlIHtcblx0XHR2YXIgYSA9IHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGZhY3RvcnkocmVxdWlyZShcImQzLXRpbWUtZm9ybWF0XCIpLCByZXF1aXJlKFwiZDMtc2VsZWN0aW9uXCIpLCByZXF1aXJlKFwiZDMtYnJ1c2hcIiksIHJlcXVpcmUoXCJkMy1heGlzXCIpLCByZXF1aXJlKFwiZDMtc2NhbGVcIiksIHJlcXVpcmUoXCJkMy1kc3ZcIiksIHJlcXVpcmUoXCJkMy1kcmFnXCIpLCByZXF1aXJlKFwiZDMtdHJhbnNpdGlvblwiKSwgcmVxdWlyZShcImQzLXpvb21cIiksIHJlcXVpcmUoXCJkMy1lYXNlXCIpLCByZXF1aXJlKFwiZDMtY29sb3JcIiksIHJlcXVpcmUoXCJkMy1zaGFwZVwiKSwgcmVxdWlyZShcImQzLWludGVycG9sYXRlXCIpKSA6IGZhY3Rvcnkocm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdKTtcblx0XHRmb3IodmFyIGkgaW4gYSkgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyA/IGV4cG9ydHMgOiByb290KVtpXSA9IGFbaV07XG5cdH1cbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM2X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM3X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM4X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM5X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQwX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQxX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQyX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQzX18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ0X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ1X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ2X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ3X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ4X18pIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxuLyogZXNsaW50IHByZWZlci1kZXN0cnVjdHVyaW5nOiBvZmYgKi9cblxudmFyIHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcblxudmFyIHNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbnZhciBvdmVybGF5ID0gcmVxdWlyZSgnLi9vdmVybGF5Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nLFxuICAgIHNldExvZ0xldmVsID0gX3JlcXVpcmUuc2V0TG9nTGV2ZWw7XG5cbnZhciBzZW5kTWVzc2FnZSA9IHJlcXVpcmUoJy4vdXRpbHMvc2VuZE1lc3NhZ2UnKTtcblxudmFyIHJlbG9hZEFwcCA9IHJlcXVpcmUoJy4vdXRpbHMvcmVsb2FkQXBwJyk7XG5cbnZhciBjcmVhdGVTb2NrZXRVcmwgPSByZXF1aXJlKCcuL3V0aWxzL2NyZWF0ZVNvY2tldFVybCcpO1xuXG52YXIgc3RhdHVzID0ge1xuICBpc1VubG9hZGluZzogZmFsc2UsXG4gIGN1cnJlbnRIYXNoOiAnJ1xufTtcbnZhciBvcHRpb25zID0ge1xuICBob3Q6IGZhbHNlLFxuICBob3RSZWxvYWQ6IHRydWUsXG4gIGxpdmVSZWxvYWQ6IGZhbHNlLFxuICBpbml0aWFsOiB0cnVlLFxuICB1c2VXYXJuaW5nT3ZlcmxheTogZmFsc2UsXG4gIHVzZUVycm9yT3ZlcmxheTogZmFsc2UsXG4gIHVzZVByb2dyZXNzOiBmYWxzZVxufTtcbnZhciBzb2NrZXRVcmwgPSBjcmVhdGVTb2NrZXRVcmwoX19yZXNvdXJjZVF1ZXJ5KTtcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICBzdGF0dXMuaXNVbmxvYWRpbmcgPSB0cnVlO1xufSk7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgcXMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnRvTG93ZXJDYXNlKCk7XG4gIG9wdGlvbnMuaG90UmVsb2FkID0gcXMuaW5kZXhPZignaG90cmVsb2FkPWZhbHNlJykgPT09IC0xO1xufVxuXG52YXIgb25Tb2NrZXRNZXNzYWdlID0ge1xuICBob3Q6IGZ1bmN0aW9uIGhvdCgpIHtcbiAgICBvcHRpb25zLmhvdCA9IHRydWU7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnQgZW5hYmxlZC4nKTtcbiAgfSxcbiAgbGl2ZVJlbG9hZDogZnVuY3Rpb24gbGl2ZVJlbG9hZCgpIHtcbiAgICBvcHRpb25zLmxpdmVSZWxvYWQgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBMaXZlIFJlbG9hZGluZyBlbmFibGVkLicpO1xuICB9LFxuICBpbnZhbGlkOiBmdW5jdGlvbiBpbnZhbGlkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVjb21waWxpbmcuLi4nKTsgLy8gZml4ZXMgIzEwNDIuIG92ZXJsYXkgZG9lc24ndCBjbGVhciBpZiBlcnJvcnMgYXJlIGZpeGVkIGJ1dCB3YXJuaW5ncyByZW1haW4uXG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdJbnZhbGlkJyk7XG4gIH0sXG4gIGhhc2g6IGZ1bmN0aW9uIGhhc2goX2hhc2gpIHtcbiAgICBzdGF0dXMuY3VycmVudEhhc2ggPSBfaGFzaDtcbiAgfSxcbiAgJ3N0aWxsLW9rJzogZnVuY3Rpb24gc3RpbGxPaygpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gTm90aGluZyBjaGFuZ2VkLicpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnU3RpbGxPaycpO1xuICB9LFxuICAnbG9nLWxldmVsJzogZnVuY3Rpb24gbG9nTGV2ZWwobGV2ZWwpIHtcbiAgICB2YXIgaG90Q3R4ID0gcmVxdWlyZS5jb250ZXh0KCd3ZWJwYWNrL2hvdCcsIGZhbHNlLCAvXlxcLlxcL2xvZyQvKTtcblxuICAgIGlmIChob3RDdHgua2V5cygpLmluZGV4T2YoJy4vbG9nJykgIT09IC0xKSB7XG4gICAgICBob3RDdHgoJy4vbG9nJykuc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICAgIH1cblxuICAgIHNldExvZ0xldmVsKGxldmVsKTtcbiAgfSxcbiAgb3ZlcmxheTogZnVuY3Rpb24gb3ZlcmxheSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IGZhbHNlO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICBvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5ID0gdmFsdWUud2FybmluZ3M7XG4gICAgICAgIG9wdGlvbnMudXNlRXJyb3JPdmVybGF5ID0gdmFsdWUuZXJyb3JzO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IGZ1bmN0aW9uIHByb2dyZXNzKF9wcm9ncmVzcykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBvcHRpb25zLnVzZVByb2dyZXNzID0gX3Byb2dyZXNzO1xuICAgIH1cbiAgfSxcbiAgJ3Byb2dyZXNzLXVwZGF0ZSc6IGZ1bmN0aW9uIHByb2dyZXNzVXBkYXRlKGRhdGEpIHtcbiAgICBpZiAob3B0aW9ucy51c2VQcm9ncmVzcykge1xuICAgICAgbG9nLmluZm8oXCJbV0RTXSBcIi5jb25jYXQoZGF0YS5wZXJjZW50LCBcIiUgLSBcIikuY29uY2F0KGRhdGEubXNnLCBcIi5cIikpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdQcm9ncmVzcycsIGRhdGEpO1xuICB9LFxuICBvazogZnVuY3Rpb24gb2soKSB7XG4gICAgc2VuZE1lc3NhZ2UoJ09rJyk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluaXRpYWwpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXG5cbiAgICByZWxvYWRBcHAob3B0aW9ucywgc3RhdHVzKTtcbiAgfSxcbiAgJ2NvbnRlbnQtY2hhbmdlZCc6IGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2VkKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBDb250ZW50IGJhc2UgY2hhbmdlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgc2VsZi5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfSxcbiAgd2FybmluZ3M6IGZ1bmN0aW9uIHdhcm5pbmdzKF93YXJuaW5ncykge1xuICAgIGxvZy53YXJuKCdbV0RTXSBXYXJuaW5ncyB3aGlsZSBjb21waWxpbmcuJyk7XG5cbiAgICB2YXIgc3RyaXBwZWRXYXJuaW5ncyA9IF93YXJuaW5ncy5tYXAoZnVuY3Rpb24gKHdhcm5pbmcpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2kod2FybmluZyk7XG4gICAgfSk7XG5cbiAgICBzZW5kTWVzc2FnZSgnV2FybmluZ3MnLCBzdHJpcHBlZFdhcm5pbmdzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRXYXJuaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLndhcm4oc3RyaXBwZWRXYXJuaW5nc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2hvd01lc3NhZ2UoX3dhcm5pbmdzKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gIGVycm9yczogZnVuY3Rpb24gZXJyb3JzKF9lcnJvcnMpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIEVycm9ycyB3aGlsZSBjb21waWxpbmcuIFJlbG9hZCBwcmV2ZW50ZWQuJyk7XG5cbiAgICB2YXIgc3RyaXBwZWRFcnJvcnMgPSBfZXJyb3JzLm1hcChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBzdHJpcEFuc2koZXJyb3IpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ0Vycm9ycycsIHN0cmlwcGVkRXJyb3JzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaXBwZWRFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy5lcnJvcihzdHJpcHBlZEVycm9yc1tpXSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF9lcnJvcnMpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICB9LFxuICBlcnJvcjogZnVuY3Rpb24gZXJyb3IoX2Vycm9yKSB7XG4gICAgbG9nLmVycm9yKF9lcnJvcik7XG4gIH0sXG4gIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBsb2cuZXJyb3IoJ1tXRFNdIERpc2Nvbm5lY3RlZCEnKTtcbiAgICBzZW5kTWVzc2FnZSgnQ2xvc2UnKTtcbiAgfVxufTtcbnNvY2tldChzb2NrZXRVcmwsIG9uU29ja2V0TWVzc2FnZSk7IiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gc3RyLnJlcGxhY2UoYW5zaVJlZ2V4LCAnJykgOiBzdHI7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAvW1xcdTAwMWJcXHUwMDliXVtbKCkjOz9dKig/OlswLTldezEsNH0oPzo7WzAtOV17MCw0fSkqKT9bMC05QS1QUlpjZi1ucXJ5PT48XS9nO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZVxuICBjYW1lbGNhc2VcbiovXG4vLyB0aGlzIFNvY2tKU0NsaWVudCBpcyBoZXJlIGFzIGEgZGVmYXVsdCBmYWxsYmFjaywgaW4gY2FzZSBpbmxpbmUgbW9kZVxuLy8gaXMgb2ZmIG9yIHRoZSBjbGllbnQgaXMgbm90IGluamVjdGVkLiBUaGlzIHdpbGwgYmUgc3dpdGNoZWQgdG9cbi8vIFdlYnNvY2tldENsaWVudCB3aGVuIGl0IGJlY29tZXMgdGhlIGRlZmF1bHRcbi8vIGltcG9ydGFudDogdGhlIHBhdGggdG8gU29ja0pTQ2xpZW50IGhlcmUgaXMgbWFkZSB0byB3b3JrIGluIHRoZSAnY2xpZW50J1xuLy8gZGlyZWN0b3J5LCBidXQgaXMgdXBkYXRlZCB2aWEgdGhlIHdlYnBhY2sgY29tcGlsYXRpb24gd2hlbiBjb21waWxlZCBmcm9tXG4vLyB0aGUgJ2NsaWVudC1zcmMnIGRpcmVjdG9yeVxuXG52YXIgQ2xpZW50ID0gdHlwZW9mIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICE9PSAndW5kZWZpbmVkJyA/IF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5yZXF1aXJlKCcuL2NsaWVudHMvU29ja0pTQ2xpZW50Jyk7XG52YXIgcmV0cmllcyA9IDA7XG52YXIgY2xpZW50ID0gbnVsbDtcblxudmFyIHNvY2tldCA9IGZ1bmN0aW9uIGluaXRTb2NrZXQodXJsLCBoYW5kbGVycykge1xuICBjbGllbnQgPSBuZXcgQ2xpZW50KHVybCk7XG4gIGNsaWVudC5vbk9wZW4oZnVuY3Rpb24gKCkge1xuICAgIHJldHJpZXMgPSAwO1xuICB9KTtcbiAgY2xpZW50Lm9uQ2xvc2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChyZXRyaWVzID09PSAwKSB7XG4gICAgICBoYW5kbGVycy5jbG9zZSgpO1xuICAgIH0gLy8gVHJ5IHRvIHJlY29ubmVjdC5cblxuXG4gICAgY2xpZW50ID0gbnVsbDsgLy8gQWZ0ZXIgMTAgcmV0cmllcyBzdG9wIHRyeWluZywgdG8gcHJldmVudCBsb2dzcGFtLlxuXG4gICAgaWYgKHJldHJpZXMgPD0gMTApIHtcbiAgICAgIC8vIEV4cG9uZW50aWFsbHkgaW5jcmVhc2UgdGltZW91dCB0byByZWNvbm5lY3QuXG4gICAgICAvLyBSZXNwZWN0ZnVsbHkgY29waWVkIGZyb20gdGhlIHBhY2thZ2UgYGdvdGAuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWl4ZWQtb3BlcmF0b3JzLCBuby1yZXN0cmljdGVkLXByb3BlcnRpZXNcbiAgICAgIHZhciByZXRyeUluTXMgPSAxMDAwICogTWF0aC5wb3coMiwgcmV0cmllcykgKyBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgcmV0cmllcyArPSAxO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNvY2tldCh1cmwsIGhhbmRsZXJzKTtcbiAgICAgIH0sIHJldHJ5SW5Ncyk7XG4gICAgfVxuICB9KTtcbiAgY2xpZW50Lm9uTWVzc2FnZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBtc2cgPSBKU09OLnBhcnNlKGRhdGEpO1xuXG4gICAgaWYgKGhhbmRsZXJzW21zZy50eXBlXSkge1xuICAgICAgaGFuZGxlcnNbbXNnLnR5cGVdKG1zZy5kYXRhKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb2NrZXQ7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGVcbiAgbm8tdW51c2VkLXZhcnNcbiovXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBTb2NrSlMgPSByZXF1aXJlKCdzb2NranMtY2xpZW50L2Rpc3Qvc29ja2pzJyk7XG5cbnZhciBCYXNlQ2xpZW50ID0gcmVxdWlyZSgnLi9CYXNlQ2xpZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZUNsaWVudCkge1xuICBfaW5oZXJpdHMoU29ja0pTQ2xpZW50LCBfQmFzZUNsaWVudCk7XG5cbiAgZnVuY3Rpb24gU29ja0pTQ2xpZW50KHVybCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb2NrSlNDbGllbnQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoU29ja0pTQ2xpZW50KS5jYWxsKHRoaXMpKTtcbiAgICBfdGhpcy5zb2NrID0gbmV3IFNvY2tKUyh1cmwpO1xuXG4gICAgX3RoaXMuc29jay5vbmVycm9yID0gZnVuY3Rpb24gKGVycikgey8vIFRPRE86IHVzZSBsb2dnZXIgdG8gbG9nIHRoZSBlcnJvciBldmVudCBvbmNlIGNsaWVudCBhbmQgY2xpZW50LXNyY1xuICAgICAgLy8gYXJlIHJlb3JnYW5pemVkIHRvIGhhdmUgdGhlIHNhbWUgZGlyZWN0b3J5IHN0cnVjdHVyZVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU29ja0pTQ2xpZW50LCBbe1xuICAgIGtleTogXCJvbk9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25PcGVuKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbm9wZW4gPSBmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xvc2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9uY2xvc2UgPSBmO1xuICAgIH0gLy8gY2FsbCBmIHdpdGggdGhlIG1lc3NhZ2Ugc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25NZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVzc2FnZShmKSB7XG4gICAgICB0aGlzLnNvY2sub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZihlLmRhdGEpO1xuICAgICAgfTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXRDbGllbnRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWVudFBhdGgob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlcXVpcmUucmVzb2x2ZSgnLi9Tb2NrSlNDbGllbnQnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU29ja0pTQ2xpZW50O1xufShCYXNlQ2xpZW50KTsiLCIvKiBzb2NranMtY2xpZW50IHYxLjQuMCB8IGh0dHA6Ly9zb2NranMub3JnIHwgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLlNvY2tKUyA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhbnNwb3J0TGlzdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0LWxpc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21haW4nKSh0cmFuc3BvcnRMaXN0KTtcblxuLy8gVE9ETyBjYW4ndCBnZXQgcmlkIG9mIHRoaXMgdW50aWwgYWxsIHNlcnZlcnMgZG9cbmlmICgnX3NvY2tqc19vbmxvYWQnIGluIGdsb2JhbCkge1xuICBzZXRUaW1lb3V0KGdsb2JhbC5fc29ja2pzX29ubG9hZCwgMSk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vbWFpblwiOjE0LFwiLi90cmFuc3BvcnQtbGlzdFwiOjE2fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIENsb3NlRXZlbnQoKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdjbG9zZScsIGZhbHNlLCBmYWxzZSk7XG4gIHRoaXMud2FzQ2xlYW4gPSBmYWxzZTtcbiAgdGhpcy5jb2RlID0gMDtcbiAgdGhpcy5yZWFzb24gPSAnJztcbn1cblxuaW5oZXJpdHMoQ2xvc2VFdmVudCwgRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb3NlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnR0YXJnZXQnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbn1cblxuaW5oZXJpdHMoRXZlbnRFbWl0dGVyLCBFdmVudFRhcmdldCk7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodHlwZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub24odHlwZSwgZyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG4gIGZvciAodmFyIGFpID0gMTsgYWkgPCBsOyBhaSsrKSB7XG4gICAgYXJnc1thaSAtIDFdID0gYXJndW1lbnRzW2FpXTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG59LHtcIi4vZXZlbnR0YXJnZXRcIjo1LFwiaW5oZXJpdHNcIjo1N31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBFdmVudChldmVudFR5cGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xufVxuXG5FdmVudC5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xuICB0aGlzLmJ1YmJsZXMgPSBjYW5CdWJibGU7XG4gIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge307XG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHt9O1xuXG5FdmVudC5DQVBUVVJJTkdfUEhBU0UgPSAxO1xuRXZlbnQuQVRfVEFSR0VUID0gMjtcbkV2ZW50LkJVQkJMSU5HX1BIQVNFID0gMztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIFNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgRE9NMiBFdmVudFRhcmdldC5cbiAqICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldFxuICovXG5cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbn1cblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghKGV2ZW50VHlwZSBpbiB0aGlzLl9saXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBbXTtcbiAgfVxuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIC8vICM0XG4gIGlmIChhcnIuaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgIGFyciA9IGFyci5jb25jYXQoW2xpc3RlbmVyXSk7XG4gIH1cbiAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnI7XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICBpZiAoIWFycikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaWR4ID0gYXJyLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnIuc2xpY2UoMCwgaWR4KS5jb25jYXQoYXJyLnNsaWNlKGlkeCArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBldmVudCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIHQgPSBldmVudC50eXBlO1xuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFtldmVudF0gOiBBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgbWF0Y2ggdGhlIHJlYWwgYmVoYXZpb3I7IHBlciBzcGVjLCBvbmZvbyBnZXRcbiAgLy8gdGhlaXIgcGxhY2UgaW4gbGluZSBmcm9tIHRoZSAvZmlyc3QvIHRpbWUgdGhleSdyZSBzZXQgZnJvbVxuICAvLyBub24tbnVsbC4gQWx0aG91Z2ggV2ViS2l0IGJ1bXBzIGl0IHRvIHRoZSBlbmQgZXZlcnkgdGltZSBpdCdzXG4gIC8vIHNldC5cbiAgaWYgKHRoaXNbJ29uJyArIHRdKSB7XG4gICAgdGhpc1snb24nICsgdF0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbiAgaWYgKHQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byB0aGUgbGlzdGVuZXJzIGxpc3QuIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWF5IGFsdGVyIHRoZSBsaXN0LlxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG5cbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBUcmFuc3BvcnRNZXNzYWdlRXZlbnQoZGF0YSkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnbWVzc2FnZScsIGZhbHNlLCBmYWxzZSk7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cbmluaGVyaXRzKFRyYW5zcG9ydE1lc3NhZ2VFdmVudCwgRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydE1lc3NhZ2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICA7XG5cbmZ1bmN0aW9uIEZhY2FkZUpTKHRyYW5zcG9ydCkge1xuICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIHRyYW5zcG9ydC5vbignY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbn1cblxuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgnYycsIEpTT04zLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSkpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCd0JywgZnJhbWUpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZGF0YSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNhZGVKUztcblxufSx7XCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwianNvbjNcIjo1OH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBGYWNhZGVKUyA9IHJlcXVpcmUoJy4vZmFjYWRlJylcbiAgLCBJbmZvSWZyYW1lUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmlmcmFtZS1ib290c3RyYXAnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdmFyIHRyYW5zcG9ydE1hcCA9IHt9O1xuICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24oYXQpIHtcbiAgICBpZiAoYXQuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICB0cmFuc3BvcnRNYXBbYXQuZmFjYWRlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdID0gYXQuZmFjYWRlVHJhbnNwb3J0O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaGFyZC1jb2RlZCBmb3IgdGhlIGluZm8gaWZyYW1lXG4gIC8vIFRPRE8gc2VlIGlmIHdlIGNhbiBtYWtlIHRoaXMgbW9yZSBkeW5hbWljXG4gIHRyYW5zcG9ydE1hcFtJbmZvSWZyYW1lUmVjZWl2ZXIudHJhbnNwb3J0TmFtZV0gPSBJbmZvSWZyYW1lUmVjZWl2ZXI7XG4gIHZhciBwYXJlbnRPcmlnaW47XG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIFNvY2tKUy5ib290c3RyYXBfaWZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB2YXIgZmFjYWRlO1xuICAgIGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCA9IGxvYy5oYXNoLnNsaWNlKDEpO1xuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5zb3VyY2UgIT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudE9yaWdpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyZW50T3JpZ2luID0gZS5vcmlnaW47XG4gICAgICB9XG4gICAgICBpZiAoZS5vcmlnaW4gIT09IHBhcmVudE9yaWdpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZnJhbWVNZXNzYWdlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIHZhciBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVyc2lvbiA9IHBbMF07XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSBwWzFdO1xuICAgICAgICB2YXIgdHJhbnNVcmwgPSBwWzJdO1xuICAgICAgICB2YXIgYmFzZVVybCA9IHBbM107XG4gICAgICAgIGRlYnVnKHZlcnNpb24sIHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICAgICAgICAvLyBjaGFuZ2UgdGhpcyB0byBzZW12ZXIgbG9naWNcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IFNvY2tKUy52ZXJzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgU29ja0pTISBNYWluIHNpdGUgdXNlczonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyB2ZXJzaW9uICsgJ1wiLCB0aGUgaWZyYW1lOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIFNvY2tKUy52ZXJzaW9uICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRyYW5zVXJsLCBsb2MuaHJlZikgfHxcbiAgICAgICAgICAgICF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGJhc2VVcmwsIGxvYy5ocmVmKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjb25uZWN0IHRvIGRpZmZlcmVudCBkb21haW4gZnJvbSB3aXRoaW4gYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdpZnJhbWUuICgnICsgbG9jLmhyZWYgKyAnLCAnICsgdHJhbnNVcmwgKyAnLCAnICsgYmFzZVVybCArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKG5ldyB0cmFuc3BvcnRNYXBbdHJhbnNwb3J0XSh0cmFuc1VybCwgYmFzZVVybCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBmYWNhZGUuX3NlbmQoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgaWYgKGZhY2FkZSkge1xuICAgICAgICAgIGZhY2FkZS5fY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIG9uTWVzc2FnZSk7XG5cbiAgICAvLyBTdGFydFxuICAgIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdzJyk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9mYWNhZGVcIjo3LFwiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi9sb2NhdGlvblwiOjEzLFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9pZnJhbWVcIjo0NyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1hamF4Jyk7XG59XG5cbmZ1bmN0aW9uIEluZm9BamF4KHVybCwgQWpheE9iamVjdCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0MCA9ICtuZXcgRGF0ZSgpO1xuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ0dFVCcsIHVybCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICB2YXIgaW5mbywgcnR0O1xuICAgIGlmIChzdGF0dXMgPT09IDIwMCkge1xuICAgICAgcnR0ID0gKCtuZXcgRGF0ZSgpKSAtIHQwO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmZvID0gSlNPTjMucGFyc2UodGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9iamVjdFV0aWxzLmlzT2JqZWN0KGluZm8pKSB7XG4gICAgICAgIGluZm8gPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvQWpheCwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0FqYXgucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMueG8uY2xvc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0FqYXg7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL3V0aWxzL29iamVjdFwiOjQ5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxuZnVuY3Rpb24gSW5mb1JlY2VpdmVySWZyYW1lKHRyYW5zVXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5pciA9IG5ldyBJbmZvQWpheCh0cmFuc1VybCwgWEhSTG9jYWxPYmplY3QpO1xuICB0aGlzLmlyLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgIHNlbGYuaXIgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIEpTT04zLnN0cmluZ2lmeShbaW5mbywgcnR0XSkpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb1JlY2VpdmVySWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtaW5mby1yZWNlaXZlcic7XG5cbkluZm9SZWNlaXZlcklmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXIpIHtcbiAgICB0aGlzLmlyLmNsb3NlKCk7XG4gICAgdGhpcy5pciA9IG51bGw7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVySWZyYW1lO1xuXG59LHtcIi4vaW5mby1hamF4XCI6OSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9pZnJhbWUnKVxuICAsIEluZm9SZWNlaXZlcklmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1pZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWZyID0gc2VsZi5pZnIgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KEluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lLCB1cmwsIGJhc2VVcmwpO1xuXG4gICAgaWZyLm9uY2UoJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZCA9IEpTT04zLnBhcnNlKG1zZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBtc2cpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gZFswXSwgcnR0ID0gZFsxXTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgICAgfVxuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaWZyLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE8gdGhpcyBzZWVtcyB0aGUgc2FtZSBhcyB0aGUgJ25lZWRCb2R5JyBmcm9tIHRyYW5zcG9ydHNcbiAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSkge1xuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgZ28pO1xuICB9IGVsc2Uge1xuICAgIGdvKCk7XG4gIH1cbn1cblxuaW5oZXJpdHMoSW5mb0lmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0lmcmFtZS5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuSW5mb0lmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaWZyKSB7XG4gICAgdGhpcy5pZnIuY2xvc2UoKTtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLmlmciA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9JZnJhbWU7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vdHJhbnNwb3J0L2lmcmFtZVwiOjIyLFwiLi91dGlscy9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBYRFIgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGRyJylcbiAgLCBYSFJDb3JzID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIFhIUkZha2UgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2UnKVxuICAsIEluZm9JZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gSW5mb1JlY2VpdmVyKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgZGVidWcoYmFzZVVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmRvWGhyKGJhc2VVcmwsIHVybEluZm8pO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoSW5mb1JlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG4vLyBUT0RPIHRoaXMgaXMgY3VycmVudGx5IGlnbm9yaW5nIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSB0cmFuc3BvcnRzIGFuZCB0aGUgd2hpdGVsaXN0XG5cbkluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmwsIHVybEluZm8pIHtcbiAgLy8gZGV0ZXJtaW5lIG1ldGhvZCBvZiBDT1JTIHN1cHBvcnQgKGlmIG5lZWRlZClcbiAgaWYgKHVybEluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJMb2NhbCk7XG4gIH1cbiAgaWYgKFhIUkNvcnMuZW5hYmxlZCkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJDb3JzKTtcbiAgfVxuICBpZiAoWERSLmVuYWJsZWQgJiYgdXJsSW5mby5zYW1lU2NoZW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhEUik7XG4gIH1cbiAgaWYgKEluZm9JZnJhbWUuZW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkZha2UpO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5kb1hociA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaW5mbycpXG4gICAgO1xuICBkZWJ1ZygnZG9YaHInLCB1cmwpO1xuXG4gIHRoaXMueG8gPSBJbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyKGJhc2VVcmwsIHVybCwgdXJsSW5mbyk7XG5cbiAgdGhpcy50aW1lb3V0UmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gIH0sIEluZm9SZWNlaXZlci50aW1lb3V0KTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICB9KTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbih3YXNDbGVhbikge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFJlZik7XG4gIHRoaXMudGltZW91dFJlZiA9IG51bGw7XG4gIGlmICghd2FzQ2xlYW4gJiYgdGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgfVxuICB0aGlzLnhvID0gbnVsbDtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuSW5mb1JlY2VpdmVyLnRpbWVvdXQgPSA4MDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vaW5mby1hamF4XCI6OSxcIi4vaW5mby1pZnJhbWVcIjoxMSxcIi4vdHJhbnNwb3J0L3NlbmRlci94ZHJcIjozNCxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItY29yc1wiOjM1LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlXCI6MzYsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5sb2NhdGlvbiB8fCB7XG4gIG9yaWdpbjogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAnXG4sIHByb3RvY29sOiAnaHR0cDonXG4sIGhvc3Q6ICdsb2NhbGhvc3QnXG4sIHBvcnQ6IDgwXG4sIGhyZWY6ICdodHRwOi8vbG9jYWxob3N0LydcbiwgaGFzaDogJydcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9zaGltcycpO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuL3V0aWxzL3JhbmRvbScpXG4gICwgZXNjYXBlID0gcmVxdWlyZSgnLi91dGlscy9lc2NhcGUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCB0cmFuc3BvcnQgPSByZXF1aXJlKCcuL3V0aWxzL3RyYW5zcG9ydCcpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vdXRpbHMvYnJvd3NlcicpXG4gICwgbG9nID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudCcpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50dGFyZ2V0JylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgLCBDbG9zZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9jbG9zZScpXG4gICwgVHJhbnNwb3J0TWVzc2FnZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC90cmFucy1tZXNzYWdlJylcbiAgLCBJbmZvUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8tcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6bWFpbicpO1xufVxuXG52YXIgdHJhbnNwb3J0cztcblxuLy8gZm9sbG93IGNvbnN0cnVjdG9yIHN0ZXBzIGRlZmluZWQgYXQgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbmZ1bmN0aW9uIFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja0pTKSkge1xuICAgIHJldHVybiBuZXcgU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnU29ja0pTOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnRcIik7XG4gIH1cbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgdGhpcy5leHRlbnNpb25zID0gJyc7XG4gIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAvLyBub24tc3RhbmRhcmQgZXh0ZW5zaW9uXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgbG9nLndhcm4oXCIncHJvdG9jb2xzX3doaXRlbGlzdCcgaXMgREVQUkVDQVRFRC4gVXNlICd0cmFuc3BvcnRzJyBpbnN0ZWFkLlwiKTtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0ID0gb3B0aW9ucy50cmFuc3BvcnRzO1xuICB0aGlzLl90cmFuc3BvcnRPcHRpb25zID0gb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDA7XG5cbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XG4gIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmRvbS5zdHJpbmcoc2Vzc2lvbklkKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIHNlc3Npb25JZCBpcyB1c2VkIGluIHRoZSBvcHRpb25zLCBpdCBuZWVkcyB0byBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgfHwgcmFuZG9tLm51bWJlclN0cmluZygxMDAwKTtcblxuICAvLyBTdGVwIDEgb2YgV1Mgc3BlYyAtIHBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgdXJsLiBJc3N1ZSAjOFxuICB2YXIgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMICdcIiArIHVybCArIFwiJyBpcyBpbnZhbGlkXCIpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCdzIHNjaGVtZSBtdXN0IGJlIGVpdGhlciAnaHR0cDonIG9yICdodHRwczonLiAnXCIgKyBwYXJzZWRVcmwucHJvdG9jb2wgKyBcIicgaXMgbm90IGFsbG93ZWQuXCIpO1xuICB9XG5cbiAgdmFyIHNlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxuICBpZiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiAhc2VjdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cml0eUVycm9yOiBBbiBpbnNlY3VyZSBTb2NrSlMgY29ubmVjdGlvbiBtYXkgbm90IGJlIGluaXRpYXRlZCBmcm9tIGEgcGFnZSBsb2FkZWQgb3ZlciBIVFRQUycpO1xuICB9XG5cbiAgLy8gU3RlcCAzIC0gY2hlY2sgcG9ydCBhY2Nlc3MgLSBubyBuZWVkIGhlcmVcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIGlmICghcHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICB9XG5cbiAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIHZhciBzb3J0ZWRQcm90b2NvbHMgPSBwcm90b2NvbHMuc29ydCgpO1xuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgKHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxKSAmJiBwcm90byA9PT0gc29ydGVkUHJvdG9jb2xzW2kgKyAxXSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gIHZhciBvID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGxvYy5ocmVmKTtcbiAgdGhpcy5fb3JpZ2luID0gbyA/IG8udG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICBwYXJzZWRVcmwuc2V0KCdwYXRobmFtZScsIHBhcnNlZFVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sICcnKSk7XG5cbiAgLy8gc3RvcmUgdGhlIHNhbml0aXplZCB1cmxcbiAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcblxuICAvLyBTdGVwIDcgLSBzdGFydCBjb25uZWN0aW9uIGluIGJhY2tncm91bmRcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gIC8vIGh0dHA6Ly9zb2NranMuZ2l0aHViLmlvL3NvY2tqcy1wcm90b2NvbC9zb2NranMtcHJvdG9jb2wtMC4zLjMuaHRtbCNzZWN0aW9uLTI2XG4gIHRoaXMuX3VybEluZm8gPSB7XG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcbiAgLCBzYW1lT3JpZ2luOiB1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgLCBzYW1lU2NoZW1lOiB1cmxVdGlscy5pc1NjaGVtZUVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgfTtcblxuICB0aGlzLl9pciA9IG5ldyBJbmZvUmVjZWl2ZXIodGhpcy51cmwsIHRoaXMuX3VybEluZm8pO1xuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcbn1cblxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XG5cbmZ1bmN0aW9uIHVzZXJTZXRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufVxuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIC8vIFN0ZXAgMVxuICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XG4gIH1cbiAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncmVhc29uIGFyZ3VtZW50IGhhcyBhbiBpbnZhbGlkIGxlbmd0aCcpO1xuICB9XG5cbiAgLy8gU3RlcCAzLjFcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xuICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICB0aGlzLl9jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCAnTm9ybWFsIGNsb3N1cmUnLCB3YXNDbGVhbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgLy8gVE9ETyB0aGlzIGN1cnJlbnRseSB0dXJucyBvYmplY3RzIGludG8gW29iamVjdCBPYmplY3RdXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVzY2FwZS5xdW90ZShkYXRhKSk7XG59O1xuXG5Tb2NrSlMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgZGVidWcoJ19yZWNlaXZlSW5mbycsIHJ0dCk7XG4gIHRoaXMuX2lyID0gbnVsbDtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhpcy5fY2xvc2UoMTAwMiwgJ0Nhbm5vdCBjb25uZWN0IHRvIHNlcnZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBhIHJvdW5kLXRyaXAgdGltZW91dCAoUlRPKSBiYXNlZCBvbiB0aGVcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gIHRoaXMuX3J0byA9IHRoaXMuY291bnRSVE8ocnR0KTtcbiAgLy8gYWxsb3cgc2VydmVyIHRvIG92ZXJyaWRlIHVybCB1c2VkIGZvciB0aGUgYWN0dWFsIHRyYW5zcG9ydFxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gIGluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoaW5mbywgdGhpcy5fdXJsSW5mbyk7XG4gIGRlYnVnKCdpbmZvJywgaW5mbyk7XG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gIHZhciBlbmFibGVkVHJhbnNwb3J0cyA9IHRyYW5zcG9ydHMuZmlsdGVyVG9FbmFibGVkKHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pO1xuICB0aGlzLl90cmFuc3BvcnRzID0gZW5hYmxlZFRyYW5zcG9ydHMubWFpbjtcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuXG4gIHRoaXMuX2Nvbm5lY3QoKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xuICAgIGRlYnVnKCdhdHRlbXB0JywgVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUpO1xuICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAodHlwZW9mIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgYm9keScpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGltZW91dCBiYXNlZCBvbiBSVE8gYW5kIHJvdW5kIHRyaXBzLiBEZWZhdWx0IHRvIDVzXG4gICAgdmFyIHRpbWVvdXRNcyA9IE1hdGgubWF4KHRoaXMuX3RpbWVvdXQsICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0LmJpbmQodGhpcyksIHRpbWVvdXRNcyk7XG4gICAgZGVidWcoJ3VzaW5nIHRpbWVvdXQnLCB0aW1lb3V0TXMpO1xuXG4gICAgdmFyIHRyYW5zcG9ydFVybCA9IHVybFV0aWxzLmFkZFBhdGgodGhpcy5fdHJhbnNVcmwsICcvJyArIHRoaXMuX3NlcnZlciArICcvJyArIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkKCkpO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5fdHJhbnNwb3J0T3B0aW9uc1tUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV07XG4gICAgZGVidWcoJ3RyYW5zcG9ydCB1cmwnLCB0cmFuc3BvcnRVcmwpO1xuICAgIHZhciB0cmFuc3BvcnRPYmogPSBuZXcgVHJhbnNwb3J0KHRyYW5zcG9ydFVybCwgdGhpcy5fdHJhbnNVcmwsIG9wdGlvbnMpO1xuICAgIHRyYW5zcG9ydE9iai5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgdHJhbnNwb3J0T2JqLm9uY2UoJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdHJhbnNwb3J0T2JqLnRyYW5zcG9ydE5hbWUgPSBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnRPYmo7XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fY2xvc2UoMjAwMCwgJ0FsbCB0cmFuc3BvcnRzIGZhaWxlZCcsIGZhbHNlKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRUaW1lb3V0Jyk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhbnNwb3J0Q2xvc2UoMjAwNywgJ1RyYW5zcG9ydCB0aW1lZCBvdXQnKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICBkZWJ1ZygnX3RyYW5zcG9ydE1lc3NhZ2UnLCBtc2cpO1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHR5cGUgPSBtc2cuc2xpY2UoMCwgMSlcbiAgICAsIGNvbnRlbnQgPSBtc2cuc2xpY2UoMSlcbiAgICAsIHBheWxvYWRcbiAgICA7XG5cbiAgLy8gZmlyc3QgY2hlY2sgZm9yIG1lc3NhZ2VzIHRoYXQgZG9uJ3QgbmVlZCBhIHBheWxvYWRcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbyc6XG4gICAgICB0aGlzLl9vcGVuKCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnaCc6XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdoZWFydGJlYXQnKSk7XG4gICAgICBkZWJ1ZygnaGVhcnRiZWF0JywgdGhpcy50cmFuc3BvcnQpO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgcGF5bG9hZCA9IEpTT04zLnBhcnNlKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZWJ1ZygnZW1wdHkgcGF5bG9hZCcsIGNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2EnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgcGF5bG9hZC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBkZWJ1ZygnbWVzc2FnZScsIHNlbGYudHJhbnNwb3J0LCBwKTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbSc6XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIHRoaXMudHJhbnNwb3J0LCBwYXlsb2FkKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHBheWxvYWQpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2MnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkgJiYgcGF5bG9hZC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY2xvc2UocGF5bG9hZFswXSwgcGF5bG9hZFsxXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgZGVidWcoJ190cmFuc3BvcnRDbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24pO1xuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF1c2VyU2V0Q29kZShjb2RlKSAmJiBjb2RlICE9PSAyMDAwICYmIHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLl9jb25uZWN0KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY2xvc2UoY29kZSwgcmVhc29uKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19vcGVuJywgdGhpcy5fdHJhbnNwb3J0ICYmIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAvLyBjb25uZWN0aW9uLlxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4sIHRoaXMucmVhZHlTdGF0ZSk7XG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5faXIpIHtcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xuICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgdGhpcy5faXIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBTb2NrSlMgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQnKTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKTtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpO1xuICAgIGUud2FzQ2xlYW4gPSB3YXNDbGVhbiB8fCBmYWxzZTtcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgZS5yZWFzb24gPSByZWFzb247XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgdGhpcy5vbm1lc3NhZ2UgPSB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cblNvY2tKUy5wcm90b3R5cGUuY291bnRSVE8gPSBmdW5jdGlvbihydHQpIHtcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAvLyB0cmFuc3BvcnQgdGhlIHRpbWUgbmVlZGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gKHRoZSB0aW1lIHRoYXQgcGFzc1xuICAvLyBmcm9tIHRoZSBvcGVuaW5nIG9mIHRoZSB0cmFuc3BvcnQgdG8gdGhlIGNhbGwgb2YgYF9kaXNwYXRjaE9wZW5gKSBpc1xuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gIC8vIGNhdXNlcyBzcHVyaW91cyB0aW1lb3V0cy4gRm9yIHRoaXMgcmVhc29uIHdlIGNhbGN1bGF0ZSBhIHZhbHVlIHNsaWdodGx5XG4gIC8vIGxhcmdlciB0aGFuIHRoYXQgdXNlZCBpbiB0aGUgYXJ0aWNsZS5cbiAgaWYgKHJ0dCA+IDEwMCkge1xuICAgIHJldHVybiA0ICogcnR0OyAvLyBydG8gPiA0MDBtc2VjXG4gIH1cbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmVxdWlyZSgnLi9pZnJhbWUtYm9vdHN0cmFwJykoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmV0dXJuIFNvY2tKUztcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vZXZlbnQvY2xvc2VcIjoyLFwiLi9ldmVudC9ldmVudFwiOjQsXCIuL2V2ZW50L2V2ZW50dGFyZ2V0XCI6NSxcIi4vZXZlbnQvdHJhbnMtbWVzc2FnZVwiOjYsXCIuL2lmcmFtZS1ib290c3RyYXBcIjo4LFwiLi9pbmZvLXJlY2VpdmVyXCI6MTIsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3NoaW1zXCI6MTUsXCIuL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vdXRpbHMvZXNjYXBlXCI6NDUsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2xvZ1wiOjQ4LFwiLi91dGlscy9vYmplY3RcIjo0OSxcIi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuL3V0aWxzL3RyYW5zcG9ydFwiOjUxLFwiLi91dGlscy91cmxcIjo1MixcIi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4LFwidXJsLXBhcnNlXCI6NjF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoganNjczogZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG59XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbmZ1bmN0aW9uIEVtcHR5KCkge31cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cblxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5leHRlbmRlZCAgID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvci5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHZvaWQgMCA/XG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBzdHJlYW1pbmcgdHJhbnNwb3J0c1xuICByZXF1aXJlKCcuL3RyYW5zcG9ydC93ZWJzb2NrZXQnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAvLyBwb2xsaW5nIHRyYW5zcG9ydHNcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXG5dO1xuXG59LHtcIi4vdHJhbnNwb3J0L2V2ZW50c291cmNlXCI6MjAsXCIuL3RyYW5zcG9ydC9odG1sZmlsZVwiOjIxLFwiLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZ1wiOjIzLFwiLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwXCI6MjYsXCIuL3RyYW5zcG9ydC93ZWJzb2NrZXRcIjozOCxcIi4vdHJhbnNwb3J0L3hkci1wb2xsaW5nXCI6MzksXCIuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nXCI6NDAsXCIuL3RyYW5zcG9ydC94aHItcG9sbGluZ1wiOjQxLFwiLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZ1wiOjQyfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgWEhSID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0XG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xufVxuXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLnhociA9IG5ldyBYSFIoKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxuXG4gIGlmICghdGhpcy54aHIpIHtcbiAgICBkZWJ1Zygnbm8geGhyJyk7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnbm8geGhyIHN1cHBvcnQnKTtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgLy8gdGFiIGdldHMgY2xvc2VkOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC81MjgwXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQgY2xlYW51cCcpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIHRoaXMueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICB0aGlzLnhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcbiAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCghb3B0cyB8fCAhb3B0cy5ub0NyZWRlbnRpYWxzKSAmJiBBYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMpIHtcbiAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxuICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnhocikge1xuICAgICAgdmFyIHggPSBzZWxmLnhocjtcbiAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgLy8gb24gTWljcm9zb2Z0LlhNTEhUVFAgYW5kIHJlYWR5c3RhdGU9M1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgIHRleHQgPSB4LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlYnVnKCdjaHVuaycpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzODM3NzAodj12cy44NSkuYXNweFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjAwNSB8fCBzdGF0dXMgPT09IDEyMDI5KSB7XG4gICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfVxufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgaWYgKCF0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XG4vLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2Lzdcbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIChheG8gaW4gZ2xvYmFsKSkge1xuICBkZWJ1Zygnb3ZlcnJpZGluZyB4bWxodHRwcmVxdWVzdCcpO1xuICBYSFIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIW5ldyBYSFIoKTtcbn1cblxudmFyIGNvcnMgPSBmYWxzZTtcbnRyeSB7XG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XG59IGNhdGNoIChpZ25vcmVkKSB7XG4gIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbn1cblxuQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFhIUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5pZiAoRHJpdmVyKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckRyaXZlcih1cmwpIHtcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvZXZlbnRzb3VyY2VcIjoyOSxcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEh0bWxmaWxlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2h0bWxmaWxlJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gIDtcblxuZnVuY3Rpb24gSHRtbEZpbGVUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIFhIUkxvY2FsT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkh0bWxGaWxlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIHJldHVybiBIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luO1xufTtcblxuSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sRmlsZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6MzAsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XG4vLyAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MxOTcwMTUodj1WUy44NSkuYXNweFxuLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICBpZiAoIUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub3JpZ2luID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGJhc2VVcmwpO1xuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcblxuICB2YXIgaWZyYW1lVXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2lmcmFtZS5odG1sJykgKyAnIycgKyB0aGlzLndpbmRvd0lkO1xuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xuXG4gIHRoaXMuaWZyYW1lT2JqID0gaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lKGlmcmFtZVVybCwgZnVuY3Rpb24ocikge1xuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1VuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoJyArIHIgKyAnKScpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xufVxuXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gICAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgIGRlYnVnKCdub3Qgc2FtZSBvcmlnaW4nLCBlLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xuICB0cnkge1xuICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gIGNhc2UgJ3MnOlxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIC8vIHdpbmRvdyBnbG9iYWwgZGVwZW5kZW5jeVxuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ3MnLCBKU09OMy5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNkYXRhWzBdLCBjZGF0YVsxXSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcbiAgdGhpcy5pZnJhbWVPYmoucG9zdChKU09OMy5zdHJpbmdpZnkoe1xuICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICwgdHlwZTogdHlwZVxuICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgfSksIHRoaXMub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5wb3N0TWVzc2FnZSgnbScsIG1lc3NhZ2UpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3Rcbi8vIGV2ZXJ5d2hlcmUuXG4vLyBLbm93biBsaW1pdGF0aW9uczpcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3Jcbi8vICAgbyBmb3IgS29ucXVlcm9yIGEgZHVtYiB0aW1lciBpcyBuZWVkZWQgdG8gZGV0ZWN0IGVycm9yc1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9zZW5kZXItcmVjZWl2ZXInKVxuICAsIEpzb25wUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2pzb25wJylcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcbiAgO1xuXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUpzb25QVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsICcvanNvbnAnLCBqc29ucFNlbmRlciwgSnNvbnBSZWNlaXZlcik7XG59XG5cbmluaGVyaXRzKEpzb25QVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50O1xufTtcblxuSnNvblBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdqc29ucC1wb2xsaW5nJztcbkpzb25QVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAxO1xuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25QVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmFqYXgtYmFzZWQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ2NyZWF0ZSBhamF4IHNlbmRlcicsIHVybCwgcGF5bG9hZCk7XG4gICAgdmFyIG9wdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5oZWFkZXJzID0geydDb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbid9O1xuICAgIH1cbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XG4gICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCBhamF4VXJsLCBwYXlsb2FkLCBvcHQpO1xuICAgIHhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdodHRwIHN0YXR1cyAnICsgc3RhdHVzKSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xuICAgICAgeG8uY2xvc2UoKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBBamF4QmFzZWRUcmFuc3BvcnQodHJhbnNVcmwsIHVybFN1ZmZpeCwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqYXhCYXNlZFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnVmZmVyZWQtc2VuZGVyJyk7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkU2VuZGVyKHVybCwgc2VuZGVyKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gIHRoaXMudXJsID0gdXJsO1xufVxuXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICBpZiAoIXRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xuICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmVmO1xuICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3NlbmRTdG9wJyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICB9O1xuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XG4gIH0sIDI1KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZScsIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhpcy5zZW5kQnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSB8fCAxMDA2LCAnU2VuZGluZyBlcnJvcjogJyArIGVycik7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2VuZFNjaGVkdWxlV2FpdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTdG9wKCk7XG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL29iamVjdFwiOjQ5LFwiLi4vaWZyYW1lXCI6MjIsXCJpbmhlcml0c1wiOjU3fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2J1ZmZlcmVkLXNlbmRlclwiOjI1LFwiLi9wb2xsaW5nXCI6MjcsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG59XG5cbmZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB2YXIgdXJsV2l0aElkID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgdGhpcy5fY3JlYXRlU2NyaXB0KHVybFdpdGhJZCk7XG5cbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XG4gIH0sIEpzb25wUmVjZWl2ZXIudGltZW91dCk7XG59XG5cbmluaGVyaXRzKEpzb25wUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAoZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgdGhpcy5fYWJvcnQoZXJyKTtcbiAgfVxufTtcblxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XG5Kc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGVidWcoJ19jYWxsYmFjaycsIGRhdGEpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgaWYgKHRoaXMuYWJvcnRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5hYm9ydGluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcbiAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgIHRoaXMuc2NyaXB0MiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcbiAgICAvLyB0aGUgc2NyaXB0LlxuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9zY3JpcHRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjcmlwdEVycm9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyb3JUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKScpKTtcbiAgICB9XG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgZGVidWcoJ19jcmVhdGVTY3JpcHQnLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIHNjcmlwdDI7ICAvLyBPcGVyYSBzeW5jaHJvbm91cyBsb2FkIHRyaWNrLlxuXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpJykpO1xuICB9O1xuXG4gIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgLy8gVXNlIGxvYWRlZE9rYXkgdG8gZGV0ZXJtaW5lIGlmIGFjdHVhbGx5IGVycm9yZWRcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBzY3JpcHQucmVhZHlTdGF0ZSk7XG4gICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICBzZWxmLmxvYWRlZE9rYXkgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgIGlmICghYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICB0cnkge1xuICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIiArIHNjcmlwdC5pZCArIFwiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIH1cblxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIGlmIChzY3JpcHQyKSB7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5idWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsLCBudWxsKTtcbiAgdGhpcy54by5vbignY2h1bmsnLCB0aGlzLl9jaHVua0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi54byA9IG51bGw7XG4gICAgdmFyIHJlYXNvbiA9IHN0YXR1cyA9PT0gMjAwID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jaHVua0hhbmRsZXIgPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgZGVidWcoJ19jaHVua0hhbmRsZXInLCBzdGF0dXMpO1xuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAtMTsgOyB0aGlzLmJ1ZmZlclBvc2l0aW9uICs9IGlkeCArIDEpIHtcbiAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIGlkeCk7XG4gICAgaWYgKG1zZykge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICd1c2VyJyk7XG4gICAgdGhpcy54byA9IG51bGw7XG4gIH1cbiAgdGhpcy5fY2xlYW51cCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbn1cblxudmFyIGZvcm0sIGFyZWE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShpZCkge1xuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICB0cnkge1xuICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9ybSgpIHtcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgZm9ybSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcblxuICBhcmVhID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGFyZWEubmFtZSA9ICdkJztcbiAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIGRlYnVnKHVybCwgcGF5bG9hZCk7XG4gIGlmICghZm9ybSkge1xuICAgIGNyZWF0ZUZvcm0oKTtcbiAgfVxuICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBmb3JtLnRhcmdldCA9IGlkO1xuICBmb3JtLmFjdGlvbiA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL2pzb25wX3NlbmQnKSwgJ2k9JyArIGlkKTtcblxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcbiAgaWZyYW1lLmlkID0gaWQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgfVxuICBmb3JtLnN1Ym1pdCgpO1xuXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgaWYgKCFpZnJhbWUub25lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUgPSBudWxsO1xuICAgIH0sIDUwMCk7XG4gICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgaWYgdGhlIGlmcmFtZSBzdWNjZWVkZWQgb3JcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XG4gICAgY29tcGxldGVkKG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6eGRyJyk7XG59XG5cbi8vIFJlZmVyZW5jZXM6XG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcbi8vICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMjg4MDYwKHY9VlMuODUpLmFzcHhcblxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKFhEUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZygnX3N0YXJ0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcbiAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncHJvZ3Jlc3MnLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLmVtaXQoJ2NodW5rJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdsb2FkJyk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9O1xuICB0aGlzLnhkciA9IHhkcjtcbiAgdGhpcy51bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMueGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMueGRyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB0aGlzLl9lcnJvcigpO1xuICB9XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnLCBhYm9ydCk7XG4gIGlmICghdGhpcy54ZHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIHRoaXMueGRyLm9udGltZW91dCA9IHRoaXMueGRyLm9uZXJyb3IgPSB0aGlzLnhkci5vbnByb2dyZXNzID0gdGhpcy54ZHIub25sb2FkID0gbnVsbDtcbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGRyID0gbnVsbDtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XG5YRFJPYmplY3QuZW5hYmxlZCA9ICEhKGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiBicm93c2VyLmhhc0RvbWFpbigpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkZha2UoLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XG4gIH0sIFhIUkZha2UudGltZW91dCk7XG59XG5cbmluaGVyaXRzKFhIUkZha2UsIEV2ZW50RW1pdHRlcik7XG5cblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcbn07XG5cblhIUkZha2UudGltZW91dCA9IDIwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcblxufSx7XCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBXZWJzb2NrZXREcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlci93ZWJzb2NrZXQnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6d2Vic29ja2V0Jyk7XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydCh0cmFuc1VybCwgaWdub3JlLCBvcHRpb25zKSB7XG4gIGlmICghV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjb25zdHJ1Y3RvcicsIHRyYW5zVXJsKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCAnL3dlYnNvY2tldCcpO1xuICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgfVxuICB0aGlzLnVybCA9IHVybDtcblxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZSBldmVudCcsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgfTtcbiAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gIC8vIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2UuIEluIHN1Y2ggc2l0dWF0aW9uIGxldCdzIGxpZSAtXG4gIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NjA4NVxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkJyk7XG4gICAgc2VsZi53cy5jbG9zZSgpO1xuICB9KTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdjbG9zZSBldmVudCcsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1dlYlNvY2tldCBjb25uZWN0aW9uIGJyb2tlbicpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xuICBkZWJ1Zygnc2VuZCcsIG1zZyk7XG4gIHRoaXMud3Muc2VuZChtc2cpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAod3MpIHtcbiAgICB3cy5jbG9zZSgpO1xuICB9XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi9kcml2ZXIvd2Vic29ja2V0XCI6MTksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcblhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU3fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5mdW5jdGlvbiBYZHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8uY29va2llX25lZWRlZCB8fCBpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFhEUk9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZVNjaGVtZTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1zdHJlYW1pbmcnO1xuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiaW5oZXJpdHNcIjo1N31dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICA7XG5cbmZ1bmN0aW9uIFhoclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXBvbGxpbmcnO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qgc3VwcG9ydCB4aHItc3RyZWFtaW5nICM2MFxuICAvLyBCdXQgaXQgbWlnaHQgYmUgYWJsZSB0byAjOTJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1zdHJlYW1pbmcnO1xuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuLy8gYmVmb3JlIG9ubG9hZC4gVGhpcyBjYXVzZXMgdGhlIGxvYWQgaW5kaWNhdG9yIHRvIHNwaW4gaW5kZWZpbmV0ZWx5LlxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRCb2R5ID0gISFnbG9iYWwuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi91dGlscy9icm93c2VyXCI6NDQsXCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcbiAgLCBleHRyYUxvb2t1cDtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxMb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgdmFyIGk7XG4gIHZhciB1bnJvbGxlZCA9IHt9O1xuICB2YXIgYyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICB9XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OMy5zdHJpbmdpZnkoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYUVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFFc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcbiAgICB9KTtcbiAgfVxufTtcblxufSx7XCJqc29uM1wiOjU4fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL3JhbmRvbVwiOjUwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04zLnN0cmluZ2lmeSh7XG4gICAgICAgIHdpbmRvd0lkOiBtb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93SWRcbiAgICAgICwgdHlwZTogdHlwZVxuICAgICAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gICAgICB9KSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy4nLCB0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuLCBjcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cblxuLyogZXNsaW50IG5vLXVuZGVmOiBcIm9mZlwiLCBuZXctY2FwOiBcIm9mZlwiICovXG4sIGNyZWF0ZUh0bWxmaWxlOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XG4gICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgcik7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvYy5vcGVuKCk7XG4gICAgZG9jLndyaXRlKCc8aHRtbD48cycgKyAnY3JpcHQ+JyArXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcbiAgICAgICAgICAgICAgJzwvcycgKyAnY3JpcHQ+PC9odG1sPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XG4gICAgdmFyIGMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGMuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIC8vIHBvc3RNZXNzYWdlIG1pc2JlaGF2ZXMgaW4ga29ucXVlcm9yIDQuNi41IC0gdGhlIG1lc3NhZ2VzIGFyZSBkZWxpdmVyZWQgd2l0aFxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxuICBtb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gKHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFicm93c2VyLmlzS29ucXVlcm9yKCkpO1xufVxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2Jyb3dzZXJcIjo0NCxcIi4vZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nT2JqZWN0ID0ge307XG5bJ2xvZycsICdkZWJ1ZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgdmFyIGxldmVsRXhpc3RzO1xuXG4gIHRyeSB7XG4gICAgbGV2ZWxFeGlzdHMgPSBnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0gJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5O1xuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfSA6IChsZXZlbCA9PT0gJ2xvZycgPyBmdW5jdGlvbiAoKSB7fSA6IGxvZ09iamVjdC5sb2cpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nT2JqZWN0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxufSx7fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgY3J5cHRvOnRydWUgKi9cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLy8gVGhpcyBzdHJpbmcgaGFzIGxlbmd0aCAzMiwgYSBwb3dlciBvZiAyLCBzbyB0aGUgbW9kdWx1cyBkb2Vzbid0IGludHJvZHVjZSBhXG4vLyBiaWFzLlxudmFyIF9yYW5kb21TdHJpbmdDaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NSc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgbWF4ID0gX3JhbmRvbVN0cmluZ0NoYXJzLmxlbmd0aDtcbiAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmV0LnB1c2goX3JhbmRvbVN0cmluZ0NoYXJzLnN1YnN0cihieXRlc1tpXSAlIG1heCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiwgbnVtYmVyOiBmdW5jdGlvbihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbiAgfVxuXG4sIG51bWJlclN0cmluZzogZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcbiAgICB2YXIgcCA9IG5ldyBBcnJheSh0ICsgMSkuam9pbignMCcpO1xuICAgIHJldHVybiAocCArIHRoaXMubnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbiAgfVxufTtcblxufSx7XCJjcnlwdG9cIjo0M31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0T3JpZ2luOiBmdW5jdGlvbih1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHAucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3J0ID0gcC5wb3J0O1xuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IChwLnByb3RvY29sID09PSAnaHR0cHM6JykgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAucHJvdG9jb2wgKyAnLy8nICsgcC5ob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gIH1cblxuLCBpc09yaWdpbkVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZ2V0T3JpZ2luKGEpID09PSB0aGlzLmdldE9yaWdpbihiKTtcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4sIGlzU2NoZW1lRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuc3BsaXQoJzonKVswXSA9PT0gYi5zcGxpdCgnOicpWzBdKTtcbiAgfVxuXG4sIGFkZFBhdGg6IGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICByZXR1cm4gcXNbMF0gKyBwYXRoICsgKHFzWzFdID8gJz8nICsgcXNbMV0gOiAnJyk7XG4gIH1cblxuLCBhZGRRdWVyeTogZnVuY3Rpb24gKHVybCwgcSkge1xuICAgIHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAoJz8nICsgcSkgOiAoJyYnICsgcSkpO1xuICB9XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcInVybC1wYXJzZVwiOjYxfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAnMS40LjAnO1xuXG59LHt9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLT9cXGQ/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7IC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG5cbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcbiAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG5cbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBTd2FsbG93XG4gIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vY29tbW9uXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzYWJsZWQ/XG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuXG59LHtcIm1zXCI6NTR9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcblxuICAgIC8vXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXG4gICAgLy8gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2Agb3IgX19wcm90b19fIGFyZSBub3Qgb3ZlcnJpZGVuIGJ5IG1hbGljaW91c1xuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cbiAgICAvL1xuICAgIGlmIChrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG5cbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2lcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzKSB7ICAgICAgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoJ1xcXFwnLCAnLycpO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsICYmIGdsb2JhbC5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgc2xhc2hlczogISFtYXRjaFsyXSxcbiAgICByZXN0OiBtYXRjaFszXVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcInF1ZXJ5c3RyaW5naWZ5XCI6NTksXCJyZXF1aXJlcy1wb3J0XCI6NjB9XX0se30sWzFdKSgxKVxufSk7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ja2pzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGVcbiAgbm8tdW51c2VkLXZhcnNcbiovXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlQ2xpZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlQ2xpZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ2xpZW50LCBudWxsLCBbe1xuICAgIGtleTogXCJnZXRDbGllbnRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWVudFBhdGgob3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbmVlZHMgaW1wbGVtZW50YXRpb24nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZUNsaWVudDtcbn0oKTsiLCIndXNlIHN0cmljdCc7IC8vIFRoZSBlcnJvciBvdmVybGF5IGlzIGluc3BpcmVkIChhbmQgbW9zdGx5IGNvcGllZCkgZnJvbSBDcmVhdGUgUmVhY3QgQXBwIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcClcbi8vIFRoZXksIGluIHR1cm4sIGdvdCBpbnNwaXJlZCBieSB3ZWJwYWNrLWhvdC1taWRkbGV3YXJlIChodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmUpLlxuXG52YXIgYW5zaUhUTUwgPSByZXF1aXJlKCdhbnNpLWh0bWwnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnaHRtbC1lbnRpdGllcycpLFxuICAgIEFsbEh0bWxFbnRpdGllcyA9IF9yZXF1aXJlLkFsbEh0bWxFbnRpdGllcztcblxudmFyIGVudGl0aWVzID0gbmV3IEFsbEh0bWxFbnRpdGllcygpO1xudmFyIGNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsndHJhbnNwYXJlbnQnLCAndHJhbnNwYXJlbnQnXSxcbiAgYmxhY2s6ICcxODE4MTgnLFxuICByZWQ6ICdFMzYwNDknLFxuICBncmVlbjogJ0IzQ0I3NCcsXG4gIHllbGxvdzogJ0ZGRDA4MCcsXG4gIGJsdWU6ICc3Q0FGQzInLFxuICBtYWdlbnRhOiAnN0ZBQ0NBJyxcbiAgY3lhbjogJ0MzQzJFRicsXG4gIGxpZ2h0Z3JleTogJ0VCRTdFMycsXG4gIGRhcmtncmV5OiAnNkQ3ODkxJ1xufTtcbnZhciBvdmVybGF5SWZyYW1lID0gbnVsbDtcbnZhciBvdmVybGF5RGl2ID0gbnVsbDtcbnZhciBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXlJZnJhbWUob25JZnJhbWVMb2FkKSB7XG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgaWZyYW1lLmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheSc7XG4gIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBpZnJhbWUuc3R5bGUubGVmdCA9IDA7XG4gIGlmcmFtZS5zdHlsZS50b3AgPSAwO1xuICBpZnJhbWUuc3R5bGUucmlnaHQgPSAwO1xuICBpZnJhbWUuc3R5bGUuYm90dG9tID0gMDtcbiAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGlmcmFtZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gIGlmcmFtZS5zdHlsZS56SW5kZXggPSA5OTk5OTk5OTk5O1xuICBpZnJhbWUub25sb2FkID0gb25JZnJhbWVMb2FkO1xuICByZXR1cm4gaWZyYW1lO1xufVxuXG5mdW5jdGlvbiBhZGRPdmVybGF5RGl2VG8oaWZyYW1lKSB7XG4gIHZhciBkaXYgPSBpZnJhbWUuY29udGVudERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5LWRpdic7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGRpdi5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gIGRpdi5zdHlsZS5sZWZ0ID0gMDtcbiAgZGl2LnN0eWxlLnRvcCA9IDA7XG4gIGRpdi5zdHlsZS5yaWdodCA9IDA7XG4gIGRpdi5zdHlsZS5ib3R0b20gPSAwO1xuICBkaXYuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuODUpJztcbiAgZGl2LnN0eWxlLmNvbG9yID0gJyNFOEU4RTgnO1xuICBkaXYuc3R5bGUuZm9udEZhbWlseSA9ICdNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZSc7XG4gIGRpdi5zdHlsZS5mb250U2l6ZSA9ICdsYXJnZSc7XG4gIGRpdi5zdHlsZS5wYWRkaW5nID0gJzJyZW0nO1xuICBkaXYuc3R5bGUubGluZUhlaWdodCA9ICcxLjInO1xuICBkaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gIGRpdi5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHJldHVybiBkaXY7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMob25PdmVybGF5RGl2UmVhZHkpIHtcbiAgaWYgKG92ZXJsYXlEaXYpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGlzIHJlYWR5LCBjYWxsIHRoZSBjYWxsYmFjayByaWdodCBhd2F5LlxuICAgIG9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGluZyBhbiBpZnJhbWUgbWF5IGJlIGFzeW5jaHJvbm91cyBzbyB3ZSdsbCBzY2hlZHVsZSB0aGUgY2FsbGJhY2suXG4gIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgY2FsbHMsIGxhc3QgY2FsbGJhY2sgd2lucy5cblxuXG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG9uT3ZlcmxheURpdlJlYWR5O1xuXG4gIGlmIChvdmVybGF5SWZyYW1lKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBjcmVhdGVkIGl0LlxuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxuXG5cbiAgb3ZlcmxheUlmcmFtZSA9IGNyZWF0ZU92ZXJsYXlJZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7IC8vIE5vdyB3ZSBjYW4gdGFsayFcblxuICAgIGxhc3RPbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgfSk7IC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxuICAvLyBvciBhc3luY2hyb25vdXNseSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gIC8vIFdlIGRlbGF5IGFkZGluZyBpdCBzbyBgb3ZlcmxheUlmcmFtZWAgaXMgc2V0IHdoZW4gYG9uSWZyYW1lTG9hZGAgZmlyZXMuXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5SWZyYW1lKTtcbn0gLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cblxuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgaWYgKCFvdmVybGF5RGl2KSB7XG4gICAgLy8gSXQgaXMgbm90IHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICByZXR1cm47XG4gIH0gLy8gQ2xlYW4gdXAgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlLlxuXG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5SWZyYW1lKTtcbiAgb3ZlcmxheURpdiA9IG51bGw7XG4gIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xufSAvLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cblxuXG5mdW5jdGlvbiBzaG93TWVzc2FnZShtZXNzYWdlcykge1xuICBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKGZ1bmN0aW9uIChkaXYpIHtcbiAgICAvLyBNYWtlIGl0IGxvb2sgc2ltaWxhciB0byBvdXIgdGVybWluYWwuXG4gICAgZGl2LmlubmVySFRNTCA9IFwiPHNwYW4gc3R5bGU9XFxcImNvbG9yOiAjXCIuY29uY2F0KGNvbG9ycy5yZWQsIFwiXFxcIj5GYWlsZWQgdG8gY29tcGlsZS48L3NwYW4+PGJyPjxicj5cIikuY29uY2F0KGFuc2lIVE1MKGVudGl0aWVzLmVuY29kZShtZXNzYWdlc1swXSkpKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjbGVhcjogY2xlYXIsXG4gIHNob3dNZXNzYWdlOiBzaG93TWVzc2FnZVxufTsiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBhbnNpSFRNTFxuXG4vLyBSZWZlcmVuY2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hbnNpLXJlZ2V4XG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS9cblxudmFyIF9kZWZDb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ2ZmZicsICcwMDAnXSwgLy8gW0ZPUkVHUk9VRF9DT0xPUiwgQkFDS0dST1VORF9DT0xPUl1cbiAgYmxhY2s6ICcwMDAnLFxuICByZWQ6ICdmZjAwMDAnLFxuICBncmVlbjogJzIwOTgwNScsXG4gIHllbGxvdzogJ2U4YmYwMycsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgY3lhbjogJzAwZmZlZScsXG4gIGxpZ2h0Z3JleTogJ2YwZjBmMCcsXG4gIGRhcmtncmV5OiAnODg4J1xufVxudmFyIF9zdHlsZXMgPSB7XG4gIDMwOiAnYmxhY2snLFxuICAzMTogJ3JlZCcsXG4gIDMyOiAnZ3JlZW4nLFxuICAzMzogJ3llbGxvdycsXG4gIDM0OiAnYmx1ZScsXG4gIDM1OiAnbWFnZW50YScsXG4gIDM2OiAnY3lhbicsXG4gIDM3OiAnbGlnaHRncmV5J1xufVxudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLCAvLyBkaW1cbiAgJzMnOiAnPGk+JywgLy8gaXRhbGljXG4gICc0JzogJzx1PicsIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJywgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn1cbnZhciBfY2xvc2VUYWdzID0ge1xuICAnMjMnOiAnPC9pPicsIC8vIHJlc2V0IGl0YWxpY1xuICAnMjQnOiAnPC91PicsIC8vIHJlc2V0IHVuZGVyc2NvcmVcbiAgJzI5JzogJzwvZGVsPicgLy8gcmVzZXQgZGVsZXRlXG59XG5cbjtbMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nXG59KVxuXG4vKipcbiAqIENvbnZlcnRzIHRleHQgd2l0aCBBTlNJIGNvbG9yIGNvZGVzIHRvIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBhbnNpSFRNTCAodGV4dCkge1xuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXG4gIGlmICghX3JlZ0FOU0kudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvLyBDYWNoZSBvcGVuZWQgc2VxdWVuY2UuXG4gIHZhciBhbnNpQ29kZXMgPSBbXVxuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKSptL2csIGZ1bmN0aW9uIChtYXRjaCwgc2VxKSB7XG4gICAgdmFyIG90ID0gX29wZW5UYWdzW3NlcV1cbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgICByZXR1cm4gJzwvc3Bhbj4nXG4gICAgICB9XG4gICAgICAvLyBPcGVuIHRhZy5cbiAgICAgIGFuc2lDb2Rlcy5wdXNoKHNlcSlcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPidcbiAgICB9XG5cbiAgICB2YXIgY3QgPSBfY2xvc2VUYWdzW3NlcV1cbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICByZXR1cm4gY3RcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0pXG5cbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cbiAgdmFyIGwgPSBhbnNpQ29kZXMubGVuZ3RoXG4gIDsobCA+IDApICYmIChyZXQgKz0gQXJyYXkobCArIDEpLmpvaW4oJzwvc3Bhbj4nKSlcblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQ3VzdG9taXplIGNvbG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgcmVmZXJlbmNlIHRvIF9kZWZDb2xvcnNcbiAqL1xuYW5zaUhUTUwuc2V0Q29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICBpZiAodHlwZW9mIGNvbG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bjb2xvcnNgIHBhcmFtZXRlciBtdXN0IGJlIGFuIE9iamVjdC4nKVxuICB9XG5cbiAgdmFyIF9maW5hbENvbG9ycyA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBfZGVmQ29sb3JzKSB7XG4gICAgdmFyIGhleCA9IGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29sb3JzW2tleV0gOiBudWxsXG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoJ3Jlc2V0JyA9PT0ga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gW2hleF1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJ1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgICB9XG4gICAgICB2YXIgZGVmSGV4Q29sb3IgPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdXG4gICAgICB9XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XG4gICAgICAgIGhleCA9IFtoZXhbMF1dXG4gICAgICAgIGhleC5wdXNoKGRlZkhleENvbG9yWzFdKVxuICAgICAgfVxuXG4gICAgICBoZXggPSBoZXguc2xpY2UoMCwgMilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleFxuICB9XG4gIF9zZXRUYWdzKF9maW5hbENvbG9ycylcbn1cblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKVxufVxuXG4vKipcbiAqIEV4cG9zZSB0YWdzLCBpbmNsdWRpbmcgb3BlbiBhbmQgY2xvc2UuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5hbnNpSFRNTC50YWdzID0ge31cblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ29wZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfb3BlblRhZ3MgfVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Nsb3NlVGFncyB9XG4gIH0pXG59IGVsc2Uge1xuICBhbnNpSFRNTC50YWdzLm9wZW4gPSBfb3BlblRhZ3NcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3Ncbn1cblxuZnVuY3Rpb24gX3NldFRhZ3MgKGNvbG9ycykge1xuICAvLyByZXNldCBhbGxcbiAgX29wZW5UYWdzWycwJ10gPSAnZm9udC13ZWlnaHQ6bm9ybWFsO29wYWNpdHk6MTtjb2xvcjojJyArIGNvbG9ycy5yZXNldFswXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFsxXVxuICAvLyBpbnZlcnNlXG4gIF9vcGVuVGFnc1snNyddID0gJ2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzFdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzBdXG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXlcblxuICBmb3IgKHZhciBjb2RlIGluIF9zdHlsZXMpIHtcbiAgICB2YXIgY29sb3IgPSBfc3R5bGVzW2NvZGVdXG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJ1xuICAgIF9vcGVuVGFnc1tjb2RlXSA9ICdjb2xvcjojJyArIG9yaUNvbG9yXG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUpXG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvclxuICB9XG59XG5cbmFuc2lIVE1MLnJlc2V0KClcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHhtbF9lbnRpdGllc18xID0gcmVxdWlyZShcIi4veG1sLWVudGl0aWVzXCIpO1xuZXhwb3J0cy5YbWxFbnRpdGllcyA9IHhtbF9lbnRpdGllc18xLlhtbEVudGl0aWVzO1xudmFyIGh0bWw0X2VudGl0aWVzXzEgPSByZXF1aXJlKFwiLi9odG1sNC1lbnRpdGllc1wiKTtcbmV4cG9ydHMuSHRtbDRFbnRpdGllcyA9IGh0bWw0X2VudGl0aWVzXzEuSHRtbDRFbnRpdGllcztcbnZhciBodG1sNV9lbnRpdGllc18xID0gcmVxdWlyZShcIi4vaHRtbDUtZW50aXRpZXNcIik7XG5leHBvcnRzLkh0bWw1RW50aXRpZXMgPSBodG1sNV9lbnRpdGllc18xLkh0bWw1RW50aXRpZXM7XG5leHBvcnRzLkFsbEh0bWxFbnRpdGllcyA9IGh0bWw1X2VudGl0aWVzXzEuSHRtbDVFbnRpdGllcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEFMUEhBX0lOREVYID0ge1xuICAgICcmbHQnOiAnPCcsXG4gICAgJyZndCc6ICc+JyxcbiAgICAnJnF1b3QnOiAnXCInLFxuICAgICcmYXBvcyc6ICdcXCcnLFxuICAgICcmYW1wJzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYXBvczsnOiAnXFwnJyxcbiAgICAnJmFtcDsnOiAnJidcbn07XG52YXIgQ0hBUl9JTkRFWCA9IHtcbiAgICA2MDogJ2x0JyxcbiAgICA2MjogJ2d0JyxcbiAgICAzNDogJ3F1b3QnLFxuICAgIDM5OiAnYXBvcycsXG4gICAgMzg6ICdhbXAnXG59O1xudmFyIENIQVJfU19JTkRFWCA9IHtcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICAnXFwnJzogJyZhcG9zOycsXG4gICAgJyYnOiAnJmFtcDsnXG59O1xudmFyIFhtbEVudGl0aWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge1xuICAgIH1cbiAgICBYbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvWzw+XCInJl0vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHJldHVybiBDSEFSX1NfSU5ERVhbc107XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiM/WzAtOWEtekEtWl0rOz8vZywgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmIChzLmNoYXJBdCgxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBzLmNoYXJBdCgyKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigzKSwgMTYpIDpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMikpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFMUEhBX0lOREVYW3NdIHx8IHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBDSEFSX0lOREVYW2NdO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gICAgfTtcbiAgICBYbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmdodCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmdodCkge1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuICAgIH07XG4gICAgcmV0dXJuIFhtbEVudGl0aWVzO1xufSgpKTtcbmV4cG9ydHMuWG1sRW50aXRpZXMgPSBYbWxFbnRpdGllcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEhUTUxfQUxQSEEgPSBbJ2Fwb3MnLCAnbmJzcCcsICdpZXhjbCcsICdjZW50JywgJ3BvdW5kJywgJ2N1cnJlbicsICd5ZW4nLCAnYnJ2YmFyJywgJ3NlY3QnLCAndW1sJywgJ2NvcHknLCAnb3JkZicsICdsYXF1bycsICdub3QnLCAnc2h5JywgJ3JlZycsICdtYWNyJywgJ2RlZycsICdwbHVzbW4nLCAnc3VwMicsICdzdXAzJywgJ2FjdXRlJywgJ21pY3JvJywgJ3BhcmEnLCAnbWlkZG90JywgJ2NlZGlsJywgJ3N1cDEnLCAnb3JkbScsICdyYXF1bycsICdmcmFjMTQnLCAnZnJhYzEyJywgJ2ZyYWMzNCcsICdpcXVlc3QnLCAnQWdyYXZlJywgJ0FhY3V0ZScsICdBY2lyYycsICdBdGlsZGUnLCAnQXVtbCcsICdBcmluZycsICdBZWxpZycsICdDY2VkaWwnLCAnRWdyYXZlJywgJ0VhY3V0ZScsICdFY2lyYycsICdFdW1sJywgJ0lncmF2ZScsICdJYWN1dGUnLCAnSWNpcmMnLCAnSXVtbCcsICdFVEgnLCAnTnRpbGRlJywgJ09ncmF2ZScsICdPYWN1dGUnLCAnT2NpcmMnLCAnT3RpbGRlJywgJ091bWwnLCAndGltZXMnLCAnT3NsYXNoJywgJ1VncmF2ZScsICdVYWN1dGUnLCAnVWNpcmMnLCAnVXVtbCcsICdZYWN1dGUnLCAnVEhPUk4nLCAnc3psaWcnLCAnYWdyYXZlJywgJ2FhY3V0ZScsICdhY2lyYycsICdhdGlsZGUnLCAnYXVtbCcsICdhcmluZycsICdhZWxpZycsICdjY2VkaWwnLCAnZWdyYXZlJywgJ2VhY3V0ZScsICdlY2lyYycsICdldW1sJywgJ2lncmF2ZScsICdpYWN1dGUnLCAnaWNpcmMnLCAnaXVtbCcsICdldGgnLCAnbnRpbGRlJywgJ29ncmF2ZScsICdvYWN1dGUnLCAnb2NpcmMnLCAnb3RpbGRlJywgJ291bWwnLCAnZGl2aWRlJywgJ29zbGFzaCcsICd1Z3JhdmUnLCAndWFjdXRlJywgJ3VjaXJjJywgJ3V1bWwnLCAneWFjdXRlJywgJ3Rob3JuJywgJ3l1bWwnLCAncXVvdCcsICdhbXAnLCAnbHQnLCAnZ3QnLCAnT0VsaWcnLCAnb2VsaWcnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdZdW1sJywgJ2NpcmMnLCAndGlsZGUnLCAnZW5zcCcsICdlbXNwJywgJ3RoaW5zcCcsICd6d25qJywgJ3p3aicsICdscm0nLCAncmxtJywgJ25kYXNoJywgJ21kYXNoJywgJ2xzcXVvJywgJ3JzcXVvJywgJ3NicXVvJywgJ2xkcXVvJywgJ3JkcXVvJywgJ2JkcXVvJywgJ2RhZ2dlcicsICdEYWdnZXInLCAncGVybWlsJywgJ2xzYXF1bycsICdyc2FxdW8nLCAnZXVybycsICdmbm9mJywgJ0FscGhhJywgJ0JldGEnLCAnR2FtbWEnLCAnRGVsdGEnLCAnRXBzaWxvbicsICdaZXRhJywgJ0V0YScsICdUaGV0YScsICdJb3RhJywgJ0thcHBhJywgJ0xhbWJkYScsICdNdScsICdOdScsICdYaScsICdPbWljcm9uJywgJ1BpJywgJ1JobycsICdTaWdtYScsICdUYXUnLCAnVXBzaWxvbicsICdQaGknLCAnQ2hpJywgJ1BzaScsICdPbWVnYScsICdhbHBoYScsICdiZXRhJywgJ2dhbW1hJywgJ2RlbHRhJywgJ2Vwc2lsb24nLCAnemV0YScsICdldGEnLCAndGhldGEnLCAnaW90YScsICdrYXBwYScsICdsYW1iZGEnLCAnbXUnLCAnbnUnLCAneGknLCAnb21pY3JvbicsICdwaScsICdyaG8nLCAnc2lnbWFmJywgJ3NpZ21hJywgJ3RhdScsICd1cHNpbG9uJywgJ3BoaScsICdjaGknLCAncHNpJywgJ29tZWdhJywgJ3RoZXRhc3ltJywgJ3Vwc2loJywgJ3BpdicsICdidWxsJywgJ2hlbGxpcCcsICdwcmltZScsICdQcmltZScsICdvbGluZScsICdmcmFzbCcsICd3ZWllcnAnLCAnaW1hZ2UnLCAncmVhbCcsICd0cmFkZScsICdhbGVmc3ltJywgJ2xhcnInLCAndWFycicsICdyYXJyJywgJ2RhcnInLCAnaGFycicsICdjcmFycicsICdsQXJyJywgJ3VBcnInLCAnckFycicsICdkQXJyJywgJ2hBcnInLCAnZm9yYWxsJywgJ3BhcnQnLCAnZXhpc3QnLCAnZW1wdHknLCAnbmFibGEnLCAnaXNpbicsICdub3RpbicsICduaScsICdwcm9kJywgJ3N1bScsICdtaW51cycsICdsb3dhc3QnLCAncmFkaWMnLCAncHJvcCcsICdpbmZpbicsICdhbmcnLCAnYW5kJywgJ29yJywgJ2NhcCcsICdjdXAnLCAnaW50JywgJ3RoZXJlNCcsICdzaW0nLCAnY29uZycsICdhc3ltcCcsICduZScsICdlcXVpdicsICdsZScsICdnZScsICdzdWInLCAnc3VwJywgJ25zdWInLCAnc3ViZScsICdzdXBlJywgJ29wbHVzJywgJ290aW1lcycsICdwZXJwJywgJ3Nkb3QnLCAnbGNlaWwnLCAncmNlaWwnLCAnbGZsb29yJywgJ3JmbG9vcicsICdsYW5nJywgJ3JhbmcnLCAnbG96JywgJ3NwYWRlcycsICdjbHVicycsICdoZWFydHMnLCAnZGlhbXMnXTtcbnZhciBIVE1MX0NPREVTID0gWzM5LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LCAxNjksIDE3MCwgMTcxLCAxNzIsIDE3MywgMTc0LCAxNzUsIDE3NiwgMTc3LCAxNzgsIDE3OSwgMTgwLCAxODEsIDE4MiwgMTgzLCAxODQsIDE4NSwgMTg2LCAxODcsIDE4OCwgMTg5LCAxOTAsIDE5MSwgMTkyLCAxOTMsIDE5NCwgMTk1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LCAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjEwLCAyMTEsIDIxMiwgMjEzLCAyMTQsIDIxNSwgMjE2LCAyMTcsIDIxOCwgMjE5LCAyMjAsIDIyMSwgMjIyLCAyMjMsIDIyNCwgMjI1LCAyMjYsIDIyNywgMjI4LCAyMjksIDIzMCwgMjMxLCAyMzIsIDIzMywgMjM0LCAyMzUsIDIzNiwgMjM3LCAyMzgsIDIzOSwgMjQwLCAyNDEsIDI0MiwgMjQzLCAyNDQsIDI0NSwgMjQ2LCAyNDcsIDI0OCwgMjQ5LCAyNTAsIDI1MSwgMjUyLCAyNTMsIDI1NCwgMjU1LCAzNCwgMzgsIDYwLCA2MiwgMzM4LCAzMzksIDM1MiwgMzUzLCAzNzYsIDcxMCwgNzMyLCA4MTk0LCA4MTk1LCA4MjAxLCA4MjA0LCA4MjA1LCA4MjA2LCA4MjA3LCA4MjExLCA4MjEyLCA4MjE2LCA4MjE3LCA4MjE4LCA4MjIwLCA4MjIxLCA4MjIyLCA4MjI0LCA4MjI1LCA4MjQwLCA4MjQ5LCA4MjUwLCA4MzY0LCA0MDIsIDkxMywgOTE0LCA5MTUsIDkxNiwgOTE3LCA5MTgsIDkxOSwgOTIwLCA5MjEsIDkyMiwgOTIzLCA5MjQsIDkyNSwgOTI2LCA5MjcsIDkyOCwgOTI5LCA5MzEsIDkzMiwgOTMzLCA5MzQsIDkzNSwgOTM2LCA5MzcsIDk0NSwgOTQ2LCA5NDcsIDk0OCwgOTQ5LCA5NTAsIDk1MSwgOTUyLCA5NTMsIDk1NCwgOTU1LCA5NTYsIDk1NywgOTU4LCA5NTksIDk2MCwgOTYxLCA5NjIsIDk2MywgOTY0LCA5NjUsIDk2NiwgOTY3LCA5NjgsIDk2OSwgOTc3LCA5NzgsIDk4MiwgODIyNiwgODIzMCwgODI0MiwgODI0MywgODI1NCwgODI2MCwgODQ3MiwgODQ2NSwgODQ3NiwgODQ4MiwgODUwMSwgODU5MiwgODU5MywgODU5NCwgODU5NSwgODU5NiwgODYyOSwgODY1NiwgODY1NywgODY1OCwgODY1OSwgODY2MCwgODcwNCwgODcwNiwgODcwNywgODcwOSwgODcxMSwgODcxMiwgODcxMywgODcxNSwgODcxOSwgODcyMSwgODcyMiwgODcyNywgODczMCwgODczMywgODczNCwgODczNiwgODc0MywgODc0NCwgODc0NSwgODc0NiwgODc0NywgODc1NiwgODc2NCwgODc3MywgODc3NiwgODgwMCwgODgwMSwgODgwNCwgODgwNSwgODgzNCwgODgzNSwgODgzNiwgODgzOCwgODgzOSwgODg1MywgODg1NSwgODg2OSwgODkwMSwgODk2OCwgODk2OSwgODk3MCwgODk3MSwgOTAwMSwgOTAwMiwgOTY3NCwgOTgyNCwgOTgyNywgOTgyOSwgOTgzMF07XG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIG51bUluZGV4ID0ge307XG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gSFRNTF9BTFBIQS5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGEgPSBIVE1MX0FMUEhBW2ldO1xuICAgICAgICB2YXIgYyA9IEhUTUxfQ09ERVNbaV07XG4gICAgICAgIGFscGhhSW5kZXhbYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICBudW1JbmRleFtjXSA9IGE7XG4gICAgICAgIGkrKztcbiAgICB9XG59KSgpO1xudmFyIEh0bWw0RW50aXRpZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbDRFbnRpdGllcygpIHtcbiAgICB9XG4gICAgSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbiAocywgZW50aXR5KSB7XG4gICAgICAgICAgICB2YXIgY2hyO1xuICAgICAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMiksIDE2KSA6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IGFscGhhID8gXCImXCIgKyBhbHBoYSArIFwiO1wiIDogc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZShzdHIpO1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbY2NdO1xuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNjIDwgMzIgfHwgY2MgPiAxMjYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImI1wiICsgY2MgKyBcIjtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIdG1sNEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw0RW50aXRpZXM7XG59KCkpO1xuZXhwb3J0cy5IdG1sNEVudGl0aWVzID0gSHRtbDRFbnRpdGllcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVOVElUSUVTID0gW1snQWFjdXRlJywgWzE5M11dLCBbJ2FhY3V0ZScsIFsyMjVdXSwgWydBYnJldmUnLCBbMjU4XV0sIFsnYWJyZXZlJywgWzI1OV1dLCBbJ2FjJywgWzg3NjZdXSwgWydhY2QnLCBbODc2N11dLCBbJ2FjRScsIFs4NzY2LCA4MTldXSwgWydBY2lyYycsIFsxOTRdXSwgWydhY2lyYycsIFsyMjZdXSwgWydhY3V0ZScsIFsxODBdXSwgWydBY3knLCBbMTA0MF1dLCBbJ2FjeScsIFsxMDcyXV0sIFsnQUVsaWcnLCBbMTk4XV0sIFsnYWVsaWcnLCBbMjMwXV0sIFsnYWYnLCBbODI4OV1dLCBbJ0FmcicsIFsxMjAwNjhdXSwgWydhZnInLCBbMTIwMDk0XV0sIFsnQWdyYXZlJywgWzE5Ml1dLCBbJ2FncmF2ZScsIFsyMjRdXSwgWydhbGVmc3ltJywgWzg1MDFdXSwgWydhbGVwaCcsIFs4NTAxXV0sIFsnQWxwaGEnLCBbOTEzXV0sIFsnYWxwaGEnLCBbOTQ1XV0sIFsnQW1hY3InLCBbMjU2XV0sIFsnYW1hY3InLCBbMjU3XV0sIFsnYW1hbGcnLCBbMTA4MTVdXSwgWydhbXAnLCBbMzhdXSwgWydBTVAnLCBbMzhdXSwgWydhbmRhbmQnLCBbMTA4MzddXSwgWydBbmQnLCBbMTA4MzVdXSwgWydhbmQnLCBbODc0M11dLCBbJ2FuZGQnLCBbMTA4NDRdXSwgWydhbmRzbG9wZScsIFsxMDg0MF1dLCBbJ2FuZHYnLCBbMTA4NDJdXSwgWydhbmcnLCBbODczNl1dLCBbJ2FuZ2UnLCBbMTA2NjBdXSwgWydhbmdsZScsIFs4NzM2XV0sIFsnYW5nbXNkYWEnLCBbMTA2NjRdXSwgWydhbmdtc2RhYicsIFsxMDY2NV1dLCBbJ2FuZ21zZGFjJywgWzEwNjY2XV0sIFsnYW5nbXNkYWQnLCBbMTA2NjddXSwgWydhbmdtc2RhZScsIFsxMDY2OF1dLCBbJ2FuZ21zZGFmJywgWzEwNjY5XV0sIFsnYW5nbXNkYWcnLCBbMTA2NzBdXSwgWydhbmdtc2RhaCcsIFsxMDY3MV1dLCBbJ2FuZ21zZCcsIFs4NzM3XV0sIFsnYW5ncnQnLCBbODczNV1dLCBbJ2FuZ3J0dmInLCBbODg5NF1dLCBbJ2FuZ3J0dmJkJywgWzEwNjUzXV0sIFsnYW5nc3BoJywgWzg3MzhdXSwgWydhbmdzdCcsIFsxOTddXSwgWydhbmd6YXJyJywgWzkwODRdXSwgWydBb2dvbicsIFsyNjBdXSwgWydhb2dvbicsIFsyNjFdXSwgWydBb3BmJywgWzEyMDEyMF1dLCBbJ2FvcGYnLCBbMTIwMTQ2XV0sIFsnYXBhY2lyJywgWzEwODYzXV0sIFsnYXAnLCBbODc3Nl1dLCBbJ2FwRScsIFsxMDg2NF1dLCBbJ2FwZScsIFs4Nzc4XV0sIFsnYXBpZCcsIFs4Nzc5XV0sIFsnYXBvcycsIFszOV1dLCBbJ0FwcGx5RnVuY3Rpb24nLCBbODI4OV1dLCBbJ2FwcHJveCcsIFs4Nzc2XV0sIFsnYXBwcm94ZXEnLCBbODc3OF1dLCBbJ0FyaW5nJywgWzE5N11dLCBbJ2FyaW5nJywgWzIyOV1dLCBbJ0FzY3InLCBbMTE5OTY0XV0sIFsnYXNjcicsIFsxMTk5OTBdXSwgWydBc3NpZ24nLCBbODc4OF1dLCBbJ2FzdCcsIFs0Ml1dLCBbJ2FzeW1wJywgWzg3NzZdXSwgWydhc3ltcGVxJywgWzg3ODFdXSwgWydBdGlsZGUnLCBbMTk1XV0sIFsnYXRpbGRlJywgWzIyN11dLCBbJ0F1bWwnLCBbMTk2XV0sIFsnYXVtbCcsIFsyMjhdXSwgWydhd2NvbmludCcsIFs4NzU1XV0sIFsnYXdpbnQnLCBbMTA3NjldXSwgWydiYWNrY29uZycsIFs4NzgwXV0sIFsnYmFja2Vwc2lsb24nLCBbMTAxNF1dLCBbJ2JhY2twcmltZScsIFs4MjQ1XV0sIFsnYmFja3NpbScsIFs4NzY1XV0sIFsnYmFja3NpbWVxJywgWzg5MDldXSwgWydCYWNrc2xhc2gnLCBbODcyNl1dLCBbJ0JhcnYnLCBbMTA5ODNdXSwgWydiYXJ2ZWUnLCBbODg5M11dLCBbJ2JhcndlZCcsIFs4OTY1XV0sIFsnQmFyd2VkJywgWzg5NjZdXSwgWydiYXJ3ZWRnZScsIFs4OTY1XV0sIFsnYmJyaycsIFs5MTQxXV0sIFsnYmJya3RicmsnLCBbOTE0Ml1dLCBbJ2Jjb25nJywgWzg3ODBdXSwgWydCY3knLCBbMTA0MV1dLCBbJ2JjeScsIFsxMDczXV0sIFsnYmRxdW8nLCBbODIyMl1dLCBbJ2JlY2F1cycsIFs4NzU3XV0sIFsnYmVjYXVzZScsIFs4NzU3XV0sIFsnQmVjYXVzZScsIFs4NzU3XV0sIFsnYmVtcHR5dicsIFsxMDY3Ml1dLCBbJ2JlcHNpJywgWzEwMTRdXSwgWydiZXJub3UnLCBbODQ5Ml1dLCBbJ0Jlcm5vdWxsaXMnLCBbODQ5Ml1dLCBbJ0JldGEnLCBbOTE0XV0sIFsnYmV0YScsIFs5NDZdXSwgWydiZXRoJywgWzg1MDJdXSwgWydiZXR3ZWVuJywgWzg4MTJdXSwgWydCZnInLCBbMTIwMDY5XV0sIFsnYmZyJywgWzEyMDA5NV1dLCBbJ2JpZ2NhcCcsIFs4ODk4XV0sIFsnYmlnY2lyYycsIFs5NzExXV0sIFsnYmlnY3VwJywgWzg4OTldXSwgWydiaWdvZG90JywgWzEwNzUyXV0sIFsnYmlnb3BsdXMnLCBbMTA3NTNdXSwgWydiaWdvdGltZXMnLCBbMTA3NTRdXSwgWydiaWdzcWN1cCcsIFsxMDc1OF1dLCBbJ2JpZ3N0YXInLCBbOTczM11dLCBbJ2JpZ3RyaWFuZ2xlZG93bicsIFs5NjYxXV0sIFsnYmlndHJpYW5nbGV1cCcsIFs5NjUxXV0sIFsnYmlndXBsdXMnLCBbMTA3NTZdXSwgWydiaWd2ZWUnLCBbODg5N11dLCBbJ2JpZ3dlZGdlJywgWzg4OTZdXSwgWydia2Fyb3cnLCBbMTA1MDldXSwgWydibGFja2xvemVuZ2UnLCBbMTA3MzFdXSwgWydibGFja3NxdWFyZScsIFs5NjQyXV0sIFsnYmxhY2t0cmlhbmdsZScsIFs5NjUyXV0sIFsnYmxhY2t0cmlhbmdsZWRvd24nLCBbOTY2Ml1dLCBbJ2JsYWNrdHJpYW5nbGVsZWZ0JywgWzk2NjZdXSwgWydibGFja3RyaWFuZ2xlcmlnaHQnLCBbOTY1Nl1dLCBbJ2JsYW5rJywgWzkyNTFdXSwgWydibGsxMicsIFs5NjE4XV0sIFsnYmxrMTQnLCBbOTYxN11dLCBbJ2JsazM0JywgWzk2MTldXSwgWydibG9jaycsIFs5NjA4XV0sIFsnYm5lJywgWzYxLCA4NDIxXV0sIFsnYm5lcXVpdicsIFs4ODAxLCA4NDIxXV0sIFsnYk5vdCcsIFsxMDk4OV1dLCBbJ2Jub3QnLCBbODk3Nl1dLCBbJ0JvcGYnLCBbMTIwMTIxXV0sIFsnYm9wZicsIFsxMjAxNDddXSwgWydib3QnLCBbODg2OV1dLCBbJ2JvdHRvbScsIFs4ODY5XV0sIFsnYm93dGllJywgWzg5MDRdXSwgWydib3hib3gnLCBbMTA2OTddXSwgWydib3hkbCcsIFs5NDg4XV0sIFsnYm94ZEwnLCBbOTU1N11dLCBbJ2JveERsJywgWzk1NThdXSwgWydib3hETCcsIFs5NTU5XV0sIFsnYm94ZHInLCBbOTQ4NF1dLCBbJ2JveGRSJywgWzk1NTRdXSwgWydib3hEcicsIFs5NTU1XV0sIFsnYm94RFInLCBbOTU1Nl1dLCBbJ2JveGgnLCBbOTQ3Ml1dLCBbJ2JveEgnLCBbOTU1Ml1dLCBbJ2JveGhkJywgWzk1MTZdXSwgWydib3hIZCcsIFs5NTcyXV0sIFsnYm94aEQnLCBbOTU3M11dLCBbJ2JveEhEJywgWzk1NzRdXSwgWydib3hodScsIFs5NTI0XV0sIFsnYm94SHUnLCBbOTU3NV1dLCBbJ2JveGhVJywgWzk1NzZdXSwgWydib3hIVScsIFs5NTc3XV0sIFsnYm94bWludXMnLCBbODg2M11dLCBbJ2JveHBsdXMnLCBbODg2Ml1dLCBbJ2JveHRpbWVzJywgWzg4NjRdXSwgWydib3h1bCcsIFs5NDk2XV0sIFsnYm94dUwnLCBbOTU2M11dLCBbJ2JveFVsJywgWzk1NjRdXSwgWydib3hVTCcsIFs5NTY1XV0sIFsnYm94dXInLCBbOTQ5Ml1dLCBbJ2JveHVSJywgWzk1NjBdXSwgWydib3hVcicsIFs5NTYxXV0sIFsnYm94VVInLCBbOTU2Ml1dLCBbJ2JveHYnLCBbOTQ3NF1dLCBbJ2JveFYnLCBbOTU1M11dLCBbJ2JveHZoJywgWzk1MzJdXSwgWydib3h2SCcsIFs5NTc4XV0sIFsnYm94VmgnLCBbOTU3OV1dLCBbJ2JveFZIJywgWzk1ODBdXSwgWydib3h2bCcsIFs5NTA4XV0sIFsnYm94dkwnLCBbOTU2OV1dLCBbJ2JveFZsJywgWzk1NzBdXSwgWydib3hWTCcsIFs5NTcxXV0sIFsnYm94dnInLCBbOTUwMF1dLCBbJ2JveHZSJywgWzk1NjZdXSwgWydib3hWcicsIFs5NTY3XV0sIFsnYm94VlInLCBbOTU2OF1dLCBbJ2JwcmltZScsIFs4MjQ1XV0sIFsnYnJldmUnLCBbNzI4XV0sIFsnQnJldmUnLCBbNzI4XV0sIFsnYnJ2YmFyJywgWzE2Nl1dLCBbJ2JzY3InLCBbMTE5OTkxXV0sIFsnQnNjcicsIFs4NDkyXV0sIFsnYnNlbWknLCBbODI3MV1dLCBbJ2JzaW0nLCBbODc2NV1dLCBbJ2JzaW1lJywgWzg5MDldXSwgWydic29sYicsIFsxMDY5M11dLCBbJ2Jzb2wnLCBbOTJdXSwgWydic29saHN1YicsIFsxMDE4NF1dLCBbJ2J1bGwnLCBbODIyNl1dLCBbJ2J1bGxldCcsIFs4MjI2XV0sIFsnYnVtcCcsIFs4NzgyXV0sIFsnYnVtcEUnLCBbMTA5MjZdXSwgWydidW1wZScsIFs4NzgzXV0sIFsnQnVtcGVxJywgWzg3ODJdXSwgWydidW1wZXEnLCBbODc4M11dLCBbJ0NhY3V0ZScsIFsyNjJdXSwgWydjYWN1dGUnLCBbMjYzXV0sIFsnY2FwYW5kJywgWzEwODIwXV0sIFsnY2FwYnJjdXAnLCBbMTA4MjVdXSwgWydjYXBjYXAnLCBbMTA4MjddXSwgWydjYXAnLCBbODc0NV1dLCBbJ0NhcCcsIFs4OTE0XV0sIFsnY2FwY3VwJywgWzEwODIzXV0sIFsnY2FwZG90JywgWzEwODE2XV0sIFsnQ2FwaXRhbERpZmZlcmVudGlhbEQnLCBbODUxN11dLCBbJ2NhcHMnLCBbODc0NSwgNjUwMjRdXSwgWydjYXJldCcsIFs4MjU3XV0sIFsnY2Fyb24nLCBbNzExXV0sIFsnQ2F5bGV5cycsIFs4NDkzXV0sIFsnY2NhcHMnLCBbMTA4MjldXSwgWydDY2Fyb24nLCBbMjY4XV0sIFsnY2Nhcm9uJywgWzI2OV1dLCBbJ0NjZWRpbCcsIFsxOTldXSwgWydjY2VkaWwnLCBbMjMxXV0sIFsnQ2NpcmMnLCBbMjY0XV0sIFsnY2NpcmMnLCBbMjY1XV0sIFsnQ2NvbmludCcsIFs4NzUyXV0sIFsnY2N1cHMnLCBbMTA4MjhdXSwgWydjY3Vwc3NtJywgWzEwODMyXV0sIFsnQ2RvdCcsIFsyNjZdXSwgWydjZG90JywgWzI2N11dLCBbJ2NlZGlsJywgWzE4NF1dLCBbJ0NlZGlsbGEnLCBbMTg0XV0sIFsnY2VtcHR5dicsIFsxMDY3NF1dLCBbJ2NlbnQnLCBbMTYyXV0sIFsnY2VudGVyZG90JywgWzE4M11dLCBbJ0NlbnRlckRvdCcsIFsxODNdXSwgWydjZnInLCBbMTIwMDk2XV0sIFsnQ2ZyJywgWzg0OTNdXSwgWydDSGN5JywgWzEwNjNdXSwgWydjaGN5JywgWzEwOTVdXSwgWydjaGVjaycsIFsxMDAwM11dLCBbJ2NoZWNrbWFyaycsIFsxMDAwM11dLCBbJ0NoaScsIFs5MzVdXSwgWydjaGknLCBbOTY3XV0sIFsnY2lyYycsIFs3MTBdXSwgWydjaXJjZXEnLCBbODc5MV1dLCBbJ2NpcmNsZWFycm93bGVmdCcsIFs4NjM0XV0sIFsnY2lyY2xlYXJyb3dyaWdodCcsIFs4NjM1XV0sIFsnY2lyY2xlZGFzdCcsIFs4ODU5XV0sIFsnY2lyY2xlZGNpcmMnLCBbODg1OF1dLCBbJ2NpcmNsZWRkYXNoJywgWzg4NjFdXSwgWydDaXJjbGVEb3QnLCBbODg1N11dLCBbJ2NpcmNsZWRSJywgWzE3NF1dLCBbJ2NpcmNsZWRTJywgWzk0MTZdXSwgWydDaXJjbGVNaW51cycsIFs4ODU0XV0sIFsnQ2lyY2xlUGx1cycsIFs4ODUzXV0sIFsnQ2lyY2xlVGltZXMnLCBbODg1NV1dLCBbJ2NpcicsIFs5Njc1XV0sIFsnY2lyRScsIFsxMDY5MV1dLCBbJ2NpcmUnLCBbODc5MV1dLCBbJ2NpcmZuaW50JywgWzEwNzY4XV0sIFsnY2lybWlkJywgWzEwOTkxXV0sIFsnY2lyc2NpcicsIFsxMDY5MF1dLCBbJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU0XV0sIFsnY2x1YnMnLCBbOTgyN11dLCBbJ2NsdWJzdWl0JywgWzk4MjddXSwgWydjb2xvbicsIFs1OF1dLCBbJ0NvbG9uJywgWzg3NTldXSwgWydDb2xvbmUnLCBbMTA4NjhdXSwgWydjb2xvbmUnLCBbODc4OF1dLCBbJ2NvbG9uZXEnLCBbODc4OF1dLCBbJ2NvbW1hJywgWzQ0XV0sIFsnY29tbWF0JywgWzY0XV0sIFsnY29tcCcsIFs4NzA1XV0sIFsnY29tcGZuJywgWzg3MjhdXSwgWydjb21wbGVtZW50JywgWzg3MDVdXSwgWydjb21wbGV4ZXMnLCBbODQ1MF1dLCBbJ2NvbmcnLCBbODc3M11dLCBbJ2Nvbmdkb3QnLCBbMTA4NjFdXSwgWydDb25ncnVlbnQnLCBbODgwMV1dLCBbJ2NvbmludCcsIFs4NzUwXV0sIFsnQ29uaW50JywgWzg3NTFdXSwgWydDb250b3VySW50ZWdyYWwnLCBbODc1MF1dLCBbJ2NvcGYnLCBbMTIwMTQ4XV0sIFsnQ29wZicsIFs4NDUwXV0sIFsnY29wcm9kJywgWzg3MjBdXSwgWydDb3Byb2R1Y3QnLCBbODcyMF1dLCBbJ2NvcHknLCBbMTY5XV0sIFsnQ09QWScsIFsxNjldXSwgWydjb3B5c3InLCBbODQ3MV1dLCBbJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NV1dLCBbJ2NyYXJyJywgWzg2MjldXSwgWydjcm9zcycsIFsxMDAwN11dLCBbJ0Nyb3NzJywgWzEwNzk5XV0sIFsnQ3NjcicsIFsxMTk5NjZdXSwgWydjc2NyJywgWzExOTk5Ml1dLCBbJ2NzdWInLCBbMTA5NTldXSwgWydjc3ViZScsIFsxMDk2MV1dLCBbJ2NzdXAnLCBbMTA5NjBdXSwgWydjc3VwZScsIFsxMDk2Ml1dLCBbJ2N0ZG90JywgWzg5NDNdXSwgWydjdWRhcnJsJywgWzEwNTUyXV0sIFsnY3VkYXJycicsIFsxMDU0OV1dLCBbJ2N1ZXByJywgWzg5MjZdXSwgWydjdWVzYycsIFs4OTI3XV0sIFsnY3VsYXJyJywgWzg2MzBdXSwgWydjdWxhcnJwJywgWzEwNTU3XV0sIFsnY3VwYnJjYXAnLCBbMTA4MjRdXSwgWydjdXBjYXAnLCBbMTA4MjJdXSwgWydDdXBDYXAnLCBbODc4MV1dLCBbJ2N1cCcsIFs4NzQ2XV0sIFsnQ3VwJywgWzg5MTVdXSwgWydjdXBjdXAnLCBbMTA4MjZdXSwgWydjdXBkb3QnLCBbODg0NV1dLCBbJ2N1cG9yJywgWzEwODIxXV0sIFsnY3VwcycsIFs4NzQ2LCA2NTAyNF1dLCBbJ2N1cmFycicsIFs4NjMxXV0sIFsnY3VyYXJybScsIFsxMDU1Nl1dLCBbJ2N1cmx5ZXFwcmVjJywgWzg5MjZdXSwgWydjdXJseWVxc3VjYycsIFs4OTI3XV0sIFsnY3VybHl2ZWUnLCBbODkxMF1dLCBbJ2N1cmx5d2VkZ2UnLCBbODkxMV1dLCBbJ2N1cnJlbicsIFsxNjRdXSwgWydjdXJ2ZWFycm93bGVmdCcsIFs4NjMwXV0sIFsnY3VydmVhcnJvd3JpZ2h0JywgWzg2MzFdXSwgWydjdXZlZScsIFs4OTEwXV0sIFsnY3V3ZWQnLCBbODkxMV1dLCBbJ2N3Y29uaW50JywgWzg3NTRdXSwgWydjd2ludCcsIFs4NzUzXV0sIFsnY3lsY3R5JywgWzkwMDVdXSwgWydkYWdnZXInLCBbODIyNF1dLCBbJ0RhZ2dlcicsIFs4MjI1XV0sIFsnZGFsZXRoJywgWzg1MDRdXSwgWydkYXJyJywgWzg1OTVdXSwgWydEYXJyJywgWzg2MDldXSwgWydkQXJyJywgWzg2NTldXSwgWydkYXNoJywgWzgyMDhdXSwgWydEYXNodicsIFsxMDk4MF1dLCBbJ2Rhc2h2JywgWzg4NjddXSwgWydkYmthcm93JywgWzEwNTExXV0sIFsnZGJsYWMnLCBbNzMzXV0sIFsnRGNhcm9uJywgWzI3MF1dLCBbJ2RjYXJvbicsIFsyNzFdXSwgWydEY3knLCBbMTA0NF1dLCBbJ2RjeScsIFsxMDc2XV0sIFsnZGRhZ2dlcicsIFs4MjI1XV0sIFsnZGRhcnInLCBbODY1MF1dLCBbJ0REJywgWzg1MTddXSwgWydkZCcsIFs4NTE4XV0sIFsnRERvdHJhaGQnLCBbMTA1MTNdXSwgWydkZG90c2VxJywgWzEwODcxXV0sIFsnZGVnJywgWzE3Nl1dLCBbJ0RlbCcsIFs4NzExXV0sIFsnRGVsdGEnLCBbOTE2XV0sIFsnZGVsdGEnLCBbOTQ4XV0sIFsnZGVtcHR5dicsIFsxMDY3M11dLCBbJ2RmaXNodCcsIFsxMDYyM11dLCBbJ0RmcicsIFsxMjAwNzFdXSwgWydkZnInLCBbMTIwMDk3XV0sIFsnZEhhcicsIFsxMDU5N11dLCBbJ2RoYXJsJywgWzg2NDNdXSwgWydkaGFycicsIFs4NjQyXV0sIFsnRGlhY3JpdGljYWxBY3V0ZScsIFsxODBdXSwgWydEaWFjcml0aWNhbERvdCcsIFs3MjldXSwgWydEaWFjcml0aWNhbERvdWJsZUFjdXRlJywgWzczM11dLCBbJ0RpYWNyaXRpY2FsR3JhdmUnLCBbOTZdXSwgWydEaWFjcml0aWNhbFRpbGRlJywgWzczMl1dLCBbJ2RpYW0nLCBbODkwMF1dLCBbJ2RpYW1vbmQnLCBbODkwMF1dLCBbJ0RpYW1vbmQnLCBbODkwMF1dLCBbJ2RpYW1vbmRzdWl0JywgWzk4MzBdXSwgWydkaWFtcycsIFs5ODMwXV0sIFsnZGllJywgWzE2OF1dLCBbJ0RpZmZlcmVudGlhbEQnLCBbODUxOF1dLCBbJ2RpZ2FtbWEnLCBbOTg5XV0sIFsnZGlzaW4nLCBbODk0Nl1dLCBbJ2RpdicsIFsyNDddXSwgWydkaXZpZGUnLCBbMjQ3XV0sIFsnZGl2aWRlb250aW1lcycsIFs4OTAzXV0sIFsnZGl2b254JywgWzg5MDNdXSwgWydESmN5JywgWzEwMjZdXSwgWydkamN5JywgWzExMDZdXSwgWydkbGNvcm4nLCBbODk5MF1dLCBbJ2RsY3JvcCcsIFs4OTczXV0sIFsnZG9sbGFyJywgWzM2XV0sIFsnRG9wZicsIFsxMjAxMjNdXSwgWydkb3BmJywgWzEyMDE0OV1dLCBbJ0RvdCcsIFsxNjhdXSwgWydkb3QnLCBbNzI5XV0sIFsnRG90RG90JywgWzg0MTJdXSwgWydkb3RlcScsIFs4Nzg0XV0sIFsnZG90ZXFkb3QnLCBbODc4NV1dLCBbJ0RvdEVxdWFsJywgWzg3ODRdXSwgWydkb3RtaW51cycsIFs4NzYwXV0sIFsnZG90cGx1cycsIFs4NzI0XV0sIFsnZG90c3F1YXJlJywgWzg4NjVdXSwgWydkb3VibGViYXJ3ZWRnZScsIFs4OTY2XV0sIFsnRG91YmxlQ29udG91ckludGVncmFsJywgWzg3NTFdXSwgWydEb3VibGVEb3QnLCBbMTY4XV0sIFsnRG91YmxlRG93bkFycm93JywgWzg2NTldXSwgWydEb3VibGVMZWZ0QXJyb3cnLCBbODY1Nl1dLCBbJ0RvdWJsZUxlZnRSaWdodEFycm93JywgWzg2NjBdXSwgWydEb3VibGVMZWZ0VGVlJywgWzEwOTgwXV0sIFsnRG91YmxlTG9uZ0xlZnRBcnJvdycsIFsxMDIzMl1dLCBbJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzNF1dLCBbJ0RvdWJsZUxvbmdSaWdodEFycm93JywgWzEwMjMzXV0sIFsnRG91YmxlUmlnaHRBcnJvdycsIFs4NjU4XV0sIFsnRG91YmxlUmlnaHRUZWUnLCBbODg3Ml1dLCBbJ0RvdWJsZVVwQXJyb3cnLCBbODY1N11dLCBbJ0RvdWJsZVVwRG93bkFycm93JywgWzg2NjFdXSwgWydEb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQxXV0sIFsnRG93bkFycm93QmFyJywgWzEwNTE1XV0sIFsnZG93bmFycm93JywgWzg1OTVdXSwgWydEb3duQXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25hcnJvdycsIFs4NjU5XV0sIFsnRG93bkFycm93VXBBcnJvdycsIFs4NjkzXV0sIFsnRG93bkJyZXZlJywgWzc4NV1dLCBbJ2Rvd25kb3duYXJyb3dzJywgWzg2NTBdXSwgWydkb3duaGFycG9vbmxlZnQnLCBbODY0M11dLCBbJ2Rvd25oYXJwb29ucmlnaHQnLCBbODY0Ml1dLCBbJ0Rvd25MZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzZdXSwgWydEb3duTGVmdFRlZVZlY3RvcicsIFsxMDU5MF1dLCBbJ0Rvd25MZWZ0VmVjdG9yQmFyJywgWzEwNTgyXV0sIFsnRG93bkxlZnRWZWN0b3InLCBbODYzN11dLCBbJ0Rvd25SaWdodFRlZVZlY3RvcicsIFsxMDU5MV1dLCBbJ0Rvd25SaWdodFZlY3RvckJhcicsIFsxMDU4M11dLCBbJ0Rvd25SaWdodFZlY3RvcicsIFs4NjQxXV0sIFsnRG93blRlZUFycm93JywgWzg2MTVdXSwgWydEb3duVGVlJywgWzg4NjhdXSwgWydkcmJrYXJvdycsIFsxMDUxMl1dLCBbJ2RyY29ybicsIFs4OTkxXV0sIFsnZHJjcm9wJywgWzg5NzJdXSwgWydEc2NyJywgWzExOTk2N11dLCBbJ2RzY3InLCBbMTE5OTkzXV0sIFsnRFNjeScsIFsxMDI5XV0sIFsnZHNjeScsIFsxMTA5XV0sIFsnZHNvbCcsIFsxMDc0Ml1dLCBbJ0RzdHJvaycsIFsyNzJdXSwgWydkc3Ryb2snLCBbMjczXV0sIFsnZHRkb3QnLCBbODk0NV1dLCBbJ2R0cmknLCBbOTY2M11dLCBbJ2R0cmlmJywgWzk2NjJdXSwgWydkdWFycicsIFs4NjkzXV0sIFsnZHVoYXInLCBbMTA2MDddXSwgWydkd2FuZ2xlJywgWzEwNjYyXV0sIFsnRFpjeScsIFsxMDM5XV0sIFsnZHpjeScsIFsxMTE5XV0sIFsnZHppZ3JhcnInLCBbMTAyMzldXSwgWydFYWN1dGUnLCBbMjAxXV0sIFsnZWFjdXRlJywgWzIzM11dLCBbJ2Vhc3RlcicsIFsxMDg2Ml1dLCBbJ0VjYXJvbicsIFsyODJdXSwgWydlY2Fyb24nLCBbMjgzXV0sIFsnRWNpcmMnLCBbMjAyXV0sIFsnZWNpcmMnLCBbMjM0XV0sIFsnZWNpcicsIFs4NzkwXV0sIFsnZWNvbG9uJywgWzg3ODldXSwgWydFY3knLCBbMTA2OV1dLCBbJ2VjeScsIFsxMTAxXV0sIFsnZUREb3QnLCBbMTA4NzFdXSwgWydFZG90JywgWzI3OF1dLCBbJ2Vkb3QnLCBbMjc5XV0sIFsnZURvdCcsIFs4Nzg1XV0sIFsnZWUnLCBbODUxOV1dLCBbJ2VmRG90JywgWzg3ODZdXSwgWydFZnInLCBbMTIwMDcyXV0sIFsnZWZyJywgWzEyMDA5OF1dLCBbJ2VnJywgWzEwOTA2XV0sIFsnRWdyYXZlJywgWzIwMF1dLCBbJ2VncmF2ZScsIFsyMzJdXSwgWydlZ3MnLCBbMTA5MDJdXSwgWydlZ3Nkb3QnLCBbMTA5MDRdXSwgWydlbCcsIFsxMDkwNV1dLCBbJ0VsZW1lbnQnLCBbODcxMl1dLCBbJ2VsaW50ZXJzJywgWzkxOTFdXSwgWydlbGwnLCBbODQ2N11dLCBbJ2VscycsIFsxMDkwMV1dLCBbJ2Vsc2RvdCcsIFsxMDkwM11dLCBbJ0VtYWNyJywgWzI3NF1dLCBbJ2VtYWNyJywgWzI3NV1dLCBbJ2VtcHR5JywgWzg3MDldXSwgWydlbXB0eXNldCcsIFs4NzA5XV0sIFsnRW1wdHlTbWFsbFNxdWFyZScsIFs5NzIzXV0sIFsnZW1wdHl2JywgWzg3MDldXSwgWydFbXB0eVZlcnlTbWFsbFNxdWFyZScsIFs5NjQzXV0sIFsnZW1zcDEzJywgWzgxOTZdXSwgWydlbXNwMTQnLCBbODE5N11dLCBbJ2Vtc3AnLCBbODE5NV1dLCBbJ0VORycsIFszMzBdXSwgWydlbmcnLCBbMzMxXV0sIFsnZW5zcCcsIFs4MTk0XV0sIFsnRW9nb24nLCBbMjgwXV0sIFsnZW9nb24nLCBbMjgxXV0sIFsnRW9wZicsIFsxMjAxMjRdXSwgWydlb3BmJywgWzEyMDE1MF1dLCBbJ2VwYXInLCBbODkxN11dLCBbJ2VwYXJzbCcsIFsxMDcyM11dLCBbJ2VwbHVzJywgWzEwODY1XV0sIFsnZXBzaScsIFs5NDldXSwgWydFcHNpbG9uJywgWzkxN11dLCBbJ2Vwc2lsb24nLCBbOTQ5XV0sIFsnZXBzaXYnLCBbMTAxM11dLCBbJ2VxY2lyYycsIFs4NzkwXV0sIFsnZXFjb2xvbicsIFs4Nzg5XV0sIFsnZXFzaW0nLCBbODc3MF1dLCBbJ2Vxc2xhbnRndHInLCBbMTA5MDJdXSwgWydlcXNsYW50bGVzcycsIFsxMDkwMV1dLCBbJ0VxdWFsJywgWzEwODY5XV0sIFsnZXF1YWxzJywgWzYxXV0sIFsnRXF1YWxUaWxkZScsIFs4NzcwXV0sIFsnZXF1ZXN0JywgWzg3OTldXSwgWydFcXVpbGlicml1bScsIFs4NjUyXV0sIFsnZXF1aXYnLCBbODgwMV1dLCBbJ2VxdWl2REQnLCBbMTA4NzJdXSwgWydlcXZwYXJzbCcsIFsxMDcyNV1dLCBbJ2VyYXJyJywgWzEwNjA5XV0sIFsnZXJEb3QnLCBbODc4N11dLCBbJ2VzY3InLCBbODQ5NV1dLCBbJ0VzY3InLCBbODQ5Nl1dLCBbJ2VzZG90JywgWzg3ODRdXSwgWydFc2ltJywgWzEwODY3XV0sIFsnZXNpbScsIFs4NzcwXV0sIFsnRXRhJywgWzkxOV1dLCBbJ2V0YScsIFs5NTFdXSwgWydFVEgnLCBbMjA4XV0sIFsnZXRoJywgWzI0MF1dLCBbJ0V1bWwnLCBbMjAzXV0sIFsnZXVtbCcsIFsyMzVdXSwgWydldXJvJywgWzgzNjRdXSwgWydleGNsJywgWzMzXV0sIFsnZXhpc3QnLCBbODcwN11dLCBbJ0V4aXN0cycsIFs4NzA3XV0sIFsnZXhwZWN0YXRpb24nLCBbODQ5Nl1dLCBbJ2V4cG9uZW50aWFsZScsIFs4NTE5XV0sIFsnRXhwb25lbnRpYWxFJywgWzg1MTldXSwgWydmYWxsaW5nZG90c2VxJywgWzg3ODZdXSwgWydGY3knLCBbMTA2MF1dLCBbJ2ZjeScsIFsxMDkyXV0sIFsnZmVtYWxlJywgWzk3OTJdXSwgWydmZmlsaWcnLCBbNjQyNTldXSwgWydmZmxpZycsIFs2NDI1Nl1dLCBbJ2ZmbGxpZycsIFs2NDI2MF1dLCBbJ0ZmcicsIFsxMjAwNzNdXSwgWydmZnInLCBbMTIwMDk5XV0sIFsnZmlsaWcnLCBbNjQyNTddXSwgWydGaWxsZWRTbWFsbFNxdWFyZScsIFs5NzI0XV0sIFsnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJywgWzk2NDJdXSwgWydmamxpZycsIFsxMDIsIDEwNl1dLCBbJ2ZsYXQnLCBbOTgzN11dLCBbJ2ZsbGlnJywgWzY0MjU4XV0sIFsnZmx0bnMnLCBbOTY0OV1dLCBbJ2Zub2YnLCBbNDAyXV0sIFsnRm9wZicsIFsxMjAxMjVdXSwgWydmb3BmJywgWzEyMDE1MV1dLCBbJ2ZvcmFsbCcsIFs4NzA0XV0sIFsnRm9yQWxsJywgWzg3MDRdXSwgWydmb3JrJywgWzg5MTZdXSwgWydmb3JrdicsIFsxMDk2OV1dLCBbJ0ZvdXJpZXJ0cmYnLCBbODQ5N11dLCBbJ2ZwYXJ0aW50JywgWzEwNzY1XV0sIFsnZnJhYzEyJywgWzE4OV1dLCBbJ2ZyYWMxMycsIFs4NTMxXV0sIFsnZnJhYzE0JywgWzE4OF1dLCBbJ2ZyYWMxNScsIFs4NTMzXV0sIFsnZnJhYzE2JywgWzg1MzddXSwgWydmcmFjMTgnLCBbODUzOV1dLCBbJ2ZyYWMyMycsIFs4NTMyXV0sIFsnZnJhYzI1JywgWzg1MzRdXSwgWydmcmFjMzQnLCBbMTkwXV0sIFsnZnJhYzM1JywgWzg1MzVdXSwgWydmcmFjMzgnLCBbODU0MF1dLCBbJ2ZyYWM0NScsIFs4NTM2XV0sIFsnZnJhYzU2JywgWzg1MzhdXSwgWydmcmFjNTgnLCBbODU0MV1dLCBbJ2ZyYWM3OCcsIFs4NTQyXV0sIFsnZnJhc2wnLCBbODI2MF1dLCBbJ2Zyb3duJywgWzg5OTRdXSwgWydmc2NyJywgWzExOTk5NV1dLCBbJ0ZzY3InLCBbODQ5N11dLCBbJ2dhY3V0ZScsIFs1MDFdXSwgWydHYW1tYScsIFs5MTVdXSwgWydnYW1tYScsIFs5NDddXSwgWydHYW1tYWQnLCBbOTg4XV0sIFsnZ2FtbWFkJywgWzk4OV1dLCBbJ2dhcCcsIFsxMDg4Nl1dLCBbJ0dicmV2ZScsIFsyODZdXSwgWydnYnJldmUnLCBbMjg3XV0sIFsnR2NlZGlsJywgWzI5MF1dLCBbJ0djaXJjJywgWzI4NF1dLCBbJ2djaXJjJywgWzI4NV1dLCBbJ0djeScsIFsxMDQzXV0sIFsnZ2N5JywgWzEwNzVdXSwgWydHZG90JywgWzI4OF1dLCBbJ2dkb3QnLCBbMjg5XV0sIFsnZ2UnLCBbODgwNV1dLCBbJ2dFJywgWzg4MDddXSwgWydnRWwnLCBbMTA4OTJdXSwgWydnZWwnLCBbODkyM11dLCBbJ2dlcScsIFs4ODA1XV0sIFsnZ2VxcScsIFs4ODA3XV0sIFsnZ2Vxc2xhbnQnLCBbMTA4NzhdXSwgWydnZXNjYycsIFsxMDkyMV1dLCBbJ2dlcycsIFsxMDg3OF1dLCBbJ2dlc2RvdCcsIFsxMDg4MF1dLCBbJ2dlc2RvdG8nLCBbMTA4ODJdXSwgWydnZXNkb3RvbCcsIFsxMDg4NF1dLCBbJ2dlc2wnLCBbODkyMywgNjUwMjRdXSwgWydnZXNsZXMnLCBbMTA5MDBdXSwgWydHZnInLCBbMTIwMDc0XV0sIFsnZ2ZyJywgWzEyMDEwMF1dLCBbJ2dnJywgWzg4MTFdXSwgWydHZycsIFs4OTIxXV0sIFsnZ2dnJywgWzg5MjFdXSwgWydnaW1lbCcsIFs4NTAzXV0sIFsnR0pjeScsIFsxMDI3XV0sIFsnZ2pjeScsIFsxMTA3XV0sIFsnZ2xhJywgWzEwOTE3XV0sIFsnZ2wnLCBbODgyM11dLCBbJ2dsRScsIFsxMDg5OF1dLCBbJ2dsaicsIFsxMDkxNl1dLCBbJ2duYXAnLCBbMTA4OTBdXSwgWydnbmFwcHJveCcsIFsxMDg5MF1dLCBbJ2duZScsIFsxMDg4OF1dLCBbJ2duRScsIFs4ODA5XV0sIFsnZ25lcScsIFsxMDg4OF1dLCBbJ2duZXFxJywgWzg4MDldXSwgWydnbnNpbScsIFs4OTM1XV0sIFsnR29wZicsIFsxMjAxMjZdXSwgWydnb3BmJywgWzEyMDE1Ml1dLCBbJ2dyYXZlJywgWzk2XV0sIFsnR3JlYXRlckVxdWFsJywgWzg4MDVdXSwgWydHcmVhdGVyRXF1YWxMZXNzJywgWzg5MjNdXSwgWydHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDddXSwgWydHcmVhdGVyR3JlYXRlcicsIFsxMDkxNF1dLCBbJ0dyZWF0ZXJMZXNzJywgWzg4MjNdXSwgWydHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OF1dLCBbJ0dyZWF0ZXJUaWxkZScsIFs4ODE5XV0sIFsnR3NjcicsIFsxMTk5NzBdXSwgWydnc2NyJywgWzg0NThdXSwgWydnc2ltJywgWzg4MTldXSwgWydnc2ltZScsIFsxMDg5NF1dLCBbJ2dzaW1sJywgWzEwODk2XV0sIFsnZ3RjYycsIFsxMDkxOV1dLCBbJ2d0Y2lyJywgWzEwODc0XV0sIFsnZ3QnLCBbNjJdXSwgWydHVCcsIFs2Ml1dLCBbJ0d0JywgWzg4MTFdXSwgWydndGRvdCcsIFs4OTE5XV0sIFsnZ3RsUGFyJywgWzEwNjQ1XV0sIFsnZ3RxdWVzdCcsIFsxMDg3Nl1dLCBbJ2d0cmFwcHJveCcsIFsxMDg4Nl1dLCBbJ2d0cmFycicsIFsxMDYxNl1dLCBbJ2d0cmRvdCcsIFs4OTE5XV0sIFsnZ3RyZXFsZXNzJywgWzg5MjNdXSwgWydndHJlcXFsZXNzJywgWzEwODkyXV0sIFsnZ3RybGVzcycsIFs4ODIzXV0sIFsnZ3Ryc2ltJywgWzg4MTldXSwgWydndmVydG5lcXEnLCBbODgwOSwgNjUwMjRdXSwgWydndm5FJywgWzg4MDksIDY1MDI0XV0sIFsnSGFjZWsnLCBbNzExXV0sIFsnaGFpcnNwJywgWzgyMDJdXSwgWydoYWxmJywgWzE4OV1dLCBbJ2hhbWlsdCcsIFs4NDU5XV0sIFsnSEFSRGN5JywgWzEwNjZdXSwgWydoYXJkY3knLCBbMTA5OF1dLCBbJ2hhcnJjaXInLCBbMTA1NjhdXSwgWydoYXJyJywgWzg1OTZdXSwgWydoQXJyJywgWzg2NjBdXSwgWydoYXJydycsIFs4NjIxXV0sIFsnSGF0JywgWzk0XV0sIFsnaGJhcicsIFs4NDYzXV0sIFsnSGNpcmMnLCBbMjkyXV0sIFsnaGNpcmMnLCBbMjkzXV0sIFsnaGVhcnRzJywgWzk4MjldXSwgWydoZWFydHN1aXQnLCBbOTgyOV1dLCBbJ2hlbGxpcCcsIFs4MjMwXV0sIFsnaGVyY29uJywgWzg4ODldXSwgWydoZnInLCBbMTIwMTAxXV0sIFsnSGZyJywgWzg0NjBdXSwgWydIaWxiZXJ0U3BhY2UnLCBbODQ1OV1dLCBbJ2hrc2Vhcm93JywgWzEwNTMzXV0sIFsnaGtzd2Fyb3cnLCBbMTA1MzRdXSwgWydob2FycicsIFs4NzAzXV0sIFsnaG9tdGh0JywgWzg3NjNdXSwgWydob29rbGVmdGFycm93JywgWzg2MTddXSwgWydob29rcmlnaHRhcnJvdycsIFs4NjE4XV0sIFsnaG9wZicsIFsxMjAxNTNdXSwgWydIb3BmJywgWzg0NjFdXSwgWydob3JiYXInLCBbODIxM11dLCBbJ0hvcml6b250YWxMaW5lJywgWzk0NzJdXSwgWydoc2NyJywgWzExOTk5N11dLCBbJ0hzY3InLCBbODQ1OV1dLCBbJ2hzbGFzaCcsIFs4NDYzXV0sIFsnSHN0cm9rJywgWzI5NF1dLCBbJ2hzdHJvaycsIFsyOTVdXSwgWydIdW1wRG93bkh1bXAnLCBbODc4Ml1dLCBbJ0h1bXBFcXVhbCcsIFs4NzgzXV0sIFsnaHlidWxsJywgWzgyNTldXSwgWydoeXBoZW4nLCBbODIwOF1dLCBbJ0lhY3V0ZScsIFsyMDVdXSwgWydpYWN1dGUnLCBbMjM3XV0sIFsnaWMnLCBbODI5MV1dLCBbJ0ljaXJjJywgWzIwNl1dLCBbJ2ljaXJjJywgWzIzOF1dLCBbJ0ljeScsIFsxMDQ4XV0sIFsnaWN5JywgWzEwODBdXSwgWydJZG90JywgWzMwNF1dLCBbJ0lFY3knLCBbMTA0NV1dLCBbJ2llY3knLCBbMTA3N11dLCBbJ2lleGNsJywgWzE2MV1dLCBbJ2lmZicsIFs4NjYwXV0sIFsnaWZyJywgWzEyMDEwMl1dLCBbJ0lmcicsIFs4NDY1XV0sIFsnSWdyYXZlJywgWzIwNF1dLCBbJ2lncmF2ZScsIFsyMzZdXSwgWydpaScsIFs4NTIwXV0sIFsnaWlpaW50JywgWzEwNzY0XV0sIFsnaWlpbnQnLCBbODc0OV1dLCBbJ2lpbmZpbicsIFsxMDcxNl1dLCBbJ2lpb3RhJywgWzg0ODldXSwgWydJSmxpZycsIFszMDZdXSwgWydpamxpZycsIFszMDddXSwgWydJbWFjcicsIFsyOThdXSwgWydpbWFjcicsIFsyOTldXSwgWydpbWFnZScsIFs4NDY1XV0sIFsnSW1hZ2luYXJ5SScsIFs4NTIwXV0sIFsnaW1hZ2xpbmUnLCBbODQ2NF1dLCBbJ2ltYWdwYXJ0JywgWzg0NjVdXSwgWydpbWF0aCcsIFszMDVdXSwgWydJbScsIFs4NDY1XV0sIFsnaW1vZicsIFs4ODg3XV0sIFsnaW1wZWQnLCBbNDM3XV0sIFsnSW1wbGllcycsIFs4NjU4XV0sIFsnaW5jYXJlJywgWzg0NTNdXSwgWydpbicsIFs4NzEyXV0sIFsnaW5maW4nLCBbODczNF1dLCBbJ2luZmludGllJywgWzEwNzE3XV0sIFsnaW5vZG90JywgWzMwNV1dLCBbJ2ludGNhbCcsIFs4ODkwXV0sIFsnaW50JywgWzg3NDddXSwgWydJbnQnLCBbODc0OF1dLCBbJ2ludGVnZXJzJywgWzg0ODRdXSwgWydJbnRlZ3JhbCcsIFs4NzQ3XV0sIFsnaW50ZXJjYWwnLCBbODg5MF1dLCBbJ0ludGVyc2VjdGlvbicsIFs4ODk4XV0sIFsnaW50bGFyaGsnLCBbMTA3NzVdXSwgWydpbnRwcm9kJywgWzEwODEyXV0sIFsnSW52aXNpYmxlQ29tbWEnLCBbODI5MV1dLCBbJ0ludmlzaWJsZVRpbWVzJywgWzgyOTBdXSwgWydJT2N5JywgWzEwMjVdXSwgWydpb2N5JywgWzExMDVdXSwgWydJb2dvbicsIFszMDJdXSwgWydpb2dvbicsIFszMDNdXSwgWydJb3BmJywgWzEyMDEyOF1dLCBbJ2lvcGYnLCBbMTIwMTU0XV0sIFsnSW90YScsIFs5MjFdXSwgWydpb3RhJywgWzk1M11dLCBbJ2lwcm9kJywgWzEwODEyXV0sIFsnaXF1ZXN0JywgWzE5MV1dLCBbJ2lzY3InLCBbMTE5OTk4XV0sIFsnSXNjcicsIFs4NDY0XV0sIFsnaXNpbicsIFs4NzEyXV0sIFsnaXNpbmRvdCcsIFs4OTQ5XV0sIFsnaXNpbkUnLCBbODk1M11dLCBbJ2lzaW5zJywgWzg5NDhdXSwgWydpc2luc3YnLCBbODk0N11dLCBbJ2lzaW52JywgWzg3MTJdXSwgWydpdCcsIFs4MjkwXV0sIFsnSXRpbGRlJywgWzI5Nl1dLCBbJ2l0aWxkZScsIFsyOTddXSwgWydJdWtjeScsIFsxMDMwXV0sIFsnaXVrY3knLCBbMTExMF1dLCBbJ0l1bWwnLCBbMjA3XV0sIFsnaXVtbCcsIFsyMzldXSwgWydKY2lyYycsIFszMDhdXSwgWydqY2lyYycsIFszMDldXSwgWydKY3knLCBbMTA0OV1dLCBbJ2pjeScsIFsxMDgxXV0sIFsnSmZyJywgWzEyMDA3N11dLCBbJ2pmcicsIFsxMjAxMDNdXSwgWydqbWF0aCcsIFs1NjddXSwgWydKb3BmJywgWzEyMDEyOV1dLCBbJ2pvcGYnLCBbMTIwMTU1XV0sIFsnSnNjcicsIFsxMTk5NzNdXSwgWydqc2NyJywgWzExOTk5OV1dLCBbJ0pzZXJjeScsIFsxMDMyXV0sIFsnanNlcmN5JywgWzExMTJdXSwgWydKdWtjeScsIFsxMDI4XV0sIFsnanVrY3knLCBbMTEwOF1dLCBbJ0thcHBhJywgWzkyMl1dLCBbJ2thcHBhJywgWzk1NF1dLCBbJ2thcHBhdicsIFsxMDA4XV0sIFsnS2NlZGlsJywgWzMxMF1dLCBbJ2tjZWRpbCcsIFszMTFdXSwgWydLY3knLCBbMTA1MF1dLCBbJ2tjeScsIFsxMDgyXV0sIFsnS2ZyJywgWzEyMDA3OF1dLCBbJ2tmcicsIFsxMjAxMDRdXSwgWydrZ3JlZW4nLCBbMzEyXV0sIFsnS0hjeScsIFsxMDYxXV0sIFsna2hjeScsIFsxMDkzXV0sIFsnS0pjeScsIFsxMDM2XV0sIFsna2pjeScsIFsxMTE2XV0sIFsnS29wZicsIFsxMjAxMzBdXSwgWydrb3BmJywgWzEyMDE1Nl1dLCBbJ0tzY3InLCBbMTE5OTc0XV0sIFsna3NjcicsIFsxMjAwMDBdXSwgWydsQWFycicsIFs4NjY2XV0sIFsnTGFjdXRlJywgWzMxM11dLCBbJ2xhY3V0ZScsIFszMTRdXSwgWydsYWVtcHR5dicsIFsxMDY3Nl1dLCBbJ2xhZ3JhbicsIFs4NDY2XV0sIFsnTGFtYmRhJywgWzkyM11dLCBbJ2xhbWJkYScsIFs5NTVdXSwgWydsYW5nJywgWzEwMjE2XV0sIFsnTGFuZycsIFsxMDIxOF1dLCBbJ2xhbmdkJywgWzEwNjQxXV0sIFsnbGFuZ2xlJywgWzEwMjE2XV0sIFsnbGFwJywgWzEwODg1XV0sIFsnTGFwbGFjZXRyZicsIFs4NDY2XV0sIFsnbGFxdW8nLCBbMTcxXV0sIFsnbGFycmInLCBbODY3Nl1dLCBbJ2xhcnJiZnMnLCBbMTA1MjddXSwgWydsYXJyJywgWzg1OTJdXSwgWydMYXJyJywgWzg2MDZdXSwgWydsQXJyJywgWzg2NTZdXSwgWydsYXJyZnMnLCBbMTA1MjVdXSwgWydsYXJyaGsnLCBbODYxN11dLCBbJ2xhcnJscCcsIFs4NjE5XV0sIFsnbGFycnBsJywgWzEwNTUzXV0sIFsnbGFycnNpbScsIFsxMDYxMV1dLCBbJ2xhcnJ0bCcsIFs4NjEwXV0sIFsnbGF0YWlsJywgWzEwNTIxXV0sIFsnbEF0YWlsJywgWzEwNTIzXV0sIFsnbGF0JywgWzEwOTIzXV0sIFsnbGF0ZScsIFsxMDkyNV1dLCBbJ2xhdGVzJywgWzEwOTI1LCA2NTAyNF1dLCBbJ2xiYXJyJywgWzEwNTA4XV0sIFsnbEJhcnInLCBbMTA1MTBdXSwgWydsYmJyaycsIFsxMDA5OF1dLCBbJ2xicmFjZScsIFsxMjNdXSwgWydsYnJhY2snLCBbOTFdXSwgWydsYnJrZScsIFsxMDYzNV1dLCBbJ2xicmtzbGQnLCBbMTA2MzldXSwgWydsYnJrc2x1JywgWzEwNjM3XV0sIFsnTGNhcm9uJywgWzMxN11dLCBbJ2xjYXJvbicsIFszMThdXSwgWydMY2VkaWwnLCBbMzE1XV0sIFsnbGNlZGlsJywgWzMxNl1dLCBbJ2xjZWlsJywgWzg5NjhdXSwgWydsY3ViJywgWzEyM11dLCBbJ0xjeScsIFsxMDUxXV0sIFsnbGN5JywgWzEwODNdXSwgWydsZGNhJywgWzEwNTUwXV0sIFsnbGRxdW8nLCBbODIyMF1dLCBbJ2xkcXVvcicsIFs4MjIyXV0sIFsnbGRyZGhhcicsIFsxMDU5OV1dLCBbJ2xkcnVzaGFyJywgWzEwNTcxXV0sIFsnbGRzaCcsIFs4NjI2XV0sIFsnbGUnLCBbODgwNF1dLCBbJ2xFJywgWzg4MDZdXSwgWydMZWZ0QW5nbGVCcmFja2V0JywgWzEwMjE2XV0sIFsnTGVmdEFycm93QmFyJywgWzg2NzZdXSwgWydsZWZ0YXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRBcnJvdycsIFs4NTkyXV0sIFsnTGVmdGFycm93JywgWzg2NTZdXSwgWydMZWZ0QXJyb3dSaWdodEFycm93JywgWzg2NDZdXSwgWydsZWZ0YXJyb3d0YWlsJywgWzg2MTBdXSwgWydMZWZ0Q2VpbGluZycsIFs4OTY4XV0sIFsnTGVmdERvdWJsZUJyYWNrZXQnLCBbMTAyMTRdXSwgWydMZWZ0RG93blRlZVZlY3RvcicsIFsxMDU5M11dLCBbJ0xlZnREb3duVmVjdG9yQmFyJywgWzEwNTg1XV0sIFsnTGVmdERvd25WZWN0b3InLCBbODY0M11dLCBbJ0xlZnRGbG9vcicsIFs4OTcwXV0sIFsnbGVmdGhhcnBvb25kb3duJywgWzg2MzddXSwgWydsZWZ0aGFycG9vbnVwJywgWzg2MzZdXSwgWydsZWZ0bGVmdGFycm93cycsIFs4NjQ3XV0sIFsnbGVmdHJpZ2h0YXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRSaWdodEFycm93JywgWzg1OTZdXSwgWydMZWZ0cmlnaHRhcnJvdycsIFs4NjYwXV0sIFsnbGVmdHJpZ2h0YXJyb3dzJywgWzg2NDZdXSwgWydsZWZ0cmlnaHRoYXJwb29ucycsIFs4NjUxXV0sIFsnbGVmdHJpZ2h0c3F1aWdhcnJvdycsIFs4NjIxXV0sIFsnTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc0XV0sIFsnTGVmdFRlZUFycm93JywgWzg2MTJdXSwgWydMZWZ0VGVlJywgWzg4NjddXSwgWydMZWZ0VGVlVmVjdG9yJywgWzEwNTg2XV0sIFsnbGVmdHRocmVldGltZXMnLCBbODkwN11dLCBbJ0xlZnRUcmlhbmdsZUJhcicsIFsxMDcwM11dLCBbJ0xlZnRUcmlhbmdsZScsIFs4ODgyXV0sIFsnTGVmdFRyaWFuZ2xlRXF1YWwnLCBbODg4NF1dLCBbJ0xlZnRVcERvd25WZWN0b3InLCBbMTA1NzddXSwgWydMZWZ0VXBUZWVWZWN0b3InLCBbMTA1OTJdXSwgWydMZWZ0VXBWZWN0b3JCYXInLCBbMTA1ODRdXSwgWydMZWZ0VXBWZWN0b3InLCBbODYzOV1dLCBbJ0xlZnRWZWN0b3JCYXInLCBbMTA1NzhdXSwgWydMZWZ0VmVjdG9yJywgWzg2MzZdXSwgWydsRWcnLCBbMTA4OTFdXSwgWydsZWcnLCBbODkyMl1dLCBbJ2xlcScsIFs4ODA0XV0sIFsnbGVxcScsIFs4ODA2XV0sIFsnbGVxc2xhbnQnLCBbMTA4NzddXSwgWydsZXNjYycsIFsxMDkyMF1dLCBbJ2xlcycsIFsxMDg3N11dLCBbJ2xlc2RvdCcsIFsxMDg3OV1dLCBbJ2xlc2RvdG8nLCBbMTA4ODFdXSwgWydsZXNkb3RvcicsIFsxMDg4M11dLCBbJ2xlc2cnLCBbODkyMiwgNjUwMjRdXSwgWydsZXNnZXMnLCBbMTA4OTldXSwgWydsZXNzYXBwcm94JywgWzEwODg1XV0sIFsnbGVzc2RvdCcsIFs4OTE4XV0sIFsnbGVzc2VxZ3RyJywgWzg5MjJdXSwgWydsZXNzZXFxZ3RyJywgWzEwODkxXV0sIFsnTGVzc0VxdWFsR3JlYXRlcicsIFs4OTIyXV0sIFsnTGVzc0Z1bGxFcXVhbCcsIFs4ODA2XV0sIFsnTGVzc0dyZWF0ZXInLCBbODgyMl1dLCBbJ2xlc3NndHInLCBbODgyMl1dLCBbJ0xlc3NMZXNzJywgWzEwOTEzXV0sIFsnbGVzc3NpbScsIFs4ODE4XV0sIFsnTGVzc1NsYW50RXF1YWwnLCBbMTA4NzddXSwgWydMZXNzVGlsZGUnLCBbODgxOF1dLCBbJ2xmaXNodCcsIFsxMDYyMF1dLCBbJ2xmbG9vcicsIFs4OTcwXV0sIFsnTGZyJywgWzEyMDA3OV1dLCBbJ2xmcicsIFsxMjAxMDVdXSwgWydsZycsIFs4ODIyXV0sIFsnbGdFJywgWzEwODk3XV0sIFsnbEhhcicsIFsxMDU5NF1dLCBbJ2xoYXJkJywgWzg2MzddXSwgWydsaGFydScsIFs4NjM2XV0sIFsnbGhhcnVsJywgWzEwNjAyXV0sIFsnbGhibGsnLCBbOTYwNF1dLCBbJ0xKY3knLCBbMTAzM11dLCBbJ2xqY3knLCBbMTExM11dLCBbJ2xsYXJyJywgWzg2NDddXSwgWydsbCcsIFs4ODEwXV0sIFsnTGwnLCBbODkyMF1dLCBbJ2xsY29ybmVyJywgWzg5OTBdXSwgWydMbGVmdGFycm93JywgWzg2NjZdXSwgWydsbGhhcmQnLCBbMTA2MDNdXSwgWydsbHRyaScsIFs5NzIyXV0sIFsnTG1pZG90JywgWzMxOV1dLCBbJ2xtaWRvdCcsIFszMjBdXSwgWydsbW91c3RhY2hlJywgWzkxMzZdXSwgWydsbW91c3QnLCBbOTEzNl1dLCBbJ2xuYXAnLCBbMTA4ODldXSwgWydsbmFwcHJveCcsIFsxMDg4OV1dLCBbJ2xuZScsIFsxMDg4N11dLCBbJ2xuRScsIFs4ODA4XV0sIFsnbG5lcScsIFsxMDg4N11dLCBbJ2xuZXFxJywgWzg4MDhdXSwgWydsbnNpbScsIFs4OTM0XV0sIFsnbG9hbmcnLCBbMTAyMjBdXSwgWydsb2FycicsIFs4NzAxXV0sIFsnbG9icmsnLCBbMTAyMTRdXSwgWydsb25nbGVmdGFycm93JywgWzEwMjI5XV0sIFsnTG9uZ0xlZnRBcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdsZWZ0YXJyb3cnLCBbMTAyMzJdXSwgWydsb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzFdXSwgWydMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzFdXSwgWydMb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzRdXSwgWydsb25nbWFwc3RvJywgWzEwMjM2XV0sIFsnbG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzBdXSwgWydMb25nUmlnaHRBcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdyaWdodGFycm93JywgWzEwMjMzXV0sIFsnbG9vcGFycm93bGVmdCcsIFs4NjE5XV0sIFsnbG9vcGFycm93cmlnaHQnLCBbODYyMF1dLCBbJ2xvcGFyJywgWzEwNjI5XV0sIFsnTG9wZicsIFsxMjAxMzFdXSwgWydsb3BmJywgWzEyMDE1N11dLCBbJ2xvcGx1cycsIFsxMDc5N11dLCBbJ2xvdGltZXMnLCBbMTA4MDRdXSwgWydsb3dhc3QnLCBbODcyN11dLCBbJ2xvd2JhcicsIFs5NV1dLCBbJ0xvd2VyTGVmdEFycm93JywgWzg2MDFdXSwgWydMb3dlclJpZ2h0QXJyb3cnLCBbODYwMF1dLCBbJ2xveicsIFs5Njc0XV0sIFsnbG96ZW5nZScsIFs5Njc0XV0sIFsnbG96ZicsIFsxMDczMV1dLCBbJ2xwYXInLCBbNDBdXSwgWydscGFybHQnLCBbMTA2NDNdXSwgWydscmFycicsIFs4NjQ2XV0sIFsnbHJjb3JuZXInLCBbODk5MV1dLCBbJ2xyaGFyJywgWzg2NTFdXSwgWydscmhhcmQnLCBbMTA2MDVdXSwgWydscm0nLCBbODIwNl1dLCBbJ2xydHJpJywgWzg4OTVdXSwgWydsc2FxdW8nLCBbODI0OV1dLCBbJ2xzY3InLCBbMTIwMDAxXV0sIFsnTHNjcicsIFs4NDY2XV0sIFsnbHNoJywgWzg2MjRdXSwgWydMc2gnLCBbODYyNF1dLCBbJ2xzaW0nLCBbODgxOF1dLCBbJ2xzaW1lJywgWzEwODkzXV0sIFsnbHNpbWcnLCBbMTA4OTVdXSwgWydsc3FiJywgWzkxXV0sIFsnbHNxdW8nLCBbODIxNl1dLCBbJ2xzcXVvcicsIFs4MjE4XV0sIFsnTHN0cm9rJywgWzMyMV1dLCBbJ2xzdHJvaycsIFszMjJdXSwgWydsdGNjJywgWzEwOTE4XV0sIFsnbHRjaXInLCBbMTA4NzNdXSwgWydsdCcsIFs2MF1dLCBbJ0xUJywgWzYwXV0sIFsnTHQnLCBbODgxMF1dLCBbJ2x0ZG90JywgWzg5MThdXSwgWydsdGhyZWUnLCBbODkwN11dLCBbJ2x0aW1lcycsIFs4OTA1XV0sIFsnbHRsYXJyJywgWzEwNjE0XV0sIFsnbHRxdWVzdCcsIFsxMDg3NV1dLCBbJ2x0cmknLCBbOTY2N11dLCBbJ2x0cmllJywgWzg4ODRdXSwgWydsdHJpZicsIFs5NjY2XV0sIFsnbHRyUGFyJywgWzEwNjQ2XV0sIFsnbHVyZHNoYXInLCBbMTA1NzBdXSwgWydsdXJ1aGFyJywgWzEwNTk4XV0sIFsnbHZlcnRuZXFxJywgWzg4MDgsIDY1MDI0XV0sIFsnbHZuRScsIFs4ODA4LCA2NTAyNF1dLCBbJ21hY3InLCBbMTc1XV0sIFsnbWFsZScsIFs5Nzk0XV0sIFsnbWFsdCcsIFsxMDAxNl1dLCBbJ21hbHRlc2UnLCBbMTAwMTZdXSwgWydNYXAnLCBbMTA1MDFdXSwgWydtYXAnLCBbODYxNF1dLCBbJ21hcHN0bycsIFs4NjE0XV0sIFsnbWFwc3RvZG93bicsIFs4NjE1XV0sIFsnbWFwc3RvbGVmdCcsIFs4NjEyXV0sIFsnbWFwc3RvdXAnLCBbODYxM11dLCBbJ21hcmtlcicsIFs5NjQ2XV0sIFsnbWNvbW1hJywgWzEwNzkzXV0sIFsnTWN5JywgWzEwNTJdXSwgWydtY3knLCBbMTA4NF1dLCBbJ21kYXNoJywgWzgyMTJdXSwgWydtRERvdCcsIFs4NzYyXV0sIFsnbWVhc3VyZWRhbmdsZScsIFs4NzM3XV0sIFsnTWVkaXVtU3BhY2UnLCBbODI4N11dLCBbJ01lbGxpbnRyZicsIFs4NDk5XV0sIFsnTWZyJywgWzEyMDA4MF1dLCBbJ21mcicsIFsxMjAxMDZdXSwgWydtaG8nLCBbODQ4N11dLCBbJ21pY3JvJywgWzE4MV1dLCBbJ21pZGFzdCcsIFs0Ml1dLCBbJ21pZGNpcicsIFsxMDk5Ml1dLCBbJ21pZCcsIFs4NzM5XV0sIFsnbWlkZG90JywgWzE4M11dLCBbJ21pbnVzYicsIFs4ODYzXV0sIFsnbWludXMnLCBbODcyMl1dLCBbJ21pbnVzZCcsIFs4NzYwXV0sIFsnbWludXNkdScsIFsxMDc5NF1dLCBbJ01pbnVzUGx1cycsIFs4NzIzXV0sIFsnbWxjcCcsIFsxMDk3MV1dLCBbJ21sZHInLCBbODIzMF1dLCBbJ21ucGx1cycsIFs4NzIzXV0sIFsnbW9kZWxzJywgWzg4NzFdXSwgWydNb3BmJywgWzEyMDEzMl1dLCBbJ21vcGYnLCBbMTIwMTU4XV0sIFsnbXAnLCBbODcyM11dLCBbJ21zY3InLCBbMTIwMDAyXV0sIFsnTXNjcicsIFs4NDk5XV0sIFsnbXN0cG9zJywgWzg3NjZdXSwgWydNdScsIFs5MjRdXSwgWydtdScsIFs5NTZdXSwgWydtdWx0aW1hcCcsIFs4ODg4XV0sIFsnbXVtYXAnLCBbODg4OF1dLCBbJ25hYmxhJywgWzg3MTFdXSwgWydOYWN1dGUnLCBbMzIzXV0sIFsnbmFjdXRlJywgWzMyNF1dLCBbJ25hbmcnLCBbODczNiwgODQwMl1dLCBbJ25hcCcsIFs4Nzc3XV0sIFsnbmFwRScsIFsxMDg2NCwgODI0XV0sIFsnbmFwaWQnLCBbODc3OSwgODI0XV0sIFsnbmFwb3MnLCBbMzI5XV0sIFsnbmFwcHJveCcsIFs4Nzc3XV0sIFsnbmF0dXJhbCcsIFs5ODM4XV0sIFsnbmF0dXJhbHMnLCBbODQ2OV1dLCBbJ25hdHVyJywgWzk4MzhdXSwgWyduYnNwJywgWzE2MF1dLCBbJ25idW1wJywgWzg3ODIsIDgyNF1dLCBbJ25idW1wZScsIFs4NzgzLCA4MjRdXSwgWyduY2FwJywgWzEwODE5XV0sIFsnTmNhcm9uJywgWzMyN11dLCBbJ25jYXJvbicsIFszMjhdXSwgWydOY2VkaWwnLCBbMzI1XV0sIFsnbmNlZGlsJywgWzMyNl1dLCBbJ25jb25nJywgWzg3NzVdXSwgWyduY29uZ2RvdCcsIFsxMDg2MSwgODI0XV0sIFsnbmN1cCcsIFsxMDgxOF1dLCBbJ05jeScsIFsxMDUzXV0sIFsnbmN5JywgWzEwODVdXSwgWyduZGFzaCcsIFs4MjExXV0sIFsnbmVhcmhrJywgWzEwNTMyXV0sIFsnbmVhcnInLCBbODU5OV1dLCBbJ25lQXJyJywgWzg2NjNdXSwgWyduZWFycm93JywgWzg1OTldXSwgWyduZScsIFs4ODAwXV0sIFsnbmVkb3QnLCBbODc4NCwgODI0XV0sIFsnTmVnYXRpdmVNZWRpdW1TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGlja1NwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJywgWzgyMDNdXSwgWyduZXF1aXYnLCBbODgwMl1dLCBbJ25lc2VhcicsIFsxMDUzNl1dLCBbJ25lc2ltJywgWzg3NzAsIDgyNF1dLCBbJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzg4MTFdXSwgWydOZXN0ZWRMZXNzTGVzcycsIFs4ODEwXV0sIFsnbmV4aXN0JywgWzg3MDhdXSwgWyduZXhpc3RzJywgWzg3MDhdXSwgWydOZnInLCBbMTIwMDgxXV0sIFsnbmZyJywgWzEyMDEwN11dLCBbJ25nRScsIFs4ODA3LCA4MjRdXSwgWyduZ2UnLCBbODgxN11dLCBbJ25nZXEnLCBbODgxN11dLCBbJ25nZXFxJywgWzg4MDcsIDgyNF1dLCBbJ25nZXFzbGFudCcsIFsxMDg3OCwgODI0XV0sIFsnbmdlcycsIFsxMDg3OCwgODI0XV0sIFsnbkdnJywgWzg5MjEsIDgyNF1dLCBbJ25nc2ltJywgWzg4MjFdXSwgWyduR3QnLCBbODgxMSwgODQwMl1dLCBbJ25ndCcsIFs4ODE1XV0sIFsnbmd0cicsIFs4ODE1XV0sIFsnbkd0dicsIFs4ODExLCA4MjRdXSwgWyduaGFycicsIFs4NjIyXV0sIFsnbmhBcnInLCBbODY1NF1dLCBbJ25ocGFyJywgWzEwOTk0XV0sIFsnbmknLCBbODcxNV1dLCBbJ25pcycsIFs4OTU2XV0sIFsnbmlzZCcsIFs4OTU0XV0sIFsnbml2JywgWzg3MTVdXSwgWydOSmN5JywgWzEwMzRdXSwgWyduamN5JywgWzExMTRdXSwgWydubGFycicsIFs4NjAyXV0sIFsnbmxBcnInLCBbODY1M11dLCBbJ25sZHInLCBbODIyOV1dLCBbJ25sRScsIFs4ODA2LCA4MjRdXSwgWydubGUnLCBbODgxNl1dLCBbJ25sZWZ0YXJyb3cnLCBbODYwMl1dLCBbJ25MZWZ0YXJyb3cnLCBbODY1M11dLCBbJ25sZWZ0cmlnaHRhcnJvdycsIFs4NjIyXV0sIFsnbkxlZnRyaWdodGFycm93JywgWzg2NTRdXSwgWydubGVxJywgWzg4MTZdXSwgWydubGVxcScsIFs4ODA2LCA4MjRdXSwgWydubGVxc2xhbnQnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXMnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXNzJywgWzg4MTRdXSwgWyduTGwnLCBbODkyMCwgODI0XV0sIFsnbmxzaW0nLCBbODgyMF1dLCBbJ25MdCcsIFs4ODEwLCA4NDAyXV0sIFsnbmx0JywgWzg4MTRdXSwgWydubHRyaScsIFs4OTM4XV0sIFsnbmx0cmllJywgWzg5NDBdXSwgWyduTHR2JywgWzg4MTAsIDgyNF1dLCBbJ25taWQnLCBbODc0MF1dLCBbJ05vQnJlYWsnLCBbODI4OF1dLCBbJ05vbkJyZWFraW5nU3BhY2UnLCBbMTYwXV0sIFsnbm9wZicsIFsxMjAxNTldXSwgWydOb3BmJywgWzg0NjldXSwgWydOb3QnLCBbMTA5ODhdXSwgWydub3QnLCBbMTcyXV0sIFsnTm90Q29uZ3J1ZW50JywgWzg4MDJdXSwgWydOb3RDdXBDYXAnLCBbODgxM11dLCBbJ05vdERvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDJdXSwgWydOb3RFbGVtZW50JywgWzg3MTNdXSwgWydOb3RFcXVhbCcsIFs4ODAwXV0sIFsnTm90RXF1YWxUaWxkZScsIFs4NzcwLCA4MjRdXSwgWydOb3RFeGlzdHMnLCBbODcwOF1dLCBbJ05vdEdyZWF0ZXInLCBbODgxNV1dLCBbJ05vdEdyZWF0ZXJFcXVhbCcsIFs4ODE3XV0sIFsnTm90R3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3LCA4MjRdXSwgWydOb3RHcmVhdGVyR3JlYXRlcicsIFs4ODExLCA4MjRdXSwgWydOb3RHcmVhdGVyTGVzcycsIFs4ODI1XV0sIFsnTm90R3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzgsIDgyNF1dLCBbJ05vdEdyZWF0ZXJUaWxkZScsIFs4ODIxXV0sIFsnTm90SHVtcERvd25IdW1wJywgWzg3ODIsIDgyNF1dLCBbJ05vdEh1bXBFcXVhbCcsIFs4NzgzLCA4MjRdXSwgWydub3RpbicsIFs4NzEzXV0sIFsnbm90aW5kb3QnLCBbODk0OSwgODI0XV0sIFsnbm90aW5FJywgWzg5NTMsIDgyNF1dLCBbJ25vdGludmEnLCBbODcxM11dLCBbJ25vdGludmInLCBbODk1MV1dLCBbJ25vdGludmMnLCBbODk1MF1dLCBbJ05vdExlZnRUcmlhbmdsZUJhcicsIFsxMDcwMywgODI0XV0sIFsnTm90TGVmdFRyaWFuZ2xlJywgWzg5MzhdXSwgWydOb3RMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4OTQwXV0sIFsnTm90TGVzcycsIFs4ODE0XV0sIFsnTm90TGVzc0VxdWFsJywgWzg4MTZdXSwgWydOb3RMZXNzR3JlYXRlcicsIFs4ODI0XV0sIFsnTm90TGVzc0xlc3MnLCBbODgxMCwgODI0XV0sIFsnTm90TGVzc1NsYW50RXF1YWwnLCBbMTA4NzcsIDgyNF1dLCBbJ05vdExlc3NUaWxkZScsIFs4ODIwXV0sIFsnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbMTA5MTQsIDgyNF1dLCBbJ05vdE5lc3RlZExlc3NMZXNzJywgWzEwOTEzLCA4MjRdXSwgWydub3RuaScsIFs4NzE2XV0sIFsnbm90bml2YScsIFs4NzE2XV0sIFsnbm90bml2YicsIFs4OTU4XV0sIFsnbm90bml2YycsIFs4OTU3XV0sIFsnTm90UHJlY2VkZXMnLCBbODgzMl1dLCBbJ05vdFByZWNlZGVzRXF1YWwnLCBbMTA5MjcsIDgyNF1dLCBbJ05vdFByZWNlZGVzU2xhbnRFcXVhbCcsIFs4OTI4XV0sIFsnTm90UmV2ZXJzZUVsZW1lbnQnLCBbODcxNl1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDQsIDgyNF1dLCBbJ05vdFJpZ2h0VHJpYW5nbGUnLCBbODkzOV1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4OTQxXV0sIFsnTm90U3F1YXJlU3Vic2V0JywgWzg4NDcsIDgyNF1dLCBbJ05vdFNxdWFyZVN1YnNldEVxdWFsJywgWzg5MzBdXSwgWydOb3RTcXVhcmVTdXBlcnNldCcsIFs4ODQ4LCA4MjRdXSwgWydOb3RTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg5MzFdXSwgWydOb3RTdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ05vdFN1YnNldEVxdWFsJywgWzg4NDBdXSwgWydOb3RTdWNjZWVkcycsIFs4ODMzXV0sIFsnTm90U3VjY2VlZHNFcXVhbCcsIFsxMDkyOCwgODI0XV0sIFsnTm90U3VjY2VlZHNTbGFudEVxdWFsJywgWzg5MjldXSwgWydOb3RTdWNjZWVkc1RpbGRlJywgWzg4MzEsIDgyNF1dLCBbJ05vdFN1cGVyc2V0JywgWzg4MzUsIDg0MDJdXSwgWydOb3RTdXBlcnNldEVxdWFsJywgWzg4NDFdXSwgWydOb3RUaWxkZScsIFs4NzY5XV0sIFsnTm90VGlsZGVFcXVhbCcsIFs4NzcyXV0sIFsnTm90VGlsZGVGdWxsRXF1YWwnLCBbODc3NV1dLCBbJ05vdFRpbGRlVGlsZGUnLCBbODc3N11dLCBbJ05vdFZlcnRpY2FsQmFyJywgWzg3NDBdXSwgWyducGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25wYXInLCBbODc0Ml1dLCBbJ25wYXJzbCcsIFsxMTAwNSwgODQyMV1dLCBbJ25wYXJ0JywgWzg3MDYsIDgyNF1dLCBbJ25wb2xpbnQnLCBbMTA3NzJdXSwgWyducHInLCBbODgzMl1dLCBbJ25wcmN1ZScsIFs4OTI4XV0sIFsnbnByZWMnLCBbODgzMl1dLCBbJ25wcmVjZXEnLCBbMTA5MjcsIDgyNF1dLCBbJ25wcmUnLCBbMTA5MjcsIDgyNF1dLCBbJ25yYXJyYycsIFsxMDU0NywgODI0XV0sIFsnbnJhcnInLCBbODYwM11dLCBbJ25yQXJyJywgWzg2NTVdXSwgWyducmFycncnLCBbODYwNSwgODI0XV0sIFsnbnJpZ2h0YXJyb3cnLCBbODYwM11dLCBbJ25SaWdodGFycm93JywgWzg2NTVdXSwgWyducnRyaScsIFs4OTM5XV0sIFsnbnJ0cmllJywgWzg5NDFdXSwgWyduc2MnLCBbODgzM11dLCBbJ25zY2N1ZScsIFs4OTI5XV0sIFsnbnNjZScsIFsxMDkyOCwgODI0XV0sIFsnTnNjcicsIFsxMTk5NzddXSwgWyduc2NyJywgWzEyMDAwM11dLCBbJ25zaG9ydG1pZCcsIFs4NzQwXV0sIFsnbnNob3J0cGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25zaW0nLCBbODc2OV1dLCBbJ25zaW1lJywgWzg3NzJdXSwgWyduc2ltZXEnLCBbODc3Ml1dLCBbJ25zbWlkJywgWzg3NDBdXSwgWyduc3BhcicsIFs4NzQyXV0sIFsnbnNxc3ViZScsIFs4OTMwXV0sIFsnbnNxc3VwZScsIFs4OTMxXV0sIFsnbnN1YicsIFs4ODM2XV0sIFsnbnN1YkUnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWJlJywgWzg4NDBdXSwgWyduc3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWyduc3Vic2V0ZXEnLCBbODg0MF1dLCBbJ25zdWJzZXRlcXEnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWNjJywgWzg4MzNdXSwgWyduc3VjY2VxJywgWzEwOTI4LCA4MjRdXSwgWyduc3VwJywgWzg4MzddXSwgWyduc3VwRScsIFsxMDk1MCwgODI0XV0sIFsnbnN1cGUnLCBbODg0MV1dLCBbJ25zdXBzZXQnLCBbODgzNSwgODQwMl1dLCBbJ25zdXBzZXRlcScsIFs4ODQxXV0sIFsnbnN1cHNldGVxcScsIFsxMDk1MCwgODI0XV0sIFsnbnRnbCcsIFs4ODI1XV0sIFsnTnRpbGRlJywgWzIwOV1dLCBbJ250aWxkZScsIFsyNDFdXSwgWydudGxnJywgWzg4MjRdXSwgWydudHJpYW5nbGVsZWZ0JywgWzg5MzhdXSwgWydudHJpYW5nbGVsZWZ0ZXEnLCBbODk0MF1dLCBbJ250cmlhbmdsZXJpZ2h0JywgWzg5MzldXSwgWydudHJpYW5nbGVyaWdodGVxJywgWzg5NDFdXSwgWydOdScsIFs5MjVdXSwgWydudScsIFs5NTddXSwgWydudW0nLCBbMzVdXSwgWydudW1lcm8nLCBbODQ3MF1dLCBbJ251bXNwJywgWzgxOTldXSwgWydudmFwJywgWzg3ODEsIDg0MDJdXSwgWydudmRhc2gnLCBbODg3Nl1dLCBbJ252RGFzaCcsIFs4ODc3XV0sIFsnblZkYXNoJywgWzg4NzhdXSwgWyduVkRhc2gnLCBbODg3OV1dLCBbJ252Z2UnLCBbODgwNSwgODQwMl1dLCBbJ252Z3QnLCBbNjIsIDg0MDJdXSwgWydudkhhcnInLCBbMTA1MDBdXSwgWydudmluZmluJywgWzEwNzE4XV0sIFsnbnZsQXJyJywgWzEwNDk4XV0sIFsnbnZsZScsIFs4ODA0LCA4NDAyXV0sIFsnbnZsdCcsIFs2MCwgODQwMl1dLCBbJ252bHRyaWUnLCBbODg4NCwgODQwMl1dLCBbJ252ckFycicsIFsxMDQ5OV1dLCBbJ252cnRyaWUnLCBbODg4NSwgODQwMl1dLCBbJ252c2ltJywgWzg3NjQsIDg0MDJdXSwgWydud2FyaGsnLCBbMTA1MzFdXSwgWydud2FycicsIFs4NTk4XV0sIFsnbndBcnInLCBbODY2Ml1dLCBbJ253YXJyb3cnLCBbODU5OF1dLCBbJ253bmVhcicsIFsxMDUzNV1dLCBbJ09hY3V0ZScsIFsyMTFdXSwgWydvYWN1dGUnLCBbMjQzXV0sIFsnb2FzdCcsIFs4ODU5XV0sIFsnT2NpcmMnLCBbMjEyXV0sIFsnb2NpcmMnLCBbMjQ0XV0sIFsnb2NpcicsIFs4ODU4XV0sIFsnT2N5JywgWzEwNTRdXSwgWydvY3knLCBbMTA4Nl1dLCBbJ29kYXNoJywgWzg4NjFdXSwgWydPZGJsYWMnLCBbMzM2XV0sIFsnb2RibGFjJywgWzMzN11dLCBbJ29kaXYnLCBbMTA4MDhdXSwgWydvZG90JywgWzg4NTddXSwgWydvZHNvbGQnLCBbMTA2ODRdXSwgWydPRWxpZycsIFszMzhdXSwgWydvZWxpZycsIFszMzldXSwgWydvZmNpcicsIFsxMDY4N11dLCBbJ09mcicsIFsxMjAwODJdXSwgWydvZnInLCBbMTIwMTA4XV0sIFsnb2dvbicsIFs3MzFdXSwgWydPZ3JhdmUnLCBbMjEwXV0sIFsnb2dyYXZlJywgWzI0Ml1dLCBbJ29ndCcsIFsxMDY4OV1dLCBbJ29oYmFyJywgWzEwNjc3XV0sIFsnb2htJywgWzkzN11dLCBbJ29pbnQnLCBbODc1MF1dLCBbJ29sYXJyJywgWzg2MzRdXSwgWydvbGNpcicsIFsxMDY4Nl1dLCBbJ29sY3Jvc3MnLCBbMTA2ODNdXSwgWydvbGluZScsIFs4MjU0XV0sIFsnb2x0JywgWzEwNjg4XV0sIFsnT21hY3InLCBbMzMyXV0sIFsnb21hY3InLCBbMzMzXV0sIFsnT21lZ2EnLCBbOTM3XV0sIFsnb21lZ2EnLCBbOTY5XV0sIFsnT21pY3JvbicsIFs5MjddXSwgWydvbWljcm9uJywgWzk1OV1dLCBbJ29taWQnLCBbMTA2NzhdXSwgWydvbWludXMnLCBbODg1NF1dLCBbJ09vcGYnLCBbMTIwMTM0XV0sIFsnb29wZicsIFsxMjAxNjBdXSwgWydvcGFyJywgWzEwNjc5XV0sIFsnT3BlbkN1cmx5RG91YmxlUXVvdGUnLCBbODIyMF1dLCBbJ09wZW5DdXJseVF1b3RlJywgWzgyMTZdXSwgWydvcGVycCcsIFsxMDY4MV1dLCBbJ29wbHVzJywgWzg4NTNdXSwgWydvcmFycicsIFs4NjM1XV0sIFsnT3InLCBbMTA4MzZdXSwgWydvcicsIFs4NzQ0XV0sIFsnb3JkJywgWzEwODQ1XV0sIFsnb3JkZXInLCBbODUwMF1dLCBbJ29yZGVyb2YnLCBbODUwMF1dLCBbJ29yZGYnLCBbMTcwXV0sIFsnb3JkbScsIFsxODZdXSwgWydvcmlnb2YnLCBbODg4Nl1dLCBbJ29yb3InLCBbMTA4MzhdXSwgWydvcnNsb3BlJywgWzEwODM5XV0sIFsnb3J2JywgWzEwODQzXV0sIFsnb1MnLCBbOTQxNl1dLCBbJ09zY3InLCBbMTE5OTc4XV0sIFsnb3NjcicsIFs4NTAwXV0sIFsnT3NsYXNoJywgWzIxNl1dLCBbJ29zbGFzaCcsIFsyNDhdXSwgWydvc29sJywgWzg4NTZdXSwgWydPdGlsZGUnLCBbMjEzXV0sIFsnb3RpbGRlJywgWzI0NV1dLCBbJ290aW1lc2FzJywgWzEwODA2XV0sIFsnT3RpbWVzJywgWzEwODA3XV0sIFsnb3RpbWVzJywgWzg4NTVdXSwgWydPdW1sJywgWzIxNF1dLCBbJ291bWwnLCBbMjQ2XV0sIFsnb3ZiYXInLCBbOTAyMV1dLCBbJ092ZXJCYXInLCBbODI1NF1dLCBbJ092ZXJCcmFjZScsIFs5MTgyXV0sIFsnT3ZlckJyYWNrZXQnLCBbOTE0MF1dLCBbJ092ZXJQYXJlbnRoZXNpcycsIFs5MTgwXV0sIFsncGFyYScsIFsxODJdXSwgWydwYXJhbGxlbCcsIFs4NzQxXV0sIFsncGFyJywgWzg3NDFdXSwgWydwYXJzaW0nLCBbMTA5OTVdXSwgWydwYXJzbCcsIFsxMTAwNV1dLCBbJ3BhcnQnLCBbODcwNl1dLCBbJ1BhcnRpYWxEJywgWzg3MDZdXSwgWydQY3knLCBbMTA1NV1dLCBbJ3BjeScsIFsxMDg3XV0sIFsncGVyY250JywgWzM3XV0sIFsncGVyaW9kJywgWzQ2XV0sIFsncGVybWlsJywgWzgyNDBdXSwgWydwZXJwJywgWzg4NjldXSwgWydwZXJ0ZW5rJywgWzgyNDFdXSwgWydQZnInLCBbMTIwMDgzXV0sIFsncGZyJywgWzEyMDEwOV1dLCBbJ1BoaScsIFs5MzRdXSwgWydwaGknLCBbOTY2XV0sIFsncGhpdicsIFs5ODFdXSwgWydwaG1tYXQnLCBbODQ5OV1dLCBbJ3Bob25lJywgWzk3NDJdXSwgWydQaScsIFs5MjhdXSwgWydwaScsIFs5NjBdXSwgWydwaXRjaGZvcmsnLCBbODkxNl1dLCBbJ3BpdicsIFs5ODJdXSwgWydwbGFuY2snLCBbODQ2M11dLCBbJ3BsYW5ja2gnLCBbODQ2Ml1dLCBbJ3BsYW5rdicsIFs4NDYzXV0sIFsncGx1c2FjaXInLCBbMTA3ODddXSwgWydwbHVzYicsIFs4ODYyXV0sIFsncGx1c2NpcicsIFsxMDc4Nl1dLCBbJ3BsdXMnLCBbNDNdXSwgWydwbHVzZG8nLCBbODcyNF1dLCBbJ3BsdXNkdScsIFsxMDc4OV1dLCBbJ3BsdXNlJywgWzEwODY2XV0sIFsnUGx1c01pbnVzJywgWzE3N11dLCBbJ3BsdXNtbicsIFsxNzddXSwgWydwbHVzc2ltJywgWzEwNzkwXV0sIFsncGx1c3R3bycsIFsxMDc5MV1dLCBbJ3BtJywgWzE3N11dLCBbJ1BvaW5jYXJlcGxhbmUnLCBbODQ2MF1dLCBbJ3BvaW50aW50JywgWzEwNzczXV0sIFsncG9wZicsIFsxMjAxNjFdXSwgWydQb3BmJywgWzg0NzNdXSwgWydwb3VuZCcsIFsxNjNdXSwgWydwcmFwJywgWzEwOTM1XV0sIFsnUHInLCBbMTA5MzldXSwgWydwcicsIFs4ODI2XV0sIFsncHJjdWUnLCBbODgyOF1dLCBbJ3ByZWNhcHByb3gnLCBbMTA5MzVdXSwgWydwcmVjJywgWzg4MjZdXSwgWydwcmVjY3VybHllcScsIFs4ODI4XV0sIFsnUHJlY2VkZXMnLCBbODgyNl1dLCBbJ1ByZWNlZGVzRXF1YWwnLCBbMTA5MjddXSwgWydQcmVjZWRlc1NsYW50RXF1YWwnLCBbODgyOF1dLCBbJ1ByZWNlZGVzVGlsZGUnLCBbODgzMF1dLCBbJ3ByZWNlcScsIFsxMDkyN11dLCBbJ3ByZWNuYXBwcm94JywgWzEwOTM3XV0sIFsncHJlY25lcXEnLCBbMTA5MzNdXSwgWydwcmVjbnNpbScsIFs4OTM2XV0sIFsncHJlJywgWzEwOTI3XV0sIFsncHJFJywgWzEwOTMxXV0sIFsncHJlY3NpbScsIFs4ODMwXV0sIFsncHJpbWUnLCBbODI0Ml1dLCBbJ1ByaW1lJywgWzgyNDNdXSwgWydwcmltZXMnLCBbODQ3M11dLCBbJ3BybmFwJywgWzEwOTM3XV0sIFsncHJuRScsIFsxMDkzM11dLCBbJ3BybnNpbScsIFs4OTM2XV0sIFsncHJvZCcsIFs4NzE5XV0sIFsnUHJvZHVjdCcsIFs4NzE5XV0sIFsncHJvZmFsYXInLCBbOTAwNl1dLCBbJ3Byb2ZsaW5lJywgWzg5NzhdXSwgWydwcm9mc3VyZicsIFs4OTc5XV0sIFsncHJvcCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbmFsJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uJywgWzg3NTldXSwgWydwcm9wdG8nLCBbODczM11dLCBbJ3Byc2ltJywgWzg4MzBdXSwgWydwcnVyZWwnLCBbODg4MF1dLCBbJ1BzY3InLCBbMTE5OTc5XV0sIFsncHNjcicsIFsxMjAwMDVdXSwgWydQc2knLCBbOTM2XV0sIFsncHNpJywgWzk2OF1dLCBbJ3B1bmNzcCcsIFs4MjAwXV0sIFsnUWZyJywgWzEyMDA4NF1dLCBbJ3FmcicsIFsxMjAxMTBdXSwgWydxaW50JywgWzEwNzY0XV0sIFsncW9wZicsIFsxMjAxNjJdXSwgWydRb3BmJywgWzg0NzRdXSwgWydxcHJpbWUnLCBbODI3OV1dLCBbJ1FzY3InLCBbMTE5OTgwXV0sIFsncXNjcicsIFsxMjAwMDZdXSwgWydxdWF0ZXJuaW9ucycsIFs4NDYxXV0sIFsncXVhdGludCcsIFsxMDc3NF1dLCBbJ3F1ZXN0JywgWzYzXV0sIFsncXVlc3RlcScsIFs4Nzk5XV0sIFsncXVvdCcsIFszNF1dLCBbJ1FVT1QnLCBbMzRdXSwgWydyQWFycicsIFs4NjY3XV0sIFsncmFjZScsIFs4NzY1LCA4MTddXSwgWydSYWN1dGUnLCBbMzQwXV0sIFsncmFjdXRlJywgWzM0MV1dLCBbJ3JhZGljJywgWzg3MzBdXSwgWydyYWVtcHR5dicsIFsxMDY3NV1dLCBbJ3JhbmcnLCBbMTAyMTddXSwgWydSYW5nJywgWzEwMjE5XV0sIFsncmFuZ2QnLCBbMTA2NDJdXSwgWydyYW5nZScsIFsxMDY2MV1dLCBbJ3JhbmdsZScsIFsxMDIxN11dLCBbJ3JhcXVvJywgWzE4N11dLCBbJ3JhcnJhcCcsIFsxMDYxM11dLCBbJ3JhcnJiJywgWzg2NzddXSwgWydyYXJyYmZzJywgWzEwNTI4XV0sIFsncmFycmMnLCBbMTA1NDddXSwgWydyYXJyJywgWzg1OTRdXSwgWydSYXJyJywgWzg2MDhdXSwgWydyQXJyJywgWzg2NThdXSwgWydyYXJyZnMnLCBbMTA1MjZdXSwgWydyYXJyaGsnLCBbODYxOF1dLCBbJ3JhcnJscCcsIFs4NjIwXV0sIFsncmFycnBsJywgWzEwNTY1XV0sIFsncmFycnNpbScsIFsxMDYxMl1dLCBbJ1JhcnJ0bCcsIFsxMDUxOF1dLCBbJ3JhcnJ0bCcsIFs4NjExXV0sIFsncmFycncnLCBbODYwNV1dLCBbJ3JhdGFpbCcsIFsxMDUyMl1dLCBbJ3JBdGFpbCcsIFsxMDUyNF1dLCBbJ3JhdGlvJywgWzg3NThdXSwgWydyYXRpb25hbHMnLCBbODQ3NF1dLCBbJ3JiYXJyJywgWzEwNTA5XV0sIFsnckJhcnInLCBbMTA1MTFdXSwgWydSQmFycicsIFsxMDUxMl1dLCBbJ3JiYnJrJywgWzEwMDk5XV0sIFsncmJyYWNlJywgWzEyNV1dLCBbJ3JicmFjaycsIFs5M11dLCBbJ3JicmtlJywgWzEwNjM2XV0sIFsncmJya3NsZCcsIFsxMDYzOF1dLCBbJ3JicmtzbHUnLCBbMTA2NDBdXSwgWydSY2Fyb24nLCBbMzQ0XV0sIFsncmNhcm9uJywgWzM0NV1dLCBbJ1JjZWRpbCcsIFszNDJdXSwgWydyY2VkaWwnLCBbMzQzXV0sIFsncmNlaWwnLCBbODk2OV1dLCBbJ3JjdWInLCBbMTI1XV0sIFsnUmN5JywgWzEwNTZdXSwgWydyY3knLCBbMTA4OF1dLCBbJ3JkY2EnLCBbMTA1NTFdXSwgWydyZGxkaGFyJywgWzEwNjAxXV0sIFsncmRxdW8nLCBbODIyMV1dLCBbJ3JkcXVvcicsIFs4MjIxXV0sIFsnQ2xvc2VDdXJseURvdWJsZVF1b3RlJywgWzgyMjFdXSwgWydyZHNoJywgWzg2MjddXSwgWydyZWFsJywgWzg0NzZdXSwgWydyZWFsaW5lJywgWzg0NzVdXSwgWydyZWFscGFydCcsIFs4NDc2XV0sIFsncmVhbHMnLCBbODQ3N11dLCBbJ1JlJywgWzg0NzZdXSwgWydyZWN0JywgWzk2NDVdXSwgWydyZWcnLCBbMTc0XV0sIFsnUkVHJywgWzE3NF1dLCBbJ1JldmVyc2VFbGVtZW50JywgWzg3MTVdXSwgWydSZXZlcnNlRXF1aWxpYnJpdW0nLCBbODY1MV1dLCBbJ1JldmVyc2VVcEVxdWlsaWJyaXVtJywgWzEwNjA3XV0sIFsncmZpc2h0JywgWzEwNjIxXV0sIFsncmZsb29yJywgWzg5NzFdXSwgWydyZnInLCBbMTIwMTExXV0sIFsnUmZyJywgWzg0NzZdXSwgWydySGFyJywgWzEwNTk2XV0sIFsncmhhcmQnLCBbODY0MV1dLCBbJ3JoYXJ1JywgWzg2NDBdXSwgWydyaGFydWwnLCBbMTA2MDRdXSwgWydSaG8nLCBbOTI5XV0sIFsncmhvJywgWzk2MV1dLCBbJ3Job3YnLCBbMTAwOV1dLCBbJ1JpZ2h0QW5nbGVCcmFja2V0JywgWzEwMjE3XV0sIFsnUmlnaHRBcnJvd0JhcicsIFs4Njc3XV0sIFsncmlnaHRhcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRhcnJvdycsIFs4NjU4XV0sIFsnUmlnaHRBcnJvd0xlZnRBcnJvdycsIFs4NjQ0XV0sIFsncmlnaHRhcnJvd3RhaWwnLCBbODYxMV1dLCBbJ1JpZ2h0Q2VpbGluZycsIFs4OTY5XV0sIFsnUmlnaHREb3VibGVCcmFja2V0JywgWzEwMjE1XV0sIFsnUmlnaHREb3duVGVlVmVjdG9yJywgWzEwNTg5XV0sIFsnUmlnaHREb3duVmVjdG9yQmFyJywgWzEwNTgxXV0sIFsnUmlnaHREb3duVmVjdG9yJywgWzg2NDJdXSwgWydSaWdodEZsb29yJywgWzg5NzFdXSwgWydyaWdodGhhcnBvb25kb3duJywgWzg2NDFdXSwgWydyaWdodGhhcnBvb251cCcsIFs4NjQwXV0sIFsncmlnaHRsZWZ0YXJyb3dzJywgWzg2NDRdXSwgWydyaWdodGxlZnRoYXJwb29ucycsIFs4NjUyXV0sIFsncmlnaHRyaWdodGFycm93cycsIFs4NjQ5XV0sIFsncmlnaHRzcXVpZ2Fycm93JywgWzg2MDVdXSwgWydSaWdodFRlZUFycm93JywgWzg2MTRdXSwgWydSaWdodFRlZScsIFs4ODY2XV0sIFsnUmlnaHRUZWVWZWN0b3InLCBbMTA1ODddXSwgWydyaWdodHRocmVldGltZXMnLCBbODkwOF1dLCBbJ1JpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDRdXSwgWydSaWdodFRyaWFuZ2xlJywgWzg4ODNdXSwgWydSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODg4NV1dLCBbJ1JpZ2h0VXBEb3duVmVjdG9yJywgWzEwNTc1XV0sIFsnUmlnaHRVcFRlZVZlY3RvcicsIFsxMDU4OF1dLCBbJ1JpZ2h0VXBWZWN0b3JCYXInLCBbMTA1ODBdXSwgWydSaWdodFVwVmVjdG9yJywgWzg2MzhdXSwgWydSaWdodFZlY3RvckJhcicsIFsxMDU3OV1dLCBbJ1JpZ2h0VmVjdG9yJywgWzg2NDBdXSwgWydyaW5nJywgWzczMF1dLCBbJ3Jpc2luZ2RvdHNlcScsIFs4Nzg3XV0sIFsncmxhcnInLCBbODY0NF1dLCBbJ3JsaGFyJywgWzg2NTJdXSwgWydybG0nLCBbODIwN11dLCBbJ3Jtb3VzdGFjaGUnLCBbOTEzN11dLCBbJ3Jtb3VzdCcsIFs5MTM3XV0sIFsncm5taWQnLCBbMTA5OTBdXSwgWydyb2FuZycsIFsxMDIyMV1dLCBbJ3JvYXJyJywgWzg3MDJdXSwgWydyb2JyaycsIFsxMDIxNV1dLCBbJ3JvcGFyJywgWzEwNjMwXV0sIFsncm9wZicsIFsxMjAxNjNdXSwgWydSb3BmJywgWzg0NzddXSwgWydyb3BsdXMnLCBbMTA3OThdXSwgWydyb3RpbWVzJywgWzEwODA1XV0sIFsnUm91bmRJbXBsaWVzJywgWzEwNjA4XV0sIFsncnBhcicsIFs0MV1dLCBbJ3JwYXJndCcsIFsxMDY0NF1dLCBbJ3JwcG9saW50JywgWzEwNzcwXV0sIFsncnJhcnInLCBbODY0OV1dLCBbJ1JyaWdodGFycm93JywgWzg2NjddXSwgWydyc2FxdW8nLCBbODI1MF1dLCBbJ3JzY3InLCBbMTIwMDA3XV0sIFsnUnNjcicsIFs4NDc1XV0sIFsncnNoJywgWzg2MjVdXSwgWydSc2gnLCBbODYyNV1dLCBbJ3JzcWInLCBbOTNdXSwgWydyc3F1bycsIFs4MjE3XV0sIFsncnNxdW9yJywgWzgyMTddXSwgWydDbG9zZUN1cmx5UXVvdGUnLCBbODIxN11dLCBbJ3J0aHJlZScsIFs4OTA4XV0sIFsncnRpbWVzJywgWzg5MDZdXSwgWydydHJpJywgWzk2NTddXSwgWydydHJpZScsIFs4ODg1XV0sIFsncnRyaWYnLCBbOTY1Nl1dLCBbJ3J0cmlsdHJpJywgWzEwNzAyXV0sIFsnUnVsZURlbGF5ZWQnLCBbMTA3NDBdXSwgWydydWx1aGFyJywgWzEwNjAwXV0sIFsncngnLCBbODQ3OF1dLCBbJ1NhY3V0ZScsIFszNDZdXSwgWydzYWN1dGUnLCBbMzQ3XV0sIFsnc2JxdW8nLCBbODIxOF1dLCBbJ3NjYXAnLCBbMTA5MzZdXSwgWydTY2Fyb24nLCBbMzUyXV0sIFsnc2Nhcm9uJywgWzM1M11dLCBbJ1NjJywgWzEwOTQwXV0sIFsnc2MnLCBbODgyN11dLCBbJ3NjY3VlJywgWzg4MjldXSwgWydzY2UnLCBbMTA5MjhdXSwgWydzY0UnLCBbMTA5MzJdXSwgWydTY2VkaWwnLCBbMzUwXV0sIFsnc2NlZGlsJywgWzM1MV1dLCBbJ1NjaXJjJywgWzM0OF1dLCBbJ3NjaXJjJywgWzM0OV1dLCBbJ3NjbmFwJywgWzEwOTM4XV0sIFsnc2NuRScsIFsxMDkzNF1dLCBbJ3NjbnNpbScsIFs4OTM3XV0sIFsnc2Nwb2xpbnQnLCBbMTA3NzFdXSwgWydzY3NpbScsIFs4ODMxXV0sIFsnU2N5JywgWzEwNTddXSwgWydzY3knLCBbMTA4OV1dLCBbJ3Nkb3RiJywgWzg4NjVdXSwgWydzZG90JywgWzg5MDFdXSwgWydzZG90ZScsIFsxMDg1NF1dLCBbJ3NlYXJoaycsIFsxMDUzM11dLCBbJ3NlYXJyJywgWzg2MDBdXSwgWydzZUFycicsIFs4NjY0XV0sIFsnc2VhcnJvdycsIFs4NjAwXV0sIFsnc2VjdCcsIFsxNjddXSwgWydzZW1pJywgWzU5XV0sIFsnc2Vzd2FyJywgWzEwNTM3XV0sIFsnc2V0bWludXMnLCBbODcyNl1dLCBbJ3NldG1uJywgWzg3MjZdXSwgWydzZXh0JywgWzEwMDM4XV0sIFsnU2ZyJywgWzEyMDA4Nl1dLCBbJ3NmcicsIFsxMjAxMTJdXSwgWydzZnJvd24nLCBbODk5NF1dLCBbJ3NoYXJwJywgWzk4MzldXSwgWydTSENIY3knLCBbMTA2NV1dLCBbJ3NoY2hjeScsIFsxMDk3XV0sIFsnU0hjeScsIFsxMDY0XV0sIFsnc2hjeScsIFsxMDk2XV0sIFsnU2hvcnREb3duQXJyb3cnLCBbODU5NV1dLCBbJ1Nob3J0TGVmdEFycm93JywgWzg1OTJdXSwgWydzaG9ydG1pZCcsIFs4NzM5XV0sIFsnc2hvcnRwYXJhbGxlbCcsIFs4NzQxXV0sIFsnU2hvcnRSaWdodEFycm93JywgWzg1OTRdXSwgWydTaG9ydFVwQXJyb3cnLCBbODU5M11dLCBbJ3NoeScsIFsxNzNdXSwgWydTaWdtYScsIFs5MzFdXSwgWydzaWdtYScsIFs5NjNdXSwgWydzaWdtYWYnLCBbOTYyXV0sIFsnc2lnbWF2JywgWzk2Ml1dLCBbJ3NpbScsIFs4NzY0XV0sIFsnc2ltZG90JywgWzEwODU4XV0sIFsnc2ltZScsIFs4NzcxXV0sIFsnc2ltZXEnLCBbODc3MV1dLCBbJ3NpbWcnLCBbMTA5MTBdXSwgWydzaW1nRScsIFsxMDkxMl1dLCBbJ3NpbWwnLCBbMTA5MDldXSwgWydzaW1sRScsIFsxMDkxMV1dLCBbJ3NpbW5lJywgWzg3NzRdXSwgWydzaW1wbHVzJywgWzEwNzg4XV0sIFsnc2ltcmFycicsIFsxMDYxMF1dLCBbJ3NsYXJyJywgWzg1OTJdXSwgWydTbWFsbENpcmNsZScsIFs4NzI4XV0sIFsnc21hbGxzZXRtaW51cycsIFs4NzI2XV0sIFsnc21hc2hwJywgWzEwODAzXV0sIFsnc21lcGFyc2wnLCBbMTA3MjRdXSwgWydzbWlkJywgWzg3MzldXSwgWydzbWlsZScsIFs4OTk1XV0sIFsnc210JywgWzEwOTIyXV0sIFsnc210ZScsIFsxMDkyNF1dLCBbJ3NtdGVzJywgWzEwOTI0LCA2NTAyNF1dLCBbJ1NPRlRjeScsIFsxMDY4XV0sIFsnc29mdGN5JywgWzExMDBdXSwgWydzb2xiYXInLCBbOTAyM11dLCBbJ3NvbGInLCBbMTA2OTJdXSwgWydzb2wnLCBbNDddXSwgWydTb3BmJywgWzEyMDEzOF1dLCBbJ3NvcGYnLCBbMTIwMTY0XV0sIFsnc3BhZGVzJywgWzk4MjRdXSwgWydzcGFkZXN1aXQnLCBbOTgyNF1dLCBbJ3NwYXInLCBbODc0MV1dLCBbJ3NxY2FwJywgWzg4NTFdXSwgWydzcWNhcHMnLCBbODg1MSwgNjUwMjRdXSwgWydzcWN1cCcsIFs4ODUyXV0sIFsnc3FjdXBzJywgWzg4NTIsIDY1MDI0XV0sIFsnU3FydCcsIFs4NzMwXV0sIFsnc3FzdWInLCBbODg0N11dLCBbJ3Nxc3ViZScsIFs4ODQ5XV0sIFsnc3FzdWJzZXQnLCBbODg0N11dLCBbJ3Nxc3Vic2V0ZXEnLCBbODg0OV1dLCBbJ3Nxc3VwJywgWzg4NDhdXSwgWydzcXN1cGUnLCBbODg1MF1dLCBbJ3Nxc3Vwc2V0JywgWzg4NDhdXSwgWydzcXN1cHNldGVxJywgWzg4NTBdXSwgWydzcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlSW50ZXJzZWN0aW9uJywgWzg4NTFdXSwgWydTcXVhcmVTdWJzZXQnLCBbODg0N11dLCBbJ1NxdWFyZVN1YnNldEVxdWFsJywgWzg4NDldXSwgWydTcXVhcmVTdXBlcnNldCcsIFs4ODQ4XV0sIFsnU3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4ODUwXV0sIFsnU3F1YXJlVW5pb24nLCBbODg1Ml1dLCBbJ3NxdWFyZicsIFs5NjQyXV0sIFsnc3F1JywgWzk2MzNdXSwgWydzcXVmJywgWzk2NDJdXSwgWydzcmFycicsIFs4NTk0XV0sIFsnU3NjcicsIFsxMTk5ODJdXSwgWydzc2NyJywgWzEyMDAwOF1dLCBbJ3NzZXRtbicsIFs4NzI2XV0sIFsnc3NtaWxlJywgWzg5OTVdXSwgWydzc3RhcmYnLCBbODkwMl1dLCBbJ1N0YXInLCBbODkwMl1dLCBbJ3N0YXInLCBbOTczNF1dLCBbJ3N0YXJmJywgWzk3MzNdXSwgWydzdHJhaWdodGVwc2lsb24nLCBbMTAxM11dLCBbJ3N0cmFpZ2h0cGhpJywgWzk4MV1dLCBbJ3N0cm5zJywgWzE3NV1dLCBbJ3N1YicsIFs4ODM0XV0sIFsnU3ViJywgWzg5MTJdXSwgWydzdWJkb3QnLCBbMTA5NDFdXSwgWydzdWJFJywgWzEwOTQ5XV0sIFsnc3ViZScsIFs4ODM4XV0sIFsnc3ViZWRvdCcsIFsxMDk0N11dLCBbJ3N1Ym11bHQnLCBbMTA5NDVdXSwgWydzdWJuRScsIFsxMDk1NV1dLCBbJ3N1Ym5lJywgWzg4NDJdXSwgWydzdWJwbHVzJywgWzEwOTQzXV0sIFsnc3VicmFycicsIFsxMDYxN11dLCBbJ3N1YnNldCcsIFs4ODM0XV0sIFsnU3Vic2V0JywgWzg5MTJdXSwgWydzdWJzZXRlcScsIFs4ODM4XV0sIFsnc3Vic2V0ZXFxJywgWzEwOTQ5XV0sIFsnU3Vic2V0RXF1YWwnLCBbODgzOF1dLCBbJ3N1YnNldG5lcScsIFs4ODQyXV0sIFsnc3Vic2V0bmVxcScsIFsxMDk1NV1dLCBbJ3N1YnNpbScsIFsxMDk1MV1dLCBbJ3N1YnN1YicsIFsxMDk2NV1dLCBbJ3N1YnN1cCcsIFsxMDk2M11dLCBbJ3N1Y2NhcHByb3gnLCBbMTA5MzZdXSwgWydzdWNjJywgWzg4MjddXSwgWydzdWNjY3VybHllcScsIFs4ODI5XV0sIFsnU3VjY2VlZHMnLCBbODgyN11dLCBbJ1N1Y2NlZWRzRXF1YWwnLCBbMTA5MjhdXSwgWydTdWNjZWVkc1NsYW50RXF1YWwnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzVGlsZGUnLCBbODgzMV1dLCBbJ3N1Y2NlcScsIFsxMDkyOF1dLCBbJ3N1Y2NuYXBwcm94JywgWzEwOTM4XV0sIFsnc3VjY25lcXEnLCBbMTA5MzRdXSwgWydzdWNjbnNpbScsIFs4OTM3XV0sIFsnc3VjY3NpbScsIFs4ODMxXV0sIFsnU3VjaFRoYXQnLCBbODcxNV1dLCBbJ3N1bScsIFs4NzIxXV0sIFsnU3VtJywgWzg3MjFdXSwgWydzdW5nJywgWzk4MzRdXSwgWydzdXAxJywgWzE4NV1dLCBbJ3N1cDInLCBbMTc4XV0sIFsnc3VwMycsIFsxNzldXSwgWydzdXAnLCBbODgzNV1dLCBbJ1N1cCcsIFs4OTEzXV0sIFsnc3VwZG90JywgWzEwOTQyXV0sIFsnc3VwZHN1YicsIFsxMDk2OF1dLCBbJ3N1cEUnLCBbMTA5NTBdXSwgWydzdXBlJywgWzg4MzldXSwgWydzdXBlZG90JywgWzEwOTQ4XV0sIFsnU3VwZXJzZXQnLCBbODgzNV1dLCBbJ1N1cGVyc2V0RXF1YWwnLCBbODgzOV1dLCBbJ3N1cGhzb2wnLCBbMTAxODVdXSwgWydzdXBoc3ViJywgWzEwOTY3XV0sIFsnc3VwbGFycicsIFsxMDYxOV1dLCBbJ3N1cG11bHQnLCBbMTA5NDZdXSwgWydzdXBuRScsIFsxMDk1Nl1dLCBbJ3N1cG5lJywgWzg4NDNdXSwgWydzdXBwbHVzJywgWzEwOTQ0XV0sIFsnc3Vwc2V0JywgWzg4MzVdXSwgWydTdXBzZXQnLCBbODkxM11dLCBbJ3N1cHNldGVxJywgWzg4MzldXSwgWydzdXBzZXRlcXEnLCBbMTA5NTBdXSwgWydzdXBzZXRuZXEnLCBbODg0M11dLCBbJ3N1cHNldG5lcXEnLCBbMTA5NTZdXSwgWydzdXBzaW0nLCBbMTA5NTJdXSwgWydzdXBzdWInLCBbMTA5NjRdXSwgWydzdXBzdXAnLCBbMTA5NjZdXSwgWydzd2FyaGsnLCBbMTA1MzRdXSwgWydzd2FycicsIFs4NjAxXV0sIFsnc3dBcnInLCBbODY2NV1dLCBbJ3N3YXJyb3cnLCBbODYwMV1dLCBbJ3N3bndhcicsIFsxMDUzOF1dLCBbJ3N6bGlnJywgWzIyM11dLCBbJ1RhYicsIFs5XV0sIFsndGFyZ2V0JywgWzg5ODJdXSwgWydUYXUnLCBbOTMyXV0sIFsndGF1JywgWzk2NF1dLCBbJ3RicmsnLCBbOTE0MF1dLCBbJ1RjYXJvbicsIFszNTZdXSwgWyd0Y2Fyb24nLCBbMzU3XV0sIFsnVGNlZGlsJywgWzM1NF1dLCBbJ3RjZWRpbCcsIFszNTVdXSwgWydUY3knLCBbMTA1OF1dLCBbJ3RjeScsIFsxMDkwXV0sIFsndGRvdCcsIFs4NDExXV0sIFsndGVscmVjJywgWzg5ODFdXSwgWydUZnInLCBbMTIwMDg3XV0sIFsndGZyJywgWzEyMDExM11dLCBbJ3RoZXJlNCcsIFs4NzU2XV0sIFsndGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXRhJywgWzkyMF1dLCBbJ3RoZXRhJywgWzk1Ml1dLCBbJ3RoZXRhc3ltJywgWzk3N11dLCBbJ3RoZXRhdicsIFs5NzddXSwgWyd0aGlja2FwcHJveCcsIFs4Nzc2XV0sIFsndGhpY2tzaW0nLCBbODc2NF1dLCBbJ1RoaWNrU3BhY2UnLCBbODI4NywgODIwMl1dLCBbJ1RoaW5TcGFjZScsIFs4MjAxXV0sIFsndGhpbnNwJywgWzgyMDFdXSwgWyd0aGthcCcsIFs4Nzc2XV0sIFsndGhrc2ltJywgWzg3NjRdXSwgWydUSE9STicsIFsyMjJdXSwgWyd0aG9ybicsIFsyNTRdXSwgWyd0aWxkZScsIFs3MzJdXSwgWydUaWxkZScsIFs4NzY0XV0sIFsnVGlsZGVFcXVhbCcsIFs4NzcxXV0sIFsnVGlsZGVGdWxsRXF1YWwnLCBbODc3M11dLCBbJ1RpbGRlVGlsZGUnLCBbODc3Nl1dLCBbJ3RpbWVzYmFyJywgWzEwODAxXV0sIFsndGltZXNiJywgWzg4NjRdXSwgWyd0aW1lcycsIFsyMTVdXSwgWyd0aW1lc2QnLCBbMTA4MDBdXSwgWyd0aW50JywgWzg3NDldXSwgWyd0b2VhJywgWzEwNTM2XV0sIFsndG9wYm90JywgWzkwMTRdXSwgWyd0b3BjaXInLCBbMTA5OTNdXSwgWyd0b3AnLCBbODg2OF1dLCBbJ1RvcGYnLCBbMTIwMTM5XV0sIFsndG9wZicsIFsxMjAxNjVdXSwgWyd0b3Bmb3JrJywgWzEwOTcwXV0sIFsndG9zYScsIFsxMDUzN11dLCBbJ3RwcmltZScsIFs4MjQ0XV0sIFsndHJhZGUnLCBbODQ4Ml1dLCBbJ1RSQURFJywgWzg0ODJdXSwgWyd0cmlhbmdsZScsIFs5NjUzXV0sIFsndHJpYW5nbGVkb3duJywgWzk2NjNdXSwgWyd0cmlhbmdsZWxlZnQnLCBbOTY2N11dLCBbJ3RyaWFuZ2xlbGVmdGVxJywgWzg4ODRdXSwgWyd0cmlhbmdsZXEnLCBbODc5Nl1dLCBbJ3RyaWFuZ2xlcmlnaHQnLCBbOTY1N11dLCBbJ3RyaWFuZ2xlcmlnaHRlcScsIFs4ODg1XV0sIFsndHJpZG90JywgWzk3MDhdXSwgWyd0cmllJywgWzg3OTZdXSwgWyd0cmltaW51cycsIFsxMDgxMF1dLCBbJ1RyaXBsZURvdCcsIFs4NDExXV0sIFsndHJpcGx1cycsIFsxMDgwOV1dLCBbJ3RyaXNiJywgWzEwNzAxXV0sIFsndHJpdGltZScsIFsxMDgxMV1dLCBbJ3RycGV6aXVtJywgWzkxODZdXSwgWydUc2NyJywgWzExOTk4M11dLCBbJ3RzY3InLCBbMTIwMDA5XV0sIFsnVFNjeScsIFsxMDYyXV0sIFsndHNjeScsIFsxMDk0XV0sIFsnVFNIY3knLCBbMTAzNV1dLCBbJ3RzaGN5JywgWzExMTVdXSwgWydUc3Ryb2snLCBbMzU4XV0sIFsndHN0cm9rJywgWzM1OV1dLCBbJ3R3aXh0JywgWzg4MTJdXSwgWyd0d29oZWFkbGVmdGFycm93JywgWzg2MDZdXSwgWyd0d29oZWFkcmlnaHRhcnJvdycsIFs4NjA4XV0sIFsnVWFjdXRlJywgWzIxOF1dLCBbJ3VhY3V0ZScsIFsyNTBdXSwgWyd1YXJyJywgWzg1OTNdXSwgWydVYXJyJywgWzg2MDddXSwgWyd1QXJyJywgWzg2NTddXSwgWydVYXJyb2NpcicsIFsxMDU2OV1dLCBbJ1VicmN5JywgWzEwMzhdXSwgWyd1YnJjeScsIFsxMTE4XV0sIFsnVWJyZXZlJywgWzM2NF1dLCBbJ3VicmV2ZScsIFszNjVdXSwgWydVY2lyYycsIFsyMTldXSwgWyd1Y2lyYycsIFsyNTFdXSwgWydVY3knLCBbMTA1OV1dLCBbJ3VjeScsIFsxMDkxXV0sIFsndWRhcnInLCBbODY0NV1dLCBbJ1VkYmxhYycsIFszNjhdXSwgWyd1ZGJsYWMnLCBbMzY5XV0sIFsndWRoYXInLCBbMTA2MDZdXSwgWyd1ZmlzaHQnLCBbMTA2MjJdXSwgWydVZnInLCBbMTIwMDg4XV0sIFsndWZyJywgWzEyMDExNF1dLCBbJ1VncmF2ZScsIFsyMTddXSwgWyd1Z3JhdmUnLCBbMjQ5XV0sIFsndUhhcicsIFsxMDU5NV1dLCBbJ3VoYXJsJywgWzg2MzldXSwgWyd1aGFycicsIFs4NjM4XV0sIFsndWhibGsnLCBbOTYwMF1dLCBbJ3VsY29ybicsIFs4OTg4XV0sIFsndWxjb3JuZXInLCBbODk4OF1dLCBbJ3VsY3JvcCcsIFs4OTc1XV0sIFsndWx0cmknLCBbOTcyMF1dLCBbJ1VtYWNyJywgWzM2Ml1dLCBbJ3VtYWNyJywgWzM2M11dLCBbJ3VtbCcsIFsxNjhdXSwgWydVbmRlckJhcicsIFs5NV1dLCBbJ1VuZGVyQnJhY2UnLCBbOTE4M11dLCBbJ1VuZGVyQnJhY2tldCcsIFs5MTQxXV0sIFsnVW5kZXJQYXJlbnRoZXNpcycsIFs5MTgxXV0sIFsnVW5pb24nLCBbODg5OV1dLCBbJ1VuaW9uUGx1cycsIFs4ODQ2XV0sIFsnVW9nb24nLCBbMzcwXV0sIFsndW9nb24nLCBbMzcxXV0sIFsnVW9wZicsIFsxMjAxNDBdXSwgWyd1b3BmJywgWzEyMDE2Nl1dLCBbJ1VwQXJyb3dCYXInLCBbMTA1MTRdXSwgWyd1cGFycm93JywgWzg1OTNdXSwgWydVcEFycm93JywgWzg1OTNdXSwgWydVcGFycm93JywgWzg2NTddXSwgWydVcEFycm93RG93bkFycm93JywgWzg2NDVdXSwgWyd1cGRvd25hcnJvdycsIFs4NTk3XV0sIFsnVXBEb3duQXJyb3cnLCBbODU5N11dLCBbJ1VwZG93bmFycm93JywgWzg2NjFdXSwgWydVcEVxdWlsaWJyaXVtJywgWzEwNjA2XV0sIFsndXBoYXJwb29ubGVmdCcsIFs4NjM5XV0sIFsndXBoYXJwb29ucmlnaHQnLCBbODYzOF1dLCBbJ3VwbHVzJywgWzg4NDZdXSwgWydVcHBlckxlZnRBcnJvdycsIFs4NTk4XV0sIFsnVXBwZXJSaWdodEFycm93JywgWzg1OTldXSwgWyd1cHNpJywgWzk2NV1dLCBbJ1Vwc2knLCBbOTc4XV0sIFsndXBzaWgnLCBbOTc4XV0sIFsnVXBzaWxvbicsIFs5MzNdXSwgWyd1cHNpbG9uJywgWzk2NV1dLCBbJ1VwVGVlQXJyb3cnLCBbODYxM11dLCBbJ1VwVGVlJywgWzg4NjldXSwgWyd1cHVwYXJyb3dzJywgWzg2NDhdXSwgWyd1cmNvcm4nLCBbODk4OV1dLCBbJ3VyY29ybmVyJywgWzg5ODldXSwgWyd1cmNyb3AnLCBbODk3NF1dLCBbJ1VyaW5nJywgWzM2Nl1dLCBbJ3VyaW5nJywgWzM2N11dLCBbJ3VydHJpJywgWzk3MjFdXSwgWydVc2NyJywgWzExOTk4NF1dLCBbJ3VzY3InLCBbMTIwMDEwXV0sIFsndXRkb3QnLCBbODk0NF1dLCBbJ1V0aWxkZScsIFszNjBdXSwgWyd1dGlsZGUnLCBbMzYxXV0sIFsndXRyaScsIFs5NjUzXV0sIFsndXRyaWYnLCBbOTY1Ml1dLCBbJ3V1YXJyJywgWzg2NDhdXSwgWydVdW1sJywgWzIyMF1dLCBbJ3V1bWwnLCBbMjUyXV0sIFsndXdhbmdsZScsIFsxMDY2M11dLCBbJ3ZhbmdydCcsIFsxMDY1Ml1dLCBbJ3ZhcmVwc2lsb24nLCBbMTAxM11dLCBbJ3ZhcmthcHBhJywgWzEwMDhdXSwgWyd2YXJub3RoaW5nJywgWzg3MDldXSwgWyd2YXJwaGknLCBbOTgxXV0sIFsndmFycGknLCBbOTgyXV0sIFsndmFycHJvcHRvJywgWzg3MzNdXSwgWyd2YXJyJywgWzg1OTddXSwgWyd2QXJyJywgWzg2NjFdXSwgWyd2YXJyaG8nLCBbMTAwOV1dLCBbJ3ZhcnNpZ21hJywgWzk2Ml1dLCBbJ3ZhcnN1YnNldG5lcScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZhcnN1YnNldG5lcXEnLCBbMTA5NTUsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxJywgWzg4NDMsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxcScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2YXJ0aGV0YScsIFs5NzddXSwgWyd2YXJ0cmlhbmdsZWxlZnQnLCBbODg4Ml1dLCBbJ3ZhcnRyaWFuZ2xlcmlnaHQnLCBbODg4M11dLCBbJ3ZCYXInLCBbMTA5ODRdXSwgWydWYmFyJywgWzEwOTg3XV0sIFsndkJhcnYnLCBbMTA5ODVdXSwgWydWY3knLCBbMTA0Ml1dLCBbJ3ZjeScsIFsxMDc0XV0sIFsndmRhc2gnLCBbODg2Nl1dLCBbJ3ZEYXNoJywgWzg4NzJdXSwgWydWZGFzaCcsIFs4ODczXV0sIFsnVkRhc2gnLCBbODg3NV1dLCBbJ1ZkYXNobCcsIFsxMDk4Ml1dLCBbJ3ZlZWJhcicsIFs4ODkxXV0sIFsndmVlJywgWzg3NDRdXSwgWydWZWUnLCBbODg5N11dLCBbJ3ZlZWVxJywgWzg3OTRdXSwgWyd2ZWxsaXAnLCBbODk0Ml1dLCBbJ3ZlcmJhcicsIFsxMjRdXSwgWydWZXJiYXInLCBbODIxNF1dLCBbJ3ZlcnQnLCBbMTI0XV0sIFsnVmVydCcsIFs4MjE0XV0sIFsnVmVydGljYWxCYXInLCBbODczOV1dLCBbJ1ZlcnRpY2FsTGluZScsIFsxMjRdXSwgWydWZXJ0aWNhbFNlcGFyYXRvcicsIFsxMDA3Ml1dLCBbJ1ZlcnRpY2FsVGlsZGUnLCBbODc2OF1dLCBbJ1ZlcnlUaGluU3BhY2UnLCBbODIwMl1dLCBbJ1ZmcicsIFsxMjAwODldXSwgWyd2ZnInLCBbMTIwMTE1XV0sIFsndmx0cmknLCBbODg4Ml1dLCBbJ3Zuc3ViJywgWzg4MzQsIDg0MDJdXSwgWyd2bnN1cCcsIFs4ODM1LCA4NDAyXV0sIFsnVm9wZicsIFsxMjAxNDFdXSwgWyd2b3BmJywgWzEyMDE2N11dLCBbJ3Zwcm9wJywgWzg3MzNdXSwgWyd2cnRyaScsIFs4ODgzXV0sIFsnVnNjcicsIFsxMTk5ODVdXSwgWyd2c2NyJywgWzEyMDAxMV1dLCBbJ3ZzdWJuRScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2c3VibmUnLCBbODg0MiwgNjUwMjRdXSwgWyd2c3VwbkUnLCBbMTA5NTYsIDY1MDI0XV0sIFsndnN1cG5lJywgWzg4NDMsIDY1MDI0XV0sIFsnVnZkYXNoJywgWzg4NzRdXSwgWyd2emlnemFnJywgWzEwNjUwXV0sIFsnV2NpcmMnLCBbMzcyXV0sIFsnd2NpcmMnLCBbMzczXV0sIFsnd2VkYmFyJywgWzEwODQ3XV0sIFsnd2VkZ2UnLCBbODc0M11dLCBbJ1dlZGdlJywgWzg4OTZdXSwgWyd3ZWRnZXEnLCBbODc5M11dLCBbJ3dlaWVycCcsIFs4NDcyXV0sIFsnV2ZyJywgWzEyMDA5MF1dLCBbJ3dmcicsIFsxMjAxMTZdXSwgWydXb3BmJywgWzEyMDE0Ml1dLCBbJ3dvcGYnLCBbMTIwMTY4XV0sIFsnd3AnLCBbODQ3Ml1dLCBbJ3dyJywgWzg3NjhdXSwgWyd3cmVhdGgnLCBbODc2OF1dLCBbJ1dzY3InLCBbMTE5OTg2XV0sIFsnd3NjcicsIFsxMjAwMTJdXSwgWyd4Y2FwJywgWzg4OThdXSwgWyd4Y2lyYycsIFs5NzExXV0sIFsneGN1cCcsIFs4ODk5XV0sIFsneGR0cmknLCBbOTY2MV1dLCBbJ1hmcicsIFsxMjAwOTFdXSwgWyd4ZnInLCBbMTIwMTE3XV0sIFsneGhhcnInLCBbMTAyMzFdXSwgWyd4aEFycicsIFsxMDIzNF1dLCBbJ1hpJywgWzkyNl1dLCBbJ3hpJywgWzk1OF1dLCBbJ3hsYXJyJywgWzEwMjI5XV0sIFsneGxBcnInLCBbMTAyMzJdXSwgWyd4bWFwJywgWzEwMjM2XV0sIFsneG5pcycsIFs4OTU1XV0sIFsneG9kb3QnLCBbMTA3NTJdXSwgWydYb3BmJywgWzEyMDE0M11dLCBbJ3hvcGYnLCBbMTIwMTY5XV0sIFsneG9wbHVzJywgWzEwNzUzXV0sIFsneG90aW1lJywgWzEwNzU0XV0sIFsneHJhcnInLCBbMTAyMzBdXSwgWyd4ckFycicsIFsxMDIzM11dLCBbJ1hzY3InLCBbMTE5OTg3XV0sIFsneHNjcicsIFsxMjAwMTNdXSwgWyd4c3FjdXAnLCBbMTA3NThdXSwgWyd4dXBsdXMnLCBbMTA3NTZdXSwgWyd4dXRyaScsIFs5NjUxXV0sIFsneHZlZScsIFs4ODk3XV0sIFsneHdlZGdlJywgWzg4OTZdXSwgWydZYWN1dGUnLCBbMjIxXV0sIFsneWFjdXRlJywgWzI1M11dLCBbJ1lBY3knLCBbMTA3MV1dLCBbJ3lhY3knLCBbMTEwM11dLCBbJ1ljaXJjJywgWzM3NF1dLCBbJ3ljaXJjJywgWzM3NV1dLCBbJ1ljeScsIFsxMDY3XV0sIFsneWN5JywgWzEwOTldXSwgWyd5ZW4nLCBbMTY1XV0sIFsnWWZyJywgWzEyMDA5Ml1dLCBbJ3lmcicsIFsxMjAxMThdXSwgWydZSWN5JywgWzEwMzFdXSwgWyd5aWN5JywgWzExMTFdXSwgWydZb3BmJywgWzEyMDE0NF1dLCBbJ3lvcGYnLCBbMTIwMTcwXV0sIFsnWXNjcicsIFsxMTk5ODhdXSwgWyd5c2NyJywgWzEyMDAxNF1dLCBbJ1lVY3knLCBbMTA3MF1dLCBbJ3l1Y3knLCBbMTEwMl1dLCBbJ3l1bWwnLCBbMjU1XV0sIFsnWXVtbCcsIFszNzZdXSwgWydaYWN1dGUnLCBbMzc3XV0sIFsnemFjdXRlJywgWzM3OF1dLCBbJ1pjYXJvbicsIFszODFdXSwgWyd6Y2Fyb24nLCBbMzgyXV0sIFsnWmN5JywgWzEwNDddXSwgWyd6Y3knLCBbMTA3OV1dLCBbJ1pkb3QnLCBbMzc5XV0sIFsnemRvdCcsIFszODBdXSwgWyd6ZWV0cmYnLCBbODQ4OF1dLCBbJ1plcm9XaWR0aFNwYWNlJywgWzgyMDNdXSwgWydaZXRhJywgWzkxOF1dLCBbJ3pldGEnLCBbOTUwXV0sIFsnemZyJywgWzEyMDExOV1dLCBbJ1pmcicsIFs4NDg4XV0sIFsnWkhjeScsIFsxMDQ2XV0sIFsnemhjeScsIFsxMDc4XV0sIFsnemlncmFycicsIFs4NjY5XV0sIFsnem9wZicsIFsxMjAxNzFdXSwgWydab3BmJywgWzg0ODRdXSwgWydac2NyJywgWzExOTk4OV1dLCBbJ3pzY3InLCBbMTIwMDE1XV0sIFsnendqJywgWzgyMDVdXSwgWyd6d25qJywgWzgyMDRdXV07XG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIGNoYXJJbmRleCA9IHt9O1xuY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpO1xudmFyIEh0bWw1RW50aXRpZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHRtbDVFbnRpdGllcygpIHtcbiAgICB9XG4gICAgSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbiAocywgZW50aXR5KSB7XG4gICAgICAgICAgICB2YXIgY2hyO1xuICAgICAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpID09PSAneCcgP1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCksIDE2KSA6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBIdG1sNUVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZGVjb2RlKHN0cik7XG4gICAgfTtcbiAgICBIdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZShzdHIpO1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbY107XG4gICAgICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gICAgfTtcbiAgICByZXR1cm4gSHRtbDVFbnRpdGllcztcbn0oKSk7XG5leHBvcnRzLkh0bWw1RW50aXRpZXMgPSBIdG1sNUVudGl0aWVzO1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhlcyhhbHBoYUluZGV4LCBjaGFySW5kZXgpIHtcbiAgICB2YXIgaSA9IEVOVElUSUVTLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBlID0gRU5USVRJRVNbaV07XG4gICAgICAgIHZhciBhbHBoYSA9IGVbMF07XG4gICAgICAgIHZhciBjaGFycyA9IGVbMV07XG4gICAgICAgIHZhciBjaHIgPSBjaGFyc1swXTtcbiAgICAgICAgdmFyIGFkZENoYXIgPSAoY2hyIDwgMzIgfHwgY2hyID4gMTI2KSB8fCBjaHIgPT09IDYyIHx8IGNociA9PT0gNjAgfHwgY2hyID09PSAzOCB8fCBjaHIgPT09IDM0IHx8IGNociA9PT0gMzk7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IHZvaWQgMDtcbiAgICAgICAgaWYgKGFkZENoYXIpIHtcbiAgICAgICAgICAgIGNoYXJJbmZvID0gY2hhckluZGV4W2Nocl0gPSBjaGFySW5kZXhbY2hyXSB8fCB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcnNbMV0pIHtcbiAgICAgICAgICAgIHZhciBjaHIyID0gY2hhcnNbMV07XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyMik7XG4gICAgICAgICAgICBhZGRDaGFyICYmIChjaGFySW5mb1tjaHIyXSA9IGFscGhhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpO1xuICAgICAgICAgICAgYWRkQ2hhciAmJiAoY2hhckluZm9bJyddID0gYWxwaGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKS5nZXRMb2dnZXIoJ3dlYnBhY2stZGV2LXNlcnZlcicpO1xuXG52YXIgSU5GTyA9ICdpbmZvJztcbnZhciBXQVJOID0gJ3dhcm4nO1xudmFyIEVSUk9SID0gJ2Vycm9yJztcbnZhciBERUJVRyA9ICdkZWJ1Zyc7XG52YXIgVFJBQ0UgPSAndHJhY2UnO1xudmFyIFNJTEVOVCA9ICdzaWxlbnQnOyAvLyBkZXByZWNhdGVkXG4vLyBUT0RPOiByZW1vdmUgdGhlc2UgYXQgbWFqb3IgcmVsZWFzZWRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9wdWxsLzE4MjVcblxudmFyIFdBUk5JTkcgPSAnd2FybmluZyc7XG52YXIgTk9ORSA9ICdub25lJzsgLy8gU2V0IHRoZSBkZWZhdWx0IGxvZyBsZXZlbFxuXG5sb2cuc2V0RGVmYXVsdExldmVsKElORk8pO1xuXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSBJTkZPOlxuICAgIGNhc2UgV0FSTjpcbiAgICBjYXNlIEVSUk9SOlxuICAgIGNhc2UgREVCVUc6XG4gICAgY2FzZSBUUkFDRTpcbiAgICAgIGxvZy5zZXRMZXZlbChsZXZlbCk7XG4gICAgICBicmVhaztcbiAgICAvLyBkZXByZWNhdGVkXG5cbiAgICBjYXNlIFdBUk5JTkc6XG4gICAgICAvLyBsb2dsZXZlbCdzIHdhcm5pbmcgbmFtZSBpcyBkaWZmZXJlbnQgZnJvbSB3ZWJwYWNrJ3NcbiAgICAgIGxvZy5zZXRMZXZlbCgnd2FybicpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gZGVwcmVjYXRlZFxuXG4gICAgY2FzZSBOT05FOlxuICAgIGNhc2UgU0lMRU5UOlxuICAgICAgbG9nLmRpc2FibGVBbGwoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZy5lcnJvcihcIltXRFNdIFVua25vd24gY2xpZW50TG9nTGV2ZWwgJ1wiLmNvbmNhdChsZXZlbCwgXCInXCIpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nOiBsb2csXG4gIHNldExvZ0xldmVsOiBzZXRMb2dMZXZlbFxufTsiLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yICE9PSB1bmRlZmluZWRUeXBlKSAmJiAoXG4gICAgICAgIC9UcmlkZW50XFwvfE1TSUUgLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICk7XG5cbiAgICB2YXIgbG9nTWV0aG9kcyA9IFtcbiAgICAgICAgXCJ0cmFjZVwiLFxuICAgICAgICBcImRlYnVnXCIsXG4gICAgICAgIFwiaW5mb1wiLFxuICAgICAgICBcIndhcm5cIixcbiAgICAgICAgXCJlcnJvclwiXG4gICAgXTtcblxuICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICBmdW5jdGlvbiBiaW5kTWV0aG9kKG9iaiwgbWV0aG9kTmFtZSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVHJhY2UoKSBkb2Vzbid0IHByaW50IHRoZSBtZXNzYWdlIGluIElFLCBzbyBmb3IgdGhhdCBjYXNlIHdlIG5lZWQgdG8gd3JhcCBpdFxuICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShjb25zb2xlLmxvZywgW2NvbnNvbGUsIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhlIGJlc3QgbG9nZ2luZyBtZXRob2QgcG9zc2libGUgZm9yIHRoaXMgZW52XG4gICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgZnVuY3Rpb24gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmIChtZXRob2ROYW1lID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gTm8gbWV0aG9kIHBvc3NpYmxlLCBmb3Igbm93IC0gZml4ZWQgbGF0ZXIgYnkgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlc1xuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZE5hbWUgPT09ICd0cmFjZScgJiYgaXNJRSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCBtZXRob2ROYW1lKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gYmluZE1ldGhvZChjb25zb2xlLCAnbG9nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHByaXZhdGUgZnVuY3Rpb25zIGFsd2F5cyBuZWVkIGB0aGlzYCB0byBiZSBzZXQgcHJvcGVybHlcblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0gPSAoaSA8IGxldmVsKSA/XG4gICAgICAgICAgICAgICAgbm9vcCA6XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWdcbiAgICAgICAgdGhpcy5sb2cgPSB0aGlzLmRlYnVnO1xuICAgIH1cblxuICAgIC8vIEluIG9sZCBJRSB2ZXJzaW9ucywgdGhlIGNvbnNvbGUgaXNuJ3QgcHJlc2VudCB1bnRpbCB5b3UgZmlyc3Qgb3BlbiBpdC5cbiAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmRcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRNZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIHJldHVybiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHx8XG4gICAgICAgICAgICAgICBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9nZ2VyKG5hbWUsIGRlZmF1bHRMZXZlbCwgZmFjdG9yeSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGN1cnJlbnRMZXZlbDtcbiAgICAgIHZhciBzdG9yYWdlS2V5ID0gXCJsb2dsZXZlbFwiO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKlxuICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIHNlbGYubmFtZSA9IG5hbWU7XG5cbiAgICAgIHNlbGYubGV2ZWxzID0geyBcIlRSQUNFXCI6IDAsIFwiREVCVUdcIjogMSwgXCJJTkZPXCI6IDIsIFwiV0FSTlwiOiAzLFxuICAgICAgICAgIFwiRVJST1JcIjogNCwgXCJTSUxFTlRcIjogNX07XG5cbiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7XG5cbiAgICAgIHNlbGYuZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcInN0cmluZ1wiICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgbGV2ZWwgPSBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJudW1iZXJcIiAmJiBsZXZlbCA+PSAwICYmIGxldmVsIDw9IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgaWYgKHBlcnNpc3QgIT09IGZhbHNlKSB7ICAvLyBkZWZhdWx0cyB0byB0cnVlXG4gICAgICAgICAgICAgICAgICBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmLCBsZXZlbCwgbmFtZSk7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSAmJiBsZXZlbCA8IHNlbGYubGV2ZWxzLlNJTEVOVCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IFwibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogXCIgKyBsZXZlbDtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldERlZmF1bHRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgICBzZWxmLnNldExldmVsKGxldmVsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5lbmFibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW5pdGlhbGl6ZSB3aXRoIHRoZSByaWdodCBsZXZlbFxuICAgICAgdmFyIGluaXRpYWxMZXZlbCA9IGdldFBlcnNpc3RlZExldmVsKCk7XG4gICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsTGV2ZWwgPSBkZWZhdWx0TGV2ZWwgPT0gbnVsbCA/IFwiV0FSTlwiIDogZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiIHx8IG5hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXTtcbiAgICAgICAgaWYgKCFsb2dnZXIpIHtcbiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoXG4gICAgICAgICAgICBuYW1lLCBkZWZhdWx0TG9nZ2VyLmdldExldmVsKCksIGRlZmF1bHRMb2dnZXIubWV0aG9kRmFjdG9yeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlcjtcbiAgICB9O1xuXG4gICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG4gICAgdmFyIF9sb2cgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgPyB3aW5kb3cubG9nIDogdW5kZWZpbmVkO1xuICAgIGRlZmF1bHRMb2dnZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJlxuICAgICAgICAgICAgICAgd2luZG93LmxvZyA9PT0gZGVmYXVsdExvZ2dlcikge1xuICAgICAgICAgICAgd2luZG93LmxvZyA9IF9sb2c7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICB9O1xuXG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXJzID0gZnVuY3Rpb24gZ2V0TG9nZ2VycygpIHtcbiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lO1xuICAgIH07XG5cbiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbn0pKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnkgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuLy8gU2VuZCBtZXNzYWdlcyB0byB0aGUgb3V0c2lkZSwgc28gcGx1Z2lucyBjYW4gY29uc3VtZSBpdC5cblxuZnVuY3Rpb24gc2VuZE1zZyh0eXBlLCBkYXRhKSB7XG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcgfHwgIShzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUpKSkge1xuICAgIHNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogXCJ3ZWJwYWNrXCIuY29uY2F0KHR5cGUpLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0sICcqJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZW5kTXNnOyIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vbG9nJyksXG4gICAgbG9nID0gX3JlcXVpcmUubG9nO1xuXG5mdW5jdGlvbiByZWxvYWRBcHAoX3JlZiwgX3JlZjIpIHtcbiAgdmFyIGhvdFJlbG9hZCA9IF9yZWYuaG90UmVsb2FkLFxuICAgICAgaG90ID0gX3JlZi5ob3QsXG4gICAgICBsaXZlUmVsb2FkID0gX3JlZi5saXZlUmVsb2FkO1xuICB2YXIgaXNVbmxvYWRpbmcgPSBfcmVmMi5pc1VubG9hZGluZyxcbiAgICAgIGN1cnJlbnRIYXNoID0gX3JlZjIuY3VycmVudEhhc2g7XG5cbiAgaWYgKGlzVW5sb2FkaW5nIHx8ICFob3RSZWxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaG90KSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCBob3QgdXBkYXRlLi4uJyk7XG5cbiAgICB2YXIgaG90RW1pdHRlciA9IHJlcXVpcmUoJ3dlYnBhY2svaG90L2VtaXR0ZXInKTtcblxuICAgIGhvdEVtaXR0ZXIuZW1pdCgnd2VicGFja0hvdFVwZGF0ZScsIGN1cnJlbnRIYXNoKTtcblxuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi53aW5kb3cpIHtcbiAgICAgIC8vIGJyb2FkY2FzdCB1cGRhdGUgdG8gd2luZG93XG4gICAgICBzZWxmLnBvc3RNZXNzYWdlKFwid2VicGFja0hvdFVwZGF0ZVwiLmNvbmNhdChjdXJyZW50SGFzaCksICcqJyk7XG4gICAgfVxuICB9IC8vIGFsbG93IHJlZnJlc2hpbmcgdGhlIHBhZ2Ugb25seSBpZiBsaXZlUmVsb2FkIGlzbid0IGRpc2FibGVkXG4gIGVsc2UgaWYgKGxpdmVSZWxvYWQpIHtcbiAgICAgIHZhciByb290V2luZG93ID0gc2VsZjsgLy8gdXNlIHBhcmVudCB3aW5kb3cgZm9yIHJlbG9hZCAoaW4gY2FzZSB3ZSdyZSBpbiBhbiBpZnJhbWUgd2l0aCBubyB2YWxpZCBzcmMpXG5cbiAgICAgIHZhciBpbnRlcnZhbElkID0gc2VsZi5zZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyb290V2luZG93LmxvY2F0aW9uLnByb3RvY29sICE9PSAnYWJvdXQ6Jykge1xuICAgICAgICAgIC8vIHJlbG9hZCBpbW1lZGlhdGVseSBpZiBwcm90b2NvbCBpcyB2YWxpZFxuICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb3RXaW5kb3cgPSByb290V2luZG93LnBhcmVudDtcblxuICAgICAgICAgIGlmIChyb290V2luZG93LnBhcmVudCA9PT0gcm9vdFdpbmRvdykge1xuICAgICAgICAgICAgLy8gaWYgcGFyZW50IGVxdWFscyBjdXJyZW50IHdpbmRvdyB3ZSd2ZSByZWFjaGVkIHRoZSByb290IHdoaWNoIHdvdWxkIGNvbnRpbnVlIGZvcmV2ZXIsIHNvIHRyaWdnZXIgYSByZWxvYWQgYW55d2F5c1xuICAgICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCkge1xuICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZCk7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWxvYWRpbmcuLi4nKTtcbiAgICByb290V2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVsb2FkQXBwOyIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBzZWxmICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcblxudmFyIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UgPSByZXF1aXJlKCcuL2dldEN1cnJlbnRTY3JpcHRTb3VyY2UnKTtcblxuZnVuY3Rpb24gY3JlYXRlU29ja2V0VXJsKHJlc291cmNlUXVlcnksIGN1cnJlbnRMb2NhdGlvbikge1xuICB2YXIgdXJsUGFydHM7XG5cbiAgaWYgKHR5cGVvZiByZXNvdXJjZVF1ZXJ5ID09PSAnc3RyaW5nJyAmJiByZXNvdXJjZVF1ZXJ5ICE9PSAnJykge1xuICAgIC8vIElmIHRoaXMgYnVuZGxlIGlzIGlubGluZWQsIHVzZSB0aGUgcmVzb3VyY2UgcXVlcnkgdG8gZ2V0IHRoZSBjb3JyZWN0IHVybC5cbiAgICAvLyBmb3JtYXQgaXMgbGlrZSBgP2h0dHA6Ly8wLjAuMC4wOjgwOTYmc29ja1BvcnQ9ODA5NyZzb2NrSG9zdD1sb2NhbGhvc3RgXG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2UocmVzb3VyY2VRdWVyeSAvLyBzdHJpcCBsZWFkaW5nIGA/YCBmcm9tIHF1ZXJ5IHN0cmluZyB0byBnZXQgYSB2YWxpZCBVUkxcbiAgICAuc3Vic3RyKDEpIC8vIHJlcGxhY2UgZmlyc3QgYCZgIHdpdGggYD9gIHRvIGhhdmUgYSB2YWxpZCBxdWVyeSBzdHJpbmdcbiAgICAucmVwbGFjZSgnJicsICc/JyksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIEVsc2UsIGdldCB0aGUgdXJsIGZyb20gdGhlIDxzY3JpcHQ+IHRoaXMgZmlsZSB3YXMgY2FsbGVkIHdpdGguXG4gICAgdmFyIHNjcmlwdEhvc3QgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlKCk7XG4gICAgdXJsUGFydHMgPSB1cmwucGFyc2Uoc2NyaXB0SG9zdCB8fCAnLycsIHRydWUsIHRydWUpO1xuICB9IC8vIFVzZSBwYXJhbWV0ZXIgdG8gYWxsb3cgcGFzc2luZyBsb2NhdGlvbiBpbiB1bml0IHRlc3RzXG5cblxuICBpZiAodHlwZW9mIGN1cnJlbnRMb2NhdGlvbiA9PT0gJ3N0cmluZycgJiYgY3VycmVudExvY2F0aW9uICE9PSAnJykge1xuICAgIGN1cnJlbnRMb2NhdGlvbiA9IHVybC5wYXJzZShjdXJyZW50TG9jYXRpb24pO1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRMb2NhdGlvbiA9IHNlbGYubG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gZ2V0U29ja2V0VXJsKHVybFBhcnRzLCBjdXJyZW50TG9jYXRpb24pO1xufVxuLypcbiAqIEdldHMgc29ja2V0IFVSTCBiYXNlZCBvbiBTY3JpcHQgU291cmNlL0xvY2F0aW9uXG4gKiAoc2NyaXB0U3JjOiBVUkwsIGxvY2F0aW9uOiBVUkwpIC0+IFVSTFxuICovXG5cblxuZnVuY3Rpb24gZ2V0U29ja2V0VXJsKHVybFBhcnRzLCBsb2MpIHtcbiAgdmFyIGF1dGggPSB1cmxQYXJ0cy5hdXRoLFxuICAgICAgcXVlcnkgPSB1cmxQYXJ0cy5xdWVyeTtcbiAgdmFyIGhvc3RuYW1lID0gdXJsUGFydHMuaG9zdG5hbWUsXG4gICAgICBwcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sLFxuICAgICAgcG9ydCA9IHVybFBhcnRzLnBvcnQ7XG5cbiAgaWYgKCFwb3J0IHx8IHBvcnQgPT09ICcwJykge1xuICAgIHBvcnQgPSBsb2MucG9ydDtcbiAgfSAvLyBjaGVjayBpcHY0IGFuZCBpcHY2IGBhbGwgaG9zdG5hbWVgXG4gIC8vIHdoeSBkbyB3ZSBuZWVkIHRoaXMgY2hlY2s/XG4gIC8vIGhvc3RuYW1lIG4vYSBmb3IgZmlsZSBwcm90b2NvbCAoZXhhbXBsZSwgd2hlbiB1c2luZyBlbGVjdHJvbiwgaW9uaWMpXG4gIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svd2VicGFjay1kZXYtc2VydmVyL3B1bGwvMzg0XG5cblxuICBpZiAoKGhvc3RuYW1lID09PSAnMC4wLjAuMCcgfHwgaG9zdG5hbWUgPT09ICc6OicpICYmIGxvYy5ob3N0bmFtZSAmJiBsb2MucHJvdG9jb2wuaW5kZXhPZignaHR0cCcpID09PSAwKSB7XG4gICAgaG9zdG5hbWUgPSBsb2MuaG9zdG5hbWU7XG4gIH0gLy8gYGhvc3RuYW1lYCBjYW4gYmUgZW1wdHkgd2hlbiB0aGUgc2NyaXB0IHBhdGggaXMgcmVsYXRpdmUuIEluIHRoYXQgY2FzZSwgc3BlY2lmeWluZ1xuICAvLyBhIHByb3RvY29sIHdvdWxkIHJlc3VsdCBpbiBhbiBpbnZhbGlkIFVSTC5cbiAgLy8gV2hlbiBodHRwcyBpcyB1c2VkIGluIHRoZSBhcHAsIHNlY3VyZSB3ZWJzb2NrZXRzIGFyZSBhbHdheXMgbmVjZXNzYXJ5XG4gIC8vIGJlY2F1c2UgdGhlIGJyb3dzZXIgZG9lc24ndCBhY2NlcHQgbm9uLXNlY3VyZSB3ZWJzb2NrZXRzLlxuXG5cbiAgaWYgKGhvc3RuYW1lICYmIGhvc3RuYW1lICE9PSAnMTI3LjAuMC4xJyAmJiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6JyB8fCB1cmxQYXJ0cy5ob3N0bmFtZSA9PT0gJzAuMC4wLjAnKSkge1xuICAgIHByb3RvY29sID0gbG9jLnByb3RvY29sO1xuICB9IC8vIGFsbCBvZiB0aGVzZSBzb2NrIHVybCBwYXJhbXMgYXJlIG9wdGlvbmFsbHkgcGFzc2VkIGluIHRocm91Z2hcbiAgLy8gcmVzb3VyY2VRdWVyeSwgc28gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGhlIGRlZmF1bHQgaWZcbiAgLy8gdGhleSBhcmUgbm90IHByb3ZpZGVkXG5cblxuICB2YXIgc29ja0hvc3QgPSBxdWVyeS5zb2NrSG9zdCB8fCBob3N0bmFtZTtcbiAgdmFyIHNvY2tQYXRoID0gcXVlcnkuc29ja1BhdGggfHwgJy9zb2NranMtbm9kZSc7XG4gIHZhciBzb2NrUG9ydCA9IHF1ZXJ5LnNvY2tQb3J0IHx8IHBvcnQ7XG5cbiAgaWYgKHNvY2tQb3J0ID09PSAnbG9jYXRpb24nKSB7XG4gICAgc29ja1BvcnQgPSBsb2MucG9ydDtcbiAgfVxuXG4gIHJldHVybiB1cmwuZm9ybWF0KHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgYXV0aDogYXV0aCxcbiAgICBob3N0bmFtZTogc29ja0hvc3QsXG4gICAgcG9ydDogc29ja1BvcnQsXG4gICAgLy8gSWYgc29ja1BhdGggaXMgcHJvdmlkZWQgaXQnbGwgYmUgcGFzc2VkIGluIHZpYSB0aGUgcmVzb3VyY2VRdWVyeSBhcyBhXG4gICAgLy8gcXVlcnkgcGFyYW0gc28gaXQgaGFzIHRvIGJlIHBhcnNlZCBvdXQgb2YgdGhlIHF1ZXJ5c3RyaW5nIGluIG9yZGVyIGZvciB0aGVcbiAgICAvLyBjbGllbnQgdG8gb3BlbiB0aGUgc29ja2V0IHRvIHRoZSBjb3JyZWN0IGxvY2F0aW9uLlxuICAgIHBhdGhuYW1lOiBzb2NrUGF0aFxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTb2NrZXRVcmw7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpIHtcbiAgLy8gYGRvY3VtZW50LmN1cnJlbnRTY3JpcHRgIGlzIHRoZSBtb3N0IGFjY3VyYXRlIHdheSB0byBmaW5kIHRoZSBjdXJyZW50IHNjcmlwdCxcbiAgLy8gYnV0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFsbCBiYWNrIHRvIGdldHRpbmcgYWxsIHNjcmlwdHMgaW4gdGhlIGRvY3VtZW50LlxuXG5cbiAgdmFyIHNjcmlwdEVsZW1lbnRzID0gZG9jdW1lbnQuc2NyaXB0cyB8fCBbXTtcbiAgdmFyIGN1cnJlbnRTY3JpcHQgPSBzY3JpcHRFbGVtZW50c1tzY3JpcHRFbGVtZW50cy5sZW5ndGggLSAxXTtcblxuICBpZiAoY3VycmVudFNjcmlwdCkge1xuICAgIHJldHVybiBjdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gIH0gLy8gRmFpbCBhcyB0aGVyZSB3YXMgbm8gc2NyaXB0IHRvIHVzZS5cblxuXG4gIHRocm93IG5ldyBFcnJvcignW1dEU10gRmFpbGVkIHRvIGdldCBjdXJyZW50IHNjcmlwdCBzb3VyY2UuJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZTsiLCJ2YXIgbWFwID0ge1xuXHRcIi4vbG9nXCI6IDMxXG59O1xuXG5cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHR2YXIgaWQgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKTtcblx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oaWQpO1xufVxuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdFx0dGhyb3cgZTtcblx0fVxuXHRyZXR1cm4gbWFwW3JlcV07XG59XG53ZWJwYWNrQ29udGV4dC5rZXlzID0gZnVuY3Rpb24gd2VicGFja0NvbnRleHRLZXlzKCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn07XG53ZWJwYWNrQ29udGV4dC5yZXNvbHZlID0gd2VicGFja0NvbnRleHRSZXNvbHZlO1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrQ29udGV4dDtcbndlYnBhY2tDb250ZXh0LmlkID0gMzA7IiwidmFyIGxvZ0xldmVsID0gXCJpbmZvXCI7XG5cbmZ1bmN0aW9uIGR1bW15KCkge31cblxuZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsKSB7XG5cdHZhciBzaG91bGRMb2cgPVxuXHRcdChsb2dMZXZlbCA9PT0gXCJpbmZvXCIgJiYgbGV2ZWwgPT09IFwiaW5mb1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcIndhcm5pbmdcIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIiwgXCJlcnJvclwiXS5pbmRleE9mKGxvZ0xldmVsKSA+PSAwICYmIGxldmVsID09PSBcImVycm9yXCIpO1xuXHRyZXR1cm4gc2hvdWxkTG9nO1xufVxuXG5mdW5jdGlvbiBsb2dHcm91cChsb2dGbikge1xuXHRyZXR1cm4gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRcdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0XHRsb2dGbihtc2cpO1xuXHRcdH1cblx0fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdGlmIChzaG91bGRMb2cobGV2ZWwpKSB7XG5cdFx0aWYgKGxldmVsID09PSBcImluZm9cIikge1xuXHRcdFx0Y29uc29sZS5sb2cobXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcIndhcm5pbmdcIikge1xuXHRcdFx0Y29uc29sZS53YXJuKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJlcnJvclwiKSB7XG5cdFx0XHRjb25zb2xlLmVycm9yKG1zZyk7XG5cdFx0fVxuXHR9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cbnZhciBncm91cCA9IGNvbnNvbGUuZ3JvdXAgfHwgZHVtbXk7XG52YXIgZ3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkIHx8IGR1bW15O1xudmFyIGdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZCB8fCBkdW1teTtcbi8qIGVzbGludC1lbmFibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwID0gbG9nR3JvdXAoZ3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cENvbGxhcHNlZCA9IGxvZ0dyb3VwKGdyb3VwQ29sbGFwc2VkKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBFbmQgPSBsb2dHcm91cChncm91cEVuZCk7XG5cbm1vZHVsZS5leHBvcnRzLnNldExvZ0xldmVsID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0bG9nTGV2ZWwgPSBsZXZlbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzLmZvcm1hdEVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG5cdHZhciBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG5cdHZhciBzdGFjayA9IGVyci5zdGFjaztcblx0aWYgKCFzdGFjaykge1xuXHRcdHJldHVybiBtZXNzYWdlO1xuXHR9IGVsc2UgaWYgKHN0YWNrLmluZGV4T2YobWVzc2FnZSkgPCAwKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2UgKyBcIlxcblwiICsgc3RhY2s7XG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHN0YWNrO1xuXHR9XG59O1xuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvZGlzdC9janMuanMhLi9iaWxsYm9hcmQuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiBidG9hKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qLS0gQ2hhcnQgLS0qL1xcbi5iYiBzdmcge1xcbiAgZm9udDogMTBweCBzYW5zLXNlcmlmO1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApOyB9XFxuXFxuLmJiIHBhdGgsIC5iYiBsaW5lIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICMwMDA7IH1cXG5cXG4uYmIgdGV4dCwgLmJiIC5iYi1idXR0b24ge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi1sZWdlbmQtaXRlbS10aWxlLFxcbi5iYi14Z3JpZC1mb2N1cyxcXG4uYmIteWdyaWQtZm9jdXMsXFxuLmJiLXlncmlkLFxcbi5iYi1ldmVudC1yZWN0LFxcbi5iYi1iYXJzIHBhdGgge1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyAuYmItZ2F1Z2UtdmFsdWUge1xcbiAgZmlsbDogIzAwMDsgfVxcblxcbi5iYi1jaGFydC1hcmMgcGF0aCB7XFxuICBzdHJva2U6ICNmZmY7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHJlY3Qge1xcbiAgc3Ryb2tlOiAjZmZmO1xcbiAgc3Ryb2tlLXdpZHRoOiAxOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyB0ZXh0IHtcXG4gIGZpbGw6ICNmZmY7XFxuICBmb250LXNpemU6IDEzcHg7IH1cXG5cXG4vKi0tIEF4aXMgLS0qL1xcbi5iYi1heGlzIHtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlczsgfVxcblxcbi8qLS0gR3JpZCAtLSovXFxuLmJiLWdyaWQgbGluZSB7XFxuICBzdHJva2U6ICNhYWE7IH1cXG5cXG4uYmItZ3JpZCB0ZXh0IHtcXG4gIGZpbGw6ICNhYWE7IH1cXG5cXG4uYmIteGdyaWQsIC5iYi15Z3JpZCB7XFxuICBzdHJva2UtZGFzaGFycmF5OiAzIDM7IH1cXG5cXG4vKi0tIFRleHQgb24gQ2hhcnQgLS0qL1xcbi5iYi10ZXh0LmJiLWVtcHR5IHtcXG4gIGZpbGw6ICM4MDgwODA7XFxuICBmb250LXNpemU6IDJlbTsgfVxcblxcbi8qLS0gTGluZSAtLSovXFxuLmJiLWxpbmUge1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7IH1cXG5cXG4vKi0tIFBvaW50IC0tKi9cXG4uYmItY2lyY2xlLl9leHBhbmRlZF8ge1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7XFxuICBzdHJva2U6IHdoaXRlOyB9XFxuXFxuLmJiLXNlbGVjdGVkLWNpcmNsZSB7XFxuICBmaWxsOiB3aGl0ZTtcXG4gIHN0cm9rZS13aWR0aDogMnB4OyB9XFxuXFxuLyotLSBCYXIgLS0qL1xcbi5iYi1iYXIge1xcbiAgc3Ryb2tlLXdpZHRoOiAwOyB9XFxuICAuYmItYmFyLl9leHBhbmRlZF8ge1xcbiAgICBmaWxsLW9wYWNpdHk6IDAuNzU7IH1cXG5cXG4vKi0tIEZvY3VzIC0tKi9cXG4uYmItdGFyZ2V0LmJiLWZvY3VzZWQsIC5iYi1jaXJjbGVzLmJiLWZvY3VzZWQge1xcbiAgb3BhY2l0eTogMTsgfVxcblxcbi5iYi10YXJnZXQuYmItZm9jdXNlZCBwYXRoLmJiLWxpbmUsIC5iYi10YXJnZXQuYmItZm9jdXNlZCBwYXRoLmJiLXN0ZXAsIC5iYi1jaXJjbGVzLmJiLWZvY3VzZWQgcGF0aC5iYi1saW5lLCAuYmItY2lyY2xlcy5iYi1mb2N1c2VkIHBhdGguYmItc3RlcCB7XFxuICBzdHJva2Utd2lkdGg6IDJweDsgfVxcblxcbi5iYi10YXJnZXQuYmItZGVmb2N1c2VkLCAuYmItY2lyY2xlcy5iYi1kZWZvY3VzZWQge1xcbiAgb3BhY2l0eTogMC4zICFpbXBvcnRhbnQ7IH1cXG4gIC5iYi10YXJnZXQuYmItZGVmb2N1c2VkIC50ZXh0LW92ZXJsYXBwaW5nLCAuYmItY2lyY2xlcy5iYi1kZWZvY3VzZWQgLnRleHQtb3ZlcmxhcHBpbmcge1xcbiAgICBvcGFjaXR5OiAuMDUgIWltcG9ydGFudDsgfVxcblxcbi8qLS0gUmVnaW9uIC0tKi9cXG4uYmItcmVnaW9uIHtcXG4gIGZpbGw6IHN0ZWVsYmx1ZTtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIFpvb20gcmVnaW9uIC0tKi9cXG4uYmItem9vbS1icnVzaCB7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBCcnVzaCAtLSovXFxuLmJiLWJydXNoIC5leHRlbnQge1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gU2VsZWN0IC0gRHJhZyAtLSovXFxuLyotLSBMZWdlbmQgLS0qL1xcbi5iYi1sZWdlbmQtaXRlbSB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi1sZWdlbmQtaXRlbS1oaWRkZW4ge1xcbiAgb3BhY2l0eTogMC4xNTsgfVxcblxcbi5iYi1sZWdlbmQtYmFja2dyb3VuZCB7XFxuICBvcGFjaXR5OiAwLjc1O1xcbiAgZmlsbDogd2hpdGU7XFxuICBzdHJva2U6IGxpZ2h0Z3JheTtcXG4gIHN0cm9rZS13aWR0aDogMTsgfVxcblxcbi8qLS0gVGl0bGUgLS0qL1xcbi5iYi10aXRsZSB7XFxuICBmb250OiAxNHB4IHNhbnMtc2VyaWY7IH1cXG5cXG4vKi0tIFRvb2x0aXAgLS0qL1xcbi5iYi10b29sdGlwLWNvbnRhaW5lciB7XFxuICB6LWluZGV4OiAxMDtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLXRvb2x0aXAge1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGVtcHR5LWNlbGxzOiBzaG93O1xcbiAgb3BhY2l0eTogMC45O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3O1xcbiAgLW1vei1ib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3O1xcbiAgYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NzsgfVxcbiAgLmJiLXRvb2x0aXAgdHIge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDOyB9XFxuICAuYmItdG9vbHRpcCB0aCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNhYWE7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgcGFkZGluZzogMnB4IDVweDtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgY29sb3I6ICNGRkY7IH1cXG4gIC5iYi10b29sdGlwIHRkIHtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBwYWRkaW5nOiAzcHggNnB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBib3JkZXItbGVmdDogMXB4IGRvdHRlZCAjOTk5OyB9XFxuICAgIC5iYi10b29sdGlwIHRkID4gc3BhbiwgLmJiLXRvb2x0aXAgdGQgPiBzdmcge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB3aWR0aDogMTBweDtcXG4gICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA2cHg7IH1cXG4gIC5iYi10b29sdGlwLnZhbHVlIHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG4vKi0tIEFyZWEgLS0qL1xcbi5iYi1hcmVhIHtcXG4gIHN0cm9rZS13aWR0aDogMDtcXG4gIG9wYWNpdHk6IDAuMjsgfVxcblxcbi8qLS0gQXJjIC0tKi9cXG4uYmItY2hhcnQtYXJjcy10aXRsZSB7XFxuICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xcbiAgZm9udC1zaXplOiAxLjNlbTsgfVxcblxcbi5iYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlIHtcXG4gIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XFxuICBmb250LXNpemU6IDIuN2VtOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZCB7XFxuICBmaWxsOiAjZTBlMGUwO1xcbiAgc3Ryb2tlOiAjZmZmOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdW5pdCB7XFxuICBmaWxsOiAjMDAwO1xcbiAgZm9udC1zaXplOiAxNnB4OyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWF4IHtcXG4gIGZpbGw6ICM3Nzc7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS1taW4ge1xcbiAgZmlsbDogIzc3NzsgfVxcblxcbi8qLS0gUmFkYXIgLS0qL1xcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWxldmVscyBwb2x5Z29uIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICM4NDgyODI7XFxuICBzdHJva2Utd2lkdGg6IC41cHg7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1sZXZlbHMgdGV4dCB7XFxuICBmaWxsOiAjODQ4MjgyOyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItYXhpcyBsaW5lIHtcXG4gIHN0cm9rZTogIzg0ODI4MjtcXG4gIHN0cm9rZS13aWR0aDogLjVweDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWF4aXMgdGV4dCB7XFxuICBmb250LXNpemU6IDEuMTVlbTtcXG4gIGN1cnNvcjogZGVmYXVsdDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLXNoYXBlcyBwb2x5Z29uIHtcXG4gIGZpbGwtb3BhY2l0eTogLjI7XFxuICBzdHJva2Utd2lkdGg6IDFweDsgfVxcblxcbi8qLS0gQnV0dG9uIC0tKi9cXG4uYmItYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTBweDtcXG4gIHJpZ2h0OiAxMHB4OyB9XFxuICAuYmItYnV0dG9uIC5iYi16b29tLXJlc2V0IHtcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcbiAgICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzZfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM3X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzlfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQwX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDJfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQzX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDVfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ2X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180N19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDhfXzsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBDU1MgY2xhc3MgbmFtZXMgZGVmaW5pdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGFyYzogXCJiYi1hcmNcIixcclxuXHRhcmNMYWJlbExpbmU6IFwiYmItYXJjLWxhYmVsLWxpbmVcIixcclxuXHRhcmNzOiBcImJiLWFyY3NcIixcclxuXHRhcmVhOiBcImJiLWFyZWFcIixcclxuXHRhcmVhczogXCJiYi1hcmVhc1wiLFxyXG5cdGF4aXM6IFwiYmItYXhpc1wiLFxyXG5cdGF4aXNYOiBcImJiLWF4aXMteFwiLFxyXG5cdGF4aXNYTGFiZWw6IFwiYmItYXhpcy14LWxhYmVsXCIsXHJcblx0YXhpc1k6IFwiYmItYXhpcy15XCIsXHJcblx0YXhpc1kyOiBcImJiLWF4aXMteTJcIixcclxuXHRheGlzWTJMYWJlbDogXCJiYi1heGlzLXkyLWxhYmVsXCIsXHJcblx0YXhpc1lMYWJlbDogXCJiYi1heGlzLXktbGFiZWxcIixcclxuXHRiYXI6IFwiYmItYmFyXCIsXHJcblx0YmFyczogXCJiYi1iYXJzXCIsXHJcblx0YnJ1c2g6IFwiYmItYnJ1c2hcIixcclxuXHRidXR0b246IFwiYmItYnV0dG9uXCIsXHJcblx0YnV0dG9uWm9vbVJlc2V0OiBcImJiLXpvb20tcmVzZXRcIixcclxuXHRjaGFydDogXCJiYi1jaGFydFwiLFxyXG5cdGNoYXJ0QXJjOiBcImJiLWNoYXJ0LWFyY1wiLFxyXG5cdGNoYXJ0QXJjczogXCJiYi1jaGFydC1hcmNzXCIsXHJcblx0Y2hhcnRBcmNzQmFja2dyb3VuZDogXCJiYi1jaGFydC1hcmNzLWJhY2tncm91bmRcIixcclxuXHRjaGFydEFyY3NHYXVnZU1heDogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1heFwiLFxyXG5cdGNoYXJ0QXJjc0dhdWdlTWluOiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWluXCIsXHJcblx0Y2hhcnRBcmNzR2F1Z2VVbml0OiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdW5pdFwiLFxyXG5cdGNoYXJ0QXJjc1RpdGxlOiBcImJiLWNoYXJ0LWFyY3MtdGl0bGVcIixcclxuXHRjaGFydEFyY3NHYXVnZVRpdGxlOiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdGl0bGVcIixcclxuXHRjaGFydEJhcjogXCJiYi1jaGFydC1iYXJcIixcclxuXHRjaGFydEJhcnM6IFwiYmItY2hhcnQtYmFyc1wiLFxyXG5cdGNoYXJ0Q2lyY2xlczogXCJiYi1jaGFydC1jaXJjbGVzXCIsXHJcblx0Y2hhcnRMaW5lOiBcImJiLWNoYXJ0LWxpbmVcIixcclxuXHRjaGFydExpbmVzOiBcImJiLWNoYXJ0LWxpbmVzXCIsXHJcblx0Y2hhcnRSYWRhcjogXCJiYi1jaGFydC1yYWRhclwiLFxyXG5cdGNoYXJ0UmFkYXJzOiBcImJiLWNoYXJ0LXJhZGFyc1wiLFxyXG5cdGNoYXJ0VGV4dDogXCJiYi1jaGFydC10ZXh0XCIsXHJcblx0Y2hhcnRUZXh0czogXCJiYi1jaGFydC10ZXh0c1wiLFxyXG5cdGNpcmNsZTogXCJiYi1jaXJjbGVcIixcclxuXHRjaXJjbGVzOiBcImJiLWNpcmNsZXNcIixcclxuXHRjb2xvclBhdHRlcm46IFwiYmItY29sb3ItcGF0dGVyblwiLFxyXG5cdGNvbG9yU2NhbGU6IFwiYmItY29sb3JzY2FsZVwiLFxyXG5cdGRlZm9jdXNlZDogXCJiYi1kZWZvY3VzZWRcIixcclxuXHRkcmFnYXJlYTogXCJiYi1kcmFnYXJlYVwiLFxyXG5cdGVtcHR5OiBcImJiLWVtcHR5XCIsXHJcblx0ZXZlbnRSZWN0OiBcImJiLWV2ZW50LXJlY3RcIixcclxuXHRldmVudFJlY3RzOiBcImJiLWV2ZW50LXJlY3RzXCIsXHJcblx0ZXZlbnRSZWN0c011bHRpcGxlOiBcImJiLWV2ZW50LXJlY3RzLW11bHRpcGxlXCIsXHJcblx0ZXZlbnRSZWN0c1NpbmdsZTogXCJiYi1ldmVudC1yZWN0cy1zaW5nbGVcIixcclxuXHRmb2N1c2VkOiBcImJiLWZvY3VzZWRcIixcclxuXHRnYXVnZVZhbHVlOiBcImJiLWdhdWdlLXZhbHVlXCIsXHJcblx0Z3JpZDogXCJiYi1ncmlkXCIsXHJcblx0Z3JpZExpbmVzOiBcImJiLWdyaWQtbGluZXNcIixcclxuXHRsZWdlbmRCYWNrZ3JvdW5kOiBcImJiLWxlZ2VuZC1iYWNrZ3JvdW5kXCIsXHJcblx0bGVnZW5kSXRlbTogXCJiYi1sZWdlbmQtaXRlbVwiLFxyXG5cdGxlZ2VuZEl0ZW1FdmVudDogXCJiYi1sZWdlbmQtaXRlbS1ldmVudFwiLFxyXG5cdGxlZ2VuZEl0ZW1Gb2N1c2VkOiBcImJiLWxlZ2VuZC1pdGVtLWZvY3VzZWRcIixcclxuXHRsZWdlbmRJdGVtSGlkZGVuOiBcImJiLWxlZ2VuZC1pdGVtLWhpZGRlblwiLFxyXG5cdGxlZ2VuZEl0ZW1Qb2ludDogXCJiYi1sZWdlbmQtaXRlbS1wb2ludFwiLFxyXG5cdGxlZ2VuZEl0ZW1UaWxlOiBcImJiLWxlZ2VuZC1pdGVtLXRpbGVcIixcclxuXHRsZXZlbDogXCJiYi1sZXZlbFwiLFxyXG5cdGxldmVsczogXCJiYi1sZXZlbHNcIixcclxuXHRsaW5lOiBcImJiLWxpbmVcIixcclxuXHRsaW5lczogXCJiYi1saW5lc1wiLFxyXG5cdHJlZ2lvbjogXCJiYi1yZWdpb25cIixcclxuXHRyZWdpb25zOiBcImJiLXJlZ2lvbnNcIixcclxuXHRzZWxlY3RlZENpcmNsZTogXCJiYi1zZWxlY3RlZC1jaXJjbGVcIixcclxuXHRzZWxlY3RlZENpcmNsZXM6IFwiYmItc2VsZWN0ZWQtY2lyY2xlc1wiLFxyXG5cdHNoYXBlOiBcImJiLXNoYXBlXCIsXHJcblx0c2hhcGVzOiBcImJiLXNoYXBlc1wiLFxyXG5cdHN0YW5mb3JkRWxlbWVudHM6IFwiYmItc3RhbmZvcmQtZWxlbWVudHNcIixcclxuXHRzdGFuZm9yZExpbmU6IFwiYmItc3RhbmZvcmQtbGluZVwiLFxyXG5cdHN0YW5mb3JkTGluZXM6IFwiYmItc3RhbmZvcmQtbGluZXNcIixcclxuXHRzdGFuZm9yZFJlZ2lvbjogXCJiYi1zdGFuZm9yZC1yZWdpb25cIixcclxuXHRzdGFuZm9yZFJlZ2lvbnM6IFwiYmItc3RhbmZvcmQtcmVnaW9uc1wiLFxyXG5cdHRhcmdldDogXCJiYi10YXJnZXRcIixcclxuXHR0ZXh0OiBcImJiLXRleHRcIixcclxuXHR0ZXh0czogXCJiYi10ZXh0c1wiLFxyXG5cdHRpdGxlOiBcImJiLXRpdGxlXCIsXHJcblx0dG9vbHRpcDogXCJiYi10b29sdGlwXCIsXHJcblx0dG9vbHRpcENvbnRhaW5lcjogXCJiYi10b29sdGlwLWNvbnRhaW5lclwiLFxyXG5cdHRvb2x0aXBOYW1lOiBcImJiLXRvb2x0aXAtbmFtZVwiLFxyXG5cdHhncmlkOiBcImJiLXhncmlkXCIsXHJcblx0eGdyaWRGb2N1czogXCJiYi14Z3JpZC1mb2N1c1wiLFxyXG5cdHhncmlkTGluZTogXCJiYi14Z3JpZC1saW5lXCIsXHJcblx0eGdyaWRMaW5lczogXCJiYi14Z3JpZC1saW5lc1wiLFxyXG5cdHhncmlkczogXCJiYi14Z3JpZHNcIixcclxuXHR5Z3JpZDogXCJiYi15Z3JpZFwiLFxyXG5cdHlncmlkRm9jdXM6IFwiYmIteWdyaWQtZm9jdXNcIixcclxuXHR5Z3JpZExpbmU6IFwiYmIteWdyaWQtbGluZVwiLFxyXG5cdHlncmlkTGluZXM6IFwiYmIteWdyaWQtbGluZXNcIixcclxuXHR5Z3JpZHM6IFwiYmIteWdyaWRzXCIsXHJcblx0em9vbUJydXNoOiBcImJiLXpvb20tYnJ1c2hcIixcclxuXHR6b29tUmVjdDogXCJiYi16b29tLXJlY3RcIixcclxuXHRFWFBBTkRFRDogXCJfZXhwYW5kZWRfXCIsXHJcblx0U0VMRUNURUQ6IFwiX3NlbGVjdGVkX1wiLFxyXG5cdElOQ0xVREVEOiBcIl9pbmNsdWRlZF9cIixcclxuXHRUZXh0T3ZlcmxhcHBpbmc6IFwidGV4dC1vdmVybGFwcGluZ1wiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcblxyXG50eXBlIFQgPSBkM1NlbGVjdGlvbiB8IG51bGw7XHJcblxyXG4vKipcclxuICogRWxlbWVudHMgY2xhc3MuXHJcbiAqIEBjbGFzcyBFbGVtZW50c1xyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGVtZW50IHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdGNvbnN0IGVsZW1lbnQ6IHtcclxuXHRcdFx0W2tleTogc3RyaW5nXTogVCB8IHtba2V5OiBzdHJpbmddOiBUfVxyXG5cdFx0fSA9IHtcclxuXHRcdFx0Y2hhcnQ6IG51bGwsXHJcblx0XHRcdG1haW46IG51bGwsXHJcblx0XHRcdHN2ZzogbnVsbCxcclxuXHRcdFx0YXhpczogeyAvLyBheGVzXHJcblx0XHRcdFx0eDogbnVsbCxcclxuXHRcdFx0XHR5OiBudWxsLFxyXG5cdFx0XHRcdHkyOiBudWxsLFxyXG5cdFx0XHRcdHN1Ylg6IG51bGxcclxuXHRcdFx0fSxcclxuXHRcdFx0ZGVmczogbnVsbCxcclxuXHRcdFx0dG9vbHRpcDogbnVsbCxcclxuXHRcdFx0bGVnZW5kOiBudWxsLFxyXG5cdFx0XHR0aXRsZTogbnVsbCxcclxuXHRcdFx0c3ViY2hhcnQ6IHtcclxuXHRcdFx0XHRtYWluOiBudWxsLCAvLyAkJC5jb250ZXh0XHJcblx0XHRcdFx0YmFyOiBudWxsLCAvLyAkJC5jb250ZXh0QmFyXHJcblx0XHRcdFx0bGluZTogbnVsbCwgLy8gJCQuY29udGV4dExpbmVcclxuXHRcdFx0XHRhcmVhOiBudWxsIC8vICQkLmNvbnRleHRBcmVhXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRhcmNzOiBudWxsLFxyXG5cdFx0XHRiYXI6IG51bGwsIC8vIG1haW5CYXIsXHJcblx0XHRcdGxpbmU6IG51bGwsIC8vIG1haW5MaW5lLFxyXG5cdFx0XHRhcmVhOiBudWxsLCAvLyBtYWluQXJlYSxcclxuXHRcdFx0Y2lyY2xlOiBudWxsLCAvLyBtYWluQ2lyY2xlLFxyXG5cdFx0XHRyYWRhcjogbnVsbCxcclxuXHRcdFx0dGV4dDogbnVsbCwgLy8gbWFpblRleHQsXHJcblx0XHRcdGdyaWQ6IHtcclxuXHRcdFx0XHRtYWluOiBudWxsLCAvLyBncmlkIChhbHNvIGZvY3VzKVxyXG5cdFx0XHRcdHg6IG51bGwsIC8vIHhncmlkLFxyXG5cdFx0XHRcdHk6IG51bGwsIC8vIHlncmlkLFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRncmlkTGluZXM6IHtcclxuXHRcdFx0XHRtYWluOiBudWxsLCAvLyBncmlkTGluZXNcclxuXHRcdFx0XHR4OiBudWxsLCAvLyB4Z3JpZExpbmVzLFxyXG5cdFx0XHRcdHk6IG51bGwsIC8vIHlncmlkTGluZXNcclxuXHRcdFx0fSxcclxuXHRcdFx0cmVnaW9uOiB7XHJcblx0XHRcdFx0bWFpbjogbnVsbCwgLy8gcmVnaW9uXHJcblx0XHRcdFx0bGlzdDogbnVsbCAvLyBtYWluUmVnaW9uXHJcblx0XHRcdH0sXHJcblx0XHRcdGV2ZW50UmVjdDogbnVsbFxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZWxlbWVudDtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogU3RhdGUgY2xhc3MuXHJcbiAqIEBjbGFzcyBTdGF0ZVxyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZSB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0d2lkdGgyOiAwLFxyXG5cdFx0XHRoZWlnaHQ6IDAsXHJcblx0XHRcdGhlaWdodDI6IDAsXHJcblx0XHRcdG1hcmdpbjoge1xyXG5cdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRib3R0b206IDAsXHJcblx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRyaWdodDogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRtYXJnaW4yOiB7XHJcblx0XHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwXHJcblx0XHRcdH0sXHJcblx0XHRcdG1hcmdpbjM6IHtcclxuXHRcdFx0XHR0b3A6IDAsXHJcblx0XHRcdFx0Ym90dG9tOiAwLFxyXG5cdFx0XHRcdGxlZnQ6IDAsXHJcblx0XHRcdFx0cmlnaHQ6IDBcclxuXHRcdFx0fSxcclxuXHRcdFx0YXJjV2lkdGg6IDAsXHJcblx0XHRcdGFyY0hlaWdodDogMCxcclxuXHRcdFx0eEF4aXNIZWlnaHQ6IDAsXHJcblxyXG5cdFx0XHRoYXNBeGlzOiBmYWxzZSxcclxuXHRcdFx0aGFzUmFkYXI6IGZhbHNlLFxyXG5cclxuXHRcdFx0Y3VycmVudDoge1xyXG5cdFx0XHRcdHdpZHRoOiAwLFxyXG5cdFx0XHRcdGhlaWdodDogMCxcclxuXHRcdFx0XHRkYXRhTWF4OiAwLFxyXG5cclxuXHRcdFx0XHRtYXhUaWNrV2lkdGhzOiB7XHJcblx0XHRcdFx0XHR4OiB7c2l6ZTogMCwgdGlja3M6IDxudW1iZXJbXT4gW10sIGNsaXBQYXRoOiAwLCBkb21haW46IFwiXCJ9LFxyXG5cdFx0XHRcdFx0eToge3NpemU6IDAsIGRvbWFpbjogXCJcIn0sXHJcblx0XHRcdFx0XHR5Mjoge3NpemU6IDAsIGRvbWFpbjogXCJcIn1cclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBjdXJyZW50IHVzZWQgY2hhcnQgdHlwZSBsaXN0XHJcblx0XHRcdFx0dHlwZXM6IDxzdHJpbmdbXT4gW10sXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBsZWdlbmRcclxuXHRcdFx0aXNMZWdlbmRSaWdodDogZmFsc2UsXHJcblx0XHRcdGlzTGVnZW5kSW5zZXQ6IGZhbHNlLFxyXG5cdFx0XHRpc0xlZ2VuZFRvcDogZmFsc2UsXHJcblx0XHRcdGlzTGVnZW5kTGVmdDogZmFsc2UsXHJcblx0XHRcdGxlZ2VuZFN0ZXA6IDAsXHJcblx0XHRcdGxlZ2VuZEl0ZW1XaWR0aDogMCxcclxuXHRcdFx0bGVnZW5kSXRlbUhlaWdodDogMCxcclxuXHRcdFx0bGVnZW5kSGFzUmVuZGVyZWQ6IGZhbHNlLFxyXG5cclxuXHRcdFx0YXhpczoge1xyXG5cdFx0XHRcdHg6IHtcclxuXHRcdFx0XHRcdHBhZGRpbmc6IHtsZWZ0OiAwLCByaWdodDogMH0sXHJcblx0XHRcdFx0XHR0aWNrQ291bnQ6IDBcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRyb3RhdGVkUGFkZGluZzoge1xyXG5cdFx0XHRcdGxlZnQ6IDMwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwLFxyXG5cdFx0XHRcdHRvcDogNVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0d2l0aG91dEZhZGVJbjoge30sXHJcblx0XHRcdGlucHV0VHlwZTogXCJcIixcclxuXHJcblx0XHRcdGRhdGV0aW1lSWQ6IFwiXCIsXHJcblxyXG5cdFx0XHQvLyBjbGlwIGlkIHN0cmluZ1xyXG5cdFx0XHRjbGlwOiB7XHJcblx0XHRcdFx0aWQ6IFwiXCIsXHJcblx0XHRcdFx0aWRYQXhpczogXCJcIixcclxuXHRcdFx0XHRpZFlBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdGlkWEF4aXNUaWNrVGV4dHM6IFwiXCIsXHJcblx0XHRcdFx0aWRHcmlkOiBcIlwiLFxyXG5cdFx0XHRcdGlkU3ViY2hhcnQ6IFwiXCIsIC8vIGNsaXBJZEZvclN1YmNoYXJ0XHJcblx0XHRcdFx0cGF0aDogXCJcIixcclxuXHRcdFx0XHRwYXRoWEF4aXM6IFwiXCIsXHJcblx0XHRcdFx0cGF0aFlBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdHBhdGhYQXhpc1RpY2tUZXh0czogXCJcIixcclxuXHRcdFx0XHRwYXRoR3JpZDogXCJcIlxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gc3RhdHVzXHJcblx0XHRcdGRyYWdTdGFydDogbnVsbCxcclxuXHRcdFx0ZHJhZ2dpbmc6IGZhbHNlLFxyXG5cdFx0XHRmbG93aW5nOiBmYWxzZSxcclxuXHRcdFx0Y2FuY2VsQ2xpY2s6IGZhbHNlLFxyXG5cdFx0XHRtb3VzZW92ZXI6IGZhbHNlLFxyXG5cdFx0XHRyZW5kZXJlZDogZmFsc2UsXHJcblx0XHRcdHRyYW5zaXRpbmc6IGZhbHNlLFxyXG5cdFx0XHRyZXNpemluZzogZmFsc2UsIC8vIHJlc2l6ZSBldmVudCBjYWxsZWRcclxuXHRcdFx0aGFzTmVnYXRpdmVWYWx1ZTogZmFsc2UsXHJcblx0XHRcdGhhc1Bvc2l0aXZlVmFsdWU6IHRydWUsXHJcblxyXG5cdFx0XHRvcmdBcmVhT3BhY2l0eTogXCIwLjJcIixcclxuXHJcblx0XHRcdC8vIElEIHN0cmluZ3NcclxuXHRcdFx0aGlkZGVuVGFyZ2V0SWRzOiA8c3RyaW5nW10+IFtdLFxyXG5cdFx0XHRoaWRkZW5MZWdlbmRJZHM6IDxzdHJpbmdbXT4gW10sXHJcblx0XHRcdGZvY3VzZWRUYXJnZXRJZHM6IDxzdHJpbmdbXT4gW10sXHJcblx0XHRcdGRlZm9jdXNlZFRhcmdldElkczogPHN0cmluZ1tdPiBbXSxcclxuXHJcblx0XHRcdC8vIHZhbHVlIGZvciBBcmNcclxuXHRcdFx0cmFkaXVzOiAwLFxyXG5cdFx0XHRpbm5lclJhZGl1czogMCxcclxuXHRcdFx0aW5uZXJSYWRpdXNSYXRpbzogMCxcclxuXHRcdFx0Z2F1Z2VBcmNXaWR0aDogMCxcclxuXHRcdFx0cmFkaXVzRXhwYW5kZWQ6IDAsXHJcblxyXG5cdFx0XHQvLyB4Z3JpZCBhdHRyaWJ1dGVcclxuXHRcdFx0eGdyaWRBdHRyOiB7XHJcblx0XHRcdFx0eDE6IDxudW1iZXIgfCBudWxsPiBudWxsLFxyXG5cdFx0XHRcdHgyOiA8bnVtYmVyIHwgbnVsbD4gbnVsbCxcclxuXHRcdFx0XHR5MTogPG51bWJlciB8IG51bGw+IG51bGwsXHJcblx0XHRcdFx0eTI6IDxudW1iZXIgfCBudWxsPiBudWxsXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4vRWxlbWVudFwiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4vU3RhdGVcIjtcclxuXHJcbi8vIG1hcHBpbmdcclxuY29uc3QgY2xhc3NlcyA9IHtcclxuXHRlbGVtZW50OiBFbGVtZW50LFxyXG5cdHN0YXRlOiBTdGF0ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIHN0b3JlIGNsYXNzLlxyXG4gKiBAY2xhc3MgU3RvcmVcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmUge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0T2JqZWN0LmtleXMoY2xhc3NlcykuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0dGhpc1t2XSA9IG5ldyBjbGFzc2VzW3ZdKCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGdldFN0b3JlKG5hbWU6IHN0cmluZyk6IEVsZW1lbnQgfCBTdGF0ZSB7XHJcblx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge0NoYXJ0VHlwZXN9IGZyb20gXCIuLi8uLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIGRhdGEgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBkYXRhIGlkIHZhbHVlXHJcblx0ICogQG5hbWUgZGF0YeKApGlkQ29udmVydGVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkOyB9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgaWRDb252ZXJ0ZXI6IGZ1bmN0aW9uKGlkKSB7XHJcblx0ICogICAgICAgLy8gd2hlbiBpZCBpcyAnZGF0YTEnLCBjb252ZXJ0cyB0byBiZSAnZGF0YTInXHJcblx0ICogICAgICAgLy8gJ2RhdGEyJyBzaG91bGQgYmUgZ2l2ZW4gYXMgdGhlIGluaXRpYWwgZGF0YSB2YWx1ZVxyXG5cdCAqICAgICAgIGlmIChpZCA9PT0gXCJkYXRhMVwiKSB7XHJcblx0ICogICAgICAgICAgcmV0dXJuIFwiZGF0YTJcIjtcclxuXHQgKiAgICAgICB9IGVsc2Uge1xyXG5cdCAqICAgICAgICAgIHJldHVybiBpZDtcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2lkQ29udmVydGVyOiBpZCA9PiBpZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGN1c3RvbSBkYXRhIG5hbWUuXHJcblx0ICogQG5hbWUgZGF0YeKApG5hbWVzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU5hbWUpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBuYW1lczoge1xyXG5cdCAqICAgICBkYXRhMTogXCJEYXRhIE5hbWUgMVwiLFxyXG5cdCAqICAgICBkYXRhMjogXCJEYXRhIE5hbWUgMlwiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfbmFtZXM6IDx7W2tleTogc3RyaW5nXTogc3RyaW5nfT4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjdXN0b20gZGF0YSBjbGFzcy48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgZyBmb3IgdGhlIGRhdGEgaGFzIGFuIGFkZGl0aW9uYWwgY2xhc3MgdGhhdCBoYXMgdGhlIHByZWZpeCAnYmItdGFyZ2V0LScgKGVnLiBiYi10YXJnZXQtYWRkaXRpb25hbC1kYXRhMS1jbGFzcykuXHJcblx0ICogQG5hbWUgZGF0YeKApGNsYXNzZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNsYXNzZXM6IHtcclxuXHQgKiAgICAgZGF0YTE6IFwiYWRkaXRpb25hbC1kYXRhMS1jbGFzc1wiLFxyXG5cdCAqICAgICBkYXRhMjogXCJhZGRpdGlvbmFsLWRhdGEyLWNsYXNzXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9jbGFzc2VzOiA8e1trZXk6IHN0cmluZ106IHN0cmluZ30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2hhcnQgdHlwZSBhdCBvbmNlLjxicj48YnI+XHJcblx0ICogSWYgdGhpcyBvcHRpb24gaXMgc3BlY2lmaWVkLCB0aGUgdHlwZSB3aWxsIGJlIGFwcGxpZWQgdG8gZXZlcnkgZGF0YS4gVGhpcyBzZXR0aW5nIGNhbiBiZSBvdmVyd3JpdHRlbiBieSBkYXRhLnR5cGVzLjxicj48YnI+XHJcblx0ICogKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogLSBhcmVhXHJcblx0ICogLSBhcmVhLWxpbmUtcmFuZ2VcclxuXHQgKiAtIGFyZWEtc3BsaW5lXHJcblx0ICogLSBhcmVhLXNwbGluZS1yYW5nZVxyXG5cdCAqIC0gYXJlYS1zdGVwXHJcblx0ICogLSBiYXJcclxuXHQgKiAtIGJ1YmJsZVxyXG5cdCAqIC0gZG9udXRcclxuXHQgKiAtIGdhdWdlXHJcblx0ICogLSBsaW5lXHJcblx0ICogLSBwaWVcclxuXHQgKiAtIHJhZGFyXHJcblx0ICogLSBzY2F0dGVyXHJcblx0ICogLSBzcGxpbmVcclxuXHQgKiAtIHN0ZXBcclxuXHQgKiBAbmFtZSBkYXRh4oCkdHlwZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCBsaW5lXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgdHlwZTogXCJiYXJcIlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3R5cGU6IDxDaGFydFR5cGVzfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2hhcnQgdHlwZSBmb3IgZWFjaCBkYXRhLjxicj5cclxuXHQgKiBUaGlzIHNldHRpbmcgb3ZlcndyaXRlcyBkYXRhLnR5cGUgc2V0dGluZy5cclxuXHQgKiAtICoqTk9URToqKiBgcmFkYXJgIHR5cGUgY2FuJ3QgYmUgY29tYmluZWQgd2l0aCBvdGhlciB0eXBlcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkdHlwZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHR5cGVzOiB7XHJcblx0ICogICAgIGRhdGExOiBcImJhclwiLFxyXG5cdCAqICAgICBkYXRhMjogXCJzcGxpbmVcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3R5cGVzOiA8e1trZXk6IHN0cmluZ106IENoYXJ0VHlwZXN9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogIFRoaXMgb3B0aW9uIGNoYW5nZXMgdGhlIG9yZGVyIG9mIHN0YWNraW5nIGRhdGEgYW5kIHBpZWNlcyBvZiBwaWUvZG9udXQuXHJcblx0ICogIC0gSWYgYG51bGxgIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB0aGUgb3JkZXIgdGhlIGRhdGEgbG9hZGVkLlxyXG5cdCAqICAtIElmIGZ1bmN0aW9uIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB1c2VkIGFzIFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKTxicj48YnI+XHJcblx0ICpcclxuXHQgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIG9yZGVyXHJcblx0ICogIC0gYGFzY2A6IEluIGFzY2VuZGluZyBvcmRlclxyXG5cdCAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgbG9hZCBvcmRlclxyXG5cdCAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvblxyXG5cdCAqIEBuYW1lIGRhdGHigKRvcmRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ3xGdW5jdGlvbnxudWxsfVxyXG5cdCAqIEBkZWZhdWx0IGRlc2NcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhT3JkZXIpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAvLyBpbiBkZXNjZW5kaW5nIG9yZGVyIChkZWZhdWx0KVxyXG5cdCAqICAgb3JkZXI6IFwiZGVzY1wiXHJcblx0ICpcclxuXHQgKiAgIC8vIGluIGFzY2VuZGluZyBvcmRlclxyXG5cdCAqICAgb3JkZXI6IFwiYXNjXCJcclxuXHQgKlxyXG5cdCAqICAgLy8ga2VlcHMgZGF0YSBpbnB1dCBvcmRlclxyXG5cdCAqICAgb3JkZXI6IG51bGxcclxuXHQgKlxyXG5cdCAqICAgLy8gc3BlY2lmeWluZyBzb3J0IGZ1bmN0aW9uXHJcblx0ICogICBvcmRlcjogZnVuY3Rpb24oYSwgYikge1xyXG5cdCAqICAgICAgIC8vIHBhcmFtIGRhdGEgcGFzc2VkIGZvcm1hdFxyXG5cdCAqICAgICAgIHtcclxuXHQgKiAgICAgICAgICBpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBbXHJcblx0ICogICAgICAgICAgICAgIHt4OiA1LCB2YWx1ZTogMjUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNSwgbmFtZTogXCJkYXRhMVwifSxcclxuXHQgKiAgICAgICAgICAgICAgLi4uXHJcblx0ICogICAgICAgICAgXVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9vcmRlcjogPFwiZGVzY1wifFwiYXNjXCJ8RnVuY3Rpb258bnVsbD4gXCJkZXNjXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjb2xvciBjb252ZXJ0ZXIgZnVuY3Rpb24uPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBzaG91bGQgYSBmdW5jdGlvbiBhbmQgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBjb2xvciAoZS5nLiAnI2ZmMDAwMCcpIGFuZCBkIHRoYXQgaGFzIGRhdGEgcGFyYW1ldGVycyBsaWtlIGlkLCB2YWx1ZSwgaW5kZXgsIGV0Yy4gQW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBjb2xvciAoZS5nLiAnIzAwZmYwMCcpLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRjb2xvclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFDb2xvcilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNvbG9yOiBmdW5jdGlvbihjb2xvciwgZCkgeyAuLi4gfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2NvbG9yOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjb2xvciBmb3IgZWFjaCBkYXRhLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRjb2xvcnNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNvbG9yczoge1xyXG5cdCAqICAgICBkYXRhMTogXCIjZmYwMDAwXCIsXHJcblx0ICogICAgIGRhdGEyOiBmdW5jdGlvbihkKSB7XHJcblx0ICogICAgICAgIHJldHVybiBcIiMwMDBcIjtcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgICAuLi5cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9jb2xvcnM6IDx7W2tleTogc3RyaW5nXTogc3RyaW5nfCgoKSA9PiBzdHJpbmcpO30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGVhY2ggZGF0YSB3aGVuIHRoZSBjaGFydCBhcHBlYXJzLjxicj48YnI+XHJcblx0ICogSWYgdHJ1ZSBzcGVjaWZpZWQsIGFsbCBvZiBkYXRhIHdpbGwgYmUgaGlkZGVuLiBJZiBtdWx0aXBsZSBpZHMgc3BlY2lmaWVkIGFzIGFuIGFycmF5LCB0aG9zZSB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiBAbmFtZSBkYXRh4oCkaGlkZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW58QXJyYXl9XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIC8vIGFsbCBvZiBkYXRhIHdpbGwgYmUgaGlkZGVuXHJcblx0ICogICBoaWRlOiB0cnVlXHJcblx0ICpcclxuXHQgKiAgIC8vIHNwZWNpZmllZCBkYXRhIHdpbGwgYmUgaGlkZGVuXHJcblx0ICogICBoaWRlOiBbXCJkYXRhMVwiLCAuLi5dXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfaGlkZTogPHN0cmluZ1tdfGJvb2xlYW4+IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBGaWx0ZXIgdmFsdWVzIHRvIGJlIHNob3duXHJcblx0ICogVGhlIGRhdGEgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIHJldHVybmVkIGJ5IGAuZGF0YSgpYC5cclxuXHQgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlclxyXG5cdCAqIEBuYW1lIGRhdGHigKRmaWx0ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIC8vIGZpbHRlciBmb3IgaWQgdmFsdWVcclxuXHQgKiAgIGZpbHRlcjogZnVuY3Rpb24odikge1xyXG5cdCAqICAgICAgLy8gdjogW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBbXHJcblx0ICogICAgICAvLyAgICAgIHt4OiAwLCB2YWx1ZTogMTMwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogMH0sIC4uLl1cclxuXHQgKiAgICAgIC8vICAgIH0sIC4uLl1cclxuXHQgKiAgICAgIHJldHVybiB2LmlkICE9PSBcImRhdGExXCI7XHJcblx0ICogICB9XHJcblx0ICovXHJcblx0ZGF0YV9maWx0ZXI6IDwoKCkgPT4gYm9vbGVhbil8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGNhbGxiYWNrIGZvciBjbGljayBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuXHQgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gZWFjaCBkYXRhIHBvaW50IGNsaWNrZWQgYW5kIHdpbGwgcmVjZWl2ZSBgZGAgYW5kIGVsZW1lbnQgYXMgdGhlIGFyZ3VtZW50cy5cclxuXHQgKiAtIGBkYCBpcyB0aGUgZGF0YSBjbGlja2VkIGFuZCBlbGVtZW50IGlzIHRoZSBlbGVtZW50IGNsaWNrZWQuXHJcblx0ICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcblx0ICogLSBJbiB0aGlzIGNhbGxiYWNrLCBgdGhpc2Agd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbmNsaWNrXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgICBvbmNsaWNrOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XHJcblx0ICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX29uY2xpY2s6ICgpID0+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbW91c2UvdG91Y2ggb3ZlciBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuXHQgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvbnRvIGVhY2ggZGF0YSBwb2ludCBhbmQgd2lsbCByZWNlaXZlIGBkYCBhbmQgYGVsZW1lbnRgIGFzIHRoZSBhcmd1bWVudC5cclxuXHQgKiAtIGBkYCBpcyB0aGUgZGF0YSB3aGVyZSBtb3VzZSBjdXJzb3IgbW92ZXMgb250by5cclxuXHQgKiAtIGBlbGVtZW50YCBpcyB0aGUgY3VycmVudCBpbnRlcmFjdGluZyBzdmcgZWxlbWVudC5cclxuXHQgKiAtIEluIHRoaXMgY2FsbGJhY2ssIGB0aGlzYCB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXHJcblx0ICogQG5hbWUgZGF0YeKApG9ub3ZlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb25vdmVyOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0fVxyXG5cdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9vbm92ZXI6ICgpID0+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbW91c2UvdG91Y2ggb3V0IGV2ZW50IG9uIGVhY2ggZGF0YSBwb2ludC48YnI+PGJyPlxyXG5cdCAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBtb3VzZSBjdXJzb3Igb3IgdmlhIHRvdWNoIG1vdmVzIG91dCBlYWNoIGRhdGEgcG9pbnQgYW5kIHdpbGwgcmVjZWl2ZSBgZGAgYXMgdGhlIGFyZ3VtZW50LlxyXG5cdCAqIC0gYGRgIGlzIHRoZSBkYXRhIHdoZXJlIG1vdXNlIGN1cnNvciBtb3ZlcyBvdXQuXHJcblx0ICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcblx0ICogLSBJbiB0aGlzIGNhbGxiYWNrLCBgdGhpc2Agd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbm91dFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb25vdXQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuXHQgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDR9XHJcblx0ICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX29ub3V0OiAoKSA9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG1pbmltdW0gZGF0YVxyXG5cdCAqIC0gKipOT1RFOioqIEZvciAnYXJlYS1saW5lLXJhbmdlJyBhbmQgJ2FyZWEtc3BsaW5lLXJhbmdlJywgYG1pZGAgZGF0YSB3aWxsIGJlIHRha2VuIGZvciB0aGUgY29tcGFyaXNvblxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbm1pblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgb25taW46IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHQgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxyXG5cdCAqICAgIC4uLlxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0ZGF0YV9vbm1pbjogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbWF4aW11bSBkYXRhXHJcblx0ICogLSAqKk5PVEU6KiogRm9yICdhcmVhLWxpbmUtcmFuZ2UnIGFuZCAnYXJlYS1zcGxpbmUtcmFuZ2UnLCBgbWlkYCBkYXRhIHdpbGwgYmUgdGFrZW4gZm9yIHRoZSBjb21wYXJpc29uXHJcblx0ICogQG5hbWUgZGF0YeKApG9ubWF4XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuT25NaW5NYXhDYWxsYmFjaylcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBvbm1heDogZnVuY3Rpb24oZGF0YSkge1xyXG5cdCAqICAgIC8vIGRhdGEgLSBleCkgW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLiBdXHJcblx0ICogICAgLi4uXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRkYXRhX29ubWF4OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIExvYWQgYSBDU1Ygb3IgSlNPTiBmaWxlIGZyb20gYSBVUkwuIE5PVEUgdGhhdCB0aGlzIHdpbGwgbm90IHdvcmsgaWYgbG9hZGluZyB2aWEgdGhlIFwiZmlsZTovL1wiIHByb3RvY29sIGFzIHRoZSBtb3N0IGJyb3dzZXJzIHdpbGwgYmxvY2sgWE1MSFRUUFJlcXVlc3RzLlxyXG5cdCAqIEBuYW1lIGRhdGHigKR1cmxcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuTG9hZERhdGEpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIHVybDogXCIvZGF0YS90ZXN0LmNzdlwiXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfdXJsOiA8c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBYSFIgaGVhZGVyIHZhbHVlXHJcblx0ICogLSAqKk5PVEU6KiogU2hvdWxkIGJlIHVzZWQgd2l0aCBgZGF0YS51cmxgIG9wdGlvblxyXG5cdCAqIEBuYW1lIGRhdGHigKRoZWFkZXJzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3NldFJlcXVlc3RIZWFkZXJcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgdXJsOiBcIi9kYXRhL3Rlc3QuY3N2XCIsXHJcblx0ICogICAgIGhlYWRlcnM6IHtcclxuXHQgKiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3htbFwiLFxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2hlYWRlcnM6IDxvYmplY3R8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhcnNlIGEgSlNPTiBvYmplY3QgZm9yIGRhdGEuIFNlZSBhbHNvIGRhdGEua2V5cy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkanNvblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW2RhdGHigKRrZXlzXSgjLmRhdGElMjVFMiUyNTgwJTI1QTRrZXlzKVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkpTT05EYXRhKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgICBqc29uOiBbXHJcblx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUxLmNvbVwiLCB1cGxvYWQ6IDIwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDQwMH0sXHJcblx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUyLmNvbVwiLCB1cGxvYWQ6IDEwMCwgZG93bmxvYWQ6IDMwMCwgdG90YWw6IDQwMH0sXHJcblx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUzLmNvbVwiLCB1cGxvYWQ6IDMwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDUwMH0sXHJcblx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGU0LmNvbVwiLCB1cGxvYWQ6IDQwMCwgZG93bmxvYWQ6IDEwMCwgdG90YWw6IDUwMH1cclxuXHQgKiAgICAgXSxcclxuXHQgKiAgICAga2V5czoge1xyXG5cdCAqICAgICAgIC8vIHg6IFwibmFtZVwiLCAvLyBpdCdzIHBvc3NpYmxlIHRvIHNwZWNpZnkgJ3gnIHdoZW4gY2F0ZWdvcnkgYXhpc1xyXG5cdCAqICAgICAgIHZhbHVlOiBbXCJ1cGxvYWRcIiwgXCJkb3dubG9hZFwiXVxyXG5cdCAqICAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfanNvbjogPG9iamVjdFtdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBMb2FkIGRhdGEgZnJvbSBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXksIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgY29udGFpbmluZyB0aGUgZGF0YSBuYW1lcywgdGhlIGZvbGxvd2luZyBjb250YWluaW5nIHJlbGF0ZWQgZGF0YSBpbiB0aGF0IG9yZGVyLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRyb3dzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuUm93T3JpZW50ZWREYXRhKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgcm93czogW1xyXG5cdCAqICAgICBbXCJBXCIsIFwiQlwiLCBcIkNcIl0sXHJcblx0ICogICAgIFs5MCwgMTIwLCAzMDBdLFxyXG5cdCAqICAgICBbNDAsIDE2MCwgMjQwXSxcclxuXHQgKiAgICAgWzUwLCAyMDAsIDI5MF0sXHJcblx0ICogICAgIFsxMjAsIDE2MCwgMjMwXSxcclxuXHQgKiAgICAgWzgwLCAxMzAsIDMwMF0sXHJcblx0ICogICAgIFs5MCwgMjIwLCAzMjBdXHJcblx0ICogICBdXHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogLy8gZm9yICdyYW5nZScgdHlwZXMoJ2FyZWEtbGluZS1yYW5nZScgb3IgJ2FyZWEtc3BsaW5lLXJhbmdlJyksIGRhdGEgc2hvdWxkIGNvbnRhaW46XHJcblx0ICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxyXG5cdCAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ2hpZ2gnLCAnbWlkJyBhbmQgJ2xvdycga2V5IHZhbHVlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgcm93czogW1xyXG5cdCAqICAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuXHQgKiAgICAgIFtcclxuXHQgKiAgICAgICAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9LCAxMjBcclxuXHQgKiAgICAgICAgWzE1MCwgMTQwLCAxMTBdLCAxMjBcclxuXHQgKiAgICAgIF0sXHJcblx0ICogICAgICBbWzE1NSwgMTMwLCAxMTVdLCA1NV0sXHJcblx0ICogICAgICBbWzE2MCwgMTM1LCAxMjBdLCA2MF1cclxuXHQgKiAgIF0sXHJcblx0ICogICB0eXBlczoge1xyXG5cdCAqICAgICAgIGRhdGExOiBcImFyZWEtbGluZS1yYW5nZVwiLFxyXG5cdCAqICAgICAgIGRhdGEyOiBcImxpbmVcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKlxyXG5cdCAqIC8vIGZvciAnYnViYmxlJyB0eXBlLCBkYXRhIGNhbiBjb250YWluIGRpbWVuc2lvbiB2YWx1ZTpcclxuXHQgKiAvLyAtIGFuIGFycmF5IG9mIFt5LCB6XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuXHQgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICd5JyBhbmQgJ3onIGtleSB2YWx1ZVxyXG5cdCAqIC8vICd5JyBpcyBmb3IgeSBheGlzIGNvb3JkaW5hdGlvbiBhbmQgJ3onIGlzIHRoZSBidWJibGUgcmFkaXVzIHZhbHVlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgcm93czogW1xyXG5cdCAqICAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuXHQgKiAgICAgIFtcclxuXHQgKiAgICAgICAgLy8gb3Ige3k6MTAsIHo6IDE0MH0sIDEyMFxyXG5cdCAqICAgICAgICBbMTAsIDE0MF0sIDEyMFxyXG5cdCAqICAgICAgXSxcclxuXHQgKiAgICAgIFtbMTAwLCAzMF0sIDU1XSxcclxuXHQgKiAgICAgIFtbNTAsIDEwMF0sIDYwXVxyXG5cdCAqICAgXSxcclxuXHQgKiAgIHR5cGVzOiB7XHJcblx0ICogICAgICAgZGF0YTE6IFwiYnViYmxlXCIsXHJcblx0ICogICAgICAgZGF0YTI6IFwibGluZVwiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfcm93czogPChzdHJpbmd8bnVtYmVyKVtdW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIExvYWQgZGF0YSBmcm9tIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSwgd2l0aCBlYWNoIGVsZW1lbnQgY29udGFpbmluZyBhbiBhcnJheSBjb25zaXN0aW5nIG9mIGEgZGF0dW0gbmFtZSBhbmQgYXNzb2NpYXRlZCBkYXRhIHZhbHVlcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkY29sdW1uc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkNvbHVtbk9yaWVudGVkRGF0YSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgIFtcImRhdGExXCIsIDMwLCAyMCwgNTAsIDQwLCA2MCwgNTBdLFxyXG5cdCAqICAgICAgW1wiZGF0YTJcIiwgMjAwLCAxMzAsIDkwLCAyNDAsIDEzMCwgMjIwXSxcclxuXHQgKiAgICAgIFtcImRhdGEzXCIsIDMwMCwgMjAwLCAxNjAsIDQwMCwgMjUwLCAyNTBdXHJcblx0ICogICBdXHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogLy8gZm9yICdyYW5nZScgdHlwZXMoJ2FyZWEtbGluZS1yYW5nZScgb3IgJ2FyZWEtc3BsaW5lLXJhbmdlJyksIGRhdGEgc2hvdWxkIGNvbnRhaW46XHJcblx0ICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxyXG5cdCAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ2hpZ2gnLCAnbWlkJyBhbmQgJ2xvdycga2V5IHZhbHVlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgW1wiZGF0YTFcIixcclxuXHQgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sICAvLyBvciB7aGlnaDoxNTAsIG1pZDogMTQwLCBsb3c6IDExMH1cclxuXHQgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sXHJcblx0ICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdXHJcblx0ICogICAgICBdXHJcblx0ICogICBdLFxyXG5cdCAqICAgdHlwZTogXCJhcmVhLWxpbmUtcmFuZ2VcIlxyXG5cdCAqIH1cclxuXHQgKlxyXG5cdCAqIC8vIGZvciAnYnViYmxlJyB0eXBlLCBkYXRhIGNhbiBjb250YWluIGRpbWVuc2lvbiB2YWx1ZTpcclxuXHQgKiAvLyAtIGFuIGFycmF5IG9mIFt5LCB6XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuXHQgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICd5JyBhbmQgJ3onIGtleSB2YWx1ZVxyXG5cdCAqIC8vICd5JyBpcyBmb3IgeSBheGlzIGNvb3JkaW5hdGlvbiBhbmQgJ3onIGlzIHRoZSBidWJibGUgcmFkaXVzIHZhbHVlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgW1wiZGF0YTFcIixcclxuXHQgKiAgICAgICAgICBbMTAsIDE0MF0sICAvLyBvciB7eToxMCwgejogMTQwfVxyXG5cdCAqICAgICAgICAgIFsxMDAsIDMwXSxcclxuXHQgKiAgICAgICAgICBbNTAsIDEwMF1cclxuXHQgKiAgICAgIF1cclxuXHQgKiAgIF0sXHJcblx0ICogICB0eXBlOiBcImJ1YmJsZVwiXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfY29sdW1uczogPChzdHJpbmd8bnVtYmVyKVtdW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgaWYgbG9hZGluZyBKU09OIHZpYSBkYXRhLnVybC5cclxuXHQgKiAtICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqICAgLSBqc29uXHJcblx0ICogICAtIGNzdlxyXG5cdCAqICAgLSB0c3ZcclxuXHQgKiBAbmFtZSBkYXRh4oCkbWltZVR5cGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgY3N2XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX21pbWVUeXBlOiA8XCJjc3ZcInxcImpzb25cInxcInRzdlwiPiBcImNzdlwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBDaG9vc2Ugd2hpY2ggSlNPTiBvYmplY3Qga2V5cyBjb3JyZXNwb25kIHRvIGRlc2lyZWQgZGF0YS5cclxuXHQgKiAtICoqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS5cclxuXHQgKiBAbmFtZSBkYXRh4oCka2V5c1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAganNvbjogW1xyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMS5jb21cIiwgdXBsb2FkOiAyMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA0MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlNC5jb21cIiwgdXBsb2FkOiA0MDAsIGRvd25sb2FkOiAxMDAsIHRvdGFsOiA1MDB9XHJcblx0ICogICAgIF0sXHJcblx0ICogICAgIGtleXM6IHtcclxuXHQgKiAgICAgICAvLyB4OiBcIm5hbWVcIiwgLy8gaXQncyBwb3NzaWJsZSB0byBzcGVjaWZ5ICd4JyB3aGVuIGNhdGVnb3J5IGF4aXNcclxuXHQgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2tleXM6IDx7eD86IHN0cmluZzsgdmFsdWU/OiBzdHJpbmdbXX18dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0ZXh0IGxhYmVsIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZXJlJ3Mgbm8gZGF0YSB0byBzaG93LlxyXG5cdCAqIC0gZXguIFRvZ2dsaW5nIGFsbCB2aXNpYmxlIGRhdGEgdG8gbm90IGJlIHNob3duLCB1bmxvYWRpbmcgYWxsIGN1cnJlbnQgZGF0YSwgZXRjLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRlbXB0eeKApGxhYmVs4oCkdGV4dFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCBcIlwiXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBlbXB0eToge1xyXG5cdCAqICAgICBsYWJlbDoge1xyXG5cdCAqICAgICAgIHRleHQ6IFwiTm8gRGF0YVwiXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9lbXB0eV9sYWJlbF90ZXh0OiBcIlwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGNvbG9yIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGNvbG9yIG9mIHRoZSBkYXRhIHZhbHVlc1xyXG5cdCAqIEBuYW1lIGNvbG9yXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb2xvciBjb2xvciBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R8RnVuY3Rpb259IFtjb2xvci5vbm92ZXJdIFNldCB0aGUgY29sb3IgdmFsdWUgZm9yIGVhY2ggZGF0YSBwb2ludCB3aGVuIG1vdXNlL3RvdWNoIG9ub3ZlciBldmVudCBvY2N1cnMuXHJcblx0ICogQHByb3BlcnR5IHtBcnJheXxudWxsfSBbY29sb3IucGF0dGVybj1bXV0gU2V0IGN1c3RvbSBjb2xvciBwYXR0ZXJuLiBQYXNzaW5nIGBudWxsYCB3aWxsIG5vdCBzZXQgYSBjb2xvciBmb3IgdGhlc2UgZWxlbWVudHMsIHdoaWNoIHJlcXVpcmVzIHRoZSB1c2FnZSBvZiBjdXN0b20gQ1NTLWJhc2VkIHRoZW1pbmcgdG8gd29yay5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY29sb3IudGlsZXNdIGlmIGRlZmluZWQsIGFsbG93cyB1c2Ugc3ZnJ3MgcGF0dGVybnMgdG8gZmlsbCBkYXRhIGFyZWEuIEl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgW1NWR1BhdHRlcm5FbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU1ZHUGF0dGVybkVsZW1lbnQpLlxyXG5cdCAqICAtICoqTk9URToqKiBUaGUgcGF0dGVybiBlbGVtZW50J3MgaWQgd2lsbCBiZSBkZWZpbmVkIGFzIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLSRDT0xPUi1WQUxVRWAuPGJyPlxyXG5cdCAqICAgIGV4LiBXaGVuIGNvbG9yIHBhdHRlcm4gdmFsdWUgaXMgYFsncmVkJywgJyNmZmYnXWAgYW5kIGRlZmluZWQgMiBwYXR0ZXJucyx0aGVuIGlkcyBmb3IgcGF0dGVybiBlbGVtZW50cyBhcmU6PGJyPlxyXG5cdCAqICAgIC0gYGJiLWNvbG9yaXplLXBhdHRlcm4tcmVkYFxyXG5cdCAqICAgIC0gYGJiLWNvbG9yaXplLXBhdHRlcm4tZmZmYFxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbY29sb3IudGhyZXNob2xkXSBjb2xvciB0aHJlc2hvbGQgZm9yIGdhdWdlIGFuZCB0b29sdGlwIGNvbG9yXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvci50aHJlc2hvbGQudW5pdF0gSWYgc2V0IHRvIGB2YWx1ZWAsIHRoZSB0aHJlc2hvbGQgd2lsbCBiZSBiYXNlZCBvbiB0aGUgZGF0YSB2YWx1ZS4gT3RoZXJ3aXNlIGl0J2xsIGJlIGJhc2VkIG9uIGVxdWF0aW9uIG9mIHRoZSBgdGhyZXNob2xkLm1heGAgb3B0aW9uIHZhbHVlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtjb2xvci50aHJlc2hvbGQudmFsdWVzXSBUaHJlc2hvbGQgdmFsdWVzIGZvciBlYWNoIHN0ZXBzXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb2xvci50aHJlc2hvbGQubWF4PTEwMF0gVGhlIGJhc2UgdmFsdWUgdG8gZGV0ZXJtaW5lIHRocmVzaG9sZCBzdGVwIHZhbHVlIGNvbmRpdGlvbi4gV2hlbiB0aGUgZ2l2ZW4gdmFsdWUgaXMgMTUgYW5kIG1heCAxMCwgdGhlbiB0aGUgdmFsdWUgZm9yIHRocmVzaG9sZCBpcyBgMTUqMTAwLzEwYC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjb2xvcjoge1xyXG5cdCAqICAgICAgcGF0dGVybjogW1wiIzFmNzdiNFwiLCBcIiNhZWM3ZThcIiwgLi4uXSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gU2V0IGNvbG9ycycgcGF0dGVybnNcclxuXHQgKiAgICAgIC8vIGl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgU1ZHUGF0dGVybkVsZW1lbnRcclxuXHQgKiAgICAgIHRpbGVzOiBmdW5jdGlvbigpIHtcclxuXHQgKiAgICAgICAgIHZhciBwYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXR0ZXJuXCIpO1xyXG5cdCAqICAgICAgICAgdmFyIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XHJcblx0ICogICAgICAgICB2YXIgY2lyY2xlMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpO1xyXG5cdCAqXHJcblx0ICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xyXG5cdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjMyXCIpO1xyXG5cdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIzMlwiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgZy5zdHlsZS5maWxsID0gXCIjMDAwXCI7XHJcblx0ICogICAgICAgICBnLnN0eWxlLm9wYWNpdHkgPSBcIjAuMlwiO1xyXG5cdCAqXHJcblx0ICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcImN4XCIsIFwiM1wiKTtcclxuXHQgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiY3lcIiwgXCIzXCIpO1xyXG5cdCAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJyXCIsIFwiM1wiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgZy5hcHBlbmRDaGlsZChjaXJjbGUxKTtcclxuXHQgKiAgICAgICAgIHBhdHRlcm4uYXBwZW5kQ2hpbGQoZyk7XHJcblx0ICpcclxuXHQgKiAgICAgICAgIHJldHVybiBbcGF0dGVybl07XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBmb3IgdGhyZXNob2xkIHVzYWdlLCBwYXR0ZXJuIHZhbHVlcyBzaG91bGQgYmUgc2V0IGZvciBlYWNoIHN0ZXBzXHJcblx0ICogICAgICBwYXR0ZXJuOiBbXCJncmV5XCIsIFwiZ3JlZW5cIiwgXCJ5ZWxsb3dcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl0sXHJcblx0ICogICAgICB0aHJlc2hvbGQ6IHtcclxuXHQgKiAgICAgICAgICB1bml0OiBcInZhbHVlXCIsXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyB3aGVuIHZhbHVlIGlzIDIwID0+ICdncmVlbicsIHZhbHVlIGlzIDQwID0+ICdvcmFuZ2UnIHdpbGwgYmUgc2V0LlxyXG5cdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzAsIDQwLCA1MF0sXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyB0aGUgZXF1YXRpb24gZm9yIG1heDpcclxuXHQgKiAgICAgICAgICAvLyAtIHVuaXQgPT0gJ3ZhbHVlJzogbWF4ID0+IDMwXHJcblx0ICogICAgICAgICAgLy8gLSB1bml0ICE9ICd2YWx1ZSc6IG1heCA9PiB2YWx1ZSoxMDAvMzBcclxuXHQgKiAgICAgICAgICBtYXg6IDMwXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBzZXQgYWxsIGRhdGEgdG8gJ3JlZCdcclxuXHQgKiAgICAgIG9ub3ZlcjogXCJyZWRcIixcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2V0IGRpZmZlcmVudCBjb2xvciBmb3IgZGF0YVxyXG5cdCAqICAgICAgb25vdmVyOiB7XHJcblx0ICogICAgICAgICAgZGF0YTE6IFwicmVkXCIsXHJcblx0ICogICAgICAgICAgZGF0YTI6IFwieWVsbG93XCJcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHdpbGwgcGFzcyBkYXRhIG9iamVjdCB0byB0aGUgY2FsbGJhY2tcclxuXHQgKiAgICAgIG9ub3ZlcjogZnVuY3Rpb24oZCkge1xyXG5cdCAqICAgICAgICAgIHJldHVybiBkLmlkID09PSBcImRhdGExXCIgPyBcInJlZFwiIDogXCJncmVlblwiO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0Y29sb3JfcGF0dGVybjogPChzdHJpbmd8bnVsbClbXT4gW10sXHJcblx0Y29sb3JfdGlsZXM6IDwoKCkgPT4gW10pfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGNvbG9yX3RocmVzaG9sZDogPHt1bml0Pzogc3RyaW5nOyB2YWx1ZXM/OiBudW1iZXJbXTsgbWF4OiBudW1iZXI7fT4ge30sXHJcblx0Y29sb3Jfb25vdmVyOiA8c3RyaW5nfG9iamVjdHx1bmRlZmluZWQ+IHVuZGVmaW5lZFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBpbnRlcmFjdGlvbiBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEludGVyYWN0aW9uIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBpbnRlcmFjdGlvblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gaW50ZXJhY3Rpb24gSW50ZXJzZWN0aW9uIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVyYWN0aW9uLmVuYWJsZWQ9dHJ1ZV0gSW5kaWNhdGUgaWYgdGhlIGNoYXJ0IHNob3VsZCBoYXZlIGludGVyYWN0aW9ucy48YnI+XHJcblx0ICogICAgIElmIGBmYWxzZWAgaXMgc2V0LCBhbGwgb2YgaW50ZXJhY3Rpb25zIChzaG93aW5nL2hpZGluZyB0b29sdGlwLCBzZWxlY3Rpb24sIG1vdXNlIGV2ZW50cywgZXRjKSB3aWxsIGJlIGRpc2FibGVkLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVyYWN0aW9uLmJyaWdodGVuPXRydWVdIE1ha2UgYnJpZ2h0ZXIgZm9yIHRoZSBzZWxlY3RlZCBhcmVhIChleC4gJ3BpZScgdHlwZSBkYXRhIHNlbGVjdGVkIGFyZWEpXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLm1vdXNlPXRydWVdIGVuYWJsZSBvciBkaXNhYmxlIG1vdXNlIGludGVyYWN0aW9uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoPXRydWVdIGVuYWJsZSBvciBkaXNhYmxlICB0b3VjaCBpbnRlcmFjdGlvblxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxudW1iZXJ9IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2gucHJldmVudERlZmF1bHQ9ZmFsc2VdIGVuYWJsZSBvciBkaXNhYmxlIHRvIGNhbGwgZXZlbnQucHJldmVudERlZmF1bHQgb24gdG91Y2hzdGFydCAmIHRvdWNobW92ZSBldmVudC4gSXQncyB1c3VhbGx5IHVzZWQgdG8gcHJldmVudCBkb2N1bWVudCBzY3JvbGxpbmcuXHJcblx0ICogQHNlZSBbRGVtbzogdG91Y2gucHJldmVudERlZmF1bHRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5QcmV2ZW50U2Nyb2xsT25Ub3VjaClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGludGVyYWN0aW9uOiB7XHJcblx0ICogICAgZW5hYmxlZDogZmFsc2UsXHJcblx0ICogICAgYnJpZ2h0ZW46IGZhbHNlLFxyXG5cdCAqICAgIGlucHV0VHlwZToge1xyXG5cdCAqICAgICAgICBtb3VzZTogdHJ1ZSxcclxuXHQgKiAgICAgICAgdG91Y2g6IGZhbHNlXHJcblx0ICpcclxuXHQgKiAgICAgICAgLy8gb3IgZGVjbGFyZSBwcmV2ZW50RGVmYXVsdCBleHBsaWNpdGx5LlxyXG5cdCAqICAgICAgICAvLyBJbiB0aGlzIGNhc2UgdG91Y2ggaW5wdXRUeXBlIGlzIGVuYWJsZWQgYnkgZGVmYXVsdFxyXG5cdCAqICAgICAgICB0b3VjaDoge1xyXG5cdCAqICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcclxuXHQgKlxyXG5cdCAqICAgICAgICAgICAgLy8gb3IgdGhyZXNob2xkIHBpeGVsIHZhbHVlIChwaXhlbCBtb3ZlZCBmcm9tIHRvdWNoc3RhcnQgdG8gdG91Y2htb3ZlKVxyXG5cdCAqICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IDVcclxuXHQgKiAgICAgICAgfVxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0aW50ZXJhY3Rpb25fZW5hYmxlZDogdHJ1ZSxcclxuXHRpbnRlcmFjdGlvbl9icmlnaHRlbjogdHJ1ZSxcclxuXHRpbnRlcmFjdGlvbl9pbnB1dFR5cGVfbW91c2U6IHRydWUsXHJcblx0aW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoOiA8Ym9vbGVhbnx7cHJldmVudERlZmF1bHQ/OiBib29sZWFufG51bWJlcn0+IHt9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGxlZ2VuZCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIExlZ2VuZCBvcHRpb25zXHJcblx0ICogQG5hbWUgbGVnZW5kXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBsZWdlbmQgTGVnZW5kIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xlZ2VuZC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZWdlbmQuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbGVnZW5kLmhpZGU9ZmFsc2VdIEhpZGUgbGVnZW5kXHJcblx0ICogIElmIHRydWUgZ2l2ZW4sIGFsbCBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uIElmIHN0cmluZyBvciBhcnJheSBnaXZlbiwgb25seSB0aGUgbGVnZW5kIHRoYXQgaGFzIHRoZSBpZCB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2xlZ2VuZC5jb250ZW50cy5iaW5kdG89dW5kZWZpbmVkXSBTZXQgQ1NTIHNlbGVjdG9yIG9yIGVsZW1lbnQgcmVmZXJlbmNlIHRvIGJpbmQgbGVnZW5kIGl0ZW1zLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfEZ1bmN0aW9ufSBbbGVnZW5kLmNvbnRlbnRzLnRlbXBsYXRlPXVuZGVmaW5lZF0gU2V0IGl0ZW0ncyB0ZW1wbGF0ZS48YnI+XHJcblx0ICogIC0gSWYgc2V0IGBzdHJpbmdgIHZhbHVlLCB3aXRoaW4gdGVtcGxhdGUgdGhlICdjb2xvcicgYW5kICd0aXRsZScgY2FuIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcclxuXHQgKiAgICAtIHs9Q09MT1J9OiBkYXRhIGNvbG9yIHZhbHVlXHJcblx0ICogICAgLSB7PVRJVExFfTogZGF0YSB0aXRsZSB2YWx1ZVxyXG5cdCAqICAtIElmIHNldCBgZnVuY3Rpb25gIHZhbHVlLCB3aWxsIHBhc3MgZm9sbG93aW5nIGFyZ3VtZW50cyB0byB0aGUgZ2l2ZW4gZnVuY3Rpb246XHJcblx0ICogICAtIHRpdGxlIHtzdHJpbmd9OiBkYXRhJ3MgaWQgdmFsdWVcclxuXHQgKiAgIC0gY29sb3Ige3N0cmluZ306IGNvbG9yIHN0cmluZ1xyXG5cdCAqICAgLSBkYXRhIHtBcnJheX06IGRhdGEgYXJyYXlcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW2xlZ2VuZC5wb3NpdGlvbj1ib3R0b21dIENoYW5nZSB0aGUgcG9zaXRpb24gb2YgbGVnZW5kLjxicj5cclxuXHQgKiAgQXZhaWxhYmxlIHZhbHVlcyBhcmU6IGBib3R0b21gLCBgcmlnaHRgIGFuZCBgaW5zZXRgIGFyZSBzdXBwb3J0ZWQuXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtsZWdlbmQuaW5zZXQ9e2FuY2hvcjogJ3RvcC1sZWZ0Jyx4OiAxMCx5OiAwLHN0ZXA6IHVuZGVmaW5lZH1dIENoYW5nZSBpbnNldCBsZWdlbmQgYXR0cmlidXRlcy48YnI+XHJcblx0ICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgb2JqZWN0IHRoYXQgaGFzIHRoZSBrZXlzIGBhbmNob3JgLCBgeGAsIGB5YCBhbmQgYHN0ZXBgLlxyXG5cdCAqICAtICoqYW5jaG9yKiogZGVjaWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZDpcclxuXHQgKiAgIC0gdG9wLWxlZnRcclxuXHQgKiAgIC0gdG9wLXJpZ2h0XHJcblx0ICogICAtIGJvdHRvbS1sZWZ0XHJcblx0ICogICAtIGJvdHRvbS1yaWdodFxyXG5cdCAqICAtICoqeCoqIGFuZCAqKnkqKjpcclxuXHQgKiAgIC0gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGJhc2VkIG9uIHRoZSBhbmNob3IuXHJcblx0ICogIC0gKipzdGVwKio6XHJcblx0ICogICAtIGRlZmluZXMgdGhlIG1heCBzdGVwIHRoZSBsZWdlbmQgaGFzIChlLmcuIElmIDIgc2V0IGFuZCBsZWdlbmQgaGFzIDMgbGVnZW5kIGl0ZW0sIHRoZSBsZWdlbmQgMiBjb2x1bW5zKS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsZWdlbmQuZXF1YWxseT1mYWxzZV0gU2V0IHRvIGFsbCBpdGVtcyBoYXZlIHNhbWUgd2lkdGggc2l6ZS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsZWdlbmQucGFkZGluZz0wXSBTZXQgcGFkZGluZyB2YWx1ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbmNsaWNrPXVuZGVmaW5lZF0gU2V0IGNsaWNrIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbm92ZXI9dW5kZWZpbmVkXSBTZXQgbW91c2UvdG91Y2ggb3ZlciBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25vdXQ9dW5kZWZpbmVkXSBTZXQgbW91c2UvdG91Y2ggb3V0IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGVnZW5kLml0ZW0udGlsZS53aWR0aD0xMF0gU2V0IHdpZHRoIG9mIGl0ZW0gdGlsZSBlbGVtZW50XHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZWdlbmQuaXRlbS50aWxlLmhlaWdodD0xMF0gU2V0IGhlaWdodCBvZiBpdGVtIHRpbGUgZWxlbWVudFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xlZ2VuZC51c2VQb2ludD1mYWxzZV0gV2hldGhlciB0byB1c2UgY3VzdG9tIHBvaW50cyBpbiBsZWdlbmQuXHJcblx0ICogQHNlZSBbRGVtbzogcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQuTGVnZW5kUG9zaXRpb24pXHJcblx0ICogQHNlZSBbRGVtbzogY29udGVudHMudGVtcGxhdGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQuTGVnZW5kVGVtcGxhdGUxKVxyXG5cdCAqIEBzZWUgW0RlbW86IHVzZVBvaW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLnVzZVBvaW50KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGxlZ2VuZDoge1xyXG5cdCAqICAgICAgc2hvdzogdHJ1ZSxcclxuXHQgKiAgICAgIGhpZGU6IHRydWUsXHJcblx0ICogICAgICAvL29yIGhpZGU6IFwiZGF0YTFcIlxyXG5cdCAqICAgICAgLy9vciBoaWRlOiBbXCJkYXRhMVwiLCBcImRhdGEyXCJdXHJcblx0ICogICAgICBjb250ZW50czoge1xyXG5cdCAqICAgICAgICAgIGJpbmR0bzogXCIjbGVnZW5kXCIsICAgLy8gPHVsIGlkPSdsZWdlbmQnPjwvdWw+XHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyB3aWxsIGJlIGFzOiA8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6IzFmNzdiNCc+ZGF0YTE8L2xpPlxyXG5cdCAqICAgICAgICAgIHRlbXBsYXRlOiBcIjxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjp7PUNPTE9SfSc+ez1USVRMRX08L2xpPlwiXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyBvciB1c2luZyBmdW5jdGlvblxyXG5cdCAqICAgICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbihpZCwgY29sb3IsIGRhdGEpIHtcclxuXHQgKiAgICAgICAgICAgICAgIC8vIGlmIHlvdSB3YW50IG9taXQgc29tZSBsZWdlbmQsIHJldHVybiBmYWxzeSB2YWx1ZVxyXG5cdCAqICAgICAgICAgICAgICAgaWYgKGlkICE9PSBcImRhdGExXCIpIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOlwiKyBjb2xvciArXCI+XCIrIGlkICtcIjwvbGk+XCI7XHJcblx0ICogICAgICAgICAgICAgICB9XHJcblx0ICogICAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLCAgLy8gYm90dG9tLCByaWdodCwgaW5zZXRcclxuXHQgKiAgICAgIGluc2V0OiB7XHJcblx0ICogICAgICAgICAgYW5jaG9yOiBcInRvcC1yaWdodFwiICAvLyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0XHJcblx0ICogICAgICAgICAgeDogMjAsXHJcblx0ICogICAgICAgICAgeTogMTAsXHJcblx0ICogICAgICAgICAgc3RlcDogMlxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIGVxdWFsbHk6IGZhbHNlLFxyXG5cdCAqICAgICAgcGFkZGluZzogMTAsXHJcblx0ICogICAgICBpdGVtOiB7XHJcblx0ICogICAgICAgICAgb25jbGljazogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXHJcblx0ICogICAgICAgICAgb25vdmVyOiBmdW5jdGlvbihpZCkgeyAuLi4gfSxcclxuXHQgKiAgICAgICAgICBvbm91dDogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyBzZXQgdGlsZSdzIHNpemVcclxuXHQgKiAgICAgICAgICB0aWxlOiB7XHJcblx0ICogICAgICAgICAgICAgIHdpZHRoOiAyMCxcclxuXHQgKiAgICAgICAgICAgICAgaGVpZ2h0OiAxNVxyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICB1c2VQb2ludDogdHJ1ZVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0bGVnZW5kX3Nob3c6IHRydWUsXHJcblx0bGVnZW5kX2hpZGU6IGZhbHNlLFxyXG5cdGxlZ2VuZF9jb250ZW50c19iaW5kdG86IDxzdHJpbmd8SFRNTEVsZW1lbnR8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGVnZW5kX2NvbnRlbnRzX3RlbXBsYXRlOiA8c3RyaW5nfCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD51bmRlZmluZWQsXHJcblx0bGVnZW5kX3Bvc2l0aW9uOiA8XCJib3R0b21cInxcInJpZ2h0XCJ8XCJpbnNldFwiPiBcImJvdHRvbVwiLFxyXG5cdGxlZ2VuZF9pbnNldF9hbmNob3I6IDxcInRvcC1sZWZ0XCJ8XCJ0b3AtcmlnaHRcInxcImJvdHRvbS1sZWZ0XCJ8XCJib3R0b20tcmlnaHRcIj4gXCJ0b3AtbGVmdFwiLFxyXG5cdGxlZ2VuZF9pbnNldF94OiAxMCxcclxuXHRsZWdlbmRfaW5zZXRfeTogMCxcclxuXHRsZWdlbmRfaW5zZXRfc3RlcDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRsZWdlbmRfaXRlbV9vbmNsaWNrOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGVnZW5kX2l0ZW1fb25vdmVyOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGVnZW5kX2l0ZW1fb25vdXQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRsZWdlbmRfZXF1YWxseTogZmFsc2UsXHJcblx0bGVnZW5kX3BhZGRpbmc6IDAsXHJcblx0bGVnZW5kX2l0ZW1fdGlsZV93aWR0aDogMTAsXHJcblx0bGVnZW5kX2l0ZW1fdGlsZV9oZWlnaHQ6IDEwLFxyXG5cdGxlZ2VuZF91c2VQb2ludDogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogdGl0bGUgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgdGl0bGUgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIHRpdGxlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aXRsZSBUaXRsZSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlLnRleHRdIFRpdGxlIHRleHQuIElmIGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhayBhbGxvd2luZyBtdWx0aWxpbmUgdGl0bGUuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aXRsZS5wYWRkaW5nLnRvcD0wXSBUb3AgcGFkZGluZyB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3RpdGxlLnBhZGRpbmcucmlnaHQ9MF0gUmlnaHQgcGFkZGluZyB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3RpdGxlLnBhZGRpbmcuYm90dG9tPTBdIEJvdHRvbSBwYWRkaW5nIHZhbHVlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGl0bGUucGFkZGluZy5sZWZ0PTBdIExlZnQgcGFkZGluZyB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlLnBvc2l0aW9uPWNlbnRlcl0gQXZhaWxhYmxlIHZhbHVlcyBhcmU6ICdjZW50ZXInLCAncmlnaHQnIGFuZCAnbGVmdCcuXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1RpdGxlLk11bHRpbGluZWRUaXRsZSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICB0aXRsZToge1xyXG5cdCAqICAgICAgdGV4dDogXCJUaXRsZSBUZXh0XCIsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIG9yIE11bHRpbGluZSB0aXRsZSB0ZXh0XHJcblx0ICogICAgICB0ZXh0OiBcIk1haW4gdGl0bGUgdGV4dFxcblN1YiB0aXRsZSB0ZXh0XCIsXHJcblx0ICpcclxuXHQgKiAgICAgIHBhZGRpbmc6IHtcclxuXHQgKiAgICAgICAgICB0b3A6IDEwLFxyXG5cdCAqICAgICAgICAgIHJpZ2h0OiAxMCxcclxuXHQgKiAgICAgICAgICBib3R0b206IDEwLFxyXG5cdCAqICAgICAgICAgIGxlZnQ6IDEwXHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgcG9zaXRpb246IFwiY2VudGVyXCJcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHRpdGxlX3RleHQ6IDxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0dGl0bGVfcGFkZGluZzoge1xyXG5cdFx0dG9wOiAwLFxyXG5cdFx0cmlnaHQ6IDAsXHJcblx0XHRib3R0b206IDAsXHJcblx0XHRsZWZ0OiAwXHJcblx0fSxcclxuXHR0aXRsZV9wb3NpdGlvbjogPFwiY2VudGVyXCJ8XCJyaWdodFwifFwibGVmdFwiPiBcImNlbnRlclwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHRvb2x0aXAgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBUb29sdGlwIG9wdGlvbnNcclxuXHQgKiBAbmFtZSB0b29sdGlwXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0b29sdGlwIFRvb2x0aXAgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbdG9vbHRpcC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB0b29sdGlwLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXAuZG9Ob3RIaWRlPWZhbHNlXSBNYWtlIHRvb2x0aXAga2VlcCBzaG93aW5nIG5vdCBoaWRpbmcgb24gaW50ZXJhY3Rpb24uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbdG9vbHRpcC5ncm91cGVkPXRydWVdIFNldCBpZiB0b29sdGlwIGlzIGdyb3VwZWQgb3Igbm90IGZvciB0aGUgZGF0YSBwb2ludHMuXHJcblx0ICogICAtICoqTk9URToqKiBUaGUgb3ZlcmxhcHBlZCBkYXRhIHBvaW50cyB3aWxsIGJlIGRpc3BsYXllZCBhcyBncm91cGVkIGV2ZW4gaWYgc2V0IGZhbHNlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXAubGlua2VkPWZhbHNlXSBTZXQgaWYgdG9vbHRpcHMgb24gYWxsIHZpc2libGUgY2hhcnRzIHdpdGggbGlrZSB4IHBvaW50cyBhcmUgc2hvd24gdG9nZXRoZXIgd2hlbiBvbmUgaXMgc2hvd24uXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFt0b29sdGlwLmxpbmtlZC5uYW1lPVwiXCJdIEdyb3BpbmcgbmFtZSBmb3IgbGlua2VkIHRvb2x0aXAuPGJyPklmIHNwZWNpZmllZCwgbGlua2VkIHRvb2x0aXAgd2lsbCBiZSBncm9wZWQgaW50ZXJhY3RpbmcgdG8gYmUgd29ya2VkIG9ubHkgd2l0aCB0aGUgc2FtZSBuYW1lLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC50aXRsZV0gU2V0IGZvcm1hdCBmb3IgdGhlIHRpdGxlIG9mIHRvb2x0aXAuPGJyPlxyXG5cdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgeCBvZiB0aGUgZGF0YSBwb2ludCB0byBzaG93LlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC5uYW1lXSBTZXQgZm9ybWF0IGZvciB0aGUgbmFtZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XHJcblx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBuYW1lLCByYXRpbywgaWQgYW5kIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIHJhdGlvIHdpbGwgYmUgdW5kZWZpbmVkIGlmIHRoZSBjaGFydCBpcyBub3QgZG9udXQvcGllL2dhdWdlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC52YWx1ZV0gU2V0IGZvcm1hdCBmb3IgdGhlIHZhbHVlIG9mIGVhY2ggZGF0YSBpbiB0b29sdGlwLjxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXHJcblx0ICogIElmIHVuZGVmaW5lZCByZXR1cm5lZCwgdGhlIHJvdyBvZiB0aGF0IHZhbHVlIHdpbGwgYmUgc2tpcHBlZC5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5wb3NpdGlvbl0gU2V0IGN1c3RvbSBwb3NpdGlvbiBmdW5jdGlvbiBmb3IgdGhlIHRvb2x0aXAuPGJyPlxyXG5cdCAqICBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgcG9zaXRpb24gYnkgcmV0dXJuaW5nIG9iamVjdCB0aGF0IGhhcyB0b3AgYW5kIGxlZnQuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbnxvYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzXSBTZXQgY3VzdG9tIEhUTUwgZm9yIHRoZSB0b29sdGlwLjxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIGRhdGEsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0IGFuZCBjb2xvciBvZiB0aGUgZGF0YSBwb2ludCB0byBzaG93LiBJZiB0b29sdGlwLmdyb3VwZWQgaXMgdHJ1ZSwgZGF0YSBpbmNsdWRlcyBtdWx0aXBsZSBkYXRhIHBvaW50cy5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW3Rvb2x0aXAuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIHRvb2x0aXAuXHJcblx0ICogIC0gKipOT1RFOioqIFdoZW4gaXMgc3BlY2lmaWVkLCB3aWxsIG5vdCBiZSB1cGRhdGluZyB0b29sdGlwJ3MgcG9zaXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFt0b29sdGlwLmNvbnRlbnRzLnRlbXBsYXRlPXVuZGVmaW5lZF0gU2V0IHRvb2x0aXAncyB0ZW1wbGF0ZS48YnI+PGJyPlxyXG5cdCAqICBXaXRoaW4gdGVtcGxhdGUsIGJlbG93IHN5bnRheCB3aWxsIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcclxuXHQgKiAgICAtICoqe3sgLi4uIH19Kio6IHRoZSBkb3VibHkgY3VybHkgYnJhY2tldHMgaW5kaWNhdGUgbG9vcCBibG9jayBmb3IgZGF0YSByb3dzLlxyXG5cdCAqICAgIC0gKip7PUNMQVNTX1RPT0xUSVB9Kio6IGRlZmF1bHQgdG9vbHRpcCBjbGFzcyBuYW1lIGBiYi10b29sdGlwYC5cclxuXHQgKiAgICAtICoqez1DTEFTU19UT09MVElQX05BTUV9Kio6IGRlZmF1bHQgdG9vbHRpcCBkYXRhIGNsYXNzIG5hbWUgKGV4LiBgYmItdG9vbHRpcC1uYW1lLWRhdGExYClcclxuXHQgKiAgICAtICoqez1USVRMRX0qKjogdGl0bGUgdmFsdWUuXHJcblx0ICogICAgLSAqKns9Q09MT1J9Kio6IGRhdGEgY29sb3IuXHJcblx0ICogICAgLSAqKns9VkFMVUV9Kio6IGRhdGEgdmFsdWUuXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzLnRleHQ9dW5kZWZpbmVkXSBTZXQgYWRkaXRpb25hbCB0ZXh0IGNvbnRlbnQgd2l0aGluIGRhdGEgbG9vcCwgdXNpbmcgdGVtcGxhdGUgc3ludGF4LlxyXG5cdCAqICAtICoqTk9URToqKiBJdCBzaG91bGQgY29udGFpbiBgeyBrZXk6IEFycmF5LCAuLi4gfWAgdmFsdWVcclxuXHQgKiAgICAtICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXHJcblx0ICogICAgLSBUaGUgdmFsdWUgYXJyYXkgbGVuZ3RoIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBkYXRhIGxlbmd0aFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXAuaW5pdC5zaG93PWZhbHNlXSBTaG93IHRvb2x0aXAgYXQgdGhlIGluaXRpYWxpemF0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdG9vbHRpcC5pbml0Lng9MF0gU2V0IHggQXhpcyBpbmRleCB0byBiZSBzaG93biBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFt0b29sdGlwLmluaXQucG9zaXRpb249e3RvcDogXCIwcHhcIixsZWZ0OiBcIjUwcHhcIn1dIFNldCB0aGUgcG9zaXRpb24gb2YgdG9vbHRpcCBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25zaG93XSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgc2hvd24uXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRlXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd25dIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSB0b29sdGlwIGlzIHNob3duXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRkZW5dIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSB0b29sdGlwIGlzIGhpZGRlbi5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xGdW5jdGlvbnxudWxsfSBbdG9vbHRpcC5vcmRlcj1udWxsXSBTZXQgdG9vbHRpcCBkYXRhIGRpc3BsYXkgb3JkZXIuPGJyPjxicj5cclxuXHQgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcclxuXHQgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcclxuXHQgKiAgLSBgbnVsbGA6IEl0IGtlZXBzIHRoZSBkYXRhIGRpc3BsYXkgb3JkZXI8YnI+XHJcblx0ICogICAgICoqTk9URToqKiBXaGVuIGBkYXRhLmdyb3Vwc2AgaXMgc2V0LCB0aGUgb3JkZXIgd2lsbCBmb2xsb3cgYXMgdGhlIHN0YWNrZWQgZ3JhcGggb3JkZXIuPGJyPlxyXG5cdCAqICAgICAgSWYgd2FudCB0byBvcmRlciBhcyBkYXRhIGJvdW5kLCBzZXQgYW55IHZhbHVlIHJhdGhlciB0aGFuIGFzYywgZGVzYyBvciBudWxsLiAoZXguIGVtcHR5IHN0cmluZyBcIlwiKVxyXG5cdCAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBbQXJyYXkuc29ydCBjb21wYXJlRnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQjUGFyYW1ldGVycylcclxuXHQgKiBAc2VlIFtEZW1vOiBIaWRlIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkhpZGVUb29sdGlwKVxyXG5cdCAqIEBzZWUgW0RlbW86IFRvb2x0aXAgR3JvdXBpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBHcm91cGluZylcclxuXHQgKiBAc2VlIFtEZW1vOiBUb29sdGlwIEZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcEZvcm1hdClcclxuXHQgKiBAc2VlIFtEZW1vOiBMaW5rZWQgVG9vbHRpcF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuTGlua2VkVG9vbHRpcHMpXHJcblx0ICogQHNlZSBbRGVtbzogVG9vbHRpcCBUZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcFRlbXBsYXRlKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHRvb2x0aXA6IHtcclxuXHQgKiAgICAgIHNob3c6IHRydWUsXHJcblx0ICogICAgICBkb05vdEhpZGU6IHRydWUsXHJcblx0ICogICAgICBncm91cGVkOiBmYWxzZSxcclxuXHQgKiAgICAgIGZvcm1hdDoge1xyXG5cdCAqICAgICAgICAgIHRpdGxlOiBmdW5jdGlvbih4KSB7IHJldHVybiBcIkRhdGEgXCIgKyB4OyB9LFxyXG5cdCAqICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uKG5hbWUsIHJhdGlvLCBpZCwgaW5kZXgpIHsgcmV0dXJuIG5hbWU7IH0sXHJcblx0ICogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiByYXRpbzsgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbihkYXRhLCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IDB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICBjb250ZW50czogZnVuY3Rpb24oZCwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQsIGNvbG9yKSB7XHJcblx0ICogICAgICAgICAgcmV0dXJuIC4uLiAvLyBmb3JtYXR0ZWQgaHRtbCBhcyB5b3Ugd2FudFxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIHNwZWNpZnkgdG9vbHRpcCBjb250ZW50cyB1c2luZyB0ZW1wbGF0ZVxyXG5cdCAqICAgICAgIC8vIC0gZXhhbXBsZSBvZiBIVE1MIHJldHVybmVkOlxyXG5cdCAqICAgICAgIC8vIDx1bCBjbGFzcz1cImJiLXRvb2x0aXBcIj5cclxuXHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMVwiPjxzcGFuPjI1MDwvc3Bhbj48YnI+PHNwYW4gc3R5bGU9XCJjb2xvcjojMDBjNzNjXCI+ZGF0YTE8L3NwYW4+PC9saT5cclxuXHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMlwiPjxzcGFuPjUwPC9zcGFuPjxicj48c3BhbiBzdHlsZT1cImNvbG9yOiNmYTcxNzFcIj5kYXRhMjwvc3Bhbj48L2xpPlxyXG5cdCAqICAgICAgIC8vIDwvdWw+XHJcblx0ICogICAgICAgY29udGVudHM6IHtcclxuXHQgKiAgICAgIFx0YmluZHRvOiBcIiN0b29sdGlwXCIsXHJcblx0ICogICAgICBcdHRlbXBsYXRlOiAnPHVsIGNsYXNzPXs9Q0xBU1NfVE9PTFRJUH0+e3snICtcclxuXHQgKiAgICAgIFx0XHRcdCc8bGkgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj48c3Bhbj57PVZBTFVFfTwvc3Bhbj48YnI+JyArXHJcblx0ICogICAgICBcdFx0XHQnPHNwYW4gc3R5bGU9Y29sb3I6ez1DT0xPUn0+ez1OQU1FfTwvc3Bhbj48L2xpPicgK1xyXG5cdCAqICAgICAgXHRcdCd9fTwvdWw+J1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogICAgICAgLy8gd2l0aCBhZGRpdGlvbmFsIHRleHQgdmFsdWVcclxuXHQgKiAgICAgICAvLyAtIGV4YW1wbGUgb2YgSFRNTCByZXR1cm5lZDpcclxuXHQgKiAgICAgICAvLyA8dWwgY2xhc3M9XCJiYi10b29sdGlwXCI+XHJcblx0ICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTFcIj48c3Bhbj4yNTA8L3NwYW4+PGJyPmNvbW1lbnQxPHNwYW4gc3R5bGU9XCJjb2xvcjojMDBjNzNjXCI+ZGF0YTE8L3NwYW4+dGV4dDE8L2xpPlxyXG5cdCAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGEyXCI+PHNwYW4+NTA8L3NwYW4+PGJyPmNvbW1lbnQyPHNwYW4gc3R5bGU9XCJjb2xvcjojZmE3MTcxXCI+ZGF0YTI8L3NwYW4+dGV4dDI8L2xpPlxyXG5cdCAqICAgICAgIC8vIDwvdWw+XHJcblx0ICogICAgICAgY29udGVudHM6IHtcclxuXHQgKiAgICAgIFx0YmluZHRvOiBcIiN0b29sdGlwXCIsXHJcblx0ICogICAgICBcdHRleHQ6IHtcclxuXHQgKiAgICAgIFx0XHQvLyBhKSAna2V5JyBuYW1lIGlzIHVzZWQgYXMgc3Vic3RpdHV0aW9uIHdpdGhpbiB0ZW1wbGF0ZSBhcyAnez1LRVl9J1xyXG5cdCAqICAgICAgXHRcdC8vIGIpIHRoZSBsZW5ndGggc2hvdWxkIG1hdGNoIHdpdGggdGhlIGRhdGEgbGVuZ3RoXHJcblx0ICogICAgICBcdFx0VkFSMTogW1widGV4dDFcIiwgXCJ0ZXh0MlwiXSxcclxuXHQgKiAgICAgIFx0XHRWQVIyOiBbXCJjb21tZW50MVwiLCBcImNvbW1lbnQyXCJdLFxyXG5cdCAqICAgICAgXHR9LFxyXG5cdCAqICAgICAgXHR0ZW1wbGF0ZTogJzx1bCBjbGFzcz17PUNMQVNTX1RPT0xUSVB9Pnt7JyArXHJcblx0ICogICAgICBcdFx0XHQnPGxpIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+PHNwYW4+ez1WQUxVRX08L3NwYW4+ez1WQVIyfTxicj4nICtcclxuXHQgKiAgICAgIFx0XHRcdCc8c3BhbiBzdHlsZT1jb2xvcjp7PUNPTE9SfT57PU5BTUV9PC9zcGFuPns9VkFSMX08L2xpPicgK1xyXG5cdCAqICAgICAgXHRcdCd9fTwvdWw+J1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogICAgICAvLyBzb3J0IHRvb2x0aXAgZGF0YSB2YWx1ZSBkaXNwbGF5IGluIGFzY2VuZGluZyBvcmRlclxyXG5cdCAqICAgICAgb3JkZXI6IFwiYXNjXCIsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHNwZWNpZnlpbmcgc29ydCBmdW5jdGlvblxyXG5cdCAqICAgICAgb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcclxuXHQgKiAgICAgICAgIC8vIHBhcmFtIGRhdGEgcGFzc2VkIGZvcm1hdFxyXG5cdCAqICAgICAgICAge3g6IDUsIHZhbHVlOiAyNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA1LCBuYW1lOiBcImRhdGExXCJ9XHJcblx0ICogICAgICAgICAgIC4uLlxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2hvdyBhdCB0aGUgaW5pdGlhbGl6YXRpb25cclxuXHQgKiAgICAgIGluaXQ6IHtcclxuXHQgKiAgICAgICAgICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICAgICAgIHg6IDIsXHJcblx0ICogICAgICAgICAgcG9zaXRpb246IHtcclxuXHQgKiAgICAgICAgICAgICAgdG9wOiBcIjE1MHB4XCIsXHJcblx0ICogICAgICAgICAgICAgIGxlZnQ6IFwiMjUwcHhcIlxyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgc2hvd25cclxuXHQgKiAgICAgIG9uc2hvdzogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuXHQgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXHJcblx0ICpcclxuXHQgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcblx0ICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXHJcblx0ICogICAgICBcdHNlbGVjdGVkRGF0YTtcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgaGlkZGVuXHJcblx0ICogICAgICBvbmhpZGU6IGZ1bmN0aW9uKGN0eCwgc2VsZWN0ZWREYXRhKSB7XHJcblx0ICogICAgICBcdGN0eDsgLy8gY3VycmVudCBjaGFydCBpbnN0YW5jZVxyXG5cdCAqXHJcblx0ICogICAgICBcdC8vIGN1cnJlbnQgZGF0YXNldCBzZWxlY3RlZFxyXG5cdCAqICAgICAgXHQvLyA9PT4gW3t4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMlwifSwgLi4uXVxyXG5cdCAqICAgICAgXHRzZWxlY3RlZERhdGE7XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBmaXJlcyBhZnRlciB0b29sdGlwIGlzIHNob3duXHJcblx0ICogICAgICBvbnNob3duOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xyXG5cdCAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuXHQgKlxyXG5cdCAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcclxuXHQgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuXHQgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gZmlyZXMgYWZ0ZXIgdG9vbHRpcCBpcyBoaWRkZW5cclxuXHQgKiAgICAgIG9uaGlkZGVuOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xyXG5cdCAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuXHQgKlxyXG5cdCAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcclxuXHQgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuXHQgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gTGluayBhbnkgdG9vbHRpcHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgYXJlIG9uIHRoZSBzY3JlZW4gd2hlcmUgc2FtZSB4IGNvb3JkaW5hdGVzIGFyZSBhdmFpbGFibGVcclxuXHQgKiAgICAgIC8vIFVzZWZ1bCBmb3IgdGltZXNlcmllcyBjb3JyZWxhdGlvblxyXG5cdCAqICAgICAgbGlua2VkOiB0cnVlLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBTcGVjaWZ5IG5hbWUgdG8gaW50ZXJhY3QgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIG9ubHkuXHJcblx0ICogICAgICBsaW5rZWQ6IHtcclxuXHQgKiAgICAgICAgICBuYW1lOiBcInNvbWUtZ3JvdXBcIlxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0dG9vbHRpcF9zaG93OiB0cnVlLFxyXG5cdHRvb2x0aXBfZG9Ob3RIaWRlOiBmYWxzZSxcclxuXHR0b29sdGlwX2dyb3VwZWQ6IHRydWUsXHJcblx0dG9vbHRpcF9mb3JtYXRfdGl0bGU6IDwoKCkgPT4gc3RyaW5nKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR0b29sdGlwX2Zvcm1hdF9uYW1lOiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0dG9vbHRpcF9mb3JtYXRfdmFsdWU6IDwoKCkgPT4gbnVtYmVyKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR0b29sdGlwX3Bvc2l0aW9uOiA8KCgpID0+IHt0b3A6IG51bWJlcjsgbGVmdDogbnVtYmVyO30pfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHRvb2x0aXBfY29udGVudHM6IDxcclxuXHRcdFx0KCgpID0+IHN0cmluZyl8e2JpbmR0bzogc3RyaW5nOyB0ZW1wbGF0ZTogc3RyaW5nOyB0ZXh0Pzoge1trZXk6IHN0cmluZ106IHN0cmluZ1tdfX1cclxuXHRcdD4ge30sXHJcblx0dG9vbHRpcF9pbml0X3Nob3c6IGZhbHNlLFxyXG5cdHRvb2x0aXBfaW5pdF94OiAwLFxyXG5cdHRvb2x0aXBfaW5pdF9wb3NpdGlvbjoge1xyXG5cdFx0dG9wOiBcIjBweFwiLFxyXG5cdFx0bGVmdDogXCI1MHB4XCJcclxuXHR9LFxyXG5cdHRvb2x0aXBfbGlua2VkOiBmYWxzZSxcclxuXHR0b29sdGlwX2xpbmtlZF9uYW1lOiBcIlwiLFxyXG5cdHRvb2x0aXBfb25zaG93OiAoKSA9PiB7fSxcclxuXHR0b29sdGlwX29uaGlkZTogKCkgPT4ge30sXHJcblx0dG9vbHRpcF9vbnNob3duOiAoKSA9PiB7fSxcclxuXHR0b29sdGlwX29uaGlkZGVuOiAoKSA9PiB7fSxcclxuXHR0b29sdGlwX29yZGVyOiA8c3RyaW5nfEZ1bmN0aW9ufG51bGw+IG51bGxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQXhpcyBiYXNlZCBjaGFydCBkYXRhIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU3BlY2lmeSB0aGUga2V5IG9mIHggdmFsdWVzIGluIHRoZSBkYXRhLjxicj48YnI+XHJcblx0ICogV2UgY2FuIHNob3cgdGhlIGRhdGEgd2l0aCBub24taW5kZXggeCB2YWx1ZXMgYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gdGhlIHR5cGUgb2YgeCBheGlzIGlzIHRpbWVzZXJpZXMuIElmIHRoaXMgb3B0aW9uIGlzIHNldCBvbiBjYXRlZ29yeSBheGlzLCB0aGUgdmFsdWVzIG9mIHRoZSBkYXRhIG9uIHRoZSBrZXkgd2lsbCBiZSB1c2VkIGZvciBjYXRlZ29yeSBuYW1lcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkeFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHg6IFwiZGF0ZVwiXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfeDogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU3BlY2lmeSB0aGUga2V5cyBvZiB0aGUgeCB2YWx1ZXMgZm9yIGVhY2ggZGF0YS48YnI+PGJyPlxyXG5cdCAqIFRoaXMgb3B0aW9uIGNhbiBiZSB1c2VkIGlmIHdlIHdhbnQgdG8gc2hvdyB0aGUgZGF0YSB0aGF0IGhhcyBkaWZmZXJlbnQgeCB2YWx1ZXMuXHJcblx0ICogQG5hbWUgZGF0YeKApHhzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICB4czoge1xyXG5cdCAqICAgICAgZGF0YTE6IFwieDFcIixcclxuXHQgKiAgICAgIGRhdGEyOiBcIngyXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV94czoge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGZvcm1hdCBzcGVjaWZpZXIgdG8gcGFyc2Ugc3RyaW5nIHNwZWNpZmVkIGFzIHguXHJcblx0ICogQG5hbWUgZGF0YeKApHhGb3JtYXRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgJVktJW0tJWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICB4OiBcInhcIixcclxuXHQgKiAgICBjb2x1bW5zOiBbXHJcblx0ICogICAgICAgIFtcInhcIiwgXCIwMTAxMjAxOVwiLCBcIjAyMDEyMDE5XCIsIFwiMDMwMTIwMTlcIl0sXHJcblx0ICogICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1cclxuXHQgKiAgICBdLFxyXG5cdCAqICAgIC8vIEZvcm1hdCBzcGVjaWZpZXIgdG8gcGFyc2UgYXMgZGF0ZXRpbWUgZm9yIGdpdmVuICd4JyBzdHJpbmcgdmFsdWVcclxuXHQgKiAgICB4Rm9ybWF0OiBcIiVtJWQlWVwiXHJcblx0ICogfSxcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICAgeDoge1xyXG5cdCAqICAgICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICogQHNlZSBbRDMncyB0aW1lIHNwZWNpZmllcl0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUtZm9ybWF0I2xvY2FsZV9mb3JtYXQpXHJcblx0ICovXHJcblx0ZGF0YV94Rm9ybWF0OiBcIiVZLSVtLSVkXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBsb2NhbHRpbWUgZm9ybWF0IHRvIHBhcnNlIHggYXhpcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkeExvY2FsdGltZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgeExvY2FsdGltZTogZmFsc2VcclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV94TG9jYWx0aW1lOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTb3J0IG9uIHggYXhpcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkeFNvcnRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHhTb3J0OiBmYWxzZVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3hTb3J0OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZ3JvdXBzIGZvciB0aGUgZGF0YSBmb3Igc3RhY2tpbmcuXHJcblx0ICogQG5hbWUgZGF0YeKApGdyb3Vwc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IFtdXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBncm91cHM6IFtcclxuXHQgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuXHQgKiAgICAgW1wiZGF0YTNcIl1cclxuXHQgKiAgIF1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9ncm91cHM6IDxzdHJpbmdbXVtdPiBbXSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHkgYXhpcyB0aGUgZGF0YSByZWxhdGVkIHRvLiB5IGFuZCB5MiBjYW4gYmUgdXNlZC5cclxuXHQgKiAtICoqTk9URToqKiBJZiBhbGwgZGF0YSBpcyByZWxhdGVkIHRvIG9uZSBvZiB0aGUgYXhlcywgdGhlIGRvbWFpbiBvZiBheGlzIHdpdGhvdXQgcmVsYXRlZCBkYXRhIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGRvbWFpbiBmcm9tIHRoZSBheGlzIHdpdGggcmVsYXRlZCBkYXRhXHJcblx0ICogQG5hbWUgZGF0YeKApGF4ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGF4ZXM6IHtcclxuXHQgKiAgICAgZGF0YTE6IFwieVwiLFxyXG5cdCAqICAgICBkYXRhMjogXCJ5MlwiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfYXhlczogPHtba2V5OiBzdHJpbmddOiBzdHJpbmd9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxhYmVscyBvcHRpb25zXHJcblx0ICogQG5hbWUgZGF0YeKApGxhYmVsc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gZGF0YSBEYXRhIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RhdGEubGFiZWxzPWZhbHNlXSBTaG93IG9yIGhpZGUgbGFiZWxzIG9uIGVhY2ggZGF0YSBwb2ludHNcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkYXRhLmxhYmVscy5jZW50ZXJlZD1mYWxzZV0gQ2VudGVyaXplIGxhYmVscyBvbiBgYmFyYCBzaGFwZS4gKCoqTk9URToqKiB3b3JrcyBvbmx5IGZvciAnYmFyJyB0eXBlKVxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkYXRhLmxhYmVscy5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZnVuY3Rpb24gZm9yIGRhdGEgbGFiZWxzLjxicj5cclxuXHQgKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9uIHJlY2VpdmVzIDQgYXJndW1lbnRzIHN1Y2ggYXMgdiwgaWQsIGksIGogYW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBhcyB0aGUgbGFiZWwuIFRoZSBhcmd1bWVudHMgYXJlOjxicj5cclxuXHQgKiAgLSBgdmAgaXMgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50IHdoZXJlIHRoZSBsYWJlbCBpcyBzaG93bi5cclxuXHQgKiAgLSBgaWRgIGlzIHRoZSBpZCBvZiB0aGUgZGF0YSB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcblx0ICogIC0gYGlgIGlzIHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcblx0ICogIC0gYGpgIGlzIHRoZSBzdWIgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLjxicj48YnI+XHJcblx0ICogRm9ybWF0dGVyIGZ1bmN0aW9uIGNhbiBiZSBkZWZpbmVkIGZvciBlYWNoIGRhdGEgYnkgc3BlY2lmeWluZyBhcyBhbiBvYmplY3QgYW5kIEQzIGZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgc2V0IChleC4gZDMuZm9ybWF0KCckJykpXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fSBbZGF0YS5sYWJlbHMuY29sb3JzXSBTZXQgbGFiZWwgdGV4dCBjb2xvcnMuXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtkYXRhLmxhYmVscy5wb3NpdGlvbl0gU2V0IGVhY2ggZGF0YXNldCBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGF0YS5sYWJlbHMucG9zaXRpb24ueD0wXSB4IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLnk9MF0geSBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsKVxyXG5cdCAqIEBzZWUgW0RlbW86IGxhYmVsIGNvbG9yc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsQ29sb3JzKVxyXG5cdCAqIEBzZWUgW0RlbW86IGxhYmVsIGZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsRm9ybWF0KVxyXG5cdCAqIEBzZWUgW0RlbW86IGxhYmVsIG92ZXJsYXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbE92ZXJsYXApXHJcblx0ICogQHNlZSBbRGVtbzogbGFiZWwgcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbFBvc2l0aW9uKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgbGFiZWxzOiB0cnVlLFxyXG5cdCAqXHJcblx0ICogICAvLyBvciBzZXQgc3BlY2lmaWMgb3B0aW9uc1xyXG5cdCAqICAgbGFiZWxzOiB7XHJcblx0ICogICAgIGZvcm1hdDogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXHJcblx0ICpcclxuXHQgKiAgICAgLy8gaXQncyBwb3NzaWJsZSB0byBzZXQgZm9yIGVhY2ggZGF0YVxyXG5cdCAqICAgICBmb3JtYXQ6IHtcclxuXHQgKiAgICAgICAgIGRhdGExOiBmdW5jdGlvbih2LCBpZCwgaSwgaikgeyAuLi4gfSxcclxuXHQgKiAgICAgICAgIC4uLlxyXG5cdCAqICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgIC8vIGFsaWduIHRleHQgdG8gY2VudGVyIG9mIHRoZSAnYmFyJyBzaGFwZSAod29ya3Mgb25seSBmb3IgJ2JhcicgdHlwZSlcclxuXHQgKiAgICAgY2VudGVyZWQ6IHRydWUsXHJcblx0ICpcclxuXHQgKiAgICAgLy8gYXBwbHkgZm9yIGFsbCBsYWJlbCB0ZXh0c1xyXG5cdCAqICAgICBjb2xvcnM6IFwicmVkXCIsXHJcblx0ICpcclxuXHQgKiAgICAgLy8gb3Igc2V0IGRpZmZlcmVudCBjb2xvcnMgcGVyIGRhdGFzZXRcclxuXHQgKiAgICAgLy8gZm9yIG5vdCBzcGVjaWZpZWQgZGF0YXNldCwgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IGNvbG9yIHZhbHVlXHJcblx0ICogICAgIGNvbG9yczoge1xyXG5cdCAqICAgICAgICBkYXRhMTogXCJ5ZWxsb3dcIixcclxuXHQgKiAgICAgICAgZGF0YTM6IFwiZ3JlZW5cIlxyXG5cdCAqICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgIC8vIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb25cclxuXHQgKiAgICAgcG9zaXRpb246IHtcclxuXHQgKiAgICAgICAgeDogLTEwLFxyXG5cdCAqICAgICAgICB5OiAxMFxyXG5cdCAqICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgIC8vIG9yIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb24gYnkgZWFjaCBkYXRhc2V0XHJcblx0ICogICAgIHBvc2l0aW9uOiB7XHJcblx0ICogICAgICAgIGRhdGExOiB7eDogNSwgeTogNX0sXHJcblx0ICogICAgICAgIGRhdGEyOiB7eDogMTAsIHk6IC0yMH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2xhYmVsczpcclxuXHRcdDxib29sZWFuIHwge1xyXG5cdFx0XHRjZW50ZXJlZD86IGJvb2xlYW47XHJcblx0XHRcdGZvcm1hdD86IEZ1bmN0aW9uO1xyXG5cdFx0XHRjb2xvcnM/OiBzdHJpbmd8e1trZXk6IHN0cmluZ106IHN0cmluZ307XHJcblx0XHRcdHBvc2l0aW9uPzoge1trZXk6IHN0cmluZ106IG51bWJlcn18e1trZXk6IHN0cmluZ106IHt4PzogbnVtYmVyOyB5PzogbnVtYmVyO319XHJcblx0XHR9PiB7fSxcclxuXHRkYXRhX2xhYmVsc19jb2xvcnM6IDxzdHJpbmd8b2JqZWN0fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGRhdGFfbGFiZWxzX3Bvc2l0aW9uOiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogRGVmaW5lIHJlZ2lvbnMgZm9yIGVhY2ggZGF0YS48YnI+XHJcblx0ICogVGhlIHZhbHVlcyBtdXN0IGJlIGFuIGFycmF5IGZvciBlYWNoIGRhdGEgYW5kIGl0IHNob3VsZCBpbmNsdWRlIGFuIG9iamVjdCB0aGF0IGhhcyBgc3RhcnRgLCBgZW5kYCBhbmQgYHN0eWxlYC5cclxuXHQgKiAtIFRoZSBvYmplY3QgdHlwZSBzaG91bGQgYmUgYXM6XHJcblx0ICogICAtIHN0YXJ0IHtudW1iZXJ9OiBTdGFydCBkYXRhIHBvaW50IG51bWJlci4gSWYgbm90IHNldCwgdGhlIHN0YXJ0IHdpbGwgYmUgdGhlIGZpcnN0IGRhdGEgcG9pbnQuXHJcblx0ICogICAtIFtlbmRdIHtudW1iZXJ9OiBFbmQgZGF0YSBwb2ludCBudW1iZXIuIElmIG5vdCBzZXQsIHRoZSBlbmQgd2lsbCBiZSB0aGUgbGFzdCBkYXRhIHBvaW50LlxyXG5cdCAqICAgLSBbc3R5bGUuZGFzaGFycmF5PVwiMiAyXCJdIHtvYmplY3R9OiBUaGUgZmlyc3QgbnVtYmVyIHNwZWNpZmllcyBhIGRpc3RhbmNlIGZvciB0aGUgZmlsbGVkIGFyZWEsIGFuZCB0aGUgc2Vjb25kIGEgZGlzdGFuY2UgZm9yIHRoZSB1bmZpbGxlZCBhcmVhLlxyXG5cdCAqIC0gKipOT1RFOioqIEN1cnJlbnRseSB0aGlzIG9wdGlvbiBzdXBwb3J0cyBvbmx5IGxpbmUgY2hhcnQgYW5kIGRhc2hlZCBzdHlsZS4gSWYgdGhpcyBvcHRpb24gc3BlY2lmaWVkLCB0aGUgbGluZSB3aWxsIGJlIGRhc2hlZCBvbmx5IGluIHRoZSByZWdpb25zLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRyZWdpb25zXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICByZWdpb25zOiB7XHJcblx0ICogICAgIGRhdGExOiBbe1xyXG5cdCAqICAgICAgICAgc3RhcnQ6IDEsXHJcblx0ICogICAgICAgICBlbmQ6IDIsXHJcblx0ICogICAgICAgICBzdHlsZToge1xyXG5cdCAqICAgICAgICAgICAgIGRhc2hhcnJheTogXCI1IDJcIlxyXG5cdCAqICAgICAgICAgfVxyXG5cdCAqICAgICB9LCB7XHJcblx0ICogICAgICAgICBzdGFydDogM1xyXG5cdCAqICAgICB9XSxcclxuXHQgKiAgICAgLi4uXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfcmVnaW9uczogPHtzdGFydD86IG51bWJlcjsgZW5kPzogbnVtYmVyOyBzdHlsZT86IHtkYXNoYXJyYXk6IHN0cmluZzt9fVtdPiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBzdGFja2luZyB0byBiZSBub3JtYWxpemVkXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gRm9yIHN0YWNraW5nLCAnW2RhdGEuZ3JvdXBzXSgjLmRhdGElMjVFMiUyNTgwJTI1QTRncm91cHMpJyBvcHRpb24gc2hvdWxkIGJlIHNldFxyXG5cdCAqICAgLSB5IEF4aXMgd2lsbCBiZSBzZXQgaW4gcGVyY2VudGFnZSB2YWx1ZSAoMCB+IDEwMCUpXHJcblx0ICogICAtIE11c3QgaGF2ZSBwb3N0aXZlIHZhbHVlc1xyXG5cdCAqIEBuYW1lIGRhdGHigKRzdGFja+KApG5vcm1hbGl6ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhU3RhY2tOb3JtYWxpemVkKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgc3RhY2s6IHtcclxuXHQgKiAgICAgIG5vcm1hbGl6ZTogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3N0YWNrX25vcm1hbGl6ZTogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZGF0YS5zZWxlY3Rpb24gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgZGF0YSBzZWxlY3Rpb24gZW5hYmxlZDxicj48YnI+XHJcblx0ICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRydWUsIHdlIGNhbiBzZWxlY3QgdGhlIGRhdGEgcG9pbnRzIGFuZCBnZXQvc2V0IGl0cyBzdGF0ZSBvZiBzZWxlY3Rpb24gYnkgQVBJIChlLmcuIHNlbGVjdCwgdW5zZWxlY3QsIHNlbGVjdGVkKS5cclxuXHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZW5hYmxlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhU2VsZWN0aW9uKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgIHNlbGVjdGlvbjoge1xyXG5cdCAqICAgICAgIGVuYWJsZWQ6IHRydWVcclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfc2VsZWN0aW9uX2VuYWJsZWQ6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZ3JvdXBlZCBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBtdWx0aXBsZSBkYXRhIHBvaW50cyB0aGF0IGhhdmUgc2FtZSB4IHZhbHVlIHdpbGwgYmUgc2VsZWN0ZWQgYnkgb25lIHNlbGVjdGlvbi5cclxuXHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZ3JvdXBlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICBzZWxlY3Rpb246IHtcclxuXHQgKiAgICAgICBncm91cGVkOiB0cnVlXHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3NlbGVjdGlvbl9ncm91cGVkOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIGVhY2ggZGF0YSBwb2ludCB0byBkZXRlcm1pbmUgaWYgaXQncyBzZWxlY3RhYmxlIG9yIG5vdC48YnI+PGJyPlxyXG5cdCAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgZCBhcyBhbiBhcmd1bWVudCBhbmQgaXQgaGFzIHNvbWUgcGFyYW1ldGVycyBsaWtlIGlkLCB2YWx1ZSwgaW5kZXguIFRoaXMgY2FsbGJhY2sgc2hvdWxkIHJldHVybiBib29sZWFuLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRpc3NlbGVjdGFibGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICBzZWxlY3Rpb246IHtcclxuXHQgKiAgICAgICBpc3NlbGVjdGFibGU6IGZ1bmN0aW9uKGQpIHsgLi4uIH1cclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZTogKCkgPT4gdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG11bHRpcGxlIGRhdGEgcG9pbnRzIHNlbGVjdGlvbiBlbmFibGVkLjxicj48YnI+XHJcblx0ICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpbGUgZGF0YSBwb2ludHMgY2FuIGhhdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGF0IHRoZSBzYW1lIHRpbWUuIElmIGZhbHNlIHNldCwgb25seSBvbmUgZGF0YSBwb2ludCBjYW4gaGF2ZSB0aGUgc2VsZWN0ZWQgc3RhdGUgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSB1bnNlbGVjdGVkIHdoZW4gdGhlIG5ldyBkYXRhIHBvaW50IGlzIHNlbGVjdGVkLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRtdWx0aXBsZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgIHNlbGVjdGlvbjoge1xyXG5cdCAqICAgICAgIG11bHRpcGxlOiBmYWxzZVxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGU6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVuYWJsZSB0byBzZWxlY3QgZGF0YSBwb2ludHMgYnkgZHJhZ2dpbmcuXHJcblx0ICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIGRhdGEgcG9pbnRzIGNhbiBiZSBzZWxlY3RlZCBieSBkcmFnZ2luZy5cclxuXHQgKiAtICoqTk9URToqKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgc2Nyb2xsaW5nIG9uIHRoZSBjaGFydCB3aWxsIGJlIGRpc2FibGVkIGJlY2F1c2UgZHJhZ2dpbmcgZXZlbnQgd2lsbCBoYW5kbGUgdGhlIGV2ZW50LlxyXG5cdCAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRkcmFnZ2FibGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgc2VsZWN0aW9uOiB7XHJcblx0ICogICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGNhbGxiYWNrIGZvciBvbiBkYXRhIHNlbGVjdGlvbi5cclxuXHQgKiBAbmFtZSBkYXRh4oCkb25zZWxlY3RlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb25zZWxlY3RlZDogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG5cdCAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMVwifVxyXG5cdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX29uc2VsZWN0ZWQ6ICgpID0+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3Igb24gZGF0YSB1bi1zZWxlY3Rpb24uXHJcblx0ICogQG5hbWUgZGF0YeKApG9udW5zZWxlY3RlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb251bnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XHJcblx0ICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfb251bnNlbGVjdGVkOiAoKSA9PiB7fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgY2xpcC1wYXRoIGF0dHJpYnV0ZSBmb3IgeCBheGlzIGVsZW1lbnRcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApGNsaXBQYXRoXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gZG9uJ3Qgc2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZVxyXG5cdCAqIGNsaXBQYXRoOiBmYWxzZVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9jbGlwUGF0aDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHggYXhpcy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHNob3dcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0eXBlIG9mIHggYXhpcy48YnI+PGJyPlxyXG5cdCAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqIC0gdGltZXNlcmllc1xyXG5cdCAqIC0gY2F0ZWdvcnlcclxuXHQgKiAtIGluZGV4ZWRcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHR5cGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgaW5kZXhlZFxyXG5cdCAqIEBzZWUgW0RlbW86IGluZGV4ZWRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5BcmVhQ2hhcnQpXHJcblx0ICogQHNlZSBbRGVtbzogdGltZXNlcmllc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlRpbWVzZXJpZXNDaGFydClcclxuXHQgKiBAc2VlIFtEZW1vOiBjYXRlZ29yeV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ2F0ZWdvcnlEYXRhKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdHlwZTogPFwiaW5kZXhlZFwifFwidGltZXNlcmllc1wifFwiY2F0ZWdvcnlcIj4gXCJpbmRleGVkXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBob3cgdG8gdHJlYXQgdGhlIHRpbWV6b25lIG9mIHggdmFsdWVzLjxicj5cclxuXHQgKiBJZiB0cnVlLCB0cmVhdCB4IHZhbHVlIGFzIGxvY2FsdGltZS4gSWYgZmFsc2UsIGNvbnZlcnQgdG8gVVRDIGludGVybmFsbHkuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRsb2NhbHRpbWVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgbG9jYWx0aW1lOiBmYWxzZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfbG9jYWx0aW1lOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2F0ZWdvcnkgbmFtZXMgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBUaGlzIG11c3QgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBjYXRlZ29yeSBuYW1lcyBpbiBzdHJpbmcuIElmIGNhdGVnb3J5IG5hbWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBieSBkYXRhLnggb3B0aW9uLCB0aGlzIGlzIG5vdCByZXF1aXJlZC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApGNhdGVnb3JpZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAZGVmYXVsdCBbXVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICBjYXRlZ29yaWVzOiBbXCJDYXRlZ29yeSAxXCIsIFwiQ2F0ZWdvcnkgMlwiLCAuLi5dXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9jYXRlZ29yaWVzOiA8c3RyaW5nW10+IFtdLFxyXG5cclxuXHQvKipcclxuXHQgKiBjZW50ZXJpemUgdGlja3Mgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjZW50ZXJlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGNlbnRlcmVkOiB0cnVlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfY2VudGVyZWQ6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBBIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aWNrIHZhbHVlLiBGb3JtYXQgc3RyaW5nIGlzIGFsc28gYXZhaWxhYmxlIGZvciB0aW1lc2VyaWVzIGRhdGEuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkZm9ybWF0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb258c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgIC8vIGZvciB0aW1lc2VyaWVzLCBhICdkYXRldGltZScgb2JqZWN0IGlzIGdpdmVuIGFzIHBhcmFtZXRlclxyXG5cdCAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG5cdCAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xyXG5cdCAqICAgICAgIH1cclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIGZvciBjYXRlZ29yeSwgaW5kZXgoTnVtYmVyKSBhbmQgY2F0ZWdvcnlOYW1lKFN0cmluZykgYXJlIGdpdmVuIGFzIHBhcmFtZXRlclxyXG5cdCAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oaW5kZXgsIGNhdGVnb3J5TmFtZSkge1xyXG5cdCAqICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnlOYW1lLnN1YnN0cigwLCAxMCk7XHJcblx0ICogICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgICAvLyBmb3IgdGltZXNlcmllcyBmb3JtYXQgc3BlY2lmaWVyXHJcblx0ICogICAgICAgIGZvcm1hdDogXCIlWS0lbS0lZCAlSDolTTolU1wiXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfZm9ybWF0OiA8RnVuY3Rpb258c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XHJcblx0ICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XHJcblx0ICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueC50aWNrLmN1bGxpbmcubWF4LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmdcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0XHJcblx0ICogLSB0cnVlIGZvciBpbmRleGVkIGF4aXMgYW5kIHRpbWVzZXJpZXMgYXhpc1xyXG5cdCAqIC0gZmFsc2UgZm9yIGNhdGVnb3J5IGF4aXNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfY3VsbGluZzoge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmfigKRtYXhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMTBcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IHtcclxuXHQgKiAgICAgICAgICAgbWF4OiA1XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX2N1bGxpbmdfbWF4OiAxMCxcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG51bWJlciBvZiB4IGF4aXMgdGlja3MgdG8gc2hvdy48YnI+PGJyPlxyXG5cdCAqIFRoaXMgb3B0aW9uIGhpZGVzIHRpY2sgbGluZXMgdG9nZXRoZXIgd2l0aCB0aWNrIHRleHQuIElmIHRoaXMgb3B0aW9uIGlzIHVzZWQgb24gdGltZXNlcmllcyBheGlzLCB0aGUgdGlja3MgcG9zaXRpb24gd2lsbCBiZSBkZXRlcm1pbmVkIHByZWNpc2VseSBhbmQgbm90IG5pY2VseSBwb3NpdGlvbmVkIChlLmcuIGl0IHdpbGwgaGF2ZSByb3VnaCBzZWNvbmQgdmFsdWUpLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGNvdW50XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgY291bnQ6IDVcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja19jb3VudDogPG51bWJlcnx1bmRlZmluZWQ+dW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgbGluZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHNob3c6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfc2hvdzogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIHRleHQuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdGV4dOKApHNob3dcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgeCBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICAgICBwb3NpdGlvbjoge1xyXG5cdCAqICAgICAgICAgICB4OiAxMCxcclxuXHQgKiAgICAgICAgICAgeTogMTBcclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuXHQvKipcclxuXHQgKiBGaXQgeCBheGlzIHRpY2tzLlxyXG5cdCAqIC0gKip0cnVlKio6IHRpY2tzIHdpbGwgYmUgcG9zaXRpb25lZCBuaWNlbHkgdG8gaGF2ZSBzYW1lIGludGVydmFscy5cclxuXHQgKiAtICoqZmFsc2UqKjogdGlja3Mgd2lsbCBiZSBwb3NpdGlvbmVkIGFjY29yZGluZyB0byB4IHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRmaXRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tGaXR0aW5nKVxyXG5cdCAqIEBzZWUgW0RlbW86IGZvciB0aW1lc2VyaWVzIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja1RpbWVzZXJpZXMpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBmaXQ6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfZml0OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIHggdmFsdWVzIG9mIHRpY2tzIG1hbnVhbGx5Ljxicj48YnI+XHJcblx0ICogSWYgdGhpcyBvcHRpb24gaXMgcHJvdmlkZWQsIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja3Mgd2lsbCBiZSBkZXRlcm1pbmVkIGJhc2VkIG9uIHRob3NlIHZhbHVlcy48YnI+XHJcblx0ICogVGhpcyBvcHRpb24gd29ya3Mgd2l0aCBgdGltZXNlcmllc2AgZGF0YSBhbmQgdGhlIHggdmFsdWVzIHdpbGwgYmUgcGFyc2VkIGFjY29kaW5nIHRvIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBhbmQgZGF0YS54Rm9ybWF0IG9wdGlvbi5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR2YWx1ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBudWxsXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB2YWx1ZXM6IFsxLCAyLCA0LCA4LCAxNiwgMzIsIC4uLl0sXHJcblx0ICpcclxuXHQgKiAgICAgICAvLyBhbiBBcnJheSB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWRcclxuXHQgKiAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG5cdCAqICAgICAgIFx0cmV0dXJuIFsgLi4uIF07XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3ZhbHVlczogPChzdHJpbmd8RGF0ZXxudW1iZXIpW118KCgpPT4gbnVtYmVyW10pfG51bGw+IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJvdGF0ZSB4IGF4aXMgdGljayB0ZXh0IGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgZm9yICdjYXRlZ29yeScgYW5kICd0aW1lc2VyaWVzJyB0eXBlIGF4aXMuXHJcblx0ICogLSAqKk5PVEU6KiogVGhlIGNvbmRpdGlvbnMgd2hlcmUgYGF1dG9yb3RhdGVgIGlzIGVuYWJsZWQgYXJlOlxyXG5cdCAqICAgLSBheGlzLngudHlwZT0nY2F0ZWdvcnknIG9yICd0aW1lc2VyaWVzXHJcblx0ICogICAtIGF4aXMueC50aWNrLm11bHRpbGluZT1mYWxzZVxyXG5cdCAqICAgLSBheGlzLngudGljay5jdWxsaW5nPWZhbHNlXHJcblx0ICogICAtIGF4aXMueC50aWNrLmZpdD10cnVlXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkYXV0b3JvdGF0ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tBdXRvcm90YXRlKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgcm90YXRlOiAxNSxcclxuXHQgKiAgICAgICBhdXRvcm90YXRlOiB0cnVlLFxyXG5cdCAqICAgICAgIG11bHRpbGluZTogZmFsc2UsXHJcblx0ICogICAgICAgY3VsbGluZzogZmFsc2UsXHJcblx0ICogICAgICAgZml0OiB0cnVlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfYXV0b3JvdGF0ZTogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJvdGF0ZSB4IGF4aXMgdGljayB0ZXh0LlxyXG5cdCAqIC0gSWYgeW91IHNldCBuZWdhdGl2ZSB2YWx1ZSwgaXQgd2lsbCByb3RhdGUgdG8gb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG5cdCAqIC0gQXBwbGllZCB3aGVuIFtgYXhpcy5yb3RhdGVkYF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0cm90YXRlZCkgb3B0aW9uIGlzIGBmYWxzZWAuXHJcblx0ICogLSBBcyBsb25nIGFzIGBheGlzX3hfdGlja19maXRgIGlzIHNldCB0byBgdHJ1ZWAgaXQgd2lsbCBjYWxjdWxhdGUgYW4gb3ZlcmZsb3cgZm9yIHRoZSB5MiBheGlzIGFuZCBhZGQgdGhpcyB2YWx1ZSB0byB0aGUgcmlnaHQgcGFkZGluZy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRyb3RhdGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlJvdGF0ZVhBeGlzVGlja1RleHQpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICByb3RhdGU6IDYwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfcm90YXRlOiAwLFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IHggYXhpcyBvdXRlciB0aWNrLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG91dGVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBvdXRlcjogZmFsc2VcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja19vdXRlcjogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRpY2sgdGV4dCB0byBiZSBtdWx0aWxpbmVcclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrIGFuZCAnYXhpcy54LnRpY2sud2lkdGgnIG9wdGlvbiBpcyBpZ25vcmVkLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG11bHRpbGluZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja011bHRpbGluZSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIG11bHRpbGluZTogZmFsc2VcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGV4YW1wbGUgb2YgbGluZSBicmVhayB3aXRoICdcXG4nXHJcblx0ICogLy8gSW4gdGhpcyBjYXNlLCAnYXhpcy54LnRpY2sud2lkdGgnIGlzIGlnbm9yZWRcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgeDogXCJ4XCIsXHJcblx0ICogICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgICBbXCJ4XCIsIFwibG9uZ1xcbnRleHRcIiwgXCJBbm90aGVyXFxuTG9uZ1xcblRleHRcIl0sXHJcblx0ICogICAgICAgIC4uLlxyXG5cdCAqICAgIF0sXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX211bHRpbGluZTogdHJ1ZSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aWNrIHdpZHRoXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCB0aGlzIG9wdGlvbiBpcyBpZ25vcmVkLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHdpZHRoXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IG51bGxcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHdpZHRoOiA1MFxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3dpZHRoOiA8bnVtYmVyfG51bGw+IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0byBkaXNwbGF5IHN5c3RlbSB0b29sdGlwKHZpYSAndGl0bGUnIGF0dHJpYnV0ZSkgZm9yIHRpY2sgdGV4dFxyXG5cdCAqIC0gKipOT1RFOioqIE9ubHkgYXZhaWxhYmxlIGZvciBjYXRlZ29yeSBheGlzIHR5cGUgKGBheGlzLngudHlwZT0nY2F0ZWdvcnknYClcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR0b29sdGlwXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdG9vbHRpcDogdHJ1ZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3Rvb2x0aXA6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWF4IHZhbHVlIG9mIHggYXhpcyByYW5nZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApG1heFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IG1heCBTZXQgdGhlIG1heCB2YWx1ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21heC5maXQ9ZmFsc2VdIFdoZW4gc3BlY2lmaWVkIGBtYXgudmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYm91bmQgZGF0YSB2YWx1ZSwgc2V0dGluZyBgdHJ1ZWAgd2lsbCBtYWtlIHggYXhpcyBtYXggdG8gYmUgZml0dGVkIHRvIHRoZSBib3VuZCBkYXRhIG1heCB2YWx1ZS5cclxuXHQgKiAtICoqTk9URToqKiBJZiB0aGUgYm91bmQgZGF0YSBtYXggdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBgbWF4LnZhbHVlYCwgdGhlIHggYXhpcyBtYXggd2lsbCBiZSBsaW1pdGVkIGFzIHRoZSBnaXZlbiBgbWF4LnZhbHVlYC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW21heC52YWx1ZV0gU2V0IHRoZSBtYXggdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgbWF4OiAxMDAsXHJcblx0ICpcclxuXHQgKiAgICAgbWF4OiB7XHJcblx0ICogICAgICAgLy8gJ2ZpdD10cnVlJyB3aWxsIG1ha2UgeCBheGlzIG1heCB0byBiZSBsaW1pdGVkIGFzIHRoZSBib3VuZCBkYXRhIHZhbHVlIG1heCB3aGVuICdtYXgudmFsdWUnIGlzIGdyZWF0ZXIuXHJcblx0ICogICAgICAgLy8gLSB3aGVuIGJvdW5kIGRhdGEgbWF4IGlzICcxMCcgYW5kIG1heC52YWx1ZTogJzEwMCcgPT0+ICB4IGF4aXMgbWF4IHdpbGwgYmUgJzEwJ1xyXG5cdCAqICAgICAgIC8vIC0gd2hlbiBib3VuZCBkYXRhIG1heCBpcyAnMTAwMCcgYW5kIG1heC52YWx1ZTogJzEwMCcgPT0+IHggYXhpcyBtYXggd2lsbCBiZSAnMTAwJ1xyXG5cdCAqICAgICAgIGZpdDogdHJ1ZSxcclxuXHQgKiAgICAgICB2YWx1ZTogMTAwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X21heDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1pbiB2YWx1ZSBvZiB4IGF4aXMgcmFuZ2UuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRtaW5cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW4gU2V0IHRoZSBtaW4gdmFsdWVcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttaW4uZml0PWZhbHNlXSBXaGVuIHNwZWNpZmllZCBgbWluLnZhbHVlYCBpcyBsb3dlciB0aGFuIHRoZSBib3VuZCBkYXRhIHZhbHVlLCBzZXR0aW5nIGB0cnVlYCB3aWxsIG1ha2UgeCBheGlzIG1pbiB0byBiZSBmaXR0ZWQgdG8gdGhlIGJvdW5kIGRhdGEgbWluIHZhbHVlLlxyXG5cdCAqIC0gKipOT1RFOioqIElmIHRoZSBib3VuZCBkYXRhIG1pbiB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBgbWluLnZhbHVlYCwgdGhlIHggYXhpcyBtaW4gd2lsbCBiZSBsaW1pdGVkIGFzIHRoZSBnaXZlbiBgbWluLnZhbHVlYC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW21pbi52YWx1ZV0gU2V0IHRoZSBtaW4gdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgbWluOiAtMTAwLFxyXG5cdCAqXHJcblx0ICogICAgIG1pbjoge1xyXG5cdCAqICAgICAgIC8vICdmaXQ9dHJ1ZScgd2lsbCBtYWtlIHggYXhpcyBtaW4gdG8gYmUgbGltaXRlZCBhcyB0aGUgYm91bmQgZGF0YSB2YWx1ZSBtaW4gd2hlbiAnbWluLnZhbHVlJyBpcyBsb3dlci5cclxuXHQgKiAgICAgICAvLyAtIHdoZW4gYm91bmQgZGF0YSBtaW4gaXMgJy0xMCcgYW5kIG1pbi52YWx1ZTogJy0xMDAnID09PiAgeCBheGlzIG1pbiB3aWxsIGJlICctMTAnXHJcblx0ICogICAgICAgLy8gLSB3aGVuIGJvdW5kIGRhdGEgbWluIGlzICctMTAwMCcgYW5kIG1pbi52YWx1ZTogJy0xMDAnID09PiB4IGF4aXMgbWluIHdpbGwgYmUgJy0xMDAnXHJcblx0ICogICAgICAgZml0OiB0cnVlLFxyXG5cdCAqICAgICAgIHZhbHVlOiAtMTAwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X21pbjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHBhZGRpbmcgZm9yIHggYXhpcy48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIHJhbmdlIG9mIHggYXhpcyB3aWxsIGluY3JlYXNlL2RlY3JlYXNlIGFjY29yZGluZyB0byB0aGUgdmFsdWVzLlxyXG5cdCAqIElmIG5vIHBhZGRpbmcgaXMgbmVlZGVkIGluIHRoZSByYWdlIG9mIHggYXhpcywgMCBzaG91bGQgYmUgc2V0LlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICBUaGUgcGFkZGluZyB2YWx1ZXMgYXJlbid0IGJhc2VkIG9uIHBpeGVscy4gSXQgZGlmZmVycyBhY2NvcmRpbmcgYXhpcyB0eXBlczxicj5cclxuXHQgKiAgIC0gKipjYXRlZ29yeToqKiBUaGUgdW5pdCBvZiB0aWNrIHZhbHVlXHJcblx0ICogICAgIGV4LiB0aGUgZ2l2ZW4gdmFsdWUgYDFgLCBpcyBzYW1lIGFzIHRoZSB3aWR0aCBvZiAxIHRpY2sgd2lkdGhcclxuXHQgKiAgIC0gKip0aW1lc2VyaWVzOioqIE51bWVyaWMgdGltZSB2YWx1ZVxyXG5cdCAqICAgICBleC4gdGhlIGdpdmVuIHZhbHVlIGAxMDAwKjYwKjYwKjI0YCwgd2hpY2ggaXMgbnVtZXJpYyB0aW1lIGVxdWl2YWxlbnQgb2YgYSBkYXksIGlzIHNhbWUgYXMgdGhlIHdpZHRoIG9mIDEgdGljayB3aWR0aFxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkcGFkZGluZ1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdHxudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgcGFkZGluZzoge1xyXG5cdCAqICAgICAgIC8vIHdoZW4gYXhpcyB0eXBlIGlzICdjYXRlZ29yeSdcclxuXHQgKiAgICAgICBsZWZ0OiAxLCAgLy8gc2V0IGxlZnQgcGFkZGluZyB3aWR0aCBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgdGljaydzIHdpZHRoXHJcblx0ICogICAgICAgcmlnaHQ6IDAuNSAgLy8gc2V0IHJpZ2h0IHBhZGRpbmcgd2lkdGggYXMgaGFsZiBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIHRpY2sncyB3aWR0aFxyXG5cdCAqXHJcblx0ICogICAgICAgLy8gd2hlbiBheGlzIHR5cGUgaXMgJ3RpbWVzZXJpZXMnXHJcblx0ICogICAgICAgbGVmdDogMTAwMCo2MCo2MCoyNCwgIC8vIHNldCBsZWZ0IHBhZGRpbmcgd2lkdGggb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcclxuXHQgKiAgICAgICByaWdodDogMTAwMCo2MCo2MCoxMiAgIC8vIHNldCByaWdodCBwYWRkaW5nIHdpZHRoIGFzIGhhbGYgb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcclxuXHQgKiAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cclxuXHQgKiAgICAgcGFkZGluZzogMTBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3BhZGRpbmc6IDxudW1iZXJ8e2xlZnQ/OiBudW1iZXI7IHJpZ2h0PzogbnVtYmVyO30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgaGVpZ2h0IG9mIHggYXhpcy48YnI+PGJyPlxyXG5cdCAqIFRoZSBoZWlnaHQgb2YgeCBheGlzIGNhbiBiZSBzZXQgbWFudWFsbHkgYnkgdGhpcyBvcHRpb24uIElmIHlvdSBuZWVkIG1vcmUgc3BhY2UgZm9yIHggYXhpcywgcGxlYXNlIHVzZSB0aGlzIG9wdGlvbiBmb3IgdGhhdC4gVGhlIHVuaXQgaXMgcGl4ZWwuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRoZWlnaHRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIGhlaWdodDogMjBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X2hlaWdodDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRlZmF1bHQgZXh0ZW50IGZvciBzdWJjaGFydCBhbmQgem9vbS4gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkZXh0ZW50XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIC8vIGV4dGVudCByYW5nZSBhcyBhIHBpeGVsIHZhbHVlXHJcblx0ICogICAgIGV4dGVudDogWzAsIDIwMF0sXHJcblx0ICpcclxuXHQgKiAgICAgLy8gd2hlbiBheGlzIGlzICd0aW1lc2VyaWVzJywgcGFyc2FibGUgZGF0ZXRpbWUgc3RyaW5nXHJcblx0ICogICAgIGV4dGVudDogW1wiMjAxOS0wMy0wMVwiLCBcIjIwMTktMDMtMDVcIl0sXHJcblx0ICpcclxuXHQgKiAgICAgLy8gcmV0dXJuIGV4dGVudCB2YWx1ZVxyXG5cdCAqICAgICBleHRlbnQ6IGZ1bmN0aW9uKGRvbWFpbiwgc2NhbGUpIHtcclxuXHQgKiAgICBcdCB2YXIgZXh0ZW50ID0gZG9tYWluLm1hcChmdW5jdGlvbih2KSB7XHJcblx0ICogICAgIFx0ICAgIHJldHVybiBzY2FsZSh2KTtcclxuXHQgKiAgICAgXHQgfSk7XHJcblx0ICpcclxuXHQgKiAgIFx0IC8vIGl0IHNob3VsZCByZXR1cm4gYSBmb3JtYXQgb2YgYXJyYXlcclxuXHQgKiAgIFx0IC8vIGV4KSBbMCwgNTg0XVxyXG5cdCAqICAgICBcdCByZXR1cm4gZXh0ZW50O1xyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9leHRlbnQ6IDwobnVtYmVyfHN0cmluZylbXXxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxhYmVsIG9uIHggYXhpcy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc2V0IHggYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi5cclxuXHQgKiBgc3RyaW5nYCBhbmQgYG9iamVjdGAgY2FuIGJlIHBhc3NlZCBhbmQgd2UgY2FuIGNoYW5nZSB0aGUgcG9pc2l0b24gYnkgcGFzc2luZyBvYmplY3QgdGhhdCBoYXMgcG9zaXRpb24ga2V5Ljxicj5cclxuXHQgKiBBdmFpbGFibGUgcG9zaXRpb24gZGlmZmVycyBhY2NvcmRpbmcgdG8gdGhlIGF4aXMgZGlyZWN0aW9uICh2ZXJ0aWNhbCBvciBob3Jpem9udGFsKS5cclxuXHQgKiBJZiBzdHJpbmcgc2V0LCB0aGUgcG9zaXRpb24gd2lsbCBiZSB0aGUgZGVmYXVsdC5cclxuXHQgKlxyXG5cdCAqICAtICoqSWYgaXQncyBob3Jpem9udGFsIGF4aXM6KipcclxuXHQgKiAgICAtIGlubmVyLXJpZ2h0IFtkZWZhdWx0XVxyXG5cdCAqICAgIC0gaW5uZXItY2VudGVyXHJcblx0ICogICAgLSBpbm5lci1sZWZ0XHJcblx0ICogICAgLSBvdXRlci1yaWdodFxyXG5cdCAqICAgIC0gb3V0ZXItY2VudGVyXHJcblx0ICogICAgLSBvdXRlci1sZWZ0XHJcblx0ICogIC0gKipJZiBpdCdzIHZlcnRpY2FsIGF4aXM6KipcclxuXHQgKiAgICAtIGlubmVyLXRvcCBbZGVmYXVsdF1cclxuXHQgKiAgICAtIGlubmVyLW1pZGRsZVxyXG5cdCAqICAgIC0gaW5uZXItYm90dG9tXHJcblx0ICogICAgLSBvdXRlci10b3BcclxuXHQgKiAgICAtIG91dGVyLW1pZGRsZVxyXG5cdCAqICAgIC0gb3V0ZXItYm90dG9tXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRsYWJlbFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ3xvYmplY3R9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIGxhYmVsOiBcIllvdXIgWCBBeGlzXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICpcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIGxhYmVsOiB7XHJcblx0ICogICAgICAgIHRleHQ6IFwiWW91ciBYIEF4aXNcIixcclxuXHQgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItY2VudGVyXCJcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfbGFiZWw6IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB4IEF4aXMuXHJcblx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geCBBeGlzIHZhbHVlIGlmIGRvbWFpbiBvcHRpb24gaXNuJ3Qgc2V0LlxyXG5cdCAqXHJcblx0ICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxyXG5cdCAqXHJcblx0ICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqIHwgZG9tYWluIHwgQXJyYXkgfCAtIHwgU2V0IHRoZSBkb21haW4gdmFsdWUgfFxyXG5cdCAqIHwgdGljay5vdXRlciB8IGJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcclxuXHQgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcclxuXHQgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcclxuXHQgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApGF4ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXHJcblx0ICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiB4OiB7XHJcblx0ICogICAgYXhlczogW1xyXG5cdCAqICAgICAge1xyXG5cdCAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB4IEF4aXMgZG9tYWluIHZhbHVlXHJcblx0ICogICAgICAgIGRvbWFpbjogWzAsIDEwMDBdLFxyXG5cdCAqICAgICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxyXG5cdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG5cdCAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICBjb3VudDogMixcclxuXHQgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxyXG5cdCAqICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgLi4uXHJcblx0ICogICAgXVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfYXhlczogPG9iamVjdFtdPltdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHkgQXhpcyAgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgY2xpcC1wYXRoIGF0dHJpYnV0ZSBmb3IgeSBheGlzIGVsZW1lbnRcclxuXHQgKiAtICoqTk9URSoqOiBgY2xpcC1wYXRoYCBhdHRyaWJ1dGUgZm9yIHkgQXhpcyBpcyBzZXQgb25seSB3aGVuIGBheGlzLnkuaW5uZXJgIG9wdGlvbiBpcyB0cnVlLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkY2xpcFBhdGhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuXHQgKiBjbGlwUGF0aDogZmFsc2VcclxuXHQgKi9cclxuXHRheGlzX3lfY2xpcFBhdGg6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB5IGF4aXMuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHNob3c6IGZhbHNlXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9zaG93OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdHlwZSBvZiB5IGF4aXMuPGJyPjxicj5cclxuXHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuXHQgKiAgIC0gdGltZXNlcmllc1xyXG5cdCAqICAgLSBpbmRleGVkXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0eXBlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IFwiaW5kZXhlZFwiXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHR5cGU6IFwidGltZXNlcmllc1wiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90eXBlOiA8XCJpbmRleGVkXCJ8XCJjYXRlZ29yeVwifFwiaW5kZXhlZFwifHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWF4IHZhbHVlIG9mIHkgYXhpcy5cclxuXHQgKiAtICoqTk9URToqKiBQYWRkaW5nIHdpbGwgYmUgYWRkZWQgYmFzZWQgb24gdGhpcyB2YWx1ZSwgc28gaWYgeW91IGRvbid0IG5lZWQgdGhlIHBhZGRpbmcsIHBsZWFzZSBzZXQgYXhpcy55LnBhZGRpbmcgdG8gZGlzYWJsZSBpdCAoZS5nLiBheGlzLnkucGFkZGluZyA9IDApLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkbWF4XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBtYXg6IDEwMDBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X21heDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1pbiB2YWx1ZSBvZiB5IGF4aXMuXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIFBhZGRpbmcgd2lsbCBiZSBhZGRlZCBiYXNlZCBvbiB0aGlzIHZhbHVlLCBzbyBpZiB5b3UgZG9uJ3QgbmVlZCB0aGUgcGFkZGluZywgcGxlYXNlIHNldCBheGlzLnkucGFkZGluZyB0byBkaXNhYmxlIGl0IChlLmcuIGF4aXMueS5wYWRkaW5nID0gMCkuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKRtaW5cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIG1pbjogMTAwMFxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfbWluOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGFuZ2UgdGhlIGRpcmVjdGlvbiBvZiB5IGF4aXMuPGJyPjxicj5cclxuXHQgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkaW52ZXJ0ZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIGludmVydGVkOiB0cnVlXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9pbnZlcnRlZDogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjZW50ZXIgdmFsdWUgb2YgeSBheGlzLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkY2VudGVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBjZW50ZXI6IDBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X2NlbnRlcjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyB5IGF4aXMgaW5zaWRlIG9mIHRoZSBjaGFydC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGlubmVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBpbm5lcjogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfaW5uZXI6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbGFiZWwgb24geSBheGlzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzZXQgeSBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGxhYmVsXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfG9iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7fVxyXG5cdCAqIEBzZWUgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKSBmb3IgcG9zaXRpb24gc3RyaW5nIHZhbHVlLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBsYWJlbDogXCJZb3VyIFkgQXhpc1wiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBsYWJlbDoge1xyXG5cdCAqICAgICAgICB0ZXh0OiBcIllvdXIgWSBBeGlzXCIsXHJcblx0ICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLW1pZGRsZVwiXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X2xhYmVsOiA8c3RyaW5nfG9iamVjdD4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBmb3JtYXR0ZXIgZm9yIHkgYXhpcyB0aWNrIHRleHQuPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGQzLmZvcm1hdCBvYmplY3QgYXMgd2VsbCBhcyBhIGZ1bmN0aW9uIHlvdSBkZWZpbmUuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkZm9ybWF0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuXHQgKiAgICAgICAgICAgcmV0dXJuIHguZ2V0RnVsbFllYXIoKTtcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfZm9ybWF0OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cclxuXHQgKiBJZiB0cnVlIGlzIHNldCwgdGhlIHRpY2tzIHdpbGwgYmUgY3VsbGVkLCB0aGVuIG9ubHkgbGltaXR0ZWQgdGljayB0ZXh0IHdpbGwgYmUgc2hvd24uIFRoaXMgb3B0aW9uIGRvZXMgbm90IGhpZGUgdGhlIHRpY2sgbGluZXMuIElmIGZhbHNlIGlzIHNldCwgYWxsIG9mIHRpY2tzIHdpbGwgYmUgc2hvd24uPGJyPjxicj5cclxuXHQgKiBXZSBjYW4gY2hhbmdlIHRoZSBudW1iZXIgb2YgdGlja3MgdG8gYmUgc2hvd24gYnkgYXhpcy55LnRpY2suY3VsbGluZy5tYXguXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY3VsbGluZ1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfY3VsbGluZzogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGN1bGxpbmfigKRtYXhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgNVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgY3VsbGluZzoge1xyXG5cdCAqICAgICAgICAgICBtYXg6IDVcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfY3VsbGluZ19tYXg6IDUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgeSBheGlzIG91dGVyIHRpY2suXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkb3V0ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIG91dGVyOiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX291dGVyOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgeSBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHZhbHVlc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fEZ1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IG51bGxcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHZhbHVlczogWzEwMCwgMTAwMCwgMTAwMDBdLFxyXG5cdCAqXHJcblx0ICogICAgICAgLy8gYW4gQXJyYXkgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXHJcblx0ICogICAgICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcclxuXHQgKiAgICAgICBcdHJldHVybiBbIC4uLiBdO1xyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfdGlja192YWx1ZXM6IDxudW1iZXJbXXwoKCk9PiBudW1iZXJbXSl8bnVsbD4gbnVsbCxcclxuXHJcblx0LyoqXHJcblx0ICogUm90YXRlIHkgYXhpcyB0aWNrIHRleHQuXHJcblx0ICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcblx0ICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYHRydWVgLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHJvdGF0ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCAwXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICByb3RhdGU6IDYwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfcm90YXRlOiAwLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cclxuXHQgKiAtICoqTk9URToqKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgY2FsY3VsYXRlZCBwcmVjaXNlbHksIHNvIHRoZSB2YWx1ZXMgb24gdGhlIHRpY2tzIHdpbGwgbm90IGJlIHJvdW5kZWQgbmljZWx5LiBJbiB0aGUgY2FzZSwgYXhpcy55LnRpY2suZm9ybWF0IG9yIGF4aXMueS50aWNrLnZhbHVlcyB3aWxsIGJlIGhlbHBmdWwuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY291bnRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjb3VudDogNVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX2NvdW50OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IG9yIGhpZGUgeSBheGlzIHRpY2sgbGluZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHNob3c6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfc2hvdzogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGF4aXMgdGljayBzdGVwKGludGVydmFsKSBzaXplLlxyXG5cdCAqIC0gKipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgYXhpcy55LnRpY2suY291bnRgIG9yIGBheGlzLnkudGljay52YWx1ZXNgIG9wdGlvbnMgYXJlIHNldC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRzdGVwU2l6ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5TdGVwU2l6ZUZvcllBeGlzKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxyXG5cdCAqICAgICAgIC8vIGV4KSAnc3RlcFNpemU9MTUnID09PiBbMCwgMTUsIDMwLCA0NSwgNjBdXHJcblx0ICogICAgICAgc3RlcFNpemU6IDE1XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfc3RlcFNpemU6IDxudW1iZXJ8bnVsbD4gbnVsbCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHkgYXhpcyB0aWNrIHRleHQuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHNob3dcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgeSBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICAgICBwb3NpdGlvbjoge1xyXG5cdCAqICAgICAgICAgICB4OiAxMCxcclxuXHQgKiAgICAgICAgICAgeTogMTBcclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cclxuXHQgKiAtICoqTk9URToqKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgY2FsY3VsYXRlZCBwcmVjaXNlbHksIHNvIHRoZSB2YWx1ZXMgb24gdGhlIHRpY2tzIHdpbGwgbm90IGJlIHJvdW5kZWQgbmljZWx5LiBJbiB0aGUgY2FzZSwgYXhpcy55LnRpY2suZm9ybWF0IG9yIGF4aXMueS50aWNrLnZhbHVlcyB3aWxsIGJlIGhlbHBmdWwuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGltZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aW1lIHRpbWUgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3RpbWUudmFsdWVdIEQzJ3MgdGltZSBpbnRlcnZhbCBmdW5jdGlvbiAoaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUjaW50ZXJ2YWxzKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdGltZToge1xyXG5cdCAqICAgICAgICAgIC8vIHRpY2tzIGF0IDE1LW1pbnV0ZSBpbnRlcnZhbHNcclxuXHQgKiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3RpbWVfdGlja3NcclxuXHQgKiAgICAgICAgICB2YWx1ZTogZDMudGltZU1pbnV0ZS5ldmVyeSgxNSlcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0Ly8gQFRPRE86IG5vdCBmdWxseSBpbXBsZW1lbnRlZCB5ZXRcclxuXHRheGlzX3lfdGlja190aW1lX3ZhbHVlOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBwYWRkaW5nIGZvciB5IGF4aXMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNldCBwYWRkaW5nIGZvciB5IGF4aXMgdG8gY3JlYXRlIG1vcmUgc3BhY2Ugb24gdGhlIGVkZ2Ugb2YgdGhlIGF4aXMuXHJcblx0ICogVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgYW5kIGl0IGNhbiBpbmNsdWRlIHRvcCBhbmQgYm90dG9tLiB0b3AsIGJvdHRvbSB3aWxsIGJlIHRyZWF0ZWQgYXMgcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gR2l2ZW4gdmFsdWVzIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB5IEF4aXMgZG9tYWluIHZhbHVlIGZvciBwYWRkaW5nXHJcblx0ICogICAtIEZvciBhcmVhIGFuZCBiYXIgdHlwZSBjaGFydHMsIFthcmVhLnplcm9iYXNlZF0oIy5hcmVhKSBvciBbYmFyLnplcm9iYXNlZF0oIy5iYXIpIG9wdGlvbnMgc2hvdWxkIGJlIHNldCB0byAnZmFsc2VgIHRvIGdldCBwYWRkZWQgYm90dG9tLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkcGFkZGluZ1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdHxudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgcGFkZGluZzoge1xyXG5cdCAqICAgICAgIHRvcDogMCxcclxuXHQgKiAgICAgICBib3R0b206IDBcclxuXHQgKiAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cclxuXHQgKiAgICAgcGFkZGluZzogMTBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3BhZGRpbmc6IDxudW1iZXJ8e3RvcD86IG51bWJlcjsgYm90dG9tPzogbnVtYmVyO30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZGVmYXVsdCByYW5nZSBvZiB5IGF4aXMuPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHkgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGRlZmF1bHRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9kZWZhdWx0OiA8bnVtYmVyW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhZGRpdGlvbmFsIGF4ZXMgZm9yIHkgQXhpcy5cclxuXHQgKiAtICoqTk9URToqKiBBeGlzJyBzY2FsZSBpcyBiYXNlZCBvbiB5IEF4aXMgdmFsdWUgaWYgZG9tYWluIG9wdGlvbiBpc24ndCBzZXQuXHJcblx0ICpcclxuXHQgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XHJcblx0ICpcclxuXHQgKiB8IE5hbWUgfCBUeXBlIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogfCBkb21haW4gfCBBcnJheSB8IC0gfCBTZXQgdGhlIGRvbWFpbiB2YWx1ZSB8XHJcblx0ICogfCB0aWNrLm91dGVyIHwgYm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxyXG5cdCAqIHwgdGljay5mb3JtYXQgfCBGdW5jdGlvbiB8IC0gfCBTZXQgZm9ybWF0dGVyIGZvciB0aWNrIHRleHQgfFxyXG5cdCAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxyXG5cdCAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkYXhlc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlcylcclxuXHQgKiBAc2VlIFtEZW1vOiBEb21haW5dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlc0RvbWFpbilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIHk6IHtcclxuXHQgKiAgICBheGVzOiBbXHJcblx0ICogICAgICB7XHJcblx0ICogICAgICAgIC8vIGlmIHNldCwgd2lsbCBub3QgYmUgY29ycmVsYXRlZCB3aXRoIHRoZSBtYWluIHkgQXhpcyBkb21haW4gdmFsdWVcclxuXHQgKiAgICAgICAgZG9tYWluOiBbMCwgMTAwMF0sXHJcblx0ICogICAgICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXHJcblx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcblx0ICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIGNvdW50OiAyLFxyXG5cdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXHJcblx0ICogICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICAuLi5cclxuXHQgKiAgICBdXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9heGVzOiA8b2JqZWN0W10+IFtdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHkyIEF4aXMgIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMuXHJcblx0ICogLSAqKk5PVEUqKjpcclxuXHQgKiAgIC0gV2hlbiBzZXQgdG8gYGZhbHNlYCB3aWxsIG5vdCBnZW5lcmF0ZSB5MiBheGlzIG5vZGUuIEluIHRoaXMgY2FzZSwgYWxsICd5MicgYXhpcyByZWxhdGVkIGZ1bmN0aW9uYWxpdHkgd29uJ3Qgd29yayBwcm9wZXJseS5cclxuXHQgKiAgIC0gSWYgbmVlZCB0byB1c2UgJ3kyJyByZWxhdGVkIG9wdGlvbnMgd2hpbGUgeTIgaXNuJ3QgdmlzaWJsZSwgc2V0IHRoZSB2YWx1ZSBgdHJ1ZWAgYW5kIGNvbnRyb2wgdmlzaWJpbGl0eSBieSBjc3MgZGlzcGxheSBwcm9wZXJ0eS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgc2hvdzogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3Nob3c6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWF4IHZhbHVlIG9mIHkyIGF4aXMuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkbWF4XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgbWF4OiAxMDAwXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfbWF4OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWluIHZhbHVlIG9mIHkyIGF4aXMuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkbWluXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgbWluOiAtMTAwMFxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX21pbjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hhbmdlIHRoZSBkaXJlY3Rpb24gb2YgeTIgYXhpcy48YnI+PGJyPlxyXG5cdCAqIElmIHRydWUgc2V0LCB0aGUgZGlyZWN0aW9uIHdpbGwgYmUgZnJvbSB0aGUgdG9wIHRvIHRoZSBib3R0b20uXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkaW52ZXJ0ZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICBpbnZlcnRlZDogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX2ludmVydGVkOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNlbnRlciB2YWx1ZSBvZiB5MiBheGlzLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApGNlbnRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIGNlbnRlcjogMFxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX2NlbnRlcjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyB5MiBheGlzIGluc2lkZSBvZiB0aGUgY2hhcnQuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkaW5uZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICBpbm5lcjogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX2lubmVyOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxhYmVsIG9uIHkyIGF4aXMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNldCB5MiBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRsYWJlbFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ3xvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAc2VlIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkgZm9yIHBvc2l0aW9uIHN0cmluZyB2YWx1ZS5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIGxhYmVsOiBcIllvdXIgWTIgQXhpc1wiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgbGFiZWw6IHtcclxuXHQgKiAgICAgICAgdGV4dDogXCJZb3VyIFkyIEF4aXNcIixcclxuXHQgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX2xhYmVsOiA8c3RyaW5nfG9iamVjdD4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBmb3JtYXR0ZXIgZm9yIHkyIGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XHJcblx0ICogVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS5mb3JtYXQuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGZvcm1hdFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGZvcm1hdDogZDMuZm9ybWF0KFwiJCxcIilcclxuXHQgKiAgICAgICAvL29yIGZvcm1hdDogZnVuY3Rpb24oZCkgeyByZXR1cm4gXCIkXCIgKyBkOyB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX2Zvcm1hdDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XHJcblx0ICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XHJcblx0ICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueS50aWNrLmN1bGxpbmcubWF4LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjdWxsaW5nXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX2N1bGxpbmc6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY3VsbGluZ+KApG1heFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCA1XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgY3VsbGluZzoge1xyXG5cdCAqICAgICAgICAgICBtYXg6IDVcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX2N1bGxpbmdfbWF4OiA1LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IG9yIGhpZGUgeTIgYXhpcyBvdXRlciB0aWNrLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRvdXRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIG91dGVyOiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19vdXRlcjogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHkyIGF4aXMgdGljayB2YWx1ZXMgbWFudWFsbHkuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHZhbHVlc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fEZ1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IG51bGxcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB2YWx1ZXM6IFsxMDAsIDEwMDAsIDEwMDAwXSxcclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIGFuIEFycmF5IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZFxyXG5cdCAqICAgICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XHJcblx0ICogICAgICAgXHRyZXR1cm4gWyAuLi4gXTtcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX3ZhbHVlczogPG51bWJlcltdfCgoKT0+IG51bWJlcltdKXxudWxsPiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBSb3RhdGUgeTIgYXhpcyB0aWNrIHRleHQuXHJcblx0ICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcblx0ICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYHRydWVgLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRyb3RhdGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHJvdGF0ZTogNjBcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3RpY2tfcm90YXRlOiAwLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIG51bWJlciBvZiB5MiBheGlzIHRpY2tzLlxyXG5cdCAqIC0gKipOT1RFOioqIFRoaXMgd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS50aWNrLmNvdW50LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjb3VudFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjb3VudDogNVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19jb3VudDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMgdGljayBsaW5lLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19zaG93OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYXhpcyB0aWNrIHN0ZXAoaW50ZXJ2YWwpIHNpemUuXHJcblx0ICogLSAqKk5PVEU6KiogV2lsbCBiZSBpZ25vcmVkIGlmIGBheGlzLnkyLnRpY2suY291bnRgIG9yIGBheGlzLnkyLnRpY2sudmFsdWVzYCBvcHRpb25zIGFyZSBzZXQuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHN0ZXBTaXplXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlN0ZXBTaXplRm9yWUF4aXMpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxyXG5cdCAqICAgICAgIC8vIGV4KSAnc3RlcFNpemU9MTUnID09PiBbMCwgMTUsIDMwLCA0NSwgNjBdXHJcblx0ICogICAgICAgc3RlcFNpemU6IDE1XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX3N0ZXBTaXplOiA8bnVtYmVyfG51bGw+IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgdGV4dC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkdGV4dOKApHNob3dcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX3RleHRfc2hvdzogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSB5MiBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgICAgIHBvc2l0aW9uOiB7XHJcblx0ICogICAgICAgICAgIHg6IDEwLFxyXG5cdCAqICAgICAgICAgICB5OiAxMFxyXG5cdCAqICAgICAgICAgfVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgcGFkZGluZyBmb3IgeTIgYXhpcy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc2V0IHBhZGRpbmcgZm9yIHkyIGF4aXMgdG8gY3JlYXRlIG1vcmUgc3BhY2Ugb24gdGhlIGVkZ2Ugb2YgdGhlIGF4aXMuXHJcblx0ICogVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgYW5kIGl0IGNhbiBpbmNsdWRlIHRvcCBhbmQgYm90dG9tLiB0b3AsIGJvdHRvbSB3aWxsIGJlIHRyZWF0ZWQgYXMgcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gR2l2ZW4gdmFsdWVzIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB5MiBBeGlzIGRvbWFpbiB2YWx1ZSBmb3IgcGFkZGluZ1xyXG5cdCAqICAgLSBGb3IgYXJlYSBhbmQgYmFyIHR5cGUgY2hhcnRzLCBbYXJlYS56ZXJvYmFzZWRdKCMuYXJlYSkgb3IgW2Jhci56ZXJvYmFzZWRdKCMuYmFyKSBvcHRpb25zIHNob3VsZCBiZSBzZXQgdG8gJ2ZhbHNlYCB0byBnZXQgcGFkZGVkIGJvdHRvbS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRwYWRkaW5nXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fG51bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB7fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgcGFkZGluZzoge1xyXG5cdCAqICAgICAgIHRvcDogMTAwLFxyXG5cdCAqICAgICAgIGJvdHRvbTogMTAwXHJcblx0ICogICAgIH1cclxuXHQgKlxyXG5cdCAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cclxuXHQgKiAgICAgcGFkZGluZzogMTBcclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9wYWRkaW5nOiA8bnVtYmVyfHt0b3A/OiBudW1iZXI7IGJvdHRvbT86IG51bWJlcjt9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRlZmF1bHQgcmFuZ2Ugb2YgeTIgYXhpcy48YnI+PGJyPlxyXG5cdCAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeTIgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRkZWZhdWx0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICBkZWZhdWx0OiBbMCwgMTAwMF1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9kZWZhdWx0OiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhZGRpdGlvbmFsIGF4ZXMgZm9yIHkyIEF4aXMuXHJcblx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geTIgQXhpcyB2YWx1ZSBpZiBkb21haW4gb3B0aW9uIGlzbid0IHNldC5cclxuXHQgKlxyXG5cdCAqIEVhY2ggYXhpcyBvYmplY3Qgc2hvdWxkIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgb3B0aW9uczpcclxuXHQgKlxyXG5cdCAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiB8IGRvbWFpbiB8IEFycmF5IHwgLSB8IFNldCB0aGUgZG9tYWluIHZhbHVlIHxcclxuXHQgKiB8IHRpY2sub3V0ZXIgfCBib29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XHJcblx0ICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XHJcblx0ICogfCB0aWNrLmNvdW50IHwgTnVtYmVyIHwgLSB8IFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcyB8XHJcblx0ICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkYXhlc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlcylcclxuXHQgKiBAc2VlIFtEZW1vOiBEb21haW5dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlc0RvbWFpbilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIHkyOiB7XHJcblx0ICogICAgYXhlczogW1xyXG5cdCAqICAgICAge1xyXG5cdCAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB5MiBBeGlzIGRvbWFpbiB2YWx1ZVxyXG5cdCAqICAgICAgICBkb21haW46IFswLCAxMDAwXSxcclxuXHQgKiAgICAgICAgdGljazoge1xyXG5cdCAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcclxuXHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuXHQgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgY291bnQ6IDIsXHJcblx0ICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cclxuXHQgKiAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIC4uLlxyXG5cdCAqICAgIF1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9heGVzOiBbXVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBXaW5kb3cgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cclxuZXhwb3J0IHt3aW4gYXMgd2luZG93LCBkb2MgYXMgZG9jdW1lbnR9O1xyXG5cclxuY29uc3Qgd2luID0gKCgpID0+IHtcclxuXHRjb25zdCBkZWYgPSBvID0+IHR5cGVvZiBvICE9PSBcInVuZGVmaW5lZFwiICYmIG87XHJcblxyXG5cdHJldHVybiBkZWYoc2VsZikgfHwgZGVmKHdpbmRvdykgfHwgZGVmKGdsb2JhbCkgfHwgZGVmKGdsb2JhbFRoaXMpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcclxufSkoKTtcclxuLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cclxuXHJcbmNvbnN0IGRvYyA9IHdpbiAmJiB3aW4uZG9jdW1lbnQ7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge2V2ZW50IGFzIGQzRXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHticnVzaFNlbGVjdGlvbiBhcyBkM0JydXNoU2VsZWN0aW9ufSBmcm9tIFwiZDMtYnJ1c2hcIjtcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnQsIHdpbmRvd30gZnJvbSBcIi4vYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQge1xyXG5cdGFzSGFsZlBpeGVsLFxyXG5cdGJydXNoRW1wdHksXHJcblx0Y2FsbEZuLFxyXG5cdGNhcGl0YWxpemUsXHJcblx0Y2VpbDEwLFxyXG5cdGNvbnZlcnRJbnB1dFR5cGUsXHJcblx0ZGlmZkRvbWFpbixcclxuXHRlbmRhbGwsXHJcblx0ZW11bGF0ZUV2ZW50LFxyXG5cdGV4dGVuZCxcclxuXHRnZXRCcnVzaFNlbGVjdGlvbixcclxuXHRnZXRCb3VuZGluZ1JlY3QsXHJcblx0Z2V0Q3NzUnVsZXMsXHJcblx0Z2V0TWluTWF4LFxyXG5cdGdldE9wdGlvbixcclxuXHRnZXRQYXRoQm94LFxyXG5cdGdldFJhbmRvbSxcclxuXHRnZXRSYW5nZSxcclxuXHRnZXRSZWN0U2VnTGlzdCxcclxuXHRnZXRUcmFuc2xhdGlvbixcclxuXHRnZXRVbmlxdWUsXHJcblx0aGFzVmFsdWUsXHJcblx0aXNBcnJheSxcclxuXHRpc2Jvb2xlYW4sXHJcblx0aXNEZWZpbmVkLFxyXG5cdGlzRW1wdHksXHJcblx0aXNGdW5jdGlvbixcclxuXHRpc051bWJlcixcclxuXHRpc09iamVjdCxcclxuXHRpc09iamVjdFR5cGUsXHJcblx0aXNTdHJpbmcsXHJcblx0aXNUYWJWaXNpYmxlLFxyXG5cdGlzVW5kZWZpbmVkLFxyXG5cdGlzVmFsdWUsXHJcblx0bWVyZ2VBcnJheSxcclxuXHRtZXJnZU9iaixcclxuXHRub3RFbXB0eSxcclxuXHRwYXJzZURhdGUsXHJcblx0c2FuaXRpc2UsXHJcblx0c2V0VGV4dFZhbHVlLFxyXG5cdHNvcnRWYWx1ZSxcclxuXHR0b0FycmF5LFxyXG5cdHRwbFByb2Nlc3NcclxufTtcclxuXHJcbmNvbnN0IGlzVmFsdWUgPSAodjogYW55KTogYm9vbGVhbiA9PiB2IHx8IHYgPT09IDA7XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xyXG5jb25zdCBpc1N0cmluZyA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiO1xyXG5jb25zdCBpc051bWJlciA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xyXG5jb25zdCBpc1VuZGVmaW5lZCA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiO1xyXG5jb25zdCBpc0RlZmluZWQgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiAhPT0gXCJ1bmRlZmluZWRcIjtcclxuY29uc3QgaXNib29sZWFuID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiO1xyXG5jb25zdCBjZWlsMTAgPSAodjogYW55KTogbnVtYmVyID0+IE1hdGguY2VpbCh2IC8gMTApICogMTA7XHJcbmNvbnN0IGFzSGFsZlBpeGVsID0gKG46IGFueSk6IG51bWJlciA9PiBNYXRoLmNlaWwobikgKyAwLjU7XHJcbmNvbnN0IGRpZmZEb21haW4gPSAoZDogbnVtYmVyW10pOiBudW1iZXIgPT4gZFsxXSAtIGRbMF07XHJcbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcIm9iamVjdFwiO1xyXG5jb25zdCBpc0VtcHR5ID0gKG86IGFueSk6IGJvb2xlYW4gPT4gKFxyXG5cdGlzVW5kZWZpbmVkKG8pIHx8IG8gPT09IG51bGwgfHxcclxuXHQoaXNTdHJpbmcobykgJiYgby5sZW5ndGggPT09IDApIHx8XHJcblx0KGlzT2JqZWN0VHlwZShvKSAmJiAhKG8gaW5zdGFuY2VvZiBEYXRlKSAmJiBPYmplY3Qua2V5cyhvKS5sZW5ndGggPT09IDApIHx8XHJcblx0KGlzTnVtYmVyKG8pICYmIGlzTmFOKG8pKVxyXG4pO1xyXG5jb25zdCBub3RFbXB0eSA9IChvOiBhbnkpOiBib29sZWFuID0+ICFpc0VtcHR5KG8pO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGlzIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBEYXRhIHRvIGJlIGNoZWNrZWRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBpc0FycmF5ID0gKGFycjogYW55KTogYm9vbGVhbiA9PiBBcnJheS5pc0FycmF5KGFycik7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgaXMgb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogRGF0YSB0byBiZSBjaGVja2VkXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaXNPYmplY3QgPSAob2JqOiBhbnkpOiBib29sZWFuID0+IG9iaiAmJiAhb2JqLm5vZGVUeXBlICYmIGlzT2JqZWN0VHlwZShvYmopICYmICFpc0FycmF5KG9iaik7XHJcblxyXG4vKipcclxuICogR2V0IHNwZWNpZmllZCBrZXkgdmFsdWUgZnJvbSBvYmplY3RcclxuICogSWYgZGVmYXVsdCB2YWx1ZSBpcyBnaXZlbiwgd2lsbCByZXR1cm4gaWYgZ2l2ZW4ga2V5IHZhbHVlIG5vdCBmb3VuZFxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBTb3VyY2Ugb2JqZWN0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IHZhbHVlXHJcbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIERlZmF1bHQgdmFsdWVcclxuICogQHJldHVybnMgeyp9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRPcHRpb24ob3B0aW9uczogb2JqZWN0LCBrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlKTogYW55IHtcclxuXHRyZXR1cm4gaXNEZWZpbmVkKG9wdGlvbnNba2V5XSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0VmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWx1ZSBleGlzdCBpbiB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaWN0IFRhcmdldCBvYmplY3QgdG8gYmUgY2hlY2tlZFxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGJlIGNoZWNrZWRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNWYWx1ZShkaWN0OiBvYmplY3QsIHZhbHVlOiBhbnkpOiBib29sZWFuIHtcclxuXHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0T2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChrZXkgPT4gKGRpY3Rba2V5XSA9PT0gdmFsdWUpICYmIChmb3VuZCA9IHRydWUpKTtcclxuXHJcblx0cmV0dXJuIGZvdW5kO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsbCBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50c1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICogQHBhcmFtIHsqfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZTogZm4gaXMgZnVuY3Rpb24sIGZhbHNlOiBmbiBpcyBub3QgZnVuY3Rpb25cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNhbGxGbihmbiwgLi4uYXJncyk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IGlzRm4gPSBpc0Z1bmN0aW9uKGZuKTtcclxuXHJcblx0aXNGbiAmJiBmbi5jYWxsKC4uLmFyZ3MpO1xyXG5cdHJldHVybiBpc0ZuO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsbCBmdW5jdGlvbiBhZnRlciBhbGwgdHJhbnNpdGlvbnMgZW5kc1xyXG4gKiBAcGFyYW0ge2QzLnRyYW5zaXRpb259IHRyYW5zaXRpb24gVHJhbnNpdGlvblxyXG4gKiBAcGFyYW0ge0Z1Y250aW9ufSBjYiBDYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZW5kYWxsKHRyYW5zaXRpb24sIGNiOiBGdW5jdGlvbik6IHZvaWQge1xyXG5cdGxldCBuID0gMDtcclxuXHJcblx0dHJhbnNpdGlvblxyXG5cdFx0LmVhY2goKCkgPT4gKytuKVxyXG5cdFx0Lm9uKFwiZW5kXCIsIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuXHRcdFx0IS0tbiAmJiBjYi5hcHBseSh0aGlzLCAuLi5hcmdzKTtcclxuXHRcdH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwbGFjZSB0YWcgc2lnbiB0byBodG1sIGVudGl0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRhcmdldCBzdHJpbmcgdmFsdWVcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNhbml0aXNlKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gaXNTdHJpbmcoc3RyKSA/XHJcblx0XHRzdHIucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikgOiBzdHI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGV4dCB2YWx1ZS4gSWYgdGhlcmUncyBtdWx0aWxpbmUgYWRkIG5vZGVzLlxyXG4gKiBAcGFyYW0ge2QzU2VsZWN0aW9ufSBub2RlIFRleHQgbm9kZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0IHZhbHVlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge0FycmF5fSBkeSBkeSB2YWx1ZSBmb3IgbXVsdGlsaW5lZCB0ZXh0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9NaWRkbGUgVG8gYmUgYWxpbmduZWQgdmVydGljYWxseSBtaWRkbGVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldFRleHRWYWx1ZShcclxuXHRub2RlOiBkM1NlbGVjdGlvbixcclxuXHR0ZXh0OiBzdHJpbmcsXHJcblx0ZHk6IG51bWJlcltdID0gWy0xLCAxXSxcclxuXHR0b01pZGRsZTogYm9vbGVhbiA9IGZhbHNlXHJcbikge1xyXG5cdGlmICghbm9kZSB8fCAhaXNTdHJpbmcodGV4dCkpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGlmICh0ZXh0LmluZGV4T2YoXCJcXG5cIikgPT09IC0xKSB7XHJcblx0XHRub2RlLnRleHQodGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNvbnN0IGRpZmYgPSBbbm9kZS50ZXh0KCksIHRleHRdLm1hcCh2ID0+IHYucmVwbGFjZSgvW1xcc1xcbl0vZywgXCJcIikpO1xyXG5cclxuXHRcdGlmIChkaWZmWzBdICE9PSBkaWZmWzFdKSB7XHJcblx0XHRcdGNvbnN0IG11bHRpbGluZSA9IHRleHQuc3BsaXQoXCJcXG5cIik7XHJcblx0XHRcdGNvbnN0IGxlbiA9IHRvTWlkZGxlID8gbXVsdGlsaW5lLmxlbmd0aCAtIDEgOiAxO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgcG9zc2libGUgdGV4dFxyXG5cdFx0XHRub2RlLmh0bWwoXCJcIik7XHJcblxyXG5cdFx0XHRtdWx0aWxpbmUuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdG5vZGUuYXBwZW5kKFwidHNwYW5cIilcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBgJHtpID09PSAwID8gZHlbMF0gKiBsZW4gOiBkeVsxXX1lbWApXHJcblx0XHRcdFx0XHQudGV4dCh2KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogU3Vic3RpdHV0aW9uIG9mIFNWR1BhdGhTZWcgQVBJIHBvbHlmaWxsXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSBwYXRoIFRhcmdldCBzdmcgZWxlbWVudFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWN0U2VnTGlzdChwYXRoOiBTVkdHcmFwaGljc0VsZW1lbnQpOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9W10ge1xyXG5cdC8qXHJcblx0ICogc2VnMSAtLS0tLS0tLS0tIHNlZzJcclxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XHJcblx0ICogICB8ICAgICAgICAgICAgICAgfFxyXG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcclxuXHQgKiBzZWcwIC0tLS0tLS0tLS0gc2VnM1xyXG5cdCAqICovXHJcblx0Y29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gcGF0aC5nZXRCQm94KCk7XHJcblxyXG5cdHJldHVybiBbXHJcblx0XHR7eCwgeTogeSArIGhlaWdodH0sIC8vIHNlZzBcclxuXHRcdHt4LCB5fSwgLy8gc2VnMVxyXG5cdFx0e3g6IHggKyB3aWR0aCwgeX0sIC8vIHNlZzJcclxuXHRcdHt4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHR9IC8vIHNlZzNcclxuXHRdO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHN2ZyBib3VuZGluZyBwYXRoIGJveCBkaW1lbnNpb25cclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHBhdGggVGFyZ2V0IHN2ZyBlbGVtZW50XHJcbiAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYXRoQm94KFxyXG5cdHBhdGg6IFNWR0dyYXBoaWNzRWxlbWVudFxyXG4pOiB7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSB7XHJcblx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRjb25zdCBpdGVtcyA9IGdldFJlY3RTZWdMaXN0KHBhdGgpO1xyXG5cdGNvbnN0IHggPSBpdGVtc1swXS54O1xyXG5cdGNvbnN0IHkgPSBNYXRoLm1pbihpdGVtc1swXS55LCBpdGVtc1sxXS55KTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHgsIHksIHdpZHRoLCBoZWlnaHRcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIGJydXNoIHNlbGVjdGlvbiBhcnJheVxyXG4gKiBAcGFyYW0ge29iamVjdH0gJGVsIFNlbGVjdGlvbiBvYmplY3RcclxuICogQHJldHVybnMge2QzLmJydXNoU2VsZWN0aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QnJ1c2hTZWxlY3Rpb24oeyRlbH0pIHtcclxuXHRjb25zdCBldmVudCA9IGQzRXZlbnQ7XHJcblx0Y29uc3QgbWFpbiA9ICRlbC5zdWJjaGFydC5tYWluIHx8ICRlbC5tYWluO1xyXG5cdGxldCBzZWxlY3Rpb247XHJcblxyXG5cdC8vIGNoZWNrIGZyb20gZXZlbnRcclxuXHRpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJicnVzaFwiKSB7XHJcblx0XHRzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb247XHJcblx0Ly8gY2hlY2sgZnJvbSBicnVzaCBhcmVhIHNlbGVjdGlvblxyXG5cdH0gZWxzZSBpZiAobWFpbiAmJiAoc2VsZWN0aW9uID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApLm5vZGUoKSkpIHtcclxuXHRcdHNlbGVjdGlvbiA9IGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBzZWxlY3Rpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYm91bmRpbmdDbGllbnRSZWN0LlxyXG4gKiBDYWNoZSB0aGUgZXZhbHVhdGVkIHZhbHVlIG9uY2UgaXQgd2FzIGNhbGxlZC5cclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUYXJnZXQgZWxlbWVudFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgZ2V0Qm91bmRpbmdSZWN0ID0gKG5vZGUpOiB7XHJcblx0bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsXHJcblx0eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXHJcbn0gPT4gbm9kZS5yZWN0IHx8IChub2RlLnJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxuXHJcbi8qKlxyXG4gKiBSZXRydW4gcmFuZG9tIG51bWJlclxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFzU3RyIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgYXMgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ8c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmFuZG9tKGFzU3RyOiBib29sZWFuID0gdHJ1ZSk6IG51bWJlciB8IHN0cmluZyB7XHJcblx0Y29uc3QgcmFuZCA9IE1hdGgucmFuZG9tKCk7XHJcblxyXG5cdHJldHVybiBhc1N0ciA/IFN0cmluZyhyYW5kKSA6IHJhbmQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBicnVzaCBpcyBlbXB0eVxyXG4gKiBAcGFyYW0ge29iamVjdH0gY3R4IEJ1cnNoIGNvbnRleHRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBicnVzaEVtcHR5KGN0eCk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IHNlbGVjdGlvbiA9IGdldEJydXNoU2VsZWN0aW9uKGN0eCk7XHJcblxyXG5cdGlmIChzZWxlY3Rpb24pIHtcclxuXHRcdC8vIGJydXNoIHNlbGVjdGVkIGFyZWFcclxuXHRcdC8vIHR3by1kaW1lbnNpb25hbDogW1t4MCwgeTBdLCBbeDEsIHkxXV1cclxuXHRcdC8vIG9uZS1kaW1lbnNpb25hbDogW3gwLCB4MV0gb3IgW3kwLCB5MV1cclxuXHRcdHJldHVybiBzZWxlY3Rpb25bMF0gPT09IHNlbGVjdGlvblsxXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0ZW5kIHRhcmdldCBmcm9tIHNvdXJjZSBvYmplY3RcclxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCA9IHt9LCBzb3VyY2UpOiBvYmplY3Qge1xyXG5cdGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuXHRcdHNvdXJjZS5mb3JFYWNoKHYgPT4gZXh0ZW5kKHRhcmdldCwgdikpO1xyXG5cdH1cclxuXHJcblx0Ly8gZXhjbHVkZSBuYW1lIHdpdGggb25seSBudW1iZXJzXHJcblx0Zm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xyXG5cdFx0aWYgKC9eXFxkKyQvLnRlc3QocCkpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGFyZ2V0W3BdID0gc291cmNlW3BdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBmaXJzdCBsZXR0ZXIgY2FwaXRhbGl6ZWRcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUYXJnZXQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNhcGl0YWxpemVkIHN0cmluZ1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FwaXRhbGl6ZSA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcblxyXG4vKipcclxuICogQ29udmVydCB0byBhcnJheVxyXG4gKiBAcGFyYW0ge29iamVjdH0gdiBUYXJnZXQgdG8gYmUgY29udmVydGVkXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvQXJyYXkgPSAodjogQ1NTU3R5bGVEZWNsYXJhdGlvbiB8IGFueSk6IGFueSA9PiBbXS5zbGljZS5jYWxsKHYpO1xyXG5cclxuLyoqXHJcbiAqIEdldCBjc3MgcnVsZXMgZm9yIHNwZWNpZmllZCBzdHlsZXNoZWV0c1xyXG4gKiBAcGFyYW0ge0FycmF5fSBzdHlsZVNoZWV0cyBUaGUgc3R5bGVzaGVldHMgdG8gZ2V0IHRoZSBydWxlcyBmcm9tXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldENzc1J1bGVzKHN0eWxlU2hlZXRzOiBhbnlbXSkge1xyXG5cdGxldCBydWxlcyA9IFtdO1xyXG5cclxuXHRzdHlsZVNoZWV0cy5mb3JFYWNoKHNoZWV0ID0+IHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGlmIChzaGVldC5jc3NSdWxlcyAmJiBzaGVldC5jc3NSdWxlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRydWxlcyA9IHJ1bGVzLmNvbmNhdCh0b0FycmF5KHNoZWV0LmNzc1J1bGVzKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgcmVhZGluZyBydWxlcyBmcm9tICR7c2hlZXQuaHJlZn06ICR7ZS50b1N0cmluZygpfWApO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gcnVsZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBTVkdNYXRyaXggb2YgYW4gU1ZHR0VsZW1lbnRcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBub2RlIE5vZGUgZWxlbWVudFxyXG4gKiBAcmV0dXJucyB7U1ZHTWF0cml4fSBtYXRyaXhcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGdldFRyYW5zbGF0aW9uID0gbm9kZSA9PiB7XHJcblx0Y29uc3QgdHJhbnNmb3JtID0gbm9kZSA/IG5vZGUudHJhbnNmb3JtIDogbnVsbDtcclxuXHRjb25zdCBiYXNlVmFsID0gdHJhbnNmb3JtICYmIHRyYW5zZm9ybS5iYXNlVmFsO1xyXG5cclxuXHRyZXR1cm4gYmFzZVZhbCAmJiBiYXNlVmFsLm51bWJlck9mSXRlbXMgP1xyXG5cdFx0YmFzZVZhbC5nZXRJdGVtKDApLm1hdHJpeCA6XHJcblx0XHR7YTogMCwgYjogMCwgYzogMCwgZDogMCwgZTogMCwgZjogMH07XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHVuaXF1ZSB2YWx1ZSBmcm9tIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgU291cmNlIGRhdGFcclxuICogQHJldHVybnMge0FycmF5fSBVbmlxdWUgYXJyYXkgdmFsdWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFVuaXF1ZShkYXRhOiBhbnlbXSk6IGFueVtdIHtcclxuXHRjb25zdCBpc0RhdGUgPSBkYXRhWzBdIGluc3RhbmNlb2YgRGF0ZTtcclxuXHRjb25zdCBkID0gKGlzRGF0ZSA/IGRhdGEubWFwKE51bWJlcikgOiBkYXRhKVxyXG5cdFx0LmZpbHRlcigodiwgaSwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHYpID09PSBpKTtcclxuXHJcblx0cmV0dXJuIGlzRGF0ZSA/IGQubWFwKHYgPT4gbmV3IERhdGUodikpIDogZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBTb3VyY2UgYXJyYXlcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VBcnJheShhcnI6IGFueVtdKTogYW55W10ge1xyXG5cdHJldHVybiBhcnIgJiYgYXJyLmxlbmd0aCA/IGFyci5yZWR1Y2UoKHAsIGMpID0+IHAuY29uY2F0KGMpKSA6IFtdO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2Ugb2JqZWN0IHJldHVybmluZyBuZXcgb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdFxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0TiBTb3VyY2Ugb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IG1lcmdlZCB0YXJnZXQgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU9iaih0YXJnZXQ6IG9iamVjdCwgLi4ub2JqZWN0Tik6IGFueSB7XHJcblx0aWYgKCFvYmplY3ROLmxlbmd0aCB8fCAob2JqZWN0Ti5sZW5ndGggPT09IDEgJiYgIW9iamVjdE5bMF0pKSB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH1cclxuXHJcblx0Y29uc3Qgc291cmNlID0gb2JqZWN0Ti5zaGlmdCgpO1xyXG5cclxuXHRpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XHJcblx0XHRPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcclxuXHJcblx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuXHRcdFx0XHQhdGFyZ2V0W2tleV0gJiYgKHRhcmdldFtrZXldID0ge30pO1xyXG5cdFx0XHRcdHRhcmdldFtrZXldID0gbWVyZ2VPYmoodGFyZ2V0W2tleV0sIHZhbHVlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGlzQXJyYXkodmFsdWUpID9cclxuXHRcdFx0XHRcdHZhbHVlLmNvbmNhdCgpIDogdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1lcmdlT2JqKHRhcmdldCwgLi4ub2JqZWN0Tik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb3J0IHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgdmFsdWUgdG8gYmUgc29ydGVkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNBc2MgdHJ1ZTogYXNjLCBmYWxzZTogZGVzY1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfHN0cmluZ3xEYXRlfSBzb3J0ZWQgZGF0ZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ydFZhbHVlKGRhdGE6IGFueVtdLCBpc0FzYyA9IHRydWUpOiBhbnlbXSB7XHJcblx0bGV0IGZuO1xyXG5cclxuXHRpZiAoZGF0YVswXSBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdGZuID0gaXNBc2MgPyAoYSwgYikgPT4gYSAtIGIgOiAoYSwgYikgPT4gYiAtIGE7XHJcblx0fSBlbHNlIHtcclxuXHRcdGlmIChpc0FzYyAmJiAhZGF0YS5ldmVyeShpc05hTikpIHtcclxuXHRcdFx0Zm4gPSAoYSwgYikgPT4gYSAtIGI7XHJcblx0XHR9IGVsc2UgaWYgKCFpc0FzYykge1xyXG5cdFx0XHRmbiA9IChhLCBiKSA9PiAoYSA+IGIgJiYgLTEpIHx8IChhIDwgYiAmJiAxKSB8fCAoYSA9PT0gYiAmJiAwKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBkYXRhLmNvbmNhdCgpLnNvcnQoZm4pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IG1pbi9tYXggdmFsdWVcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ21pbicgb3IgJ21heCdcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBcnJheSBkYXRhIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ8RGF0ZXx1bmRlZmluZWR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNaW5NYXgodHlwZTogXCJtaW5cIiB8IFwibWF4XCIsIGRhdGE6IG51bWJlcltdIHwgRGF0ZVtdIHwgYW55KTogbnVtYmVyIHwgRGF0ZSB8IHVuZGVmaW5lZCB8IGFueSB7XHJcblx0bGV0IHJlcyA9IGRhdGEuZmlsdGVyKHYgPT4gbm90RW1wdHkodikpO1xyXG5cclxuXHRpZiAocmVzLmxlbmd0aCkge1xyXG5cdFx0aWYgKGlzTnVtYmVyKHJlc1swXSkpIHtcclxuXHRcdFx0cmVzID0gTWF0aFt0eXBlXSguLi5yZXMpO1xyXG5cdFx0fSBlbHNlIGlmIChyZXNbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdHJlcyA9IHNvcnRWYWx1ZShyZXMsIHR5cGUgPT09IFwibWluXCIpWzBdO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXMgPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHJhbmdlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBudW1iZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFN0ZXAgbnVtYmVyXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGdldFJhbmdlID0gKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzdGVwID0gMSk6IG51bWJlcltdID0+IHtcclxuXHRjb25zdCByZXM6IG51bWJlcltdID0gW107XHJcblx0Y29uc3QgbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCkpIHwgMDtcclxuXHJcblx0Zm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbjsgaSsrKSB7XHJcblx0XHRyZXMucHVzaChzdGFydCArIGkgKiBzdGVwKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXM7XHJcbn07XHJcblxyXG4vLyBlbXVsYXRlIGV2ZW50XHJcbmNvbnN0IGVtdWxhdGVFdmVudCA9IHtcclxuXHRtb3VzZTogKCgpID0+IHtcclxuXHRcdGNvbnN0IGdldFBhcmFtcyA9ICgpID0+ICh7XHJcblx0XHRcdGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgc2NyZWVuWDogMCwgc2NyZWVuWTogMCwgY2xpZW50WDogMCwgY2xpZW50WTogMFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xyXG5cdFx0XHRuZXcgTW91c2VFdmVudChcInRcIik7XHJcblxyXG5cdFx0XHRyZXR1cm4gKGVsOiBTVkdFbGVtZW50IHwgSFRNTEVsZW1lbnQsIGV2ZW50VHlwZTogc3RyaW5nLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xyXG5cdFx0XHRcdGVsLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMpKTtcclxuXHRcdFx0fTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Ly8gUG9seWZpbGxzIERPTTQgTW91c2VFdmVudFxyXG5cdFx0XHRyZXR1cm4gKGVsOiBTVkdFbGVtZW50IHwgSFRNTEVsZW1lbnQsIGV2ZW50VHlwZTogc3RyaW5nLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IG1vdXNlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XHJcblxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2luaXRNb3VzZUV2ZW50XHJcblx0XHRcdFx0bW91c2VFdmVudC5pbml0TW91c2VFdmVudChcclxuXHRcdFx0XHRcdGV2ZW50VHlwZSxcclxuXHRcdFx0XHRcdHBhcmFtcy5idWJibGVzLFxyXG5cdFx0XHRcdFx0cGFyYW1zLmNhbmNlbGFibGUsXHJcblx0XHRcdFx0XHR3aW5kb3csXHJcblx0XHRcdFx0XHQwLCAvLyB0aGUgZXZlbnQncyBtb3VzZSBjbGljayBjb3VudFxyXG5cdFx0XHRcdFx0cGFyYW1zLnNjcmVlblgsIHBhcmFtcy5zY3JlZW5ZLFxyXG5cdFx0XHRcdFx0cGFyYW1zLmNsaWVudFgsIHBhcmFtcy5jbGllbnRZLFxyXG5cdFx0XHRcdFx0ZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGxcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH0pKCksXHJcblx0dG91Y2g6IChlbDogU1ZHRWxlbWVudCB8IEhUTUxFbGVtZW50LCBldmVudFR5cGU6IHN0cmluZywgcGFyYW1zOiBhbnkpID0+IHtcclxuXHRcdGNvbnN0IHRvdWNoT2JqID0gbmV3IFRvdWNoKG1lcmdlT2JqKHtcclxuXHRcdFx0aWRlbnRpZmllcjogRGF0ZS5ub3coKSxcclxuXHRcdFx0dGFyZ2V0OiBlbCxcclxuXHRcdFx0cmFkaXVzWDogMi41LFxyXG5cdFx0XHRyYWRpdXNZOiAyLjUsXHJcblx0XHRcdHJvdGF0aW9uQW5nbGU6IDEwLFxyXG5cdFx0XHRmb3JjZTogMC41XHJcblx0XHR9LCBwYXJhbXMpKTtcclxuXHJcblx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBUb3VjaEV2ZW50KGV2ZW50VHlwZSwge1xyXG5cdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxyXG5cdFx0XHRidWJibGVzOiB0cnVlLFxyXG5cdFx0XHRzaGlmdEtleTogdHJ1ZSxcclxuXHRcdFx0dG91Y2hlczogW3RvdWNoT2JqXSxcclxuXHRcdFx0dGFyZ2V0VG91Y2hlczogW10sXHJcblx0XHRcdGNoYW5nZWRUb3VjaGVzOiBbdG91Y2hPYmpdXHJcblx0XHR9KSk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlICAmIHJldHVybiBib3VuZCBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IHRwbCBUZW1wbGF0ZSBzdHJpbmdcclxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSB2YWx1ZSB0byBiZSByZXBsYWNlZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdHBsUHJvY2Vzcyh0cGw6IHN0cmluZywgZGF0YTogb2JqZWN0KTogc3RyaW5nIHtcclxuXHRsZXQgcmVzID0gdHBsO1xyXG5cclxuXHRmb3IgKGNvbnN0IHggaW4gZGF0YSkge1xyXG5cdFx0cmVzID0gcmVzLnJlcGxhY2UobmV3IFJlZ0V4cChgez0ke3h9fWAsIFwiZ1wiKSwgZGF0YVt4XSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHBhcnNlZCBkYXRlIHZhbHVlXHJcbiAqIChJdCBtdXN0IGJlIGNhbGxlZCBpbiAnQ2hhcnRJbnRlcm5hbCcgY29udGV4dClcclxuICogQHBhcmFtIHtEYXRlfHN0cmluZ3xudW1iZXJ9IGRhdGUgVmFsdWUgb2YgZGF0ZSB0byBiZSBwYXJzZWRcclxuICogQHJldHVybnMge0RhdGV9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZTogRGF0ZSB8IHN0cmluZyB8IG51bWJlciB8IGFueSk6IERhdGUge1xyXG5cdGxldCBwYXJzZWREYXRlO1xyXG5cclxuXHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdHBhcnNlZERhdGUgPSBkYXRlO1xyXG5cdH0gZWxzZSBpZiAoaXNTdHJpbmcoZGF0ZSkpIHtcclxuXHRcdGNvbnN0IHtjb25maWcsIGZvcm1hdH0gPSB0aGlzO1xyXG5cclxuXHRcdHBhcnNlZERhdGUgPSBmb3JtYXQuZGF0YVRpbWUoY29uZmlnLmRhdGFfeEZvcm1hdCkoZGF0ZSk7XHJcblx0fSBlbHNlIGlmIChpc051bWJlcihkYXRlKSAmJiAhaXNOYU4oZGF0ZSkpIHtcclxuXHRcdHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIXBhcnNlZERhdGUgfHwgaXNOYU4oK3BhcnNlZERhdGUpKSB7XHJcblx0XHRjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IgJiZcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBhcnNlIHggJyR7ZGF0ZX0nIHRvIERhdGUgb2JqZWN0YCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcGFyc2VkRGF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBpZiB0aGUgY3VycmVudCBkb2MgaXMgdmlzaWJsZSBvciBub3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1RhYlZpc2libGUoKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuICFkb2N1bWVudC5oaWRkZW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgaW5wdXQgdHlwZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1vdXNlIENvbmZpZyB2YWx1ZTogaW50ZXJhY3Rpb24uaW5wdXRUeXBlLm1vdXNlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG91Y2ggQ29uZmlnIHZhbHVlOiBpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2hcclxuICogQHJldHVybnMge3N0cmluZ30gXCJtb3VzZVwiIHwgXCJ0b3VjaFwiIHwgbnVsbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydElucHV0VHlwZShtb3VzZTogYm9vbGVhbiwgdG91Y2g6IGJvb2xlYW4pOiBcIm1vdXNlXCIgfCBcInRvdWNoXCIgfCBudWxsIHtcclxuXHRsZXQgaXNNb2JpbGUgPSBmYWxzZTtcclxuXHJcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Ccm93c2VyX2RldGVjdGlvbl91c2luZ190aGVfdXNlcl9hZ2VudCNNb2JpbGVfVGFibGV0X29yX0Rlc2t0b3BcclxuXHRpZiAoL01vYmkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpICYmIHRvdWNoKSB7XHJcblx0XHQvLyBTb21lIEVkZ2UgZGVza3RvcCByZXR1cm4gdHJ1ZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMjA0MTcwNzQvXHJcblx0XHRjb25zdCBoYXNUb3VjaFBvaW50cyA9IHdpbmRvdy5uYXZpZ2F0b3IgJiYgXCJtYXhUb3VjaFBvaW50c1wiIGluIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XHJcblxyXG5cdFx0Ly8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvdG91Y2hldmVudHMuanNcclxuXHRcdC8vIE9uIElFMTEgd2l0aCBJRTkgZW11bGF0aW9uIG1vZGUsICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIGlzIHJldHVybmluZyB0cnVlXHJcblx0XHRjb25zdCBoYXNUb3VjaCA9IChcIm9udG91Y2htb3ZlXCIgaW4gd2luZG93IHx8ICh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG5cdFx0aXNNb2JpbGUgPSBoYXNUb3VjaFBvaW50cyB8fCBoYXNUb3VjaDtcclxuXHR9XHJcblxyXG5cdGNvbnN0IGhhc01vdXNlID0gbW91c2UgJiYgIWlzTW9iaWxlID8gKFwib25tb3VzZW92ZXJcIiBpbiB3aW5kb3cpIDogZmFsc2U7XHJcblxyXG5cdHJldHVybiAoaGFzTW91c2UgJiYgXCJtb3VzZVwiKSB8fCAoaXNNb2JpbGUgJiYgXCJ0b3VjaFwiKSB8fCBudWxsO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHggZnJvbSBcIi4veFwiO1xyXG5pbXBvcnQgeSBmcm9tIFwiLi95XCI7XHJcbmltcG9ydCB5MiBmcm9tIFwiLi95MlwiO1xyXG5cclxuaW1wb3J0IHttZXJnZU9ian0gZnJvbSBcIi4uLy4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogeSBBeGlzICBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgbWVyZ2VPYmooe1xyXG5cdC8qKlxyXG5cdCAqIFN3aXRjaCB4IGFuZCB5IGF4aXMgcG9zaXRpb24uXHJcblx0ICogQG5hbWUgYXhpc+KApHJvdGF0ZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICByb3RhdGVkOiB0cnVlXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfcm90YXRlZDogZmFsc2VcclxufSwgeCwgeSwgeTIpO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBncmlkIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG50eXBlIExpbmVzID0ge3ZhbHVlPzogbnVtYmVyOyB0ZXh0Pzogc3RyaW5nOyBjbGFzcz86IHN0cmluZzsgcG9zaXRpb24/OiBzdHJpbmd9W107XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHJlbGF0ZWQgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGdyaWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZnJvbnQ9ZmFsc2VdIFNldCAnZ3JpZCAmIGZvY3VzIGxpbmVzJyB0byBiZSBwb3NpdGlvbmVkIG92ZXIgZ3JpZCBsaW5lcyBhbmQgY2hhcnQgZWxlbWVudHMuXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHggR3JpZCB4IG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3guc2hvdz1mYWxzZV0gU2hvdyBncmlkcyBhbG9uZyB4IGF4aXMuXHJcblx0ICogQHByb3BlcnR5IHtBcnJheX0gW3gubGluZXM9W11dIFNob3cgYWRkaXRpb25hbCBncmlkIGxpbmVzIGFsb25nIHggYXhpcy48YnI+XHJcblx0ICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyB2YWx1ZSwgdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzLiB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLiBGb3IgcG9zaXRpb24sIHN0YXJ0LCBtaWRkbGUgYW5kIGVuZCAoZGVmYXVsdCkgYXJlIGF2YWlsYWJsZS5cclxuXHQgKiAgSWYgeCBheGlzIGlzIGNhdGVnb3J5IGF4aXMsIHZhbHVlIGNhbiBiZSBjYXRlZ29yeSBuYW1lLiBJZiB4IGF4aXMgaXMgdGltZXNlcmllcyBheGlzLCB2YWx1ZSBjYW4gYmUgZGF0ZSBzdHJpbmcsIERhdGUgb2JqZWN0IGFuZCB1bml4dGltZSBpbnRlZ2VyLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB5IEdyaWQgeSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt5LnNob3c9ZmFsc2VdIFNob3cgZ3JpZHMgYWxvbmcgeCBheGlzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt5LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB5IGF4aXMuPGJyPlxyXG5cdCAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgdmFsdWUsIHRleHQsIHBvc2l0aW9uIGFuZCBjbGFzcy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3kudGlja3M9MTBdIE51bWJlciBvZiB5IGdyaWRzIHRvIGJlIHNob3duLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBmb2N1cyBHcmlkIGZvY3VzIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZvY3VzLmVkZ2U9ZmFsc2VdIFNob3cgZWRnZWQgZm9jdXMgZ3JpZCBsaW5lLjxicj4qKk5PVEU6KiogQXZhaWxhYmxlIHdoZW4gW2B0b29sdGlwLmdyb3VwZWQ9ZmFsc2VgXSgjLnRvb2x0aXApIG9wdGlvbiBpcyBzZXQuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZm9jdXMuc2hvdz10cnVlXSBTaG93IGdyaWQgbGluZSB3aGVuIGZvY3VzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZvY3VzLnk9ZmFsc2VdIFNob3cgeSBjb29yZGluYXRlIGZvY3VzIGdyaWQgbGluZS48YnI+KipOT1RFOioqIEF2YWlsYWJsZSB3aGVuIFtgdG9vbHRpcC5ncm91cGVkPWZhbHNlYF0oIy50b29sdGlwKSBvcHRpb24gaXMgc2V0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBsaW5lcyBHcmlkIGxpbmVzIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpbmVzLmZyb250PXRydWVdIFNldCBncmlkIGxpbmVzIHRvIGJlIHBvc2l0aW9uZWQgb3ZlciBjaGFydCBlbGVtZW50cy5cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5HcmlkTGluZXMpXHJcblx0ICogQHNlZSBbRGVtbzogWCBHcmlkIExpbmVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5PcHRpb25hbFhHcmlkTGluZXMpXHJcblx0ICogQHNlZSBbRGVtbzogWSBHcmlkIExpbmVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5PcHRpb25hbFlHcmlkTGluZXMpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBncmlkOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHNob3c6IHRydWUsXHJcblx0ICogICAgIGxpbmVzOiBbXHJcblx0ICogICAgICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIG9uIDJcIn0sXHJcblx0ICogICAgICAge3ZhbHVlOiA1LCB0ZXh0OiBcIkxhYmVsIG9uIDVcIiwgY2xhc3M6IFwibGFiZWwtNVwifSxcclxuXHQgKiAgICAgICB7dmFsdWU6IDYsIHRleHQ6IFwiTGFiZWwgb24gNlwiLCBwb3NpdGlvbjogXCJzdGFydFwifVxyXG5cdCAqICAgICBdXHJcblx0ICogICB9LFxyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICBsaW5lczogW1xyXG5cdCAqICAgICAgIHt2YWx1ZTogMTAwLCB0ZXh0OiBcIkxhYmVsIG9uIDEwMFwifSxcclxuXHQgKiAgICAgICB7dmFsdWU6IDIwMCwgdGV4dDogXCJMYWJlbCBvbiAyMDBcIiwgY2xhc3M6IFwibGFiZWwtMjAwXCJ9LFxyXG5cdCAqICAgICAgIHt2YWx1ZTogMzAwLCB0ZXh0OiBcIkxhYmVsIG9uIDMwMFwiLCBwb3NpdGlvbjogJ21pZGRsZSd9XHJcblx0ICogICAgIF0sXHJcblx0ICogICAgIHRpY2tzOiA1XHJcblx0ICogICB9LFxyXG5cdCAqICAgZnJvbnQ6IHRydWUsXHJcblx0ICogICBmb2N1czoge1xyXG5cdCAqICAgICAgc2hvdzogZmFsc2UsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIEJlbG93IG9wdGlvbnMgYXJlIGF2YWlsYWJsZSB3aGVuICd0b29sdGlwLmdyb3VwZWQ9ZmFsc2UnIG9wdGlvbiBpcyBzZXRcclxuXHQgKiAgICAgIGVkZ2U6IHRydWUsXHJcblx0ICogICAgICB5OiB0cnVlXHJcblx0ICogICB9LFxyXG5cdCAqICAgbGluZXM6IHtcclxuXHQgKiAgICAgIGZyb250OiBmYWxzZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRncmlkX3hfc2hvdzogZmFsc2UsXHJcblx0Z3JpZF94X3R5cGU6IFwidGlja1wiLFxyXG5cdGdyaWRfeF9saW5lczogPExpbmVzPiBbXSxcclxuXHRncmlkX3lfc2hvdzogZmFsc2UsXHJcblx0Z3JpZF95X2xpbmVzOiA8TGluZXM+IFtdLFxyXG5cdGdyaWRfeV90aWNrczogMTAsXHJcblx0Z3JpZF9mb2N1c19lZGdlOiBmYWxzZSxcclxuXHRncmlkX2ZvY3VzX3Nob3c6IHRydWUsXHJcblx0Z3JpZF9mb2N1c195OiBmYWxzZSxcclxuXHRncmlkX2Zyb250OiBmYWxzZSxcclxuXHRncmlkX2xpbmVzX2Zyb250OiB0cnVlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHBvaW50IGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHBvaW50IG9wdGlvbnNcclxuXHQgKiBAbmFtZSBwb2ludFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gcG9pbnQgUG9pbnQgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcG9pbnQuc2hvdz10cnVlXSBXaGV0aGVyIHRvIHNob3cgZWFjaCBwb2ludCBpbiBsaW5lLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfEZ1bmN0aW9ufSBbcG9pbnQucj0yLjVdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50LlxyXG5cdCAqICAtICoqTk9URToqKiBEaXNhYmxlZCBmb3IgJ2J1YmJsZScgdHlwZVxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BvaW50LmZvY3VzLmV4cGFuZC5lbmFibGVkPXRydWVdIFdoZXRoZXIgdG8gZXhwYW5kIGVhY2ggcG9pbnQgb24gZm9jdXMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwb2ludC5mb2N1cy5leHBhbmQucj1wb2ludC5yKjEuNzVdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50IG9uIGZvY3VzLlxyXG5cdCAqICAtICoqTk9URToqKiBGb3IgJ2J1YmJsZScgdHlwZSwgdGhlIGRlZmF1bHQgaXMgYGJ1YmJsZVNpemUqMS4xNWBcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwb2ludC5mb2N1cy5vbmx5PWZhbHNlXSBTaG93IHBvaW50IG9ubHkgd2hlbiBpcyBmb2N1c2VkLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcG9pbnQuc2Vuc2l0aXZpdHk9MTBdIFRoZSBzZW5zdGl2aXR5IHZhbHVlIGZvciBpbnRlcmFjdGlvbiBib3VuZGFyeS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BvaW50LnNlbGVjdC5yPXBvaW50LnIqNF0gVGhlIHJhZGl1cyBzaXplIG9mIGVhY2ggcG9pbnQgb24gc2VsZWN0ZWQuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtwb2ludC50eXBlPVwiY2lyY2xlXCJdIFRoZSB0eXBlIG9mIHBvaW50IHRvIGJlIGRyYXduXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gSWYgY2hhcnQgaGFzICdidWJibGUnIHR5cGUsIG9ubHkgY2lyY2xlIGNhbiBiZSB1c2VkLlxyXG5cdCAqICAgLSBGb3IgSUUsIG5vbiBjaXJjbGUgcG9pbnQgZXhwYW5zaW9ucyBhcmUgbm90IHN1cHBvcnRlZCBkdWUgdG8gbGFjayBvZiB0cmFuc2Zvcm0gc3VwcG9ydC5cclxuXHQgKiAtICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqICAgLSBjaXJjbGVcclxuXHQgKiAgIC0gcmVjdGFuZ2xlXHJcblx0ICogQHByb3BlcnR5IHtBcnJheX0gW3BvaW50LnBhdHRlcm49W11dIFRoZSB0eXBlIG9mIHBvaW50IG9yIHN2ZyBzaGFwZSBhcyBzdHJpbmcsIHRvIGJlIGRyYXduIGZvciBlYWNoIGxpbmVcclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgLSBUaGlzIGlzIGFuIGBleHBlcmltZW50YWxgIGZlYXR1cmUgYW5kIGNhbiBoYXZlIHNvbWUgdW5leHBlY3RlZCBiZWhhdmlvcnMuXHJcblx0ICogICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cclxuXHQgKiAgIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXHJcblx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuXHQgKiAgIC0gY2lyY2xlXHJcblx0ICogICAtIHJlY3RhbmdsZVxyXG5cdCAqICAgLSBzdmcgc2hhcGUgdGFnIGludGVycHJldGVkIGFzIHN0cmluZzxicj5cclxuXHQgKiAgICAgKGV4LiBgPHBvbHlnb24gcG9pbnRzPScyLjUgMCAwIDUgNSA1Jz48L3BvbHlnb24+YClcclxuXHQgKiBAc2VlIFtEZW1vOiBwb2ludCB0eXBlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUG9pbnQuUmVjdGFuZ2xlUG9pbnRzKVxyXG5cdCAqIEBzZWUgW0RlbW86IHBvaW50IGZvY3VzIG9ubHldKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNQb2ludC5Gb2N1c09ubHkpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgcG9pbnQ6IHtcclxuXHQgKiAgICAgIHNob3c6IGZhbHNlLFxyXG5cdCAqICAgICAgcjogNSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gb3IgY3VzdG9taXplIHRoZSByYWRpdXNcclxuXHQgKiAgICAgIHI6IGZ1bmN0aW9uKGQpIHtcclxuXHQgKiAgICAgICAgICAuLi5cclxuXHQgKiAgICAgICAgICByZXR1cm4gcjtcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIGZvY3VzOiB7XHJcblx0ICogICAgICAgICAgZXhwYW5kOiB7XHJcblx0ICogICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcblx0ICogICAgICAgICAgICAgIHI6IDFcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIG9ubHk6IHRydWVcclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBzZWxlY3Q6IHtcclxuXHQgKiAgICAgICAgICByOiAzXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBoYXZpbmcgbG93ZXIgdmFsdWUsIG1lYW5zIGhvdyBjbG9zZXIgdG8gYmUgZm9yIGludGVyYWN0aW9uXHJcblx0ICogICAgICBzZW5zaXRpdml0eTogMyxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gdmFsaWQgdmFsdWVzIGFyZSBcImNpcmNsZVwiIG9yIFwicmVjdGFuZ2xlXCJcclxuXHQgKiAgICAgIHR5cGU6IFwicmVjdGFuZ2xlXCIsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIG9yIGluZGljYXRlIGFzIHBhdHRlcm5cclxuXHQgKiAgICAgIHBhdHRlcm46IFtcclxuXHQgKiAgICAgICAgXCJjaXJjbGVcIixcclxuXHQgKiAgICAgICAgXCJyZWN0YW5nbGVcIixcclxuXHQgKiAgICAgICAgXCI8cG9seWdvbiBwb2ludHM9JzAgNiA0IDAgLTQgMCc+PC9wb2x5Z29uPlwiXHJcblx0ICogICAgIF0sXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRwb2ludF9zaG93OiB0cnVlLFxyXG5cdHBvaW50X3I6IDIuNSxcclxuXHRwb2ludF9zZW5zaXRpdml0eTogMTAsXHJcblx0cG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQ6IHRydWUsXHJcblx0cG9pbnRfZm9jdXNfZXhwYW5kX3I6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0cG9pbnRfZm9jdXNfb25seTogZmFsc2UsXHJcblx0cG9pbnRfcGF0dGVybjogPHN0cmluZ1tdPiBbXSxcclxuXHRwb2ludF9zZWxlY3RfcjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRwb2ludF90eXBlOiBcImNpcmNsZVwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBzdWJjaGFydCBvcHRpb25zXHJcblx0ICogQG5hbWUgc3ViY2hhcnRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHN1YmNoYXJ0IFN1YmNoYXJ0IG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N1YmNoYXJ0LnNob3c9ZmFsc2VdIFNob3cgc3ViIGNoYXJ0IG9uIHRoZSBib3R0b20gb2YgdGhlIGNoYXJ0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnRpY2suc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgbGluZS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzdWJjaGFydC5heGlzLngudGljay50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIHRleHQuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdWJjaGFydC5zaXplLmhlaWdodF0gQ2hhbmdlIHRoZSBoZWlnaHQgb2YgdGhlIHN1YmNoYXJ0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtzdWJjaGFydC5vbmJydXNoXSBTZXQgY2FsbGJhY2sgZm9yIGJydXNoIGV2ZW50Ljxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBjdXJyZW50IHpvb21lZCB4IGRvbWFpbi5cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uU3ViQ2hhcnQpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgc3ViY2hhcnQ6IHtcclxuXHQgKiAgICAgIGF4aXM6IHtcclxuXHQgKiAgICAgIFx0eDoge1xyXG5cdCAqICAgICAgXHQgIHNob3c6IHRydWUsXHJcblx0ICogICAgICBcdCAgICB0aWNrOiB7XHJcblx0ICogICAgICBcdCAgICAgIHNob3c6IHRydWUsXHJcblx0ICogICAgICBcdCAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgIFx0ICAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICAgXHQgICAgICB9XHJcblx0ICogICAgICBcdCAgICB9XHJcblx0ICogICAgICBcdH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICAgc2l6ZToge1xyXG5cdCAqICAgICAgICAgIGhlaWdodDogMjBcclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBvbmJydXNoOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH1cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHN1YmNoYXJ0X3Nob3c6IGZhbHNlLFxyXG5cdHN1YmNoYXJ0X3NpemVfaGVpZ2h0OiA2MCxcclxuXHRzdWJjaGFydF9heGlzX3hfc2hvdzogdHJ1ZSxcclxuXHRzdWJjaGFydF9heGlzX3hfdGlja19zaG93OiB0cnVlLFxyXG5cdHN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdzogdHJ1ZSxcclxuXHRzdWJjaGFydF9vbmJydXNoOiAoKSA9PiB7fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB6b29tIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHpvb20gb3B0aW9uc1xyXG5cdCAqIEBuYW1lIHpvb21cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHpvb20gWm9vbSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt6b29tLmVuYWJsZWQ9ZmFsc2VdIEVuYWJsZSB6b29taW5nLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbS5lbmFibGVkLnR5cGU9J3doZWVsJ10gU2V0IHpvb20gaW50ZXJhY3Rpb24gdHlwZS5cclxuXHQgKiAgLSAqKkF2YWlsYWJsZSB0eXBlczoqKlxyXG5cdCAqICAgIC0gd2hlZWxcclxuXHQgKiAgICAtIGRyYWdcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt6b29tLnJlc2NhbGU9ZmFsc2VdIEVuYWJsZSB0byByZXNjYWxlIGFmdGVyIHpvb21pbmcuPGJyPlxyXG5cdCAqICBJZiB0cnVlIHNldCwgeSBkb21haW4gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZyB0byB0aGUgem9vbWVkIHJlZ2lvbi5cclxuXHQgKiBAcHJvcGVydHkge0FycmF5fSBbem9vbS5leHRlbnQ9WzEsIDEwXV0gQ2hhbmdlIHpvb20gZXh0ZW50LlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfERhdGV9IFt6b29tLngubWluXSBTZXQgeCBBeGlzIG1pbmltdW0gem9vbSByYW5nZVxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfERhdGV9IFt6b29tLngubWF4XSBTZXQgeCBBeGlzIG1heGltdW0gem9vbSByYW5nZVxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbXN0YXJ0PXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gem9vbWluZyBzdGFydHMuPGJyPlxyXG5cdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIHpvb20gZXZlbnQuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tPXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHpvb21pbmcuPGJyPlxyXG5cdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIHpvb21lZCBkb21haW4uXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tZW5kPXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gem9vbWluZyBlbmRzLjxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tZWQgZG9tYWluLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxvYmplY3R9IFt6b29tLnJlc2V0QnV0dG9uPXRydWVdIFNldCB0byBkaXNwbGF5IHpvb20gcmVzZXQgYnV0dG9uIGZvciAnZHJhZycgdHlwZSB6b29tXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ucmVzZXRCdXR0b24ub25jbGlja10gU2V0IGNhbGxiYWNrIHdoZW4gY2xpY2tzIHRoZSByZXNldCBidXR0b24uIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgcmVzZXQgYnV0dG9uIGVsZW1lbnQgcmVmZXJlbmNlIGFzIGFyZ3VtZW50LlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9vbS5yZXNldEJ1dHRvbi50ZXh0PSdSZXNldCBab29tJ10gVGV4dCB2YWx1ZSBmb3Igem9vbSByZXNldCBidXR0b24uXHJcblx0ICogQHNlZSBbRGVtbzp6b29tXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uWm9vbSlcclxuXHQgKiBAc2VlIFtEZW1vOmRyYWcgem9vbV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLkRyYWdab29tKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHpvb206IHtcclxuXHQgKiAgICAgIGVuYWJsZWQ6IHtcclxuXHQgKiAgICAgICAgICB0eXBlOiBcImRyYWdcIlxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHJlc2NhbGU6IHRydWUsXHJcblx0ICogICAgICBleHRlbnQ6IFsxLCAxMDBdICAvLyBlbmFibGUgbW9yZSB6b29taW5nXHJcblx0ICogICAgICB4OiB7XHJcblx0ICogICAgICAgICAgbWluOiAtMSwgIC8vIHNldCBtaW4gcmFuZ2VcclxuXHQgKiAgICAgICAgICBtYXg6IDEwICAvLyBzZXQgbWF4IHJhbmdlXHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgb256b29tc3RhcnQ6IGZ1bmN0aW9uKGV2ZW50KSB7IC4uLiB9LFxyXG5cdCAqICAgICAgb256b29tOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH0sXHJcblx0ICogICAgICBvbnpvb21lbmQ6IGZ1bmN0aW9uKGRvbWFpbikgeyAuLi4gfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2hvdyByZXNldCBidXR0b24gd2hlbiBpcyB6b29tZWQtaW5cclxuXHQgKiAgICAgIHJlc2V0QnV0dG9uOiB0cnVlLFxyXG5cdCAqXHJcblx0ICogICAgICByZXNldEJ1dHRvbjoge1xyXG5cdCAqICAgICAgICAgIC8vIG9uY2xpY2sgY2FsbGJhY2sgd2hlbiByZXNldCBidXR0b24gaXMgY2xpY2tlZFxyXG5cdCAqICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGJ1dHRvbikge1xyXG5cdCAqICAgICAgICAgICAgYnV0dG9uOyAvLyBSZXNldCBidXR0b24gZWxlbWVudCByZWZlcmVuY2VcclxuXHQgKiAgICAgICAgICAgIC4uLlxyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyBjdXN0b21pemVkIHRleHQgdmFsdWUgZm9yIHJlc2V0IHpvb20gYnV0dG9uXHJcblx0ICogICAgICAgICAgdGV4dDogXCJVbnpvb21cIlxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0em9vbV9lbmFibGVkOiA8e3R5cGU6IFwid2hlZWxcIiB8IFwiZHJhZ1wifXxib29sZWFufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHpvb21fZXh0ZW50OiA8bnVtYmVyW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0em9vbV9wcml2aWxlZ2VkOiBmYWxzZSxcclxuXHR6b29tX3Jlc2NhbGU6IGZhbHNlLFxyXG5cdHpvb21fb256b29tOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0em9vbV9vbnpvb21zdGFydDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHpvb21fb256b29tZW5kOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0em9vbV9yZXNldEJ1dHRvbjogPHt0ZXh0OiBzdHJpbmc7fXxib29sZWFuPiB0cnVlLFxyXG5cdHpvb21feF9taW46IDxOdW1iZXJ8RGF0ZXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR6b29tX3hfbWF4OiA8TnVtYmVyfERhdGV8dW5kZWZpbmVkPiB1bmRlZmluZWRcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogYXJlYSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBhcmVhIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBhcmVhXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBhcmVhIEFyZWEgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbYXJlYS56ZXJvYmFzZWQ9dHJ1ZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGFyZWEgY2hhcnQuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbYXJlYS5hYm92ZT1mYWxzZV0gU2V0IGJhY2tncm91bmQgYXJlYSBhYm92ZSB0aGUgZGF0YSBjaGFydCBsaW5lLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxvYmplY3R9IFthcmVhLmxpbmVhckdyYWRpZW50PWZhbHNlXSBTZXQgdGhlIGxpbmVhciBncmFkaWVudCBvbiBhcmVhLjxicj48YnI+XHJcblx0ICogT3IgY3VzdG9taXplIGJ5IGdpdmluZyBiZWxvdyBvYmplY3QgdmFsdWU6XHJcblx0ICogIC0geCB7QXJyYXl9OiBgeDFgLCBgeDJgIHZhbHVlXHJcblx0ICogIC0geSB7QXJyYXl9OiBgeTFgLCBgeTJgIHZhbHVlXHJcblx0ICogIC0gc3RvcHMge0FycmF5fTogRWFjaCBpdGVtIHNob3VsZCBiZSBoYXZpbmcgYFtvZmZzZXQsIHN0b3AtY29sb3IsIHN0b3Atb3BhY2l0eV1gIHZhbHVlcy5cclxuXHQgKiBAc2VlIFtNRE4ncyAmbHQ7bGluZWFyR3JhZGllbnQ+XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC9saW5lYXJHcmFkaWVudCksIFsmbHQ7c3RvcD5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N0b3ApXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LkFyZWFDaGFydClcclxuXHQgKiBAc2VlIFtEZW1vOiBhYm92ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0FyZWFDaGFydE9wdGlvbnMuQWJvdmUpXHJcblx0ICogQHNlZSBbRGVtbzogbGluZWFyR3JhZGllbnRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBcmVhQ2hhcnRPcHRpb25zLkxpbmVhckdyYWRpZW50KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGFyZWE6IHtcclxuXHQgKiAgICAgIHplcm9iYXNlZDogZmFsc2UsXHJcblx0ICogICAgICBhYm92ZTogdHJ1ZSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gd2lsbCBnZW5lcmF0ZSBmb2xsd2luZyBsaW5lYXJHcmFkaWVudDpcclxuXHQgKiAgICAgIC8vIDxsaW5lYXJHcmFkaWVudCB4MT1cIjBcIiB4Mj1cIjBcIiB5MT1cIjBcIiB5Mj1cIjFcIj5cclxuXHQgKiAgICAgIC8vICAgIDxzdG9wIG9mZnNldD1cIjBcIiBzdG9wLWNvbG9yPVwiJERBVEFfQ09MT1JcIiBzdG9wLW9wYWNpdHk9XCIxXCI+PC9zdG9wPlxyXG5cdCAqICAgICAgLy8gICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0b3AtY29sb3I9XCIkREFUQV9DT0xPUlwiIHN0b3Atb3BhY2l0eT1cIjBcIj48L3N0b3A+XHJcblx0ICogICAgICAvLyA8L2xpbmVhckdyYWRpZW50PlxyXG5cdCAqICAgICAgbGluZWFyR3JhZGllbnQ6IHRydWUsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIE9yIGN1c3RvbWl6ZWQgZ3JhZGllbnRcclxuXHQgKiAgICAgIGxpbmVhckdyYWRpZW50OiB7XHJcblx0ICogICAgICBcdHg6IFswLCAwXSwgIC8vIHgxLCB4MiBhdHRyaWJ1dGVzXHJcblx0ICogICAgICBcdHk6IFswLCAwXSwgIC8vIHkxLCB5MiBhdHRyaWJ1dGVzXHJcblx0ICogICAgICBcdHN0b3BzOiBbXHJcblx0ICogICAgICBcdCAgLy8gb2Zmc2V0LCBzdG9wLWNvbG9yLCBzdG9wLW9wYWNpdHlcclxuXHQgKiAgICAgIFx0ICBbMCwgXCIjN2NiNWVjXCIsIDFdLFxyXG5cdCAqXHJcblx0ICogICAgICBcdCAgLy8gc2V0dGluZyAnbnVsbCcgZm9yIHN0b3AtY29sb3IsIHdpbGwgc2V0IGl0cyBvcmlnaW5hbCBkYXRhIGNvbG9yXHJcblx0ICogICAgICBcdCAgWzAuNSwgbnVsbCwgMF0sXHJcblx0ICpcclxuXHQgKiAgICAgIFx0ICAvLyBzZXR0aW5nICdmdW5jdGlvbicgZm9yIHN0b3AtY29sb3IsIHdpbGwgcGFzcyBkYXRhIGlkIGFzIGFyZ3VtZW50LlxyXG5cdCAqICAgICAgXHQgIC8vIEl0IHNob3VsZCByZXR1cm4gY29sb3Igc3RyaW5nIG9yIG51bGwgdmFsdWVcclxuXHQgKiAgICAgIFx0ICBbMSwgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkID09PSBcImRhdGExXCIgPyBcInJlZFwiIDogXCJibHVlXCI7IH0sIDBdLFxyXG5cdCAqICAgICAgXHRdXHJcblx0ICogICAgICB9XHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRhcmVhX3plcm9iYXNlZDogdHJ1ZSxcclxuXHRhcmVhX2Fib3ZlOiBmYWxzZSxcclxuXHRhcmVhX2xpbmVhckdyYWRpZW50OiA8XHJcblx0XHRcdGJvb2xlYW58e3g/OiBudW1iZXJbXTsgeT86IG51bWJlcltdOyBzdG9wcz86IFtudW1iZXIsIHN0cmluZ3xGdW5jdGlvbnxudWxsLCBudW1iZXJdfVxyXG5cdFx0PiBmYWxzZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBiYXIgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgYmFyIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBiYXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGJhciBCYXIgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIucGFkZGluZz0wXSBUaGUgcGFkZGluZyBwaXhlbCB2YWx1ZSBiZXR3ZWVuIGVhY2ggYmFyLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLnJhZGl1c10gU2V0IHRoZSByYWRpdXMgb2YgYmFyIGVkZ2UgaW4gcGl4ZWwuXHJcblx0ICogLSAqKk5PVEU6KiogV29ya3Mgb25seSBmb3Igbm9uLXN0YWNrZWQgYmFyXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIucmFkaXVzLnJhdGlvXSBTZXQgdGhlIHJhZGl1cyByYXRpbyBvZiBiYXIgZWRnZSBpbiByZWxhdGl2ZSB0aGUgYmFyJ3Mgd2lkdGguXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIuc2Vuc2l0aXZpdHk9Ml0gVGhlIHNlbnN0aXZpdHkgb2Zmc2V0IHZhbHVlIGZvciBpbnRlcmFjdGlvbiBib3VuZGFyeS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci53aWR0aF0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIud2lkdGgucmF0aW89MC42XSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydCBieSByYXRpby5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci53aWR0aC5tYXhdIFRoZSBtYXhpbXVtIHdpZHRoIHZhbHVlIGZvciByYXRpby5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZV0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgZm9yIGluZGljYXRlZCBkYXRhc2V0IG9ubHkuXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gV29ya3Mgb25seSBmb3Igbm9uLXN0YWNrZWQgYmFyXHJcblx0ICogICAtIEJhcnMgYXJlIGNlbnRlcmVkIGFjY29kaW5nIGl0cyB0b3RhbCB3aWR0aCB2YWx1ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lLnJhdGlvPTAuNl0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQgYnkgcmF0aW8uXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWUubWF4XSBUaGUgbWF4aW11bSB3aWR0aCB2YWx1ZSBmb3IgcmF0aW8uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbYmFyLnplcm9iYXNlZD10cnVlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gYmFyIGNoYXJ0LlxyXG5cdCAqIEBzZWUgW0RlbW86IGJhciBwYWRkaW5nXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclBhZGRpbmcpXHJcblx0ICogQHNlZSBbRGVtbzogYmFyIHJhZGl1c10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJSYWRpdXMpXHJcblx0ICogQHNlZSBbRGVtbzogYmFyIHdpZHRoXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhcldpZHRoKVxyXG5cdCAqIEBzZWUgW0RlbW86IGJhciB3aWR0aCB2YXJpYW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhcldpZHRoVmFyaWFudClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBiYXI6IHtcclxuXHQgKiAgICAgIHBhZGRpbmc6IDEsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHRoZSAncmFkaXVzJyBvcHRpb24gY2FuIGJlIHVzZWQgb25seSBmb3Igbm9uLXN0YWNraW5nIGJhcnNcclxuXHQgKiAgICAgIHJhZGl1czogMTAsXHJcblx0ICogICAgICAvLyBvclxyXG5cdCAqICAgICAgcmFkaXVzOiB7XHJcblx0ICogICAgICAgICAgcmF0aW86IDAuNVxyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogICAgICAvLyB3aWxsIG5vdCBoYXZlIG9mZnNldCBiZXR3ZWVuIGVhY2ggYmFyIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxyXG5cdCAqICAgICAgc2Vuc2l0aXZpdHk6IDAsXHJcblx0ICpcclxuXHQgKiAgICAgIHdpZHRoOiAxMCxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gb3JcclxuXHQgKiAgICAgIHdpZHRoOiB7XHJcblx0ICogICAgICAgICAgcmF0aW86IDAuMixcclxuXHQgKiAgICAgICAgICBtYXg6IDIwXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBvciBzcGVjaWZ5IHdpZHRoIHBlciBkYXRhc2V0XHJcblx0ICogICAgICB3aWR0aDoge1xyXG5cdCAqICAgICAgICAgIGRhdGExOiAyMCxcclxuXHQgKiAgICAgICAgICBkYXRhMjoge1xyXG5cdCAqICAgICAgICAgICAgICByYXRpbzogMC4yLFxyXG5cdCAqICAgICAgICAgICAgICBtYXg6IDIwXHJcblx0ICogICAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0YmFyX3BhZGRpbmc6IDAsXHJcblx0YmFyX3JhZGl1czogPG51bWJlcnx7cmF0aW86IG51bWJlcn18dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0YmFyX3JhZGl1c19yYXRpbzogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRiYXJfc2Vuc2l0aXZpdHk6IDIsXHJcblx0YmFyX3dpZHRoOiA8bnVtYmVyfHtyYXRpbz86IG51bWJlcjsgbWF4PzogbnVtYmVyO318dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0YmFyX3dpZHRoX3JhdGlvOiAwLjYsXHJcblx0YmFyX3dpZHRoX21heDogdW5kZWZpbmVkLFxyXG5cdGJhcl96ZXJvYmFzZWQ6IHRydWVcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogYnViYmxlIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGJ1YmJsZSBvcHRpb25zXHJcblx0ICogQG5hbWUgYnViYmxlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBidWJibGUgYnViYmxlIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfEZ1bmN0aW9ufSBbYnViYmxlLm1heFI9MzVdIFNldCB0aGUgbWF4IGJ1YmJsZSByYWRpdXMgdmFsdWVcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtidWJibGUuemVyb2Jhc2VkPWZhbHNlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gYnViYmxlIGNoYXJ0LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGJ1YmJsZToge1xyXG5cdCAqICAgICAgLy8gZXgpIElmIDEwMCBpcyB0aGUgaGlnaGVzdCB2YWx1ZSBhbW9uZyBkYXRhIGJvdW5kLCB0aGUgcmVwcmVzZW50YXRpb24gYnViYmxlIG9mIDEwMCB3aWxsIGhhdmUgcmFkaXVzIG9mIDUwLlxyXG5cdCAqICAgICAgLy8gQW5kIHRoZSBsZXNzZXIgd2lsbCBoYXZlIHJhZGl1cyByZWxhdGl2ZWx5IGZyb20gdGhhIG1heCB2YWx1ZS5cclxuXHQgKiAgICAgIG1heFI6IDUwLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBvciBzZXQgcmFkaXVzIGNhbGxiYWNrXHJcblx0ICogICAgICBtYXhSOiBmdW5jdGlvbihkKSB7XHJcblx0ICogICAgICAgICAgLy8gZXguIG9mIGQgcGFyYW0gLSB7eDogRnJpIE9jdCAwNiAyMDE3IDAwOjAwOjAwIEdNVCswOTAwLCB2YWx1ZTogODAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA1fVxyXG5cdCAqICAgICAgICAgIC4uLlxyXG5cdCAqICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZC52YWx1ZSAqIDIpO1xyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHplcm9iYXNlZDogZmFsc2VcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGJ1YmJsZV9tYXhSOiA8bnVtYmVyfCgoKSA9PiBudW1iZXIpPiAzNSxcclxuXHRidWJibGVfemVyb2Jhc2VkOiBmYWxzZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBsaW5lIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGxpbmUgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGxpbmVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGxpbmUgTGluZSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaW5lLmNvbm5lY3ROdWxsPWZhbHNlXSBTZXQgaWYgbnVsbCBkYXRhIHBvaW50IHdpbGwgYmUgY29ubmVjdGVkIG9yIG5vdC48YnI+XHJcblx0ICogIElmIHRydWUgc2V0LCB0aGUgcmVnaW9uIG9mIG51bGwgZGF0YSB3aWxsIGJlIGNvbm5lY3RlZCB3aXRob3V0IGFueSBkYXRhIHBvaW50LiBJZiBmYWxzZSBzZXQsIHRoZSByZWdpb24gb2YgbnVsbCBkYXRhIHdpbGwgbm90IGJlIGNvbm5lY3RlZCBhbmQgZ2V0IGVtcHR5LlxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9ICAgW2xpbmUuY2xhc3Nlcz11bmRlZmluZWRdIElmIHNldCwgdXNlZCB0byBzZXQgYSBjc3MgY2xhc3Mgb24gZWFjaCBsaW5lLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpbmUuc3RlcC50eXBlPXN0ZXBdIENoYW5nZSBzdGVwIHR5cGUgZm9yIHN0ZXAgY2hhcnQuPGJyPlxyXG5cdCAqICoqQXZhaWxhYmxlIHZhbHVlczoqKlxyXG5cdCAqIC0gc3RlcFxyXG5cdCAqIC0gc3RlcC1iZWZvcmVcclxuXHQgKiAtIHN0ZXAtYWZ0ZXJcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW58QXJyYXl9IFtsaW5lLnBvaW50PXRydWVdIFNldCB0byBmYWxzZSB0byBub3QgZHJhdyBwb2ludHMgb24gbGluZWNoYXJ0cy4gT3IgcGFzcyBhbiBhcnJheSBvZiBsaW5lIGlkcyB0byBkcmF3IHBvaW50cyBmb3IuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbGluZS56ZXJvYmFzZWQ9ZmFsc2VdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBsaW5lIGNoYXJ0LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGxpbmU6IHtcclxuXHQgKiAgICAgIGNvbm5lY3ROdWxsOiB0cnVlLFxyXG5cdCAqICAgICAgY2xhc3NlczogW1xyXG5cdCAqICAgICAgICAgIFwibGluZS1jbGFzczFcIixcclxuXHQgKiAgICAgICAgICBcImxpbmUtY2xhc3MyXCJcclxuXHQgKiAgICAgIF0sXHJcblx0ICogICAgICBzdGVwOiB7XHJcblx0ICogICAgICAgICAgdHlwZTogXCJzdGVwLWFmdGVyXCJcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGhpZGUgYWxsIGRhdGEgcG9pbnRzICgncG9pbnQuc2hvdz1mYWxzZScgYWxzbyBoYXMgc2ltaWxhciBlZmZlY3QpXHJcblx0ICogICAgICBwb2ludDogZmFsc2UsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHNob3cgZGF0YSBwb2ludHMgZm9yIG9ubHkgaW5kaWNhdGVkIGRhdGFzXHJcblx0ICogICAgICBwb2ludDogW1xyXG5cdCAqICAgICAgICAgIFwiZGF0YTFcIiwgXCJkYXRhM1wiXHJcblx0ICogICAgICBdLFxyXG5cdCAqXHJcblx0ICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRsaW5lX2Nvbm5lY3ROdWxsOiBmYWxzZSxcclxuXHRsaW5lX3N0ZXBfdHlwZTogPFwic3RlcFwifFwic3RlcC1iZWZvcmVcInxcInN0ZXAtYWZ0ZXJcIj4gXCJzdGVwXCIsXHJcblx0bGluZV96ZXJvYmFzZWQ6IGZhbHNlLFxyXG5cdGxpbmVfY2xhc3NlczogPHN0cmluZ1tdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGxpbmVfcG9pbnQ6IDxzdHJpbmdbXXxib29sZWFuPiB0cnVlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBzcGxpbmUgb3B0aW9uc1xyXG5cdCAqIC0gKipBdmFpbGFibGUgaW50ZXJwb2xhdGlvbiB0eXBlIHZhbHVlczoqKlxyXG5cdCAqICAtIGJhc2lzIChkMy5jdXJ2ZUJhc2lzKVxyXG5cdCAqICAtIGJhc2lzLWNsb3NlZCAoZDMuY3VydmVCYXNpc0Nsb3NlZClcclxuXHQgKiAgLSBiYXNpcy1vcGVuIChkMy5jdXJ2ZUJhc2lzT3BlbilcclxuXHQgKiAgLSBidW5kbGUgKGQzLmN1cnZlQnVuZGxlKVxyXG5cdCAqICAtIGNhcmRpbmFsIChkMy5jdXJ2ZUNhcmRpbmFsKVxyXG5cdCAqICAtIGNhcmRpbmFsLWNsb3NlZCAoZDMuY3VydmVDYXJkaW5hbENsb3NlZClcclxuXHQgKiAgLSBjYXJkaW5hbC1vcGVuIChkMy5jdXJ2ZUNhcmRpbmFsT3BlbilcclxuXHQgKiAgLSBjYXRtdWxsLXJvbSAoZDMuY3VydmVDYXRtdWxsUm9tKVxyXG5cdCAqICAtIGNhdG11bGwtcm9tLWNsb3NlZCAoZDMuY3VydmVDYXRtdWxsUm9tQ2xvc2VkKVxyXG5cdCAqICAtIGNhdG11bGwtcm9tLW9wZW4gKGQzLmN1cnZlQ2F0bXVsbFJvbU9wZW4pXHJcblx0ICogIC0gbW9ub3RvbmUteCAoZDMuY3VydmVNb25vdG9uZVgpXHJcblx0ICogIC0gbW9ub3RvbmUteSAoZDMuY3VydmVNb25vdG9uZVkpXHJcblx0ICogIC0gbmF0dXJhbCAoZDMuY3VydmVOYXR1cmFsKVxyXG5cdCAqICAtIGxpbmVhci1jbG9zZWQgKGQzLmN1cnZlTGluZWFyQ2xvc2VkKVxyXG5cdCAqICAtIGxpbmVhciAoZDMuY3VydmVMaW5lYXIpXHJcblx0ICogIC0gc3RlcCAoZDMuY3VydmVTdGVwKVxyXG5cdCAqICAtIHN0ZXAtYWZ0ZXIgKGQzLmN1cnZlU3RlcEFmdGVyKVxyXG5cdCAqICAtIHN0ZXAtYmVmb3JlIChkMy5jdXJ2ZVN0ZXBCZWZvcmUpXHJcblx0ICogQG5hbWUgc3BsaW5lXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBzcGxpbmUgU3BsaW5lIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBzcGxpbmUuaW50ZXJwb2xhdGlvbiBTcGxpbmUgaW50ZXJwb2xhdGlvbiBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3NwbGluZS5pbnRlcnBvbGF0aW9uLnR5cGU9XCJjYXJkaW5hbFwiXSBJbnRlcnBvbGF0aW9uIHR5cGVcclxuXHQgKiBAc2VlIFtJbnRlcnBvbGF0aW9uIChkMyB2NCldKGh0dHA6Ly9ibC5vY2tzLm9yZy9lbW1hc2F1bmRlcnMvYzI1YTE0Nzk3MGRlZjJiMDJkOGM3YzI3MTlkYzc1MDIpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgc3BsaW5lOiB7XHJcblx0ICogICAgICBpbnRlcnBvbGF0aW9uOiB7XHJcblx0ICogICAgICAgICAgdHlwZTogXCJjYXJkaW5hbFwiXHJcblx0ICogICAgICB9XHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRzcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlOiBcImNhcmRpbmFsXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZG9udXQgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgZG9udXQgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGRvbnV0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkb251dCBEb251dCBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkb251dC5sYWJlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsYWJlbCBvbiBlYWNoIGRvbnV0IHBpZWNlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkb251dC5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIGRvbnV0IHBpZWNlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZG9udXQubGFiZWwudGhyZXNob2xkPTAuMDVdIFNldCB0aHJlc2hvbGQgdG8gc2hvdy9oaWRlIGxhYmVscy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcnxGdW5jdGlvbn0gW2RvbnV0LmxhYmVsLnJhdGlvPXVuZGVmaW5lZF0gU2V0IHJhdGlvIG9mIGxhYmVscyBwb3NpdGlvbi5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkb251dC5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIGRvbnV0IHBpZWNlcy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RvbnV0LmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RvbnV0LmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbXMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtkb251dC53aWR0aF0gU2V0IHdpZHRoIG9mIGRvbnV0IGNoYXJ0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZG9udXQudGl0bGU9XCJcIl0gU2V0IHRpdGxlIG9mIGRvbnV0IGNoYXJ0LiBVc2UgYFxcbmAgY2hhcmFjdGVyIHRvIGVudGVyIGxpbmUgYnJlYWsuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtkb251dC5wYWRBbmdsZT0wXSBTZXQgcGFkZGluZyBiZXR3ZWVuIGRhdGEuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtkb251dC5zdGFydGluZ0FuZ2xlPTBdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGRvbnV0OiB7XHJcblx0ICogICAgICBsYWJlbDoge1xyXG5cdCAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG5cdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xyXG5cdCAqICAgICAgICAgICAgICByZXR1cm4gZDMuZm9ybWF0KFwiJFwiKSh2YWx1ZSk7XHJcblx0ICpcclxuXHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcclxuXHQgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlICtcIiVcXG5MaW5lMVxcbjJMaW5lMlwiO1xyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcclxuXHQgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XHJcblx0ICogICAgICAgICAgXHQuLi5cclxuXHQgKiAgICAgICAgICBcdHJldHVybiByYXRpbztcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIC8vIG9yIHNldCByYXRpbyBudW1iZXJcclxuXHQgKiAgICAgICAgICByYXRpbzogMC41XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBkaXNhYmxlIGV4cGFuZCB0cmFuc2l0aW9uIGZvciBpbnRlcmFjdGlvblxyXG5cdCAqICAgICAgZXhwYW5kOiBmYWxzZSxcclxuXHQgKlxyXG5cdCAqICAgICAgZXhwYW5kOiB7XHJcblx0ICogICAgICBcdC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cclxuXHQgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxyXG5cdCAqXHJcblx0ICogICAgICBcdC8vIHNldCBleHBhbmQgYXJlYSByYXRlXHJcblx0ICogICAgICAgICAgcmF0ZTogMVxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgd2lkdGg6IDEwLFxyXG5cdCAqICAgICAgcGFkQW5nbGU6IDAuMixcclxuXHQgKiAgICAgIHN0YXJ0aW5nQW5nbGU6IDEsXHJcblx0ICogICAgICB0aXRsZTogXCJEb251dCBUaXRsZVwiXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHRpdGxlIHdpdGggbGluZSBicmVha1xyXG5cdCAqICAgICAgdGl0bGU6IFwiVGl0bGUxXFxuVGl0bGUyXCJcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGRvbnV0X2xhYmVsX3Nob3c6IHRydWUsXHJcblx0ZG9udXRfbGFiZWxfZm9ybWF0OiA8KCgpID0+IG51bWJlcnxzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGRvbnV0X2xhYmVsX3RocmVzaG9sZDogMC4wNSxcclxuXHRkb251dF9sYWJlbF9yYXRpbzogPG51bWJlcnwoKCkgPT4gbnVtYmVyKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRkb251dF93aWR0aDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRkb251dF90aXRsZTogXCJcIixcclxuXHRkb251dF9leHBhbmQ6IDxib29sZWFufHtyYXRlPzogbnVtYmVyOyBkdXJhdGlvbj86IG51bWJlcjt9PiB7fSxcclxuXHRkb251dF9leHBhbmRfcmF0ZTogMC45OCxcclxuXHRkb251dF9leHBhbmRfZHVyYXRpb246IDUwLFxyXG5cdGRvbnV0X3BhZEFuZ2xlOiAwLFxyXG5cdGRvbnV0X3N0YXJ0aW5nQW5nbGU6IDBcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZ2F1Z2UgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgZ2F1Z2Ugb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGdhdWdlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBnYXVnZSBHYXVnZSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnYXVnZS5mdWxsQ2lyY2xlPWZhbHNlXSBTaG93IGZ1bGwgY2lyY2xlIGFzIGRvbnV0LiBXaGVuIHNldCB0byAndHJ1ZScsIHRoZSBtYXggbGFiZWwgd2lsbCBub3QgYmUgc2hvd2VkIGR1ZSB0byBzdGFydCBhbmQgZW5kIHBvaW50cyBhcmUgc2FtZSBsb2NhdGlvbi5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnYXVnZS5sYWJlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsYWJlbCBvbiBnYXVnZS5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZ2F1Z2UubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZ2F1Z2UuIExhYmVsIHRleHQgY2FuIGJlIG11bHRpbGluZWQgd2l0aCBgXFxuYCBjaGFyYWN0ZXIuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2dhdWdlLmxhYmVsLmV4dGVudHNdIFNldCBjdXN0b21pemVkIG1pbi9tYXggbGFiZWwgdGV4dC5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtnYXVnZS5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIGdhdWdlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZ2F1Z2UuZXhwYW5kLnJhdGU9MC45OF0gU2V0IGV4cGFuZCByYXRlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZ2F1Z2UuZXhwYW5kLmR1cmF0aW9uPTUwXSBTZXQgdGhlIGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZ2F1Z2UubWluPTBdIFNldCBtaW4gdmFsdWUgb2YgdGhlIGdhdWdlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZ2F1Z2UubWF4PTEwMF0gU2V0IG1heCB2YWx1ZSBvZiB0aGUgZ2F1Z2UuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtnYXVnZS5zdGFydGluZ0FuZ2xlPS0xICogTWF0aC5QSSAvIDJdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2F1Z2UudGl0bGU9XCJcIl0gU2V0IHRpdGxlIG9mIGdhdWdlIGNoYXJ0LiBVc2UgYFxcbmAgY2hhcmFjdGVyIHRvIGVudGVyIGxpbmUgYnJlYWsuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtnYXVnZS51bml0c10gU2V0IHVuaXRzIG9mIHRoZSBnYXVnZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2dhdWdlLndpZHRoXSBTZXQgd2lkdGggb2YgZ2F1Z2UgY2hhcnQuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtnYXVnZS50eXBlPVwic2luZ2xlXCJdIFNldCB0eXBlIG9mIGdhdWdlIHRvIGJlIGRpc3BsYXllZC48YnI+PGJyPlxyXG5cdCAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqIC0gc2luZ2xlXHJcblx0ICogLSBtdWx0aVxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2F1Z2UuYXJjcy5taW5XaWR0aD01XSBTZXQgbWluaW1hbCB3aWR0aCBvZiBnYXVnZSBhcmNzIHVudGlsIHRoZSBpbm5lclJhZGl1cyBkaXNhcHBlYXJzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGdhdWdlOiB7XHJcblx0ICogICAgICBmdWxsQ2lyY2xlOiBmYWxzZSxcclxuXHQgKiAgICAgIGxhYmVsOiB7XHJcblx0ICogICAgICAgICAgc2hvdzogZmFsc2UsXHJcblx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8pIHtcclxuXHQgKiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG5cdCAqXHJcblx0ICogICAgICAgICAgICAgIC8vIHRvIG11bHRpbGluZSwgcmV0dXJuIHdpdGggJ1xcbicgY2hhcmFjdGVyXHJcblx0ICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIGV4dGVudHM6IGZ1bmN0aW9uKHZhbHVlLCBpc01heCkge1xyXG5cdCAqICAgICAgICAgICAgICByZXR1cm4gKGlzTWF4ID8gXCJNYXg6XCIgOiBcIk1pbjpcIikgKyB2YWx1ZTtcclxuXHQgKiAgICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBkaXNhYmxlIGV4cGFuZCB0cmFuc2l0aW9uIGZvciBpbnRlcmFjdGlvblxyXG5cdCAqICAgICAgZXhwYW5kOiBmYWxzZSxcclxuXHQgKlxyXG5cdCAqICAgICAgZXhwYW5kOiB7XHJcblx0ICogICAgICBcdC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cclxuXHQgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxyXG5cdCAqXHJcblx0ICogICAgICBcdC8vIHNldCBleHBhbmQgYXJlYSByYXRlXHJcblx0ICogICAgICAgICAgcmF0ZTogMVxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgbWluOiAtMTAwLFxyXG5cdCAqICAgICAgbWF4OiAyMDAsXHJcblx0ICogICAgICB0eXBlOiBcInNpbmdsZVwiICAvLyBvciAnbXVsdGknXHJcblx0ICogICAgICB0aXRsZTogXCJUaXRsZSBUZXh0XCIsXHJcblx0ICogICAgICB1bml0czogXCIlXCIsXHJcblx0ICogICAgICB3aWR0aDogMTAsXHJcblx0ICogICAgICBhcmNzOiB7XHJcblx0ICogICAgICAgICAgbWluV2lkdGg6IDVcclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGdhdWdlX2Z1bGxDaXJjbGU6IGZhbHNlLFxyXG5cdGdhdWdlX2xhYmVsX3Nob3c6IHRydWUsXHJcblx0Z2F1Z2VfbGFiZWxfZm9ybWF0OiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0Z2F1Z2VfbGFiZWxfZXh0ZW50czogPCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGdhdWdlX21pbjogMCxcclxuXHRnYXVnZV9tYXg6IDEwMCxcclxuXHRnYXVnZV90eXBlOiBcInNpbmdsZVwiLFxyXG5cdGdhdWdlX3N0YXJ0aW5nQW5nbGU6IC0xICogTWF0aC5QSSAvIDIsXHJcblx0Z2F1Z2VfdGl0bGU6IFwiXCIsXHJcblx0Z2F1Z2VfdW5pdHM6IDxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0Z2F1Z2Vfd2lkdGg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0Z2F1Z2VfYXJjc19taW5XaWR0aDogNSxcclxuXHRnYXVnZV9leHBhbmQ6IDxib29sZWFufHtkdXJhdGlvbjogbnVtYmVyfT4ge30sXHJcblx0Z2F1Z2VfZXhwYW5kX3JhdGU6IDAuOTgsXHJcblx0Z2F1Z2VfZXhwYW5kX2R1cmF0aW9uOiA1MFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgcGllIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBwaWVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHBpZSBQaWUgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcGllLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGVhY2ggcGllIHBpZWNlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtwaWUubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZWFjaCBwaWUgcGllY2UuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaWUubGFiZWwudGhyZXNob2xkPTAuMDVdIFNldCB0aHJlc2hvbGQgdG8gc2hvdy9oaWRlIGxhYmVscy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcnxGdW5jdGlvbn0gW3BpZS5sYWJlbC5yYXRpbz11bmRlZmluZWRdIFNldCByYXRpbyBvZiBsYWJlbHMgcG9zaXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufG9iamVjdH0gW3BpZS5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIHBpZSBwaWVjZXMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaWUuZXhwYW5kLnJhdGU9MC45OF0gU2V0IGV4cGFuZCByYXRlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGllLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbXMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ8b2JqZWN0fSBbcGllLmlubmVyUmFkaXVzPTBdIFNldHMgdGhlIGlubmVyIHJhZGl1cyBvZiBwaWUgYXJjLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGllLnBhZEFuZ2xlPTBdIFNldCBwYWRkaW5nIGJldHdlZW4gZGF0YS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BpZS5wYWRkaW5nPTBdIFNldHMgdGhlIGdhcCBiZXR3ZWVuIHBpZSBhcmNzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBkb251dCBEb251dCBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RvbnV0LnN0YXJ0aW5nQW5nbGU9MF0gU2V0IHN0YXJ0aW5nIGFuZ2xlIHdoZXJlIGRhdGEgZHJhd3MuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgcGllOiB7XHJcblx0ICogICAgICBsYWJlbDoge1xyXG5cdCAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG5cdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xyXG5cdCAqICAgICAgICAgICAgICByZXR1cm4gZDMuZm9ybWF0KFwiJFwiKSh2YWx1ZSk7XHJcblx0ICpcclxuXHQgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcclxuXHQgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlICtcIiVcXG5MaW5lMVxcbjJMaW5lMlwiO1xyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcclxuXHQgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XHJcblx0ICogICAgICAgICAgICAgIC4uLlxyXG5cdCAqICAgICAgICAgICAgICByZXR1cm4gcmF0aW87XHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICAvLyBvciBzZXQgcmF0aW8gbnVtYmVyXHJcblx0ICogICAgICAgICAgcmF0aW86IDAuNVxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gZGlzYWJsZSBleHBhbmQgdHJhbnNpdGlvbiBmb3IgaW50ZXJhY3Rpb25cclxuXHQgKiAgICAgIGV4cGFuZDogZmFsc2UsXHJcblx0ICpcclxuXHQgKiAgICAgIGV4cGFuZDoge1xyXG5cdCAqICAgICAgXHQvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXHJcblx0ICogICAgICAgICAgZHVyYXRpb246IDUwMCxcclxuXHQgKlxyXG5cdCAqICAgICAgXHQvLyBzZXQgZXhwYW5kIGFyZWEgcmF0ZVxyXG5cdCAqICAgICAgICAgIHJhdGU6IDFcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIGlubmVyUmFkaXVzOiAwLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBzZXQgZGlmZmVyZW50IGlubmVyUmFkaXVzIGZvciBlYWNoIGRhdGFcclxuXHQgKiAgICAgIGlubmVyUmFkaXVzOiB7XHJcblx0ICogICAgICBcdGRhdGExOiAxMCxcclxuXHQgKiAgICAgIFx0ZGF0YTI6IDBcclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqICAgICAgcGFkQW5nbGU6IDAuMSxcclxuXHQgKiAgICAgIHBhZGRpbmc6IDAsXHJcblx0ICogICAgICBzdGFydGluZ0FuZ2xlOiAxXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRwaWVfbGFiZWxfc2hvdzogdHJ1ZSxcclxuXHRwaWVfbGFiZWxfZm9ybWF0OiA8KCgpID0+IG51bWJlcnxzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHBpZV9sYWJlbF90aHJlc2hvbGQ6IDAuMDUsXHJcblx0cGllX2xhYmVsX3JhdGlvOiA8KCgpID0+IG51bWJlcil8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0cGllX2V4cGFuZDogPGJvb2xlYW58e3JhdGU/OiBudW1iZXI7IGR1cmF0aW9uPzogbnVtYmVyO30+IHt9LFxyXG5cdHBpZV9leHBhbmRfcmF0ZTogMC45OCxcclxuXHRwaWVfZXhwYW5kX2R1cmF0aW9uOiA1MCxcclxuXHRwaWVfaW5uZXJSYWRpdXM6IDxudW1iZXJ8e1trZXk6IHN0cmluZ106IG51bWJlcn0+IDAsXHJcblx0cGllX3BhZEFuZ2xlOiAwLFxyXG5cdHBpZV9wYWRkaW5nOiAwLFxyXG5cdHBpZV9zdGFydGluZ0FuZ2xlOiAwXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCByYWRhciBvcHRpb25zXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhay5cclxuXHQgKiBAbmFtZSByYWRhclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gcmFkYXIgUmFkYXIgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRhci5heGlzLm1heD11bmRlZmluZWRdIFRoZSBtYXggdmFsdWUgb2YgYXhpcy4gSWYgbm90IGdpdmVuLCBpdCdsbCB0YWtlIHRoZSBtYXggdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gZGF0YS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWRhci5heGlzLmxpbmUuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgYXhpcyBsaW5lLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkYXIuYXhpcy50ZXh0LnBvc2l0aW9uLng9MF0geCBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtyYWRhci5heGlzLnRleHQucG9zaXRpb24ueT0wXSB5IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWRhci5heGlzLnRleHQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgYXhpcyB0ZXh0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhZGFyLmRpcmVjdGlvbi5jbG9ja3dpc2U9ZmFsc2VdIFNldCB0aGUgZGlyZWN0aW9uIHRvIGJlIGRyYXduLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkYXIubGV2ZWwuZGVwdGg9M10gU2V0IHRoZSBsZXZlbCBkZXB0aC5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWRhci5sZXZlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZXZlbC5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbcmFkYXIubGV2ZWwudGV4dC5mb3JtYXQ9KHgpID0+ICh4ICUgMSA9PT0gMCA/IHggOiB4LnRvRml4ZWQoMikpXSBTZXQgZm9ybWF0IGZ1bmN0aW9uIGZvciB0aGUgbGV2ZWwgdmFsdWUuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcmFkYXIubGV2ZWwudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZXZlbCB0ZXh0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkYXIuc2l6ZS5yYXRpbz0wLjg3XSBTZXQgc2l6ZSByYXRpby5cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuUmFkYXJDaGFydClcclxuXHQgKiBAc2VlIFtEZW1vOiByYWRhciBheGlzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzKVxyXG5cdCAqIEBzZWUgW0RlbW86IHJhZGFyIGxldmVsXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJMZXZlbClcclxuXHQgKiBAc2VlIFtEZW1vOiByYWRhciBzaXplXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJTaXplKVxyXG5cdCAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXMgbXVsdGlsaW5lXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzTXVsdGlsaW5lKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHJhZGFyOiB7XHJcblx0ICogICAgICBheGlzOiB7XHJcblx0ICogICAgICAgICAgbWF4OiA1MCxcclxuXHQgKiAgICAgICAgICBsaW5lOiB7XHJcblx0ICogICAgICAgICAgICAgIHNob3c6IGZhbHNlXHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcblx0ICogICAgICAgICAgICAgIFx0eDogMCxcclxuXHQgKiAgICAgICAgICAgICAgXHR5OiAwXHJcblx0ICogICAgICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgICAgIHNob3c6IGZhbHNlXHJcblx0ICogICAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIGRpcmVjdGlvbjoge1xyXG5cdCAqICAgICAgICAgIGNsb2Nrd2lzZTogdHJ1ZVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIGxldmVsOiB7XHJcblx0ICogICAgICAgICAgc2hvdzogZmFsc2UsXHJcblx0ICogICAgICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XHJcblx0ICogICAgICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgICAgIHNob3c6IHRydWVcclxuXHQgKiAgICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgc2l6ZToge1xyXG5cdCAqICAgICAgICAgIHJhdGlvOiAwLjdcclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHJhZGFyX2F4aXNfbWF4OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHJhZGFyX2F4aXNfbGluZV9zaG93OiB0cnVlLFxyXG5cdHJhZGFyX2F4aXNfdGV4dF9zaG93OiB0cnVlLFxyXG5cdHJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbjogPHt4PzogbnVtYmVyOyB5PzogbnVtYmVyO30+IHt9LFxyXG5cdHJhZGFyX2xldmVsX2RlcHRoOiAzLFxyXG5cdHJhZGFyX2xldmVsX3Nob3c6IHRydWUsXHJcblx0cmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQ6ICh4OiBudW1iZXIpID0+ICh4ICUgMSA9PT0gMCA/IHggOiB4LnRvRml4ZWQoMikpLFxyXG5cdHJhZGFyX2xldmVsX3RleHRfc2hvdzogdHJ1ZSxcclxuXHRyYWRhcl9zaXplX3JhdGlvOiAwLjg3LFxyXG5cdHJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLy8gY29tbW9uXHJcbmltcG9ydCBkYXRhIGZyb20gXCIuL2RhdGEvZGF0YVwiO1xyXG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29tbW9uL2NvbG9yXCI7XHJcbmltcG9ydCBpbnRlcmFjdGlvbiBmcm9tIFwiLi9jb21tb24vaW50ZXJhY3Rpb25cIjtcclxuaW1wb3J0IGxlZ2VuZCBmcm9tIFwiLi9jb21tb24vbGVnZW5kXCI7XHJcbmltcG9ydCB0aXRsZSBmcm9tIFwiLi9jb21tb24vdGl0bGVcIjtcclxuaW1wb3J0IHRvb2x0aXAgZnJvbSBcIi4vY29tbW9uL3Rvb2x0aXBcIjtcclxuXHJcbi8vIEF4aXMgYmFzZWRcclxuaW1wb3J0IGRhdGFBeGlzIGZyb20gXCIuL2RhdGEvYXhpc1wiO1xyXG5pbXBvcnQgZGF0YVNlbGVjdGlvbiBmcm9tIFwiLi9kYXRhL3NlbGVjdGlvblwiO1xyXG5pbXBvcnQgYXhpcyBmcm9tIFwiLi9heGlzL2F4aXNcIjtcclxuaW1wb3J0IGdyaWQgZnJvbSBcIi4vY29tbW9uL2dyaWRcIjtcclxuaW1wb3J0IHBvaW50IGZyb20gXCIuL2NvbW1vbi9wb2ludFwiO1xyXG5pbXBvcnQgc3ViY2hhcnQgZnJvbSBcIi4vY29tbW9uL3N1YmNoYXJ0XCI7XHJcbmltcG9ydCB6b29tIGZyb20gXCIuL2NvbW1vbi96b29tXCI7XHJcblxyXG5pbXBvcnQgYXJlYSBmcm9tIFwiLi9zaGFwZS9hcmVhXCI7XHJcbmltcG9ydCBiYXIgZnJvbSBcIi4vc2hhcGUvYmFyXCI7XHJcbmltcG9ydCBidWJibGUgZnJvbSBcIi4vc2hhcGUvYnViYmxlXCI7XHJcbmltcG9ydCBsaW5lIGZyb20gXCIuL3NoYXBlL2xpbmVcIjtcclxuaW1wb3J0IHNwbGluZSBmcm9tIFwiLi9zaGFwZS9zcGxpbmVcIjtcclxuXHJcbi8vIE5vbi1BeGlzIGJhc2VkXHJcbmltcG9ydCBkb251dCBmcm9tIFwiLi9zaGFwZS9kb251dFwiO1xyXG5pbXBvcnQgZ2F1Z2UgZnJvbSBcIi4vc2hhcGUvZ2F1Z2VcIjtcclxuaW1wb3J0IHBpZSBmcm9tIFwiLi9zaGFwZS9waWVcIjtcclxuaW1wb3J0IHJhZGFyIGZyb20gXCIuL3NoYXBlL3JhZGFyXCI7XHJcblxyXG5pbXBvcnQge21lcmdlT2JqfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0byBzZXQgb3B0aW9ucyBvbiBnZW5lcmF0aW5nIGNoYXJ0LlxyXG4gKiAtIEl0J3MgaW5zdGFudGlhdGVkIGludGVybmFsbHksIG5vdCBleHBvc2VkIGZvciBwdWJsaWMuXHJcbiAqIEBjbGFzcyBPcHRpb25zXHJcbiAqIEBzZWUge0BsaW5rIGJiLmdlbmVyYXRlfSB0byB1c2UgdGhlc2Ugb3B0aW9ucyBvbiBnZW5lcmF0aW5nIHRoZSBjaGFydFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9ucyB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRjb25zdCBhcmNTaGFwZUNvbmZpZyA9IFtkb251dCwgZ2F1Z2UsIHBpZSwgcmFkYXJdO1xyXG5cclxuXHRcdGNvbnN0IGF4aXNDb25maWcgPSBbZGF0YUF4aXMsIGRhdGFTZWxlY3Rpb24sIGF4aXMsIGdyaWQsIHBvaW50LCBzdWJjaGFydCwgem9vbV07XHJcblx0XHRjb25zdCBheGlzU2hhcGVDb25maWcgPSBbYXJlYSwgYmFyLCBidWJibGUsIGxpbmUsIHNwbGluZV07XHJcblxyXG5cdFx0Y29uc3QgY29uZmlnID0gW1xyXG5cdFx0XHRkYXRhLFxyXG5cdFx0XHRjb2xvcixcclxuXHRcdFx0aW50ZXJhY3Rpb24sXHJcblx0XHRcdGxlZ2VuZCxcclxuXHRcdFx0dGl0bGUsXHJcblx0XHRcdHRvb2x0aXAsXHJcblx0XHRcdC4uLmFyY1NoYXBlQ29uZmlnLFxyXG5cdFx0XHQuLi5heGlzQ29uZmlnLFxyXG5cdFx0XHQuLi5heGlzU2hhcGVDb25maWdcclxuXHRcdF07XHJcblxyXG5cdFx0cmV0dXJuIG1lcmdlT2JqKHtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNwZWNpZnkgdGhlIENTUyBzZWxlY3RvciBvciB0aGUgZWxlbWVudCB3aGljaCB0aGUgY2hhcnQgd2lsbCBiZSBzZXQgdG8uIEQzIHNlbGVjdGlvbiBvYmplY3QgY2FuIGJlIHNwZWNpZmllZCBhbHNvLjxicj5cclxuXHRcdFx0ICogSWYgb3RoZXIgY2hhcnQgaXMgc2V0IGFscmVhZHksIGl0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IG9uZSAob25seSBvbmUgY2hhcnQgY2FuIGJlIHNldCBpbiBvbmUgZWxlbWVudCkuXHJcblx0XHRcdCAqIC0gKipOT1RFOioqIEluIGNhc2Ugb2YgZWxlbWVudCBkb2Vzbid0IGV4aXN0IG9yIG5vdCBzcGVjaWZpZWQsIHdpbGwgYWRkIGEgYDxkaXY+YCBlbGVtZW50IHRvIHRoZSBib2R5LlxyXG5cdFx0XHQgKiBAbmFtZSBiaW5kdG9cclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHByb3BlcnR5IHtzdHJpbmd8SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufG9iamVjdH0gW2JpbmR0bz1cIiNjaGFydFwiXSBTcGVjaWZ5IHRoZSBlbGVtZW50IHdoZXJlIGNoYXJ0IHdpbGwgYmUgZHJhd24uXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gYmluZHRvLmVsZW1lbnQ9XCIjY2hhcnRcIiBTcGVjaWZ5IHRoZSBlbGVtZW50IHdoZXJlIGNoYXJ0IHdpbGwgYmUgZHJhd24uXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYmluZHRvLmNsYXNzbmFtZT1iYl0gU3BlY2lmeSB0aGUgY2xhc3MgbmFtZSBvZiBiaW5kIGVsZW1lbnQuPGJyPlxyXG5cdFx0XHQgKiAgICAgKipOT1RFOioqIFdoZW4gY2xhc3MgbmFtZSBpc24ndCBgYmJgLCB0aGVuIHlvdSBhbHNvIG5lZWQgdG8gdXBkYXRlIHRoZSBkZWZhdWx0IENTUyB0byBiZSByZW5kZXJlZCBjb3JyZWN0bHkuXHJcblx0XHRcdCAqIEBkZWZhdWx0ICNjaGFydFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBiaW5kdG86IFwiI215Q29udGFpbmVyXCJcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogLy8gb3IgSFRNTEVsZW1lbnRcclxuXHRcdFx0ICogYmluZHRvOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q29udGFpbmVyXCIpXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIC8vIG9yIEQzIHNlbGVjdGlvbiBvYmplY3RcclxuXHRcdFx0ICogYmluZHRvOiBkMy5zZWxlY3QoXCIjbXlDb250YWluZXJcIilcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogLy8gb3IgdG8gY2hhbmdlIGRlZmF1bHQgY2xhc3NuYW1lXHJcblx0XHRcdCAqIGJpbmR0bzoge1xyXG5cdFx0XHQgKiAgICBlbGVtZW50OiBcIiNjaGFydFwiLFxyXG5cdFx0XHQgKiAgICBjbGFzc25hbWU6IFwiYmlsbC1ib2FyZFwiICAvLyBleCkgPGRpdiBpZD0nY2hhcnQnIGNsYXNzPSdiaWxsLWJvYXJkJz5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0YmluZHRvOiA8c3RyaW5nfHtlbGVtZW50OiBzdHJpbmc7IGNsYXNzbmFtZT86IHN0cmluZ30+IFwiI2NoYXJ0XCIsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGNoYXJ0IGJhY2tncm91bmQuXHJcblx0XHRcdCAqIEBuYW1lIGJhY2tncm91bmRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHByb3BlcnR5IHtvYmplY3R9IGJhY2tncm91bmQgYmFja2dyb3VuZCBvYmplY3RcclxuXHRcdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmQuY2xhc3MgU3BlY2lmeSB0aGUgY2xhc3MgbmFtZSBmb3IgYmFja2dyb3VuZCBlbGVtZW50LlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZC5jb2xvciBTcGVjaWZ5IHRoZSBmaWxsIGNvbG9yIGZvciBiYWNrZ3JvdW5kIGVsZW1lbnQuPGJyPioqTk9URToqKiBXaWxsIGJlIGlnbm9yZWQgaWYgYGltZ1VybGAgb3B0aW9uIGlzIHNldC5cclxuXHRcdFx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmQuaW1nVXJsIFNwZWNpZnkgdGhlIGltYWdlIHVybCBzdHJpbmcgZm9yIGJhY2tncm91bmQuXHJcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuQmFja2dyb3VuZClcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogYmFja2dyb3VuZDoge1xyXG5cdFx0XHQgKiAgICBjbGFzczogXCJteUNsYXNzXCIsXHJcblx0XHRcdCAqICAgIGNvbG9yOiBcInJlZFwiLFxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgICAvLyBTZXQgaW1hZ2UgdXJsIGZvciBiYWNrZ3JvdW5kLlxyXG5cdFx0XHQgKiAgICAvLyBJZiBzcGVjaWZpZWQsICdjb2xvcicgb3B0aW9uIHdpbGwgYmUgaWdub3JlZC5cclxuXHRcdFx0ICogICAgaW1nVXJsOiBcImh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9pbWcvbG9nby9iaWxsYm9hcmQuanMuc3ZnXCIsXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdGJhY2tncm91bmQ6IDx7Y2xhc3M/OiBzdHJpbmc7IGNvbG9yPzogc3RyaW5nOyBpbWdVcmw/OiBzdHJpbmc7fT4ge30sXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSBmb3IgY2hhcnQgZWxlbWVudFxyXG5cdFx0XHQgKiAtICoqTk9URToqKlxyXG5cdFx0XHQgKiAgPiBXaGVuIGlzIGZhbHNlLCBjaGFydCBub2RlIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBhZnRlciB0aGUgYXhpcyBub2RlIGluIERPTSB0cmVlIGhpZXJhcmNoeS5cclxuXHRcdFx0ICogID4gSXMgdG8gbWFrZSBjaGFydCBlbGVtZW50IHBvc2l0aW9uZWQgb3ZlciBheGlzIGVsZW1lbnQuXHJcblx0XHRcdCAqIEBuYW1lIGNsaXBQYXRoXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuY2xpcFBhdGgpXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuXHRcdFx0ICogY2xpcFBhdGg6IGZhbHNlXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRjbGlwUGF0aDogdHJ1ZSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgc3ZnIGVsZW1lbnQncyBjbGFzcyBuYW1lXHJcblx0XHRcdCAqIEBuYW1lIHN2Z1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gW3N2Z10gc3ZnIG9iamVjdFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3N2Zy5jbGFzc25hbWVdIGNsYXNzIG5hbWUgZm9yIHN2ZyBlbGVtZW50XHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHN2Zzoge1xyXG5cdFx0XHQgKiAgIGNsYXNzbmFtZTogXCJ0ZXN0X2NsYXNzXCJcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0c3ZnX2NsYXNzbmFtZTogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBUaGUgZGVzaXJlZCBzaXplIG9mIHRoZSBjaGFydCBlbGVtZW50LlxyXG5cdFx0XHQgKiBJZiB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgd2lkdGggb2YgdGhlIGNoYXJ0IHdpbGwgYmUgY2FsY3VsYXRlZCBieSB0aGUgc2l6ZSBvZiB0aGUgcGFyZW50IGVsZW1lbnQgaXQncyBhcHBlbmRlZCB0by5cclxuXHRcdFx0ICogQG5hbWUgc2l6ZVxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gW3NpemVdIHNpemUgb2JqZWN0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZS53aWR0aF0gd2lkdGggb2YgdGhlIGNoYXJ0IGVsZW1lbnRcclxuXHRcdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtzaXplLmhlaWdodF0gaGVpZ2h0IG9mIHRoZSBjaGFydCBlbGVtZW50XHJcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuQ2hhcnRTaXplKVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBzaXplOiB7XHJcblx0XHRcdCAqICAgd2lkdGg6IDY0MCxcclxuXHRcdFx0ICogICBoZWlnaHQ6IDQ4MFxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRzaXplX3dpZHRoOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdFx0XHRzaXplX2hlaWdodDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBUaGUgcGFkZGluZyBvZiB0aGUgY2hhcnQgZWxlbWVudC5cclxuXHRcdFx0ICogQG5hbWUgcGFkZGluZ1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge29iamVjdH0gW3BhZGRpbmddIHBhZGRpbmcgb2JqZWN0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFkZGluZy50b3BdIHBhZGRpbmcgb24gdGhlIHRvcCBvZiBjaGFydFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BhZGRpbmcucmlnaHRdIHBhZGRpbmcgb24gdGhlIHJpZ2h0IG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGFkZGluZy5ib3R0b21dIHBhZGRpbmcgb24gdGhlIGJvdHRvbSBvZiBjaGFydFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BhZGRpbmcubGVmdF0gcGFkZGluZyBvbiB0aGUgbGVmdCBvZiBjaGFydFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBwYWRkaW5nOiB7XHJcblx0XHRcdCAqICAgdG9wOiAyMCxcclxuXHRcdFx0ICogICByaWdodDogMjAsXHJcblx0XHRcdCAqICAgYm90dG9tOiAyMCxcclxuXHRcdFx0ICogICBsZWZ0OiAyMFxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRwYWRkaW5nX2xlZnQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0XHRcdHBhZGRpbmdfcmlnaHQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0XHRcdHBhZGRpbmdfdG9wOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdFx0XHRwYWRkaW5nX2JvdHRvbTogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgY2hhcnQgcmVzaXplIG9wdGlvbnNcclxuXHRcdFx0ICogQG5hbWUgcmVzaXplXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbcmVzaXplXSByZXNpemUgb2JqZWN0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Jlc2l6ZS5hdXRvPXRydWVdIFNldCBjaGFydCByZXNpemUgYXV0b21hdGljYWxseSBvbiB2aWV3cG9ydCBjaGFuZ2VzLlxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAgcmVzaXplOiB7XHJcblx0XHRcdCAqICAgICAgYXV0bzogZmFsc2VcclxuXHRcdFx0ICogIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHJlc2l6ZV9hdXRvOiB0cnVlLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBtb3VzZS90b3VjaCBlbnRlcnMgdGhlIGNoYXJ0LlxyXG5cdFx0XHQgKiBAbmFtZSBvbm92ZXJcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ub3ZlcjogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9ub3ZlcjogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggbGVhdmVzIHRoZSBjaGFydC5cclxuXHRcdFx0ICogQG5hbWUgb25vdXRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ub3V0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25vdXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHVzZXIgcmVzaXplcyB0aGUgc2NyZWVuLlxyXG5cdFx0XHQgKiBAbmFtZSBvbnJlc2l6ZVxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25yZXNpemU6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbnJlc2l6ZTogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gc2NyZWVuIHJlc2l6ZSBmaW5pc2hlZC5cclxuXHRcdFx0ICogQG5hbWUgb25yZXNpemVkXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbnJlc2l6ZWQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbnJlc2l6ZWQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXHJcblx0XHRcdCAqIEBuYW1lIG9uYmVmb3JlaW5pdFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25iZWZvcmVpbml0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25iZWZvcmVpbml0OiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgY2hhcnQgaXMgaW5pdGlhbGl6ZWQuXHJcblx0XHRcdCAqIEBuYW1lIG9uaW5pdFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25pbml0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25pbml0OiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXHJcblx0XHRcdCAqIEBuYW1lIG9uYWZ0ZXJpbml0XHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbmFmdGVyaW5pdDogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9uYWZ0ZXJpbml0OiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHJlbmRlcmVkLiBCYXNpY2FsbHksIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaW4gZWFjaCB0aW1lIHdoZW4gdGhlIGNoYXJ0IGlzIHJlZHJhd2VkLlxyXG5cdFx0XHQgKiBAbmFtZSBvbnJlbmRlcmVkXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbnJlbmRlcmVkOiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25yZW5kZXJlZDogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgZHVyYXRpb24gb2YgdHJhbnNpdGlvbiAoaW4gbWlsbGlzZWNvbmRzKSBmb3IgY2hhcnQgYW5pbWF0aW9uLjxicj48YnI+XHJcblx0XHRcdCAqIC0gKipOT1RFOioqIElmIGAwIGBvciBgbnVsbGAgc2V0LCB0cmFuc2l0aW9uIHdpbGwgYmUgc2tpcHBlZC4gU28sIHRoaXMgbWFrZXMgaW5pdGlhbCByZW5kZXJpbmcgZmFzdGVyIGVzcGVjaWFsbHkgaW4gY2FzZSB5b3UgaGF2ZSBhIGxvdCBvZiBkYXRhLlxyXG5cdFx0XHQgKiBAbmFtZSB0cmFuc2l0aW9uXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdHJhbnNpdGlvbl0gdHJhbnNpdGlvbiBvYmplY3RcclxuXHRcdFx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt0cmFuc2l0aW9uLmR1cmF0aW9uPTM1MF0gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHRyYW5zaXRpb246IHtcclxuXHRcdFx0ICogICAgZHVyYXRpb246IDUwMFxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0cmFuc2l0aW9uX2R1cmF0aW9uOiAzNTAsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IHNjYXR0ZXIgb3B0aW9uc1xyXG5cdFx0XHQgKiBAbmFtZSBzY2F0dGVyXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbc2NhdHRlcl0gc2NhdHRlciBvYmplY3RcclxuXHRcdFx0ICogQHByb3BlcnR5IHtib29sZWFufSBbc2NhdHRlci56ZXJvYmFzZWQ9ZmFsc2VdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBzY2F0dGVyIGNoYXJ0LlxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAgc2NhdHRlcjoge1xyXG5cdFx0XHQgKiAgICAgIGNvbm5lY3ROdWxsOiB0cnVlLFxyXG5cdFx0XHQgKiAgICAgIHN0ZXA6IHtcclxuXHRcdFx0ICogICAgICAgICAgdHlwZTogXCJzdGVwLWFmdGVyXCJcclxuXHRcdFx0ICogICAgICB9LFxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgICAgIC8vIGhpZGUgYWxsIGRhdGEgcG9pbnRzICgncG9pbnQuc2hvdz1mYWxzZScgYWxzbyBoYXMgc2ltaWxhciBlZmZlY3QpXHJcblx0XHRcdCAqICAgICAgcG9pbnQ6IGZhbHNlLFxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgICAgIC8vIHNob3cgZGF0YSBwb2ludHMgZm9yIG9ubHkgaW5kaWNhdGVkIGRhdGFzXHJcblx0XHRcdCAqICAgICAgcG9pbnQ6IFtcclxuXHRcdFx0ICogICAgICAgICAgXCJkYXRhMVwiLCBcImRhdGEzXCJcclxuXHRcdFx0ICogICAgICBdLFxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgICAgIHplcm9iYXNlZDogZmFsc2VcclxuXHRcdFx0ICogIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHNjYXR0ZXJfemVyb2Jhc2VkOiBmYWxzZSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgcGx1Z2luc1xyXG5cdFx0XHQgKiBAbmFtZSBwbHVnaW5zXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogIHBsdWdpbnM6IFtcclxuXHRcdFx0ICogICAgbmV3IGJiLnBsdWdpbi5zdGFuZm9yZCh7IC4uLiB9KSxcclxuXHRcdFx0ICogICAgbmV3IFBsdWdpbkEoKSxcclxuXHRcdFx0ICogICAgLi4uXHJcblx0XHRcdCAqIF1cclxuXHRcdFx0ICovXHJcblx0XHRcdHBsdWdpbnM6IFtdLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIENvbnRyb2wgdGhlIHJlbmRlciB0aW1pbmdcclxuXHRcdFx0ICogQG5hbWUgcmVuZGVyXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbcmVuZGVyXSByZW5kZXIgb2JqZWN0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlbmRlci5sYXp5PXRydWVdIE1ha2UgdG8gbm90IHJlbmRlciBhdCBpbml0aWFsaXphdGlvbiAoZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gYmluZCBlbGVtZW50J3MgdmlzaWJpbGl0eSBpcyBoaWRkZW4pLlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZW5kZXIub2JzZXJ2ZT10cnVlXSBPYnNlcnZlIGJpbmQgZWxlbWVudCdzIHZpc2liaWxpdHkoYGRpc3BsYXlgIG9yIGB2aXNpYmxpdHlgIGlubGluZSBjc3MgcHJvcGVydHkgb3IgY2xhc3MgdmFsdWUpICYgcmVuZGVyIHdoZW4gaXMgdmlzaWJsZSBhdXRvbWF0aWNhbGx5IChmb3IgSUVzLCBvbmx5IHdvcmtzIElFMTErKS4gV2hlbiBzZXQgdG8gKipmYWxzZSoqLCBjYWxsIFtgLmZsdXNoKClgXSguL0NoYXJ0Lmh0bWwjZmx1c2gpIHRvIHJlbmRlci5cclxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5MYXp5UmVuZGVyKVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAgcmVuZGVyOiB7XHJcblx0XHRcdCAqICAgIGxhenk6IHRydWUsXHJcblx0XHRcdCAqICAgIG9ic2VydmU6IHRydWVcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKlx0Ly8gPCEtLSByZW5kZXIubGF6eSB3aWxsIGRldGVjdCB2aXNpYmlsaXR5IGRlZmluZWQgLS0+XHJcblx0XHRcdCAqICAvLyAoYSkgPGRpdiBpZD0nY2hhcnQnIGNsYXNzPSdoaWRlJz48L2Rpdj5cclxuXHRcdFx0ICogIC8vIChiKSA8ZGl2IGlkPSdjaGFydCcgc3R5bGU9J2Rpc3BsYXk6bm9uZSc+PC9kaXY+XHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAvLyByZW5kZXIubGF6eSBlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBlbGVtZW50IGlzIGhpZGRlblxyXG5cdFx0XHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAvLyBjaGFydCB3aWxsIGJlIHJlbmRlcmVkIGF1dG9tYXRpY2FsbHkgd2hlbiBlbGVtZW50J3MgdmlzaWJpbGl0eSBjaGFuZ2VzXHJcblx0XHRcdCAqICAvLyBOb3RlOiB3b3JrcyBvbmx5IGZvciBpbmxpbmVkIGNzcyBwcm9wZXJ0eSBvciBjbGFzcyBhdHRyaWJ1dGUgY2hhbmdlc1xyXG5cdFx0XHQgKiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0JykuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpICAvLyAoYSlcclxuXHRcdFx0ICogIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFydCcpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAgLy8gKGIpXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqXHQvLyBjaGFydCB3b24ndCBiZSByZW5kZXJlZCBhbmQgbm90IG9ic2VydmluZyBiaW5kIGVsZW1lbnQncyB2aXNpYmxpdHkgY2hhbmdlc1xyXG5cdFx0XHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xyXG5cdFx0XHQgKiAgICAgcmVuZGVyOiB7XHJcblx0XHRcdCAqICAgICAgICAgIGxhenk6IHRydWUsXHJcblx0XHRcdCAqICAgICAgICAgIG9ic2VydmU6IGZhbHNlXHJcblx0XHRcdCAqICAgICB9XHJcblx0XHRcdCAqICB9KTtcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogIC8vIGNhbGwgYXQgYW55IHBvaW50IHdoZW4geW91IHdhbnQgdG8gcmVuZGVyXHJcblx0XHRcdCAqICBjaGFydC5mbHVzaCgpO1xyXG5cdFx0XHQgKi9cclxuXHRcdFx0cmVuZGVyOiA8e2xhenk/OiBib29sZWFuOyBvYnNlcnZlPzogYm9vbGVhbjt9PiB7fSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTaG93IHJlY3RhbmdsZXMgaW5zaWRlIHRoZSBjaGFydC48YnI+PGJyPlxyXG5cdFx0XHQgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgYXhpcywgc3RhcnQsIGVuZCBhbmQgY2xhc3MuXHJcblx0XHRcdCAqIFRoZSBrZXlzIHN0YXJ0LCBlbmQgYW5kIGNsYXNzIGFyZSBvcHRpb25hbC5cclxuXHRcdFx0ICogYXhpcyBtdXN0IGJlIHgsIHkgb3IgeTIuIHN0YXJ0IGFuZCBlbmQgc2hvdWxkIGJlIHRoZSB2YWx1ZSB3aGVyZSByZWdpb25zIHN0YXJ0IGFuZCBlbmQuXHJcblx0XHRcdCAqIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBlZGdlIHZhbHVlcyB3aWxsIGJlIHVzZWQuXHJcblx0XHRcdCAqIElmIHRpbWVzZXJpZXMgeCBheGlzLCBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3QgYW5kIHVuaXh0aW1lIGludGVnZXIgY2FuIGJlIHVzZWQuXHJcblx0XHRcdCAqIElmIGNsYXNzIGlzIHNldCwgdGhlIHJlZ2lvbiBlbGVtZW50IHdpbGwgaGF2ZSBpdCBhcyBjbGFzcy5cclxuXHRcdFx0ICogQG5hbWUgcmVnaW9uc1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0XHRcdCAqIEBkZWZhdWx0IFtdXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICByZWdpb25zOiBbXHJcblx0XHRcdCAqICAgIHtcclxuXHRcdFx0ICogICAgICBheGlzOiBcInhcIixcclxuXHRcdFx0ICogICAgICBzdGFydDogMSxcclxuXHRcdFx0ICogICAgICBlbmQ6IDQsXHJcblx0XHRcdCAqICAgICAgY2xhc3M6IFwicmVnaW9uLTEtNFwiXHJcblx0XHRcdCAqICAgIH1cclxuXHRcdFx0ICogIF1cclxuXHRcdFx0ICovXHJcblx0XHRcdHJlZ2lvbnM6IDx7YXhpcz86IHN0cmluZzsgc3RhcnQ/OiBudW1iZXI7IGVuZD86IG51bWJlcjsgY2xhc3M/OiBzdHJpbmc7fVtdPiBbXVxyXG5cdFx0fSwgLi4uY29uZmlnKTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIHRvQXJyYXl9IGZyb20gXCIuL3V0aWxcIjtcclxuaW1wb3J0IHtEYXRhUm93fSBmcm9tIFwiLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdGFudCBmb3IgY2FjaGUga2V5XHJcbiAqIC0gTk9URTogUHJlZml4ZWQgd2l0aCAnJCcsIHdpbGwgYmUgcmVzZXR0ZWQgd2hlbiAubG9hZCgpIGlzIGNhbGxlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEtFWSA9IHtcclxuXHRidWJibGVCYXNlTGVuZ3RoOiBcIiRiYXNlTGVuZ3RoXCIsXHJcblx0Y29sb3JQYXR0ZXJuOiBcIl9fY29sb3JQYXR0ZXJuX19cIixcclxuXHRkYXRhTWluTWF4OiBcIiRkYXRhTWluTWF4XCIsXHJcblx0ZGF0YVRvdGFsU3VtOiBcIiRkYXRhVG90YWxTdW1cIixcclxuXHRkYXRhVG90YWxQZXJJbmRleDogXCIkdG90YWxQZXJJbmRleFwiLFxyXG5cdGxlZ2VuZEl0ZW1UZXh0Qm94OiBcImxlZ2VuZEl0ZW1UZXh0Qm94XCIsXHJcblx0cmFkYXJQb2ludHM6IFwiJHJhZGFyUG9pbnRzXCIsXHJcblx0c2V0T3Zlck91dDogXCJzZXRPdmVyT3V0XCIsXHJcblx0Y2FsbE92ZXJPdXRGb3JUb3VjaDogXCJjYWxsT3Zlck91dEZvclRvdWNoXCIsXHJcblx0dGV4dFJlY3Q6IFwidGV4dFJlY3RcIlxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FjaGUge1xyXG5cdHByaXZhdGUgY2FjaGUgPSB7fTtcclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGNhY2hlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBDYWNoZSBrZXlcclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGJlIHN0b3JlZFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEYXRhVHlwZSBXZWF0aGVyIHRoZSBjYWNoZSBpcyBkYXRhIHR5cGVkICd7aWQ6J2RhdGEnLCBpZF9vcmc6ICdkYXRhJywgdmFsdWVzOiBbe3g6MCwgaW5kZXg6MCwuLi59LCAuLi5dfSdcclxuXHQgKiBAcmV0dXJucyB7Kn0gQWRkZWQgZGF0YSB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0YWRkKGtleTogc3RyaW5nLCB2YWx1ZSwgaXNEYXRhVHlwZSA9IGZhbHNlKSB7XHJcblx0XHR0aGlzLmNhY2hlW2tleV0gPSBpc0RhdGFUeXBlID8gdGhpcy5jbG9uZVRhcmdldCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlW2tleV07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgY2FjaGVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0ga2V5IENhY2hlIGtleVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVtb3ZlKGtleTogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdHRvQXJyYXkoa2V5KS5mb3JFYWNoKHYgPT4gZGVsZXRlIHRoaXMuY2FjaGVbdl0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGNhaGNlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGtleSBDYWNoZSBrZXlcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGF0YVR5cGUgV2VhdGhlciB0aGUgY2FjaGUgaXMgZGF0YSB0eXBlZCAne2lkOidkYXRhJywgaWRfb3JnOiAnZGF0YScsIHZhbHVlczogW3t4OjAsIGluZGV4OjAsLi4ufSwgLi4uXX0nXHJcblx0ICogQHJldHVybnMgeyp9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXQoa2V5OiBzdHJpbmcsIGlzRGF0YVR5cGUgPSBmYWxzZSk6IGFueSB8IG51bGwge1xyXG5cdFx0aWYgKGlzRGF0YVR5cGUpIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0czogYW55W10gPSBbXTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpZDsgKGlkID0ga2V5W2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKGlkIGluIHRoaXMuY2FjaGUpIHtcclxuXHRcdFx0XHRcdHRhcmdldHMucHVzaCh0aGlzLmNsb25lVGFyZ2V0KHRoaXMuY2FjaGVbaWRdKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5jYWNoZVtrZXldO1xyXG5cclxuXHRcdFx0cmV0dXJuIGlzVmFsdWUodmFsdWUpID8gdmFsdWUgOiBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVzZXQgY2FjaGVkIGRhdGFcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbCB0cnVlOiByZXNldCBhbGwgZGF0YSwgZmFsc2U6IHJlc2V0IG9ubHkgJyQnIHByZWZpeGVkIGtleSBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZXNldChhbGw/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Zm9yIChjb25zdCB4IGluICQkLmNhY2hlKSB7XHJcblx0XHRcdC8vIHJlc2V0IHRoZSBwcmVmaXhlZCAnJCcga2V5KHdoaWNoIGlzIGludGVybmFsIHVzZSBkYXRhKSBvbmx5LlxyXG5cdFx0XHRpZiAoYWxsIHx8IC9eXFwkLy50ZXN0KHgpKSB7XHJcblx0XHRcdFx0JCQuY2FjaGVbeF0gPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbG9uZSBkYXRhIHRhcmdldCBvYmplY3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcclxuXHRjbG9uZVRhcmdldCh0YXJnZXQ6IERhdGFSb3cpOiBEYXRhUm93IHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGlkOiB0YXJnZXQuaWQsXHJcblx0XHRcdGlkX29yZzogdGFyZ2V0LmlkX29yZyxcclxuXHRcdFx0dmFsdWVzOiB0YXJnZXQudmFsdWVzLm1hcChkID0+ICh7eDogZC54LCB2YWx1ZTogZC52YWx1ZSwgaWQ6IGQuaWR9KSlcclxuXHRcdH07XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuL2Jyb3dzZXJcIjtcclxuaW1wb3J0IHtpc0FycmF5fSBmcm9tIFwiLi91dGlsXCI7XHJcblxyXG5jb25zdCB7c2V0VGltZW91dCwgY2xlYXJUaW1lb3V0fSA9IHdpbmRvdztcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSByZXNpemUgcXVldWUgZnVuY3Rpb25cclxuICogQHJldHVybnMge0Z1Y250aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmVzaXplKCkge1xyXG5cdGNvbnN0IGZuOiBhbnlbXSA9IFtdO1xyXG5cdGxldCB0aW1lb3V0O1xyXG5cclxuXHRjb25zdCBjYWxsUmVzaXplRm4gPSBmdW5jdGlvbigpIHtcclxuXHRcdC8vIERlbGF5IGFsbCByZXNpemUgZnVuY3Rpb25zIGNhbGwsIHRvIHByZXZlbnQgdW5pbnRlbmRlZCBleGNlc3NpdmUgY2FsbCBmcm9tIHJlc2l6ZSBldmVudFxyXG5cdFx0Y2FsbFJlc2l6ZUZuLmNsZWFyKCk7XHJcblxyXG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRmbi5mb3JFYWNoKChmOiBGdW5jdGlvbikgPT4gZigpKTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fTtcclxuXHJcblx0Y2FsbFJlc2l6ZUZuLmNsZWFyID0gKCkgPT4ge1xyXG5cdFx0aWYgKHRpbWVvdXQpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cdFx0XHR0aW1lb3V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRjYWxsUmVzaXplRm4uYWRkID0gZiA9PiBmbi5wdXNoKGYpO1xyXG5cdGNhbGxSZXNpemVGbi5yZW1vdmUgPSBmID0+IGZuLnNwbGljZShmbi5pbmRleE9mKGYpLCAxKTtcclxuXHJcblx0cmV0dXJuIGNhbGxSZXNpemVGbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHRyYW5zaXRpb24gcXVldWUgZnVuY3Rpb25cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlV2FpdCgpIHtcclxuXHRsZXQgdHJhbnNpdGlvbnNUb1dhaXQ6IGFueSA9IFtdO1xyXG5cdGNvbnN0IGYgPSBmdW5jdGlvbih0LCBjYWxsYmFjaykge1xyXG5cdFx0bGV0IHRpbWVyO1xyXG5cclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gbG9vcCgpIHtcclxuXHRcdFx0bGV0IGRvbmUgPSAwO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIHQ7ICh0ID0gdHJhbnNpdGlvbnNUb1dhaXRbaV0pOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodCA9PT0gdHJ1ZSB8fCAodC5lbXB0eSAmJiB0LmVtcHR5KCkpKSB7XHJcblx0XHRcdFx0XHRkb25lKys7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR0LnRyYW5zaXRpb24oKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRkb25lKys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xyXG5cclxuXHRcdFx0aWYgKGRvbmUgPT09IHRyYW5zaXRpb25zVG9XYWl0Lmxlbmd0aCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KGxvb3AsIDUwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxvb3AoKTtcclxuXHR9O1xyXG5cclxuXHRmLmFkZCA9IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlzQXJyYXkodCkgP1xyXG5cdFx0XHQodHJhbnNpdGlvbnNUb1dhaXQgPSB0cmFuc2l0aW9uc1RvV2FpdC5jb25jYXQodCkpIDpcclxuXHRcdFx0dHJhbnNpdGlvbnNUb1dhaXQucHVzaCh0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gZjtcclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuaW1wb3J0IHtzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyfSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuaW1wb3J0IHtpc0RlZmluZWQsIGlzTnVtYmVyLCBpc1N0cmluZ30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpc1JlbmRlcmVySGVscGVyIHtcclxuXHRwcml2YXRlIG93bmVyO1xyXG5cdHByaXZhdGUgY29uZmlnO1xyXG5cdHByaXZhdGUgc2NhbGU7XHJcblxyXG5cdGNvbnN0cnVjdG9yKG93bmVyKSB7XHJcblx0XHRjb25zdCBzY2FsZSA9IGQzU2NhbGVMaW5lYXIoKTtcclxuXHRcdGNvbnN0IHtjb25maWcsIHBhcmFtc30gPSBvd25lcjtcclxuXHJcblx0XHR0aGlzLm93bmVyID0gb3duZXI7XHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdHRoaXMuc2NhbGUgPSBzY2FsZTtcclxuXHJcblx0XHRpZiAoY29uZmlnLm5vVHJhbnNpdGlvbiB8fCAhcGFyYW1zLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKSB7XHJcblx0XHRcdGNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2V0IHJhbmdlXHJcblx0XHRjb25maWcucmFuZ2UgPSB0aGlzLnNjYWxlRXh0ZW50KChwYXJhbXMub3JnWFNjYWxlIHx8IHNjYWxlKS5yYW5nZSgpKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbXB1dGUgYSBjaGFyYWN0ZXIgZGltZW5zaW9uXHJcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IG5vZGUgPGcgY2xhc3M9dGljaz4gbm9kZVxyXG5cdCAqIEByZXR1cm5zIHt7dzogbnVtYmVyLCBoOiBudW1iZXJ9fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c3RhdGljIGdldFNpemVGb3IxQ2hhcihub2RlPykge1xyXG5cdFx0Ly8gZGVmYXVsdCBzaXplIGZvciBvbmUgY2hhcmFjdGVyXHJcblx0XHRjb25zdCBzaXplID0ge1xyXG5cdFx0XHR3OiA1LjUsXHJcblx0XHRcdGg6IDExLjVcclxuXHRcdH07XHJcblxyXG5cdFx0IW5vZGUuZW1wdHkoKSAmJiBub2RlLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LnRleHQoXCIwXCIpXHJcblx0XHRcdC5jYWxsKGVsID0+IHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWwubm9kZSgpLmdldEJCb3goKTtcclxuXHJcblx0XHRcdFx0XHRpZiAod2lkdGggJiYgaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdHNpemUudyA9IHdpZHRoO1xyXG5cdFx0XHRcdFx0XHRzaXplLmggPSBoZWlnaHQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdH0gZmluYWxseSB7XHJcblx0XHRcdFx0XHRlbC50ZXh0KFwiXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0dGhpcy5nZXRTaXplRm9yMUNoYXIgPSAoKSA9PiBzaXplO1xyXG5cclxuXHRcdHJldHVybiBzaXplO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgdHJhbnNmb3JtIHNldHRlciBmdW5jdGlvblxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSB0cmFuc2Zyb20gc2V0dGVyIGZ1bmN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUaWNrVHJhbnNmb3JtU2V0dGVyKGlkOiBzdHJpbmcpOiAoc2VsZWN0aW9uOiBkM1NlbGVjdGlvbiwgc2NhbGUpID0+IHZvaWQge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgZm4gPSBpZCA9PT0gXCJ4XCIgP1xyXG5cdFx0XHR2YWx1ZSA9PiBgdHJhbnNsYXRlKCR7dmFsdWUgKyBjb25maWcudGlja09mZnNldH0sMClgIDpcclxuXHRcdFx0dmFsdWUgPT4gYHRyYW5zbGF0ZSgwLCR7dmFsdWV9KWA7XHJcblxyXG5cdFx0cmV0dXJuIChzZWxlY3Rpb24sIHNjYWxlKSA9PiB7XHJcblx0XHRcdHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gZm4oTWF0aC5jZWlsKHNjYWxlKGQpKSkpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdHNjYWxlRXh0ZW50KGRvbWFpbjogW251bWJlciwgbnVtYmVyXSk6IFtudW1iZXIsIG51bWJlcl0ge1xyXG5cdFx0Y29uc3Qgc3RhcnQgPSBkb21haW5bMF07XHJcblx0XHRjb25zdCBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcclxuXHJcblx0XHRyZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRpY2tzKHNjYWxlLCBpc1lBeGVzOiBib29sZWFuKTogbnVtYmVyW10ge1xyXG5cdFx0Y29uc3Qge3RpY2tTdGVwU2l6ZX0gPSB0aGlzLm93bmVyLnBhcmFtcztcclxuXHRcdGxldCB0aWNrczogbnVtYmVyW10gPSBbXTtcclxuXHJcblx0XHQvLyBXaGVuICdheGlzW3l8eTJdLnRpY2suc3RlcFNpemUnIG9wdGlvbiBpcyBzZXRcclxuXHRcdGlmIChpc1lBeGVzICYmIHRpY2tTdGVwU2l6ZSkge1xyXG5cdFx0XHRjb25zdCBbc3RhcnQsIGVuZF0gPSBzY2FsZS5kb21haW4oKTtcclxuXHRcdFx0bGV0IGludGVydmFsID0gc3RhcnQ7XHJcblxyXG5cdFx0XHR3aGlsZSAoaW50ZXJ2YWwgPD0gZW5kKSB7XHJcblx0XHRcdFx0dGlja3MucHVzaChpbnRlcnZhbCk7XHJcblx0XHRcdFx0aW50ZXJ2YWwgKz0gdGlja1N0ZXBTaXplO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHNjYWxlLnRpY2tzKSB7XHJcblx0XHRcdHRpY2tzID0gc2NhbGUudGlja3MoXHJcblx0XHRcdFx0Li4uKHRoaXMuY29uZmlnLnRpY2tBcmd1bWVudHMgfHwgW10pXHJcblx0XHRcdCkubWFwKHYgPT4gKFxyXG5cdFx0XHRcdC8vIHJvdW5kIHRoZSB0aWNrIHZhbHVlIGlmIGlzIG51bWJlclxyXG5cdFx0XHRcdChpc1N0cmluZyh2KSAmJiBpc051bWJlcih2KSAmJiAhaXNOYU4odikgJiZcclxuXHRcdFx0XHRcdE1hdGgucm91bmQodiAqIDEwKSAvIDEwXHJcblx0XHRcdFx0KSB8fCB2XHJcblx0XHRcdCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gTWF0aC5jZWlsKGRvbWFpblswXSk7IGkgPCBkb21haW5bMV07IGkrKykge1xyXG5cdFx0XHRcdHRpY2tzLnB1c2goaSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh0aWNrcy5sZW5ndGggPiAwICYmIHRpY2tzWzBdID4gMCkge1xyXG5cdFx0XHRcdHRpY2tzLnVuc2hpZnQodGlja3NbMF0gLSAodGlja3NbMV0gLSB0aWNrc1swXSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRpY2tzO1xyXG5cdH1cclxuXHJcblx0Y29weVNjYWxlKCkge1xyXG5cdFx0Y29uc3QgbmV3U2NhbGUgPSB0aGlzLnNjYWxlLmNvcHkoKTtcclxuXHJcblx0XHRpZiAoIW5ld1NjYWxlLmRvbWFpbigpLmxlbmd0aCkge1xyXG5cdFx0XHRuZXdTY2FsZS5kb21haW4odGhpcy5zY2FsZS5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ld1NjYWxlO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvcm1hdHRlZCh2OiBzdHJpbmcgfCBudW1iZXIgfCBhbnkpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgdGlja0Zvcm1hdCA9IHRoaXMuY29uZmlnLnRpY2tGb3JtYXQ7XHJcblxyXG5cdFx0Ly8gdG8gcm91bmQgZmxvYXQgbnVtYmVycyBmcm9tICdiaW5hcnkgZmxvYXRpbmcgcG9pbnQnXHJcblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibGUtcHJlY2lzaW9uX2Zsb2F0aW5nLXBvaW50X2Zvcm1hdFxyXG5cdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4NDkxMDEvbGF5bWFucy1leHBsYW5hdGlvbi1mb3Itd2h5LWphdmFzY3JpcHQtaGFzLXdlaXJkLWZsb2F0aW5nLW1hdGgtaWVlZS03NTQtc3RhbmRcclxuXHRcdGNvbnN0IHZhbHVlID0gL1xcZCtcXC5cXGQrMHs1LH1cXGQkLy50ZXN0KHYpID8gK1N0cmluZyh2KS5yZXBsYWNlKC8wK1xcZCQvLCBcIlwiKSA6IHY7XHJcblx0XHRjb25zdCBmb3JtYXR0ZWQgPSB0aWNrRm9ybWF0ID8gdGlja0Zvcm1hdCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKGZvcm1hdHRlZCkgPyBmb3JtYXR0ZWQgOiBcIlwiO1xyXG5cdH1cclxuXHJcblx0dHJhbnNpdGlvbmlzZShzZWxlY3Rpb24pOiBkM1NlbGVjdGlvbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA/XHJcblx0XHRcdHNlbGVjdGlvbi5pbnRlcnJ1cHQoKSA6IHNlbGVjdGlvbi50cmFuc2l0aW9uKGNvbmZpZy50cmFuc2l0aW9uKTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5pbXBvcnQgSGVscGVyIGZyb20gXCIuL0F4aXNSZW5kZXJlckhlbHBlclwiO1xyXG5pbXBvcnQge2lzQXJyYXksIHRvQXJyYXksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlcn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBeGlzUmVuZGVyZXIge1xyXG5cdGhlbHBlcjtcclxuXHRjb25maWc7XHJcblx0cGFyYW1zO1xyXG5cdGc7XHJcblxyXG5cdGNvbnN0cnVjdG9yKHBhcmFtczogYW55ID0ge30pIHtcclxuXHRcdGNvbnN0IGNvbmZpZyA9IHtcclxuXHRcdFx0aW5uZXJUaWNrU2l6ZTogNixcclxuXHRcdFx0b3V0ZXJUaWNrU2l6ZTogcGFyYW1zLm91dGVyVGljayA/IDYgOiAwLFxyXG5cdFx0XHRvcmllbnQ6IFwiYm90dG9tXCIsXHJcblx0XHRcdHJhbmdlOiBbXSxcclxuXHRcdFx0dGlja0FyZ3VtZW50czogbnVsbCxcclxuXHRcdFx0dGlja0NlbnRlcmVkOiBudWxsLFxyXG5cdFx0XHR0aWNrQ3VsbGluZzogdHJ1ZSxcclxuXHRcdFx0dGlja0Zvcm1hdDogbnVsbCxcclxuXHRcdFx0dGlja0xlbmd0aDogOSxcclxuXHRcdFx0dGlja09mZnNldDogMCxcclxuXHRcdFx0dGlja1BhZGRpbmc6IDMsXHJcblx0XHRcdHRpY2tWYWx1ZXM6IG51bGwsXHJcblx0XHRcdHRyYW5zaXRpb246IG51bGwsXHJcblx0XHRcdG5vVHJhbnNpdGlvbjogcGFyYW1zLm5vVHJhbnNpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25maWcudGlja0xlbmd0aCA9IE1hdGgubWF4KGNvbmZpZy5pbm5lclRpY2tTaXplLCAwKSArIGNvbmZpZy50aWNrUGFkZGluZztcclxuXHJcblx0XHR0aGlzLmNvbmZpZyA9IGNvbmZpZztcclxuXHRcdHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG5cdFx0dGhpcy5oZWxwZXIgPSBuZXcgSGVscGVyKHRoaXMpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlIGF4aXMgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBnIEF4aXMgc2VsZWN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjcmVhdGUoZzogZDNTZWxlY3Rpb24pOiB2b2lkIHtcclxuXHRcdGNvbnN0IGN0eCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBoZWxwZXIsIHBhcmFtc30gPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NjYWxlfSA9IGhlbHBlcjtcclxuXHRcdGNvbnN0IHtvcmllbnR9ID0gY29uZmlnO1xyXG5cdFx0Y29uc3Qgc3BsaXRUaWNrVGV4dCA9IHRoaXMuc3BsaXRUaWNrVGV4dC5iaW5kKHRoaXMpO1xyXG5cdFx0Y29uc3QgaXNMZWZ0UmlnaHQgPSAvXihsZWZ0fHJpZ2h0KSQvLnRlc3Qob3JpZW50KTtcclxuXHRcdGNvbnN0IGlzVG9wQm90dG9tID0gL14odG9wfGJvdHRvbSkkLy50ZXN0KG9yaWVudCk7XHJcblxyXG5cdFx0Ly8gbGluZS90ZXh0IGVudGVyIGFuZCBwYXRoIHVwZGF0ZVxyXG5cdFx0Y29uc3QgdGlja1RyYW5zZm9ybSA9IGhlbHBlci5nZXRUaWNrVHJhbnNmb3JtU2V0dGVyKGlzVG9wQm90dG9tID8gXCJ4XCIgOiBcInlcIik7XHJcblx0XHRjb25zdCBheGlzUHggPSB0aWNrVHJhbnNmb3JtID09PSBoZWxwZXIuYXhpc1ggPyBcInlcIiA6IFwieFwiO1xyXG5cdFx0Y29uc3Qgc2lnbiA9IC9eKHRvcHxsZWZ0KSQvLnRlc3Qob3JpZW50KSA/IC0xIDogMTtcclxuXHJcblx0XHQvLyB0aWNrIHRleHQgaGVscGVyc1xyXG5cdFx0Y29uc3Qgcm90YXRlID0gcGFyYW1zLnRpY2tUZXh0Um90YXRlO1xyXG5cclxuXHRcdHRoaXMuY29uZmlnLnJhbmdlID0gc2NhbGUucmFuZ2VFeHRlbnQgP1xyXG5cdFx0XHRzY2FsZS5yYW5nZUV4dGVudCgpIDpcclxuXHRcdFx0aGVscGVyLnNjYWxlRXh0ZW50KChwYXJhbXMub3JnWFNjYWxlIHx8IHNjYWxlKS5yYW5nZSgpKTtcclxuXHJcblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgdGlja0xlbmd0aCwgcmFuZ2V9ID0gY29uZmlnO1xyXG5cclxuXHRcdC8vIC8vIGdldCB0aGUgYXhpcycgdGljayBwb3NpdGlvbiBjb25maWd1cmF0aW9uXHJcblx0XHRjb25zdCBpZCA9IHBhcmFtcy5pZDtcclxuXHRcdGNvbnN0IHRpY2tUZXh0UG9zID0gaWQgJiYgL14oeHx5fHkyKSQvLnRlc3QoaWQpID9cclxuXHRcdFx0cGFyYW1zLmNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3RleHRfcG9zaXRpb25gXSA6IHt4OiAwLCB5OiAwfTtcclxuXHJcblx0XHQvLyB0aWNrIHZpc2libGl0eVxyXG5cdFx0Y29uc3QgcHJlZml4ID0gaWQgPT09IFwic3ViWFwiID8gYHN1YmNoYXJ0X2F4aXNfeGAgOiBgYXhpc18ke2lkfWA7XHJcblx0XHRjb25zdCBheGlzU2hvdyA9IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV9zaG93YF07XHJcblx0XHRjb25zdCB0aWNrU2hvdyA9IHtcclxuXHRcdFx0dGljazogYXhpc1Nob3cgPyBwYXJhbXMuY29uZmlnW2Ake3ByZWZpeH1fdGlja19zaG93YF0gOiBmYWxzZSxcclxuXHRcdFx0dGV4dDogYXhpc1Nob3cgPyBwYXJhbXMuY29uZmlnW2Ake3ByZWZpeH1fdGlja190ZXh0X3Nob3dgXSA6IGZhbHNlXHJcblx0XHR9O1xyXG5cclxuXHRcdGxldCAkZztcclxuXHJcblx0XHRnLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnN0IGcgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0bGV0IHNjYWxlMCA9IHRoaXMuX19jaGFydF9fIHx8IHNjYWxlO1xyXG5cdFx0XHRsZXQgc2NhbGUxID0gaGVscGVyLmNvcHlTY2FsZSgpO1xyXG5cclxuXHRcdFx0JGcgPSBnO1xyXG5cdFx0XHR0aGlzLl9fY2hhcnRfXyA9IHNjYWxlMTtcclxuXHJcblx0XHRcdGNvbmZpZy50aWNrT2Zmc2V0ID0gcGFyYW1zLmlzQ2F0ZWdvcnkgP1xyXG5cdFx0XHRcdE1hdGguY2VpbCgoc2NhbGUxKDEpIC0gc2NhbGUxKDApKSAvIDIpIDogMDtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb24gLSBkYXRhIGpvaW5cclxuXHRcdFx0Y29uc3QgcGF0aCA9IGcuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFswXSk7XHJcblxyXG5cdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cclxuXHRcdFx0cGF0aC5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpXHJcblx0XHRcdFx0Lm1lcmdlKGhlbHBlci50cmFuc2l0aW9uaXNlKHBhdGgpKVxyXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBvdXRlclRpY2tTaXplZCA9IGNvbmZpZy5vdXRlclRpY2tTaXplICogc2lnbjtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gaXNUb3BCb3R0b20gP1xyXG5cdFx0XHRcdFx0XHRgTSR7cmFuZ2VbMF19LCR7b3V0ZXJUaWNrU2l6ZWR9VjBIJHtyYW5nZVsxXX1WJHtvdXRlclRpY2tTaXplZH1gIDpcclxuXHRcdFx0XHRcdFx0YE0ke291dGVyVGlja1NpemVkfSwke3JhbmdlWzBdfUgwViR7cmFuZ2VbMV19SCR7b3V0ZXJUaWNrU2l6ZWR9YDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdGlmICh0aWNrU2hvdy50aWNrIHx8IHRpY2tTaG93LnRleHQpIHtcclxuXHRcdFx0XHQvLyBjb3VudCBvZiB0aWNrIGRhdGEgaW4gYXJyYXlcclxuXHRcdFx0XHRjb25zdCB0aWNrcyA9IGNvbmZpZy50aWNrVmFsdWVzIHx8IGhlbHBlci5nZW5lcmF0ZVRpY2tzKHNjYWxlMSwgaXNMZWZ0UmlnaHQpO1xyXG5cclxuXHRcdFx0XHQvLyB1cGRhdGUgc2VsZWN0aW9uXHJcblx0XHRcdFx0bGV0IHRpY2s6IGQzU2VsZWN0aW9uID0gZy5zZWxlY3RBbGwoXCIudGlja1wiKVxyXG5cdFx0XHRcdFx0LmRhdGEodGlja3MsIHNjYWxlMSk7XHJcblxyXG5cdFx0XHRcdC8vIGVudGVyIHNlbGVjdGlvblxyXG5cdFx0XHRcdGNvbnN0IHRpY2tFbnRlciA9IHRpY2tcclxuXHRcdFx0XHRcdC5lbnRlcigpXHJcblx0XHRcdFx0XHQuaW5zZXJ0KFwiZ1wiLCBcIi5kb21haW5cIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgXCJ0aWNrXCIpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHJcblx0XHRcdFx0Ly8gTUVNTzogTm8gZXhpdCB0cmFuc2l0aW9uLiBUaGUgcmVhc29uIGlzIHRoaXMgdHJhbnNpdGlvbiBhZmZlY3RzIG1heCB0aWNrIHdpZHRoIGNhbGN1bGF0aW9uIGJlY2F1c2Ugb2xkIHRpY2sgd2lsbCBiZSBpbmNsdWRlZCBpbiB0aGUgdGlja3MuXHJcblx0XHRcdFx0Y29uc3QgdGlja0V4aXQgPSB0aWNrLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdFx0Ly8gZW50ZXIgKyB1cGRhdGUgc2VsZWN0aW9uXHJcblx0XHRcdFx0dGljayA9IHRpY2tFbnRlci5tZXJnZSh0aWNrKTtcclxuXHJcblx0XHRcdFx0dGlja1Nob3cudGljayAmJiB0aWNrRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcclxuXHRcdFx0XHR0aWNrU2hvdy50ZXh0ICYmIHRpY2tFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaXplRm9yMUNoYXIgPSBIZWxwZXIuZ2V0U2l6ZUZvcjFDaGFyKHRpY2spO1xyXG5cdFx0XHRcdGNvbnN0IGNvdW50czogbnVtYmVyW10gPSBbXTtcclxuXHJcblx0XHRcdFx0bGV0IHRzcGFuOiBkM1NlbGVjdGlvbiA9IHRpY2suc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdFx0LnNlbGVjdEFsbChcInRzcGFuXCIpXHJcblx0XHRcdFx0XHQuZGF0YSgoZCwgaW5kZXgpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc3BsaXQgPSBwYXJhbXMudGlja011bHRpbGluZSA/XHJcblx0XHRcdFx0XHRcdFx0c3BsaXRUaWNrVGV4dChkLCBzY2FsZTEsIHRpY2tzLCBpc0xlZnRSaWdodCwgc2l6ZUZvcjFDaGFyLncpIDogKFxyXG5cdFx0XHRcdFx0XHRcdFx0aXNBcnJheShoZWxwZXIudGV4dEZvcm1hdHRlZChkKSkgP1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWxwZXIudGV4dEZvcm1hdHRlZChkKS5jb25jYXQoKSA6IFtoZWxwZXIudGV4dEZvcm1hdHRlZChkKV1cclxuXHRcdFx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdFx0Y291bnRzW2luZGV4XSA9IHNwbGl0Lmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBzcGxpdC5tYXAoc3BsaXR0ZWQgPT4gKHtpbmRleCwgc3BsaXR0ZWR9KSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dHNwYW4uZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0XHR0c3BhbiA9IHRzcGFuXHJcblx0XHRcdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHRcdFx0LmFwcGVuZChcInRzcGFuXCIpXHJcblx0XHRcdFx0XHQubWVyZ2UodHNwYW4pXHJcblx0XHRcdFx0XHQudGV4dChkID0+IGQuc3BsaXR0ZWQpO1xyXG5cclxuXHRcdFx0XHQvLyBzZXQgPHRzcGFuPidzIHBvc2l0aW9uXHJcblx0XHRcdFx0dHNwYW5cclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBpc1RvcEJvdHRvbSA/IDAgOiB0aWNrTGVuZ3RoICogc2lnbilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0bGV0IGR4ID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICgvKHRvcHxib3R0b20pLy50ZXN0KG9yaWVudCkgJiYgcm90YXRlKSB7XHJcblx0XHRcdFx0XHRcdFx0ZHggPSA4ICogTWF0aC5zaW4oTWF0aC5QSSAqIChyb3RhdGUgLyAxODApKSAqIChvcmllbnQgPT09IFwidG9wXCIgPyAtMSA6IDEpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZHggKyAodGlja1RleHRQb3MueCB8fCAwKTtcclxuXHRcdFx0XHRcdH0pKCkpXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIChkLCBpKSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRlZlZhbHVlID0gXCIuNzFlbVwiO1xyXG5cdFx0XHRcdFx0XHRsZXQgZHk6IG51bWJlciB8IHN0cmluZyA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAob3JpZW50ICE9PSBcInRvcFwiKSB7XHJcblx0XHRcdFx0XHRcdFx0ZHkgPSBzaXplRm9yMUNoYXIuaDtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKGkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGR5ID0gaXNMZWZ0UmlnaHQgPyAtKChjb3VudHNbZC5pbmRleF0gLSAxKSAqIChzaXplRm9yMUNoYXIuaCAvIDIpIC0gMykgOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQodGlja1RleHRQb3MueSA9PT0gMCA/IGRlZlZhbHVlIDogMCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaXNOdW1iZXIoZHkpICYmIHRpY2tUZXh0UG9zLnkgP1xyXG5cdFx0XHRcdFx0XHRcdGR5ICsgdGlja1RleHRQb3MueSA6IGR5IHx8IGRlZlZhbHVlO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGxpbmVVcGRhdGUgPSB0aWNrLnNlbGVjdChcImxpbmVcIik7XHJcblx0XHRcdFx0Y29uc3QgdGV4dFVwZGF0ZSA9IHRpY2suc2VsZWN0KFwidGV4dFwiKTtcclxuXHJcblx0XHRcdFx0dGlja0VudGVyLnNlbGVjdChcImxpbmVcIikuYXR0cihgJHtheGlzUHh9MmAsIGlubmVyVGlja1NpemUgKiBzaWduKTtcclxuXHRcdFx0XHR0aWNrRW50ZXIuc2VsZWN0KFwidGV4dFwiKS5hdHRyKGF4aXNQeCwgdGlja0xlbmd0aCAqIHNpZ24pO1xyXG5cclxuXHRcdFx0XHRjdHguc2V0VGlja0xpbmVUZXh0UG9zaXRpb24obGluZVVwZGF0ZSwgdGV4dFVwZGF0ZSk7XHJcblxyXG5cdFx0XHRcdC8vIEFwcGVuZCA8dGl0bGU+IGZvciB0b29sdGlwIGRpc3BsYXlcclxuXHRcdFx0XHRpZiAocGFyYW1zLnRpY2tUaXRsZSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdGl0bGUgPSB0ZXh0VXBkYXRlLnNlbGVjdChcInRpdGxlXCIpO1xyXG5cclxuXHRcdFx0XHRcdCh0aXRsZS5lbXB0eSgpID8gdGV4dFVwZGF0ZS5hcHBlbmQoXCJ0aXRsZVwiKSA6IHRpdGxlKVxyXG5cdFx0XHRcdFx0XHQudGV4dChpbmRleCA9PiBwYXJhbXMudGlja1RpdGxlW2luZGV4XSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoc2NhbGUxLmJhbmR3aWR0aCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHNjYWxlMTtcclxuXHRcdFx0XHRcdGNvbnN0IGR4ID0geC5iYW5kd2lkdGgoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0c2NhbGUwID0gZCA9PiB4KGQpICsgZHg7XHJcblx0XHRcdFx0XHRzY2FsZTEgPSBzY2FsZTA7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChzY2FsZTAuYmFuZHdpZHRoKSB7XHJcblx0XHRcdFx0XHRzY2FsZTAgPSBzY2FsZTE7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpY2tUcmFuc2Zvcm0odGlja0V4aXQsIHNjYWxlMSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aWNrVHJhbnNmb3JtKHRpY2tFbnRlciwgc2NhbGUwKTtcclxuXHRcdFx0XHR0aWNrVHJhbnNmb3JtKGhlbHBlci50cmFuc2l0aW9uaXNlKHRpY2spLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIiksIHNjYWxlMSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuZyA9ICRnO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgeC95IGNvb3JkaW5hdGVcclxuXHQgKiBAcmV0dXJucyB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRpY2tYWSgpOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9IHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IHBvcyA9IHt4OiAwLCB5OiAwfTtcclxuXHJcblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRwb3MueCA9IGNvbmZpZy50aWNrQ2VudGVyZWQgPyAwIDogY29uZmlnLnRpY2tPZmZzZXQ7XHJcblx0XHRcdHBvcy55ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IGNvbmZpZy50aWNrT2Zmc2V0IDogMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9zO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgc2l6ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIGRhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRpY2tTaXplKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3Qge3NjYWxlfSA9IHRoaXMuaGVscGVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2lubmVyVGlja1NpemUsIHJhbmdlfSA9IGNvbmZpZztcclxuXHJcblx0XHRjb25zdCB0aWNrUG9zaXRpb24gPSBzY2FsZShkKSArXHJcblx0XHRcdChjb25maWcudGlja0NlbnRlcmVkID8gMCA6IGNvbmZpZy50aWNrT2Zmc2V0KTtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2VbMF0gPCB0aWNrUG9zaXRpb24gJiYgdGlja1Bvc2l0aW9uIDwgcmFuZ2VbMV0gPyBpbm5lclRpY2tTaXplIDogMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aWNrJ3MgbGluZSAmIHRleHQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gbGluZVVwZGF0ZSBMaW5lIHNlbGVjdGlvblxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSB0ZXh0VXBkYXRlIFRleHQgc2VsZWN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRUaWNrTGluZVRleHRQb3NpdGlvbihsaW5lVXBkYXRlLCB0ZXh0VXBkYXRlKTogdm9pZCB7XHJcblx0XHRjb25zdCB0aWNrUG9zID0gdGhpcy5nZXRUaWNrWFkoKTtcclxuXHRcdGNvbnN0IHtpbm5lclRpY2tTaXplLCBvcmllbnQsIHRpY2tMZW5ndGgsIHRpY2tPZmZzZXR9ID0gdGhpcy5jb25maWc7XHJcblx0XHRjb25zdCByb3RhdGUgPSB0aGlzLnBhcmFtcy50aWNrVGV4dFJvdGF0ZTtcclxuXHJcblx0XHRjb25zdCB0ZXh0QW5jaG9yRm9yVGV4dCA9IHIgPT4ge1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IFtcInN0YXJ0XCIsIFwiZW5kXCJdO1xyXG5cclxuXHRcdFx0b3JpZW50ID09PSBcInRvcFwiICYmIHZhbHVlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdHJldHVybiAhciA/IFwibWlkZGxlXCIgOiAociA+IDAgPyB2YWx1ZVswXSA6IHZhbHVlWzFdKTtcclxuXHRcdH07XHJcblx0XHRjb25zdCB0ZXh0VHJhbnNmb3JtID0gciA9PiAociA/IGByb3RhdGUoJHtyfSlgIDogbnVsbCk7XHJcblx0XHRjb25zdCB5Rm9yVGV4dCA9IHIgPT4ge1xyXG5cdFx0XHRjb25zdCByMiA9IHIgLyAob3JpZW50ID09PSBcImJvdHRvbVwiID8gMTUgOiAyMyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gciA/IDExLjUgLSAyLjUgKiByMiAqIChyID4gMCA/IDEgOiAtMSkgOiB0aWNrTGVuZ3RoO1xyXG5cdFx0fTtcclxuXHJcblx0XHRzd2l0Y2ggKG9yaWVudCkge1xyXG5cdFx0XHRjYXNlIFwiYm90dG9tXCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB0aWNrUG9zLngpXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIHRpY2tQb3MueClcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGhpcy5nZXRUaWNrU2l6ZS5iaW5kKHRoaXMpKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIDApXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZvclRleHQocm90YXRlKSlcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwidG9wXCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAtaW5uZXJUaWNrU2l6ZSk7XHJcblxyXG5cdFx0XHRcdHRleHRVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIC15Rm9yVGV4dChyb3RhdGUpICogMilcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwibGVmdFwiOlxyXG5cdFx0XHRcdGxpbmVVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgLWlubmVyVGlja1NpemUpXHJcblx0XHRcdFx0XHQuYXR0cihcInkxXCIsIHRpY2tQb3MueSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGlja1Bvcy55KTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIC10aWNrTGVuZ3RoKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHRpY2tPZmZzZXQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInJpZ2h0XCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpbm5lclRpY2tTaXplKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAwKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHRpY2tMZW5ndGgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgMClcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwic3RhcnRcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyB0aGlzIHNob3VsZCBiZSBjYWxsZWQgb25seSB3aGVuIGNhdGVnb3J5IGF4aXNcclxuXHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlLCB0aWNrcywgaXNMZWZ0UmlnaHQsIGNoYXJXaWR0aCkge1xyXG5cdFx0Y29uc3Qge3BhcmFtc30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGlja1RleHQgPSB0aGlzLmhlbHBlci50ZXh0Rm9ybWF0dGVkKGQpO1xyXG5cdFx0Y29uc3Qgc3BsaXR0ZWQgPSBpc1N0cmluZyh0aWNrVGV4dCkgJiYgdGlja1RleHQuaW5kZXhPZihcIlxcblwiKSA+IC0xID9cclxuXHRcdFx0dGlja1RleHQuc3BsaXQoXCJcXG5cIikgOiBbXTtcclxuXHJcblx0XHRpZiAoc3BsaXR0ZWQubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBzcGxpdHRlZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNBcnJheSh0aWNrVGV4dCkpIHtcclxuXHRcdFx0cmV0dXJuIHRpY2tUZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0aWNrV2lkdGggPSBwYXJhbXMudGlja1dpZHRoO1xyXG5cclxuXHRcdGlmICghdGlja1dpZHRoIHx8IHRpY2tXaWR0aCA8PSAwKSB7XHJcblx0XHRcdHRpY2tXaWR0aCA9IGlzTGVmdFJpZ2h0ID8gOTUgOiAoXHJcblx0XHRcdFx0cGFyYW1zLmlzQ2F0ZWdvcnkgP1xyXG5cdFx0XHRcdFx0KE1hdGguY2VpbChzY2FsZSh0aWNrc1sxXSkgLSBzY2FsZSh0aWNrc1swXSkpIC0gMTIpIDogMTEwXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc3BsaXQgZ2l2ZW4gdGV4dCBieSB0aWNrIHdpZHRoIHNpemVcclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gc3BsaXQoc3BsaXR0ZWQsIHRleHQpIHtcclxuXHRcdFx0bGV0IHN1YnRleHQ7XHJcblx0XHRcdGxldCBzcGFjZUluZGV4O1xyXG5cdFx0XHRsZXQgdGV4dFdpZHRoO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHRleHQuY2hhckF0KGkpID09PSBcIiBcIikge1xyXG5cdFx0XHRcdFx0c3BhY2VJbmRleCA9IGk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdWJ0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaSArIDEpO1xyXG5cdFx0XHRcdHRleHRXaWR0aCA9IGNoYXJXaWR0aCAqIHN1YnRleHQubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0ZXh0IHdpZHRoIGdldHMgb3ZlciB0aWNrIHdpZHRoLCBzcGxpdCBieSBzcGFjZSBpbmRleCBvciBjdXJyZW50IGluZGV4XHJcblx0XHRcdFx0aWYgKHRpY2tXaWR0aCA8IHRleHRXaWR0aCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNwbGl0KFxyXG5cdFx0XHRcdFx0XHRzcGxpdHRlZC5jb25jYXQodGV4dC5zdWJzdHIoMCwgc3BhY2VJbmRleCB8fCBpKSksXHJcblx0XHRcdFx0XHRcdHRleHQuc2xpY2Uoc3BhY2VJbmRleCA/IHNwYWNlSW5kZXggKyAxIDogaSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQuY29uY2F0KHRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzcGxpdChzcGxpdHRlZCwgU3RyaW5nKHRpY2tUZXh0KSk7XHJcblx0fVxyXG5cclxuXHRzY2FsZSh4KTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5oZWxwZXIuc2NhbGU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5oZWxwZXIuc2NhbGUgPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0b3JpZW50KHgpOiBBeGlzUmVuZGVyZXIge1xyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNvbmZpZy5vcmllbnQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jb25maWcub3JpZW50ID0geCBpbiB7XHJcblx0XHRcdHRvcDogMSxcclxuXHRcdFx0cmlnaHQ6IDEsXHJcblx0XHRcdGJvdHRvbTogMSxcclxuXHRcdFx0bGVmdDogMVxyXG5cdFx0fSA/IFN0cmluZyh4KSA6IFwiYm90dG9tXCI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHR0aWNrRm9ybWF0KGZvcm1hdCk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0Zvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcudGlja0Zvcm1hdCA9IGZvcm1hdDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tDZW50ZXJlZChpc0NlbnRlcmVkOiBib29sZWFuKTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrQ2VudGVyZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tDZW50ZXJlZCA9IGlzQ2VudGVyZWQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGljaydzIG9mZnNldCB2YWx1ZS5cclxuXHQgKiBUaGUgdmFsdWUgd2lsbCBiZSBzZXQgZm9yICdjYXRlZ29yeScgYXhpcyB0eXBlLlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0aWNrT2Zmc2V0KCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcudGlja09mZnNldDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aWNrIGludGVydmFsIGNvdW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBUb3RhbCBkYXRhIHNpemVcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqL1xyXG5cdHRpY2tJbnRlcnZhbChzaXplOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0bGV0IGludGVydmFsO1xyXG5cclxuXHRcdGlmICh0aGlzLnBhcmFtcy5pc0NhdGVnb3J5KSB7XHJcblx0XHRcdGludGVydmFsID0gdGhpcy5jb25maWcudGlja09mZnNldCAqIDI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBsZW5ndGggPSB0aGlzLmcuc2VsZWN0KFwicGF0aC5kb21haW5cIilcclxuXHRcdFx0XHQubm9kZSgpXHJcblx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKCkgLSB0aGlzLmNvbmZpZy5vdXRlclRpY2tTaXplICogMjtcclxuXHJcblx0XHRcdGludGVydmFsID0gbGVuZ3RoIC8gKHNpemUgfHwgdGhpcy5nLnNlbGVjdEFsbChcImxpbmVcIikuc2l6ZSgpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW50ZXJ2YWwgPT09IEluZmluaXR5ID8gMCA6IGludGVydmFsO1xyXG5cdH1cclxuXHJcblx0dGlja3MoLi4uYXJncyk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmdzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tBcmd1bWVudHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tBcmd1bWVudHMgPSB0b0FycmF5KGFyZ3MpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0dGlja0N1bGxpbmcoY3VsbGluZyk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0N1bGxpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tDdWxsaW5nID0gY3VsbGluZztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tWYWx1ZXMoeCk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKGlzRnVuY3Rpb24oeCkpIHtcclxuXHRcdFx0Y29uZmlnLnRpY2tWYWx1ZXMgPSAoKSA9PiB4KHRoaXMuaGVscGVyLnNjYWxlLmRvbWFpbigpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldHVybiBjb25maWcudGlja1ZhbHVlcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uZmlnLnRpY2tWYWx1ZXMgPSB4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0c2V0VHJhbnNpdGlvbih0KTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdHRoaXMuY29uZmlnLnRyYW5zaXRpb24gPSB0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0YXhpc1RvcCBhcyBkM0F4aXNUb3AsXHJcblx0YXhpc0JvdHRvbSBhcyBkM0F4aXNCb3R0b20sXHJcblx0YXhpc0xlZnQgYXMgZDNBeGlzTGVmdCxcclxuXHRheGlzUmlnaHQgYXMgZDNBeGlzUmlnaHRcclxufSBmcm9tIFwiZDMtYXhpc1wiO1xyXG5pbXBvcnQge3NjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJ9IGZyb20gXCJkMy1zY2FsZVwiO1xyXG5pbXBvcnQgQXhpc1JlbmRlcmVyIGZyb20gXCIuL0F4aXNSZW5kZXJlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVmFsdWUsIGlzRW1wdHksIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIG1lcmdlT2JqLCBub3RFbXB0eSwgcGFyc2VEYXRlLCBzb3J0VmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpcyB7XHJcblx0cHVibGljIG93bmVyO1xyXG5cclxuXHRwdWJsaWMgeDtcclxuXHRwdWJsaWMgc3ViWDtcclxuXHRwdWJsaWMgeTtcclxuXHRwdWJsaWMgeTI7XHJcblxyXG5cdHByaXZhdGUgYXhlc0xpc3QgPSB7fTtcclxuXHRwdWJsaWMgdGljayA9IHtcclxuXHRcdHg6IG51bGwsIHk6IG51bGwsIHkyOiBudWxsXHJcblx0fTtcclxuXHRwdWJsaWMgeHMgPSBbXTtcclxuXHRwcml2YXRlIG9yaWVudCA9IHtcclxuXHRcdHg6IFwiYm90dG9tXCIsXHJcblx0XHR5OiBcImxlZnRcIixcclxuXHRcdHkyOiBcInJpZ2h0XCIsXHJcblx0XHRzdWJYOiBcImJvdHRvbVwiXHJcblx0fTtcclxuXHJcblx0Y29uc3RydWN0b3Iob3duZXIpIHtcclxuXHRcdHRoaXMub3duZXIgPSBvd25lcjtcclxuXHRcdHRoaXMuc2V0T3JpZW50KCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdldEF4aXNDbGFzc05hbWUoaWQpIHtcclxuXHRcdHJldHVybiBgJHtDTEFTUy5heGlzfSAke0NMQVNTW2BheGlzJHtjYXBpdGFsaXplKGlkKX1gXX1gO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBpc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpIHtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0cmV0dXJuIGZvckhvcml6b250YWwgPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzQ2F0ZWdvcml6ZWQoKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSB0aGlzLm93bmVyO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuYXhpc194X3R5cGUuaW5kZXhPZihcImNhdGVnb3J5XCIpID49IDAgfHwgc3RhdGUuaGFzUmFkYXI7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNDdXN0b21YKCkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzLm93bmVyO1xyXG5cclxuXHRcdHJldHVybiAhdGhpcy5pc1RpbWVTZXJpZXMoKSAmJiAoY29uZmlnLmRhdGFfeCB8fCBub3RFbXB0eShjb25maWcuZGF0YV94cykpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzVGltZVNlcmllcyhpZCA9IFwieFwiKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXMub3duZXI7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZ1tgYXhpc18ke2lkfV90eXBlYF0gPT09IFwidGltZXNlcmllc1wiO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGlzVGltZVNlcmllc1koKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1RpbWVTZXJpZXMoXCJ5XCIpO1xyXG5cdH1cclxuXHJcblx0aW5pdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW4sIGF4aXN9LCBzdGF0ZToge2NsaXB9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHRhcmdldCA9IFtcInhcIiwgXCJ5XCJdO1xyXG5cclxuXHRcdGNvbmZpZy5heGlzX3kyX3Nob3cgJiYgdGFyZ2V0LnB1c2goXCJ5MlwiKTtcclxuXHJcblx0XHR0YXJnZXQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgY2xhc3NBeGlzID0gdGhpcy5nZXRBeGlzQ2xhc3NOYW1lKHYpO1xyXG5cdFx0XHRjb25zdCBjbGFzc0xhYmVsID0gQ0xBU1NbYGF4aXMke3YudG9VcHBlckNhc2UoKX1MYWJlbGBdO1xyXG5cclxuXHRcdFx0YXhpc1t2XSA9IG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBeGlzKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICgpID0+IHtcclxuXHRcdFx0XHRcdGxldCByZXMgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdGlmICh2ID09PSBcInhcIikge1xyXG5cdFx0XHRcdFx0XHRyZXMgPSBjbGlwLnBhdGhYQXhpcztcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJ5XCIgJiYgY29uZmlnLmF4aXNfeV9pbm5lcikge1xyXG5cdFx0XHRcdFx0XHRyZXMgPSBjbGlwLnBhdGhZQXhpcztcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKHYpKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnW2BheGlzXyR7dn1fc2hvd2BdID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcclxuXHJcblx0XHRcdGF4aXNbdl0uYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMYWJlbClcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBbXCJyb3RhdGUoLTkwKVwiLCBudWxsXVtcclxuXHRcdFx0XHRcdHYgPT09IFwieFwiID8gKyFpc1JvdGF0ZWQgOiAraXNSb3RhdGVkXHJcblx0XHRcdFx0XSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCAoKSA9PiB0aGlzLnRleHRBbmNob3JGb3JBeGlzTGFiZWwodikpO1xyXG5cclxuXHRcdFx0dGhpcy5nZW5lcmF0ZUF4ZXModik7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBheGlzIG9yaWVudCBhY2NvcmRpbmcgb3B0aW9uIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRPcmllbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGF4aXNfcm90YXRlZDogaXNSb3RhdGVkLFxyXG5cdFx0XHRheGlzX3lfaW5uZXI6IHlJbm5lcixcclxuXHRcdFx0YXhpc195Ml9pbm5lcjogeTJJbm5lclxyXG5cdFx0fSA9ICQkLmNvbmZpZztcclxuXHJcblx0XHR0aGlzLm9yaWVudCA9IHtcclxuXHRcdFx0eDogaXNSb3RhdGVkID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiLFxyXG5cdFx0XHR5OiBpc1JvdGF0ZWQgPyAoeUlubmVyID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIpIDogKHlJbm5lciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKSxcclxuXHRcdFx0eTI6IGlzUm90YXRlZCA/ICh5MklubmVyID8gXCJib3R0b21cIiA6IFwidG9wXCIpIDogKHkySW5uZXIgPyBcImxlZnRcIiA6IFwicmlnaHRcIiksXHJcblx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IFwibGVmdFwiIDogXCJib3R0b21cIlxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGF4ZXNcclxuXHQgKiBJdCdzIHVzZWQgd2hlbiBheGlzJyBheGVzIG9wdGlvbiBpcyBzZXRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgQXhpcyBpZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVBeGVzKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBheGVzOiBhbnlbXSA9IFtdO1xyXG5cdFx0Y29uc3QgYXhlc0NvbmZpZyA9IGNvbmZpZ1tgYXhpc18ke2lkfV9heGVzYF07XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IGQzQXhpcztcclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc0xlZnQgOiBkM0F4aXNCb3R0b207XHJcblx0XHR9IGVsc2UgaWYgKGlkID09PSBcInlcIikge1xyXG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNCb3R0b20gOiBkM0F4aXNMZWZ0O1xyXG5cdFx0fSBlbHNlIGlmIChpZCA9PT0gXCJ5MlwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc1RvcCA6IGQzQXhpc1JpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGVzQ29uZmlnLmxlbmd0aCkge1xyXG5cdFx0XHRheGVzQ29uZmlnLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdGljayA9IHYudGljayB8fCB7fTtcclxuXHRcdFx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlW2lkXS5jb3B5KCk7XHJcblxyXG5cdFx0XHRcdHYuZG9tYWluICYmIHNjYWxlLmRvbWFpbih2LmRvbWFpbik7XHJcblxyXG5cdFx0XHRcdGF4ZXMucHVzaChcclxuXHRcdFx0XHRcdGQzQXhpcyhzY2FsZSlcclxuXHRcdFx0XHRcdFx0LnRpY2tzKHRpY2suY291bnQpXHJcblx0XHRcdFx0XHRcdC50aWNrRm9ybWF0KGlzRnVuY3Rpb24odGljay5mb3JtYXQpID8gdGljay5mb3JtYXQuYmluZCgkJC5hcGkpIDogKCh4OiBhbnkpID0+IHgpKVxyXG5cdFx0XHRcdFx0XHQudGlja1ZhbHVlcyh0aWNrLnZhbHVlcylcclxuXHRcdFx0XHRcdFx0LnRpY2tTaXplT3V0ZXIodGljay5vdXRlciA9PT0gZmFsc2UgPyAwIDogNilcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmF4ZXNMaXN0W2lkXSA9IGF4ZXM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgYXhlcyBub2Rlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlQXhlcygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHRoaXMuYXhlc0xpc3QpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCBheGVzQ29uZmlnID0gY29uZmlnW2BheGlzXyR7aWR9X2F4ZXNgXTtcclxuXHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZVtpZF0uY29weSgpO1xyXG5cdFx0XHRjb25zdCByYW5nZSA9IHNjYWxlLnJhbmdlKCk7XHJcblxyXG5cdFx0XHR0aGlzLmF4ZXNMaXN0W2lkXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgYXhpc1JhbmdlID0gdi5zY2FsZSgpLnJhbmdlKCk7XHJcblxyXG5cdFx0XHRcdC8vIGFkanVzdCByYW5nZSB2YWx1ZSB3aXRoIHRoZSBjdXJyZW50XHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvODU5XHJcblx0XHRcdFx0aWYgKCFyYW5nZS5ldmVyeSgodiwgaSkgPT4gdiA9PT0gYXhpc1JhbmdlW2ldKSkge1xyXG5cdFx0XHRcdFx0di5zY2FsZSgpLnJhbmdlKHJhbmdlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGNsYXNzTmFtZSA9IGAke3RoaXMuZ2V0QXhpc0NsYXNzTmFtZShpZCl9LSR7aSArIDF9YDtcclxuXHRcdFx0XHRsZXQgZyA9IG1haW4uc2VsZWN0KGAuJHtjbGFzc05hbWUucmVwbGFjZSgvXFxzLywgXCIuXCIpfWApO1xyXG5cclxuXHRcdFx0XHRpZiAoZy5lbXB0eSgpKSB7XHJcblx0XHRcdFx0XHRnID0gbWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NOYW1lKVxyXG5cdFx0XHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZ1tgYXhpc18ke2lkfV9zaG93YF0gPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpXHJcblx0XHRcdFx0XHRcdC5jYWxsKHYpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRheGVzQ29uZmlnW2ldLmRvbWFpbiAmJiBzY2FsZS5kb21haW4oYXhlc0NvbmZpZ1tpXS5kb21haW4pO1xyXG5cclxuXHRcdFx0XHRcdHRoaXMueC5oZWxwZXIudHJhbnNpdGlvbmlzZShnKVxyXG5cdFx0XHRcdFx0XHQuY2FsbCh2LnNjYWxlKHNjYWxlKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKGlkLCBpICsgMSkpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IEF4aXMgJiB0aWNrIHZhbHVlc1xyXG5cdCAqIGNhbGxlZCBmcm9tOiB1cGRhdGVTY2FsZXMoKVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkIHN0cmluZ1xyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJndW1lbnRzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRBeGlzKGlkLCAuLi5hcmdzKTogdm9pZCB7XHJcblx0XHRpZiAoaWQgIT09IFwic3ViWFwiKSB7XHJcblx0XHRcdHRoaXMudGlja1tpZF0gPSB0aGlzLmdldFRpY2tWYWx1ZXMoaWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHRoaXNbaWRdID0gdGhpcy5nZXRBeGlzKGlkLCAuLi5hcmdzKTtcclxuXHR9XHJcblxyXG5cdC8vIGNhbGxlZCBmcm9tIDogZ2V0TWF4VGlja1dpZHRoKClcclxuXHRnZXRBeGlzKGlkLCBzY2FsZSwgb3V0ZXJUaWNrLCBub1RyYW5zaXRpb24sIG5vVGlja1RleHRSb3RhdGUpOiBBeGlzUmVuZGVyZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzWCA9IC9eKHh8c3ViWCkkLy50ZXN0KGlkKTtcclxuXHRcdGNvbnN0IHR5cGUgPSBpc1ggPyBcInhcIiA6IGlkO1xyXG5cclxuXHRcdGNvbnN0IGlzQ2F0ZWdvcnkgPSBpc1ggJiYgdGhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRjb25zdCBvcmllbnQgPSB0aGlzLm9yaWVudFtpZF07XHJcblx0XHRjb25zdCB0aWNrVGV4dFJvdGF0ZSA9IG5vVGlja1RleHRSb3RhdGUgPyAwIDogJCQuZ2V0QXhpc1RpY2tSb3RhdGUodHlwZSk7XHJcblx0XHRsZXQgdGlja0Zvcm1hdDtcclxuXHJcblx0XHRpZiAoaXNYKSB7XHJcblx0XHRcdHRpY2tGb3JtYXQgPSAkJC5mb3JtYXQueEF4aXNUaWNrO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgZm4gPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19mb3JtYXRgXTtcclxuXHJcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGZuKSkge1xyXG5cdFx0XHRcdHRpY2tGb3JtYXQgPSBmbi5iaW5kKCQkLmFwaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdGlja1ZhbHVlcyA9IHRoaXMudGlja1t0eXBlXTtcclxuXHJcblx0XHRjb25zdCBheGlzUGFyYW1zID0gbWVyZ2VPYmooe1xyXG5cdFx0XHRvdXRlclRpY2ssXHJcblx0XHRcdG5vVHJhbnNpdGlvbixcclxuXHRcdFx0Y29uZmlnLFxyXG5cdFx0XHRpZCxcclxuXHRcdFx0dGlja1RleHRSb3RhdGVcclxuXHRcdH0sIGlzWCAmJiB7XHJcblx0XHRcdGlzQ2F0ZWdvcnksXHJcblx0XHRcdHRpY2tNdWx0aWxpbmU6IGNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUsXHJcblx0XHRcdHRpY2tXaWR0aDogY29uZmlnLmF4aXNfeF90aWNrX3dpZHRoLFxyXG5cdFx0XHR0aWNrVGl0bGU6IGlzQ2F0ZWdvcnkgJiYgY29uZmlnLmF4aXNfeF90aWNrX3Rvb2x0aXAgJiYgJCQuYXBpLmNhdGVnb3JpZXMoKSxcclxuXHRcdFx0b3JnWFNjYWxlOiAkJC5zY2FsZS54XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWlzWCkge1xyXG5cdFx0XHRheGlzUGFyYW1zLnRpY2tTdGVwU2l6ZSA9IGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfc3RlcFNpemVgXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBheGlzID0gbmV3IEF4aXNSZW5kZXJlcihheGlzUGFyYW1zKVxyXG5cdFx0XHQuc2NhbGUoKGlzWCAmJiAkJC5zY2FsZS56b29tKSB8fCBzY2FsZSlcclxuXHRcdFx0Lm9yaWVudChvcmllbnQpO1xyXG5cclxuXHRcdGlmIChpc1ggJiYgdGhpcy5pc1RpbWVTZXJpZXMoKSAmJiB0aWNrVmFsdWVzICYmICFpc0Z1bmN0aW9uKHRpY2tWYWx1ZXMpKSB7XHJcblx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0dGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMubWFwKHYgPT4gZm4odikpO1xyXG5cdFx0fSBlbHNlIGlmICghaXNYICYmIHRoaXMuaXNUaW1lU2VyaWVzWSgpKSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy9ibG9iL21hc3Rlci9DSEFOR0VTLm1kI3RpbWUtaW50ZXJ2YWxzLWQzLXRpbWVcclxuXHRcdFx0YXhpcy50aWNrcyhjb25maWcuYXhpc195X3RpY2tfdGltZV92YWx1ZSk7XHJcblx0XHRcdHRpY2tWYWx1ZXMgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRpY2tWYWx1ZXMgJiYgYXhpcy50aWNrVmFsdWVzKHRpY2tWYWx1ZXMpO1xyXG5cclxuXHRcdC8vIFNldCB0aWNrXHJcblx0XHRheGlzLnRpY2tGb3JtYXQoXHJcblx0XHRcdHRpY2tGb3JtYXQgfHwgKFxyXG5cdFx0XHRcdCFpc1ggJiYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgJiYgKHggPT4gYCR7eH0lYCkpXHJcblx0XHRcdClcclxuXHRcdCk7XHJcblxyXG5cdFx0aWYgKGlzQ2F0ZWdvcnkpIHtcclxuXHRcdFx0YXhpcy50aWNrQ2VudGVyZWQoY29uZmlnLmF4aXNfeF90aWNrX2NlbnRlcmVkKTtcclxuXHJcblx0XHRcdGlmIChpc0VtcHR5KGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nKSkge1xyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0aWNrQ291bnQgPSBjb25maWdbYGF4aXNfJHt0eXBlfV90aWNrX2NvdW50YF07XHJcblxyXG5cdFx0dGlja0NvdW50ICYmIGF4aXMudGlja3ModGlja0NvdW50KTtcclxuXHJcblx0XHRyZXR1cm4gYXhpcztcclxuXHR9XHJcblxyXG5cdHVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzLCBheGlzPyk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBmaXQgPSBjb25maWcuYXhpc194X3RpY2tfZml0O1xyXG5cdFx0bGV0IGNvdW50ID0gY29uZmlnLmF4aXNfeF90aWNrX2NvdW50O1xyXG5cdFx0bGV0IHZhbHVlcztcclxuXHJcblx0XHRpZiAoZml0IHx8IChjb3VudCAmJiBmaXQpKSB7XHJcblx0XHRcdHZhbHVlcyA9ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpO1xyXG5cclxuXHRcdFx0Ly8gaWYgZ2l2ZW4gY291bnQgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBsZW5ndGgsIHRoZW4gbGltaXQgdGhlIGNvdW50LlxyXG5cdFx0XHRpZiAodGhpcy5pc0NhdGVnb3JpemVkKCkgJiYgY291bnQgPiB2YWx1ZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0Y291bnQgPSB2YWx1ZXMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdlbmVyYXRlVGlja1ZhbHVlcyhcclxuXHRcdFx0XHR2YWx1ZXMsXHJcblx0XHRcdFx0Y291bnQsXHJcblx0XHRcdFx0dGhpcy5pc1RpbWVTZXJpZXMoKVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGlzKSB7XHJcblx0XHRcdGF4aXMudGlja1ZhbHVlcyh2YWx1ZXMpO1xyXG5cdFx0fSBlbHNlIGlmICh0aGlzLngpIHtcclxuXHRcdFx0dGhpcy54LnRpY2tWYWx1ZXModmFsdWVzKTtcclxuXHRcdFx0dGhpcy5zdWJYICYmIHRoaXMuc3ViWC50aWNrVmFsdWVzKHZhbHVlcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG5cdGdldElkKGlkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gdGhpcy5vd25lcjtcclxuXHRcdGxldCBheGlzID0gY29uZmlnLmRhdGFfYXhlc1tpZF07XHJcblxyXG5cdFx0Ly8gd2hlbiBkYXRhLmF4ZXMgb3B0aW9uIGhhcyAneTInLCBidXQgJ2F4aXMueTIuc2hvdz10cnVlJyBpc24ndCBzZXQgd2lsbCByZXR1cm4gJ3knXHJcblx0XHRpZiAoIWF4aXMgfHwgIXNjYWxlW2F4aXNdKSB7XHJcblx0XHRcdGF4aXMgPSBcInlcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXhpcztcclxuXHR9XHJcblxyXG5cdGdldFhBeGlzVGlja0Zvcm1hdCgpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBmb3JtYXR9ID0gJCQ7XHJcblx0XHRjb25zdCB0aWNrRm9ybWF0ID0gY29uZmlnLmF4aXNfeF90aWNrX2Zvcm1hdDtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9IHRoaXMuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gdGhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRsZXQgY3VyckZvcm1hdDtcclxuXHJcblx0XHRpZiAodGlja0Zvcm1hdCkge1xyXG5cdFx0XHRpZiAoaXNGdW5jdGlvbih0aWNrRm9ybWF0KSkge1xyXG5cdFx0XHRcdGN1cnJGb3JtYXQgPSB0aWNrRm9ybWF0LmJpbmQoJCQuYXBpKTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHRjdXJyRm9ybWF0ID0gZGF0ZSA9PiAoZGF0ZSA/IGZvcm1hdC5heGlzVGltZSh0aWNrRm9ybWF0KShkYXRlKSA6IFwiXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdXJyRm9ybWF0ID0gaXNUaW1lU2VyaWVzID8gZm9ybWF0LmRlZmF1bHRBeGlzVGltZSA6IChcclxuXHRcdFx0XHRpc0NhdGVnb3JpemVkID9cclxuXHRcdFx0XHRcdCQkLmNhdGVnb3J5TmFtZSA6IHYgPT4gKHYgPCAwID8gdi50b0ZpeGVkKDApIDogdilcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihjdXJyRm9ybWF0KSA/IHYgPT5cclxuXHRcdFx0Y3VyckZvcm1hdC5hcHBseSgkJCwgaXNDYXRlZ29yaXplZCA/XHJcblx0XHRcdFx0W3YsICQkLmNhdGVnb3J5TmFtZSh2KV0gOiBbdl1cclxuXHRcdFx0KSA6IGN1cnJGb3JtYXQ7XHJcblx0fVxyXG5cclxuXHRnZXRUaWNrVmFsdWVzKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSAkJC5jb25maWdbYGF4aXNfJHtpZH1fdGlja192YWx1ZXNgXTtcclxuXHRcdGNvbnN0IGF4aXMgPSAkJFtgJHtpZH1BeGlzYF07XHJcblxyXG5cdFx0cmV0dXJuIChpc0Z1bmN0aW9uKHRpY2tWYWx1ZXMpID8gdGlja1ZhbHVlcy5jYWxsKCQkLmFwaSkgOiB0aWNrVmFsdWVzKSB8fFxyXG5cdFx0XHQoYXhpcyA/IGF4aXMudGlja1ZhbHVlcygpIDogdW5kZWZpbmVkKTtcclxuXHR9XHJcblxyXG5cdGdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQ6IHN0cmluZykge1xyXG5cdFx0cmV0dXJuIHRoaXMub3duZXIuY29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF07XHJcblx0fVxyXG5cclxuXHRnZXRMYWJlbFRleHQoaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcclxuXHJcblx0XHRyZXR1cm4gaXNTdHJpbmcob3B0aW9uKSA/IG9wdGlvbiA6IChcclxuXHRcdFx0b3B0aW9uID8gb3B0aW9uLnRleHQgOiBudWxsXHJcblx0XHQpO1xyXG5cdH1cclxuXHJcblx0c2V0TGFiZWxUZXh0KGlkOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XHJcblxyXG5cdFx0aWYgKGlzU3RyaW5nKG9wdGlvbikpIHtcclxuXHRcdFx0Y29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF0gPSB0ZXh0O1xyXG5cdFx0fSBlbHNlIGlmIChvcHRpb24pIHtcclxuXHRcdFx0b3B0aW9uLnRleHQgPSB0ZXh0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxQb3NpdGlvbihpZDogc3RyaW5nLCBkZWZhdWx0UG9zaXRpb24pIHtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IHRoaXMub3duZXIuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IChpc09iamVjdFR5cGUob3B0aW9uKSAmJiBvcHRpb24ucG9zaXRpb24pID9cclxuXHRcdFx0b3B0aW9uLnBvc2l0aW9uIDogZGVmYXVsdFBvc2l0aW9uWyshaXNSb3RhdGVkXTtcclxuXHJcblx0XHRjb25zdCBoYXMgPSB2ID0+ICEhfnBvc2l0aW9uLmluZGV4T2Yodik7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0aXNJbm5lcjogaGFzKFwiaW5uZXJcIiksXHJcblx0XHRcdGlzT3V0ZXI6IGhhcyhcIm91dGVyXCIpLFxyXG5cdFx0XHRpc0xlZnQ6IGhhcyhcImxlZnRcIiksXHJcblx0XHRcdGlzQ2VudGVyOiBoYXMoXCJjZW50ZXJcIiksXHJcblx0XHRcdGlzUmlnaHQ6IGhhcyhcInJpZ2h0XCIpLFxyXG5cdFx0XHRpc1RvcDogaGFzKFwidG9wXCIpLFxyXG5cdFx0XHRpc01pZGRsZTogaGFzKFwibWlkZGxlXCIpLFxyXG5cdFx0XHRpc0JvdHRvbTogaGFzKFwiYm90dG9tXCIpXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0Z2V0QXhpc0xhYmVsUG9zaXRpb24oaWQ6IHN0cmluZykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxQb3NpdGlvbihpZCwgaWQgPT09IFwieFwiID8gW1wiaW5uZXItdG9wXCIsIFwiaW5uZXItcmlnaHRcIl0gOiBbXCJpbm5lci1yaWdodFwiLCBcImlubmVyLXRvcFwiXSk7XHJcblx0fVxyXG5cclxuXHRnZXRMYWJlbFBvc2l0aW9uQnlJZChpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihpZCk7XHJcblx0fVxyXG5cclxuXHR4Rm9yQXhpc0xhYmVsKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtzdGF0ZToge3dpZHRoLCBoZWlnaHR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSB0aGlzLmdldEF4aXNMYWJlbFBvc2l0aW9uKGlkKTtcclxuXHRcdGxldCB4ID0gcG9zaXRpb24uaXNNaWRkbGUgPyAtaGVpZ2h0IC8gMiA6IDA7XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCQkLCBpZCAhPT0gXCJ4XCIpKSB7XHJcblx0XHRcdHggPSBwb3NpdGlvbi5pc0xlZnQgPyAwIDogKFxyXG5cdFx0XHRcdHBvc2l0aW9uLmlzQ2VudGVyID8gd2lkdGggLyAyIDogd2lkdGhcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNCb3R0b20pIHtcclxuXHRcdFx0eCA9IC1oZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cclxuXHRkeEZvckF4aXNMYWJlbChpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oaWQpO1xyXG5cdFx0bGV0IGR4ID0gcG9zaXRpb24uaXNCb3R0b20gPyBcIjAuNWVtXCIgOiBcIjBcIjtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGlkICE9PSBcInhcIikpIHtcclxuXHRcdFx0ZHggPSBwb3NpdGlvbi5pc0xlZnQgPyBcIjAuNWVtXCIgOiAoXHJcblx0XHRcdFx0cG9zaXRpb24uaXNSaWdodCA/IFwiLTAuNWVtXCIgOiBcIjBcIlxyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc1RvcCkge1xyXG5cdFx0XHRkeCA9IFwiLTAuNWVtXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGR4O1xyXG5cdH1cclxuXHJcblx0dGV4dEFuY2hvckZvckF4aXNMYWJlbChpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oaWQpO1xyXG5cdFx0bGV0IGFuY2hvciA9IHBvc2l0aW9uLmlzTWlkZGxlID8gXCJtaWRkbGVcIiA6IFwiZW5kXCI7XHJcblxyXG5cdFx0aWYgKHRoaXMuaXNIb3Jpem9udGFsKCQkLCBpZCAhPT0gXCJ4XCIpKSB7XHJcblx0XHRcdGFuY2hvciA9IHBvc2l0aW9uLmlzTGVmdCA/IFwic3RhcnRcIiA6IChcclxuXHRcdFx0XHRwb3NpdGlvbi5pc0NlbnRlciA/IFwibWlkZGxlXCIgOiBcImVuZFwiXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzQm90dG9tKSB7XHJcblx0XHRcdGFuY2hvciA9IFwic3RhcnRcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYW5jaG9yO1xyXG5cdH1cclxuXHJcblx0ZHlGb3JBeGlzTGFiZWwoaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc0lubmVyID0gdGhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihpZCkuaXNJbm5lcjtcclxuXHRcdGNvbnN0IHRpY2tSb3RhdGUgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19yb3RhdGVgXSA/ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKSA6IDA7XHJcblx0XHRjb25zdCBtYXhUaWNrV2lkdGggPSB0aGlzLmdldE1heFRpY2tXaWR0aChpZCk7XHJcblx0XHRsZXQgZHk7XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInhcIikge1xyXG5cdFx0XHRjb25zdCB4SGVpZ2h0ID0gY29uZmlnLmF4aXNfeF9oZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdFx0ZHkgPSBpc0lubmVyID8gXCIxLjJlbVwiIDogLTI1IC0gbWF4VGlja1dpZHRoO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzSW5uZXIpIHtcclxuXHRcdFx0XHRkeSA9IFwiLTAuNWVtXCI7XHJcblx0XHRcdH0gZWxzZSBpZiAoeEhlaWdodCkge1xyXG5cdFx0XHRcdGR5ID0geEhlaWdodCAtIDEwO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRpY2tSb3RhdGUpIHtcclxuXHRcdFx0XHRkeSA9IHRpY2tSb3RhdGUgLSAxMDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkeSA9IFwiM2VtXCI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGR5ID0ge1xyXG5cdFx0XHRcdHk6IFtcIi0wLjVlbVwiLCAxMCwgXCIzZW1cIiwgXCIxLjJlbVwiLCAxMF0sXHJcblx0XHRcdFx0eTI6IFtcIjEuMmVtXCIsIC0yMCwgXCItMi4yZW1cIiwgXCItMC41ZW1cIiwgMTVdXHJcblx0XHRcdH1baWRdO1xyXG5cclxuXHRcdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHRcdGlmIChpc0lubmVyKSB7XHJcblx0XHRcdFx0XHRkeSA9IGR5WzBdO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAodGlja1JvdGF0ZSkge1xyXG5cdFx0XHRcdFx0ZHkgPSB0aWNrUm90YXRlICogKGlkID09PSBcInkyXCIgPyAtMSA6IDEpIC0gZHlbMV07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGR5ID0gZHlbMl07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGR5ID0gaXNJbm5lciA/XHJcblx0XHRcdFx0XHRkeVszXSA6IChcclxuXHRcdFx0XHRcdFx0ZHlbNF0gKyAoXHJcblx0XHRcdFx0XHRcdFx0Y29uZmlnW2BheGlzXyR7aWR9X2lubmVyYF0gPyAwIDogKG1heFRpY2tXaWR0aCArIGR5WzRdKVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHQpICogKGlkID09PSBcInlcIiA/IC0xIDogMSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZHk7XHJcblx0fVxyXG5cclxuXHRnZXRNYXhUaWNrV2lkdGgoaWQ6IHN0cmluZywgd2l0aG91dFJlY29tcHV0ZT86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50fSwgJGVsOiB7c3ZnLCBjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyZW50VGlja01heCA9IGN1cnJlbnQubWF4VGlja1dpZHRoc1tpZF07XHJcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xyXG5cclxuXHRcdGlmICh3aXRob3V0UmVjb21wdXRlIHx8ICFjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdIHx8ICQkLmZpbHRlclRhcmdldHNUb1Nob3coKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRjb25zdCBpc1lBeGlzID0gL155Mj8kLy50ZXN0KGlkKTtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZVtpZF0uY29weSgpLmRvbWFpbigkJFtgZ2V0JHtpc1lBeGlzID8gXCJZXCIgOiBcIlhcIn1Eb21haW5gXSh0YXJnZXRzVG9TaG93LCBpZCkpO1xyXG5cdFx0XHRjb25zdCBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcclxuXHJcblx0XHRcdC8vIGRvIG5vdCBjb21wdXRlIGlmIGRvbWFpbiBpcyBzYW1lXHJcblx0XHRcdGlmIChkb21haW5bMF0gPT09IGRvbWFpblsxXSB8fFxyXG5cdFx0XHRcdChpc0FycmF5KGN1cnJlbnRUaWNrTWF4LmRvbWFpbikgJiYgY3VycmVudFRpY2tNYXguZG9tYWluWzBdID09PSBjdXJyZW50VGlja01heC5kb21haW5bMV0pXHJcblx0XHRcdCkge1xyXG5cdFx0XHRcdHJldHVybiBjdXJyZW50VGlja01heC5zaXplO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGN1cnJlbnRUaWNrTWF4LmRvbWFpbiA9IGRvbWFpbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgYXhpcyA9IHRoaXMuZ2V0QXhpcyhpZCwgc2NhbGUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XHJcblx0XHRcdGNvbnN0IHRpY2tDb3VudCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2NvdW50YF07XHJcblx0XHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja192YWx1ZXNgXTtcclxuXHJcblx0XHRcdC8vIE1ha2UgdG8gZ2VuZXJhdGUgdGhlIGZpbmFsIHRpY2sgdGV4dCB0byBiZSByZW5kZXJlZFxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy85MjBcclxuXHRcdFx0Ly8gRG8gbm90IGdlbmVyYXRlIGlmICd0aWNrIHZhbHVlcycgb3B0aW9uIGlzIGdpdmVuXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzEyNTFcclxuXHRcdFx0aWYgKCF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xyXG5cdFx0XHRcdGF4aXMudGlja1ZhbHVlcyhcclxuXHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0XHRkb21haW4sXHJcblx0XHRcdFx0XHRcdHRpY2tDb3VudCxcclxuXHRcdFx0XHRcdFx0aXNZQXhpcyA/IHRoaXMuaXNUaW1lU2VyaWVzWSgpIDogdGhpcy5pc1RpbWVTZXJpZXMoKVxyXG5cdFx0XHRcdFx0KSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCFpc1lBeGlzICYmIHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3csIGF4aXMpO1xyXG5cclxuXHRcdFx0Y29uc3QgZHVtbXkgPSBjaGFydC5hcHBlbmQoXCJzdmdcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJmaXhlZFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRvcFwiLCBcIjBweFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgXCIwcHhcIik7XHJcblxyXG5cdFx0XHRheGlzLmNyZWF0ZShkdW1teSk7XHJcblxyXG5cdFx0XHRkdW1teS5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgY3VycmVudFRleHRXaWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XHJcblxyXG5cdFx0XHRcdFx0bWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgY3VycmVudFRleHRXaWR0aCk7XHJcblx0XHRcdFx0XHQvLyBjYWNoZSB0aWNrIHRleHQgd2lkdGggZm9yIGdldFhBeGlzVGlja1RleHRZMk92ZXJmbG93KClcclxuXHRcdFx0XHRcdGlmIChpZCA9PT0gXCJ4XCIpIHtcclxuXHRcdFx0XHRcdFx0Y3VycmVudFRpY2tNYXgudGlja3NbaV0gPSBjdXJyZW50VGV4dFdpZHRoO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZHVtbXkucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFdpZHRoID4gMCkge1xyXG5cdFx0XHRjdXJyZW50VGlja01heC5zaXplID0gbWF4V2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0fVxyXG5cclxuXHRnZXRYQXhpc1RpY2tUZXh0WTJPdmVyZmxvdyhkZWZhdWx0UGFkZGluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB4QXhpc1RpY2tSb3RhdGUgPSAkJC5nZXRBeGlzVGlja1JvdGF0ZShcInhcIik7XHJcblx0XHRjb25zdCBwb3NpdGl2ZVJvdGF0aW9uID0geEF4aXNUaWNrUm90YXRlID4gMCAmJiB4QXhpc1RpY2tSb3RhdGUgPCA5MDtcclxuXHJcblx0XHRpZiAoKGF4aXMuaXNDYXRlZ29yaXplZCgpIHx8IGF4aXMuaXNUaW1lU2VyaWVzKCkpICYmXHJcblx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19maXQgJiZcclxuXHRcdFx0IWNvbmZpZy5heGlzX3hfdGlja19jdWxsaW5nICYmXHJcblx0XHRcdCFjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lICYmXHJcblx0XHRcdHBvc2l0aXZlUm90YXRpb25cclxuXHRcdCkge1xyXG5cdFx0XHRjb25zdCB3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQgPSBzdGF0ZS5jdXJyZW50LndpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCk7XHJcblx0XHRcdGNvbnN0IG1heE92ZXJmbG93ID0gdGhpcy5nZXRYQXhpc1RpY2tNYXhPdmVyZmxvdyhcclxuXHRcdFx0XHR4QXhpc1RpY2tSb3RhdGUsIHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCAtIGRlZmF1bHRQYWRkaW5nXHJcblx0XHRcdCk7XHJcblx0XHRcdGNvbnN0IHhBeGlzVGlja1RleHRZMk92ZXJmbG93ID0gTWF0aC5tYXgoMCwgbWF4T3ZlcmZsb3cpICtcclxuXHRcdFx0XHRkZWZhdWx0UGFkZGluZzsgLy8gZm9yIGRpc3BsYXkgaW5jb25zaXN0ZW5jaWVzIGJldHdlZW4gYnJvd3NlcnNcclxuXHJcblx0XHRcdHJldHVybiBNYXRoLm1pbih4QXhpc1RpY2tUZXh0WTJPdmVyZmxvdywgd2lkdGhXaXRob3V0Q3VycmVudFBhZGRpbmdMZWZ0IC8gMik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fVxyXG5cclxuXHRnZXRYQXhpc1RpY2tNYXhPdmVyZmxvdyh4QXhpc1RpY2tSb3RhdGUsIHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSBheGlzLmlzVGltZVNlcmllcygpO1xyXG5cclxuXHRcdGNvbnN0IHRpY2tUZXh0V2lkdGhzID0gc3RhdGUuY3VycmVudC5tYXhUaWNrV2lkdGhzLngudGlja3M7XHJcblx0XHRjb25zdCB0aWNrQ291bnQgPSB0aWNrVGV4dFdpZHRocy5sZW5ndGg7XHJcblx0XHRjb25zdCB7bGVmdCwgcmlnaHR9ID0gc3RhdGUuYXhpcy54LnBhZGRpbmc7XHJcblx0XHRsZXQgbWF4T3ZlcmZsb3cgPSAwO1xyXG5cclxuXHRcdGNvbnN0IHJlbWFpbmluZyA9IHRpY2tDb3VudCAtIChpc1RpbWVTZXJpZXMgJiYgY29uZmlnLmF4aXNfeF90aWNrX2ZpdCA/IDAuNSA6IDApO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGlja0NvdW50OyBpKyspIHtcclxuXHRcdFx0Y29uc3QgdGlja0luZGV4ID0gaSArIDE7XHJcblx0XHRcdGNvbnN0IHJvdGF0ZWRUaWNrVGV4dFdpZHRoID0gTWF0aC5jb3MoTWF0aC5QSSAqIHhBeGlzVGlja1JvdGF0ZSAvIDE4MCkgKiB0aWNrVGV4dFdpZHRoc1tpXTtcclxuXHRcdFx0Y29uc3QgdGlja3NCZWZvcmVUaWNrVGV4dCA9IHRpY2tJbmRleCAtIChpc1RpbWVTZXJpZXMgPyAxIDogMC41KSArIGxlZnQ7XHJcblxyXG5cdFx0XHQvLyBTa2lwIHRpY2tzIGlmIHRoZXJlIGFyZSBubyB0aWNrcyBiZWZvcmUgdGhlbVxyXG5cdFx0XHRpZiAodGlja3NCZWZvcmVUaWNrVGV4dCA8PSAwKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHhBeGlzTGVuZ3RoV2l0aG91dFRpY2tUZXh0V2lkdGggPSB3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQgLSByb3RhdGVkVGlja1RleHRXaWR0aDtcclxuXHRcdFx0Y29uc3QgdGlja0xlbmd0aCA9IHhBeGlzTGVuZ3RoV2l0aG91dFRpY2tUZXh0V2lkdGggLyB0aWNrc0JlZm9yZVRpY2tUZXh0O1xyXG5cdFx0XHRjb25zdCByZW1haW5pbmdUaWNrcyA9IHJlbWFpbmluZyAtIHRpY2tJbmRleDtcclxuXHJcblx0XHRcdGNvbnN0IHBhZGRpbmdSaWdodExlbmd0aCA9IHJpZ2h0ICogdGlja0xlbmd0aDtcclxuXHRcdFx0Y29uc3QgcmVtYWluaW5nVGlja1dpZHRoID0gKHJlbWFpbmluZ1RpY2tzICogdGlja0xlbmd0aCkgKyBwYWRkaW5nUmlnaHRMZW5ndGg7XHJcblx0XHRcdGNvbnN0IG92ZXJmbG93ID0gcm90YXRlZFRpY2tUZXh0V2lkdGggLSAodGlja0xlbmd0aCAvIDIpIC0gcmVtYWluaW5nVGlja1dpZHRoO1xyXG5cclxuXHRcdFx0bWF4T3ZlcmZsb3cgPSBNYXRoLm1heChtYXhPdmVyZmxvdywgb3ZlcmZsb3cpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0aWNrT2Zmc2V0ID0gMDtcclxuXHJcblx0XHRpZiAoIWlzVGltZVNlcmllcykge1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9IGQzU2NhbGVMaW5lYXIoKVxyXG5cdFx0XHRcdC5kb21haW4oW1xyXG5cdFx0XHRcdFx0bGVmdCAqIC0xLFxyXG5cdFx0XHRcdFx0JCQuZ2V0WERvbWFpbk1heCgkJC5kYXRhLnRhcmdldHMpICsgMSArIHJpZ2h0XHJcblx0XHRcdFx0XSlcclxuXHRcdFx0XHQucmFuZ2UoWzAsIHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCAtIG1heE92ZXJmbG93XSk7XHJcblxyXG5cdFx0XHR0aWNrT2Zmc2V0ID0gKE1hdGguY2VpbCgoc2NhbGUoMSkgLSBzY2FsZSgwKSkgLyAyKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1heE92ZXJmbG93ICsgdGlja09mZnNldDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB4IEF4aXMgcGFkZGluZ1xyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aWNrQ291bnQgVGljayBjb3VudFxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFBhZGRpbmcgb2JqZWN0IHZhbHVlcyB3aXRoICdsZWZ0JyAmICdyaWdodCcga2V5XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRYQXhpc1BhZGRpbmcodGlja0NvdW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRsZXQgcGFkZGluZyA9ICQkLmNvbmZpZy5heGlzX3hfcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNFbXB0eShwYWRkaW5nKSkge1xyXG5cdFx0XHRwYWRkaW5nID0ge2xlZnQ6IDAsIHJpZ2h0OiAwfTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcubGVmdCA9IHBhZGRpbmcubGVmdCB8fCAwO1xyXG5cdFx0XHRwYWRkaW5nLnJpZ2h0ID0gcGFkZGluZy5yaWdodCB8fCAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgkJC5heGlzLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdGNvbnN0IGZpcnN0WCA9ICskJC5nZXRYRG9tYWluTWluKCQkLmRhdGEudGFyZ2V0cyk7XHJcblx0XHRcdGNvbnN0IGxhc3RYID0gKyQkLmdldFhEb21haW5NYXgoJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3QgdGltZURpZmYgPSBsYXN0WCAtIGZpcnN0WDtcclxuXHJcblx0XHRcdGNvbnN0IHJhbmdlID0gdGltZURpZmYgKyBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xyXG5cdFx0XHRjb25zdCByZWxhdGl2ZVRpY2tXaWR0aCA9ICh0aW1lRGlmZiAvIHRpY2tDb3VudCkgLyByYW5nZTtcclxuXHJcblx0XHRcdGNvbnN0IGxlZnQgPSBwYWRkaW5nLmxlZnQgLyByYW5nZSAvIHJlbGF0aXZlVGlja1dpZHRoIHx8IDA7XHJcblx0XHRcdGNvbnN0IHJpZ2h0ID0gcGFkZGluZy5yaWdodCAvIHJhbmdlIC8gcmVsYXRpdmVUaWNrV2lkdGggfHwgMDtcclxuXHJcblx0XHRcdHBhZGRpbmcgPSB7bGVmdCwgcmlnaHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nO1xyXG5cdH1cclxuXHJcblxyXG5cdHVwZGF0ZUxhYmVscyh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cclxuXHRcdGNvbnN0IGxhYmVscyA9IHtcclxuXHRcdFx0eDogbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfSAuJHtDTEFTUy5heGlzWExhYmVsfWApLFxyXG5cdFx0XHR5OiBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1l9IC4ke0NMQVNTLmF4aXNZTGFiZWx9YCksXHJcblx0XHRcdHkyOiBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1kyfSAuJHtDTEFTUy5heGlzWTJMYWJlbH1gKVxyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyhsYWJlbHMpLmZpbHRlcihpZCA9PiAhbGFiZWxzW2lkXS5lbXB0eSgpKVxyXG5cdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCBub2RlID0gbGFiZWxzW3ZdO1xyXG5cclxuXHRcdFx0XHQod2l0aFRyYW5zaXRpb24gPyBub2RlLnRyYW5zaXRpb24oKSA6IG5vZGUpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgKCkgPT4gdGhpcy54Rm9yQXhpc0xhYmVsKHYpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCAoKSA9PiB0aGlzLmR4Rm9yQXhpc0xhYmVsKHYpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCAoKSA9PiB0aGlzLmR5Rm9yQXhpc0xhYmVsKHYpKVxyXG5cdFx0XHRcdFx0LnRleHQoKCkgPT4gdGhpcy5nZXRMYWJlbFRleHQodikpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGdldFBhZGRpbmcocGFkZGluZywga2V5LCBkZWZhdWx0VmFsdWUsIGRvbWFpbkxlbmd0aCkge1xyXG5cdFx0Y29uc3QgcCA9IGlzTnVtYmVyKHBhZGRpbmcpID8gcGFkZGluZyA6IHBhZGRpbmdba2V5XTtcclxuXHJcblx0XHRpZiAoIWlzVmFsdWUocCkpIHtcclxuXHRcdFx0cmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhwLCBkb21haW5MZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0Y29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcocGl4ZWxzLCBkb21haW5MZW5ndGgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7d2lkdGgsIGhlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBsZW5ndGggPSBjb25maWcuYXhpc19yb3RhdGVkID8gd2lkdGggOiBoZWlnaHQ7XHJcblxyXG5cdFx0cmV0dXJuIGRvbWFpbkxlbmd0aCAqIChwaXhlbHMgLyBsZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUaWNrVmFsdWVzKHZhbHVlcywgdGlja0NvdW50LCBmb3JUaW1lU2VyaWVzKSB7XHJcblx0XHRsZXQgdGlja1ZhbHVlcyA9IHZhbHVlcztcclxuXHJcblx0XHRpZiAodGlja0NvdW50KSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldENvdW50ID0gaXNGdW5jdGlvbih0aWNrQ291bnQpID8gdGlja0NvdW50KCkgOiB0aWNrQ291bnQ7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHRpY2tzIGFjY29yZGluZyB0byB0aWNrQ291bnRcclxuXHRcdFx0aWYgKHRhcmdldENvdW50ID09PSAxKSB7XHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID09PSAyKSB7XHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF0sIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID4gMikge1xyXG5cdFx0XHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSB0aGlzLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgY291bnQgPSB0YXJnZXRDb3VudCAtIDI7XHJcblx0XHRcdFx0Y29uc3Qgc3RhcnQgPSB2YWx1ZXNbMF07XHJcblx0XHRcdFx0Y29uc3QgZW5kID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRjb25zdCBpbnRlcnZhbCA9IChlbmQgLSBzdGFydCkgLyAoY291bnQgKyAxKTtcclxuXHRcdFx0XHRsZXQgdGlja1ZhbHVlO1xyXG5cclxuXHRcdFx0XHQvLyByZS1jb25zdHJ1Y3QgdW5pcXVlIHZhbHVlc1xyXG5cdFx0XHRcdHRpY2tWYWx1ZXMgPSBbc3RhcnRdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHRcdFx0XHRcdHRpY2tWYWx1ZSA9ICtzdGFydCArIGludGVydmFsICogKGkgKyAxKTtcclxuXHRcdFx0XHRcdHRpY2tWYWx1ZXMucHVzaChcclxuXHRcdFx0XHRcdFx0Zm9yVGltZVNlcmllcyA/IG5ldyBEYXRlKHRpY2tWYWx1ZSkgOiAoXHJcblx0XHRcdFx0XHRcdFx0aXNDYXRlZ29yaXplZCA/IE1hdGgucm91bmQodGlja1ZhbHVlKSA6IHRpY2tWYWx1ZVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGlja1ZhbHVlcy5wdXNoKGVuZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWZvclRpbWVTZXJpZXMpIHtcclxuXHRcdFx0dGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWNrVmFsdWVzO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3QgYXhpcyA9ICQkLiRlbC5heGlzO1xyXG5cclxuXHRcdGNvbnN0IFtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1YlhdID0gW1wieFwiLCBcInlcIiwgXCJ5MlwiLCBcInN1YlhcIl1cclxuXHRcdFx0Lm1hcCh2ID0+IHtcclxuXHRcdFx0XHRsZXQgYXggPSBheGlzW3ZdO1xyXG5cclxuXHRcdFx0XHRpZiAoYXggJiYgZHVyYXRpb24pIHtcclxuXHRcdFx0XHRcdGF4ID0gYXgudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBheDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1Ylh9O1xyXG5cdH1cclxuXHJcblx0cmVkcmF3KHRyYW5zaXRpb25zLCBpc0hpZGRlbiwgaXNJbml0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBvcGFjaXR5ID0gaXNIaWRkZW4gPyBcIjBcIiA6IFwiMVwiO1xyXG5cclxuXHRcdFtcInhcIiwgXCJ5XCIsIFwieTJcIiwgXCJzdWJYXCJdLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCBheGlzID0gdGhpc1tpZF07XHJcblx0XHRcdGNvbnN0ICRheGlzID0gJGVsLmF4aXNbaWRdO1xyXG5cclxuXHRcdFx0aWYgKGF4aXMgJiYgJGF4aXMpIHtcclxuXHRcdFx0XHRpZiAoIWlzSW5pdCkge1xyXG5cdFx0XHRcdFx0YXhpcy5jb25maWcud2l0aG91dFRyYW5zaXRpb24gPSAhY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb247XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQkYXhpcy5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XHJcblx0XHRcdFx0YXhpcy5jcmVhdGUodHJhbnNpdGlvbnNbYGF4aXMke2NhcGl0YWxpemUoaWQpfWBdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVBeGVzKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgYXhpc1xyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNUb1Nob3cgdGFyZ2V0cyBkYXRhIHRvIGJlIHNob3duXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHd0aCBvcHRpb24gb2JqZWN0XHJcblx0ICogQHBhcmFtIHtkMy5UcmFuc2l0aW9ufSB0cmFuc2l0aW9ucyBUcmFuc2l0aW9uIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBmbG93IGZsb3cgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc0luaXQgY2FsbGVkIGZyb20gaW5pdGlhbGl6YXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaXNJbml0OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzWm9vbSA9ICEhc2NhbGUuem9vbTtcclxuXHRcdGxldCB4RG9tYWluRm9yWm9vbTtcclxuXHJcblx0XHRpZiAoIWhhc1pvb20gJiYgdGhpcy5pc0NhdGVnb3JpemVkKCkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0c2NhbGUueC5kb21haW4oWzAsICRlbC5heGlzLnguc2VsZWN0QWxsKFwiLnRpY2tcIikuc2l6ZSgpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNjYWxlLnggJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcclxuXHRcdFx0IWhhc1pvb20gJiZcclxuXHRcdFx0XHQkJC51cGRhdGVYRG9tYWluKHRhcmdldHNUb1Nob3csIHd0aC5VcGRhdGVYRG9tYWluLCB3dGguVXBkYXRlT3JnWERvbWFpbiwgd3RoLlRyaW1YRG9tYWluKTtcclxuXHJcblx0XHRcdGlmICghY29uZmlnLmF4aXNfeF90aWNrX3ZhbHVlcykge1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3cpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMueCkge1xyXG5cdFx0XHR0aGlzLngudGlja1ZhbHVlcyhbXSk7XHJcblx0XHRcdHRoaXMuc3ViWCAmJiB0aGlzLnN1YlgudGlja1ZhbHVlcyhbXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy56b29tX3Jlc2NhbGUgJiYgIWZsb3cpIHtcclxuXHRcdFx0eERvbWFpbkZvclpvb20gPSBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdFtcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdGNvbnN0IGF4aXNTY2FsZSA9IHNjYWxlW2tleV07XHJcblxyXG5cdFx0XHRpZiAoYXhpc1NjYWxlKSB7XHJcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IGNvbmZpZ1tgYXhpc18ke2tleX1fdGlja192YWx1ZXNgXTtcclxuXHRcdFx0XHRjb25zdCB0aWNrQ291bnQgPSBjb25maWdbYGF4aXNfJHtrZXl9X3RpY2tfY291bnRgXTtcclxuXHJcblx0XHRcdFx0YXhpc1NjYWxlLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIGtleSwgeERvbWFpbkZvclpvb20pKTtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgYXhpcyA9ICQkLmF4aXNba2V5XTtcclxuXHRcdFx0XHRcdGNvbnN0IGRvbWFpbiA9IGF4aXNTY2FsZS5kb21haW4oKTtcclxuXHJcblx0XHRcdFx0XHRheGlzLnRpY2tWYWx1ZXMoXHJcblx0XHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0XHRcdGRvbWFpbixcclxuXHRcdFx0XHRcdFx0XHRkb21haW4uZXZlcnkodiA9PiB2ID09PSAwKSA/IDEgOiB0aWNrQ291bnQsXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5pc1RpbWVTZXJpZXNZKClcclxuXHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGF4ZXNcclxuXHRcdHRoaXMucmVkcmF3KHRyYW5zaXRpb25zLCAkJC5oYXNBcmNUeXBlKCksIGlzSW5pdCk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGF4aXMgbGFiZWxcclxuXHRcdHRoaXMudXBkYXRlTGFiZWxzKHd0aC5UcmFuc2l0aW9uKTtcclxuXHJcblx0XHQvLyBzaG93L2hpZGUgaWYgbWFudWFsIGN1bGxpbmcgbmVlZGVkXHJcblx0XHRpZiAoKHd0aC5VcGRhdGVYRG9tYWluIHx8IHd0aC5VcGRhdGVYQXhpcyB8fCB3dGguWSkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcclxuXHRcdFx0dGhpcy5zZXRDdWxsaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIHN1YiBkb21haW5cclxuXHRcdGlmICh3dGguWSkge1xyXG5cdFx0XHRzY2FsZS5zdWJZICYmIHNjYWxlLnN1YlkuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywgXCJ5XCIpKTtcclxuXHRcdFx0c2NhbGUuc3ViWTIgJiYgc2NhbGUuc3ViWTIuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywgXCJ5MlwiKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWFudWFsIGN1bGxpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEN1bGxpbmcoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXAsIGN1cnJlbnR9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0W1wic3ViWFwiLCBcInhcIiwgXCJ5XCIsIFwieTJcIl0uZm9yRWFjaCh0eXBlID0+IHtcclxuXHRcdFx0Y29uc3QgYXhpcyA9ICRlbC5heGlzW3R5cGVdO1xyXG5cclxuXHRcdFx0Ly8gc3ViY2hhcnQgeCBheGlzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggeCBheGlzIGN1bGxpbmdcclxuXHRcdFx0Y29uc3QgaWQgPSB0eXBlID09PSBcInN1YlhcIiA/IFwieFwiIDogdHlwZTtcclxuXHRcdFx0Y29uc3QgdG9DdWxsID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY3VsbGluZ2BdO1xyXG5cclxuXHRcdFx0aWYgKGF4aXMgJiYgdG9DdWxsKSB7XHJcblx0XHRcdFx0Y29uc3QgdGlja1RleHQgPSBheGlzLnNlbGVjdEFsbChcIi50aWNrIHRleHRcIik7XHJcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IHNvcnRWYWx1ZSh0aWNrVGV4dC5kYXRhKCkpO1xyXG5cdFx0XHRcdGNvbnN0IHRpY2tTaXplID0gdGlja1ZhbHVlcy5sZW5ndGg7XHJcblx0XHRcdFx0Y29uc3QgY3VsbGluZ01heCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2N1bGxpbmdfbWF4YF07XHJcblx0XHRcdFx0bGV0IGludGVydmFsRm9yQ3VsbGluZztcclxuXHJcblx0XHRcdFx0aWYgKHRpY2tTaXplKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRpY2tTaXplOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKHRpY2tTaXplIC8gaSA8IGN1bGxpbmdNYXgpIHtcclxuXHRcdFx0XHRcdFx0XHRpbnRlcnZhbEZvckN1bGxpbmcgPSBpO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGlja1RleHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IHRpY2tWYWx1ZXMuaW5kZXhPZihkKSAlIGludGVydmFsRm9yQ3VsbGluZyA/IFwibm9uZVwiIDogXCJibG9ja1wiO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpY2tUZXh0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gc2V0L3Vuc2V0IHhfYXhpc190aWNrX2NsaXBwYXRoXHJcblx0XHRcdFx0aWYgKHR5cGUgPT09IFwieFwiKSB7XHJcblx0XHRcdFx0XHRjb25zdCBjbGlwUGF0aCA9IGN1cnJlbnQubWF4VGlja1dpZHRocy54LmNsaXBQYXRoID8gY2xpcC5wYXRoWEF4aXNUaWNrVGV4dHMgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRcdCRlbC5zdmcuc2VsZWN0QWxsKGAuJHtDTEFTUy5heGlzWH0gLnRpY2sgdGV4dGApXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0Y3N2UGFyc2UgYXMgZDNDc3ZQYXJzZSxcclxuXHR0c3ZQYXJzZSBhcyBkM1RzdlBhcnNlLFxyXG5cdGNzdlBhcnNlUm93cyBhcyBkM0NzdlBhcnNlUm93cyxcclxuXHR0c3ZQYXJzZVJvd3MgYXMgZDNUc3ZQYXJzZVJvd3MsXHJcbn0gZnJvbSBcImQzLWRzdlwiO1xyXG5pbXBvcnQge2lzVW5kZWZpbmVkLCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1ZhbHVlLCBub3RFbXB0eSwgaXNBcnJheSwgY2FwaXRhbGl6ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogRGF0YSBjb252ZXJ0XHJcbiAqIEBtZW1iZXJvZiBDaGFydEludGVybmFsXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ29udmVydCBkYXRhIGFjY29yZGluZyBpdHMgdHlwZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIGRhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmb3IgdXJsKFhIUikgdHlwZSBsb2FkaW5nXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnREYXRhKGFyZ3MsIGNhbGxiYWNrOiBGdW5jdGlvbik6IG9iamVjdCB7XHJcblx0XHRsZXQgZGF0YTtcclxuXHJcblx0XHRpZiAoYXJncy5iaW5kdG8pIHtcclxuXHRcdFx0ZGF0YSA9IHt9O1xyXG5cclxuXHRcdFx0W1widXJsXCIsIFwibWltZVR5cGVcIiwgXCJoZWFkZXJzXCIsIFwia2V5c1wiLCBcImpzb25cIiwgXCJrZXlzXCIsIFwicm93c1wiLCBcImNvbHVtbnNcIl1cclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGtleSA9IGBkYXRhXyR7dn1gO1xyXG5cclxuXHRcdFx0XHRcdGlmIChrZXkgaW4gYXJncykge1xyXG5cdFx0XHRcdFx0XHRkYXRhW3ZdID0gYXJnc1trZXldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGF0YSA9IGFyZ3M7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRhdGEudXJsICYmIGNhbGxiYWNrKSB7XHJcblx0XHRcdHRoaXMuY29udmVydFVybFRvRGF0YShkYXRhLnVybCwgZGF0YS5taW1lVHlwZSwgZGF0YS5oZWFkZXJzLCBkYXRhLmtleXMsIGNhbGxiYWNrKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5qc29uKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRKc29uVG9EYXRhKGRhdGEuanNvbiwgZGF0YS5rZXlzKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5yb3dzKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRSb3dzVG9EYXRhKGRhdGEucm93cyk7XHJcblx0XHR9IGVsc2UgaWYgKGRhdGEuY29sdW1ucykge1xyXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Q29sdW1uc1RvRGF0YShkYXRhLmNvbHVtbnMpO1xyXG5cdFx0fSBlbHNlIGlmIChhcmdzLmJpbmR0bykge1xyXG5cdFx0XHR0aHJvdyBFcnJvcihcInVybCBvciBqc29uIG9yIHJvd3Mgb3IgY29sdW1ucyBpcyByZXF1aXJlZC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzQXJyYXkoZGF0YSkgJiYgZGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IFVSTCBkYXRhXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZW1vdGUgVVJMXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1pbWVUeXBlIE1JTUUgdHlwZSBzdHJpbmc6IGpzb24gfCBjc3YgfCB0c3ZcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gaGVhZGVycyBIZWFkZXIgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGtleXMgS2V5IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQ2FsbGJhY2sgZnVuY3Rpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnRVcmxUb0RhdGEodXJsOiBzdHJpbmcsIG1pbWVUeXBlID0gXCJjc3ZcIiwgaGVhZGVyczogb2JqZWN0LCBrZXlzOiBvYmplY3QsIGRvbmU6IEZ1bmN0aW9uKTogdm9pZCB7XHJcblx0XHRjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0XHRyZXEub3BlbihcIkdFVFwiLCB1cmwpO1xyXG5cclxuXHRcdGlmIChoZWFkZXJzKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRyZXEuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcblx0XHRcdGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG5cdFx0XHRcdGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcclxuXHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcclxuXHJcblx0XHRcdFx0XHRyZXNwb25zZSAmJiBkb25lLmNhbGwodGhpcyxcclxuXHRcdFx0XHRcdFx0dGhpc1tgY29udmVydCR7Y2FwaXRhbGl6ZShtaW1lVHlwZSl9VG9EYXRhYF0oXHJcblx0XHRcdFx0XHRcdFx0bWltZVR5cGUgPT09IFwianNvblwiID8gSlNPTi5wYXJzZShyZXNwb25zZSkgOiByZXNwb25zZSxcclxuXHRcdFx0XHRcdFx0XHRrZXlzXHJcblx0XHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7dXJsfTogU29tZXRoaW5nIHdlbnQgd3JvbmcgbG9hZGluZyFgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0cmVxLnNlbmQoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IENTVi9UU1YgZGF0YVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZXIgUGFyc2VyIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB4c3YgRGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKi9cclxuXHRjb252ZXJ0Q3N2VHN2VG9EYXRhKHBhcnNlciwgeHN2KSB7XHJcblx0XHRjb25zdCByb3dzID0gcGFyc2VyLnJvd3MoeHN2KTtcclxuXHRcdGxldCBkO1xyXG5cclxuXHRcdGlmIChyb3dzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRkID0gW3t9XTtcclxuXHJcblx0XHRcdHJvd3NbMF0uZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdFx0ZFswXVtpZF0gPSBudWxsO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGQgPSBwYXJzZXIucGFyc2UoeHN2KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0Q3N2VG9EYXRhKHhzdikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydENzdlRzdlRvRGF0YSh7XHJcblx0XHRcdHJvd3M6IGQzQ3N2UGFyc2VSb3dzLFxyXG5cdFx0XHRwYXJzZTogZDNDc3ZQYXJzZVxyXG5cdFx0fSwgeHN2KTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VHN2VG9EYXRhKHRzdikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydENzdlRzdlRvRGF0YSh7XHJcblx0XHRcdHJvd3M6IGQzVHN2UGFyc2VSb3dzLFxyXG5cdFx0XHRwYXJzZTogZDNUc3ZQYXJzZVxyXG5cdFx0fSwgdHN2KTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0SnNvblRvRGF0YShqc29uLCBrZXlzUGFyYW0pIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IHN0cmluZ1tdW10gPSBbXTtcclxuXHRcdGxldCB0YXJnZXRLZXlzOiBzdHJpbmdbXTtcclxuXHRcdGxldCBkYXRhO1xyXG5cclxuXHRcdGlmIChpc0FycmF5KGpzb24pKSB7XHJcblx0XHRcdGNvbnN0IGtleXMgPSBrZXlzUGFyYW0gfHwgY29uZmlnLmRhdGFfa2V5cztcclxuXHJcblx0XHRcdGlmIChrZXlzLngpIHtcclxuXHRcdFx0XHR0YXJnZXRLZXlzID0ga2V5cy52YWx1ZS5jb25jYXQoa2V5cy54KTtcclxuXHRcdFx0XHRjb25maWcuZGF0YV94ID0ga2V5cy54O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRhcmdldEtleXMgPSBrZXlzLnZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuZXdSb3dzLnB1c2godGFyZ2V0S2V5cyk7XHJcblxyXG5cdFx0XHRqc29uLmZvckVhY2gobyA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbmV3Um93ID0gdGFyZ2V0S2V5cy5tYXAoa2V5ID0+IHtcclxuXHRcdFx0XHRcdC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgYmVjYXVzZSB1bmRlZmluZWQgZGF0YSB3aWxsIGJlIHJlbW92ZWQgaW4gY29udmVydERhdGFUb1RhcmdldHMoKVxyXG5cdFx0XHRcdFx0bGV0IHYgPSB0aGlzLmZpbmRWYWx1ZUluSnNvbihvLCBrZXkpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh2KSkge1xyXG5cdFx0XHRcdFx0XHR2ID0gbnVsbDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gdjtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydFJvd3NUb0RhdGEobmV3Um93cyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhqc29uKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdG1wID0ganNvbltrZXldLmNvbmNhdCgpO1xyXG5cclxuXHRcdFx0XHR0bXAudW5zaGlmdChrZXkpO1xyXG5cdFx0XHRcdG5ld1Jvd3MucHVzaCh0bXApO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRDb2x1bW5zVG9EYXRhKG5ld1Jvd3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRWYWx1ZUluSnNvbihvYmplY3QsIHBhdGgpIHtcclxuXHRcdGlmIChvYmplY3RbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gb2JqZWN0W3BhdGhdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNvbnZlcnRlZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcWyhcXHcrKVxcXS9nLCBcIi4kMVwiKTsgLy8gY29udmVydCBpbmRleGVzIHRvIHByb3BlcnRpZXMgKHJlcGxhY2UgW10gd2l0aCAuKVxyXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gY29udmVydGVkUGF0aC5yZXBsYWNlKC9eXFwuLywgXCJcIikuc3BsaXQoXCIuXCIpOyAvLyBzdHJpcCBhIGxlYWRpbmcgZG90XHJcblx0XHRsZXQgdGFyZ2V0ID0gb2JqZWN0O1xyXG5cclxuXHRcdHBhdGhBcnJheS5zb21lKGsgPT4gIShcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0ICYmIGsgaW4gdGFyZ2V0ID9cclxuXHRcdFx0XHR0YXJnZXRba10gOiB1bmRlZmluZWRcclxuXHRcdCkpO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0Y29udmVydFJvd3NUb0RhdGEocm93cykge1xyXG5cdFx0Y29uc3Qga2V5cyA9IHJvd3NbMF07XHJcblx0XHRjb25zdCBuZXdSb3dzOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdHJvd3MuZm9yRWFjaCgocm93LCBpKSA9PiB7XHJcblx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IG5ld1JvdyA9IHt9O1xyXG5cclxuXHRcdFx0XHRyb3cuZm9yRWFjaCgodiwgaikgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHYpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgU291cmNlIGRhdGEgaXMgbWlzc2luZyBhIGNvbXBvbmVudCBhdCAoJHtpfSwgJHtqfSkhYCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bmV3Um93W2tleXNbal1dID0gdjtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBuZXdSb3dzO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRDb2x1bW5zVG9EYXRhKGNvbHVtbnMpIHtcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IGFueVtdID0gW107XHJcblxyXG5cdFx0Y29sdW1ucy5mb3JFYWNoKChjb2wsIGkpID0+IHtcclxuXHRcdFx0Y29uc3Qga2V5ID0gY29sWzBdO1xyXG5cclxuXHRcdFx0Y29sLmZvckVhY2goKHYsIGopID0+IHtcclxuXHRcdFx0XHRpZiAoaiA+IDApIHtcclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZChuZXdSb3dzW2ogLSAxXSkpIHtcclxuXHRcdFx0XHRcdFx0bmV3Um93c1tqIC0gMV0gPSB7fTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodikpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0ICgke2l9LCAke2p9KSFgKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRuZXdSb3dzW2ogLSAxXVtrZXldID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XHJcblx0fSxcclxuXHJcblx0Y29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgYXBwZW5kWHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtheGlzLCBjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0bGV0IGlzQ2F0ZWdvcml6ZWQgPSBmYWxzZTtcclxuXHRcdGxldCBpc1RpbWVTZXJpZXMgPSBmYWxzZTtcclxuXHRcdGxldCBpc0N1c3RvbVggPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoYXhpcykge1xyXG5cdFx0XHRpc0NhdGVnb3JpemVkID0gYXhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRcdGlzVGltZVNlcmllcyA9IGF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRcdGlzQ3VzdG9tWCA9IGF4aXMuaXNDdXN0b21YKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdIHx8IHt9KTtcclxuXHRcdGNvbnN0IGlkcyA9IGRhdGFLZXlzLmxlbmd0aCA/IGRhdGFLZXlzLmZpbHRlcigkJC5pc05vdFgsICQkKSA6IFtdO1xyXG5cdFx0Y29uc3QgeHMgPSBkYXRhS2V5cy5sZW5ndGggPyBkYXRhS2V5cy5maWx0ZXIoJCQuaXNYLCAkJCkgOiBbXTtcclxuXHJcblx0XHRsZXQgeHNEYXRhO1xyXG5cclxuXHRcdC8vIHNhdmUgeCBmb3IgdXBkYXRlIGRhdGEgYnkgbG9hZCB3aGVuIGN1c3RvbSB4IGFuZCBiYi54IEFQSVxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCB4S2V5ID0gdGhpcy5nZXRYS2V5KGlkKTtcclxuXHJcblx0XHRcdGlmIChpc0N1c3RvbVggfHwgaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0Ly8gaWYgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YVxyXG5cdFx0XHRcdGlmICh4cy5pbmRleE9mKHhLZXkpID49IDApIHtcclxuXHRcdFx0XHRcdHhzRGF0YSA9ICgoYXBwZW5kWHMgJiYgJCQuZGF0YS54c1tpZF0pIHx8IFtdKVxyXG5cdFx0XHRcdFx0XHQuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEubWFwKGQgPT4gZFt4S2V5XSlcclxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoaXNWYWx1ZSlcclxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKHJhd1gsIGkpID0+ICQkLmdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaSkpXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjb25maWcuZGF0YV94KSB7XHJcblx0XHRcdFx0XHQvLyBpZiBub3QgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YSwgZmluZCBmcm9tIHByZWxvYWRlZCBkYXRhIG9mIG90aGVyIGlkJ3MgeFxyXG5cdFx0XHRcdFx0eHNEYXRhID0gdGhpcy5nZXRPdGhlclRhcmdldFhzKCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChub3RFbXB0eShjb25maWcuZGF0YV94cykpIHtcclxuXHRcdFx0XHRcdC8vIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhLCBmaW5kIGZyb20gcHJlbG9hZGVkIGRhdGFcclxuXHRcdFx0XHRcdHhzRGF0YSA9ICQkLmdldFhWYWx1ZXNPZlhLZXkoeEtleSwgJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gTUVNTzogaWYgbm8geCBpbmNsdWRlZCwgdXNlIHNhbWUgeCBvZiBjdXJyZW50IHdpbGwgYmUgdXNlZFxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHhzRGF0YSA9IGRhdGEubWFwKChkLCBpKSA9PiBpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eHNEYXRhICYmICh0aGlzLmRhdGEueHNbaWRdID0geHNEYXRhKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGNoZWNrIHggaXMgZGVmaW5lZFxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRpZiAoIXRoaXMuZGF0YS54c1tpZF0pIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHggaXMgbm90IGRlZmluZWQgZm9yIGlkID0gXCIke2lkfVwiLmApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBjb252ZXJ0IHRvIHRhcmdldFxyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IGlkcy5tYXAoKGlkLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRjb25zdCBjb252ZXJ0ZWRJZCA9IGNvbmZpZy5kYXRhX2lkQ29udmVydGVyLmJpbmQoJCQuYXBpKShpZCk7XHJcblx0XHRcdGNvbnN0IHhLZXkgPSAkJC5nZXRYS2V5KGlkKTtcclxuXHRcdFx0Y29uc3QgaXNDYXRlZ29yeSA9IGlzQ3VzdG9tWCAmJiBpc0NhdGVnb3JpemVkO1xyXG5cdFx0XHRjb25zdCBoYXNDYXRlZ29yeSA9IGlzQ2F0ZWdvcnkgJiYgZGF0YS5tYXAodiA9PiB2LngpXHJcblx0XHRcdFx0LmV2ZXJ5KHYgPT4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodikgPiAtMSk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGlkOiBjb252ZXJ0ZWRJZCxcclxuXHRcdFx0XHRpZF9vcmc6IGlkLFxyXG5cdFx0XHRcdHZhbHVlczogZGF0YS5tYXAoKGQsIGkpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHJhd1ggPSBkW3hLZXldO1xyXG5cdFx0XHRcdFx0bGV0IHZhbHVlID0gZFtpZF07XHJcblx0XHRcdFx0XHRsZXQgeDtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgIWlzT2JqZWN0KHZhbHVlKSA/XHJcblx0XHRcdFx0XHRcdCt2YWx1ZSA6IChpc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IG51bGwpO1xyXG5cclxuXHRcdFx0XHRcdC8vIHVzZSB4IGFzIGNhdGVnb3JpZXMgaWYgY3VzdG9tIHggYW5kIGNhdGVnb3JpemVkXHJcblx0XHRcdFx0XHRpZiAoKGlzQ2F0ZWdvcnkgfHwgc3RhdGUuaGFzUmFkYXIpICYmIGluZGV4ID09PSAwICYmICFpc1VuZGVmaW5lZChyYXdYKSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIWhhc0NhdGVnb3J5ICYmIGluZGV4ID09PSAwICYmIGkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0eCA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHJhd1gpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHggPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0eCA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLnB1c2gocmF3WCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHggPSAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIG1hcmsgYXMgeCA9IHVuZGVmaW5lZCBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kIGZpbHRlciB0byByZW1vdmUgYWZ0ZXIgbWFwcGVkXHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8ICQkLmRhdGEueHNbaWRdLmxlbmd0aCA8PSBpKSB7XHJcblx0XHRcdFx0XHRcdHggPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHt4LCB2YWx1ZSwgaWQ6IGNvbnZlcnRlZElkfTtcclxuXHRcdFx0XHR9KS5maWx0ZXIodiA9PiBpc0RlZmluZWQodi54KSlcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGZpbmlzaCB0YXJnZXRzXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdC8vIHNvcnQgdmFsdWVzIGJ5IGl0cyB4XHJcblx0XHRcdGlmIChjb25maWcuZGF0YV94U29ydCkge1xyXG5cdFx0XHRcdHQudmFsdWVzID0gdC52YWx1ZXMuc29ydCgodjEsIHYyKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB4MSA9IHYxLnggfHwgdjEueCA9PT0gMCA/IHYxLnggOiBJbmZpbml0eTtcclxuXHRcdFx0XHRcdGNvbnN0IHgyID0gdjIueCB8fCB2Mi54ID09PSAwID8gdjIueCA6IEluZmluaXR5O1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB4MSAtIHgyO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpbmRleGluZyBlYWNoIHZhbHVlXHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHYsIGkpID0+ICh2LmluZGV4ID0gaSkpO1xyXG5cclxuXHRcdFx0Ly8gdGhpcyBuZWVkcyB0byBiZSBzb3J0ZWQgYmVjYXVzZSBpdHMgaW5kZXggYW5kIHZhbHVlLmluZGV4IGlzIGlkZW50aWNhbFxyXG5cdFx0XHQkJC5kYXRhLnhzW3QuaWRdLnNvcnQoKHYxLCB2MikgPT4gdjEgLSB2Mik7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBjYWNoZSBpbmZvcm1hdGlvbiBhYm91dCB2YWx1ZXNcclxuXHRcdHN0YXRlLmhhc05lZ2F0aXZlVmFsdWUgPSAkJC5oYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xyXG5cdFx0c3RhdGUuaGFzUG9zaXRpdmVWYWx1ZSA9ICQkLmhhc1Bvc2l0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gc2V0IHRhcmdldCB0eXBlc1xyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX3R5cGUpIHtcclxuXHRcdFx0JCQuc2V0VGFyZ2V0VHlwZSgkJC5tYXBUb0lkcyh0YXJnZXRzKVxyXG5cdFx0XHRcdC5maWx0ZXIoaWQgPT4gIShpZCBpbiBjb25maWcuZGF0YV90eXBlcykpLCBjb25maWcuZGF0YV90eXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWNoZSBhcyBvcmlnaW5hbCBpZCBrZXllZFxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4gJCQuY2FjaGUuYWRkKGQuaWRfb3JnLCBkLCB0cnVlKSk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtLRVl9IGZyb20gXCIuLi8uLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IHtcclxuXHRnZXRVbmlxdWUsXHJcblx0aGFzVmFsdWUsXHJcblx0aXNBcnJheSxcclxuXHRpc2Jvb2xlYW4sXHJcblx0aXNEZWZpbmVkLFxyXG5cdGlzRnVuY3Rpb24sXHJcblx0aXNOdW1iZXIsXHJcblx0aXNPYmplY3QsXHJcblx0aXNPYmplY3RUeXBlLFxyXG5cdGlzU3RyaW5nLFxyXG5cdGlzVW5kZWZpbmVkLFxyXG5cdGlzVmFsdWUsXHJcblx0bWVyZ2VBcnJheSxcclxuXHRub3RFbXB0eSxcclxuXHRwYXJzZURhdGUsXHJcblx0c29ydFZhbHVlXHJcbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aXNYKGtleSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFLZXkgPSBjb25maWcuZGF0YV94ICYmIGtleSA9PT0gY29uZmlnLmRhdGFfeDtcclxuXHRcdGNvbnN0IGV4aXN0VmFsdWUgPSBub3RFbXB0eShjb25maWcuZGF0YV94cykgJiYgaGFzVmFsdWUoY29uZmlnLmRhdGFfeHMsIGtleSk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGFLZXkgfHwgZXhpc3RWYWx1ZTtcclxuXHR9LFxyXG5cclxuXHRpc05vdFgoa2V5KTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gIXRoaXMuaXNYKGtleSk7XHJcblx0fSxcclxuXHJcblx0aXNTdGFja05vcm1hbGl6ZWQoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICEhKGNvbmZpZy5kYXRhX3N0YWNrX25vcm1hbGl6ZSAmJiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoKTtcclxuXHR9LFxyXG5cclxuXHRpc0dyb3VwZWQoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5kYXRhX2dyb3Vwc1xyXG5cdFx0XHQubWFwKHYgPT4gdi5pbmRleE9mKGlkKSA+PSAwKVswXTtcclxuXHR9LFxyXG5cclxuXHRnZXRYS2V5KGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuZGF0YV94ID9cclxuXHRcdFx0Y29uZmlnLmRhdGFfeCA6IChub3RFbXB0eShjb25maWcuZGF0YV94cykgPyBjb25maWcuZGF0YV94c1tpZF0gOiBudWxsKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYVmFsdWVzT2ZYS2V5KGtleSwgdGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaWRzID0gdGFyZ2V0cyAmJiBub3RFbXB0eSh0YXJnZXRzKSA/ICQkLm1hcFRvSWRzKHRhcmdldHMpIDogW107XHJcblx0XHRsZXQgeFZhbHVlcztcclxuXHJcblx0XHRpZHMuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGlmICgkJC5nZXRYS2V5KGlkKSA9PT0ga2V5KSB7XHJcblx0XHRcdFx0eFZhbHVlcyA9ICQkLmRhdGEueHNbaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4geFZhbHVlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgaW5kZXggbnVtYmVyIGJhc2VkIG9uIGdpdmVuIHggQXhpcyB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7RGF0ZXxudW1iZXJ8c3RyaW5nfSB4IHggQXhpcyB0byBiZSBjb21wYXJlZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGJhc2VkWCB4IEF4aXMgbGlzdCB0byBiZSBiYXNlZCBvblxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kZXhCeVgoeCwgYmFzZWRYOiAoc3RyaW5nfERhdGUpW10pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBiYXNlZFggP1xyXG5cdFx0XHRiYXNlZFguaW5kZXhPZihpc1N0cmluZyh4KSA/IHggOiAreCkgOlxyXG5cdFx0XHQoJCQuZmlsdGVyQnlYKCQkLmRhdGEudGFyZ2V0cywgeClbMF0gfHwge2luZGV4OiBudWxsfSkuaW5kZXg7XHJcblx0fSxcclxuXHJcblx0Z2V0WFZhbHVlKGlkOiBzdHJpbmcsIGk6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGlkIGluICQkLmRhdGEueHMgJiZcclxuXHRcdFx0JCQuZGF0YS54c1tpZF0gJiZcclxuXHRcdFx0aXNWYWx1ZSgkJC5kYXRhLnhzW2lkXVtpXSkgPyAkJC5kYXRhLnhzW2lkXVtpXSA6IGk7XHJcblx0fSxcclxuXHJcblx0Z2V0T3RoZXJUYXJnZXRYcygpOiBzdHJpbmcgfCBudWxsIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlkc0ZvclggPSBPYmplY3Qua2V5cygkJC5kYXRhLnhzKTtcclxuXHJcblx0XHRyZXR1cm4gaWRzRm9yWC5sZW5ndGggPyAkJC5kYXRhLnhzW2lkc0ZvclhbMF1dIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHRnZXRPdGhlclRhcmdldFgoaW5kZXg6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0Y29uc3QgeHMgPSB0aGlzLmdldE90aGVyVGFyZ2V0WHMoKTtcclxuXHJcblx0XHRyZXR1cm4geHMgJiYgaW5kZXggPCB4cy5sZW5ndGggPyB4c1tpbmRleF0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGFkZFhzKHhzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHhzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfeHNbaWRdID0geHNbaWRdO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0aXNNdWx0aXBsZVgoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgfHxcclxuXHRcdFx0IXRoaXMuY29uZmlnLmRhdGFfeFNvcnQgfHxcclxuXHRcdFx0dGhpcy5oYXNUeXBlKFwiYnViYmxlXCIpIHx8XHJcblx0XHRcdHRoaXMuaGFzVHlwZShcInNjYXR0ZXJcIik7XHJcblx0fSxcclxuXHJcblx0YWRkTmFtZShkYXRhKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IG5hbWU7XHJcblxyXG5cdFx0aWYgKGRhdGEpIHtcclxuXHRcdFx0bmFtZSA9IGNvbmZpZy5kYXRhX25hbWVzW2RhdGEuaWRdO1xyXG5cdFx0XHRkYXRhLm5hbWUgPSBuYW1lICE9PSB1bmRlZmluZWQgPyBuYW1lIDogZGF0YS5pZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYWxsIHZhbHVlcyBvbiBnaXZlbiBpbmRleFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyTnVsbCBGaWx0ZXIgbnVsbGlzaCB2YWx1ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXg6IG51bWJlciwgZmlsdGVyTnVsbCA9IGZhbHNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IHZhbHVlID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpXHJcblx0XHRcdC5tYXAodCA9PiAkJC5hZGROYW1lKCQkLmdldFZhbHVlT25JbmRleCh0LnZhbHVlcywgaW5kZXgpKSk7XHJcblxyXG5cdFx0aWYgKGZpbHRlck51bGwpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5maWx0ZXIodiA9PiBpc1ZhbHVlKHYudmFsdWUpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVPbkluZGV4KHZhbHVlcywgaW5kZXg6IG51bWJlcikge1xyXG5cdFx0Y29uc3QgdmFsdWVPbkluZGV4ID0gdmFsdWVzLmZpbHRlcih2ID0+IHYuaW5kZXggPT09IGluZGV4KTtcclxuXHJcblx0XHRyZXR1cm4gdmFsdWVPbkluZGV4Lmxlbmd0aCA/IHZhbHVlT25JbmRleFswXSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0WCh0YXJnZXRzLCB4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0di54ID0gJCQuZ2VuZXJhdGVUYXJnZXRYKHhbaV0sIHQuaWQsIGkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmRhdGEueHNbdC5pZF0gPSB4O1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0WHModGFyZ2V0cywgeHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHhzW3QuaWRdICYmICQkLnVwZGF0ZVRhcmdldFgoW3RdLCB4c1t0LmlkXSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQ6IHN0cmluZywgaW5kZXg6IG51bWJlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXN9ID0gJCQ7XHJcblx0XHRsZXQgeCA9IGF4aXMgJiYgYXhpcy5pc0NhdGVnb3JpemVkKCkgPyBpbmRleCA6IChyYXdYIHx8IGluZGV4KTtcclxuXHJcblx0XHRpZiAoYXhpcyAmJiBheGlzLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0eCA9IHJhd1ggPyBmbihyYXdYKSA6IGZuKCQkLmdldFhWYWx1ZShpZCwgaW5kZXgpKTtcclxuXHRcdH0gZWxzZSBpZiAoYXhpcyAmJiBheGlzLmlzQ3VzdG9tWCgpICYmICFheGlzLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHR4ID0gaXNWYWx1ZShyYXdYKSA/ICtyYXdYIDogJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWHModmFsdWVzKTogdm9pZCB7XHJcblx0XHRpZiAodmFsdWVzLmxlbmd0aCkge1xyXG5cdFx0XHR0aGlzLmF4aXMueHMgPSB2YWx1ZXMubWFwKHYgPT4gdi54KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRQcmV2WChpOiBudW1iZXIpOiBudW1iZXJbXSB8IG51bGwge1xyXG5cdFx0Y29uc3QgeCA9IHRoaXMuYXhpcy54c1tpIC0gMV07XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldE5leHRYKGk6IG51bWJlcik6IG51bWJlcltdIHwgbnVsbCB7XHJcblx0XHRjb25zdCB4ID0gdGhpcy5heGlzLnhzW2kgKyAxXTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHgpID8geCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGJhc2UgdmFsdWUgaXNBcmVhUmFuZ2VUeXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZVZhbHVlKGRhdGEpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXN9ID0gJCQuc3RhdGU7XHJcblx0XHRsZXQge3ZhbHVlfSA9IGRhdGE7XHJcblxyXG5cdFx0Ly8gSW4gY2FzZSBvZiBhcmVhLXJhbmdlLCBkYXRhIGlzIGdpdmVuIGFzOiBbbG93LCBtaWQsIGhpZ2hdIG9yIHtsb3csIG1pZCwgaGlnaH1cclxuXHRcdC8vIHdpbGwgdGFrZSB0aGUgJ21pZCcgYXMgdGhlIGJhc2UgdmFsdWVcclxuXHRcdGlmICh2YWx1ZSAmJiBoYXNBeGlzKSB7XHJcblx0XHRcdGlmICgkJC5pc0FyZWFSYW5nZVR5cGUoZGF0YSkpIHtcclxuXHRcdFx0XHR2YWx1ZSA9ICQkLmdldEFyZWFSYW5nZURhdGEoZGF0YSwgXCJtaWRcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVaVHlwZShkYXRhKSkge1xyXG5cdFx0XHRcdHZhbHVlID0gJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBtaW4vbWF4IHZhbHVlIGZyb20gdGhlIGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgYXJyYXkgZGF0YSB0byBiZSBldmFsdWF0ZWRcclxuXHQgKiBAcmV0dXJucyB7e21pbjoge251bWJlcn0sIG1heDoge251bWJlcn19fVxyXG5cdCAqL1xyXG5cdGdldE1pbk1heFZhbHVlKGRhdGEpOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSB7XHJcblx0XHRjb25zdCBnZXRCYXNlVmFsdWUgPSB0aGlzLmdldEJhc2VWYWx1ZS5iaW5kKHRoaXMpO1xyXG5cdFx0bGV0IG1pbjtcclxuXHRcdGxldCBtYXg7XHJcblxyXG5cdFx0KGRhdGEgfHwgdGhpcy5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKVxyXG5cdFx0XHQuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdi5tYXAoZ2V0QmFzZVZhbHVlKS5maWx0ZXIoaXNOdW1iZXIpO1xyXG5cclxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihpID8gbWluIDogSW5maW5pdHksIC4uLnZhbHVlKTtcclxuXHRcdFx0XHRtYXggPSBNYXRoLm1heChpID8gbWF4IDogLUluZmluaXR5LCAuLi52YWx1ZSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB7bWluLCBtYXh9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbWluL21heCBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJucyB7e21pbjogQXJyYXksIG1heDogQXJyYXl9fVxyXG5cdCAqL1xyXG5cdGdldE1pbk1heERhdGEoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IEtFWS5kYXRhTWluTWF4O1xyXG5cdFx0bGV0IG1pbk1heERhdGEgPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghbWluTWF4RGF0YSkge1xyXG5cdFx0XHRjb25zdCBkYXRhID0gJCQuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKTtcclxuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4VmFsdWUoZGF0YSk7XHJcblxyXG5cdFx0XHRsZXQgbWluID0gW107XHJcblx0XHRcdGxldCBtYXggPSBbXTtcclxuXHJcblx0XHRcdGRhdGEuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCBtaW5EYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWluKTtcclxuXHRcdFx0XHRjb25zdCBtYXhEYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWF4KTtcclxuXHJcblx0XHRcdFx0aWYgKG1pbkRhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRtaW4gPSBtaW4uY29uY2F0KG1pbkRhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKG1heERhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRtYXggPSBtYXguY29uY2F0KG1heERhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGNhY2hlZCBkYXRhXHJcblx0XHRcdCQkLmNhY2hlLmFkZChjYWNoZUtleSwgbWluTWF4RGF0YSA9IHttaW4sIG1heH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtaW5NYXhEYXRhO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBzdW0gb2YgZGF0YSBwZXIgaW5kZXhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKi9cclxuXHRnZXRUb3RhbFBlckluZGV4KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBLRVkuZGF0YVRvdGFsUGVySW5kZXg7XHJcblx0XHRsZXQgc3VtID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAhc3VtKSB7XHJcblx0XHRcdHN1bSA9IFtdO1xyXG5cclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2gocm93ID0+IHtcclxuXHRcdFx0XHRyb3cudmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRcdGlmICghc3VtW2ldKSB7XHJcblx0XHRcdFx0XHRcdHN1bVtpXSA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c3VtW2ldICs9IGlzTnVtYmVyKHYudmFsdWUpID8gdi52YWx1ZSA6IDA7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdW07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRvdGFsIGRhdGEgc3VtXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBzdWJ0cmFjdEhpZGRlbiBTdWJ0cmFjdCBoaWRkZW4gZGF0YSBmcm9tIHRvdGFsXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvdGFsRGF0YVN1bShzdWJ0cmFjdEhpZGRlbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBLRVkuZGF0YVRvdGFsU3VtO1xyXG5cdFx0bGV0IHRvdGFsID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIWlzTnVtYmVyKHRvdGFsKSkge1xyXG5cdFx0XHRjb25zdCBzdW0gPSBtZXJnZUFycmF5KCQkLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IHYudmFsdWUpXHJcblx0XHRcdFx0LnJlZHVjZSgocCwgYykgPT4gcCArIGMpO1xyXG5cclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCB0b3RhbCA9IHN1bSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN1YnRyYWN0SGlkZGVuKSB7XHJcblx0XHRcdHRvdGFsIC09ICQkLmdldEhpZGRlblRvdGFsRGF0YVN1bSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0b3RhbDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdG90YWwgaGlkZGVuIGRhdGEgc3VtXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEhpZGRlblRvdGFsRGF0YVN1bSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHthcGksIHN0YXRlOiB7aGlkZGVuVGFyZ2V0SWRzfX0gPSAkJDtcclxuXHRcdGxldCB0b3RhbCA9IDA7XHJcblxyXG5cdFx0aWYgKGhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0dG90YWwgPSBhcGkuZGF0YS52YWx1ZXMuYmluZChhcGkpKGhpZGRlblRhcmdldElkcylcclxuXHRcdFx0XHQucmVkdWNlKChwLCBjKSA9PiBwICsgYyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRvdGFsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBmaWx0ZXJlZCBkYXRhIGJ5IHZhbHVlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YVxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBiZSBmaWx0ZXJlZFxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gZmlsdGVyZWQgYXJyYXkgZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RmlsdGVyZWREYXRhQnlWYWx1ZShkYXRhLCB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKHQgPT4gdGhpcy5nZXRCYXNlVmFsdWUodCkgPT09IHZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgdGhlIGRhdGFcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggZGF0YSBsZW5ndGhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldE1heERhdGFDb3VudCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLmxlbmd0aCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1heERhdGFDb3VudFRhcmdldCgpIHtcclxuXHRcdGxldCB0YXJnZXQgPSB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKSB8fCBbXTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKGxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0Lm1hcCh0ID0+IHQudmFsdWVzKVxyXG5cdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2LngpO1xyXG5cclxuXHRcdFx0dGFyZ2V0ID0gc29ydFZhbHVlKGdldFVuaXF1ZSh0YXJnZXQpKVxyXG5cdFx0XHRcdC5tYXAoKHgsIGluZGV4KSA9PiAoe3gsIGluZGV4fSkpO1xyXG5cdFx0fSBlbHNlIGlmIChsZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0WzBdLnZhbHVlcztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvSWRzKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0YXJnZXRzLm1hcChkID0+IGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvVGFyZ2V0SWRzKGlkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBpZHMgPyAoaXNBcnJheShpZHMpID8gaWRzLmNvbmNhdCgpIDogW2lkc10pIDogJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHR9LFxyXG5cclxuXHRoYXNUYXJnZXQodGFyZ2V0cywgaWQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyk7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHZhbDsgKHZhbCA9IGlkc1tpXSk7IGkrKykge1xyXG5cdFx0XHRpZiAodmFsID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGlzVGFyZ2V0VG9TaG93KHRhcmdldElkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGlzTGVnZW5kVG9TaG93KHRhcmdldElkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlclRhcmdldHNUb1Nob3codGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAodGFyZ2V0cyB8fCAkJC5kYXRhLnRhcmdldHMpLmZpbHRlcih0ID0+ICQkLmlzVGFyZ2V0VG9TaG93KHQuaWQpKTtcclxuXHR9LFxyXG5cclxuXHRtYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpc30gPSAkJDtcclxuXHRcdGxldCB4czogYW55W10gPSBbXTtcclxuXHJcblx0XHRpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR4cyA9IGdldFVuaXF1ZShcclxuXHRcdFx0XHRtZXJnZUFycmF5KHRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMubWFwKHYgPT4gK3YueCkpKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0eHMgPSBheGlzICYmIGF4aXMuaXNUaW1lU2VyaWVzKCkgPyB4cy5tYXAoeCA9PiBuZXcgRGF0ZSgreCkpIDogeHMubWFwKHggPT4gK3gpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzb3J0VmFsdWUoeHMpO1xyXG5cdH0sXHJcblxyXG5cdGFkZEhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUuaGlkZGVuVGFyZ2V0SWRzID0gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuY29uY2F0KHRhcmdldElkcyk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlSGlkZGVuVGFyZ2V0SWRzKHRhcmdldElkcyk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlblRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0fSxcclxuXHJcblx0YWRkSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcyk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcy5jb25jYXQodGFyZ2V0SWRzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcyA9IHRoaXMuc3RhdGUuaGlkZGVuTGVnZW5kSWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXN9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCB5cyA9IHt9O1xyXG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xyXG5cdFx0Y29uc3QgeHMgPSBpc011bHRpcGxlWCA/ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpXHJcblx0XHRcdC5tYXAodiA9PiAoaXNTdHJpbmcodikgPyB2IDogK3YpKSA6IG51bGw7XHJcblxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRjb25zdCBkYXRhOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYudmFsdWU7XHJcblxyXG5cdFx0XHRcdGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLnZhbHVlKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiBcImhpZ2hcIiBpbiB2YWx1ZSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLk9iamVjdC52YWx1ZXModmFsdWUpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlWlR5cGUodikpIHtcclxuXHRcdFx0XHRcdGRhdGEucHVzaChoYXNBeGlzICYmICQkLmdldEJ1YmJsZVpEYXRhKHZhbHVlLCBcInlcIikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcclxuXHRcdFx0XHRcdFx0ZGF0YVskJC5nZXRJbmRleEJ5WCh2LngsIHhzKV0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGRhdGEucHVzaCh2YWx1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHlzW3QuaWRdID0gZGF0YTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB5cztcclxuXHR9LFxyXG5cclxuXHRjaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIGNoZWNrZXI6IEZ1bmN0aW9uKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBpZHMgPSBPYmplY3Qua2V5cyh0YXJnZXRzKTtcclxuXHRcdGxldCB2YWx1ZXM7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFsdWVzID0gdGFyZ2V0c1tpZHNbaV1dLnZhbHVlcztcclxuXHJcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGNoZWNrZXIodmFsdWVzW2pdLnZhbHVlKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGhhc011bHRpVGFyZ2V0cygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKS5sZW5ndGggPiAxO1xyXG5cdH0sXHJcblxyXG5cdGhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCB2ID0+IHYgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRoYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgdiA9PiB2ID4gMCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrT3JkZXIodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy5kYXRhX29yZGVyO1xyXG5cclxuXHRcdHJldHVybiBpc1N0cmluZyhvcmRlcikgJiYgb3JkZXIudG9Mb3dlckNhc2UoKSA9PT0gdHlwZTtcclxuXHR9LFxyXG5cclxuXHRpc09yZGVyRGVzYygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl9jaGVja09yZGVyKFwiZGVzY1wiKTtcclxuXHR9LFxyXG5cclxuXHRpc09yZGVyQXNjKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrT3JkZXIoXCJhc2NcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCB0YXJnZXRzIGRhdGFcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRzVmFsdWUgVGFyZ2V0IHZhbHVlXHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b3JkZXJUYXJnZXRzKHRhcmdldHNWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSBbLi4udGFyZ2V0c1ZhbHVlXTtcclxuXHRcdGNvbnN0IG9yZGVyQXNjID0gJCQuaXNPcmRlckFzYygpO1xyXG5cdFx0Y29uc3Qgb3JkZXJEZXNjID0gJCQuaXNPcmRlckRlc2MoKTtcclxuXHJcblx0XHRpZiAob3JkZXJBc2MgfHwgb3JkZXJEZXNjKSB7XHJcblx0XHRcdHRhcmdldHMuc29ydCgodDEsIHQyKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgcmVkdWNlciA9IChwLCBjKSA9PiBwICsgTWF0aC5hYnMoYy52YWx1ZSk7XHJcblx0XHRcdFx0Y29uc3QgdDFTdW0gPSB0MS52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApO1xyXG5cdFx0XHRcdGNvbnN0IHQyU3VtID0gdDIudmFsdWVzLnJlZHVjZShyZWR1Y2VyLCAwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9yZGVyQXNjID8gdDJTdW0gLSB0MVN1bSA6IHQxU3VtIC0gdDJTdW07XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5kYXRhX29yZGVyKSkge1xyXG5cdFx0XHR0YXJnZXRzLnNvcnQoY29uZmlnLmRhdGFfb3JkZXIuYmluZCgkJC5hcGkpKTtcclxuXHRcdH0gLy8gVE9ETzogYWNjZXB0IG5hbWUgYXJyYXkgZm9yIG9yZGVyXHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0ZmlsdGVyQnlYKHRhcmdldHMsIHgpIHtcclxuXHRcdHJldHVybiBtZXJnZUFycmF5KHRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKS5maWx0ZXIodiA9PiB2LnggLSB4ID09PSAwKTtcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJSZW1vdmVOdWxsKGRhdGEpIHtcclxuXHRcdHJldHVybiBkYXRhLmZpbHRlcihkID0+IGlzVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoZCkpKTtcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJCeVhEb21haW4odGFyZ2V0cywgeERvbWFpbikge1xyXG5cdFx0cmV0dXJuIHRhcmdldHMubWFwKHQgPT4gKHtcclxuXHRcdFx0aWQ6IHQuaWQsXHJcblx0XHRcdGlkX29yZzogdC5pZF9vcmcsXHJcblx0XHRcdHZhbHVlczogdC52YWx1ZXMuZmlsdGVyKHYgPT4geERvbWFpblswXSA8PSB2LnggJiYgdi54IDw9IHhEb21haW5bMV0pXHJcblx0XHR9KSk7XHJcblx0fSxcclxuXHJcblx0aGFzRGF0YUxhYmVsKCkge1xyXG5cdFx0Y29uc3QgZGF0YUxhYmVscyA9IHRoaXMuY29uZmlnLmRhdGFfbGFiZWxzO1xyXG5cclxuXHRcdHJldHVybiAoaXNib29sZWFuKGRhdGFMYWJlbHMpICYmIGRhdGFMYWJlbHMpIHx8XHJcblx0XHRcdChpc09iamVjdFR5cGUoZGF0YUxhYmVscykgJiYgbm90RW1wdHkoZGF0YUxhYmVscykpO1xyXG5cdH0sXHJcblxyXG5cdGdldERhdGFMYWJlbExlbmd0aChtaW4sIG1heCwga2V5KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBsZW5ndGhzID0gWzAsIDBdO1xyXG5cdFx0Y29uc3QgcGFkZGluZ0NvZWYgPSAxLjM7XHJcblxyXG5cdFx0JCQuJGVsLmNoYXJ0LnNlbGVjdChcInN2Z1wiKS5zZWxlY3RBbGwoXCIuZHVtbXlcIilcclxuXHRcdFx0LmRhdGEoW21pbiwgbWF4XSlcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LnRleHQoZCA9PiAkJC5kYXRhTGFiZWxGb3JtYXQoZC5pZCkoZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRsZW5ndGhzW2ldID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtrZXldICogcGFkZGluZ0NvZWY7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRyZXR1cm4gbGVuZ3RocztcclxuXHR9LFxyXG5cclxuXHRpc05vbmVBcmMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRpc0FyYyhkKSB7XHJcblx0XHRyZXR1cm4gXCJkYXRhXCIgaW4gZCAmJiB0aGlzLmhhc1RhcmdldCh0aGlzLmRhdGEudGFyZ2V0cywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRmaW5kU2FtZVhPZlZhbHVlcyh2YWx1ZXMsIGluZGV4KSB7XHJcblx0XHRjb25zdCB0YXJnZXRYID0gdmFsdWVzW2luZGV4XS54O1xyXG5cdFx0Y29uc3Qgc2FtZXM6IGFueVtdID0gW107XHJcblx0XHRsZXQgaTtcclxuXHJcblx0XHRmb3IgKGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmICh0YXJnZXRYICE9PSB2YWx1ZXNbaV0ueCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzYW1lcy5wdXNoKHZhbHVlc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gaW5kZXg7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNhbWVzLnB1c2godmFsdWVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2FtZXM7XHJcblx0fSxcclxuXHJcblx0ZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4gJCQuZmluZENsb3Nlc3QodGFyZ2V0LnZhbHVlcywgcG9zKSk7IC8vIG1hcCB0byBhcnJheSBvZiBjbG9zZXN0IHBvaW50cyBvZiBlYWNoIHRhcmdldFxyXG5cclxuXHRcdC8vIGRlY2lkZSBjbG9zZXN0IHBvaW50IGFuZCByZXR1cm5cclxuXHRcdHJldHVybiAkJC5maW5kQ2xvc2VzdChjYW5kaWRhdGVzLCBwb3MpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRDbG9zZXN0KHZhbHVlcywgcG9zKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGEgPSB2YWx1ZXMuZmlsdGVyKHYgPT4gdiAmJiBpc1ZhbHVlKHYudmFsdWUpKTtcclxuXHRcdGxldCBtaW5EaXN0ID0gY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5O1xyXG5cdFx0bGV0IGNsb3Nlc3Q7XHJcblxyXG5cdFx0Ly8gZmluZCBtb3VzZW92ZXJpbmcgYmFyXHJcblx0XHRkYXRhXHJcblx0XHRcdC5maWx0ZXIodiA9PiAkJC5pc0JhclR5cGUodi5pZCkpXHJcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh2LmlkKX0gLiR7Q0xBU1MuYmFyfS0ke3YuaW5kZXh9YCkubm9kZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWNsb3Nlc3QgJiYgJCQuaXNXaXRoaW5CYXIoc2hhcGUpKSB7XHJcblx0XHRcdFx0XHRjbG9zZXN0ID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdC8vIGZpbmQgY2xvc2VzdCBwb2ludCBmcm9tIG5vbi1iYXJcclxuXHRcdGRhdGFcclxuXHRcdFx0LmZpbHRlcih2ID0+ICEkJC5pc0JhclR5cGUodi5pZCkpXHJcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGQgPSAkJC5kaXN0KHYsIHBvcyk7XHJcblxyXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdCkge1xyXG5cdFx0XHRcdFx0bWluRGlzdCA9IGQ7XHJcblx0XHRcdFx0XHRjbG9zZXN0ID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjbG9zZXN0O1xyXG5cdH0sXHJcblxyXG5cdGRpc3QoZGF0YSwgcG9zKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnOiB7YXhpc19yb3RhdGVkOiBpc1JvdGF0ZWR9LCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IHhJbmRleCA9IGlzUm90YXRlZCA/IDEgOiAwO1xyXG5cdFx0Y29uc3QgeUluZGV4ID0gaXNSb3RhdGVkID8gMCA6IDE7XHJcblx0XHRjb25zdCB5ID0gJCQuY2lyY2xlWShkYXRhLCBkYXRhLmluZGV4KTtcclxuXHRcdGNvbnN0IHggPSAoc2NhbGUuem9vbSB8fCBzY2FsZS54KShkYXRhLngpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeCAtIHBvc1t4SW5kZXhdLCAyKSArIE1hdGgucG93KHkgLSBwb3NbeUluZGV4XSwgMikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgZGF0YSBmb3Igc3RlcCB0eXBlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIE9iamVjdCBkYXRhIHZhbHVlc1xyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBzdGVwVHlwZSA9IGNvbmZpZy5saW5lX3N0ZXBfdHlwZTtcclxuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSBheGlzID8gYXhpcy5pc0NhdGVnb3JpemVkKCkgOiBmYWxzZTtcclxuXHJcblx0XHRjb25zdCBjb252ZXJ0ZWQgPSBpc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMuY29uY2F0KCkgOiBbdmFsdWVzXTtcclxuXHJcblx0XHRpZiAoIWlzUm90YXRlZCAmJiAhaXNDYXRlZ29yaXplZCkge1xyXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluc2VydCAmIGFwcGVuZCBjbG9uaW5nIGZpcnN0L2xhc3QgdmFsdWUgdG8gYmUgZnVsbHkgcmVuZGVyZWQgY292ZXJpbmcgb24gZWFjaCBnYXAgc2lkZXNcclxuXHRcdGNvbnN0IGlkID0gY29udmVydGVkWzBdLmlkO1xyXG5cclxuXHRcdC8vIGluc2VydFxyXG5cdFx0bGV0IHggPSBjb252ZXJ0ZWRbMF0ueCAtIDE7XHJcblx0XHRsZXQgdmFsdWUgPSBjb252ZXJ0ZWRbMF0udmFsdWU7XHJcblxyXG5cdFx0aXNDYXRlZ29yaXplZCAmJiBjb252ZXJ0ZWQudW5zaGlmdCh7eCwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0c3RlcFR5cGUgPT09IFwic3RlcC1hZnRlclwiICYmXHJcblx0XHRcdGNvbnZlcnRlZC51bnNoaWZ0KHt4OiB4IC0gMSwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0Ly8gYXBwZW5kXHJcblx0XHR4ID0gY29udmVydGVkLmxlbmd0aCAtIDE7XHJcblx0XHR2YWx1ZSA9IGNvbnZlcnRlZFt4XS52YWx1ZTtcclxuXHJcblx0XHRpc0NhdGVnb3JpemVkICYmIGNvbnZlcnRlZC5wdXNoKHt4LCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRzdGVwVHlwZSA9PT0gXCJzdGVwLWJlZm9yZVwiICYmXHJcblx0XHRcdGNvbnZlcnRlZC5wdXNoKHt4OiB4ICsgMSwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnZlcnRlZDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VmFsdWVzVG9SYW5nZSh2YWx1ZXMpIHtcclxuXHRcdGNvbnN0IGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdO1xyXG5cdFx0Y29uc3QgcmFuZ2VzOiB7eDogc3RyaW5nIHwgbnVtYmVyLCBpZDogc3RyaW5nLCB2YWx1ZTogbnVtYmVyfVtdID0gW107XHJcblxyXG5cdFx0Y29udmVydGVkLmZvckVhY2gocmFuZ2UgPT4ge1xyXG5cdFx0XHRjb25zdCB7eCwgaWR9ID0gcmFuZ2U7XHJcblxyXG5cdFx0XHRyYW5nZXMucHVzaCh7XHJcblx0XHRcdFx0eCxcclxuXHRcdFx0XHRpZCxcclxuXHRcdFx0XHR2YWx1ZTogcmFuZ2UudmFsdWVbMF1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyYW5nZXMucHVzaCh7XHJcblx0XHRcdFx0eCxcclxuXHRcdFx0XHRpZCxcclxuXHRcdFx0XHR2YWx1ZTogcmFuZ2UudmFsdWVbMl1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2VzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZURhdGFBdHRyaWJ1dGVzKG5hbWUsIGF0dHJzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgY3VycmVudCA9IGNvbmZpZ1tgZGF0YV8ke25hbWV9YF07XHJcblxyXG5cdFx0aWYgKGlzVW5kZWZpbmVkKGF0dHJzKSkge1xyXG5cdFx0XHRyZXR1cm4gY3VycmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGN1cnJlbnRbaWRdID0gYXR0cnNbaWRdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0JCQucmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QXJlYVJhbmdlRGF0YShkLCB0eXBlKSB7XHJcblx0XHRjb25zdCB2YWx1ZSA9IGQudmFsdWU7XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gW1wiaGlnaFwiLCBcIm1pZFwiLCBcImxvd1wiXS5pbmRleE9mKHR5cGUpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiB2YWx1ZVtpbmRleF07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlW3R5cGVdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCByYXRpbyB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFJhdGlvIGZvciBnaXZlbiB0eXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSB2YWx1ZSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFzUGVyY2VudCBDb252ZXJ0IHRoZSByZXR1cm4gYXMgcGVyY2VudCBvciBub3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSYXRpbyB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0UmF0aW8odHlwZSwgZCwgYXNQZXJjZW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGFwaSA9ICQkLmFwaTtcclxuXHRcdGxldCByYXRpbyA9IDA7XHJcblxyXG5cdFx0aWYgKGQgJiYgYXBpLmRhdGEuc2hvd24oKS5sZW5ndGgpIHtcclxuXHRcdFx0cmF0aW8gPSBkLnJhdGlvIHx8IGQudmFsdWU7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJhcmNcIikge1xyXG5cdFx0XHRcdC8vIGlmIGhhcyBwYWRBbmdsZSBzZXQsIGNhbGN1bGF0ZSByYXRlIGJhc2VkIG9uIHZhbHVlXHJcblx0XHRcdFx0aWYgKCQkLnBpZS5wYWRBbmdsZSgpKCkpIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gZC52YWx1ZSAvICQkLmdldFRvdGFsRGF0YVN1bSh0cnVlKTtcclxuXHJcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIGJhc2VkIG9uIHRoZSByZW5kZXJlZCBhbmdsZSB2YWx1ZVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyYXRpbyA9IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIChcclxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMSA6IDIpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImluZGV4XCIpIHtcclxuXHRcdFx0XHRjb25zdCBkYXRhVmFsdWVzID0gYXBpLmRhdGEudmFsdWVzLmJpbmQoYXBpKTtcclxuXHRcdFx0XHRsZXQgdG90YWwgPSB0aGlzLmdldFRvdGFsUGVySW5kZXgoKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGxldCBoaWRkZW5TdW0gPSBkYXRhVmFsdWVzKHN0YXRlLmhpZGRlblRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChoaWRkZW5TdW0ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGhpZGRlblN1bSA9IGhpZGRlblN1bVxyXG5cdFx0XHRcdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLm1hcCgodiwgaSkgPT4gKGlzTnVtYmVyKHYpID8gdiA6IDApICsgY3VycltpXSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0dG90YWwgPSB0b3RhbC5tYXAoKHYsIGkpID0+IHYgLSBoaWRkZW5TdW1baV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZC5yYXRpbyA9IGlzTnVtYmVyKGQudmFsdWUpICYmIHRvdGFsICYmIHRvdGFsW2QuaW5kZXhdID4gMCA/XHJcblx0XHRcdFx0XHRkLnZhbHVlIC8gdG90YWxbZC5pbmRleF0gOiAwO1xyXG5cclxuXHRcdFx0XHRyYXRpbyA9IGQucmF0aW87XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdFx0cmF0aW8gPSAoXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KFN0cmluZyhNYXRoLm1heChkLnZhbHVlLCAwKSkpIC8gc3RhdGUuY3VycmVudC5kYXRhTWF4XHJcblx0XHRcdFx0KSAqIGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFzUGVyY2VudCAmJiByYXRpbyA/IHJhdGlvICogMTAwIDogcmF0aW87XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCBkYXRhIGluZGV4IHRvIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGlja1ZhbHVlcyBUaWNrIGFycmF5IHZhbHVlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRGF0YUluZGV4QnlYKHRpY2tWYWx1ZXMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRjb25zdCB0aWNrVmFsdWVNYXAgPSB0aWNrVmFsdWVzLnJlZHVjZSgob3V0LCB0aWNrLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbTnVtYmVyKHRpY2sueCldID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gdGlja1ZhbHVlTWFwW051bWJlcih2YWx1ZS54KV07XHJcblxyXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRpbmRleCA9IHZhbHVlSW5kZXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhbHVlLmluZGV4ID0gaW5kZXg7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtlbmRhbGx9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGxvYWQocmF3VGFyZ2V0cywgYXJncyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHRhcmdldHMgPSByYXdUYXJnZXRzO1xyXG5cclxuXHRcdGlmICh0YXJnZXRzKSB7XHJcblx0XHRcdC8vIGZpbHRlciBsb2FkaW5nIHRhcmdldHMgaWYgbmVlZGVkXHJcblx0XHRcdGlmIChhcmdzLmZpbHRlcikge1xyXG5cdFx0XHRcdHRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcihhcmdzLmZpbHRlcik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNldCB0eXBlIGlmIGFyZ3MudHlwZXMgfHwgYXJncy50eXBlIHNwZWNpZmllZFxyXG5cdFx0XHRpZiAoYXJncy50eXBlIHx8IGFyZ3MudHlwZXMpIHtcclxuXHRcdFx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gKGFyZ3MudHlwZXMgJiYgYXJncy50eXBlc1t0LmlkXSkgfHwgYXJncy50eXBlO1xyXG5cclxuXHRcdFx0XHRcdCQkLnNldFRhcmdldFR5cGUodC5pZCwgdHlwZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFVwZGF0ZS9BZGQgZGF0YVxyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChkLmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XHJcblx0XHRcdFx0XHRcdGQudmFsdWVzID0gdGFyZ2V0c1tpXS52YWx1ZXM7XHJcblx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHQvLyBSZWRyYXcgd2l0aCBuZXcgdGFyZ2V0c1xyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBVcGRhdGUgY3VycmVudCBzdGF0ZSBjaGFydCB0eXBlIGFuZCBlbGVtZW50cyBsaXN0IGFmdGVyIHJlZHJhd1xyXG5cdFx0JCQudXBkYXRlVHlwZXNFbGVtZW50cygpO1xyXG5cclxuXHRcdGFyZ3MuZG9uZSAmJiBhcmdzLmRvbmUuY2FsbCgkJC5hcGkpO1xyXG5cdH0sXHJcblxyXG5cdGxvYWRGcm9tQXJncyhhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBsb2FkIHdoZW4gY2hhcnQgaXMgYWxyZWFkeSBkZXN0cm95ZWRcclxuXHRcdGlmICghJCQuY29uZmlnKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXNldCBpbnRlcm5hbGx5IGNhY2hlZCBkYXRhXHJcblx0XHQkJC5jYWNoZS5yZXNldCgpO1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBhcmdzLmRhdGEgfHwgJCQuY29udmVydERhdGEoYXJncywgZCA9PiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGQpLCBhcmdzKSk7XHJcblxyXG5cdFx0ZGF0YSAmJiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpLCBhcmdzKTtcclxuXHR9LFxyXG5cclxuXHR1bmxvYWQocmF3VGFyZ2V0SWRzLCBjdXN0b21Eb25lQ2IpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0bGV0IGRvbmUgPSBjdXN0b21Eb25lQ2I7XHJcblx0XHRsZXQgdGFyZ2V0SWRzID0gcmF3VGFyZ2V0SWRzO1xyXG5cclxuXHRcdC8vIHJlc2V0IGludGVybmFsbHkgY2FjaGVkIGRhdGFcclxuXHRcdCQkLmNhY2hlLnJlc2V0KCk7XHJcblxyXG5cdFx0aWYgKCFkb25lKSB7XHJcblx0XHRcdGRvbmUgPSAoKSA9PiB7fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaWx0ZXIgZXhpc3RpbmcgdGFyZ2V0XHJcblx0XHR0YXJnZXRJZHMgPSB0YXJnZXRJZHMuZmlsdGVyKGlkID0+ICQkLmhhc1RhcmdldCgkJC5kYXRhLnRhcmdldHMsIGlkKSk7XHJcblxyXG5cdFx0Ly8gSWYgbm8gdGFyZ2V0LCBjYWxsIGRvbmUgYW5kIHJldHVyblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMgfHwgdGFyZ2V0SWRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRkb25lKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuc3ZnLnNlbGVjdEFsbCh0YXJnZXRJZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkKSkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpXHJcblx0XHRcdC5jYWxsKGVuZGFsbCwgZG9uZSk7XHJcblxyXG5cdFx0dGFyZ2V0SWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHQvLyBSZXNldCBmYWRlaW4gZm9yIGZ1dHVyZSBsb2FkXHJcblx0XHRcdHN0YXRlLndpdGhvdXRGYWRlSW5baWRdID0gZmFsc2U7XHJcblxyXG5cdFx0XHQvLyBSZW1vdmUgdGFyZ2V0J3MgZWxlbWVudHNcclxuXHRcdFx0aWYgKCRlbC5sZWdlbmQpIHtcclxuXHRcdFx0XHQkZWwubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX0keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gKS5yZW1vdmUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIHRhcmdldFxyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHQgPT4gdC5pZCAhPT0gaWQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGN1cnJlbnQgc3RhdGUgY2hhcnQgdHlwZSBhbmQgZWxlbWVudHMgbGlzdCBhZnRlciByZWRyYXdcclxuXHRcdCQkLnVwZGF0ZVR5cGVzRWxlbWVudHMoKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkcmFnIGFzIGQzRHJhZ30gZnJvbSBcImQzLWRyYWdcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2VtdWxhdGVFdmVudCwgaXNOdW1iZXIsIGlzT2JqZWN0fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBIYW5kbGUgZGF0YS5vbm92ZXIvb3V0IGNhbGxiYWNrIG9wdGlvbnNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzT3ZlciBPdmVyIG9yIG5vdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfG9iamVjdH0gZCBkYXRhIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0T3Zlck91dChpc092ZXI6IGJvb2xlYW4sIGQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aGFzUmFkYXJ9LCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzQXJjID0gaXNPYmplY3QoZCk7XHJcblxyXG5cdFx0Ly8gQ2FsbCBldmVudCBoYW5kbGVyXHJcblx0XHRpZiAoaXNBcmMgfHwgZCAhPT0gLTEpIHtcclxuXHRcdFx0bGV0IGNhbGxiYWNrID0gY29uZmlnW2lzT3ZlciA/IFwiZGF0YV9vbm92ZXJcIiA6IFwiZGF0YV9vbm91dFwiXS5iaW5kKCQkLmFwaSk7XHJcblxyXG5cdFx0XHRjb25maWcuY29sb3Jfb25vdmVyICYmICQkLnNldE92ZXJDb2xvcihpc092ZXIsIGQsIGlzQXJjKTtcclxuXHJcblx0XHRcdGlmIChpc0FyYykge1xyXG5cdFx0XHRcdGNhbGxiYWNrKGQsIG1haW4uc2VsZWN0KGAuJHtDTEFTUy5hcmN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKS5ub2RlKCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0bGV0IGxhc3QgPSAkJC5jYWNoZS5nZXQoS0VZLnNldE92ZXJPdXQpIHx8IFtdO1xyXG5cclxuXHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7ZH1gKVxyXG5cdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHNoYXBlXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdGlmIChsYXN0Lmxlbmd0aCA9PT0gMCB8fCBsYXN0LmV2ZXJ5KHYgPT4gdiAhPT0gdGhpcykpIHtcclxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhkLCB0aGlzKTtcclxuXHRcdFx0XHRcdFx0XHRsYXN0LnB1c2godGhpcyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAobGFzdC5sZW5ndGggPiAwICYmIHNoYXBlLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gY29uZmlnLmRhdGFfb25vdXQuYmluZCgkJC5hcGkpO1xyXG5cclxuXHRcdFx0XHRcdGxhc3QuZm9yRWFjaCh2ID0+IGNhbGxiYWNrKGQzU2VsZWN0KHYpLmRhdHVtKCksIHYpKTtcclxuXHRcdFx0XHRcdGxhc3QgPSBbXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCQkLmNhY2hlLmFkZChLRVkuc2V0T3Zlck91dCwgbGFzdCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGlzT3Zlcikge1xyXG5cdFx0XHRcdFx0Y29uZmlnLnBvaW50X2ZvY3VzX29ubHkgJiYgaGFzUmFkYXIgP1xyXG5cdFx0XHRcdFx0XHQkJC5zaG93Q2lyY2xlRm9jdXMoJCQuZ2V0QWxsVmFsdWVzT25JbmRleChkLCB0cnVlKSkgOlxyXG5cdFx0XHRcdFx0XHQkJC5leHBhbmRDaXJjbGVzQmFycyhkLCBudWxsLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCEkJC5pc011bHRpcGxlWCgpICYmIG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBmb3IgdG91Y2ggZXZlbnRcclxuXHQgKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IGQgdGFyZ2V0IGluZGV4IG9yIGRhdGEgb2JqZWN0IGZvciBBcmMgdHlwZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsbE92ZXJPdXRGb3JUb3VjaChkKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBsYXN0ID0gJCQuY2FjaGUuZ2V0KEtFWS5jYWxsT3Zlck91dEZvclRvdWNoKTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoZCkgJiYgbGFzdCA/IGQuaWQgIT09IGxhc3QuaWQgOiAoZCAhPT0gbGFzdCkpIHtcclxuXHRcdFx0KGxhc3QgfHwgaXNOdW1iZXIobGFzdCkpICYmICQkLnNldE92ZXJPdXQoZmFsc2UsIGxhc3QpO1xyXG5cdFx0XHQoZCB8fCBpc051bWJlcihkKSkgJiYgJCQuc2V0T3Zlck91dCh0cnVlLCBkKTtcclxuXHJcblx0XHRcdCQkLmNhY2hlLmFkZChLRVkuY2FsbE92ZXJPdXRGb3JUb3VjaCwgZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGRyYWdnYWJsZSBzZWxlY3Rpb24gZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXREcmFnZ2FibGVTZWxlY3Rpb24oKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZSAmJiAkJC5kcmFnID9cclxuXHRcdFx0ZDNEcmFnKClcclxuXHRcdFx0XHQub24oXCJkcmFnXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0JCQuZHJhZyhkM01vdXNlKHRoaXMpKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0JCQuZHJhZ3N0YXJ0KGQzTW91c2UodGhpcykpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwiZW5kXCIsICgpID0+IHsgJCQuZHJhZ2VuZCgpOyB9KSA6ICgpID0+IHt9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoIGEgbW91c2UgZXZlbnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBldmVudCB0eXBlXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIGV2ZW50UmVjdFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZSB2YWx1ZVxyXG5cdCAqL1xyXG5cdGRpc3BhdGNoRXZlbnQodHlwZTogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBtb3VzZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7aGFzUmFkYXJ9LCAkZWw6IHttYWluLCByYWRhcn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc011bHRpcGxlWCA9ICQkLmlzTXVsdGlwbGVYKCk7XHJcblx0XHRjb25zdCBzZWxlY3RvciA9IGhhc1JhZGFyID8gYC4ke0NMQVNTLmF4aXN9LSR7aW5kZXh9IHRleHRgIDogYC4ke2lzTXVsdGlwbGVYID8gQ0xBU1MuZXZlbnRSZWN0IDogYCR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWB9YDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdCA9IChoYXNSYWRhciA/IHJhZGFyLmF4ZXMgOiBtYWluKS5zZWxlY3Qoc2VsZWN0b3IpLm5vZGUoKTtcclxuXHJcblx0XHRjb25zdCB7d2lkdGgsIGxlZnQsIHRvcH0gPSBldmVudFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHRjb25zdCB4ID0gbGVmdCArIChtb3VzZSA/IG1vdXNlWzBdIDogMCkgKyAoXHJcblx0XHRcdGlzTXVsdGlwbGVYIHx8ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogKHdpZHRoIC8gMilcclxuXHRcdCk7XHJcblx0XHRjb25zdCB5ID0gdG9wICsgKG1vdXNlID8gbW91c2VbMV0gOiAwKTtcclxuXHRcdGNvbnN0IHBhcmFtcyA9IHtcclxuXHRcdFx0c2NyZWVuWDogeCxcclxuXHRcdFx0c2NyZWVuWTogeSxcclxuXHRcdFx0Y2xpZW50WDogeCxcclxuXHRcdFx0Y2xpZW50WTogeVxyXG5cdFx0fTtcclxuXHJcblx0XHRlbXVsYXRlRXZlbnRbL14obW91c2V8Y2xpY2spLy50ZXN0KHR5cGUpID8gXCJtb3VzZVwiIDogXCJ0b3VjaFwiXShldmVudFJlY3QsIHR5cGUsIHBhcmFtcyk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZW5lcmF0ZUNsYXNzKHByZWZpeDogc3RyaW5nLCB0YXJnZXRJZDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgICR7cHJlZml4fSAke3ByZWZpeCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUZXh0KGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy50ZXh0LCBkLmluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc1RleHRzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy50ZXh0cywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NTaGFwZShkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGUsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzU2hhcGVzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zaGFwZXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MoKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2xhc3NlcyA9ICQkLmNvbmZpZy5saW5lX2NsYXNzZXMgfHwgW107XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0Y29uc3QgaWQ6IHN0cmluZyA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XHJcblxyXG5cdFx0XHRpZiAoaWRzLmluZGV4T2YoaWQpIDwgMCkge1xyXG5cdFx0XHRcdGlkcy5wdXNoKGlkKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNsYXNzZXNbaWRzLmluZGV4T2YoaWQpICUgY2xhc3Nlcy5sZW5ndGhdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0xpbmUoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmxpbmUsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzTGluZXMoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lcywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaXJjbGUoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZSwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaXJjbGVzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuY2lyY2xlcywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NCYXIoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmJhciwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NCYXJzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYmFycywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NBcmMoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQuZGF0YSkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJjLCBkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJjcyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQuZGF0YSkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJjcywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0FyZWEoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyZWEsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJlYXMoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmVhcywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NSZWdpb24oZCwgaTogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgJHt0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MucmVnaW9uLCBpKX0gJHtcImNsYXNzXCIgaW4gZCA/IGQuY2xhc3MgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NFdmVudChkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmV2ZW50UmVjdCwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUYXJnZXQoaWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBhZGRpdGlvbmFsQ2xhc3NTdWZmaXggPSB0aGlzLmNvbmZpZy5kYXRhX2NsYXNzZXNbaWRdO1xyXG5cdFx0bGV0IGFkZGl0aW9uYWxDbGFzcyA9IFwiXCI7XHJcblxyXG5cdFx0aWYgKGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCkge1xyXG5cdFx0XHRhZGRpdGlvbmFsQ2xhc3MgPSBgICR7Q0xBU1MudGFyZ2V0fS0ke2FkZGl0aW9uYWxDbGFzc1N1ZmZpeH1gO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGFyZ2V0LCBpZCkgKyBhZGRpdGlvbmFsQ2xhc3M7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NGb2N1cyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzRm9jdXNlZChkKSArIHRoaXMuY2xhc3NEZWZvY3VzZWQoZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NGb2N1c2VkKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGAgJHt0aGlzLnN0YXRlLmZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gQ0xBU1MuZm9jdXNlZCA6IFwiXCJ9YDtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0RlZm9jdXNlZChkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgICR7dGhpcy5zdGF0ZS5kZWZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gQ0xBU1MuZGVmb2N1c2VkIDogXCJcIn1gO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRUZXh0KGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0VGV4dCArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydExpbmUoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRMaW5lICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NoYXJ0QmFyKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QmFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NoYXJ0QXJjKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QXJjICsgdGhpcy5jbGFzc1RhcmdldChkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRSYWRhcihkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBDTEFTUy5jaGFydFJhZGFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0YXJnZXRJZD86IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0SWQgfHwgdGFyZ2V0SWQgPT09IDAgP1xyXG5cdFx0XHRgLSR7dGFyZ2V0SWR9YC5yZXBsYWNlKC9bXFxzPyFAIyQlXiYqKClfPSssLjw+J1wiOjtcXFtcXF1cXC98fmB7fVxcXFxdL2csIFwiLVwiKSA6IFwiXCI7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JUYXJnZXQoaWQ6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0IHBmeCA9IHByZWZpeCB8fCBcIlwiO1xyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCk7XHJcblxyXG5cdFx0Ly8gc2VsZWN0IHRhcmdldCAmIGNpcmNsZVxyXG5cdFx0cmV0dXJuIGAke3BmeH0uJHtDTEFTUy50YXJnZXQgKyB0YXJnZXR9LCAke3BmeH0uJHtDTEFTUy5jaXJjbGVzICsgdGFyZ2V0fWA7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JUYXJnZXRzKGlkc1ZhbHVlLCBwcmVmaXg6IHN0cmluZyk6IHN0cmluZ1tdIHwgbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpZHMgPSBpZHNWYWx1ZSB8fCBbXTtcclxuXHJcblx0XHRyZXR1cm4gaWRzLmxlbmd0aCA/XHJcblx0XHRcdGlkcy5tYXAoaWQgPT4gJCQuc2VsZWN0b3JUYXJnZXQoaWQsIHByZWZpeCkpIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RvckxlZ2VuZChpZDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgLiR7Q0xBU1MubGVnZW5kSXRlbSArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWA7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JMZWdlbmRzKGlkcyk6IHN0cmluZ1tdIHwgbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGlkcyAmJiBpZHMubGVuZ3RoID9cclxuXHRcdFx0aWRzLm1hcChpZCA9PiAkJC5zZWxlY3RvckxlZ2VuZChpZCkpIDogbnVsbDtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBDYXRlZ29yeSBOYW1lXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgSW5kZXggbnVtYmVyXHJcblx0ICogQHJldHVybnMge3N0cmluZ30gY2F0ZWdvcnkgTmFtZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2F0ZWdvcnlOYW1lKGk6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRjb25zdCB7YXhpc194X2NhdGVnb3JpZXM6IGNhdGVnb3JpZXN9ID0gdGhpcy5jb25maWc7XHJcblxyXG5cdFx0cmV0dXJuIGkgPCBjYXRlZ29yaWVzLmxlbmd0aCA/IGNhdGVnb3JpZXNbaV0gOiBpO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtzY2FsZU9yZGluYWwgYXMgZDNTY2FsZU9yZGluYWx9IGZyb20gXCJkMy1zY2FsZVwiO1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7S0VZfSBmcm9tIFwiLi4vLi4vbW9kdWxlL0NhY2hlXCI7XHJcbmltcG9ydCB7bm90RW1wdHksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogU2V0IHBhdHRlcm4ncyBiYWNrZ3JvdW5kIGNvbG9yXHJcbiAqIChpdCBhZGRzIGEgPHJlY3Q+IGVsZW1lbnQgdG8gc2ltdWxhdGUgYmctY29sb3IpXHJcbiAqIEBwYXJhbSB7U1ZHUGF0dGVybkVsZW1lbnR9IHBhdHRlcm4gU1ZHIHBhdHRlcm4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgQ29sb3Igc3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCB0byBiZSBzZXRcclxuICogQHJldHVybnMge3tpZDogc3RyaW5nLCBub2RlOiBTVkdQYXR0ZXJuRWxlbWVudH19XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjb2xvcml6ZVBhdHRlcm4gPSAocGF0dGVybiwgY29sb3IsIGlkOiBzdHJpbmcpID0+IHtcclxuXHRjb25zdCBub2RlID0gZDNTZWxlY3QocGF0dGVybi5jbG9uZU5vZGUodHJ1ZSkpO1xyXG5cclxuXHRub2RlXHJcblx0XHQuYXR0cihcImlkXCIsIGlkKVxyXG5cdFx0Lmluc2VydChcInJlY3RcIiwgXCI6Zmlyc3QtY2hpbGRcIilcclxuXHRcdC5hdHRyKFwid2lkdGhcIiwgbm9kZS5hdHRyKFwid2lkdGhcIikpXHJcblx0XHQuYXR0cihcImhlaWdodFwiLCBub2RlLmF0dHIoXCJoZWlnaHRcIikpXHJcblx0XHQuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGlkLFxyXG5cdFx0bm9kZTogbm9kZS5ub2RlKClcclxuXHR9O1xyXG59O1xyXG5cclxuLy8gUmVwbGFjZW1lbnQgb2YgZDMuc2NoZW1lQ2F0ZWdvcnkxMC5cclxuLy8gQ29udGFpbmVkIGRpZmZlcmVudGx5IGRlcGVuZCBvbiBkMyB2ZXJzaW9uOiB2NChkMy1zY2FsZSksIHY1KGQzLXNjYWxlLWNocm9tYXRpYylcclxuY29uc3Qgc2NoZW1lQ2F0ZWdvcnkxMCA9IFtcIiMxZjc3YjRcIiwgXCIjZmY3ZjBlXCIsIFwiIzJjYTAyY1wiLCBcIiNkNjI3MjhcIiwgXCIjOTQ2N2JkXCIsIFwiIzhjNTY0YlwiLCBcIiNlMzc3YzJcIiwgXCIjN2Y3ZjdmXCIsIFwiI2JjYmQyMlwiLCBcIiMxN2JlY2ZcIl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGNvbG9yIHBhdHRlcm4gZnJvbSBDU1MgZmlsZVxyXG5cdCAqIENTUyBzaG91bGQgYmUgZGVmaW5lZCBhczogYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiIzAwYzczYzsjZmE3MTcxOyAuLi5cIik7XHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q29sb3JGcm9tQ3NzKCk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gS0VZLmNvbG9yUGF0dGVybjtcclxuXHRcdGNvbnN0IHtib2R5fSA9IGRvY3VtZW50O1xyXG5cdFx0bGV0IHBhdHRlcm4gPSBib2R5W2NhY2hlS2V5XTtcclxuXHJcblx0XHRpZiAoIXBhdHRlcm4pIHtcclxuXHRcdFx0Y29uc3QgZGVsaW1pdGVyID0gXCI7XCI7XHJcblx0XHRcdGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuXHJcblx0XHRcdHNwYW4uY2xhc3NOYW1lID0gQ0xBU1MuY29sb3JQYXR0ZXJuO1xyXG5cdFx0XHRzcGFuLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuXHRcdFx0Ym9keS5hcHBlbmRDaGlsZChzcGFuKTtcclxuXHJcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5iYWNrZ3JvdW5kSW1hZ2U7XHJcblxyXG5cdFx0XHRzcGFuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3Bhbik7XHJcblxyXG5cdFx0XHRpZiAoY29udGVudC5pbmRleE9mKGRlbGltaXRlcikgPiAtMSkge1xyXG5cdFx0XHRcdHBhdHRlcm4gPSBjb250ZW50XHJcblx0XHRcdFx0XHQucmVwbGFjZSgvdXJsW14jXSp8W1wiJygpXXwoXFxzfCUyMCkvZywgXCJcIilcclxuXHRcdFx0XHRcdC5zcGxpdChkZWxpbWl0ZXIpXHJcblx0XHRcdFx0XHQubWFwKHYgPT4gdi50cmltKCkucmVwbGFjZSgvW1xcXCInXFxzXS9nLCBcIlwiKSlcclxuXHRcdFx0XHRcdC5maWx0ZXIoQm9vbGVhbik7XHJcblxyXG5cdFx0XHRcdGJvZHlbY2FjaGVLZXldID0gcGF0dGVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXR0ZXJuO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlQ29sb3IoKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5kYXRhX2NvbG9ycztcclxuXHRcdGNvbnN0IGNhbGxiYWNrID0gY29uZmlnLmRhdGFfY29sb3I7XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0bGV0IHBhdHRlcm4gPSBub3RFbXB0eShjb25maWcuY29sb3JfcGF0dGVybikgPyBjb25maWcuY29sb3JfcGF0dGVybiA6XHJcblx0XHRcdGQzU2NhbGVPcmRpbmFsKCQkLmdldENvbG9yRnJvbUNzcygpIHx8IHNjaGVtZUNhdGVnb3J5MTApLnJhbmdlKCk7XHJcblxyXG5cdFx0Y29uc3Qgb3JpZ2luYWxDb2xvclBhdHRlcm4gPSBwYXR0ZXJuO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5jb2xvcl90aWxlcykpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBjb25maWcuY29sb3JfdGlsZXMuYmluZCgkJC5hcGkpKCk7XHJcblxyXG5cdFx0XHQvLyBBZGQgYmFja2dyb3VuZCBjb2xvciB0byBwYXR0ZXJuc1xyXG5cdFx0XHRjb25zdCBjb2xvcml6ZWRQYXR0ZXJucyA9IHBhdHRlcm4ubWFwKChwLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gcC5yZXBsYWNlKC9bI1xcKFxcKVxccyxdL2csIFwiXCIpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gYCR7JCQuc3RhdGUuZGF0ZXRpbWVJZH0tcGF0dGVybi0ke2NvbG9yfS0ke2luZGV4fWA7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjb2xvcml6ZVBhdHRlcm4odGlsZXNbaW5kZXggJSB0aWxlcy5sZW5ndGhdLCBwLCBpZCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cGF0dGVybiA9IGNvbG9yaXplZFBhdHRlcm5zLm1hcChwID0+IGB1cmwoIyR7cC5pZH0pYCk7XHJcblx0XHRcdCQkLnBhdHRlcm5zID0gY29sb3JpemVkUGF0dGVybnM7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0Y29uc3QgaWQ6IHN0cmluZyA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XHJcblx0XHRcdGNvbnN0IGlzTGluZSA9ICQkLmlzVHlwZU9mKGlkLCBbXCJsaW5lXCIsIFwic3BsaW5lXCIsIFwic3RlcFwiXSkgfHwgIWNvbmZpZy5kYXRhX3R5cGVzW2lkXTtcclxuXHRcdFx0bGV0IGNvbG9yO1xyXG5cclxuXHRcdFx0Ly8gaWYgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWRcclxuXHRcdFx0aWYgKGlzRnVuY3Rpb24oY29sb3JzW2lkXSkpIHtcclxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpZF0uYmluZCgkJC5hcGkpKGQpO1xyXG5cclxuXHRcdFx0Ly8gaWYgc3BlY2lmaWVkLCBjaG9vc2UgdGhhdCBjb2xvclxyXG5cdFx0XHR9IGVsc2UgaWYgKGNvbG9yc1tpZF0pIHtcclxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpZF07XHJcblxyXG5cdFx0XHQvLyBpZiBub3Qgc3BlY2lmaWVkLCBjaG9vc2UgZnJvbSBwYXR0ZXJuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcclxuXHRcdFx0XHRcdGlkcy5wdXNoKGlkKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gaXNMaW5lID8gb3JpZ2luYWxDb2xvclBhdHRlcm5baWRzLmluZGV4T2YoaWQpICUgb3JpZ2luYWxDb2xvclBhdHRlcm4ubGVuZ3RoXSA6XHJcblx0XHRcdFx0XHRwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcclxuXHJcblx0XHRcdFx0Y29sb3JzW2lkXSA9IGNvbG9yO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gaXNGdW5jdGlvbihjYWxsYmFjaykgP1xyXG5cdFx0XHRcdGNhbGxiYWNrLmJpbmQoJCQuYXBpKShjb2xvciwgZCkgOiBjb2xvcjtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVMZXZlbENvbG9yKCk6IEZ1bmN0aW9uIHwgbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgY29sb3JzID0gY29uZmlnLmNvbG9yX3BhdHRlcm47XHJcblx0XHRjb25zdCB0aHJlc2hvbGQgPSBjb25maWcuY29sb3JfdGhyZXNob2xkO1xyXG5cdFx0Y29uc3QgYXNWYWx1ZSA9IHRocmVzaG9sZC51bml0ID09PSBcInZhbHVlXCI7XHJcblx0XHRjb25zdCBtYXggPSB0aHJlc2hvbGQubWF4IHx8IDEwMDtcclxuXHRcdGNvbnN0IHZhbHVlcyA9IHRocmVzaG9sZC52YWx1ZXMgJiZcclxuXHRcdFx0dGhyZXNob2xkLnZhbHVlcy5sZW5ndGggPyB0aHJlc2hvbGQudmFsdWVzIDogW107XHJcblxyXG5cdFx0cmV0dXJuIG5vdEVtcHR5KHRocmVzaG9sZCkgPyBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRjb25zdCB2ID0gYXNWYWx1ZSA/IHZhbHVlIDogKHZhbHVlICogMTAwIC8gbWF4KTtcclxuXHRcdFx0bGV0IGNvbG9yID0gY29sb3JzW2NvbG9ycy5sZW5ndGggLSAxXTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRcdGlmICh2IDw9IHZhbHVlc1tpXSkge1xyXG5cdFx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaV07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjb2xvcjtcclxuXHRcdH0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgZGF0YSBvdmVyIGNvbG9yLlxyXG5cdCAqIFdoZW4gaXMgb3V0LCB3aWxsIHJlc3RhdGUgaW4gaXRzIHByZXZpb3VzIGNvbG9yIHZhbHVlXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc092ZXIgdHJ1ZTogc2V0IG92ZXJlZCBjb2xvciwgZmFsc2U6IHJlc3RvcmVcclxuXHQgKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IGQgdGFyZ2V0IGluZGV4IG9yIGRhdGEgb2JqZWN0IGZvciBBcmMgdHlwZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0T3ZlckNvbG9yKGlzT3ZlcjogYm9vbGVhbiwgZCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBvbm92ZXIgPSBjb25maWcuY29sb3Jfb25vdmVyO1xyXG5cdFx0bGV0IGNvbG9yID0gaXNPdmVyID8gb25vdmVyIDogJCQuY29sb3I7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KGNvbG9yKSkge1xyXG5cdFx0XHRjb2xvciA9ICh7aWR9KSA9PiAoaWQgaW4gb25vdmVyID8gb25vdmVyW2lkXSA6ICQkLmNvbG9yKGlkKSk7XHJcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGNvbG9yKSkge1xyXG5cdFx0XHRjb2xvciA9ICgpID0+IG9ub3ZlcjtcclxuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvbm92ZXIpKSB7XHJcblx0XHRcdGNvbG9yID0gY29sb3IuYmluZCgkJC5hcGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdoZW4gaXMgQXJjIHR5cGVcclxuXHRcdGlmIChpc09iamVjdChkKSkge1xyXG5cdFx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKGQpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBDaGFydCB0eXBlIGNvbnN0YW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVFlQRSA9IHtcclxuXHRBUkVBOiBcImFyZWFcIixcclxuXHRBUkVBX0xJTkVfUkFOR0U6IFwiYXJlYS1saW5lLXJhbmdlXCIsXHJcblx0QVJFQV9TUExJTkU6IFwiYXJlYS1zcGxpbmVcIixcclxuXHRBUkVBX1NQTElORV9SQU5HRTogXCJhcmVhLXNwbGluZS1yYW5nZVwiLFxyXG5cdEFSRUFfU1RFUDogXCJhcmVhLXN0ZXBcIixcclxuXHRCQVI6IFwiYmFyXCIsXHJcblx0QlVCQkxFOiBcImJ1YmJsZVwiLFxyXG5cdERPTlVUOiBcImRvbnV0XCIsXHJcblx0R0FVR0U6IFwiZ2F1Z2VcIixcclxuXHRMSU5FOiBcImxpbmVcIixcclxuXHRQSUU6IFwicGllXCIsXHJcblx0UkFEQVI6IFwicmFkYXJcIixcclxuXHRTQ0FUVEVSOiBcInNjYXR0ZXJcIixcclxuXHRTUExJTkU6IFwic3BsaW5lXCIsXHJcblx0U1RFUDogXCJzdGVwXCJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBjaGFydCB0eXBlcyBieSBjYXRlZ29yeVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRZUEVfQllfQ0FURUdPUlkgPSB7XHJcblx0QXJlYTogW1xyXG5cdFx0VFlQRS5BUkVBLFxyXG5cdFx0VFlQRS5BUkVBX1NQTElORSxcclxuXHRcdFRZUEUuQVJFQV9TUExJTkVfUkFOR0UsXHJcblx0XHRUWVBFLkFSRUFfTElORV9SQU5HRSxcclxuXHRcdFRZUEUuQVJFQV9TVEVQXHJcblx0XSxcclxuXHRBcmVhUmFuZ2U6IFtcclxuXHRcdFRZUEUuQVJFQV9TUExJTkVfUkFOR0UsXHJcblx0XHRUWVBFLkFSRUFfTElORV9SQU5HRVxyXG5cdF0sXHJcblx0QXJjOiBbXHJcblx0XHRUWVBFLlBJRSxcclxuXHRcdFRZUEUuRE9OVVQsXHJcblx0XHRUWVBFLkdBVUdFLFxyXG5cdFx0VFlQRS5SQURBUlxyXG5cdF0sXHJcblx0TGluZTogW1xyXG5cdFx0VFlQRS5MSU5FLFxyXG5cdFx0VFlQRS5TUExJTkUsXHJcblx0XHRUWVBFLkFSRUEsXHJcblx0XHRUWVBFLkFSRUFfU1BMSU5FLFxyXG5cdFx0VFlQRS5BUkVBX1NQTElORV9SQU5HRSxcclxuXHRcdFRZUEUuQVJFQV9MSU5FX1JBTkdFLFxyXG5cdFx0VFlQRS5TVEVQLFxyXG5cdFx0VFlQRS5BUkVBX1NURVBcclxuXHRdLFxyXG5cdFN0ZXA6IFtcclxuXHRcdFRZUEUuU1RFUCxcclxuXHRcdFRZUEUuQVJFQV9TVEVQXHJcblx0XSxcclxuXHRTcGxpbmU6IFtcclxuXHRcdFRZUEUuU1BMSU5FLFxyXG5cdFx0VFlQRS5BUkVBX1NQTElORSxcclxuXHRcdFRZUEUuQVJFQV9TUExJTkVfUkFOR0VcclxuXHRdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtUWVBFLCBUWVBFX0JZX0NBVEVHT1JZfSBmcm9tIFwiLi4vLi4vY29uZmlnL2NvbnN0XCI7XHJcbmltcG9ydCB7YnJ1c2hFbXB0eSwgZ2V0QnJ1c2hTZWxlY3Rpb24sIGdldE1pbk1heCwgaXNEZWZpbmVkLCBub3RFbXB0eSwgaXNWYWx1ZSwgaXNPYmplY3QsIGlzTnVtYmVyLCBkaWZmRG9tYWluLCBwYXJzZURhdGUsIHNvcnRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIik6IG51bWJlciB8IERhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzTWluID0gdHlwZSA9PT0gXCJtaW5cIjtcclxuXHJcblx0XHRjb25zdCBkYXRhR3JvdXBzID0gY29uZmlnLmRhdGFfZ3JvdXBzO1xyXG5cdFx0Y29uc3QgaWRzID0gJCQubWFwVG9JZHModGFyZ2V0cyk7XHJcblx0XHRjb25zdCB5cyA9ICQkLmdldFZhbHVlc0FzSWRLZXllZCh0YXJnZXRzKTtcclxuXHJcblx0XHRpZiAoZGF0YUdyb3Vwcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdGNvbnN0IGhhc1ZhbHVlID0gJCRbYGhhcyR7aXNNaW4gPyBcIk5lZ2F0aXZlXCIgOiBcIlBvc2l0aXZlXCJ9VmFsdWVJblRhcmdldHNgXSh0YXJnZXRzKTtcclxuXHJcblx0XHRcdGZvciAobGV0IGogPSAwLCBpZHNJbkdyb3VwOyAoaWRzSW5Hcm91cCA9IGRhdGFHcm91cHNbal0pOyBqKyspIHtcclxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgYmFzZUlkXHJcblx0XHRcdFx0aWRzSW5Hcm91cCA9IGlkc0luR3JvdXAuZmlsdGVyKHYgPT4gaWRzLmluZGV4T2YodikgPj0gMCk7XHJcblxyXG5cdFx0XHRcdGlmIChpZHNJbkdyb3VwLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBiYXNlSWQgPSBpZHNJbkdyb3VwWzBdO1xyXG5cdFx0XHRcdGNvbnN0IGJhc2VBeGlzSWQgPSBheGlzLmdldElkKGJhc2VJZCk7XHJcblxyXG5cdFx0XHRcdC8vIEluaXRpYWxpemUgYmFzZSB2YWx1ZS4gU2V0IHRvIDAgaWYgbm90IG1hdGNoIHdpdGggdGhlIGNvbmRpdGlvblxyXG5cdFx0XHRcdGlmIChoYXNWYWx1ZSAmJiB5c1tiYXNlSWRdKSB7XHJcblx0XHRcdFx0XHR5c1tiYXNlSWRdID0geXNbYmFzZUlkXS5tYXAodiA9PiAoXHJcblx0XHRcdFx0XHRcdChpc01pbiA/IHYgPCAwIDogdiA+IDApID8gdiA6IDBcclxuXHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgayA9IDEsIGlkOyAoaWQgPSBpZHNJbkdyb3VwW2tdKTsgaysrKSB7XHJcblx0XHRcdFx0XHRpZiAoIXlzW2lkXSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCBheGlzSWQgPSBheGlzLmdldElkKGlkKTtcclxuXHJcblx0XHRcdFx0XHR5c1tpZF0uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zdCB2YWwgPSArdjtcclxuXHRcdFx0XHRcdFx0Y29uc3QgbWVldENvbmRpdGlvbiA9IGlzTWluID8gdmFsID4gMCA6IHZhbCA8IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoYXhpc0lkID09PSBiYXNlQXhpc0lkICYmICEoaGFzVmFsdWUgJiYgbWVldENvbmRpdGlvbikpIHtcclxuXHRcdFx0XHRcdFx0XHR5c1tiYXNlSWRdW2ldICs9IHZhbDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldE1pbk1heCh0eXBlLCBPYmplY3Qua2V5cyh5cykubWFwKGtleSA9PiBnZXRNaW5NYXgodHlwZSwgeXNba2V5XSkpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluTWluKHRhcmdldHMpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1pblwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluTWF4KHRhcmdldHMpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1heFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiBoaWRkZW4gdGFyZ2V0cyBib3VuZCB0byB0aGUgZ2l2ZW4gYXhpcyBpZFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCB0byBiZSBjaGVja2VkXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpc0hpZGRlblRhcmdldFdpdGhZRG9tYWluKGlkKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLnN0YXRlLmhpZGRlblRhcmdldElkc1xyXG5cdFx0XHQuc29tZSh2ID0+ICQkLmF4aXMuZ2V0SWQodikgPT09IGlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluKHRhcmdldHMsIGF4aXNJZDogc3RyaW5nLCB4RG9tYWluKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IHBmeCA9IGBheGlzXyR7YXhpc0lkfWA7XHJcblxyXG5cdFx0aWYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIFswLCAxMDBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRhcmdldHNCeUF4aXNJZCA9IHRhcmdldHMuZmlsdGVyKHQgPT4gYXhpcy5nZXRJZCh0LmlkKSA9PT0gYXhpc0lkKTtcclxuXHRcdGNvbnN0IHlUYXJnZXRzID0geERvbWFpbiA/ICQkLmZpbHRlckJ5WERvbWFpbih0YXJnZXRzQnlBeGlzSWQsIHhEb21haW4pIDogdGFyZ2V0c0J5QXhpc0lkO1xyXG5cclxuXHRcdGlmICh5VGFyZ2V0cy5sZW5ndGggPT09IDApIHsgLy8gdXNlIGRvbWFpbiBvZiB0aGUgb3RoZXIgYXhpcyBpZiB0YXJnZXQgb2YgYXhpc0lkIGlzIG5vbmVcclxuXHRcdFx0aWYgKCQkLmlzSGlkZGVuVGFyZ2V0V2l0aFlEb21haW4oYXhpc0lkKSkge1xyXG5cdFx0XHRcdHJldHVybiBzY2FsZVtheGlzSWRdLmRvbWFpbigpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBheGlzSWQgPT09IFwieTJcIiA/XHJcblx0XHRcdFx0XHRzY2FsZS55LmRvbWFpbigpIDpcclxuXHRcdFx0XHRcdC8vIFdoZW4gYWxsIGRhdGEgYm91bmRzIHRvIHkyLCB5IEF4aXMgZG9tYWluIGlzIGNhbGxlZCBwcmlvciB5Mi5cclxuXHRcdFx0XHRcdC8vIFNvLCBpdCBuZWVkcyB0byBjYWxsIHRvIGdldCB5MiBkb21haW4gaGVyZVxyXG5cdFx0XHRcdFx0JCQuZ2V0WURvbWFpbih0YXJnZXRzLCBcInkyXCIsIHhEb21haW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeU1pbiA9IGNvbmZpZ1tgJHtwZnh9X21pbmBdO1xyXG5cdFx0Y29uc3QgeU1heCA9IGNvbmZpZ1tgJHtwZnh9X21heGBdO1xyXG5cdFx0bGV0IHlEb21haW5NaW4gPSAkJC5nZXRZRG9tYWluTWluKHlUYXJnZXRzKTtcclxuXHRcdGxldCB5RG9tYWluTWF4ID0gJCQuZ2V0WURvbWFpbk1heCh5VGFyZ2V0cyk7XHJcblxyXG5cdFx0Y29uc3QgY2VudGVyID0gY29uZmlnW2Ake3BmeH1fY2VudGVyYF07XHJcblx0XHRsZXQgaXNaZXJvQmFzZWQgPSBbVFlQRS5CQVIsIFRZUEUuQlVCQkxFLCBUWVBFLlNDQVRURVIsIC4uLlRZUEVfQllfQ0FURUdPUlkuTGluZV1cclxuXHRcdFx0LnNvbWUodiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHYuaW5kZXhPZihcImFyZWFcIikgPiAtMSA/IFwiYXJlYVwiIDogdjtcclxuXHJcblx0XHRcdFx0cmV0dXJuICQkLmhhc1R5cGUodiwgeVRhcmdldHMpICYmIGNvbmZpZ1tgJHt0eXBlfV96ZXJvYmFzZWRgXTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgaXNJbnZlcnRlZCA9IGNvbmZpZ1tgJHtwZnh9X2ludmVydGVkYF07XHJcblx0XHRjb25zdCBzaG93SG9yaXpvbnRhbERhdGFMYWJlbCA9ICQkLmhhc0RhdGFMYWJlbCgpICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBzaG93VmVydGljYWxEYXRhTGFiZWwgPSAkJC5oYXNEYXRhTGFiZWwoKSAmJiAhY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBNRU1POiBhdm9pZCBpbnZlcnRpbmcgZG9tYWluIHVuZXhwZWN0ZWRseVxyXG5cdFx0eURvbWFpbk1pbiA9IGlzVmFsdWUoeU1pbikgPyB5TWluIDpcclxuXHRcdFx0KGlzVmFsdWUoeU1heCkgPyAoeURvbWFpbk1pbiA8IHlNYXggPyB5RG9tYWluTWluIDogeU1heCAtIDEwKSA6IHlEb21haW5NaW4pO1xyXG5cdFx0eURvbWFpbk1heCA9IGlzVmFsdWUoeU1heCkgPyB5TWF4IDpcclxuXHRcdFx0KGlzVmFsdWUoeU1pbikgPyAoeU1pbiA8IHlEb21haW5NYXggPyB5RG9tYWluTWF4IDogeU1pbiArIDEwKSA6IHlEb21haW5NYXgpO1xyXG5cclxuXHRcdGlmIChpc05hTih5RG9tYWluTWluKSkgeyAvLyBzZXQgbWluaW11bSB0byB6ZXJvIHdoZW4gbm90IG51bWJlclxyXG5cdFx0XHR5RG9tYWluTWluID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNOYU4oeURvbWFpbk1heCkpIHsgLy8gc2V0IG1heGltdW0gdG8gaGF2ZSBzYW1lIHZhbHVlIGFzIHlEb21haW5NaW5cclxuXHRcdFx0eURvbWFpbk1heCA9IHlEb21haW5NaW47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHlEb21haW5NaW4gPT09IHlEb21haW5NYXgpIHtcclxuXHRcdFx0eURvbWFpbk1pbiA8IDAgPyB5RG9tYWluTWF4ID0gMCA6IHlEb21haW5NaW4gPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzQWxsUG9zaXRpdmUgPSB5RG9tYWluTWluID49IDAgJiYgeURvbWFpbk1heCA+PSAwO1xyXG5cdFx0Y29uc3QgaXNBbGxOZWdhdGl2ZSA9IHlEb21haW5NaW4gPD0gMCAmJiB5RG9tYWluTWF4IDw9IDA7XHJcblxyXG5cdFx0Ly8gQ2FuY2VsIHplcm9iYXNlZCBpZiBheGlzXypfbWluIC8gYXhpc18qX21heCBzcGVjaWZpZWRcclxuXHRcdGlmICgoaXNWYWx1ZSh5TWluKSAmJiBpc0FsbFBvc2l0aXZlKSB8fCAoaXNWYWx1ZSh5TWF4KSAmJiBpc0FsbE5lZ2F0aXZlKSkge1xyXG5cdFx0XHRpc1plcm9CYXNlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxyXG5cdFx0aWYgKGlzWmVyb0Jhc2VkKSB7XHJcblx0XHRcdGlzQWxsUG9zaXRpdmUgJiYgKHlEb21haW5NaW4gPSAwKTtcclxuXHRcdFx0aXNBbGxOZWdhdGl2ZSAmJiAoeURvbWFpbk1heCA9IDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRvbWFpbkxlbmd0aCA9IE1hdGguYWJzKHlEb21haW5NYXggLSB5RG9tYWluTWluKTtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSB7dG9wOiBkb21haW5MZW5ndGggKiAwLjEsIGJvdHRvbTogZG9tYWluTGVuZ3RoICogMC4xfTtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNlbnRlcikpIHtcclxuXHRcdFx0Y29uc3QgeURvbWFpbkFicyA9IE1hdGgubWF4KE1hdGguYWJzKHlEb21haW5NaW4pLCBNYXRoLmFicyh5RG9tYWluTWF4KSk7XHJcblxyXG5cdFx0XHR5RG9tYWluTWF4ID0gY2VudGVyICsgeURvbWFpbkFicztcclxuXHRcdFx0eURvbWFpbk1pbiA9IGNlbnRlciAtIHlEb21haW5BYnM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWRkIHBhZGRpbmcgZm9yIGRhdGEgbGFiZWxcclxuXHRcdGlmIChzaG93SG9yaXpvbnRhbERhdGFMYWJlbCkge1xyXG5cdFx0XHRjb25zdCBkaWZmID0gZGlmZkRvbWFpbihzY2FsZS55LnJhbmdlKCkpO1xyXG5cdFx0XHRjb25zdCByYXRpbyA9ICQkLmdldERhdGFMYWJlbExlbmd0aCh5RG9tYWluTWluLCB5RG9tYWluTWF4LCBcIndpZHRoXCIpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IHYgLyBkaWZmKTtcclxuXHJcblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0cGFkZGluZ1t2XSArPSBkb21haW5MZW5ndGggKiAocmF0aW9baV0gLyAoMSAtIHJhdGlvWzBdIC0gcmF0aW9bMV0pKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKHNob3dWZXJ0aWNhbERhdGFMYWJlbCkge1xyXG5cdFx0XHRjb25zdCBsZW5ndGhzID0gJCQuZ2V0RGF0YUxhYmVsTGVuZ3RoKHlEb21haW5NaW4sIHlEb21haW5NYXgsIFwiaGVpZ2h0XCIpO1xyXG5cclxuXHRcdFx0W1wiYm90dG9tXCIsIFwidG9wXCJdLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRwYWRkaW5nW3ZdICs9IGF4aXMuY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcobGVuZ3Roc1tpXSwgZG9tYWluTGVuZ3RoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgcGFkZGluZyBpcyBzZXQsIHRoZSBkb21haW4gd2lsbCBiZSB1cGRhdGVkIHJlbGF0aXZlIHRoZSBjdXJyZW50IGRvbWFpbiB2YWx1ZVxyXG5cdFx0Ly8gZXgpICQkLmhlaWdodD0zMDAsIHBhZGRpbmcudG9wPTE1MCwgZG9tYWluTGVuZ3RoPTQgIC0tPiBkb21haW49NlxyXG5cdFx0Y29uc3QgcCA9IGNvbmZpZ1tgJHtwZnh9X3BhZGRpbmdgXTtcclxuXHJcblx0XHRpZiAobm90RW1wdHkocCkpIHtcclxuXHRcdFx0W1wiYm90dG9tXCIsIFwidG9wXCJdLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0cGFkZGluZ1t2XSA9IGF4aXMuZ2V0UGFkZGluZyhwLCB2LCBwYWRkaW5nW3ZdLCBkb21haW5MZW5ndGgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBCYXIvQXJlYSBjaGFydCBzaG91bGQgYmUgMC1iYXNlZCBpZiBhbGwgcG9zaXRpdmV8bmVnYXRpdmVcclxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xyXG5cdFx0XHRpc0FsbFBvc2l0aXZlICYmIChwYWRkaW5nLmJvdHRvbSA9IHlEb21haW5NaW4pO1xyXG5cdFx0XHRpc0FsbE5lZ2F0aXZlICYmIChwYWRkaW5nLnRvcCA9IC15RG9tYWluTWF4KTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkb21haW4gPSBbeURvbWFpbk1pbiAtIHBhZGRpbmcuYm90dG9tLCB5RG9tYWluTWF4ICsgcGFkZGluZy50b3BdO1xyXG5cclxuXHRcdHJldHVybiBpc0ludmVydGVkID8gZG9tYWluLnJldmVyc2UoKSA6IGRvbWFpbjtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIHR5cGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNvbmZpZ1ZhbHVlID0gJCQuY29uZmlnW2BheGlzX3hfJHt0eXBlfWBdO1xyXG5cdFx0Y29uc3QgZGF0YVZhbHVlID0gZ2V0TWluTWF4KHR5cGUsIHRhcmdldHMubWFwKHQgPT4gZ2V0TWluTWF4KHR5cGUsIHQudmFsdWVzLm1hcCh2ID0+IHYueCkpKSk7XHJcblx0XHRsZXQgdmFsdWUgPSBpc09iamVjdChjb25maWdWYWx1ZSkgPyBjb25maWdWYWx1ZS52YWx1ZSA6IGNvbmZpZ1ZhbHVlO1xyXG5cclxuXHRcdHZhbHVlID0gaXNEZWZpbmVkKHZhbHVlKSAmJiAkJC5heGlzLmlzVGltZVNlcmllcygpID8gcGFyc2VEYXRlKHZhbHVlKSA6IHZhbHVlO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb25maWdWYWx1ZSkgJiYgY29uZmlnVmFsdWUuZml0ICYmIChcclxuXHRcdFx0KHR5cGUgPT09IFwibWluXCIgJiYgdmFsdWUgPCBkYXRhVmFsdWUpIHx8ICh0eXBlID09PSBcIm1heFwiICYmIHZhbHVlID4gZGF0YVZhbHVlKVxyXG5cdFx0KSkge1xyXG5cdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogZGF0YVZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW5NaW4odGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1pblwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluTWF4KHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpblBhZGRpbmcoZG9tYWluKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZGlmZiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcclxuXHRcdGNvbnN0IHhQYWRkaW5nID0gY29uZmlnLmF4aXNfeF9wYWRkaW5nO1xyXG5cdFx0bGV0IG1heERhdGFDb3VudDtcclxuXHRcdGxldCBwYWRkaW5nO1xyXG5cclxuXHRcdGlmIChheGlzLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRwYWRkaW5nID0gMDtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xyXG5cdFx0XHRtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdFx0cGFkZGluZyA9IG1heERhdGFDb3VudCA+IDEgPyAoZGlmZiAvIChtYXhEYXRhQ291bnQgLSAxKSkgLyAyIDogMC41O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFkZGluZyA9IGRpZmYgKiAwLjAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBsZWZ0ID0gcGFkZGluZztcclxuXHRcdGxldCByaWdodCA9IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KHhQYWRkaW5nKSAmJiBub3RFbXB0eSh4UGFkZGluZykpIHtcclxuXHRcdFx0bGVmdCA9IGlzVmFsdWUoeFBhZGRpbmcubGVmdCkgPyB4UGFkZGluZy5sZWZ0IDogcGFkZGluZztcclxuXHRcdFx0cmlnaHQgPSBpc1ZhbHVlKHhQYWRkaW5nLnJpZ2h0KSA/IHhQYWRkaW5nLnJpZ2h0IDogcGFkZGluZztcclxuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoY29uZmlnLmF4aXNfeF9wYWRkaW5nKSkge1xyXG5cdFx0XHRsZWZ0ID0geFBhZGRpbmc7XHJcblx0XHRcdHJpZ2h0ID0geFBhZGRpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtsZWZ0LCByaWdodH07XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbih0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuYXhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5heGlzLmlzVGltZVNlcmllcygpO1xyXG5cdFx0Y29uc3QgeERvbWFpbiA9IFskJC5nZXRYRG9tYWluTWluKHRhcmdldHMpLCAkJC5nZXRYRG9tYWluTWF4KHRhcmdldHMpXTtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSAkJC5nZXRYRG9tYWluUGFkZGluZyh4RG9tYWluKTtcclxuXHRcdGxldCBbZmlyc3RYLCBsYXN0WF0gPSB4RG9tYWluO1xyXG5cdFx0bGV0IG1pbjogRGF0ZSB8IG51bWJlciA9IDA7XHJcblx0XHRsZXQgbWF4OiBEYXRlIHwgbnVtYmVyID0gMDtcclxuXHJcblx0XHQvLyBzaG93IGNlbnRlciBvZiB4IGRvbWFpbiBpZiBtaW4gYW5kIG1heCBhcmUgdGhlIHNhbWVcclxuXHRcdGlmICgoZmlyc3RYIC0gbGFzdFgpID09PSAwICYmICFpc0NhdGVnb3JpemVkKSB7XHJcblx0XHRcdGlmIChpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHRmaXJzdFggPSBuZXcgRGF0ZShmaXJzdFguZ2V0VGltZSgpICogMC41KTtcclxuXHRcdFx0XHRsYXN0WCA9IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSAqIDEuNSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zmlyc3RYID0gZmlyc3RYID09PSAwID8gMSA6IChmaXJzdFggKiAwLjUpO1xyXG5cdFx0XHRcdGxhc3RYID0gbGFzdFggPT09IDAgPyAtMSA6IChsYXN0WCAqIDEuNSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZmlyc3RYIHx8IGZpcnN0WCA9PT0gMCkge1xyXG5cdFx0XHRtaW4gPSBpc1RpbWVTZXJpZXMgPyBuZXcgRGF0ZShmaXJzdFguZ2V0VGltZSgpIC0gcGFkZGluZy5sZWZ0KSA6IGZpcnN0WCAtIHBhZGRpbmcubGVmdDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGFzdFggfHwgbGFzdFggPT09IDApIHtcclxuXHRcdFx0bWF4ID0gaXNUaW1lU2VyaWVzID8gbmV3IERhdGUobGFzdFguZ2V0VGltZSgpICsgcGFkZGluZy5yaWdodCkgOiBsYXN0WCArIHBhZGRpbmcucmlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFttaW4sIG1heF07XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWERvbWFpbih0YXJnZXRzLCB3aXRoVXBkYXRlWERvbWFpbiwgd2l0aFVwZGF0ZU9yZ1hEb21haW4sIHdpdGhUcmltLCBkb21haW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZywgc2NhbGU6IHt4LCBzdWJYfX0gPSAkJDtcclxuXHRcdGNvbnN0IHpvb21FbmFibGVkID0gY29uZmlnLnpvb21fZW5hYmxlZDtcclxuXHJcblx0XHRpZiAod2l0aFVwZGF0ZU9yZ1hEb21haW4pIHtcclxuXHRcdFx0eC5kb21haW4oZG9tYWluIHx8IHNvcnRWYWx1ZSgkJC5nZXRYRG9tYWluKHRhcmdldHMpKSk7XHJcblx0XHRcdG9yZy54RG9tYWluID0geC5kb21haW4oKTtcclxuXHJcblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcclxuXHJcblx0XHRcdHN1YlguZG9tYWluKHguZG9tYWluKCkpO1xyXG5cdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC5zY2FsZShzdWJYKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2l0aFVwZGF0ZVhEb21haW4pIHtcclxuXHRcdFx0Y29uc3QgZG9tYWluVmFsdWUgPSBkb21haW4gfHwgKCEkJC5icnVzaCB8fCBicnVzaEVtcHR5KCQkKSkgP1xyXG5cdFx0XHRcdG9yZy54RG9tYWluIDogZ2V0QnJ1c2hTZWxlY3Rpb24oJCQpLm1hcChzdWJYLmludmVydCk7XHJcblxyXG5cdFx0XHR4LmRvbWFpbihkb21haW5WYWx1ZSk7XHJcblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUcmltIGRvbWFpbiB3aGVuIHRvbyBiaWcgYnkgem9vbSBtb3VzZW1vdmUgZXZlbnRcclxuXHRcdHdpdGhUcmltICYmIHguZG9tYWluKCQkLnRyaW1YRG9tYWluKHgub3JnRG9tYWluKCkpKTtcclxuXHJcblx0XHRyZXR1cm4geC5kb21haW4oKTtcclxuXHR9LFxyXG5cclxuXHR0cmltWERvbWFpbihkb21haW4pIHtcclxuXHRcdGNvbnN0IHpvb21Eb21haW4gPSB0aGlzLmdldFpvb21Eb21haW4oKTtcclxuXHRcdGNvbnN0IFttaW4sIG1heF0gPSB6b29tRG9tYWluO1xyXG5cclxuXHRcdGlmIChkb21haW5bMF0gPD0gbWluKSB7XHJcblx0XHRcdGRvbWFpblsxXSA9ICtkb21haW5bMV0gKyAobWluIC0gZG9tYWluWzBdKTtcclxuXHRcdFx0ZG9tYWluWzBdID0gbWluO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXggPD0gZG9tYWluWzFdKSB7XHJcblx0XHRcdGRvbWFpblswXSA9ICtkb21haW5bMF0gLSAoZG9tYWluWzFdIC0gbWF4KTtcclxuXHRcdFx0ZG9tYWluWzFdID0gbWF4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkb21haW47XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0VHlwZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7QXhpc1R5cGV9IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEdldCBmb3JtYXR0ZWRcclxuICogQHBhcmFtIHtvYmplY3R9ICQkIENvbnRleHRcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVWYWx1ZSBBeGlzIHR5cGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHYgVmFsdWUgdG8gYmUgZm9ybWF0dGVkXHJcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGb3JtYXQoJCQsIHR5cGVWYWx1ZTogQXhpc1R5cGUsIHY6IG51bWJlcik6IG51bWJlciB8IHN0cmluZyB7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRjb25zdCB0eXBlID0gYGF4aXNfJHt0eXBlVmFsdWV9X3RpY2tfZm9ybWF0YDtcclxuXHRjb25zdCBmb3JtYXQgPSBjb25maWdbdHlwZV0gP1xyXG5cdFx0Y29uZmlnW3R5cGVdIDogJCQuZGVmYXVsdFZhbHVlRm9ybWF0O1xyXG5cclxuXHRyZXR1cm4gZm9ybWF0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0WUZvcm1hdChmb3JBcmM6IGJvb2xlYW4pOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQge3lGb3JtYXQsIHkyRm9ybWF0fSA9ICQkO1xyXG5cclxuXHRcdGlmIChmb3JBcmMgJiYgISQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHR5Rm9ybWF0ID0gJCQuZGVmYXVsdEFyY1ZhbHVlRm9ybWF0O1xyXG5cdFx0XHR5MkZvcm1hdCA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24odiwgcmF0aW8sIGlkKSB7XHJcblx0XHRcdGNvbnN0IGZvcm1hdCA9ICQkLmF4aXMgJiYgJCQuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIiA/XHJcblx0XHRcdFx0eTJGb3JtYXQgOiB5Rm9ybWF0O1xyXG5cclxuXHRcdFx0cmV0dXJuIGZvcm1hdC5jYWxsKCQkLCB2LCByYXRpbyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdHlGb3JtYXQodjogbnVtYmVyKTogbnVtYmVyIHwgc3RyaW5nIHtcclxuXHRcdHJldHVybiBnZXRGb3JtYXQodGhpcywgXCJ5XCIsIHYpO1xyXG5cdH0sXHJcblxyXG5cdHkyRm9ybWF0KHY6IG51bWJlcik6IG51bWJlciB8IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gZ2V0Rm9ybWF0KHRoaXMsIFwieTJcIiwgdik7XHJcblx0fSxcclxuXHJcblx0ZGVmYXVsdFZhbHVlRm9ybWF0KHYpOiBudW1iZXIgfCBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGlzVmFsdWUodikgPyArdiA6IFwiXCI7XHJcblx0fSxcclxuXHJcblx0ZGVmYXVsdEFyY1ZhbHVlRm9ybWF0KHYsIHJhdGlvKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgJHsocmF0aW8gKiAxMDApLnRvRml4ZWQoMSl9JWA7XHJcblx0fSxcclxuXHJcblx0ZGF0YUxhYmVsRm9ybWF0KHRhcmdldElkOiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzO1xyXG5cdFx0Y29uc3QgZGVmYXVsdEZvcm1hdCA9IHYgPT4gKGlzVmFsdWUodikgPyArdiA6IFwiXCIpO1xyXG5cdFx0bGV0IGZvcm1hdCA9IGRlZmF1bHRGb3JtYXQ7XHJcblxyXG5cdFx0Ly8gZmluZCBmb3JtYXQgYWNjb3JkaW5nIHRvIGF4aXMgaWRcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGRhdGFMYWJlbHMuZm9ybWF0KSkge1xyXG5cdFx0XHRmb3JtYXQgPSBkYXRhTGFiZWxzLmZvcm1hdDtcclxuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3RUeXBlKGRhdGFMYWJlbHMuZm9ybWF0KSkge1xyXG5cdFx0XHRpZiAoZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdKSB7XHJcblx0XHRcdFx0Zm9ybWF0ID0gZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdID09PSB0cnVlID9cclxuXHRcdFx0XHRcdGRlZmF1bHRGb3JtYXQgOiBkYXRhTGFiZWxzLmZvcm1hdFt0YXJnZXRJZF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9ybWF0ID0gKCkgPT4gXCJcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmb3JtYXQuYmluZCgkJC5hcGkpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50LFxyXG5cdG5hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2NhbGxGbiwgaXNEZWZpbmVkLCBnZXRPcHRpb24sIGlzRW1wdHksIGlzRnVuY3Rpb24sIG5vdEVtcHR5LCB0cGxQcm9jZXNzfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0TGVnZW5kKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLmxlZ2VuZEl0ZW1UZXh0Qm94ID0ge307XHJcblx0XHQkJC5zdGF0ZS5sZWdlbmRIYXNSZW5kZXJlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0aWYgKCFjb25maWcubGVnZW5kX2NvbnRlbnRzX2JpbmR0bykge1xyXG5cdFx0XHRcdCRlbC5sZWdlbmQgPSAkJC4kZWwuc3ZnLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE1FTU86IGNhbGwgaGVyZSB0byB1cGRhdGUgbGVnZW5kIGJveCBhbmQgdHJhbnNsYXRlIGZvciBhbGxcclxuXHRcdFx0Ly8gTUVNTzogdHJhbnNsYXRlIHdpbGwgYmUgdXBkYXRlZCBieSB0aGlzLCBzbyB0cmFuc2Zvcm0gbm90IG5lZWRlZCBpbiB1cGRhdGVMZWdlbmQoKVxyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLnN0YXRlLmhpZGRlbkxlZ2VuZElkcyA9ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGxlZ2VuZCBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgd2l0aFRyYW5zZm9ybSA6IFdoZXRoZXIgdG8gdXNlIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogV2hldGhlciB0cmFuc2l0aW9uIGlzIHVzZWQgd2hlbiB1c2luZyB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb24gOiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0cmFuc2l0aW9ucyBSZXR1cm4gdmFsdWUgb2YgdGhlIGdlbmVyYXRlVHJhbnNpdGlvbnNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZCh0YXJnZXRJZHMsIG9wdGlvbnMsIHRyYW5zaXRpb25zKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgc2NhbGUsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IG9wdGlvbnogPSBvcHRpb25zIHx8IHtcclxuXHRcdFx0d2l0aFRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBmYWxzZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlXHJcblx0XHR9O1xyXG5cclxuXHRcdG9wdGlvbnoud2l0aFRyYW5zaXRpb24gPSBnZXRPcHRpb24ob3B0aW9ueiwgXCJ3aXRoVHJhbnNpdGlvblwiLCB0cnVlKTtcclxuXHRcdG9wdGlvbnoud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0gPSBnZXRPcHRpb24ob3B0aW9ueiwgXCJ3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybVwiLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8gJiYgY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZSkge1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRUZW1wbGF0ZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kRWxlbWVudChcclxuXHRcdFx0XHR0YXJnZXRJZHMgfHwgJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSxcclxuXHRcdFx0XHRvcHRpb256LFxyXG5cdFx0XHRcdHRyYW5zaXRpb25zXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdG9nZ2xlIGxlZ2VuZCBzdGF0ZVxyXG5cdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbiwgaWQgPT4gISQkLmlzVGFyZ2V0VG9TaG93KGlkKSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIHNpemUgYW5kIHNjYWxlXHJcblx0XHQkJC51cGRhdGVTY2FsZXMoZmFsc2UsICFzY2FsZS56b29tKTtcclxuXHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgZyBwb3NpdGlvbnNcclxuXHRcdCQkLnRyYW5zZm9ybUFsbChvcHRpb256LndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtLCB0cmFuc2l0aW9ucyk7XHJcblxyXG5cdFx0c3RhdGUubGVnZW5kSGFzUmVuZGVyZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgdXNpbmcgdGVtcGxhdGUgb3B0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRUZW1wbGF0ZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHdyYXBwZXIgPSBkM1NlbGVjdChjb25maWcubGVnZW5kX2NvbnRlbnRzX2JpbmR0byk7XHJcblx0XHRjb25zdCB0ZW1wbGF0ZSA9IGNvbmZpZy5sZWdlbmRfY29udGVudHNfdGVtcGxhdGU7XHJcblxyXG5cdFx0aWYgKCF3cmFwcGVyLmVtcHR5KCkpIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblx0XHRcdGNvbnN0IGlkczogYW55W10gPSBbXTtcclxuXHRcdFx0bGV0IGh0bWwgPSBcIlwiO1xyXG5cclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBpc0Z1bmN0aW9uKHRlbXBsYXRlKSA/XHJcblx0XHRcdFx0XHR0ZW1wbGF0ZS5iaW5kKCQkLmFwaSkodiwgJCQuY29sb3IodiksICQkLmFwaS5kYXRhKHYpWzBdLnZhbHVlcykgOlxyXG5cdFx0XHRcdFx0dHBsUHJvY2Vzcyh0ZW1wbGF0ZSwge1xyXG5cdFx0XHRcdFx0XHRDT0xPUjogJCQuY29sb3IodiksXHJcblx0XHRcdFx0XHRcdFRJVExFOiB2XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0aWYgKGNvbnRlbnQpIHtcclxuXHRcdFx0XHRcdGlkcy5wdXNoKHYpO1xyXG5cdFx0XHRcdFx0aHRtbCArPSBjb250ZW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCBsZWdlbmRJdGVtID0gd3JhcHBlci5odG1sKGh0bWwpXHJcblx0XHRcdFx0LnNlbGVjdEFsbChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2hpbGROb2RlczsgfSlcclxuXHRcdFx0XHQuZGF0YShpZHMpO1xyXG5cclxuXHRcdFx0JCQuc2V0TGVnZW5kSXRlbShsZWdlbmRJdGVtKTtcclxuXHJcblx0XHRcdCRlbC5sZWdlbmQgPSB3cmFwcGVyO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgbGVnZW5kLlxyXG5cdCAqIEBwYXJhbSB7T2JlamN0fSBzaXplIFNpemUgb2JqZWN0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVTaXplRm9yTGVnZW5kKHNpemUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7XHJcblx0XHRcdGlzTGVnZW5kVG9wLCBpc0xlZ2VuZExlZnQsIGlzTGVnZW5kUmlnaHQsIGlzTGVnZW5kSW5zZXQsIGN1cnJlbnRcclxuXHRcdH19ID0gJCQ7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xyXG5cclxuXHRcdGNvbnN0IGluc2V0TGVnZW5kUG9zaXRpb24gPSB7XHJcblx0XHRcdHRvcDogaXNMZWdlbmRUb3AgP1xyXG5cdFx0XHRcdCQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCkgKyBjb25maWcubGVnZW5kX2luc2V0X3kgKyA1LjUgOlxyXG5cdFx0XHRcdGN1cnJlbnQuaGVpZ2h0IC0gaGVpZ2h0IC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20oKSAtIGNvbmZpZy5sZWdlbmRfaW5zZXRfeSxcclxuXHRcdFx0bGVmdDogaXNMZWdlbmRMZWZ0ID9cclxuXHRcdFx0XHQkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeCArIDAuNSA6XHJcblx0XHRcdFx0Y3VycmVudC53aWR0aCAtIHdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF94ICsgMC41XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLnN0YXRlLm1hcmdpbjMgPSB7XHJcblx0XHRcdHRvcDogaXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0MCA6IGlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLnRvcCA6IGN1cnJlbnQuaGVpZ2h0IC0gaGVpZ2h0LFxyXG5cdFx0XHRyaWdodDogTmFOLFxyXG5cdFx0XHRib3R0b206IDAsXHJcblx0XHRcdGxlZnQ6IGlzTGVnZW5kUmlnaHQgP1xyXG5cdFx0XHRcdGN1cnJlbnQud2lkdGggLSB3aWR0aCA6IGlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLmxlZnQgOiAwXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYW5zZm9ybSBMZWdlbmRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uIHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0cmFuc2Zvcm1MZWdlbmQod2l0aFRyYW5zaXRpb24pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtsZWdlbmR9ID0gJCQuJGVsO1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxlZ2VuZC50cmFuc2l0aW9uKCkgOiBsZWdlbmQpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBsZWdlbmQgc3RlcFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFN0ZXAgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlLmxlZ2VuZFN0ZXAgPSBzdGVwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSB3aWR0aFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kSXRlbVdpZHRoKHdpZHRoOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUubGVnZW5kSXRlbVdpZHRoID0gd2lkdGg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGxlZ2VuZCBpdGVtIGhlaWdodFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0KGhlaWdodCk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5sZWdlbmRJdGVtSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSBjb2xvclxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb3JyZXNwb25kaW5nIGRhdGEgSUQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcihpZDogc3RyaW5nLCBjb2xvcjogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLiRlbC5sZWdlbmQuc2VsZWN0KGAuJHtDTEFTUy5sZWdlbmRJdGVtfS0ke2lkfSBsaW5lYClcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIGNvbG9yKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB3aWR0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0TGVnZW5kV2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjdXJyZW50OiB7d2lkdGh9LCBpc0xlZ2VuZFJpZ2h0LCBpc0xlZ2VuZEluc2V0LCBsZWdlbmRJdGVtV2lkdGgsIGxlZ2VuZFN0ZXB9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/IChcclxuXHRcdFx0aXNMZWdlbmRSaWdodCB8fCBpc0xlZ2VuZEluc2V0ID9cclxuXHRcdFx0XHRsZWdlbmRJdGVtV2lkdGggKiAobGVnZW5kU3RlcCArIDEpIDogd2lkdGhcclxuXHRcdCkgOiAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldExlZ2VuZEhlaWdodCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2N1cnJlbnQsIGlzTGVnZW5kUmlnaHQsIGxlZ2VuZEl0ZW1IZWlnaHQsIGxlZ2VuZFN0ZXB9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/IChcclxuXHRcdFx0aXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0Y3VycmVudC5oZWlnaHQgOiBNYXRoLm1heCgyMCwgbGVnZW5kSXRlbUhlaWdodCkgKiAobGVnZW5kU3RlcCArIDEpXHJcblx0XHQpIDogMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBsZWdlbmRJdGVtIExlZ2VuZCBpdGVtIG5vZGVcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IG9wYWNpdHlcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9wYWNpdHlGb3JMZWdlbmQobGVnZW5kSXRlbSk6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0cmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjFcIjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZCB0aGF0IGlzIHVuZm9jdXNlZFxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBsZWdlbmRJdGVtIExlZ2VuZCBpdGVtIG5vZGVcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IG9wYWNpdHlcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQobGVnZW5kSXRlbSk6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0cmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjAuM1wiO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIGZvY3VzIG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGZvY3VzIHdoZXRoZXIgb3Igbm90IHRvIGZvY3VzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzOiBzdHJpbmdbXSwgZm9jdXM6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtsZWdlbmR9ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWR6ID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcclxuXHJcblx0XHRsZWdlbmQgJiYgbGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxyXG5cdFx0XHQuZmlsdGVyKGlkID0+IHRhcmdldElkei5pbmRleE9mKGlkKSA+PSAwKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZm9jdXMpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKDEwMClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gKGZvY3VzID8gJCQub3BhY2l0eUZvckxlZ2VuZCA6ICQkLm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQpXHJcblx0XHRcdFx0XHQuY2FsbCgkJCwgZDNTZWxlY3QodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXZlcnQgdGhlIGxlZ2VuZCB0byBpdHMgZGVmYXVsdCBzdGF0ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmV2ZXJ0TGVnZW5kKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2xlZ2VuZH0gPSAkJC4kZWw7XHJcblxyXG5cdFx0bGVnZW5kICYmIGxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZhbHNlKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoZDNTZWxlY3QodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93cyB0aGUgbGVnZW5kXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzaG93TGVnZW5kKHRhcmdldElkczogc3RyaW5nW10pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHRjb25maWcubGVnZW5kX3Nob3cgPSB0cnVlO1xyXG5cclxuXHRcdFx0JGVsLmxlZ2VuZCA/XHJcblx0XHRcdFx0JGVsLmxlZ2VuZC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpIDpcclxuXHRcdFx0XHQkJC5pbml0TGVnZW5kKCk7XHJcblxyXG5cdFx0XHQhJCQuc3RhdGUubGVnZW5kSGFzUmVuZGVyZWQgJiYgJCQudXBkYXRlTGVnZW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQucmVtb3ZlSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCQub3BhY2l0eUZvckxlZ2VuZChkM1NlbGVjdCh0aGlzKSk7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGlkZUxlZ2VuZCh0YXJnZXRJZHM6IHN0cmluZ1tdKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgaXNFbXB0eSh0YXJnZXRJZHMpKSB7XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xyXG5cdFx0XHRsZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xyXG5cdFx0bGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgbGVnZW5kIGl0ZW0gdGV4dGJveCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgRGF0YSBJRFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSB0ZXh0RWxlbWVudCBUZXh0IG5vZGUgZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IEJvdW5kaW5nIHJlY3RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldExlZ2VuZEl0ZW1UZXh0Qm94KGlkPzogc3RyaW5nLCB0ZXh0RWxlbWVudD8pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjYWNoZX0gPSAkJDtcclxuXHRcdGxldCBkYXRhO1xyXG5cclxuXHRcdC8vIGRvIG5vdCBwcmVmaXggdy8nJCcsIHRvIG5vdCBiZSByZXNldHRlZCBjYWNoZSBpbiAubG9hZCgpIGNhbGxcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gS0VZLmxlZ2VuZEl0ZW1UZXh0Qm94O1xyXG5cclxuXHRcdGlmIChpZCkge1xyXG5cdFx0XHRkYXRhID0gY2FjaGUuZ2V0KGNhY2hlS2V5KSB8fCB7fTtcclxuXHJcblx0XHRcdGlmICghZGF0YVtpZF0pIHtcclxuXHRcdFx0XHRkYXRhW2lkXSA9ICQkLmdldFRleHRSZWN0KHRleHRFbGVtZW50LCBDTEFTUy5sZWdlbmRJdGVtKTtcclxuXHRcdFx0XHRjYWNoZS5hZGQoY2FjaGVLZXksIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkYXRhID0gZGF0YVtpZF07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxlZ2VuZCBpdGVtIHN0eWxlICYgYmluZCBldmVudHNcclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gaXRlbSBJdGVtIG5vZGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldExlZ2VuZEl0ZW0oaXRlbSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2FwaSwgY29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cclxuXHRcdGl0ZW1cclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihpZCkge1xyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpdGVtQ2xhc3MgPSAoIW5vZGUuZW1wdHkoKSAmJiBub2RlLmF0dHIoXCJjbGFzc1wiKSkgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGl0ZW1DbGFzcyArICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGVnZW5kSXRlbSwgaWQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGlkID0+ICgkJC5pc0xlZ2VuZFRvU2hvdyhpZCkgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGlkID0+IHtcclxuXHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25jbGljaywgYXBpLCBpZCkpIHtcclxuXHRcdFx0XHRcdGlmIChkM0V2ZW50LmFsdEtleSkge1xyXG5cdFx0XHRcdFx0XHRhcGkuaGlkZSgpO1xyXG5cdFx0XHRcdFx0XHRhcGkuc2hvdyhpZCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhcGkudG9nZ2xlKGlkKTtcclxuXHRcdFx0XHRcdFx0IWlzVG91Y2ggJiYgJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gYXBpLmZvY3VzKGlkKSA6IGFwaS5yZXZlcnQoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlzVG91Y2ggJiYgJCQuaGlkZVRvb2x0aXAoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFpc1RvdWNoKSB7XHJcblx0XHRcdGl0ZW1cclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihpZCkge1xyXG5cdFx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29ub3V0LCBhcGksIGlkKSkge1xyXG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoaGFzR2F1Z2UpIHtcclxuXHRcdFx0XHRcdFx0XHQkJC51bmRvTWFya092ZXJsYXBwZWQoJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQkJC5hcGkucmV2ZXJ0KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRcdGlmICghY2FsbEZuKGNvbmZpZy5sZWdlbmRfaXRlbV9vbm92ZXIsIGFwaSwgaWQpKSB7XHJcblx0XHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0JCQubWFya092ZXJsYXBwZWQoaWQsICQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCFzdGF0ZS50cmFuc2l0aW5nICYmICQkLmlzVGFyZ2V0VG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdFx0XHRcdGFwaS5mb2N1cyhpZCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEVsZW1lbnQodGFyZ2V0SWRzOiBzdHJpbmdbXSwgb3B0aW9ucyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge2xlZ2VuZH19ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nVG9wID0gNDtcclxuXHRcdGNvbnN0IHBhZGRpbmdSaWdodCA9IDEwO1xyXG5cdFx0Y29uc3QgcG9zTWluID0gMTA7XHJcblx0XHRjb25zdCB0aWxlV2lkdGggPSBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aCArIDU7XHJcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xyXG5cdFx0bGV0IG1heEhlaWdodCA9IDA7XHJcblx0XHRsZXQgeEZvckxlZ2VuZDtcclxuXHRcdGxldCB5Rm9yTGVnZW5kO1xyXG5cdFx0bGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuXHRcdGNvbnN0IG9mZnNldHMgPSB7fTtcclxuXHRcdGNvbnN0IHdpZHRocyA9IHt9O1xyXG5cdFx0Y29uc3QgaGVpZ2h0cyA9IHt9O1xyXG5cdFx0Y29uc3QgbWFyZ2lucyA9IFswXTtcclxuXHRcdGNvbnN0IHN0ZXBzID0ge307XHJcblx0XHRsZXQgc3RlcCA9IDA7XHJcblx0XHRsZXQgYmFja2dyb3VuZDtcclxuXHRcdGNvbnN0IGlzTGVnZW5kUmlnaHRPckluc2V0ID0gc3RhdGUuaXNMZWdlbmRSaWdodCB8fCBzdGF0ZS5pc0xlZ2VuZEluc2V0O1xyXG5cclxuXHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXHJcblx0XHRjb25zdCB0YXJnZXRJZHogPSB0YXJnZXRJZHNcclxuXHRcdFx0LmZpbHRlcihpZCA9PiAhaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgfHwgY29uZmlnLmRhdGFfbmFtZXNbaWRdICE9PSBudWxsKTtcclxuXHJcblx0XHRjb25zdCB3aXRoVHJhbnNpdGlvbiA9IG9wdGlvbnMud2l0aFRyYW5zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24odGV4dEVsZW1lbnQsIGlkLCBpbmRleCkge1xyXG5cdFx0XHRjb25zdCByZXNldCA9IGluZGV4ID09PSAwO1xyXG5cdFx0XHRjb25zdCBpc0xhc3QgPSBpbmRleCA9PT0gdGFyZ2V0SWR6Lmxlbmd0aCAtIDE7XHJcblx0XHRcdGNvbnN0IGJveCA9ICQkLmdldExlZ2VuZEl0ZW1UZXh0Qm94KGlkLCB0ZXh0RWxlbWVudCk7XHJcblx0XHRcdGNvbnN0IGl0ZW1XaWR0aCA9IGJveC53aWR0aCArIHRpbGVXaWR0aCArXHJcblx0XHRcdFx0KGlzTGFzdCAmJiAhaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAwIDogcGFkZGluZ1JpZ2h0KSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZztcclxuXHRcdFx0Y29uc3QgaXRlbUhlaWdodCA9IGJveC5oZWlnaHQgKyBwYWRkaW5nVG9wO1xyXG5cdFx0XHRjb25zdCBpdGVtTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBpdGVtSGVpZ2h0IDogaXRlbVdpZHRoO1xyXG5cdFx0XHRjb25zdCBhcmVhTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6ICQkLmdldExlZ2VuZFdpZHRoKCk7XHJcblx0XHRcdGxldCBtYXJnaW47XHJcblxyXG5cdFx0XHQvLyBNRU1POiBjYXJlIGFib3V0IGNvbmRpZmlvbiBvZiBzdGVwLCB0b3RhbExlbmd0aFxyXG5cdFx0XHRjb25zdCB1cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbihpZDIsIHdpdGhvdXRTdGVwPzogYm9vbGVhbikge1xyXG5cdFx0XHRcdGlmICghd2l0aG91dFN0ZXApIHtcclxuXHRcdFx0XHRcdG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gdG90YWxMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIGl0ZW1MZW5ndGgpIC8gMjtcclxuXHRcdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0XHRzdGVwKys7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGVwc1tpZDJdID0gc3RlcDtcclxuXHRcdFx0XHRtYXJnaW5zW3N0ZXBdID0gc3RhdGUuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luO1xyXG5cdFx0XHRcdG9mZnNldHNbaWQyXSA9IHRvdGFsTGVuZ3RoO1xyXG5cdFx0XHRcdHRvdGFsTGVuZ3RoICs9IGl0ZW1MZW5ndGg7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAocmVzZXQpIHtcclxuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDA7XHJcblx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0bWF4V2lkdGggPSAwO1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IDA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgISQkLmlzTGVnZW5kVG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdHdpZHRoc1tpZF0gPSAwO1xyXG5cdFx0XHRcdGhlaWdodHNbaWRdID0gMDtcclxuXHRcdFx0XHRzdGVwc1tpZF0gPSAwO1xyXG5cdFx0XHRcdG9mZnNldHNbaWRdID0gMDtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aWR0aHNbaWRdID0gaXRlbVdpZHRoO1xyXG5cdFx0XHRoZWlnaHRzW2lkXSA9IGl0ZW1IZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkge1xyXG5cdFx0XHRcdG1heFdpZHRoID0gaXRlbVdpZHRoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW1heEhlaWdodCB8fCBpdGVtSGVpZ2h0ID49IG1heEhlaWdodCkge1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IGl0ZW1IZWlnaHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1heExlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gbWF4SGVpZ2h0IDogbWF4V2lkdGg7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmxlZ2VuZF9lcXVhbGx5KSB7XHJcblx0XHRcdFx0T2JqZWN0LmtleXMod2lkdGhzKS5mb3JFYWNoKGlkMiA9PiAod2lkdGhzW2lkMl0gPSBtYXhXaWR0aCkpO1xyXG5cdFx0XHRcdE9iamVjdC5rZXlzKGhlaWdodHMpLmZvckVhY2goaWQyID0+IChoZWlnaHRzW2lkMl0gPSBtYXhIZWlnaHQpKTtcclxuXHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIG1heExlbmd0aCAqIHRhcmdldElkei5sZW5ndGgpIC8gMjtcclxuXHJcblx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0XHR0YXJnZXRJZHouZm9yRWFjaChpZDIgPT4gdXBkYXRlVmFsdWVzKGlkMikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHN0ZXAgPSBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgPyBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgOiB0YXJnZXRJZHoubGVuZ3RoO1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXTtcclxuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xyXG5cdFx0fSBlbHNlIGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXSArIDEwO1xyXG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXhIZWlnaHQgKiBzdGVwc1tpZF07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFRleHQgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpICsgNCArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFJlY3QgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpO1xyXG5cdFx0Y29uc3QgeDFGb3JMZWdlbmRUaWxlID0gKGlkLCBpPzogbnVtYmVyKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDI7XHJcblx0XHRjb25zdCB4MkZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpIC0gMiArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cclxuXHRcdGNvbnN0IHlGb3JMZWdlbmRUZXh0ID0gKGlkLCBpPzogbnVtYmVyKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDk7XHJcblx0XHRjb25zdCB5Rm9yTGVnZW5kUmVjdCA9IChpZCwgaT86IG51bWJlcikgPT4geUZvckxlZ2VuZChpZCwgaSkgLSA1O1xyXG5cdFx0Y29uc3QgeUZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHlGb3JMZWdlbmQoaWQsIGkpICsgNDtcclxuXHJcblx0XHRjb25zdCBwb3MgPSAtMjAwO1xyXG5cclxuXHRcdC8vIERlZmluZSBnIGZvciBsZWdlbmQgYXJlYVxyXG5cdFx0Y29uc3QgbCA9IGxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHQkJC5zZXRMZWdlbmRJdGVtKGwpO1xyXG5cclxuXHRcdGwuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRUZXh0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGV4dCk7XHJcblxyXG5cdFx0bC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbUV2ZW50KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRSZWN0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kUmVjdCk7XHJcblxyXG5cdFx0Y29uc3QgdXNlUG9pbnQgPSBjb25maWcubGVnZW5kX3VzZVBvaW50O1xyXG5cclxuXHRcdGlmICh1c2VQb2ludCkge1xyXG5cdFx0XHRjb25zdCBpZHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0XHRsLmFwcGVuZChkID0+IHtcclxuXHRcdFx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID9cclxuXHRcdFx0XHRcdGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcclxuXHJcblx0XHRcdFx0aWRzLmluZGV4T2YoZCkgPT09IC0xICYmIGlkcy5wdXNoKGQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGQpICUgcGF0dGVybi5sZW5ndGhdO1xyXG5cclxuXHRcdFx0XHRpZiAocG9pbnQgPT09IFwicmVjdGFuZ2xlXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50ID0gXCJyZWN0XCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsICQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSA/IHBvaW50IDogXCJ1c2VcIik7XHJcblx0XHRcdH0pXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRJdGVtUG9pbnQpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiaHJlZlwiLCAoZGF0YSwgaWR4LCBzZWxlY3Rpb24pID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25baWR4XTtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSA9PT0gXCJ1c2VcIiA/IGAjJHtzdGF0ZS5kYXRldGltZUlkfS1wb2ludC0ke2RhdGF9YCA6IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGwuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbVRpbGUpXHJcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MUZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MkZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX2hlaWdodCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IGJhY2tncm91bmQgZm9yIGluc2V0IGxlZ2VuZFxyXG5cdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEJhY2tncm91bmR9IHJlY3RgKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRJbnNldCAmJiBtYXhXaWR0aCA+IDAgJiYgYmFja2dyb3VuZC5zaXplKCkgPT09IDApIHtcclxuXHRcdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRCYWNrZ3JvdW5kKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHRzID0gbGVnZW5kLnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpIC8vIE1FTU86IG5lZWRlZCBmb3IgdXBkYXRlXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXHJcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JMZWdlbmRUZXh0KTtcclxuXHJcblx0XHRjb25zdCByZWN0cyA9IGxlZ2VuZC5zZWxlY3RBbGwoYHJlY3QuJHtDTEFTUy5sZWdlbmRJdGVtRXZlbnR9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KTtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyByZWN0cy50cmFuc2l0aW9uKCkgOiByZWN0cylcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBpZCA9PiB3aWR0aHNbaWRdKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBpZCA9PiBoZWlnaHRzW2lkXSlcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIHhGb3JMZWdlbmRSZWN0KVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeUZvckxlZ2VuZFJlY3QpO1xyXG5cclxuXHJcblx0XHRpZiAodXNlUG9pbnQpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBsZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtUG9pbnR9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xyXG5cclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0XHRcdFx0bGV0IHggPSBcInhcIjtcclxuXHRcdFx0XHRcdGxldCB5ID0gXCJ5XCI7XHJcblx0XHRcdFx0XHRsZXQgeE9mZnNldCA9IDI7XHJcblx0XHRcdFx0XHRsZXQgeU9mZnNldCA9IDIuNTtcclxuXHRcdFx0XHRcdGxldCByYWRpdXM7XHJcblx0XHRcdFx0XHRsZXQgd2lkdGg7XHJcblx0XHRcdFx0XHRsZXQgaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdGlmIChub2RlTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaXplID0gcG9pbnRSICogMC4yO1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IFwiY3hcIjtcclxuXHRcdFx0XHRcdFx0eSA9IFwiY3lcIjtcclxuXHRcdFx0XHRcdFx0cmFkaXVzID0gcG9pbnRSICsgc2l6ZTtcclxuXHRcdFx0XHRcdFx0eE9mZnNldCA9IHBvaW50UiAqIDI7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAtc2l6ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFwicmVjdFwiKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSBwb2ludFIgKiAyLjU7XHJcblxyXG5cdFx0XHRcdFx0XHR3aWR0aCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdGhlaWdodCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAzO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKHgsIGQgPT4geDFGb3JMZWdlbmRUaWxlKGQpICsgeE9mZnNldClcclxuXHRcdFx0XHRcdFx0LmF0dHIoeSwgZCA9PiB5Rm9yTGVnZW5kVGlsZShkKSAtIHlPZmZzZXQpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiclwiLCByYWRpdXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCB0aWxlcyA9IGxlZ2VuZC5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy5sZWdlbmRJdGVtVGlsZX1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldElkeik7XHJcblxyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aWxlcy50cmFuc2l0aW9uKCkgOiB0aWxlcylcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQubGV2ZWxDb2xvciA/IGlkID0+ICQkLmxldmVsQ29sb3IoJCQuY2FjaGUuZ2V0KGlkKS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4MUZvckxlZ2VuZFRpbGUpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5Rm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIHgyRm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcInkyXCIsIHlGb3JMZWdlbmRUaWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYmFja2dyb3VuZCkge1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgLSAxMilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIG1heFdpZHRoICogKHN0ZXAgKyAxKSArIDEwKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVcGRhdGUgYWxsIHRvIHJlZmxlY3QgY2hhbmdlIG9mIGxlZ2VuZFxyXG5cdFx0JCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobWF4SGVpZ2h0KTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7dHJhbnNpdGlvbiBhcyBkM1RyYW5zaXRpb259IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZW5lcmF0ZVdhaXR9IGZyb20gXCIuLi8uLi9tb2R1bGUvZ2VuZXJhdG9yXCI7XHJcbmltcG9ydCB7Y2FsbEZuLCBnZXRPcHRpb24sIGlzVGFiVmlzaWJsZSwgbm90RW1wdHl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdHJlZHJhdyhvcHRpb25zOiBhbnkgPSB7fSwgdHJhbnNpdGlvbnNWYWx1ZT8pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkZWw7XHJcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdGNvbnN0IGluaXRpYWxpemluZyA9IG9wdGlvbnMuaW5pdGlhbGl6aW5nO1xyXG5cdFx0Y29uc3QgZmxvdyA9IG9wdGlvbnMuZmxvdztcclxuXHRcdGNvbnN0IHd0aCA9ICQkLmdldFdpdGhPcHRpb24ob3B0aW9ucyk7XHJcblx0XHRjb25zdCBkdXJhdGlvbiA9IHd0aC5UcmFuc2l0aW9uID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JFeGl0ID0gd3RoLlRyYW5zaXRpb25Gb3JFeGl0ID8gZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JBeGlzID0gd3RoLlRyYW5zaXRpb25Gb3JBeGlzID8gZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uc1ZhbHVlIHx8ICgkJC5heGlzICYmICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbkZvckF4aXMpKTtcclxuXHJcblx0XHQkJC51cGRhdGVTaXplcyhpbml0aWFsaXppbmcpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBsZWdlbmQgYW5kIHRyYW5zZm9ybSBlYWNoIGdcclxuXHJcblx0XHRpZiAod3RoLkxlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kKCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyksIG9wdGlvbnMsIHRyYW5zaXRpb25zKTtcclxuXHRcdH0gZWxzZSBpZiAod3RoLkRpbWVuc2lvbikge1xyXG5cdFx0XHQvLyBuZWVkIHRvIHVwZGF0ZSBkaW1lbnNpb24gKGUuZy4gYXhpcy55LnRpY2sudmFsdWVzKSBiZWNhdXNlIHkgdGljayB2YWx1ZXMgc2hvdWxkIGNoYW5nZVxyXG5cdFx0XHQvLyBubyBuZWVkIHRvIHVwZGF0ZSBheGlzIGluIGl0IGJlY2F1c2UgdGhleSB3aWxsIGJlIHVwZGF0ZWQgaW4gcmVkcmF3KClcclxuXHRcdFx0JCQudXBkYXRlRGltZW5zaW9uKHRydWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRleHRcclxuXHRcdCQkLmhhc0RhdGFMYWJlbCgpICYmICQkLnVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2lyY2xlWSBiYXNlZCBvbiB1cGRhdGVkIHBhcmFtZXRlcnNcclxuXHRcdGlmICghJCQuaGFzQXJjVHlwZSgpIHx8IHN0YXRlLmhhc1JhZGFyKSB7XHJcblx0XHRcdCQkLnVwZGF0ZUNpcmNsZVkoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBAVE9ETzogQXhpcyAmIFJhZGFyIHR5cGVcclxuXHRcdGlmICghc3RhdGUucmVzaXppbmcgJiYgKCQkLmhhc1BvaW50VHlwZSgpIHx8IHN0YXRlLmhhc1JhZGFyKSkge1xyXG5cdFx0XHQkJC51cGRhdGVDaXJjbGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgYXhpc1xyXG5cdFx0aWYgKHN0YXRlLmhhc0F4aXMpIHtcclxuXHRcdFx0Ly8gQFRPRE86IE1ha2UgJ2luaXQnIHN0YXRlIHRvIGJlIGFjY2Vzc2libGUgZXZlcnl3aGVyZSBub3QgcGFzc2luZyBhcyBhcmd1bWVudC5cclxuXHRcdFx0JCQuYXhpcy5yZWRyYXdBeGlzKHRhcmdldHNUb1Nob3csIHd0aCwgdHJhbnNpdGlvbnMsIGZsb3csIGluaXRpYWxpemluZyk7XHJcblxyXG5cdFx0XHQvLyBEYXRhIGVtcHR5IGxhYmVsIHBvc2l0aW9uaW5nIGFuZCB0ZXh0LlxyXG5cdFx0XHRjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0ICYmIG1haW4uc2VsZWN0KGB0ZXh0LiR7Q0xBU1MudGV4dH0uJHtDTEFTUy5lbXB0eX1gKVxyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCBzdGF0ZS53aWR0aCAvIDIpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIHN0YXRlLmhlaWdodCAvIDIpXHJcblx0XHRcdFx0LnRleHQoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dClcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIHRhcmdldHNUb1Nob3cubGVuZ3RoID8gXCJub25lXCIgOiBudWxsKTtcclxuXHJcblx0XHRcdC8vIGdyaWRcclxuXHRcdFx0JCQuaGFzR3JpZCgpICYmICQkLnVwZGF0ZUdyaWQoZHVyYXRpb24pO1xyXG5cclxuXHRcdFx0Ly8gcmVjdCBmb3IgcmVnaW9uc1xyXG5cdFx0XHRjb25maWcucmVnaW9ucy5sZW5ndGggJiYgJCQudXBkYXRlUmVnaW9uKGR1cmF0aW9uKTtcclxuXHJcblx0XHRcdC8vIGJhcnNcclxuXHRcdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiAkJC51cGRhdGVCYXIoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHJcblx0XHRcdC8vIGxpbmVzLCBhcmVhcyBhbmQgY2lyY2xlc1xyXG5cdFx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiTGluZVwiKSkge1xyXG5cdFx0XHRcdCQkLnVwZGF0ZUxpbmUoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCQkLmhhc1R5cGVPZihcIkFyZWFcIikpIHtcclxuXHRcdFx0XHQkJC51cGRhdGVBcmVhKGR1cmF0aW9uRm9yRXhpdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNpcmNsZXMgZm9yIHNlbGVjdFxyXG5cdFx0XHQkZWwudGV4dCAmJiBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfWApXHJcblx0XHRcdFx0LmZpbHRlcigkJC5pc0JhclR5cGUuYmluZCgkJCkpXHJcblx0XHRcdFx0LnNlbGVjdEFsbChcImNpcmNsZVwiKVxyXG5cdFx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRcdC8vIGV2ZW50IHJlY3RzIHdpbGwgcmVkcmF3biB3aGVuIGZsb3cgY2FsbGVkXHJcblx0XHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiAhZmxvdyAmJiB3dGguRXZlbnRSZWN0KSB7XHJcblx0XHRcdFx0JCQuYmluZFpvb21FdmVudCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBhcmNcclxuXHRcdFx0JGVsLmFyY3MgJiYgJCQucmVkcmF3QXJjKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQsIHd0aC5UcmFuc2Zvcm0pO1xyXG5cclxuXHRcdFx0Ly8gcmFkYXJcclxuXHRcdFx0JGVsLnJhZGFyICYmICQkLnJlZHJhd1JhZGFyKGR1cmF0aW9uRm9yRXhpdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGl0bGVcclxuXHRcdCQkLnJlZHJhd1RpdGxlICYmICQkLnJlZHJhd1RpdGxlKCk7XHJcblxyXG5cdFx0aW5pdGlhbGl6aW5nICYmICQkLnVwZGF0ZVR5cGVzRWxlbWVudHMoKTtcclxuXHJcblx0XHQkJC5nZW5lcmF0ZVJlZHJhd0xpc3QodGFyZ2V0c1RvU2hvdywgZmxvdywgZHVyYXRpb24sIHd0aC5TdWJjaGFydCk7XHJcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRyZWRyYXdcIiwgb3B0aW9ucywgZHVyYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIHJlZHJhdyBsaXN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldHMgdGFyZ2V0cyBkYXRhIHRvIGJlIHNob3duXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGZsb3cgZmxvdyBvYmplY3RcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gZHVyYXRpb24gdmFsdWVcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhTdWJjaGFydCB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHN1YmNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVJlZHJhd0xpc3QodGFyZ2V0cywgZmxvdzogYW55LCBkdXJhdGlvbjogbnVtYmVyLCB3aXRoU3ViY2hhcnQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2hhcGUgPSAkJC5nZXREcmF3U2hhcGUoKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaGFzQXhpcykge1xyXG5cdFx0XHQvLyBzdWJjaGFydFxyXG5cdFx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyAmJiAkJC5yZWRyYXdTdWJjaGFydCh3aXRoU3ViY2hhcnQsIGR1cmF0aW9uLCBzaGFwZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgZmxvd1xyXG5cdFx0Y29uc3QgZmxvd0ZuID0gZmxvdyAmJiAkJC5nZW5lcmF0ZUZsb3coe1xyXG5cdFx0XHR0YXJnZXRzLFxyXG5cdFx0XHRmbG93LFxyXG5cdFx0XHRkdXJhdGlvbjogZmxvdy5kdXJhdGlvbixcclxuXHRcdFx0c2hhcGUsXHJcblx0XHRcdHh2OiAkJC54di5iaW5kKCQkKVxyXG5cdFx0fSk7XHJcblx0XHRjb25zdCBpc1RyYW5zaXRpb24gPSAoZHVyYXRpb24gfHwgZmxvd0ZuKSAmJiBpc1RhYlZpc2libGUoKTtcclxuXHJcblx0XHQvLyByZWRyYXcgbGlzdFxyXG5cdFx0Y29uc3QgcmVkcmF3TGlzdCA9ICQkLmdldFJlZHJhd0xpc3Qoc2hhcGUsIGZsb3csIGZsb3dGbiwgaXNUcmFuc2l0aW9uKTtcclxuXHJcblx0XHQvLyBjYWxsYmFjayBmdW5jdGlvbiBhZnRlciByZWRyYXcgZW5kc1xyXG5cdFx0Y29uc3QgYWZ0ZXJSZWRyYXcgPSBmbG93IHx8IGNvbmZpZy5vbnJlbmRlcmVkID8gKCkgPT4ge1xyXG5cdFx0XHRmbG93Rm4gJiYgZmxvd0ZuKCk7XHJcblx0XHRcdGNhbGxGbihjb25maWcub25yZW5kZXJlZCwgJCQuYXBpKTtcclxuXHRcdH0gOiBudWxsO1xyXG5cclxuXHRcdGlmIChhZnRlclJlZHJhdykge1xyXG5cdFx0XHQvLyBPbmx5IHVzZSB0cmFuc2l0aW9uIHdoZW4gY3VycmVudCB0YWIgaXMgdmlzaWJsZS5cclxuXHRcdFx0aWYgKGlzVHJhbnNpdGlvbiAmJiByZWRyYXdMaXN0Lmxlbmd0aCkge1xyXG5cdFx0XHRcdC8vIFdhaXQgZm9yIGVuZCBvZiB0cmFuc2l0aW9ucyBmb3IgY2FsbGJhY2tcclxuXHRcdFx0XHRjb25zdCB3YWl0Rm9yRHJhdyA9IGdlbmVyYXRlV2FpdCgpO1xyXG5cclxuXHRcdFx0XHQvLyB0cmFuc2l0aW9uIHNob3VsZCBiZSBkZXJpdmVkIGZyb20gb25lIHRyYW5zaXRpb25cclxuXHRcdFx0XHRkM1RyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0XHRcdC5lYWNoKCgpID0+IHtcclxuXHRcdFx0XHRcdFx0cmVkcmF3TGlzdFxyXG5cdFx0XHRcdFx0XHRcdC5yZWR1Y2UoKGFjYywgdDEpID0+IGFjYy5jb25jYXQodDEpLCBbXSlcclxuXHRcdFx0XHRcdFx0XHQuZm9yRWFjaCh0ID0+IHdhaXRGb3JEcmF3LmFkZCh0KSk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0LmNhbGwod2FpdEZvckRyYXcsIGFmdGVyUmVkcmF3KTtcclxuXHRcdFx0fSBlbHNlIGlmICghc3RhdGUudHJhbnNpdGluZykge1xyXG5cdFx0XHRcdGFmdGVyUmVkcmF3KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgZmFkZWluIGNvbmRpdGlvblxyXG5cdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0c3RhdGUud2l0aG91dEZhZGVJbltpZF0gPSB0cnVlO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Z2V0UmVkcmF3TGlzdChzaGFwZSwgZmxvdywgZmxvd0ZuLCBpc1RyYW5zaXRpb246IGJvb2xlYW4pOiBGdW5jdGlvbltdIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aGFzQXhpcywgaGFzUmFkYXJ9fSA9ICQkO1xyXG5cdFx0Y29uc3Qge2N4LCBjeSwgeEZvclRleHQsIHlGb3JUZXh0fSA9IHNoYXBlLnBvcztcclxuXHRcdGNvbnN0IGxpc3Q6IEZ1bmN0aW9uW10gPSBbXTtcclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHRjb25zdCB7YXJlYSwgYmFyLCBsaW5lfSA9IHNoYXBlLnR5cGU7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRsaXN0LnB1c2goJCQucmVkcmF3R3JpZChpc1RyYW5zaXRpb24pKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5yZWdpb25zLmxlbmd0aCkge1xyXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdSZWdpb24oaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLmhhc1R5cGVPZihcIkxpbmVcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0xpbmUobGluZSwgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdCQkLmhhc1R5cGVPZihcIkFyZWFcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0FyZWEoYXJlYSwgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0JhcihiYXIsIGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0XHQhZmxvdyAmJiBsaXN0LnB1c2goJCQudXBkYXRlR3JpZEZvY3VzKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghJCQuaGFzQXJjVHlwZSgpIHx8IGhhc1JhZGFyKSB7XHJcblx0XHRcdG5vdEVtcHR5KGNvbmZpZy5kYXRhX2xhYmVscykgJiZcclxuXHRcdFx0XHRsaXN0LnB1c2goJCQucmVkcmF3VGV4dCh4Rm9yVGV4dCwgeUZvclRleHQsIGZsb3csIGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgoJCQuaGFzUG9pbnRUeXBlKCkgfHwgaGFzUmFkYXIpICYmICFjb25maWcucG9pbnRfZm9jdXNfb25seSkge1xyXG5cdFx0XHRsaXN0LnB1c2goJCQucmVkcmF3Q2lyY2xlKGN4LCBjeSwgaXNUcmFuc2l0aW9uLCBmbG93Rm4pKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbGlzdDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBbmRSZWRyYXcob3B0aW9uczogYW55ID0ge30pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0bGV0IHRyYW5zaXRpb25zO1xyXG5cclxuXHRcdC8vIHNhbWUgd2l0aCByZWRyYXdcclxuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoVHJhbnNpdGlvblwiLCB0cnVlKTtcclxuXHRcdG9wdGlvbnMud2l0aFRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2Zvcm1cIiwgZmFsc2UpO1xyXG5cdFx0b3B0aW9ucy53aXRoTGVnZW5kID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aExlZ2VuZFwiLCBmYWxzZSk7XHJcblxyXG5cdFx0Ly8gTk9UIHNhbWUgd2l0aCByZWRyYXdcclxuXHRcdG9wdGlvbnMud2l0aFVwZGF0ZVhEb21haW4gPSB0cnVlO1xyXG5cdFx0b3B0aW9ucy53aXRoVXBkYXRlT3JnWERvbWFpbiA9IHRydWU7XHJcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yRXhpdCA9IGZhbHNlO1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtXCIsIG9wdGlvbnMud2l0aFRyYW5zaXRpb24pO1xyXG5cclxuXHRcdC8vIE1FTU86IGNhbGxlZCBpbiB1cGRhdGVMZWdlbmQgaW4gcmVkcmF3IGlmIHdpdGhMZWdlbmRcclxuXHRcdGlmICghKG9wdGlvbnMud2l0aExlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpKSB7XHJcblx0XHRcdGlmIChzdGF0ZS5oYXNBeGlzKSB7XHJcblx0XHRcdFx0dHJhbnNpdGlvbnMgPSAkJC5heGlzLmdlbmVyYXRlVHJhbnNpdGlvbnMoXHJcblx0XHRcdFx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yQXhpcyA/IGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uIDogMFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFVwZGF0ZSBzY2FsZXNcclxuXHRcdFx0JCQudXBkYXRlU2NhbGVzKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSBnIHBvc2l0aW9uc1xyXG5cdFx0XHQkJC50cmFuc2Zvcm1BbGwob3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSwgdHJhbnNpdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERyYXcgd2l0aCBuZXcgc2l6ZXMgJiBzY2FsZXNcclxuXHRcdCQkLnJlZHJhdyhvcHRpb25zLCB0cmFuc2l0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3V2l0aG91dFJlc2NhbGUoKSB7XHJcblx0XHR0aGlzLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhZOiBmYWxzZSxcclxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcclxuXHRcdFx0d2l0aEV2ZW50UmVjdDogZmFsc2UsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yQXhpczogZmFsc2VcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNjYWxlVGltZSBhcyBkM1NjYWxlVGltZSxcclxuXHRzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyXHJcbn0gZnJvbSBcImQzLXNjYWxlXCI7XHJcbmltcG9ydCB7aXNTdHJpbmcsIGlzVmFsdWUsIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0U2NhbGUobWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBmb3JUaW1lc2VyaWVzPzogYm9vbGVhbikge1xyXG5cdFx0cmV0dXJuIChmb3JUaW1lc2VyaWVzID9cclxuXHRcdFx0ZDNTY2FsZVRpbWUoKSA6IGQzU2NhbGVMaW5lYXIoKVxyXG5cdFx0KS5yYW5nZShbbWluLCBtYXhdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgeCBBeGlzIHNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiBNaW4gdmFsdWVcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRvbWFpbiBEb21haW4gdmFsdWVcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvZmZzZXQgVGhlIG9mZnNldCBnZXR0ZXIgdG8gYmUgc3VtXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBzY2FsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WFNjYWxlKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgZG9tYWluOiBudW1iZXJbXSwgb2Zmc2V0OiBGdW5jdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZS56b29tIHx8ICQkLmdldFNjYWxlKG1pbiwgbWF4LCAkJC5heGlzLmlzVGltZVNlcmllcygpKTtcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKFxyXG5cdFx0XHRkb21haW4gPyBzY2FsZS5kb21haW4oZG9tYWluKSA6IHNjYWxlLFxyXG5cdFx0XHRvZmZzZXRcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHkgQXhpcyBzY2FsZSBmdW5jdGlvblxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gTWluIHZhbHVlXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1heCBNYXggdmFsdWVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBkb21haW4gRG9tYWluIHZhbHVlXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBTY2FsZSBmdW5jdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WVNjYWxlKG1pbjogbnVtYmVyLCBtYXg6IG51bWJlciwgZG9tYWluOiBudW1iZXJbXSk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNjYWxlID0gJCQuZ2V0U2NhbGUobWluLCBtYXgsICQkLmF4aXMuaXNUaW1lU2VyaWVzWSgpKTtcclxuXHJcblx0XHRkb21haW4gJiYgc2NhbGUuZG9tYWluKGRvbWFpbik7XHJcblxyXG5cdFx0cmV0dXJuIHNjYWxlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB5IEF4aXMgc2NhbGVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgQXhpcyBpZFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdWIgV2VhdGhlciBpcyBzdWIgQXhpc1xyXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gU2NhbGUgZnVuY3Rpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFlTY2FsZUJ5SWQoaWQ6IHN0cmluZywgaXNTdWIgPSBmYWxzZSk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0IGlzWTIgPSB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCI7XHJcblx0XHRjb25zdCBrZXkgPSBpc1N1YiA/IChpc1kyID8gXCJzdWJZMlwiIDogXCJzdWJZXCIpIDogKGlzWTIgPyBcInkyXCIgOiBcInlcIik7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2NhbGVba2V5XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgY3VzdG9taXplZCBzY2FsZVxyXG5cdCAqIEBwYXJhbSB7ZDMuc2NhbGVMaW5lYXJ8ZDMuc2NhbGVUaW1lfSBzY2FsZVZhbHVlIFNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb2Zmc2V0VmFsdWUgT2Zmc2V0IGdldHRlciB0byBiZSBzdW1cclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRDdXN0b21pemVkU2NhbGUoc2NhbGVWYWx1ZTogRnVuY3Rpb24gfCBhbnksIG9mZnNldFZhbHVlKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgfHwgKCgpID0+ICQkLmF4aXMueC50aWNrT2Zmc2V0KCkpO1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSBmdW5jdGlvbihkLCByYXcpIHtcclxuXHRcdFx0Y29uc3QgdiA9IHNjYWxlVmFsdWUoZCkgKyBvZmZzZXQoKTtcclxuXHJcblx0XHRcdHJldHVybiByYXcgPyB2IDogTWF0aC5jZWlsKHYpO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBjb3B5IG9yaWdpbmFsIHNjYWxlIG1ldGhvZHNcclxuXHRcdGZvciAoY29uc3Qga2V5IGluIHNjYWxlVmFsdWUpIHtcclxuXHRcdFx0c2NhbGVba2V5XSA9IHNjYWxlVmFsdWVba2V5XTtcclxuXHRcdH1cclxuXHJcblx0XHRzY2FsZS5vcmdEb21haW4gPSAoKSA9PiBzY2FsZVZhbHVlLmRvbWFpbigpO1xyXG5cdFx0c2NhbGUub3JnU2NhbGUgPSAoKSA9PiBzY2FsZVZhbHVlO1xyXG5cclxuXHRcdC8vIGRlZmluZSBjdXN0b20gZG9tYWluKCkgZm9yIGNhdGVnb3JpemVkIGF4aXNcclxuXHRcdGlmICgkJC5heGlzLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRzY2FsZS5kb21haW4gPSBmdW5jdGlvbihkb21haW5WYWx1ZSkge1xyXG5cdFx0XHRcdGxldCBkb21haW4gPSBkb21haW5WYWx1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRkb21haW4gPSB0aGlzLm9yZ0RvbWFpbigpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBbZG9tYWluWzBdLCBkb21haW5bMV0gKyAxXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNjYWxlVmFsdWUuZG9tYWluKGRvbWFpbik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBzY2FsZTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2NhbGU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHNjYWxlXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc0luaXQgUGFyYW0gaXMgZ2l2ZW4gYXQgdGhlIGluaXQgcmVuZGVyaW5nXHJcblx0ICogQHBhcmFtIHtib29sZWFufSB1cGRhdGVYRG9tYWluIElmIHVwZGF0ZSB4IGRvbWFpblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlU2NhbGVzKGlzSW5pdDogYm9vbGVhbiwgdXBkYXRlWERvbWFpbiA9IHRydWUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtheGlzLCBjb25maWcsIGZvcm1hdCwgb3JnLCBzY2FsZSxcclxuXHRcdFx0c3RhdGU6IHt3aWR0aCwgaGVpZ2h0LCB3aWR0aDIsIGhlaWdodDIsIGhhc0F4aXN9XHJcblx0XHR9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMpIHtcclxuXHRcdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBlZGdlc1xyXG5cdFx0XHRjb25zdCBtaW4gPSB7XHJcblx0XHRcdFx0eDogaXNSb3RhdGVkID8gMSA6IDAsXHJcblx0XHRcdFx0eTogaXNSb3RhdGVkID8gMCA6IGhlaWdodCxcclxuXHRcdFx0XHRzdWJYOiBpc1JvdGF0ZWQgPyAxIDogMCxcclxuXHRcdFx0XHRzdWJZOiBpc1JvdGF0ZWQgPyAwIDogaGVpZ2h0MlxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y29uc3QgbWF4ID0ge1xyXG5cdFx0XHRcdHg6IGlzUm90YXRlZCA/IGhlaWdodCA6IHdpZHRoLFxyXG5cdFx0XHRcdHk6IGlzUm90YXRlZCA/IHdpZHRoIDogMSxcclxuXHRcdFx0XHRzdWJYOiBpc1JvdGF0ZWQgPyBoZWlnaHQgOiB3aWR0aCxcclxuXHRcdFx0XHRzdWJZOiBpc1JvdGF0ZWQgPyB3aWR0aDIgOiAxXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgc2NhbGVzXHJcblx0XHRcdC8vIHggQXhpc1xyXG5cdFx0XHRjb25zdCB4RG9tYWluID0gdXBkYXRlWERvbWFpbiAmJiBzY2FsZS54ICYmIHNjYWxlLngub3JnRG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IHhTdWJEb21haW4gPSB1cGRhdGVYRG9tYWluICYmIG9yZy54RG9tYWluO1xyXG5cclxuXHRcdFx0c2NhbGUueCA9ICQkLmdldFhTY2FsZShtaW4ueCwgbWF4LngsIHhEb21haW4sICgpID0+IGF4aXMueC50aWNrT2Zmc2V0KCkpO1xyXG5cdFx0XHRzY2FsZS5zdWJYID0gJCQuZ2V0WFNjYWxlKG1pbi54LCBtYXgueCwgeFN1YkRvbWFpbiwgZCA9PiAoZCAlIDEgPyAwIDogYXhpcy5zdWJYLnRpY2tPZmZzZXQoKSkpO1xyXG5cclxuXHRcdFx0Zm9ybWF0LnhBeGlzVGljayA9IGF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCk7XHJcblxyXG5cdFx0XHRheGlzLnNldEF4aXMoXCJ4XCIsIHNjYWxlLngsIGNvbmZpZy5heGlzX3hfdGlja19vdXRlciwgaXNJbml0KTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuc3ViY2hhcnRfc2hvdykge1xyXG5cdFx0XHRcdGF4aXMuc2V0QXhpcyhcInN1YlhcIiwgc2NhbGUuc3ViWCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB5IEF4aXNcclxuXHRcdFx0c2NhbGUueSA9ICQkLmdldFlTY2FsZShtaW4ueSwgbWF4LnksIHNjYWxlLnkgPyBzY2FsZS55LmRvbWFpbigpIDogY29uZmlnLmF4aXNfeV9kZWZhdWx0KTtcclxuXHRcdFx0c2NhbGUuc3ViWSA9ICQkLmdldFlTY2FsZShcclxuXHRcdFx0XHRtaW4uc3ViWSwgbWF4LnN1YlksIHNjYWxlLnN1YlkgPyBzY2FsZS5zdWJZLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeV9kZWZhdWx0KTtcclxuXHJcblx0XHRcdGF4aXMuc2V0QXhpcyhcInlcIiwgc2NhbGUueSwgY29uZmlnLmF4aXNfeV90aWNrX291dGVyLCBpc0luaXQpO1xyXG5cclxuXHRcdFx0Ly8geTIgQXhpc1xyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfeTJfc2hvdykge1xyXG5cdFx0XHRcdHNjYWxlLnkyID0gJCQuZ2V0WVNjYWxlKG1pbi55LCBtYXgueSwgc2NhbGUueTIgPyBzY2FsZS55Mi5kb21haW4oKSA6IGNvbmZpZy5heGlzX3kyX2RlZmF1bHQpO1xyXG5cdFx0XHRcdHNjYWxlLnN1YlkyID0gJCQuZ2V0WVNjYWxlKG1pbi5zdWJZLCBtYXguc3ViWSxcclxuXHRcdFx0XHRcdHNjYWxlLnN1YlkyID8gc2NhbGUuc3ViWTIuZG9tYWluKCkgOiBjb25maWcuYXhpc195Ml9kZWZhdWx0KTtcclxuXHJcblx0XHRcdFx0YXhpcy5zZXRBeGlzKFwieTJcIiwgc2NhbGUueTIsIGNvbmZpZy5heGlzX3kyX3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHVwZGF0ZSBmb3IgYXJjXHJcblx0XHRcdCQkLnVwZGF0ZUFyYyAmJiAkJC51cGRhdGVBcmMoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHpvb20gb3IgdW56b29tZWQgc2NhbGVkIHZhbHVlXHJcblx0ICogQHBhcmFtIHtEYXRlfG51bWJlcnxvYmplY3R9IGQgRGF0YSB2YWx1ZVxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ8bnVsbH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHh4KGQpOiBudW1iZXIgfCBudWxsIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlOiB7eCwgem9vbX19ID0gJCQ7XHJcblx0XHRjb25zdCBmbiA9IGNvbmZpZy56b29tX2VuYWJsZWQgJiYgem9vbSA/XHJcblx0XHRcdHpvb20gOiB4O1xyXG5cclxuXHRcdHJldHVybiBkID8gZm4oaXNWYWx1ZShkLngpID8gZC54IDogZCkgOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdHh2KGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgc2NhbGU6IHt4fX0gPSAkJDtcclxuXHRcdGxldCB2YWx1ZSA9ICQkLmdldEJhc2VWYWx1ZShkKTtcclxuXHJcblx0XHRpZiAoYXhpcy5pc1RpbWVTZXJpZXMoKSkge1xyXG5cdFx0XHR2YWx1ZSA9IHBhcnNlRGF0ZS5jYWxsKCQkLCB2YWx1ZSk7XHJcblx0XHR9IGVsc2UgaWYgKGF4aXMuaXNDYXRlZ29yaXplZCgpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG5cdFx0XHR2YWx1ZSA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHZhbHVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHgodmFsdWUpKTtcclxuXHR9LFxyXG5cclxuXHR5dihkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzY2FsZToge3ksIHkyfX0gPSAkJDtcclxuXHRcdGNvbnN0IHlTY2FsZSA9IGQuYXhpcyAmJiBkLmF4aXMgPT09IFwieTJcIiA/IHkyIDogeTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHlTY2FsZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcclxuXHR9LFxyXG5cclxuXHRzdWJ4eChkKTogbnVtYmVyIHwgbnVsbCB7XHJcblx0XHRyZXR1cm4gZCA/IHRoaXMuc2NhbGUuc3ViWChkLngpIDogbnVsbDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtpc1ZhbHVlLCBjZWlsMTAsIGNhcGl0YWxpemV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge0F4aXNUeXBlfSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBVcGRhdGUgY29udGFpbmVyIHNpemVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldENvbnRhaW5lclNpemUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblxyXG5cdFx0c3RhdGUuY3VycmVudC53aWR0aCA9ICQkLmdldEN1cnJlbnRXaWR0aCgpO1xyXG5cdFx0c3RhdGUuY3VycmVudC5oZWlnaHQgPSAkJC5nZXRDdXJyZW50SGVpZ2h0KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudFdpZHRoKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5zaXplX3dpZHRoIHx8ICQkLmdldFBhcmVudFdpZHRoKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudEhlaWdodCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGggPSBjb25maWcuc2l6ZV9oZWlnaHQgfHwgJCQuZ2V0UGFyZW50SGVpZ2h0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGggPiAwID8gaCA6IDMyMCAvICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBBeGlzIHNpemUgYWNjb3JkaW5nIGl0cyBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkIHZhbHVlIC0geCwgeSBvciB5MlxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHNpemUgQXhpcyBzaXplIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRBeGlzU2l6ZShpZDogQXhpc1R5cGUpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRyZXR1cm4gKGlzUm90YXRlZCAmJiBpZCA9PT0gXCJ4XCIpIHx8ICghaXNSb3RhdGVkICYmIC95Mj8vLnRlc3QoaWQpKSA/XHJcblx0XHRcdCQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkLCB0cnVlKSA6XHJcblx0XHRcdCQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ1RvcCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZy5heGlzX3kyX2F4ZXMubGVuZ3RoO1xyXG5cclxuXHRcdGxldCBwYWRkaW5nID0gaXNWYWx1ZShjb25maWcucGFkZGluZ190b3ApID9cclxuXHRcdFx0Y29uZmlnLnBhZGRpbmdfdG9wIDogMDtcclxuXHJcblx0XHRpZiAoJGVsLnRpdGxlICYmICRlbC50aXRsZS5ub2RlKCkpIHtcclxuXHRcdFx0cGFkZGluZyArPSAkJC5nZXRUaXRsZVBhZGRpbmcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYXhlc0xlbiAmJiBjb25maWcuYXhpc19yb3RhdGVkKSB7XHJcblx0XHRcdHBhZGRpbmcgKz0gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ5MlwiKSAqIGF4ZXNMZW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhZGRpbmc7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudFBhZGRpbmdCb3R0b20oKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBheGlzSWQgPSBjb25maWcuYXhpc19yb3RhdGVkID8gXCJ5XCIgOiBcInhcIjtcclxuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X2F4ZXNgXS5sZW5ndGg7XHJcblx0XHRjb25zdCBwYWRkaW5nID0gaXNWYWx1ZShjb25maWcucGFkZGluZ19ib3R0b20pID9cclxuXHRcdFx0Y29uZmlnLnBhZGRpbmdfYm90dG9tIDogMDtcclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZyArIChcclxuXHRcdFx0YXhlc0xlbiA/ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGF4aXNJZCkgKiBheGVzTGVuIDogMFxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ0xlZnQod2l0aG91dFJlY29tcHV0ZT86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtoYXNBeGlzfX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBheGlzSWQgPSBpc1JvdGF0ZWQgPyBcInhcIiA6IFwieVwiO1xyXG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fYXhlc2BdLmxlbmd0aDtcclxuXHRcdGNvbnN0IGF4aXNXaWR0aCA9IGhhc0F4aXMgPyAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChheGlzSWQsIHdpdGhvdXRSZWNvbXB1dGUpIDogMDtcclxuXHRcdGxldCBwYWRkaW5nO1xyXG5cclxuXHRcdGlmIChpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2xlZnQpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjb25maWcucGFkZGluZ19sZWZ0O1xyXG5cdFx0fSBlbHNlIGlmIChoYXNBeGlzICYmIGlzUm90YXRlZCkge1xyXG5cdFx0XHRwYWRkaW5nID0gIWNvbmZpZy5heGlzX3hfc2hvdyA/XHJcblx0XHRcdFx0MSA6IE1hdGgubWF4KGNlaWwxMChheGlzV2lkdGgpLCA0MCk7XHJcblx0XHR9IGVsc2UgaWYgKGhhc0F4aXMgJiYgKCFjb25maWcuYXhpc195X3Nob3cgfHwgY29uZmlnLmF4aXNfeV9pbm5lcikpIHsgLy8gJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWRcclxuXHRcdFx0cGFkZGluZyA9ICQkLmF4aXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oXCJ5XCIpLmlzT3V0ZXIgPyAzMCA6IDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYWRkaW5nID0gY2VpbDEwKGF4aXNXaWR0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhZGRpbmcgKyAoYXhpc1dpZHRoICogYXhlc0xlbik7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudFBhZGRpbmdSaWdodCh3aXRob3V0VGlja1RleHRPdmVyZmxvdyA9IGZhbHNlKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkZWZhdWx0UGFkZGluZyA9IDEwO1xyXG5cdFx0Y29uc3QgbGVnZW5kV2lkdGhPblJpZ2h0ID0gJCQuc3RhdGUuaXNMZWdlbmRSaWdodCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgKyAyMCA6IDA7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnLmF4aXNfeTJfYXhlcy5sZW5ndGg7XHJcblx0XHRjb25zdCBheGlzV2lkdGggPSAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChcInkyXCIpO1xyXG5cdFx0Y29uc3QgeEF4aXNUaWNrVGV4dE92ZXJmbG93ID0gd2l0aG91dFRpY2tUZXh0T3ZlcmZsb3cgP1xyXG5cdFx0XHQwIDogJCQuYXhpcy5nZXRYQXhpc1RpY2tUZXh0WTJPdmVyZmxvdyhkZWZhdWx0UGFkZGluZyk7XHJcblx0XHRsZXQgcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNWYWx1ZShjb25maWcucGFkZGluZ19yaWdodCkpIHtcclxuXHRcdFx0cGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nX3JpZ2h0ICsgMTsgLy8gMSBpcyBuZWVkZWQgbm90IHRvIGhpZGUgdGljayBsaW5lXHJcblx0XHR9IGVsc2UgaWYgKCQkLmF4aXMgJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRwYWRkaW5nID0gZGVmYXVsdFBhZGRpbmcgKyBsZWdlbmRXaWR0aE9uUmlnaHQ7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmF4aXMgJiYgKCFjb25maWcuYXhpc195Ml9zaG93IHx8IGNvbmZpZy5heGlzX3kyX2lubmVyKSkgeyAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxyXG5cdFx0XHRwYWRkaW5nID0gTWF0aC5tYXgoXHJcblx0XHRcdFx0MiArIGxlZ2VuZFdpZHRoT25SaWdodCArICgkJC5heGlzLmdldEF4aXNMYWJlbFBvc2l0aW9uKFwieTJcIikuaXNPdXRlciA/IDIwIDogMCksXHJcblx0XHRcdFx0eEF4aXNUaWNrVGV4dE92ZXJmbG93XHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYWRkaW5nID0gTWF0aC5tYXgoY2VpbDEwKGF4aXNXaWR0aCkgKyBsZWdlbmRXaWR0aE9uUmlnaHQsIHhBeGlzVGlja1RleHRPdmVyZmxvdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhZGRpbmcgKyAoYXhpc1dpZHRoICogYXhlc0xlbik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBwYXJlbnQgcmVjdCBlbGVtZW50J3Mgc2l6ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgcHJvcGVydHkvYXR0cmlidXRlIG5hbWVcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0UGFyZW50UmVjdFZhbHVlKGtleSk6IG51bWJlciB7XHJcblx0XHRjb25zdCBvZmZzZXROYW1lID0gYG9mZnNldCR7Y2FwaXRhbGl6ZShrZXkpfWA7XHJcblx0XHRsZXQgcGFyZW50ID0gdGhpcy4kZWwuY2hhcnQubm9kZSgpO1xyXG5cdFx0bGV0IHY7XHJcblxyXG5cdFx0d2hpbGUgKCF2ICYmIHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHR2ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV07XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRpZiAob2Zmc2V0TmFtZSBpbiBwYXJlbnQpIHtcclxuXHRcdFx0XHRcdC8vIEluIElFIGluIGNlcnRhaW4gY2FzZXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XHJcblx0XHRcdFx0XHQvLyB3aWxsIGNhdXNlIGFuIFwidW5zcGVjaWZpZWQgZXJyb3JcIlxyXG5cdFx0XHRcdFx0diA9IHBhcmVudFtvZmZzZXROYW1lXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChrZXkgPT09IFwid2lkdGhcIikge1xyXG5cdFx0XHQvLyBTb21ldGltZXMgZWxlbWVudCdzIHdpZHRoIHZhbHVlIGlzIGluY29ycmVjdChleC4gZmxleCBjb250YWluZXIpXHJcblx0XHRcdC8vIEluIHRoaXMgY2FzZSwgdXNlIGJvZHkncyBvZmZzZXRXaWR0aCBpbnN0ZWFkLlxyXG5cdFx0XHRjb25zdCBib2R5V2lkdGggPSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xyXG5cclxuXHRcdFx0diA+IGJvZHlXaWR0aCAmJiAodiA9IGJvZHlXaWR0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHY7XHJcblx0fSxcclxuXHJcblx0Z2V0UGFyZW50V2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFBhcmVudFJlY3RWYWx1ZShcIndpZHRoXCIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBhcmVudEhlaWdodCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgaCA9IHRoaXMuJGVsLmNoYXJ0LnN0eWxlKFwiaGVpZ2h0XCIpO1xyXG5cclxuXHRcdHJldHVybiBoLmluZGV4T2YoXCJweFwiKSA+IDAgPyBwYXJzZUludChoLCAxMCkgOiAwO1xyXG5cdH0sXHJcblxyXG5cdGdldFN2Z0xlZnQod2l0aG91dFJlY29tcHV0ZT86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzTGVmdEF4aXNSZWN0ID0gY29uZmlnLmF4aXNfcm90YXRlZCB8fCAoIWNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgIWNvbmZpZy5heGlzX3lfaW5uZXIpO1xyXG5cdFx0Y29uc3QgbGVmdEF4aXNDbGFzcyA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBDTEFTUy5heGlzWCA6IENMQVNTLmF4aXNZO1xyXG5cdFx0Y29uc3QgbGVmdEF4aXMgPSAkZWwubWFpbi5zZWxlY3QoYC4ke2xlZnRBeGlzQ2xhc3N9YCkubm9kZSgpO1xyXG5cdFx0Y29uc3Qgc3ZnUmVjdCA9IGxlZnRBeGlzICYmIGhhc0xlZnRBeGlzUmVjdCA/IGxlZnRBeGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge3JpZ2h0OiAwfTtcclxuXHRcdGNvbnN0IGNoYXJ0UmVjdCA9ICRlbC5jaGFydC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHRjb25zdCBoYXNBcmMgPSAkJC5oYXNBcmNUeXBlKCk7XHJcblx0XHRjb25zdCBzdmdMZWZ0ID0gc3ZnUmVjdC5yaWdodCAtIGNoYXJ0UmVjdC5sZWZ0IC1cclxuXHRcdFx0KGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQod2l0aG91dFJlY29tcHV0ZSkpO1xyXG5cclxuXHRcdHJldHVybiBzdmdMZWZ0ID4gMCA/IHN2Z0xlZnQgOiAwO1xyXG5cdH0sXHJcblxyXG5cdGdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkOiBBeGlzVHlwZSwgd2l0aG91dFJlY29tcHV0ZT86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdGlmICgkJC5heGlzKSB7XHJcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gJCQuYXhpcyAmJiAkJC5heGlzLmdldExhYmVsUG9zaXRpb25CeUlkKGlkKTtcclxuXHJcblx0XHRcdHJldHVybiAkJC5heGlzLmdldE1heFRpY2tXaWR0aChpZCwgd2l0aG91dFJlY29tcHV0ZSkgK1xyXG5cdFx0XHRcdChwb3NpdGlvbi5pc0lubmVyID8gMjAgOiA0MCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gNDA7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQ6IEF4aXNUeXBlKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3Qge2N1cnJlbnQsIHJvdGF0ZWRQYWRkaW5nLCBpc0xlZ2VuZFJpZ2h0LCBpc0xlZ2VuZEluc2V0fSA9IHN0YXRlO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCBoID0gMzA7XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInhcIiAmJiAhY29uZmlnLmF4aXNfeF9zaG93KSB7XHJcblx0XHRcdHJldHVybiA4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ4XCIgJiYgY29uZmlnLmF4aXNfeF9oZWlnaHQpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfaGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ5XCIgJiYgIWNvbmZpZy5heGlzX3lfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmxlZ2VuZF9zaG93ICYmXHJcblx0XHRcdFx0IWlzTGVnZW5kUmlnaHQgJiZcclxuXHRcdFx0XHQhaXNMZWdlbmRJbnNldCA/IDEwIDogMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaWQgPT09IFwieTJcIiAmJiAhY29uZmlnLmF4aXNfeTJfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gcm90YXRlZFBhZGRpbmcudG9wO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJvdGF0ZSA9ICQkLmdldEF4aXNUaWNrUm90YXRlKGlkKTtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgeC95IGF4aXMgaGVpZ2h0IHdoZW4gdGljayByb3RhdGVkXHJcblx0XHRpZiAoXHJcblx0XHRcdCgoaWQgPT09IFwieFwiICYmICFpc1JvdGF0ZWQpIHx8ICgveTI/Ly50ZXN0KGlkKSAmJiBpc1JvdGF0ZWQpKSAmJiByb3RhdGVcclxuXHRcdCkge1xyXG5cdFx0XHRoID0gMzAgK1xyXG5cdFx0XHRcdCQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkKSAqXHJcblx0XHRcdFx0TWF0aC5jb3MoTWF0aC5QSSAqICg5MCAtIHJvdGF0ZSkgLyAxODApO1xyXG5cclxuXHRcdFx0aWYgKCFjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lICYmIGN1cnJlbnQuaGVpZ2h0KSB7XHJcblx0XHRcdFx0aWYgKGggPiBjdXJyZW50LmhlaWdodCAvIDIpIHtcclxuXHRcdFx0XHRcdGggPSBjdXJyZW50LmhlaWdodCAvIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGggK1xyXG5cdFx0XHQoJCQuYXhpcy5nZXRMYWJlbFBvc2l0aW9uQnlJZChpZCkuaXNJbm5lciA/IDAgOiAxMCkgK1xyXG5cdFx0XHQoaWQgPT09IFwieTJcIiAmJiAhaXNSb3RhdGVkID8gLTEwIDogMCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRSZWN0V2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBNYXRoLm1heCgwLCB0aGlzLmF4aXMueC50aWNrSW50ZXJ2YWwoKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGF4aXMgdGljayB0ZXN0IHJvdGF0ZSB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkXHJcblx0ICogQHJldHVybnMge251bWJlcn0gcm90YXRlIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRBeGlzVGlja1JvdGF0ZShpZDogQXhpc1R5cGUpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHRcdGxldCByb3RhdGUgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19yb3RhdGVgXTtcclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiKSB7XHJcblx0XHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSBheGlzLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHRcdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gYXhpcy5pc1RpbWVTZXJpZXMoKTtcclxuXHRcdFx0Y29uc3QgYWxsb3dlZFhBeGlzVHlwZXMgPSBpc0NhdGVnb3JpemVkIHx8IGlzVGltZVNlcmllcztcclxuXHRcdFx0bGV0IHRpY2tDb3VudCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfeF90aWNrX2ZpdCAmJiBhbGxvd2VkWEF4aXNUeXBlcykge1xyXG5cdFx0XHRcdHRpY2tDb3VudCA9IHN0YXRlLmN1cnJlbnQubWF4VGlja1dpZHRocy54LnRpY2tzLmxlbmd0aCArIChpc1RpbWVTZXJpZXMgPyAtMSA6IDEpO1xyXG5cclxuXHRcdFx0XHRpZiAodGlja0NvdW50ICE9PSBzdGF0ZS5heGlzLngudGlja0NvdW50KSB7XHJcblx0XHRcdFx0XHRzdGF0ZS5heGlzLngucGFkZGluZyA9ICQkLmF4aXMuZ2V0WEF4aXNQYWRkaW5nKHRpY2tDb3VudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGF0ZS5heGlzLngudGlja0NvdW50ID0gdGlja0NvdW50O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoJGVsLnN2ZyAmJlxyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19maXQgJiZcclxuXHRcdFx0XHQhY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSAmJlxyXG5cdFx0XHRcdCFjb25maWcuYXhpc194X3RpY2tfY3VsbGluZyAmJlxyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19hdXRvcm90YXRlICYmXHJcblx0XHRcdFx0YWxsb3dlZFhBeGlzVHlwZXNcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0cm90YXRlID0gJCQubmVlZFRvUm90YXRlWEF4aXNUaWNrVGV4dHMoKSA/XHJcblx0XHRcdFx0XHRjb25maWcuYXhpc194X3RpY2tfcm90YXRlIDogMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByb3RhdGU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgd2VhdGhlciBheGlzIHRpY2sgdGV4dCBuZWVkcyB0byBiZSByb3RhdGVkXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRuZWVkVG9Sb3RhdGVYQXhpc1RpY2tUZXh0cygpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge2F4aXMsIGN1cnJlbnR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgeEF4aXNMZW5ndGggPSBjdXJyZW50LndpZHRoIC1cclxuXHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KGZhbHNlKSAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQodHJ1ZSk7XHJcblx0XHRjb25zdCB0aWNrQ291bnRXaXRoUGFkZGluZyA9IGF4aXMueC50aWNrQ291bnQgK1xyXG5cdFx0XHRheGlzLngucGFkZGluZy5sZWZ0ICsgYXhpcy54LnBhZGRpbmcucmlnaHQ7XHJcblxyXG5cdFx0Y29uc3QgbWF4VGlja1dpZHRoID0gJCQuYXhpcy5nZXRNYXhUaWNrV2lkdGgoXCJ4XCIpO1xyXG5cdFx0Y29uc3QgdGlja0xlbmd0aCA9ICh4QXhpc0xlbmd0aCAvIHRpY2tDb3VudFdpdGhQYWRkaW5nKSB8fCAwO1xyXG5cclxuXHRcdHJldHVybiBtYXhUaWNrV2lkdGggPiB0aWNrTGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZURpbWVuc2lvbih3aXRob3V0QXhpcz86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aGFzQXhpc30sICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoaGFzQXhpcyAmJiAhd2l0aG91dEF4aXMpIHtcclxuXHRcdFx0aWYgKCQkLmF4aXMueCAmJiBjb25maWcuYXhpc19yb3RhdGVkKSB7XHJcblx0XHRcdFx0JCQuYXhpcy54LmNyZWF0ZSgkZWwuYXhpcy54KTtcclxuXHRcdFx0XHQkJC5heGlzLnN1YlggJiYgJCQuYXhpcy5zdWJYLmNyZWF0ZSgkZWwuYXhpcy5zdWJYKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQkJC5heGlzLnkgJiYgJCQuYXhpcy55LmNyZWF0ZSgkZWwuYXhpcy55KTtcclxuXHRcdFx0XHQkJC5heGlzLnkyICYmICQkLmF4aXMueTIuY3JlYXRlKCRlbC5heGlzLnkyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHBhc3MgJ3dpdGhvdXRBeGlzJyBwYXJhbSB0byBub3QgYW5pbWF0ZSBhdCB0aGUgaW5pdCByZW5kZXJpbmdcclxuXHRcdCQkLnVwZGF0ZVNjYWxlcyh3aXRob3V0QXhpcyk7XHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblx0XHQkJC50cmFuc2Zvcm1BbGwoZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVN2Z1NpemUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGUsICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0c3ZnXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUuY3VycmVudC53aWR0aClcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgc3RhdGUuY3VycmVudC5oZWlnaHQpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5oYXNBeGlzKSB7XHJcblx0XHRcdGNvbnN0IGJydXNoID0gc3ZnLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9IC5vdmVybGF5YCk7XHJcblx0XHRcdGNvbnN0IGJydXNoU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcclxuXHJcblx0XHRcdGlmIChicnVzaC5zaXplKCkpIHtcclxuXHRcdFx0XHRicnVzaFNpemUud2lkdGggPSArYnJ1c2guYXR0cihcIndpZHRoXCIpO1xyXG5cdFx0XHRcdGJydXNoU2l6ZS5oZWlnaHQgPSArYnJ1c2guYXR0cihcImhlaWdodFwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdEFsbChbYCMke3N0YXRlLmNsaXAuaWR9YCwgYCMke3N0YXRlLmNsaXAuaWRHcmlkfWBdKVxyXG5cdFx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBzdGF0ZS53aWR0aClcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCBzdGF0ZS5oZWlnaHQpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFhBeGlzfWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgJCQuZ2V0WEF4aXNDbGlwWC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgJCQuZ2V0WEF4aXNDbGlwWS5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmdldFhBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldFhBeGlzQ2xpcEhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0XHRzdmcuc2VsZWN0KGAjJHtzdGF0ZS5jbGlwLmlkWUF4aXN9YClcclxuXHRcdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCAkJC5nZXRZQXhpc0NsaXBYLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCAkJC5nZXRZQXhpc0NsaXBZLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQuZ2V0WUF4aXNDbGlwV2lkdGguYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0WUF4aXNDbGlwSGVpZ2h0LmJpbmQoJCQpKTtcclxuXHJcblx0XHRcdHN0YXRlLmNsaXAuaWRTdWJjaGFydCAmJiBzdmcuc2VsZWN0KGAjJHtzdGF0ZS5jbGlwLmlkU3ViY2hhcnR9YClcclxuXHRcdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUud2lkdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgYnJ1c2hTaXplLmhlaWdodCk7XHJcblxyXG5cdFx0XHRzdmcuc2VsZWN0KGAuJHtDTEFTUy56b29tUmVjdH1gKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUud2lkdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgc3RhdGUuaGVpZ2h0KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgc2l6ZSB2YWx1ZXNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSW5pdCBJZiBpcyBjYWxsZWQgYXQgaW5pdGlhbGl6YXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVNpemVzKGlzSW5pdD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcclxuXHJcblx0XHQhaXNJbml0ICYmICQkLnNldENvbnRhaW5lclNpemUoKTtcclxuXHJcblx0XHRjb25zdCBjdXJyTGVnZW5kID0ge1xyXG5cdFx0XHR3aWR0aDogbGVnZW5kID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSA6IDAsXHJcblx0XHRcdGhlaWdodDogbGVnZW5kID8gJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgOiAwXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGxlZ2VuZEhlaWdodEZvckJvdHRvbSA9IHN0YXRlLmlzTGVnZW5kUmlnaHQgfHwgc3RhdGUuaXNMZWdlbmRJbnNldCA/IDAgOiBjdXJyTGVnZW5kLmhlaWdodDtcclxuXHRcdGNvbnN0IHhBeGlzSGVpZ2h0ID0gaXNSb3RhdGVkIHx8IGhhc0FyYyA/IDAgOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInhcIik7XHJcblxyXG5cdFx0Y29uc3Qgc3ViY2hhcnRYQXhpc0hlaWdodCA9IGNvbmZpZy5zdWJjaGFydF9heGlzX3hfc2hvdyAmJiBjb25maWcuc3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93ID9cclxuXHRcdFx0eEF4aXNIZWlnaHQgOiAzMDtcclxuXHRcdGNvbnN0IHN1YmNoYXJ0SGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgIWhhc0FyYyA/XHJcblx0XHRcdChjb25maWcuc3ViY2hhcnRfc2l6ZV9oZWlnaHQgKyBzdWJjaGFydFhBeGlzSGVpZ2h0KSA6IDA7XHJcblxyXG5cdFx0Ly8gZm9yIG1haW5cclxuXHRcdHN0YXRlLm1hcmdpbiA9IGlzUm90YXRlZCA/IHtcclxuXHRcdFx0dG9wOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSxcclxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXHJcblx0XHRcdGJvdHRvbTogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ5XCIpICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20oKSxcclxuXHRcdFx0bGVmdDogc3ViY2hhcnRIZWlnaHQgKyAoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpKVxyXG5cdFx0fSA6IHtcclxuXHRcdFx0dG9wOiA0ICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSwgLy8gZm9yIHRvcCB0aWNrIHRleHRcclxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXHJcblx0XHRcdGJvdHRvbTogeEF4aXNIZWlnaHQgKyBzdWJjaGFydEhlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXHJcblx0XHRcdGxlZnQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmb3Igc3ViY2hhcnRcclxuXHRcdHN0YXRlLm1hcmdpbjIgPSBpc1JvdGF0ZWQgPyB7XHJcblx0XHRcdHRvcDogc3RhdGUubWFyZ2luLnRvcCxcclxuXHRcdFx0cmlnaHQ6IE5hTixcclxuXHRcdFx0Ym90dG9tOiAyMCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcclxuXHRcdFx0bGVmdDogJCQuc3RhdGUucm90YXRlZFBhZGRpbmcubGVmdFxyXG5cdFx0fSA6IHtcclxuXHRcdFx0dG9wOiBzdGF0ZS5jdXJyZW50LmhlaWdodCAtIHN1YmNoYXJ0SGVpZ2h0IC0gbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxyXG5cdFx0XHRyaWdodDogTmFOLFxyXG5cdFx0XHRib3R0b206IHN1YmNoYXJ0WEF4aXNIZWlnaHQgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXHJcblx0XHRcdGxlZnQ6IHN0YXRlLm1hcmdpbi5sZWZ0XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGZvciBsZWdlbmRcclxuXHRcdHN0YXRlLm1hcmdpbjMgPSB7XHJcblx0XHRcdHRvcDogMCxcclxuXHRcdFx0cmlnaHQ6IE5hTixcclxuXHRcdFx0Ym90dG9tOiAwLFxyXG5cdFx0XHRsZWZ0OiAwXHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLnVwZGF0ZVNpemVGb3JMZWdlbmQgJiYgJCQudXBkYXRlU2l6ZUZvckxlZ2VuZChjdXJyTGVnZW5kKTtcclxuXHJcblx0XHRzdGF0ZS53aWR0aCA9IHN0YXRlLmN1cnJlbnQud2lkdGggLSBzdGF0ZS5tYXJnaW4ubGVmdCAtIHN0YXRlLm1hcmdpbi5yaWdodDtcclxuXHRcdHN0YXRlLmhlaWdodCA9IHN0YXRlLmN1cnJlbnQuaGVpZ2h0IC0gc3RhdGUubWFyZ2luLnRvcCAtIHN0YXRlLm1hcmdpbi5ib3R0b207XHJcblxyXG5cdFx0aWYgKHN0YXRlLndpZHRoIDwgMCkge1xyXG5cdFx0XHRzdGF0ZS53aWR0aCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXRlLmhlaWdodCA8IDApIHtcclxuXHRcdFx0c3RhdGUuaGVpZ2h0ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS53aWR0aDIgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRzdGF0ZS5tYXJnaW4ubGVmdCAtIHN0YXRlLnJvdGF0ZWRQYWRkaW5nLmxlZnQgLSBzdGF0ZS5yb3RhdGVkUGFkZGluZy5yaWdodCA6IHN0YXRlLndpZHRoO1xyXG5cclxuXHRcdHN0YXRlLmhlaWdodDIgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRzdGF0ZS5oZWlnaHQgOiBzdGF0ZS5jdXJyZW50LmhlaWdodCAtIHN0YXRlLm1hcmdpbjIudG9wIC0gc3RhdGUubWFyZ2luMi5ib3R0b207XHJcblxyXG5cdFx0aWYgKHN0YXRlLndpZHRoMiA8IDApIHtcclxuXHRcdFx0c3RhdGUud2lkdGgyID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RhdGUuaGVpZ2h0MiA8IDApIHtcclxuXHRcdFx0c3RhdGUuaGVpZ2h0MiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZm9yIGFyY1xyXG5cdFx0c3RhdGUuYXJjV2lkdGggPSBzdGF0ZS53aWR0aCAtIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0ID8gY3VyckxlZ2VuZC53aWR0aCArIDEwIDogMCk7XHJcblx0XHRzdGF0ZS5hcmNIZWlnaHQgPSBzdGF0ZS5oZWlnaHQgLSAoc3RhdGUuaXNMZWdlbmRSaWdodCA/IDAgOiAxMCk7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUpIHtcclxuXHRcdFx0c3RhdGUuYXJjSGVpZ2h0ICs9IHN0YXRlLmhlaWdodCAtICQkLmdldEdhdWdlTGFiZWxIZWlnaHQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC51cGRhdGVSYWRpdXMgJiYgJCQudXBkYXRlUmFkaXVzKCk7XHJcblxyXG5cdFx0aWYgKHN0YXRlLmlzTGVnZW5kUmlnaHQgJiYgaGFzQXJjKSB7XHJcblx0XHRcdHN0YXRlLm1hcmdpbjMubGVmdCA9IHN0YXRlLmFyY1dpZHRoIC8gMiArIHN0YXRlLnJhZGl1c0V4cGFuZGVkICogMS4xO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmICghaGFzQXJjICYmIGNvbmZpZy5heGlzX3hfc2hvdyAmJiBjb25maWcuYXhpc194X3RpY2tfY3VsbGluZykge1xyXG5cdFx0Ly8gXHQkJC51cGRhdGVYQXhpc1RpY2tDbGlwKCk7XHJcblx0XHQvLyB9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtLRVl9IGZyb20gXCIuLi8uLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhcGl0YWxpemUsIGdldEJvdW5kaW5nUmVjdCwgZ2V0UmFuZG9tLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nLCBnZXRUcmFuc2xhdGlvbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7QXhpc1R5cGV9IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRvcGFjaXR5Rm9yVGV4dCgpOiBcIjFcIiB8IFwiMFwiIHtcclxuXHRcdHJldHVybiB0aGlzLmhhc0RhdGFMYWJlbCgpID8gXCIxXCIgOiBcIjBcIjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyB0aGUgdGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFRleHQoKTogdm9pZCB7XHJcblx0XHRjb25zdCB7JGVsfSA9IHRoaXM7XHJcblxyXG5cdFx0JGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRUZXh0cyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGNoYXJ0VGV4dFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRzICQkLmRhdGEudGFyZ2V0c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydFRleHQgPSAkJC5jbGFzc0NoYXJ0VGV4dC5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzVGV4dHMgPSAkJC5jbGFzc1RleHRzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBtYWluVGV4dFVwZGF0ZSA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRUZXh0c31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0VGV4dH1gKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydFRleHQoZCkgKyBjbGFzc0ZvY3VzKGQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluVGV4dEVudGVyID0gbWFpblRleHRVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydFRleHQpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHRtYWluVGV4dEVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc1RleHRzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGV4dFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbkZvckV4aXQgRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlVGV4dChkdXJhdGlvbkZvckV4aXQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFGbiA9ICQkLmxhYmVsaXNoRGF0YS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzVGV4dCA9ICQkLmNsYXNzVGV4dC5iaW5kKCQkKTtcclxuXHJcblx0XHQkZWwudGV4dCA9ICRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MudGV4dHN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy50ZXh0fWApXHJcblx0XHRcdC5kYXRhKGQgPT4gKHRoaXMuaXNSYWRhclR5cGUoZCkgPyBkLnZhbHVlcyA6IGRhdGFGbihkKSkpO1xyXG5cclxuXHRcdCRlbC50ZXh0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdCRlbC50ZXh0ID0gJGVsLnRleHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQubWVyZ2UoJCQuJGVsLnRleHQpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NUZXh0KVxyXG5cdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIGQgPT4gKGNvbmZpZy5heGlzX3JvdGF0ZWQgPyAoZC52YWx1ZSA8IDAgPyBcImVuZFwiIDogXCJzdGFydFwiKSA6IFwibWlkZGxlXCIpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZVRleHRDb2xvci5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQudGV4dCgoZCwgaSwgaikgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwielwiKSA6IGQudmFsdWU7XHJcblxyXG5cdFx0XHRcdHJldHVybiAkJC5kYXRhTGFiZWxGb3JtYXQoZC5pZCkodmFsdWUsIGQuaWQsIGksIGopO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUZXh0Q29sb3IoZCk6IG9iamVjdCB8IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBsYWJlbENvbG9ycyA9ICQkLmNvbmZpZy5kYXRhX2xhYmVsc19jb2xvcnM7XHJcblx0XHRsZXQgY29sb3I7XHJcblxyXG5cdFx0aWYgKGlzU3RyaW5nKGxhYmVsQ29sb3JzKSkge1xyXG5cdFx0XHRjb2xvciA9IGxhYmVsQ29sb3JzO1xyXG5cdFx0fSBlbHNlIGlmIChpc09iamVjdChsYWJlbENvbG9ycykpIHtcclxuXHRcdFx0Y29sb3IgPSBsYWJlbENvbG9yc1tkLmlkXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29sb3IgfHwgJCQuY29sb3IoZCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IGNoYXJ0VGV4dFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHggUG9zaXRpb25pbmcgZnVuY3Rpb24gZm9yIHhcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB5IFBvc2l0aW9uaW5nIGZ1bmN0aW9uIGZvciB5XHJcblx0ICogQHBhcmFtIHtib29sZWFufSBmb3JGbG93IFdlYXRoZXIgaXMgZmxvd1xyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gdHJhbnNpdGlvbiBpcyBlbmFibGVkXHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3VGV4dCh4LCB5LCBmb3JGbG93PzogYm9vbGVhbiwgd2l0aFRyYW5zaXRpb24/OiBib29sZWFuKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0OiBhbnkgPSBnZXRSYW5kb20oKTtcclxuXHRcdGNvbnN0IG9wYWNpdHlGb3JUZXh0ID0gZm9yRmxvdyA/IDAgOiAkJC5vcGFjaXR5Rm9yVGV4dC5iaW5kKCQkKTtcclxuXHJcblx0XHQkJC4kZWwudGV4dC5lYWNoKGZ1bmN0aW9uKGQsIGk6IG51bWJlcikge1xyXG5cdFx0XHRjb25zdCB0ZXh0ID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHQvLyBkbyBub3QgYXBwbHkgdHJhbnNpdGlvbiBmb3IgbmV3bHkgYWRkZWQgdGV4dCBlbGVtZW50c1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gJiYgdGV4dC5hdHRyKFwieFwiKSA/IHRleHQudHJhbnNpdGlvbih0KSA6IHRleHQpXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIHguYmluZCh0aGlzKShkLCBpKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgZCA9PiB5LmJpbmQodGhpcykoZCwgaSkpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVUZXh0Q29sb3IuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHlGb3JUZXh0KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIG5lZWQgdG8gcmV0dXJuICd0cnVlJyBhcyBvZiBiZWluZyBwdXNoZWQgdG8gdGhlIHJlZHJhdyBsaXN0XHJcblx0XHQvLyByZWY6IGdldFJlZHJhd0xpc3QoKVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHZhbHVlIG9mIHRoZSBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudHxkMy5zZWxlY3Rpb259IGVsZW1lbnQgVGFyZ2V0IGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIENsYXNzIG5hbWVcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB2YWx1ZSBvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUZXh0UmVjdChlbGVtZW50LCBjbGFzc05hbWU6IHN0cmluZyk6IG9iamVjdCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgYmFzZSA9IChlbGVtZW50Lm5vZGUgPyBlbGVtZW50Lm5vZGUoKSA6IGVsZW1lbnQpO1xyXG5cclxuXHRcdGlmICghL3RleHQvaS50ZXN0KGJhc2UudGFnTmFtZSkpIHtcclxuXHRcdFx0YmFzZSA9IGJhc2UucXVlcnlTZWxlY3RvcihcInRleHRcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdGV4dCA9IGJhc2UudGV4dENvbnRlbnQ7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IGAke0tFWS50ZXh0UmVjdH0tJHt0ZXh0LnJlcGxhY2UoL1xcVy9nLCBcIl9cIil9YDtcclxuXHRcdGxldCByZWN0ID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIXJlY3QpIHtcclxuXHRcdFx0JCQuJGVsLnN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImZvbnRcIiwgZDNTZWxlY3QoYmFzZSkuc3R5bGUoXCJmb250XCIpKVxyXG5cdFx0XHRcdC5jbGFzc2VkKGNsYXNzTmFtZSwgdHJ1ZSlcclxuXHRcdFx0XHQudGV4dCh0ZXh0KVxyXG5cdFx0XHRcdC5jYWxsKHYgPT4ge1xyXG5cdFx0XHRcdFx0cmVjdCA9IGdldEJvdW5kaW5nUmVjdCh2Lm5vZGUoKSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIHJlY3QpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHggb3IgeSBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGluZGljZXMgSW5kaWNlcyB2YWx1ZXNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGZvclggd2hldGhlciBvciBub3QgdG8geFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IGNvb3JkaW5hdGVzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVhZRm9yVGV4dChpbmRpY2VzLCBmb3JYPzogYm9vbGVhbik6IChkLCBpKSA9PiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyhpbmRpY2VzKTtcclxuXHRcdGNvbnN0IHBvaW50cyA9IHt9O1xyXG5cdFx0Y29uc3QgZ2V0dGVyID0gZm9yWCA/ICQkLmdldFhGb3JUZXh0IDogJCQuZ2V0WUZvclRleHQ7XHJcblxyXG5cdFx0JCQuaGFzVHlwZShcInJhZGFyXCIpICYmIHR5cGVzLnB1c2goXCJyYWRhclwiKTtcclxuXHJcblx0XHR0eXBlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRwb2ludHNbdl0gPSAkJFtgZ2VuZXJhdGVHZXQke2NhcGl0YWxpemUodil9UG9pbnRzYF0oaW5kaWNlc1t2XSwgZmFsc2UpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0Y29uc3QgdHlwZSA9ICgkJC5pc0FyZWFUeXBlKGQpICYmIFwiYXJlYVwiKSB8fFxyXG5cdFx0XHRcdCgkJC5pc0JhclR5cGUoZCkgJiYgXCJiYXJcIikgfHxcclxuXHRcdFx0XHQoJCQuaXNSYWRhclR5cGUoZCkgJiYgXCJyYWRhclwiKSB8fCBcImxpbmVcIjtcclxuXHJcblx0XHRcdHJldHVybiBnZXR0ZXIuY2FsbCgkJCwgcG9pbnRzW3R5cGVdKGQsIGkpLCBkLCB0aGlzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGNlbnRlcml6ZWQgdGV4dCBwb3NpdGlvbiBmb3IgYmFyIHR5cGUgZGF0YS5sYWJlbC50ZXh0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBwb2ludHMgRGF0YSBwb2ludHMgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0ZXh0RWxlbWVudCBEYXRhIGxhYmVsIHRleHQgZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFBvc2l0aW9uIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRpZiAoY29uZmlnLmRhdGFfbGFiZWxzLmNlbnRlcmVkICYmICQkLmlzQmFyVHlwZShkKSkge1xyXG5cdFx0XHRjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcclxuXHRcdFx0Y29uc3QgaXNQb3NpdGl2ZSA9IGQudmFsdWUgPj0gMDtcclxuXHJcblx0XHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0XHRjb25zdCB3ID0gKFxyXG5cdFx0XHRcdFx0aXNQb3NpdGl2ZSA/XHJcblx0XHRcdFx0XHRcdHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXSA6XHJcblx0XHRcdFx0XHRcdHBvaW50c1swXVsxXSAtIHBvaW50c1sxXVsxXVxyXG5cdFx0XHRcdCkgLyAyICsgKHJlY3Qud2lkdGggLyAyKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGlzUG9zaXRpdmUgPyAtdyAtIDMgOiB3ICsgMjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBoID0gKFxyXG5cdFx0XHRcdFx0aXNQb3NpdGl2ZSA/XHJcblx0XHRcdFx0XHRcdHBvaW50c1swXVsxXSAtIHBvaW50c1sxXVsxXSA6XHJcblx0XHRcdFx0XHRcdHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXVxyXG5cdFx0XHRcdCkgLyAyICsgKHJlY3QuaGVpZ2h0IC8gMik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gaCA6IC1oIC0gMjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhLmxhYmVscy5wb3NpdGlvbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBEYXRhIGlkIHZhbHVlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgeCB8IHlcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NpdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VGV4dFBvcyhpZCwgdHlwZSk6IG51bWJlciB7XHJcblx0XHRjb25zdCBwb3MgPSB0aGlzLmNvbmZpZy5kYXRhX2xhYmVsc19wb3NpdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gKGlkIGluIHBvcyA/IHBvc1tpZF0gOiBwb3MpW3R5cGVdIHx8IDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHBvaW50cyBEYXRhIHBvaW50cyBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGV4dEVsZW1lbnQgRGF0YSBsYWJlbCB0ZXh0IGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB4IGNvb3JkaW5hdGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFhGb3JUZXh0KHBvaW50cywgZCwgdGV4dEVsZW1lbnQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IHhQb3M7XHJcblx0XHRsZXQgcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAkJC5pc0JhclR5cGUoZCkgPyA0IDogNjtcclxuXHRcdFx0eFBvcyA9IHBvaW50c1syXVsxXSArIHBhZGRpbmcgKiAoZC52YWx1ZSA8IDAgPyAtMSA6IDEpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eFBvcyA9ICQkLmhhc1R5cGUoXCJiYXJcIikgPyAocG9pbnRzWzJdWzBdICsgcG9pbnRzWzBdWzBdKSAvIDIgOiBwb2ludHNbMF1bMF07XHJcblx0XHR9XHJcblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxyXG5cdFx0aWYgKGQudmFsdWUgPT09IG51bGwpIHtcclxuXHRcdFx0aWYgKHhQb3MgPiBzdGF0ZS53aWR0aCkge1xyXG5cdFx0XHRcdGNvbnN0IHt3aWR0aH0gPSBnZXRCb3VuZGluZ1JlY3QodGV4dEVsZW1lbnQpO1xyXG5cclxuXHRcdFx0XHR4UG9zID0gc3RhdGUud2lkdGggLSB3aWR0aDtcclxuXHRcdFx0fSBlbHNlIGlmICh4UG9zIDwgMCkge1xyXG5cdFx0XHRcdHhQb3MgPSA0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHR4UG9zICs9ICQkLmdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geFBvcyArICQkLmdldFRleHRQb3MoZC5pZCwgXCJ4XCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludHMgRGF0YSBwb2ludHMgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRleHRFbGVtZW50IERhdGEgbGFiZWwgdGV4dCBlbGVtZW50XHJcblx0ICogQHJldHVybnMge251bWJlcn0geSBjb29yZGluYXRlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRZRm9yVGV4dChwb2ludHMsIGQsIHRleHRFbGVtZW50KTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHIgPSBjb25maWcucG9pbnRfcjtcclxuXHRcdGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ1JlY3QodGV4dEVsZW1lbnQpO1xyXG5cdFx0bGV0IGJhc2VZID0gMztcclxuXHRcdGxldCB5UG9zO1xyXG5cclxuXHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0eVBvcyA9IChwb2ludHNbMF1bMF0gKyBwb2ludHNbMl1bMF0gKyByZWN0LmhlaWdodCAqIDAuNikgLyAyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eVBvcyA9IHBvaW50c1syXVsxXTtcclxuXHJcblx0XHRcdGlmIChpc051bWJlcihyKSAmJiByID4gNSAmJiAoJCQuaXNMaW5lVHlwZShkKSB8fCAkJC5pc1NjYXR0ZXJUeXBlKGQpKSkge1xyXG5cdFx0XHRcdGJhc2VZICs9IGNvbmZpZy5wb2ludF9yIC8gMi4zO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZC52YWx1ZSA8IDAgfHwgKGQudmFsdWUgPT09IDAgJiYgIXN0YXRlLmhhc1Bvc2l0aXZlVmFsdWUgJiYgc3RhdGUuaGFzTmVnYXRpdmVWYWx1ZSkpIHtcclxuXHRcdFx0XHR5UG9zICs9IHJlY3QuaGVpZ2h0ICsgKCQkLmlzQmFyVHlwZShkKSA/IC1iYXNlWSA6IGJhc2VZKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgZGlmZiA9IC1iYXNlWSAqIDI7XHJcblxyXG5cdFx0XHRcdGlmICgkJC5pc0JhclR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdGRpZmYgPSAtYmFzZVk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICgkJC5pc0J1YmJsZVR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdGRpZmYgPSBiYXNlWTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHlQb3MgKz0gZGlmZjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNob3cgbGFiZWxzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRvbWFpbiBpZiB2YWx1ZSBpcyBudWxsXHJcblx0XHRpZiAoZC52YWx1ZSA9PT0gbnVsbCAmJiAhaXNSb3RhdGVkKSB7XHJcblx0XHRcdGNvbnN0IGJveEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG5cclxuXHRcdFx0aWYgKHlQb3MgPCBib3hIZWlnaHQpIHtcclxuXHRcdFx0XHR5UG9zID0gYm94SGVpZ2h0O1xyXG5cdFx0XHR9IGVsc2UgaWYgKHlQb3MgPiBzdGF0ZS5oZWlnaHQpIHtcclxuXHRcdFx0XHR5UG9zID0gc3RhdGUuaGVpZ2h0IC0gNDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghaXNSb3RhdGVkKSB7XHJcblx0XHRcdHlQb3MgKz0gJCQuZ2V0Q2VudGVyZWRUZXh0UG9zKGQsIHBvaW50cywgdGV4dEVsZW1lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB5UG9zICsgJCQuZ2V0VGV4dFBvcyhkLmlkLCBcInlcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsY3VsYXRlIGlmIHR3byBvciBtb3JlIHRleHQgbm9kZXMgYXJlIG92ZXJsYXBwaW5nXHJcblx0ICogTWFyayBvdmVybGFwcGluZyB0ZXh0IG5vZGVzIHdpdGggXCJ0ZXh0LW92ZXJsYXBwaW5nXCIgY2xhc3NcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgQXhpcyBpZFxyXG5cdCAqIEBwYXJhbSB7Q2hhcnRJbnRlcm5hbH0gJCQgQ2hhcnRJbnRlcm5hbCBjb250ZXh0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHN0cmluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0bWFya092ZXJsYXBwZWQoaWQ6IEF4aXNUeXBlLCAkJCwgc2VsZWN0b3I6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgdGV4dE5vZGVzID0gJCQuJGVsLmFyY3Muc2VsZWN0QWxsKHNlbGVjdG9yKTtcclxuXHRcdGNvbnN0IGZpbHRlcmVkVGV4dE5vZGVzID0gdGV4dE5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUuZGF0YS5pZCAhPT0gaWQpO1xyXG5cdFx0Y29uc3QgdGV4dE5vZGUgPSB0ZXh0Tm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5kYXRhLmlkID09PSBpZCk7XHJcblx0XHRjb25zdCB0cmFuc2xhdGUgPSBnZXRUcmFuc2xhdGlvbih0ZXh0Tm9kZS5ub2RlKCkpO1xyXG5cclxuXHRcdC8vIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGUgaHlwb3RlbnVzZVxyXG5cdFx0Y29uc3QgY2FsY0h5cG8gPSAoeCwgeSkgPT4gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xyXG5cclxuXHRcdHRleHROb2RlLm5vZGUoKSAmJiBmaWx0ZXJlZFRleHROb2Rlcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBjb29yZGluYXRlID0gZ2V0VHJhbnNsYXRpb24odGhpcyk7XHJcblx0XHRcdGNvbnN0IGZpbHRlcmVkVGV4dE5vZGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0Y29uc3Qgbm9kZUZvcldpZHRoID0gY2FsY0h5cG8odHJhbnNsYXRlLmUsIHRyYW5zbGF0ZS5mKSA+IGNhbGNIeXBvKGNvb3JkaW5hdGUuZSwgY29vcmRpbmF0ZS5mKSA/XHJcblx0XHRcdFx0dGV4dE5vZGUgOiBmaWx0ZXJlZFRleHROb2RlO1xyXG5cclxuXHRcdFx0Y29uc3Qgb3ZlcmxhcHNYID0gTWF0aC5jZWlsKE1hdGguYWJzKHRyYW5zbGF0ZS5lIC0gY29vcmRpbmF0ZS5lKSkgPFxyXG5cdFx0XHRcdE1hdGguY2VpbChub2RlRm9yV2lkdGgubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpKTtcclxuXHRcdFx0Y29uc3Qgb3ZlcmxhcHNZID0gTWF0aC5jZWlsKE1hdGguYWJzKHRyYW5zbGF0ZS5mIC0gY29vcmRpbmF0ZS5mKSkgPFxyXG5cdFx0XHRcdHBhcnNlSW50KHRleHROb2RlLnN0eWxlKFwiZm9udC1zaXplXCIpLCAwKTtcclxuXHJcblx0XHRcdGZpbHRlcmVkVGV4dE5vZGUuY2xhc3NlZChDTEFTUy5UZXh0T3ZlcmxhcHBpbmcsIG92ZXJsYXBzWCAmJiBvdmVybGFwc1kpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsY3VsYXRlIGlmIHR3byBvciBtb3JlIHRleHQgbm9kZXMgYXJlIG92ZXJsYXBwaW5nXHJcblx0ICogUmVtb3ZlIFwidGV4dC1vdmVybGFwcGluZ1wiIGNsYXNzIG9uIHNlbGVjdGVkIHRleHQgbm9kZXNcclxuXHQgKiBAcGFyYW0ge0NoYXJ0SW50ZXJuYWx9ICQkIENoYXJ0SW50ZXJuYWwgY29udGV4dFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciBzdHJpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVuZG9NYXJrT3ZlcmxhcHBlZCgkJCwgc2VsZWN0b3IpOiB2b2lkIHtcclxuXHRcdCQkLiRlbC5hcmNzLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0ZDNTZWxlY3RBbGwoW3RoaXMsIHRoaXMucHJldmlvdXNTaWJsaW5nXSlcclxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLlRleHRPdmVybGFwcGluZywgZmFsc2UpO1xyXG5cdFx0XHR9KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc051bWJlciwgc2V0VGV4dFZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgdGV4dCBwb3NpdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9zIHJpZ2h0LCBsZWZ0IG9yIGNlbnRlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggY2hhcnQgd2lkdGhcclxuICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ9IHRleHQtYW5jaG9yIHZhbHVlIG9yIHBvc2l0aW9uIGluIHBpeGVsXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUZXh0UG9zKHBvcyA9IFwibGVmdFwiLCB3aWR0aD86IG51bWJlciB8IGFueSk6IG51bWJlciB8IFwic3RhcnRcIiB8IFwibWlkZGxlXCIgfCBcImVuZFwiIHtcclxuXHRjb25zdCBpc051bSA9IGlzTnVtYmVyKHdpZHRoKTtcclxuXHRsZXQgcG9zaXRpb247XHJcblxyXG5cdGlmIChwb3MuaW5kZXhPZihcImNlbnRlclwiKSA+IC0xKSB7XHJcblx0XHRwb3NpdGlvbiA9IGlzTnVtID8gd2lkdGggLyAyIDogXCJtaWRkbGVcIjtcclxuXHR9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwicmlnaHRcIikgPiAtMSkge1xyXG5cdFx0cG9zaXRpb24gPSBpc051bSA/IHdpZHRoIDogXCJlbmRcIjtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cG9zaXRpb24gPSBpc051bSA/IDAgOiBcInN0YXJ0XCI7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9zaXRpb247XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyB0aGUgdGl0bGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUaXRsZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLnRpdGxlX3RleHQpIHtcclxuXHRcdFx0JGVsLnRpdGxlID0gJGVsLnN2Zy5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdFx0Y29uc3QgdGV4dCA9ICRlbC50aXRsZVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgZ2V0VGV4dFBvcyhjb25maWcudGl0bGVfcG9zaXRpb24pKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MudGl0bGUpO1xyXG5cclxuXHRcdFx0c2V0VGV4dFZhbHVlKHRleHQsIGNvbmZpZy50aXRsZV90ZXh0LCBbMC4zLCAxLjVdKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGl0bGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd1RpdGxlKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50fSwgJGVsOiB7dGl0bGV9fSA9ICQkO1xyXG5cclxuXHRcdGlmICh0aXRsZSkge1xyXG5cdFx0XHRjb25zdCB5ID0gJCQueUZvclRpdGxlLmNhbGwoJCQpO1xyXG5cclxuXHRcdFx0aWYgKC9nL2kudGVzdCh0aXRsZS5ub2RlKCkudGFnTmFtZSkpIHtcclxuXHRcdFx0XHR0aXRsZS5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHtnZXRUZXh0UG9zKGNvbmZpZy50aXRsZV9wb3NpdGlvbiwgY3VycmVudC53aWR0aCl9LCAke3l9KWApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRpdGxlLmF0dHIoXCJ4XCIsICQkLnhGb3JUaXRsZS5jYWxsKCQkKSkuYXR0cihcInlcIiwgeSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB4IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB4IGF0dHJpYnV0ZSB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0eEZvclRpdGxlKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2N1cnJlbnR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBjb25maWcudGl0bGVfcG9zaXRpb24gfHwgXCJsZWZ0XCI7XHJcblx0XHRjb25zdCB0ZXh0UmVjdFdpZHRoID0gJCQuZ2V0VGV4dFJlY3QoJCQuJGVsLnRpdGxlLCBDTEFTUy50aXRsZSkud2lkdGg7XHJcblx0XHRsZXQgeDtcclxuXHJcblx0XHRpZiAoLyhyaWdodHxjZW50ZXIpLy50ZXN0KHBvc2l0aW9uKSkge1xyXG5cdFx0XHR4ID0gY3VycmVudC53aWR0aCAtIHRleHRSZWN0V2lkdGg7XHJcblxyXG5cdFx0XHRpZiAocG9zaXRpb24uaW5kZXhPZihcInJpZ2h0XCIpID49IDApIHtcclxuXHRcdFx0XHR4ID0gY3VycmVudC53aWR0aCAtIHRleHRSZWN0V2lkdGggLSBjb25maWcudGl0bGVfcGFkZGluZy5yaWdodDtcclxuXHRcdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pbmRleE9mKFwiY2VudGVyXCIpID49IDApIHtcclxuXHRcdFx0XHR4ID0gKGN1cnJlbnQud2lkdGggLSB0ZXh0UmVjdFdpZHRoKSAvIDI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7IC8vIGxlZnRcclxuXHRcdFx0eCA9IChjb25maWcudGl0bGVfcGFkZGluZy5sZWZ0IHx8IDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB4O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHkgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSB0aXRsZVxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHkgYXR0cmlidXRlIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR5Rm9yVGl0bGUoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gKCQkLmNvbmZpZy50aXRsZV9wYWRkaW5nLnRvcCB8fCAwKSArXHJcblx0XHRcdCQkLmdldFRleHRSZWN0KCQkLiRlbC50aXRsZSwgQ0xBU1MudGl0bGUpLmhlaWdodDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGl0bGUgcGFkZGluZ1xyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHBhZGRpbmcgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRpdGxlUGFkZGluZygpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC55Rm9yVGl0bGUoKSArICgkJC5jb25maWcudGl0bGVfcGFkZGluZy5ib3R0b20gfHwgMCk7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRtb3VzZSBhcyBkM01vdXNlXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZywgaXNWYWx1ZSwgY2FsbEZuLCBzYW5pdGlzZSwgdHBsUHJvY2VzcywgaXNVbmRlZmluZWQsIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRvb2x0aXBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUb29sdGlwKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qge2JpbmR0b30gPSBjb25maWcudG9vbHRpcF9jb250ZW50cztcclxuXHJcblx0XHQkZWwudG9vbHRpcCA9IGQzU2VsZWN0KGJpbmR0byk7XHJcblxyXG5cdFx0aWYgKCRlbC50b29sdGlwLmVtcHR5KCkpIHtcclxuXHRcdFx0JGVsLnRvb2x0aXAgPSAkZWwuY2hhcnRcclxuXHRcdFx0XHQuc3R5bGUoXCJwb3NpdGlvblwiLCBcInJlbGF0aXZlXCIpXHJcblx0XHRcdFx0LmFwcGVuZChcImRpdlwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MudG9vbHRpcENvbnRhaW5lcilcclxuXHRcdFx0XHQuc3R5bGUoXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcIm5vbmVcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2hvdyB0b29sdGlwIGlmIG5lZWRlZFxyXG5cdFx0aWYgKGNvbmZpZy50b29sdGlwX2luaXRfc2hvdykge1xyXG5cdFx0XHRpZiAoJCQuYXhpcy5pc1RpbWVTZXJpZXMoKSAmJiBpc1N0cmluZyhjb25maWcudG9vbHRpcF9pbml0X3gpKSB7XHJcblx0XHRcdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0c1swXTtcclxuXHRcdFx0XHRsZXQgaTtcclxuXHRcdFx0XHRsZXQgdmFsO1xyXG5cclxuXHRcdFx0XHRjb25maWcudG9vbHRpcF9pbml0X3ggPSBwYXJzZURhdGUuY2FsbCgkJCwgY29uZmlnLnRvb2x0aXBfaW5pdF94KTtcclxuXHJcblx0XHRcdFx0Zm9yIChpID0gMDsgKHZhbCA9IHRhcmdldHMudmFsdWVzW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoKHZhbC54IC0gY29uZmlnLnRvb2x0aXBfaW5pdF94KSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbmZpZy50b29sdGlwX2luaXRfeCA9IGk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCRlbC50b29sdGlwLmh0bWwoJCQuZ2V0VG9vbHRpcEhUTUwoXHJcblx0XHRcdFx0JCQuZGF0YS50YXJnZXRzLm1hcChkID0+ICQkLmFkZE5hbWUoZC52YWx1ZXNbY29uZmlnLnRvb2x0aXBfaW5pdF94XSkpLFxyXG5cdFx0XHRcdCQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCksXHJcblx0XHRcdFx0JCQuZ2V0WUZvcm1hdCgkJC5oYXNBcmNUeXBlKG51bGwsIFtcInJhZGFyXCJdKSksXHJcblx0XHRcdFx0JCQuY29sb3JcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0XHRpZiAoIWJpbmR0bykge1xyXG5cdFx0XHRcdCRlbC50b29sdGlwLnN0eWxlKFwidG9wXCIsIGNvbmZpZy50b29sdGlwX2luaXRfcG9zaXRpb24udG9wKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwibGVmdFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLmxlZnQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQkJC5iaW5kVG9vbHRpcFJlc2l6ZVBvcygpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdG9vbHRpcCBIVE1MIHN0cmluZ1xyXG5cdCAqIEBwYXJhbSAge0FycmF5fSBhcmdzIEFyZ3VtZW50c1xyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IEZvcm1hdHRlZCBIVE1MIHN0cmluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VG9vbHRpcEhUTUwoLi4uYXJncyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXBpLCBjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oY29uZmlnLnRvb2x0aXBfY29udGVudHMpID9cclxuXHRcdFx0Y29uZmlnLnRvb2x0aXBfY29udGVudHMuYmluZChhcGkpKC4uLmFyZ3MpIDogJCQuZ2V0VG9vbHRpcENvbnRlbnQoLi4uYXJncyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdG9vbHRpcCBjb250ZW50KEhUTUwgc3RyaW5nKVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIGRhdGFcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWZhdWx0VGl0bGVGb3JtYXQgRGVmYXVsdCB0aXRsZSBmb3JtYXRcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWZhdWx0VmFsdWVGb3JtYXQgRGVmYXVsdCBmb3JtYXQgZm9yIGVhY2ggZGF0YSB2YWx1ZSBpbiB0aGUgdG9vbHRpcC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb2xvciBDb2xvciBmdW5jdGlvblxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IGh0bWxcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvb2x0aXBDb250ZW50KGQsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0LCBjb2xvcik6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXBpLCBjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0bGV0IFt0aXRsZUZvcm1hdCwgbmFtZUZvcm1hdCwgdmFsdWVGb3JtYXRdID0gW1widGl0bGVcIiwgXCJuYW1lXCIsIFwidmFsdWVcIl0ubWFwKHYgPT4ge1xyXG5cdFx0XHRjb25zdCBmbiA9IGNvbmZpZ1tgdG9vbHRpcF9mb3JtYXRfJHt2fWBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIGlzRnVuY3Rpb24oZm4pID8gZm4uYmluZChhcGkpIDogZm47XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aXRsZUZvcm1hdCA9IHRpdGxlRm9ybWF0IHx8IGRlZmF1bHRUaXRsZUZvcm1hdDtcclxuXHRcdG5hbWVGb3JtYXQgPSBuYW1lRm9ybWF0IHx8IChuYW1lID0+IG5hbWUpO1xyXG5cdFx0dmFsdWVGb3JtYXQgPSB2YWx1ZUZvcm1hdCB8fCAoXHJcblx0XHRcdCQkLmlzU3RhY2tOb3JtYWxpemVkKCkgPyAodiwgcmF0aW8pID0+IGAkeyhyYXRpbyAqIDEwMCkudG9GaXhlZCgyKX0lYCA6IGRlZmF1bHRWYWx1ZUZvcm1hdFxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy50b29sdGlwX29yZGVyO1xyXG5cdFx0Y29uc3QgZ2V0Um93VmFsdWUgPSByb3cgPT4gKCQkLmF4aXMgJiYgJCQuaXNCdWJibGVaVHlwZShyb3cpID8gJCQuZ2V0QnViYmxlWkRhdGEocm93LnZhbHVlLCBcInpcIikgOiAkJC5nZXRCYXNlVmFsdWUocm93KSk7XHJcblx0XHRjb25zdCBnZXRCZ0NvbG9yID0gJCQubGV2ZWxDb2xvciA/IHJvdyA9PiAkJC5sZXZlbENvbG9yKHJvdy52YWx1ZSkgOiByb3cgPT4gY29sb3Iocm93KTtcclxuXHRcdGNvbnN0IGNvbnRlbnRzID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XHJcblx0XHRjb25zdCB0cGxTdHIgPSBjb250ZW50cy50ZW1wbGF0ZTtcclxuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKCk7XHJcblxyXG5cdFx0aWYgKG9yZGVyID09PSBudWxsICYmIGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gZm9yIHN0YWNrZWQgZGF0YSwgb3JkZXIgc2hvdWxkIGFsaWduZWQgd2l0aCB0aGUgdmlzdWFsbHkgZGlzcGxheWVkIGRhdGFcclxuXHRcdFx0Y29uc3QgaWRzID0gJCQub3JkZXJUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cylcclxuXHRcdFx0XHQubWFwKGkyID0+IGkyLmlkKVxyXG5cdFx0XHRcdC5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRkLnNvcnQoKGEsIGIpID0+IHtcclxuXHRcdFx0XHRsZXQgdjEgPSBhID8gYS52YWx1ZSA6IG51bGw7XHJcblx0XHRcdFx0bGV0IHYyID0gYiA/IGIudmFsdWUgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRpZiAodjEgPiAwICYmIHYyID4gMCkge1xyXG5cdFx0XHRcdFx0djEgPSBhLmlkID8gaWRzLmluZGV4T2YoYS5pZCkgOiBudWxsO1xyXG5cdFx0XHRcdFx0djIgPSBiLmlkID8gaWRzLmluZGV4T2YoYi5pZCkgOiBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHYxIC0gdjI7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmICgvXihhc2N8ZGVzYykkLy50ZXN0KG9yZGVyKSkge1xyXG5cdFx0XHRjb25zdCBpc0FzY2VuZGluZyA9IG9yZGVyID09PSBcImFzY1wiO1xyXG5cclxuXHRcdFx0ZC5zb3J0KChhLCBiKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdjEgPSBhID8gZ2V0Um93VmFsdWUoYSkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IHYyID0gYiA/IGdldFJvd1ZhbHVlKGIpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGlzQXNjZW5kaW5nID8gdjEgLSB2MiA6IHYyIC0gdjE7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKG9yZGVyKSkge1xyXG5cdFx0XHRkLnNvcnQob3JkZXIuYmluZChhcGkpKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0cGwgPSAkJC5nZXRUb29sdGlwQ29udGVudFRlbXBsYXRlKHRwbFN0cik7XHJcblx0XHRjb25zdCBsZW4gPSBkLmxlbmd0aDtcclxuXHRcdGxldCB0ZXh0O1xyXG5cdFx0bGV0IHJvdztcclxuXHRcdGxldCBwYXJhbTtcclxuXHRcdGxldCB2YWx1ZTtcclxuXHRcdGxldCBpO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRyb3cgPSBkW2ldO1xyXG5cclxuXHRcdFx0aWYgKCFyb3cgfHwgIShnZXRSb3dWYWx1ZShyb3cpIHx8IGdldFJvd1ZhbHVlKHJvdykgPT09IDApKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChpc1VuZGVmaW5lZCh0ZXh0KSkge1xyXG5cdFx0XHRcdGNvbnN0IHRpdGxlID0gc2FuaXRpc2UodGl0bGVGb3JtYXQgPyB0aXRsZUZvcm1hdChyb3cueCkgOiByb3cueCk7XHJcblxyXG5cdFx0XHRcdHRleHQgPSB0cGxQcm9jZXNzKHRwbFswXSwge1xyXG5cdFx0XHRcdFx0Q0xBU1NfVE9PTFRJUDogQ0xBU1MudG9vbHRpcCxcclxuXHRcdFx0XHRcdFRJVExFOiBpc1ZhbHVlKHRpdGxlKSA/IChcclxuXHRcdFx0XHRcdFx0dHBsU3RyID8gdGl0bGUgOiBgPHRyPjx0aCBjb2xzcGFuPVwiMlwiPiR7dGl0bGV9PC90aD48L3RyPmBcclxuXHRcdFx0XHRcdCkgOiBcIlwiXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcmFtID0gW3Jvdy5yYXRpbywgcm93LmlkLCByb3cuaW5kZXgsIGRdO1xyXG5cdFx0XHR2YWx1ZSA9IHNhbml0aXNlKHZhbHVlRm9ybWF0KGdldFJvd1ZhbHVlKHJvdyksIC4uLnBhcmFtKSk7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNBcmVhUmFuZ2VUeXBlKHJvdykpIHtcclxuXHRcdFx0XHRjb25zdCBbaGlnaCwgbG93XSA9IFtcImhpZ2hcIiwgXCJsb3dcIl0ubWFwKHYgPT4gc2FuaXRpc2UoXHJcblx0XHRcdFx0XHR2YWx1ZUZvcm1hdCgkJC5nZXRBcmVhUmFuZ2VEYXRhKHJvdywgdiksIC4uLnBhcmFtKVxyXG5cdFx0XHRcdCkpO1xyXG5cclxuXHRcdFx0XHR2YWx1ZSA9IGA8Yj5NaWQ6PC9iPiAke3ZhbHVlfSA8Yj5IaWdoOjwvYj4gJHtoaWdofSA8Yj5Mb3c6PC9iPiAke2xvd31gO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXHJcblx0XHRcdFx0aWYgKHJvdy5uYW1lID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IG5hbWUgPSBzYW5pdGlzZShuYW1lRm9ybWF0KHJvdy5uYW1lLCAuLi5wYXJhbSkpO1xyXG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gZ2V0QmdDb2xvcihyb3cpO1xyXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnRWYWx1ZSA9IHtcclxuXHRcdFx0XHRcdENMQVNTX1RPT0xUSVBfTkFNRTogQ0xBU1MudG9vbHRpcE5hbWUgKyAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChyb3cuaWQpLFxyXG5cdFx0XHRcdFx0Q09MT1I6ICh0cGxTdHIgfHwgISQkLnBhdHRlcm5zKSA/IGNvbG9yIDogYDxzdmc+PHJlY3Qgc3R5bGU9XCJmaWxsOiR7Y29sb3J9XCIgd2lkdGg9XCIxMFwiIGhlaWdodD1cIjEwXCI+PC9yZWN0Pjwvc3ZnPmAsXHJcblx0XHRcdFx0XHROQU1FOiBuYW1lLFxyXG5cdFx0XHRcdFx0VkFMVUU6IHZhbHVlXHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0aWYgKHRwbFN0ciAmJiBpc09iamVjdChjb250ZW50cy50ZXh0KSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSB0YXJnZXRJZHMuaW5kZXhPZihyb3cuaWQpO1xyXG5cclxuXHRcdFx0XHRcdE9iamVjdC5rZXlzKGNvbnRlbnRzLnRleHQpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRcdFx0Y29udGVudFZhbHVlW2tleV0gPSBjb250ZW50cy50ZXh0W2tleV1baW5kZXhdO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0ZXh0ICs9IHRwbFByb2Nlc3ModHBsWzFdLCBjb250ZW50VmFsdWUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGAke3RleHR9PC90YWJsZT5gO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgY29udGVudCB0ZW1wbGF0ZSBzdHJpbmdcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHBsU3RyIFRlbXBhbHRlIHN0cmluZ1xyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGVtcGxhdGUgc3RyaW5nXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUb29sdGlwQ29udGVudFRlbXBsYXRlKHRwbFN0cik6IHN0cmluZ1tdIHtcclxuXHRcdHJldHVybiAodHBsU3RyIHx8IGA8dGFibGUgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVB9XCI+PHRib2R5PlxyXG5cdFx0XHRcdHs9VElUTEV9XHJcblx0XHRcdFx0e3s8dHIgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj5cclxuXHRcdFx0XHRcdDx0ZCBjbGFzcz1cIm5hbWVcIj4ke3RoaXMucGF0dGVybnMgPyBgez1DT0xPUn1gIDogYDxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjp7PUNPTE9SfVwiPjwvc3Bhbj5gfXs9TkFNRX08L3RkPlxyXG5cdFx0XHRcdFx0PHRkIGNsYXNzPVwidmFsdWVcIj57PVZBTFVFfTwvdGQ+XHJcblx0XHRcdFx0PC90cj59fVxyXG5cdFx0XHQ8L3Rib2R5PjwvdGFibGU+YClcclxuXHRcdFx0LnJlcGxhY2UoLyhcXHI/XFxufFxcdCkvZywgXCJcIilcclxuXHRcdFx0LnNwbGl0KC97eyguKil9fS8pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFUb1Nob3cgZGF0YVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0V2lkdGggV2lkdGggdmFsdWUgb2YgdG9vbHRpcCBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRIZWlnaHQgSGVpZ2h0IHZhbHVlIG9mIHRvb2x0aXAgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVG9vbHRpcCBlbGVtZW50XHJcblx0ICogQHJldHVybnMge29iamVjdH0gdG9wLCBsZWZ0IHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0b29sdGlwUG9zaXRpb24oZGF0YVRvU2hvdywgdFdpZHRoOiBudW1iZXIsIHRIZWlnaHQ6IG51bWJlciwgZWxlbWVudCk6XHJcblx0XHR7dG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlcn0ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodCwgY3VycmVudCwgaXNMZWdlbmRSaWdodCwgaW5wdXRUeXBlfSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlO1xyXG5cdFx0Y29uc3Qgc3ZnTGVmdCA9ICQkLmdldFN2Z0xlZnQodHJ1ZSk7XHJcblx0XHRsZXQgW2xlZnQsIHRvcF0gPSBkM01vdXNlKGVsZW1lbnQpO1xyXG5cdFx0bGV0IGNoYXJ0UmlnaHQgPSBzdmdMZWZ0ICsgY3VycmVudC53aWR0aCAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQodHJ1ZSk7XHJcblx0XHRjb25zdCBjaGFydExlZnQgPSAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQodHJ1ZSk7XHJcblx0XHRjb25zdCBzaXplID0gMjA7XHJcblxyXG5cdFx0dG9wICs9IHNpemU7XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIHRvb2x0aXAgcG9zaXRpb25cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0Y29uc3QgcmF3ID0gaW5wdXRUeXBlID09PSBcInRvdWNoXCIgfHwgJCQuaGFzVHlwZShcInJhZGFyXCIpO1xyXG5cclxuXHRcdFx0aWYgKCFyYXcpIHtcclxuXHRcdFx0XHR0b3AgKz0gaGFzR2F1Z2UgPyBoZWlnaHQgOiBoZWlnaHQgLyAyO1xyXG5cdFx0XHRcdGxlZnQgKz0gKHdpZHRoIC0gKGlzTGVnZW5kUmlnaHQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpIDogMCkpIC8gMjtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgZGF0YVNjYWxlID0gc2NhbGUueChkYXRhVG9TaG93WzBdLngpO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0XHR0b3AgPSBkYXRhU2NhbGUgKyBzaXplO1xyXG5cdFx0XHRcdGxlZnQgKz0gc3ZnTGVmdCArIDEwMDtcclxuXHRcdFx0XHRjaGFydFJpZ2h0IC09IHN2Z0xlZnQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dG9wIC09IDU7XHJcblx0XHRcdFx0bGVmdCA9IHN2Z0xlZnQgKyBjaGFydExlZnQgKyBzaXplICsgKCQkLnpvb21TY2FsZSA/IGxlZnQgOiBkYXRhU2NhbGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2hlbiB0b29sdGlwIGxlZnQgKyB0V2lkdGggPiBjaGFydCdzIHdpZHRoXHJcblx0XHRpZiAoKGxlZnQgKyB0V2lkdGggKyAxNSkgPiBjaGFydFJpZ2h0KSB7XHJcblx0XHRcdGxlZnQgLT0gdFdpZHRoICsgY2hhcnRMZWZ0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0b3AgKyB0SGVpZ2h0ID4gY3VycmVudC5oZWlnaHQpIHtcclxuXHRcdFx0dG9wIC09IGhhc0dhdWdlID8gdEhlaWdodCAqIDMgOiB0SGVpZ2h0ICsgMzA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRvcCA8IDApIHtcclxuXHRcdFx0dG9wID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge3RvcCwgbGVmdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyB0aGUgdG9vbHRpcFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBzZWxlY3RlZERhdGEgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRvb2x0aXAgZWxlbWVudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2hvd1Rvb2x0aXAoc2VsZWN0ZWREYXRhLCBlbGVtZW50KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7dG9vbHRpcH19ID0gJCQ7XHJcblx0XHRjb25zdCB7YmluZHRvfSA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzO1xyXG5cdFx0Y29uc3QgZm9yQXJjID0gJCQuaGFzQXJjVHlwZShudWxsLCBbXCJyYWRhclwiXSk7XHJcblx0XHRjb25zdCBkYXRhVG9TaG93ID0gc2VsZWN0ZWREYXRhLmZpbHRlcihkID0+IGQgJiYgaXNWYWx1ZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcclxuXHJcblx0XHRpZiAoZGF0YVRvU2hvdy5sZW5ndGggPT09IDAgfHwgIWNvbmZpZy50b29sdGlwX3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBkYXR1bSA9IHRvb2x0aXAuZGF0dW0oKTtcclxuXHRcdGxldCB7d2lkdGggPSAwLCBoZWlnaHQgPSAwfSA9IGRhdHVtIHx8IHt9O1xyXG5cdFx0Y29uc3QgZGF0YVN0ciA9IEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0aWYgKCFkYXR1bSB8fCBkYXR1bS5jdXJyZW50ICE9PSBkYXRhU3RyKSB7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gc2VsZWN0ZWREYXRhLmNvbmNhdCgpLnNvcnQoKVswXS5pbmRleDtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3csICQkLmFwaSwgc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHRcdC8vIHNldCB0b29sdGlwIGNvbnRlbnRcclxuXHRcdFx0dG9vbHRpcFxyXG5cdFx0XHRcdC5odG1sKCQkLmdldFRvb2x0aXBIVE1MKFxyXG5cdFx0XHRcdFx0c2VsZWN0ZWREYXRhLCAvLyBkYXRhXHJcblx0XHRcdFx0XHQkJC5heGlzID8gJCQuYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKSA6ICQkLmNhdGVnb3J5TmFtZS5iaW5kKCQkKSwgLy8gZGVmYXVsdFRpdGxlRm9ybWF0XHJcblx0XHRcdFx0XHQkJC5nZXRZRm9ybWF0KGZvckFyYyksIC8vIGRlZmF1bHRWYWx1ZUZvcm1hdFxyXG5cdFx0XHRcdFx0JCQuY29sb3IgLy8gY29sb3JcclxuXHRcdFx0XHQpKVxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgbnVsbClcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIG51bGwpIC8vIGZvciBJRTlcclxuXHRcdFx0XHQuZGF0dW0oZGF0dW0gPSB7XHJcblx0XHRcdFx0XHRpbmRleCxcclxuXHRcdFx0XHRcdGN1cnJlbnQ6IGRhdGFTdHIsXHJcblx0XHRcdFx0XHR3aWR0aDogd2lkdGggPSB0b29sdGlwLnByb3BlcnR5KFwib2Zmc2V0V2lkdGhcIiksXHJcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodCA9IHRvb2x0aXAucHJvcGVydHkoXCJvZmZzZXRIZWlnaHRcIilcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3duLCAkJC5hcGksIHNlbGVjdGVkRGF0YSk7XHJcblx0XHRcdCQkLl9oYW5kbGVMaW5rZWRDaGFydHModHJ1ZSwgaW5kZXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghYmluZHRvKSB7XHJcblx0XHRcdGNvbnN0IGZuUG9zID0gY29uZmlnLnRvb2x0aXBfcG9zaXRpb24gfHwgJCQudG9vbHRpcFBvc2l0aW9uO1xyXG5cclxuXHRcdFx0Ly8gR2V0IHRvb2x0aXAgZGltZW5zaW9uc1xyXG5cdFx0XHRjb25zdCBwb3MgPSBmblBvcy5jYWxsKHRoaXMsIGRhdGFUb1Nob3csIHdpZHRoLCBoZWlnaHQsIGVsZW1lbnQpO1xyXG5cclxuXHRcdFx0W1widG9wXCIsIFwibGVmdFwiXS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gcG9zW3ZdO1xyXG5cclxuXHRcdFx0XHR0b29sdGlwLnN0eWxlKHYsIGAke3ZhbHVlfXB4YCk7XHJcblxyXG5cdFx0XHRcdC8vIFJlbWVtYmVyIGxlZnQgcG9zIGluIHBlcmNlbnRhZ2UgdG8gYmUgdXNlZCBvbiByZXNpemUgY2FsbFxyXG5cdFx0XHRcdGlmICh2ID09PSBcImxlZnRcIiAmJiAhZGF0dW0ueFBvc0luUGVyY2VudCkge1xyXG5cdFx0XHRcdFx0ZGF0dW0ueFBvc0luUGVyY2VudCA9IHZhbHVlIC8gc3RhdGUuY3VycmVudC53aWR0aCAqIDEwMDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkanVzdCB0b29sdGlwIHBvc2l0aW9uIG9uIHJlc2l6ZSBldmVudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0YmluZFRvb2x0aXBSZXNpemVQb3MoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7cmVzaXplRnVuY3Rpb24sIHN0YXRlLCAkZWw6IHt0b29sdGlwfX0gPSAkJDtcclxuXHJcblx0XHRyZXNpemVGdW5jdGlvbi5hZGQoKCkgPT4ge1xyXG5cdFx0XHRpZiAodG9vbHRpcC5zdHlsZShcImRpc3BsYXlcIikgPT09IFwiYmxvY2tcIikge1xyXG5cdFx0XHRcdGNvbnN0IHtjdXJyZW50fSA9IHN0YXRlO1xyXG5cdFx0XHRcdGNvbnN0IHt3aWR0aCwgeFBvc0luUGVyY2VudH0gPSB0b29sdGlwLmRhdHVtKCk7XHJcblx0XHRcdFx0bGV0IHZhbHVlID0gY3VycmVudC53aWR0aCAvIDEwMCAqIHhQb3NJblBlcmNlbnQ7XHJcblx0XHRcdFx0Y29uc3QgZGlmZiA9IGN1cnJlbnQud2lkdGggLSAodmFsdWUgKyB3aWR0aCk7XHJcblxyXG5cdFx0XHRcdC8vIGlmIHRvb2x0aXAgc2l6ZSBvdmVycyBjdXJyZW50IHZpZXdwb3J0IHNpemVcclxuXHRcdFx0XHRpZiAoZGlmZiA8IDApIHtcclxuXHRcdFx0XHRcdHZhbHVlICs9IGRpZmY7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0b29sdGlwLnN0eWxlKFwibGVmdFwiLCBgJHt2YWx1ZX1weGApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIHRoZSB0b29sdGlwXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBmb3JjZSBGb3JjZSB0byBoaWRlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoaWRlVG9vbHRpcChmb3JjZT86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHthcGksIGNvbmZpZywgJGVsOiB7dG9vbHRpcH19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKHRvb2x0aXAuc3R5bGUoXCJkaXNwbGF5XCIpICE9PSBcIm5vbmVcIiAmJiAoIWNvbmZpZy50b29sdGlwX2RvTm90SGlkZSB8fCBmb3JjZSkpIHtcclxuXHRcdFx0Y29uc3Qgc2VsZWN0ZWREYXRhID0gSlNPTi5wYXJzZSh0b29sdGlwLmRhdHVtKCkuY3VycmVudCk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25oaWRlLCBhcGksIHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0XHQvLyBoaWRlIHRvb2x0aXBcclxuXHRcdFx0dG9vbHRpcFxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKSAvLyBmb3IgSUU5XHJcblx0XHRcdFx0LmRhdHVtKG51bGwpO1xyXG5cclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uaGlkZGVuLCBhcGksIHNlbGVjdGVkRGF0YSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlIGRpc3BsYXkgZm9yIGxpbmtlZCBjaGFydCBpbnN0YW5jZXNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3cgdHJ1ZTogc2hvdywgZmFsc2U6IGhpZGVcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggeCBBeGlzIGluZGV4XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfaGFuZGxlTGlua2VkQ2hhcnRzKHNob3c6IGJvb2xlYW4sIGluZGV4OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjaGFydHMsIGNvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLnRvb2x0aXBfbGlua2VkICYmIGNoYXJ0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdGNvbnN0IGxpbmtlZE5hbWUgPSBjb25maWcudG9vbHRpcF9saW5rZWRfbmFtZTtcclxuXHJcblx0XHRcdGNoYXJ0cy5mb3JFYWNoKGMgPT4ge1xyXG5cdFx0XHRcdGlmIChjICE9PSAkJC5hcGkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSBjLmludGVybmFsO1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNMaW5rZWQgPSBjb25maWcudG9vbHRpcF9saW5rZWQ7XHJcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gY29uZmlnLnRvb2x0aXBfbGlua2VkX25hbWU7XHJcblx0XHRcdFx0XHRjb25zdCBpc0luRG9tID0gZG9jdW1lbnQuYm9keS5jb250YWlucygkZWwuY2hhcnQubm9kZSgpKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaXNMaW5rZWQgJiYgbGlua2VkTmFtZSA9PT0gbmFtZSAmJiBpc0luRG9tKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBjLmludGVybmFsLiRlbC50b29sdGlwLmRhdGEoKVswXTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgaXNOb3RTYW1lSW5kZXggPSBpbmRleCAhPT0gKGRhdGEgJiYgZGF0YS5pbmRleCk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IHRocm93aW5nIGVycm9yIGZvciBub24tcGFpcmVkIGxpbmtlZCBpbmRleGVzXHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHNob3cgJiYgaXNOb3RTYW1lSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5zaG93KHtpbmRleH0pO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIXNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5oaWRlKCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHthc0hhbGZQaXhlbH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG50eXBlIFRyYW5zbGF0ZVBhcmFtID0gXCJtYWluXCIgfCBcImNvbnRleHRcIiB8IFwibGVnZW5kXCIgfCBcInhcIiB8IFwieVwiIHwgXCJ5MlwiIHwgXCJzdWJYXCIgfCBcImFyY1wiIHwgXCJyYWRhclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGdldFRyYW5zbGF0ZSh0YXJnZXQ6IFRyYW5zbGF0ZVBhcmFtLCBpbmRleCA9IDApOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblx0XHRsZXQgcGFkZGluZyA9IDA7XHJcblx0XHRsZXQgeDtcclxuXHRcdGxldCB5O1xyXG5cclxuXHRcdGlmIChpbmRleCAmJiAvXih4fHkyPykkLy50ZXN0KHRhcmdldCkpIHtcclxuXHRcdFx0cGFkZGluZyA9ICQkLmdldEF4aXNTaXplKHRhcmdldCkgKiBpbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGFyZ2V0ID09PSBcIm1haW5cIikge1xyXG5cdFx0XHR4ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luLmxlZnQpO1xyXG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luLnRvcCk7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJjb250ZXh0XCIpIHtcclxuXHRcdFx0eCA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbjIubGVmdCk7XHJcblx0XHRcdHkgPSBhc0hhbGZQaXhlbChzdGF0ZS5tYXJnaW4yLnRvcCk7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJsZWdlbmRcIikge1xyXG5cdFx0XHR4ID0gc3RhdGUubWFyZ2luMy5sZWZ0O1xyXG5cdFx0XHR5ID0gc3RhdGUubWFyZ2luMy50b3AgKyAoaGFzR2F1Z2UgPyAxMCA6IDApO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieFwiKSB7XHJcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAtcGFkZGluZyA6IDA7XHJcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyAwIDogc3RhdGUuaGVpZ2h0ICsgcGFkZGluZztcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInlcIikge1xyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IC1wYWRkaW5nO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ5MlwiKSB7XHJcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAwIDogc3RhdGUud2lkdGggKyBwYWRkaW5nO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMSAtIHBhZGRpbmcgOiAwO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwic3ViWFwiKSB7XHJcblx0XHRcdHggPSAwO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodDI7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJhcmNcIikge1xyXG5cdFx0XHR4ID0gc3RhdGUuYXJjV2lkdGggLyAyO1xyXG5cdFx0XHR5ID0gc3RhdGUuYXJjSGVpZ2h0IC8gMjtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInJhZGFyXCIpIHtcclxuXHRcdFx0Y29uc3QgW3dpZHRoXSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cclxuXHRcdFx0eCA9IHN0YXRlLndpZHRoIC8gMiAtIHdpZHRoO1xyXG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luLnRvcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgO1xyXG5cdH0sXHJcblxyXG5cdHRyYW5zZm9ybU1haW4od2l0aFRyYW5zaXRpb246IGJvb2xlYW4sIHRyYW5zaXRpb25zKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkJC4kZWw7XHJcblx0XHRsZXQgeEF4aXM7XHJcblx0XHRsZXQgeUF4aXM7XHJcblx0XHRsZXQgeTJBeGlzO1xyXG5cclxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzWCkge1xyXG5cdFx0XHR4QXhpcyA9IHRyYW5zaXRpb25zLmF4aXNYO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eEF4aXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9YCk7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHR4QXhpcyA9IHhBeGlzLnRyYW5zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzWSkge1xyXG5cdFx0XHR5QXhpcyA9IHRyYW5zaXRpb25zLmF4aXNZO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eUF4aXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1l9YCk7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHR5QXhpcyA9IHlBeGlzLnRyYW5zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzWTIpIHtcclxuXHRcdFx0eTJBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1kyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eTJBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZMn1gKTtcclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdHkyQXhpcyA9IHkyQXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyBtYWluLnRyYW5zaXRpb24oKSA6IG1haW4pXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcIm1haW5cIikpO1xyXG5cclxuXHRcdHhBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwieFwiKSk7XHJcblx0XHR5QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInlcIikpO1xyXG5cdFx0eTJBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwieTJcIikpO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3N9YClcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiYXJjXCIpKTtcclxuXHR9LFxyXG5cclxuXHR0cmFuc2Zvcm1BbGwod2l0aFRyYW5zaXRpb246IGJvb2xlYW4sIHRyYW5zaXRpb25zKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2hhc0F4aXN9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0JCQudHJhbnNmb3JtTWFpbih3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpO1xyXG5cclxuXHRcdGhhc0F4aXMgJiYgY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiZcclxuXHRcdFx0JCQudHJhbnNmb3JtQ29udGV4dCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpO1xyXG5cclxuXHRcdCRlbC5sZWdlbmQgJiYgJCQudHJhbnNmb3JtTGVnZW5kKHdpdGhUcmFuc2l0aW9uKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1N0cmluZywgaXNBcnJheX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7VFlQRSwgVFlQRV9CWV9DQVRFR09SWX0gZnJvbSBcIi4uLy4uL2NvbmZpZy9jb25zdFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdHNldFRhcmdldFR5cGUodGFyZ2V0SWRzOiBzdHJpbmdbXSwgdHlwZTogc3RyaW5nKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3dpdGhvdXRGYWRlSW59fSA9ICQkO1xyXG5cclxuXHRcdCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdHdpdGhvdXRGYWRlSW5baWRdID0gKHR5cGUgPT09IGNvbmZpZy5kYXRhX3R5cGVzW2lkXSk7XHJcblx0XHRcdGNvbmZpZy5kYXRhX3R5cGVzW2lkXSA9IHR5cGU7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIXRhcmdldElkcykge1xyXG5cdFx0XHRjb25maWcuZGF0YV90eXBlID0gdHlwZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGR0ZSBjdXJyZW50IHVzZWQgY2hhcnQgdHlwZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVR5cGVzRWxlbWVudHMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHtjdXJyZW50fX0gPSAkJDtcclxuXHJcblx0XHRPYmplY3Qua2V5cyhUWVBFKS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRjb25zdCB0ID0gVFlQRVt2XTtcclxuXHRcdFx0Y29uc3QgaGFzID0gJCQuaGFzVHlwZSh0LCBudWxsLCB0cnVlKTtcclxuXHRcdFx0Y29uc3QgaWR4ID0gY3VycmVudC50eXBlcy5pbmRleE9mKHQpO1xyXG5cclxuXHRcdFx0aWYgKGlkeCA9PT0gLTEgJiYgaGFzKSB7XHJcblx0XHRcdFx0Y3VycmVudC50eXBlcy5wdXNoKHQpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlkeCA+IC0xICYmICFoYXMpIHtcclxuXHRcdFx0XHRjdXJyZW50LnR5cGVzLnNwbGljZShpZHgsIDEpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBVcGRhdGUgY3VycmVudCBjaGFydCBlbGVtZW50cyByZWZlcmVuY2VcclxuXHRcdCQkLnNldENoYXJ0RWxlbWVudHMoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiBnaXZlbiBjaGFydCB0eXBlcyBleGlzdHNcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBDaGFydCB0eXBlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0c1ZhbHVlIERhdGEgYXJyYXlcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrRnJvbURhdGEgRm9yY2UgdG8gY2hlY2sgdHlwZSBjb3RhaW5zIGZyb20gZGF0YSB0YXJnZXRzXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYXNUeXBlKHR5cGU6IHN0cmluZywgdGFyZ2V0c1ZhbHVlPywgY2hlY2tGcm9tRGF0YSA9IGZhbHNlKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2N1cnJlbnR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgdHlwZXMgPSBjb25maWcuZGF0YV90eXBlcztcclxuXHRcdGNvbnN0IHRhcmdldHMgPSB0YXJnZXRzVmFsdWUgfHwgJCQuZGF0YS50YXJnZXRzO1xyXG5cdFx0bGV0IGhhcyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICghY2hlY2tGcm9tRGF0YSAmJiBjdXJyZW50LnR5cGVzLmxlbmd0aCAmJiBjdXJyZW50LnR5cGVzLmluZGV4T2YodHlwZSkgPiAtMSkge1xyXG5cdFx0XHRoYXMgPSB0cnVlO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoKSB7XHJcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh0YXJnZXQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHQgPSB0eXBlc1t0YXJnZXQuaWRdO1xyXG5cclxuXHRcdFx0XHRpZiAodCA9PT0gdHlwZSB8fCAoIXQgJiYgdHlwZSA9PT0gXCJsaW5lXCIpKSB7XHJcblx0XHRcdFx0XHRoYXMgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHR5cGVzKS5sZW5ndGgpIHtcclxuXHRcdFx0T2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRcdGlmICh0eXBlc1tpZF0gPT09IHR5cGUpIHtcclxuXHRcdFx0XHRcdGhhcyA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhhcyA9IGNvbmZpZy5kYXRhX3R5cGUgPT09IHR5cGU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhhcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiBjb250YWlucyBnaXZlbiBjaGFydCB0eXBlc1xyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUga2V5XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldHMgVGFyZ2V0IGRhdGFcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlIEV4Y2x1ZGVkIHR5cGVzXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYXNUeXBlT2YodHlwZSwgdGFyZ2V0cywgZXhjbHVkZSA9IFtdKTogYm9vbGVhbiB7XHJcblx0XHQvLyDsi6TsoJwg64W465OcIOyhtOyerCDsl6zrtoDrj4Qg7ZmV7J247ZWE7JqUXHJcblx0XHRyZXR1cm4gIVRZUEVfQllfQ0FURUdPUllbdHlwZV1cclxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHQuZmlsdGVyKHYgPT4gZXhjbHVkZS5pbmRleE9mKHYpID09PSAtMSlcclxuXHRcdFx0LmV2ZXJ5KHYgPT4gIXRoaXMuaGFzVHlwZSh2LCB0YXJnZXRzKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgZ2l2ZW4gZGF0YSBpcyBjZXJ0YWluIGNoYXJ0IHR5cGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSB0eXBlIGNoYXJ0IHR5cGVcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGlzVHlwZU9mKGQsIHR5cGUpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcclxuXHRcdGNvbnN0IGRhdGFUeXBlID0gdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIGlzQXJyYXkodHlwZSkgP1xyXG5cdFx0XHR0eXBlLmluZGV4T2YoZGF0YVR5cGUpID49IDAgOiBkYXRhVHlwZSA9PT0gdHlwZTtcclxuXHR9LFxyXG5cclxuXHRoYXNQb2ludFR5cGUoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmhhc1R5cGVPZihcIkxpbmVcIikgfHwgJCQuaGFzVHlwZShcImJ1YmJsZVwiKSB8fCAkJC5oYXNUeXBlKFwic2NhdHRlclwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiBjb250YWlucyBhcmMgdHlwZXMgY2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0cyBUYXJnZXQgZGF0YVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGV4Y2x1ZGUgRXhjbHVkZWQgdHlwZXNcclxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhhc0FyY1R5cGUodGFyZ2V0cywgZXhjbHVkZSk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzVHlwZU9mKFwiQXJjXCIsIHRhcmdldHMsIGV4Y2x1ZGUpO1xyXG5cdH0sXHJcblxyXG5cdGhhc011bHRpQXJjR2F1Z2UoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgdGhpcy5jb25maWcuZ2F1Z2VfdHlwZSA9PT0gXCJtdWx0aVwiO1xyXG5cdH0sXHJcblxyXG5cdGlzTGluZVR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgaWQgPSBpc1N0cmluZyhkKSA/IGQgOiBkLmlkO1xyXG5cclxuXHRcdHJldHVybiAhdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF0gfHxcclxuXHRcdFx0dGhpcy5pc1R5cGVPZihpZCwgVFlQRV9CWV9DQVRFR09SWS5MaW5lKTtcclxuXHR9LFxyXG5cclxuXHRpc1N0ZXBUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVfQllfQ0FURUdPUlkuU3RlcCk7XHJcblx0fSxcclxuXHJcblx0aXNTcGxpbmVUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVfQllfQ0FURUdPUlkuU3BsaW5lKTtcclxuXHR9LFxyXG5cclxuXHRpc0FyZWFUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVfQllfQ0FURUdPUlkuQXJlYSk7XHJcblx0fSxcclxuXHJcblx0aXNBcmVhUmFuZ2VUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVfQllfQ0FURUdPUlkuQXJlYVJhbmdlKTtcclxuXHR9LFxyXG5cclxuXHRpc0JhclR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJiYXJcIik7XHJcblx0fSxcclxuXHJcblx0aXNCdWJibGVUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYnViYmxlXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzU2NhdHRlclR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJzY2F0dGVyXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzUGllVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcInBpZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc0dhdWdlVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImdhdWdlXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzRG9udXRUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiZG9udXRcIik7XHJcblx0fSxcclxuXHJcblx0aXNSYWRhclR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJyYWRhclwiKTtcclxuXHR9LFxyXG5cclxuXHRpc0FyY1R5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNQaWVUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNEb251dFR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc0dhdWdlVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzUmFkYXJUeXBlKGQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRldGVybWluZSBpZiBpcyAnY2lyY2xlJyBkYXRhIHBvaW50XHJcblx0aXNDaXJjbGVQb2ludChub2RlPyk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgcGF0dGVybiA9IGNvbmZpZy5wb2ludF9wYXR0ZXJuO1xyXG5cdFx0bGV0IGlzQ2lyY2xlID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKG5vZGUgJiYgbm9kZS50YWdOYW1lID09PSBcImNpcmNsZVwiKSB7XHJcblx0XHRcdGlzQ2lyY2xlID0gdHJ1ZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGlzQ2lyY2xlID0gY29uZmlnLnBvaW50X3R5cGUgPT09IFwiY2lyY2xlXCIgJiZcclxuXHRcdFx0XHQoIXBhdHRlcm4gfHwgKFxyXG5cdFx0XHRcdFx0aXNBcnJheShwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMFxyXG5cdFx0XHRcdCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc0NpcmNsZTtcclxuXHR9LFxyXG5cclxuXHRsaW5lRGF0YShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc0xpbmVUeXBlKGQpID8gW2RdIDogW107XHJcblx0fSxcclxuXHJcblx0YXJjRGF0YShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc0FyY1R5cGUoZC5kYXRhKSA/IFtkXSA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdGJhckRhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBbXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgZGF0YSBhZGFwdCBmb3IgZGF0YSBsYWJlbCBzaG93aW5nXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRsYWJlbGlzaERhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNMaW5lVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzU2NhdHRlclR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc0J1YmJsZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1JhZGFyVHlwZShkKSA/IGQudmFsdWVzIDogW107XHJcblx0fSxcclxuXHJcblx0YmFyTGluZUJ1YmJsZURhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpIHx8IHRoaXMuaXNMaW5lVHlwZShkKSB8fCB0aGlzLmlzQnViYmxlVHlwZShkKSA/XHJcblx0XHRcdGQudmFsdWVzIDogW107XHJcblx0fSxcclxuXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlI2N1cnZlc1xyXG5cdGlzSW50ZXJwb2xhdGlvblR5cGUodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcImJhc2lzXCIsXHJcblx0XHRcdFwiYmFzaXMtY2xvc2VkXCIsXHJcblx0XHRcdFwiYmFzaXMtb3BlblwiLFxyXG5cdFx0XHRcImJ1bmRsZVwiLFxyXG5cdFx0XHRcImNhcmRpbmFsXCIsXHJcblx0XHRcdFwiY2FyZGluYWwtY2xvc2VkXCIsXHJcblx0XHRcdFwiY2FyZGluYWwtb3BlblwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tXCIsXHJcblx0XHRcdFwiY2F0bXVsbC1yb20tY2xvc2VkXCIsXHJcblx0XHRcdFwiY2F0bXVsbC1yb20tb3BlblwiLFxyXG5cdFx0XHRcImxpbmVhclwiLFxyXG5cdFx0XHRcImxpbmVhci1jbG9zZWRcIixcclxuXHRcdFx0XCJtb25vdG9uZS14XCIsXHJcblx0XHRcdFwibW9ub3RvbmUteVwiLFxyXG5cdFx0XHRcIm5hdHVyYWxcIlxyXG5cdFx0XS5pbmRleE9mKHR5cGUpID49IDA7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNWYWx1ZSwgaXNEZWZpbmVkLCBpc09iamVjdFR5cGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgbWluL21heCB2YWx1ZVxyXG4gKiBAcGFyYW0ge0NoYXJ0fSAkJCBDaGFydCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBTZXQgdHlwZSAnbWluJyBvciAnbWF4J1xyXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgVmFsdWUgdG8gYmUgc2V0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRNaW5NYXgoJCQsIHR5cGU6IFwibWluXCIgfCBcIm1heFwiLCB2YWx1ZSk6IHZvaWQge1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0Y29uc3QgYXhpc1ggPSBgYXhpc194XyR7dHlwZX1gO1xyXG5cdGNvbnN0IGF4aXNZID0gYGF4aXNfeV8ke3R5cGV9YDtcclxuXHRjb25zdCBheGlzWTIgPSBgYXhpc195Ml8ke3R5cGV9YDtcclxuXHJcblx0aWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuXHRcdGlmIChpc09iamVjdFR5cGUodmFsdWUpKSB7XHJcblx0XHRcdGlzVmFsdWUodmFsdWUueCkgJiYgKGNvbmZpZ1theGlzWF0gPSB2YWx1ZS54KTtcclxuXHRcdFx0aXNWYWx1ZSh2YWx1ZS55KSAmJiAoY29uZmlnW2F4aXNZXSA9IHZhbHVlLnkpO1xyXG5cdFx0XHRpc1ZhbHVlKHZhbHVlLnkyKSAmJiAoY29uZmlnW2F4aXNZMl0gPSB2YWx1ZS55Mik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25maWdbYXhpc1ldID0gdmFsdWU7XHJcblx0XHRcdGNvbmZpZ1theGlzWTJdID0gdmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXHJcblx0XHR9KTtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIG1pbi9tYXggdmFsdWVcclxuICogQHBhcmFtIHtDaGFydH0gJCQgQ2hhcnQgaW5zdGFuY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgU2V0IHR5cGUgJ21pbicgb3IgJ21heCdcclxuICogQHJldHVybnMge3t4LCB5LCB5Mn19XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNaW5NYXgoJCQsIHR5cGU6IFwibWluXCIgfCBcIm1heFwiKToge3g6IG51bWJlciwgeTogbnVtYmVyLCB5MjogbnVtYmVyfSB7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IGNvbmZpZ1tgYXhpc194XyR7dHlwZX1gXSxcclxuXHRcdHk6IGNvbmZpZ1tgYXhpc195XyR7dHlwZX1gXSxcclxuXHRcdHkyOiBjb25maWdbYGF4aXNfeTJfJHt0eXBlfWBdXHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmluZSBheGlzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNvbnN0IGF4aXMgPSB7XHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhpcyBsYWJlbHMuXHJcblx0ICogQGZ1bmN0aW9uIGF4aXPigKRsYWJlbHNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gbGFiZWxzIHNwZWNpZmllZCBheGlzJyBsYWJlbCB0byBiZSB1cGRhdGVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gVXBkYXRlIGF4aXMnIGxhYmVsXHJcblx0ICogY2hhcnQuYXhpcy5sYWJlbHMoe1xyXG5cdCAqICAgeDogXCJOZXcgWCBBeGlzIExhYmVsXCIsXHJcblx0ICogICB5OiBcIk5ldyBZIEF4aXMgTGFiZWxcIlxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGxhYmVsczogZnVuY3Rpb24obGFiZWxzOiB7eD86IHN0cmluZywgeT86IHN0cmluZywgeTI/OiBzdHJpbmd9KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0T2JqZWN0LmtleXMobGFiZWxzKS5mb3JFYWNoKGF4aXNJZCA9PiB7XHJcblx0XHRcdFx0JCQuYXhpcy5zZXRMYWJlbFRleHQoYXhpc0lkLCBsYWJlbHNbYXhpc0lkXSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuYXhpcy51cGRhdGVMYWJlbHMoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1pbiB2YWx1ZS5cclxuXHQgKiBAZnVuY3Rpb24gYXhpc+KApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtaW4gSWYgbWluIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIHZhbHVlIHdpbGwgYmUgdXBkYXRlZC48YnI+XHJcblx0ICogICAgIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbWluIHZhbHVlcyBzZXQgb24gZ2VuZXJhdGluZyBvcHRpb24gZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICAgICBJZiBub3Qgc2V0IGFueSBtaW4gdmFsdWVzIG9uIGdlbmVyYXRpb24sIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R8dW5kZWZpbmVkfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gVXBkYXRlIGF4aXMnIG1pblxyXG5cdCAqIGNoYXJ0LmF4aXMubWluKHtcclxuXHQgKiAgIHg6IC0xMCxcclxuXHQgKiAgIHk6IDEwMDAsXHJcblx0ICogICB5MjogMTAwXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbihtaW4/OiBudW1iZXIpOiBvYmplY3R8dm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0cmV0dXJuIGlzVmFsdWUobWluKSA/XHJcblx0XHRcdHNldE1pbk1heCgkJCwgXCJtaW5cIiwgbWluKSA6XHJcblx0XHRcdGdldE1pbk1heCgkJCwgXCJtaW5cIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhpcyBtYXggdmFsdWUuXHJcblx0ICogQGZ1bmN0aW9uIGF4aXPigKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gbWF4IElmIG1heCBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1heCB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuPGJyPlxyXG5cdCAqICAgICBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG1heCB2YWx1ZXMgc2V0IG9uIGdlbmVyYXRpbmcgb3B0aW9uIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiAgICAgSWYgbm90IHNldCBhbnkgbWF4IHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fHVuZGVmaW5lZH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMubWF4KHtcclxuXHQgKiAgICB4OiAxMDAsXHJcblx0ICogICAgeTogMTAwMCxcclxuXHQgKiAgICB5MjogMTAwMDBcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKG1heD86IG51bWJlcik6IG9iamVjdHx2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/XHJcblx0XHRcdHNldE1pbk1heCgkJCwgXCJtYXhcIiwgbWF4KSA6XHJcblx0XHRcdGdldE1pbk1heCgkJCwgXCJtYXhcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhpcyBtaW4gYW5kIG1heCB2YWx1ZS5cclxuXHQgKiBAZnVuY3Rpb24gYXhpc+KApHJhbmdlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHJhbmdlIElmIHJhbmdlIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIGFuZCBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgbWluIGFuZCBtYXggdmFsdWVzIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fHVuZGVmaW5lZH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMucmFuZ2Uoe1xyXG5cdCAqICAgbWluOiB7XHJcblx0ICogICAgIHg6IC0xMCxcclxuXHQgKiAgICAgeTogLTEwMDAsXHJcblx0ICogICAgIHkyOiAtMTAwMDBcclxuXHQgKiAgIH0sXHJcblx0ICogICBtYXg6IHtcclxuXHQgKiAgICAgeDogMTAwLFxyXG5cdCAqICAgICB5OiAxMDAwLFxyXG5cdCAqICAgICB5MjogMTAwMDBcclxuXHQgKiAgIH0sXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0cmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKTogb2JqZWN0fHZvaWQge1xyXG5cdFx0Y29uc3Qge2F4aXN9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRpc0RlZmluZWQocmFuZ2UubWF4KSAmJiBheGlzLm1heChyYW5nZS5tYXgpO1xyXG5cdFx0XHRpc0RlZmluZWQocmFuZ2UubWluKSAmJiBheGlzLm1pbihyYW5nZS5taW4pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRtYXg6IGF4aXMubWF4KCksXHJcblx0XHRcdFx0bWluOiBheGlzLm1pbigpXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7YXhpc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBzcGVjaWZpZWQgY2F0ZWdvcnkgbmFtZSBvbiBjYXRlZ29yeSBheGlzLlxyXG5cdCAqIEBmdW5jdGlvbiBjYXRlZ29yeVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIGluZGV4IG9mIGNhdGVnb3J5IHRvIGJlIGNoYW5nZWRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnkgY2F0ZWdvcnkgdmFsdWUgdG8gYmUgY2hhbmdlZFxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5jYXRlZ29yeSgyLCBcIkNhdGVnb3J5IDNcIik7XHJcblx0ICovXHJcblx0Y2F0ZWdvcnkoaTogbnVtYmVyLCBjYXRlZ29yeTogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXSA9IGNhdGVnb3J5O1xyXG5cdFx0XHQkJC5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzW2ldO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjYXRlZ29yeSBuYW1lcyBvbiBjYXRlZ29yeSBheGlzLlxyXG5cdCAqIEBmdW5jdGlvbiBjYXRlZ29yaWVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gY2F0ZWdvcmllcyBUaGlzIG11c3QgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBjYXRlZ29yeSBuYW1lcyBpbiBzdHJpbmcuIElmIGNhdGVnb3J5IG5hbWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBieSBkYXRhLnggb3B0aW9uLCB0aGlzIGlzIG5vdCByZXF1aXJlZC5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5jYXRlZ29yaWVzKFtcclxuXHQgKiAgICAgIFwiQ2F0ZWdvcnkgMVwiLCBcIkNhdGVnb3J5IDJcIiwgLi4uXHJcblx0ICogXSk7XHJcblx0ICovXHJcblx0Y2F0ZWdvcmllcyhjYXRlZ29yaWVzOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gY2F0ZWdvcmllcztcclxuXHRcdCQkLnJlZHJhdygpO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNEZWZpbmVkLCBpc1RhYlZpc2libGUsIGlzVmFsdWUsIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogRmxvdyBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxyXG5cdCAqIEJ5IHRoaXMgQVBJLCB5b3UgY2FuIGFwcGVuZCBuZXcgZGF0YSBwb2ludHMgdG8gdGhlIGNoYXJ0LlxyXG5cdCAqIEBmdW5jdGlvbiBmbG93XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCBqc29uIHwgT2JqZWN0IHwgRGF0YSBhcyBKU09OIGZvcm1hdCAoQHNlZSBbZGF0YeKApGpzb25dKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGpzb24pKSB8XHJcblx0ICogICAgfCByb3dzIHwgQXJyYXkgfCBEYXRhIGluIGFycmF5IGFzIHJvdyBmb3JtYXQgKEBzZWUgW2RhdGHigKRyb3dzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxyXG5cdCAqICAgIHwgY29sdW1ucyB8IEFycmF5IHwgRGF0YSBpbiBhcnJheSBhcyBjb2x1bW4gZm9ybWF0IChAc2VlIFtkYXRh4oCkY29sdW1uc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0Y29sdW1ucykpIHxcclxuXHQgKiAgICB8IHRvIHwgU3RyaW5nIHwgVGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgdG8gdGhhdCBwb2ludC4gSWYgbm90IGdpdmVuLCB0aGUgbG93ZXIgeCBlZGdlIHdpbGwgbW92ZSBieSB0aGUgbnVtYmVyIG9mIGdpdmVuIGRhdGEgcG9pbnRzIHxcclxuXHQgKiAgICB8IGxlbmd0aCB8IE51bWJlciB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIGJ5IHRoZSBudW1iZXIgb2YgdGhpcyBhcmd1bWVudCB8XHJcblx0ICogICAgfCBkdXJhdGlvbiB8IE51bWJlciB8IFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIHNwZWNpZmllZCB2YWx1ZS4gSWYgbm90IGdpdmVuLCB0cmFuc2l0aW9uLmR1cmF0aW9uIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHxcclxuXHQgKiAgICB8IGRvbmUgfCBGdW5jdGlvbiB8IFRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBmbG93IGVuZHMgfFxyXG5cdCAqXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gSWYganNvbiwgcm93cyBhbmQgY29sdW1ucyBnaXZlbiwgdGhlIGRhdGEgd2lsbCBiZSBsb2FkZWQuXHJcblx0ICogICAtIElmIGRhdGEgdGhhdCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGlkIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSBhcHBlbmRlZC5cclxuXHQgKiAgIC0gT3RoZXJ3aXNlLCBuZXcgdGFyZ2V0IHdpbGwgYmUgYWRkZWQuIE9uZSBvZiB0aGVzZSBpcyByZXF1aXJlZCB3aGVuIGNhbGxpbmcuXHJcblx0ICogICAtIElmIGpzb24gc3BlY2lmaWVkLCBrZXlzIGlzIHJlcXVpcmVkIGFzIHdlbGwgYXMgZGF0YS5qc29uLlxyXG5cdCAqIFx0IC0gSWYgdGFiIGlzbid0IHZpc2libGUoYnkgZXZhbHVhdGluZyBgZG9jdW1lbnQuaGlkZGVuYCksIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnkgd29yay5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIDIgZGF0YSBwb2ludHMgd2lsbCBiZSBhcHByZW5kZWQgdG8gdGhlIHRhaWwgYW5kIHBvcHBlZCBmcm9tIHRoZSBoZWFkLlxyXG5cdCAqIC8vIEFmdGVyIHRoYXQsIDQgZGF0YSBwb2ludHMgd2lsbCBiZSBhcHBlbmRlZCBhbmQgbm8gZGF0YSBwb2ludHMgd2lsbCBiZSBwb3Bwb2VkLlxyXG5cdCAqIGNoYXJ0LmZsb3coe1xyXG5cdCAqICBjb2x1bW5zOiBbXHJcblx0ICogICAgW1wieFwiLCBcIjIwMTgtMDEtMTFcIiwgXCIyMDE4LTAxLTIxXCJdLFxyXG5cdCAqICAgIFtcImRhdGExXCIsIDUwMCwgMjAwXSxcclxuXHQgKiAgICBbXCJkYXRhMlwiLCAxMDAsIDMwMF0sXHJcblx0ICogICAgW1wiZGF0YTNcIiwgMjAwLCAxMjBdXHJcblx0ICogIF0sXHJcblx0ICogIHRvOiBcIjIwMTMtMDEtMTFcIixcclxuXHQgKiAgZG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdCAqICAgIGNoYXJ0LmZsb3coe1xyXG5cdCAqICAgICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgICBbXCJ4XCIsIFwiMjAxOC0wMi0xMVwiLCBcIjIwMTgtMDItMTJcIiwgXCIyMDE4LTAyLTEzXCIsIFwiMjAxOC0wMi0xNFwiXSxcclxuXHQgKiAgICAgICAgW1wiZGF0YTFcIiwgMjAwLCAzMDAsIDEwMCwgMjUwXSxcclxuXHQgKiAgICAgICAgW1wiZGF0YTJcIiwgMTAwLCA5MCwgNDAsIDEyMF0sXHJcblx0ICogICAgICAgIFtcImRhdGEzXCIsIDEwMCwgMTAwLCAzMDAsIDUwMF1cclxuXHQgKiAgICAgIF0sXHJcblx0ICogICAgICBsZW5ndGg6IDIsXHJcblx0ICogICAgICBkdXJhdGlvbjogMTUwMFxyXG5cdCAqICAgIH0pO1xyXG5cdCAqICB9XHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0ZmxvdyhhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRsZXQgZGF0YTtcclxuXHRcdGxldCBkb21haW47XHJcblx0XHRsZXQgbGVuZ3RoOiBudW1iZXIgPSAwO1xyXG5cdFx0bGV0IHRhaWwgPSAwO1xyXG5cdFx0bGV0IGRpZmY7XHJcblx0XHRsZXQgdG87XHJcblxyXG5cdFx0aWYgKGFyZ3MuanNvbiB8fCBhcmdzLnJvd3MgfHwgYXJncy5jb2x1bW5zKSB7XHJcblx0XHRcdGRhdGEgPSAkJC5jb252ZXJ0RGF0YShhcmdzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWRhdGEgfHwgIWlzVGFiVmlzaWJsZSgpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBub3Rmb3VuZElkczogc3RyaW5nW10gPSBbXTtcclxuXHRcdGNvbnN0IG9yZ0RhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEsIHRydWUpO1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuYXhpcy5pc1RpbWVTZXJpZXMoKTtcclxuXHJcblx0XHQvLyBVcGRhdGUvQWRkIGRhdGFcclxuXHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmICh0LmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XHJcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHQudmFsdWVzW3QudmFsdWVzLmxlbmd0aCAtIDFdKSB7XHJcblx0XHRcdFx0XHRcdHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGVuZ3RoID0gdGFyZ2V0c1tpXS52YWx1ZXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0c1tpXS52YWx1ZXNbal0uaW5kZXggPSB0YWlsICsgajtcclxuXHJcblx0XHRcdFx0XHRcdGlmICghaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0XHRcdFx0dGFyZ2V0c1tpXS52YWx1ZXNbal0ueCA9IHRhaWwgKyBqO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dC52YWx1ZXMgPSB0LnZhbHVlcy5jb25jYXQodGFyZ2V0c1tpXS52YWx1ZXMpO1xyXG5cdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCFmb3VuZCAmJiBub3Rmb3VuZElkcy5wdXNoKHQuaWQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gQXBwZW5kIG51bGwgZm9yIG5vdCBmb3VuZCB0YXJnZXRzXHJcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBub3Rmb3VuZElkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmICh0LmlkID09PSBub3Rmb3VuZElkc1tpXSkge1xyXG5cdFx0XHRcdFx0dGFpbCA9IHQudmFsdWVzW3QudmFsdWVzLmxlbmd0aCAtIDFdLmluZGV4ICsgMTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHQudmFsdWVzLnB1c2goe1xyXG5cdFx0XHRcdFx0XHRcdGlkOiB0LmlkLFxyXG5cdFx0XHRcdFx0XHRcdGluZGV4OiB0YWlsICsgaixcclxuXHRcdFx0XHRcdFx0XHR4OiBpc1RpbWVTZXJpZXMgPyAkJC5nZXRPdGhlclRhcmdldFgodGFpbCArIGopIDogdGFpbCArIGosXHJcblx0XHRcdFx0XHRcdFx0dmFsdWU6IG51bGxcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBHZW5lcmF0ZSBudWxsIHZhbHVlcyBmb3IgbmV3IHRhcmdldFxyXG5cdFx0aWYgKCQkLmRhdGEudGFyZ2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IG1pc3Npbmc6IGFueVtdID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzWzBdLmluZGV4OyBpIDwgdGFpbDsgaSsrKSB7XHJcblx0XHRcdFx0XHRtaXNzaW5nLnB1c2goe1xyXG5cdFx0XHRcdFx0XHRpZDogdC5pZCxcclxuXHRcdFx0XHRcdFx0aW5kZXg6IGksXHJcblx0XHRcdFx0XHRcdHg6IGlzVGltZVNlcmllcyA/ICQkLmdldE90aGVyVGFyZ2V0WChpKSA6IGksXHJcblx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHQudmFsdWVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHR2LmluZGV4ICs9IHRhaWw7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCFpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHRcdFx0di54ICs9IHRhaWw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHQudmFsdWVzID0gbWlzc2luZy5jb25jYXQodC52YWx1ZXMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuY29uY2F0KHRhcmdldHMpOyAvLyBhZGQgcmVtYWluZWRcclxuXHJcblx0XHQvLyBjaGVjayBkYXRhIGNvdW50IGJlY2F1c2UgYmVoYXZpb3IgbmVlZHMgdG8gY2hhbmdlIHdoZW4gaXRcInMgb25seSBvbmVcclxuXHRcdC8vIGNvbnN0IGRhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xyXG5cdFx0Y29uc3QgYmFzZVRhcmdldCA9ICQkLmRhdGEudGFyZ2V0c1swXTtcclxuXHRcdGNvbnN0IGJhc2VWYWx1ZSA9IGJhc2VUYXJnZXQudmFsdWVzWzBdO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBsZW5ndGggdG8gZmxvdyBpZiBuZWVkZWRcclxuXHRcdGlmIChpc0RlZmluZWQoYXJncy50bykpIHtcclxuXHRcdFx0bGVuZ3RoID0gMDtcclxuXHRcdFx0dG8gPSBpc1RpbWVTZXJpZXMgPyBwYXJzZURhdGUuY2FsbCgkJCwgYXJncy50bykgOiBhcmdzLnRvO1xyXG5cclxuXHRcdFx0YmFzZVRhcmdldC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHR2LnggPCB0byAmJiBsZW5ndGgrKztcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLmxlbmd0aCkpIHtcclxuXHRcdFx0bGVuZ3RoID0gYXJncy5sZW5ndGg7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgb25seSBvbmUgZGF0YSwgdXBkYXRlIHRoZSBkb21haW4gdG8gZmxvdyBmcm9tIGxlZnQgZWRnZSBvZiB0aGUgY2hhcnRcclxuXHRcdGlmICghb3JnRGF0YUNvdW50KSB7XHJcblx0XHRcdGlmIChpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHRkaWZmID0gYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoID4gMSA/XHJcblx0XHRcdFx0XHRiYXNlVGFyZ2V0LnZhbHVlc1tiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggLSAxXS54IC0gYmFzZVZhbHVlLnggOlxyXG5cdFx0XHRcdFx0YmFzZVZhbHVlLnggLSAkJC5nZXRYRG9tYWluKCQkLmRhdGEudGFyZ2V0cylbMF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZGlmZiA9IDE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRvbWFpbiA9IFtiYXNlVmFsdWUueCAtIGRpZmYsIGJhc2VWYWx1ZS54XTtcclxuXHRcdH0gZWxzZSBpZiAob3JnRGF0YUNvdW50ID09PSAxICYmIGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRkaWZmID0gKGJhc2VUYXJnZXQudmFsdWVzW2Jhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCAtIDFdLnggLSBiYXNlVmFsdWUueCkgLyAyO1xyXG5cdFx0XHRkb21haW4gPSBbbmV3IERhdGUoK2Jhc2VWYWx1ZS54IC0gZGlmZiksIG5ldyBEYXRlKCtiYXNlVmFsdWUueCArIGRpZmYpXTtcclxuXHRcdH1cclxuXHJcblx0XHRkb21haW4gJiYgJCQudXBkYXRlWERvbWFpbihudWxsLCB0cnVlLCB0cnVlLCBmYWxzZSwgZG9tYWluKTtcclxuXHJcblx0XHQvLyBTZXQgdGFyZ2V0c1xyXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdC8vIFJlZHJhdyB3aXRoIG5ldyB0YXJnZXRzXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRmbG93OiB7XHJcblx0XHRcdFx0aW5kZXg6IGJhc2VWYWx1ZS5pbmRleCxcclxuXHRcdFx0XHRsZW5ndGg6IGxlbmd0aCxcclxuXHRcdFx0XHRkdXJhdGlvbjogaXNWYWx1ZShhcmdzLmR1cmF0aW9uKSA/IGFyZ3MuZHVyYXRpb24gOiAkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbixcclxuXHRcdFx0XHRkb25lOiBhcmdzLmRvbmUsXHJcblx0XHRcdFx0b3JnRGF0YUNvdW50OiBvcmdEYXRhQ291bnQsXHJcblx0XHRcdH0sXHJcblx0XHRcdHdpdGhMZWdlbmQ6IHRydWUsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBvcmdEYXRhQ291bnQgPiAxLFxyXG5cdFx0XHR3aXRoVHJpbVhEb21haW46IGZhbHNlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWEF4aXM6IHRydWVcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG50eXBlIGdyaWRzUGFyYW0gPSB7dmFsdWU/OiBudW1iZXIsIGNsYXNzPzogc3RyaW5nLCB0ZXh0Pzogc3RyaW5nfVtdO1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB4IGdyaWQgbGluZXMuXHJcbiAqIEBmdW5jdGlvbiB4Z3JpZHNcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge0FycmF5fSBncmlkcyBYIGdyaWQgbGluZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoaXMgYXJndW1lbnQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLngubGluZXMuXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAqIEBleGFtcGxlXHJcbiAqICAvLyBTaG93IDIgeCBncmlkIGxpbmVzXHJcbiAqIGNoYXJ0LnhncmlkcyhbXHJcbiAqICAgIHt2YWx1ZTogMSwgdGV4dDogXCJMYWJlbCAxXCJ9LFxyXG4gKiAgICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG4gKiBdKTtcclxuICogLy8gLS0+IFJldHVybnM6IFt7dmFsdWU6IDEsIHRleHQ6IFwiTGFiZWwgMVwifSwge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1dXHJcbiAqL1xyXG5mdW5jdGlvbiB4Z3JpZHMoZ3JpZHM6IGdyaWRzUGFyYW0pOiBncmlkc1BhcmFtIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0aWYgKCFncmlkcykge1xyXG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XHJcblx0fVxyXG5cclxuXHRjb25maWcuZ3JpZF94X2xpbmVzID0gZ3JpZHM7XHJcblx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcclxuXHJcblx0cmV0dXJuIGNvbmZpZy5ncmlkX3hfbGluZXM7XHJcbn1cclxuXHJcbmV4dGVuZCh4Z3JpZHMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgeCBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSBhZGRzIG5ldyB4IGdyaWQgbGluZXMgaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSB4Z3JpZHMuXHJcblx0ICogQGZ1bmN0aW9uIHhncmlkc+KApGFkZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl8b2JqZWN0fSBncmlkcyBOZXcgeCBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLngubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXHJcblx0ICogY2hhcnQueGdyaWRzLmFkZChcclxuXHQgKiAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcblx0ICogKTtcclxuXHQgKlxyXG5cdCAqIC8vIEFkZCBuZXcgeCBncmlkIGxpbmVzXHJcblx0ICogY2hhcnQueGdyaWRzLmFkZChbXHJcblx0ICogICB7dmFsdWU6IDIsIHRleHQ6IFwiTGFiZWwgMlwifSxcclxuXHQgKiAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcblx0ICogXSk7XHJcblx0ICovXHJcblx0YWRkOiBmdW5jdGlvbihncmlkczogZ3JpZHNQYXJhbSk6IGdyaWRzUGFyYW0ge1xyXG5cdFx0cmV0dXJuIHRoaXMueGdyaWRzKFxyXG5cdFx0XHR0aGlzLmludGVybmFsLmNvbmZpZy5ncmlkX3hfbGluZXNcclxuXHRcdFx0XHQuY29uY2F0KGdyaWRzIHx8IFtdKVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgeCBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHggZ3JpZCBsaW5lcy5cclxuXHQgKiBAZnVuY3Rpb24geGdyaWRz4oCkcmVtb3ZlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBUaGlzIGFyZ3VtZW50IHNob3VsZCBpbmNsdWRlIHZhbHVlIG9yIGNsYXNzLiBJZiB2YWx1ZSBpcyBnaXZlbiwgdGhlIHggZ3JpZCBsaW5lcyB0aGF0IGhhdmUgc3BlY2lmaWVkIHggdmFsdWUgd2lsbCBiZSByZW1vdmVkLiBJZiBjbGFzcyBpcyBnaXZlbiwgdGhlIHggZ3JpZCBsaW5lcyB0aGF0IGhhdmUgc3BlY2lmaWVkIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZC4gSWYgYXJncyBpcyBub3QgZ2l2ZW4sIGFsbCBvZiB4IGdyaWQgbGluZXMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8geCBncmlkIGxpbmUgb24geCA9IDIgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueGdyaWRzLnJlbW92ZSh7dmFsdWU6IDJ9KTtcclxuXHQgKlxyXG5cdCAqIC8vIHggZ3JpZCBsaW5lcyB0aGF0IGhhdmUgJ2dyaWQtQScgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueGdyaWRzLnJlbW92ZSh7XHJcblx0ICogICBjbGFzczogXCJncmlkLUFcIlxyXG5cdCAqIH0pO1xyXG5cdCAqXHJcblx0ICogLy8gYWxsIG9mIHggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC54Z3JpZHMucmVtb3ZlKCk7XHJcblx0ICovXHJcblx0cmVtb3ZlOiBmdW5jdGlvbihwYXJhbXM/OiBncmlkc1BhcmFtKTogdm9pZCB7IC8vIFRPRE86IG11bHRpcGxlXHJcblx0XHR0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIHRydWUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7eGdyaWRzfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogVXBkYXRlIHkgZ3JpZCBsaW5lcy5cclxuICogQGZ1bmN0aW9uIHlncmlkc1xyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGdyaWRzIFkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueS5saW5lcy5cclxuICogQHJldHVybnMge29iamVjdH1cclxuICogQGV4YW1wbGVcclxuICogIC8vIFNob3cgMiB5IGdyaWQgbGluZXNcclxuICogY2hhcnQueWdyaWRzKFtcclxuICogICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgMVwifSxcclxuICogICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG4gKiBdKTtcclxuICogLy8gLS0+IFJldHVybnM6IFt7dmFsdWU6IDEwMCwgdGV4dDogXCJMYWJlbCAxXCJ9LCB7dmFsdWU6IDQwMCwgdGV4dDogXCJMYWJlbCA0XCJ9XVxyXG4gKi9cclxuZnVuY3Rpb24geWdyaWRzKGdyaWRzOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10pOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10ge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRpZiAoIWdyaWRzKSB7XHJcblx0XHRyZXR1cm4gY29uZmlnLmdyaWRfeV9saW5lcztcclxuXHR9XHJcblxyXG5cdGNvbmZpZy5ncmlkX3lfbGluZXMgPSBncmlkcztcclxuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRyZXR1cm4gY29uZmlnLmdyaWRfeV9saW5lcztcclxufVxyXG5cclxuZXh0ZW5kKHlncmlkcywge1xyXG5cdC8qKlxyXG5cdCAqIEFkZCB5IGdyaWQgbGluZXMuPGJyPlxyXG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHkgZ3JpZCBsaW5lcyBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHlncmlkcy5cclxuXHQgKiBAZnVuY3Rpb24geWdyaWRz4oCkYWRkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheXxvYmplY3R9IGdyaWRzIE5ldyB5IGdyaWQgbGluZXMgd2lsbCBiZSBhZGRlZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueS5saW5lcyBhbmQgaXQncyBwb3NzaWJsZSB0byBnaXZlIGFuIE9iamVjdCBpZiBvbmx5IG9uZSBsaW5lIHdpbGwgYmUgYWRkZWQuXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBBZGQgYSBuZXcgeCBncmlkIGxpbmVcclxuXHQgKiBjaGFydC55Z3JpZHMuYWRkKFxyXG5cdCAqICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqICk7XHJcblx0ICpcclxuXHQgKiAvLyBBZGQgbmV3IHggZ3JpZCBsaW5lc1xyXG5cdCAqIGNoYXJ0Lnlncmlkcy5hZGQoW1xyXG5cdCAqICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgMlwifSxcclxuXHQgKiAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuXHQgKiBdKTtcclxuXHQgKi9cclxuXHRhZGQ6IGZ1bmN0aW9uKGdyaWRzOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10pOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10ge1xyXG5cdFx0cmV0dXJuIHRoaXMueWdyaWRzKFxyXG5cdFx0XHR0aGlzLmludGVybmFsLmNvbmZpZy5ncmlkX3lfbGluZXNcclxuXHRcdFx0XHQuY29uY2F0KGdyaWRzIHx8IFtdKVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgeSBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHggZ3JpZCBsaW5lcy5cclxuXHQgKiBAZnVuY3Rpb24geWdyaWRz4oCkcmVtb3ZlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBUaGlzIGFyZ3VtZW50IHNob3VsZCBpbmNsdWRlIHZhbHVlIG9yIGNsYXNzLiBJZiB2YWx1ZSBpcyBnaXZlbiwgdGhlIHkgZ3JpZCBsaW5lcyB0aGF0IGhhdmUgc3BlY2lmaWVkIHkgdmFsdWUgd2lsbCBiZSByZW1vdmVkLiBJZiBjbGFzcyBpcyBnaXZlbiwgdGhlIHkgZ3JpZCBsaW5lcyB0aGF0IGhhdmUgc3BlY2lmaWVkIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZC4gSWYgYXJncyBpcyBub3QgZ2l2ZW4sIGFsbCBvZiB5IGdyaWQgbGluZXMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8geSBncmlkIGxpbmUgb24geSA9IDIwMCB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC55Z3JpZHMucmVtb3ZlKHt2YWx1ZTogMjAwfSk7XHJcblx0ICpcclxuXHQgKiAvLyB5IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnlncmlkcy5yZW1vdmUoe1xyXG5cdCAqICAgY2xhc3M6IFwiZ3JpZC1BXCJcclxuXHQgKiB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCBvZiB5IGdyaWQgbGluZXMgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSgpO1xyXG5cdCAqL1xyXG5cdHJlbW92ZTogZnVuY3Rpb24ocGFyYW1zPzoge3ZhbHVlPzogbnVtYmVyLCBjbGFzcz86IHN0cmluZ30pOiB2b2lkIHsgLy8gVE9ETzogbXVsdGlwbGVcclxuXHRcdHRoaXMuaW50ZXJuYWwucmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgZmFsc2UpO1xyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7eWdyaWRzfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVW5kZWZpbmVkfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBVcGRhdGUgZ3JvdXBzIGZvciB0aGUgdGFyZ2V0cy5cclxuXHQgKiBAZnVuY3Rpb24gZ3JvdXBzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gZ3JvdXBzIFRoaXMgYXJndW1lbnQgbmVlZHMgdG8gYmUgYW4gQXJyYXkgdGhhdCBpbmNsdWRlcyBvbmUgb3IgbW9yZSBBcnJheSB0aGF0IGluY2x1ZGVzIHRhcmdldCBpZHMgdG8gYmUgZ3JvdXBlZC5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEdyb3VwZWQgZGF0YSBuYW1lcyBhcnJheVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIGEgbmV3IGdyb3VwLlxyXG5cdCAqICBjaGFydC5ncm91cHMoW1xyXG5cdCAqICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdXHJcblx0ICogIF0pO1xyXG5cdCAqL1xyXG5cdGdyb3Vwcyhncm91cHM6IHN0cmluZ1tdW10pOiBzdHJpbmdbXVtdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGlzVW5kZWZpbmVkKGdyb3VwcykpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy5kYXRhX2dyb3VwcztcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcuZGF0YV9ncm91cHMgPSBncm91cHM7XHJcblx0XHQkJC5yZWRyYXcoKTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmRhdGFfZ3JvdXBzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0T3B0aW9uLCBleHRlbmR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxudHlwZSByZWdpb25zUGFyYW0gPSB7YXhpcz86IHN0cmluZywgY2xhc3M/OiBzdHJpbmcsIHN0YXJ0PzogbnVtYmVyLCBlbmQ/OiBudW1iZXJ9W107XHJcblxyXG4vKipcclxuICogVXBkYXRlIHJlZ2lvbnMuXHJcbiAqIEBmdW5jdGlvbiByZWdpb25zXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtBcnJheX0gcmVnaW9ucyBSZWdpb25zIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgcmVnaW9ucy5cclxuICogQHJldHVybnMge0FycmF5fSByZWdpb25zXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFNob3cgMiByZWdpb25zXHJcbiAqIGNoYXJ0LnJlZ2lvbnMoW1xyXG4gKiAgICB7YXhpczogXCJ4XCIsIHN0YXJ0OiA1LCBjbGFzczogXCJyZWdpb25YXCJ9LFxyXG4gKiAgICB7YXhpczogXCJ5XCIsIGVuZDogNTAsIGNsYXNzOiBcInJlZ2lvbllcIn1cclxuICogXSk7XHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpb25zKHJlZ2lvbnM6IHJlZ2lvbnNQYXJhbSk6IHJlZ2lvbnNQYXJhbSB7XHJcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdGlmICghcmVnaW9ucykge1xyXG5cdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xyXG5cdH1cclxuXHJcblx0Y29uZmlnLnJlZ2lvbnMgPSByZWdpb25zO1xyXG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XHJcblxyXG5cdHJldHVybiByZWdpb25zO1xyXG59XHJcblxyXG5leHRlbmQocmVnaW9ucywge1xyXG5cdC8qKlxyXG5cdCAqIEFkZCBuZXcgcmVnaW9uLjxicj48YnI+XHJcblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgcmVnaW9uIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgcmVnaW9ucy5cclxuXHQgKiBAZnVuY3Rpb24gcmVnaW9uc+KApGFkZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl8b2JqZWN0fSByZWdpb25zIE5ldyByZWdpb24gd2lsbCBiZSBhZGRlZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIHJlZ2lvbnMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgcmVnaW9uIHdpbGwgYmUgYWRkZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSByZWdpb25zXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBBZGQgYSBuZXcgcmVnaW9uXHJcblx0ICogY2hhcnQucmVnaW9ucy5hZGQoXHJcblx0ICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifVxyXG5cdCAqICk7XHJcblx0ICpcclxuXHQgKiAvLyBBZGQgbmV3IHJlZ2lvbnNcclxuXHQgKiBjaGFydC5yZWdpb25zLmFkZChbXHJcblx0ICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifSxcclxuXHQgKiAgICB7YXhpczogXCJ5XCIsIGVuZDogNTAsIGNsYXNzOiBcInJlZ2lvbllcIn1cclxuXHQgKl0pO1xyXG5cdCAqL1xyXG5cdGFkZDogZnVuY3Rpb24ocmVnaW9uczogcmVnaW9uc1BhcmFtKTogcmVnaW9uc1BhcmFtIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFyZWdpb25zKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcucmVnaW9ucztcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcucmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zLmNvbmNhdChyZWdpb25zKTtcclxuXHRcdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSByZWdpb25zLjxicj48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyByZWdpb25zLlxyXG5cdCAqIEBmdW5jdGlvbiByZWdpb25z4oCkcmVtb3ZlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNWYWx1ZSBUaGlzIGFyZ3VtZW50IHNob3VsZCBpbmNsdWRlIGNsYXNzZXMuIElmIGNsYXNzZXMgaXMgZ2l2ZW4sIHRoZSByZWdpb25zIHRoYXQgaGF2ZSBvbmUgb2YgdGhlIHNwZWNpZmllZCBjbGFzc2VzIHdpbGwgYmUgcmVtb3ZlZC4gSWYgYXJncyBpcyBub3QgZ2l2ZW4sIGFsbCBvZiByZWdpb25zIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHJlZ2lvbnMgUmVtb3ZlZCByZWdpb25zXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyByZWdpb25zIHRoYXQgaGF2ZSAncmVnaW9uLUEnIG9yICdyZWdpb24tQicgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqIGNoYXJ0LnJlZ2lvbnMucmVtb3ZlKHtcclxuXHQgKiAgIGNsYXNzZXM6IFtcclxuXHQgKiAgICAgXCJyZWdpb24tQVwiLCBcInJlZ2lvbi1CXCJcclxuXHQgKiAgIF1cclxuXHQgKiB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCBvZiByZWdpb25zIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSgpO1xyXG5cdCAqL1xyXG5cdHJlbW92ZTogZnVuY3Rpb24ob3B0aW9uc1ZhbHVlOiByZWdpb25zUGFyYW0pOiByZWdpb25zUGFyYW0ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjb25zdCBvcHRpb25zID0gb3B0aW9uc1ZhbHVlIHx8IHt9O1xyXG5cdFx0Y29uc3QgZHVyYXRpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJkdXJhdGlvblwiLCBjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbik7XHJcblx0XHRjb25zdCBjbGFzc2VzID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiY2xhc3Nlc1wiLCBbQ0xBU1MucmVnaW9uXSk7XHJcblx0XHRsZXQgcmVnaW9ucyA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MucmVnaW9uc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGNsYXNzZXMubWFwKGMgPT4gYC4ke2N9YCkpO1xyXG5cclxuXHRcdChkdXJhdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IHJlZ2lvbnMpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRyZWdpb25zID0gY29uZmlnLnJlZ2lvbnM7XHJcblxyXG5cdFx0aWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCkge1xyXG5cdFx0XHRyZWdpb25zID0gcmVnaW9ucy5maWx0ZXIocmVnaW9uID0+IHtcclxuXHRcdFx0XHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKCFyZWdpb24uY2xhc3MpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmVnaW9uLmNsYXNzLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGMgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGNsYXNzZXMuaW5kZXhPZihjKSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuICFmb3VuZDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25maWcucmVnaW9ucyA9IHJlZ2lvbnM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25maWcucmVnaW9ucyA9IFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWdpb25zO1xyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7cmVnaW9uc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7RGF0YUl0ZW19IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBzZWxlY3RlZCBkYXRhIHBvaW50cy48YnI+PGJyPlxyXG5cdCAqIEJ5IHRoaXMgQVBJLCB5b3UgY2FuIGdldCBzZWxlY3RlZCBkYXRhIHBvaW50cyBpbmZvcm1hdGlvbi4gVG8gdXNlIHRoaXMgQVBJLCBkYXRhLnNlbGVjdGlvbi5lbmFibGVkIG5lZWRzIHRvIGJlIHNldCB0cnVlLlxyXG5cdCAqIEBmdW5jdGlvbiBzZWxlY3RlZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0SWRdIFlvdSBjYW4gZmlsdGVyIHRoZSByZXN1bHQgYnkgZ2l2aW5nIHRhcmdldCBpZCB0aGF0IHlvdSB3YW50IHRvIGdldC4gSWYgbm90IGdpdmVuLCBhbGwgb2YgZGF0YSBwb2ludHMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IGRhdGFQb2ludCBBcnJheSBvZiB0aGUgZGF0YSBwb2ludHMuPGJyPmV4LikgYFt7eDogMSwgdmFsdWU6IDIwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDEsIG5hbWU6IFwiZGF0YTFcIn0sIC4uLl1gXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gYWxsIHNlbGVjdGVkIGRhdGEgcG9pbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogIGNoYXJ0LnNlbGVjdGVkKCk7XHJcblx0ICogIC8vIC0tPiBleC4pIFt7eDogMSwgdmFsdWU6IDIwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDEsIG5hbWU6IFwiZGF0YTFcIn0sIC4uLiBdXHJcblx0ICpcclxuXHQgKiAgLy8gYWxsIHNlbGVjdGVkIGRhdGEgcG9pbnRzIG9mIGRhdGExIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogIGNoYXJ0LnNlbGVjdGVkKFwiZGF0YTFcIik7XHJcblx0ICovXHJcblx0c2VsZWN0ZWQodGFyZ2V0SWQ/OiBzdHJpbmcpOiBEYXRhSXRlbVtdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IGRhdGFQb2ludDogRGF0YUl0ZW1bXSA9IFtdO1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuZWFjaChkID0+IGRhdGFQb2ludC5wdXNoKGQpKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YVBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBkYXRhIHBvaW50cyB0byBiZSBzZWxlY3RlZC4gKGBbZGF0YS5zZWxlY3Rpb24uZW5hYmxlZF0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0c2VsZWN0aW9uJTI1RTIlMjU4MCUyNUE0ZW5hYmxlZCkgb3B0aW9uIHNob3VsZCBiZSBzZXQgdHJ1ZSB0byB1c2UgdGhpcyBtZXRob2QpYFxyXG5cdCAqIEBmdW5jdGlvbiBzZWxlY3RcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gZ2V0IHNlbGVjdGVkLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtpbmRpY2VzXSBUaGUgaW5kZXggYXJyYXkgb2YgZGF0YSBwb2ludHMuIElmIGZhbHN5IHZhbHVlIGdpdmVuLCB3aWxsIHNlbGVjdCBhbGwgZGF0YSBwb2ludHMuXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBbcmVzZXRPdGhlcl0gVW5zZWxlY3QgYWxyZWFkeSBzZWxlY3RlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzXHJcblx0ICogIGNoYXJ0LnNlbGVjdCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIHNlbGVjdCBhbGwgZnJvbSAnZGF0YTInXHJcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGEyXCIpO1xyXG5cdCAqXHJcblx0ICogIC8vIHNlbGVjdCBhbGwgZnJvbSAnZGF0YTEnIGFuZCAnZGF0YTInXHJcblx0ICogIGNoYXJ0LnNlbGVjdChbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDIgYW5kIHVuc2VsZWN0IG90aGVycyBzZWxlY3RlZFxyXG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMVwiLCBbMl0sIHRydWUpO1xyXG5cdCAqXHJcblx0ICogIC8vIHNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMCwgMyBhbmQgNVxyXG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMVwiLCBbMCwgMywgNV0pO1xyXG5cdCAqL1xyXG5cdHNlbGVjdChpZHM/OiBzdHJpbmdbXSB8IHN0cmluZywgaW5kaWNlcz86IG51bWJlcltdLCByZXNldE90aGVyPzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZDtcclxuXHRcdFx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCk7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHJcblx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmIGlzVGFyZ2V0SW5kZXgpIHtcclxuXHRcdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSAmJiAhaXNTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0XHR0b2dnbGUodHJ1ZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgdHJ1ZSksIGQsIGkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKHJlc2V0T3RoZXIpICYmIHJlc2V0T3RoZXIgJiYgaXNTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRhdGEgcG9pbnRzIHRvIGJlIHVuLXNlbGVjdGVkLlxyXG5cdCAqIEBmdW5jdGlvbiB1bnNlbGVjdFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBbaWRzXSBpZCB2YWx1ZSB0byBiZSB1bnNlbGVjdGVkLlxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtpbmRpY2VzXSBUaGUgaW5kZXggYXJyYXkgb2YgZGF0YSBwb2ludHMuIElmIGZhbHN5IHZhbHVlIGdpdmVuLCB3aWxsIHNlbGVjdCBhbGwgZGF0YSBwb2ludHMuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gdW5zZWxlY3QgYWxsIGRhdGEgcG9pbnRzXHJcblx0ICogIGNoYXJ0LnVuc2VsZWN0KCk7XHJcblx0ICpcclxuXHQgKiAgLy8gdW5zZWxlY3QgYWxsIGZyb20gJ2RhdGExJ1xyXG5cdCAqICBjaGFydC51bnNlbGVjdChcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogIC8vIHVuc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyXHJcblx0ICogIGNoYXJ0LnVuc2VsZWN0KFwiZGF0YTFcIiwgWzJdKTtcclxuXHQgKi9cclxuXHR1bnNlbGVjdChpZHM/OiBzdHJpbmcgfCBzdHJpbmdbXSwgaW5kaWNlcz86IG51bWJlcltdKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSBkLmRhdGEgPyBkLmRhdGEuaWQgOiBkLmlkO1xyXG5cdFx0XHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGlzLCBkKS5iaW5kKCQkKTtcclxuXHRcdFx0XHRjb25zdCBpc1RhcmdldElkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgIWlkcyB8fCBpZHMuaW5kZXhPZihpZCkgPj0gMDtcclxuXHRcdFx0XHRjb25zdCBpc1RhcmdldEluZGV4ID0gIWluZGljZXMgfHwgaW5kaWNlcy5pbmRleE9mKGkpID49IDA7XHJcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xyXG5cclxuXHRcdFx0XHQvLyBsaW5lL2FyZWEgc2VsZWN0aW9uIG5vdCBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MubGluZSkgfHwgc2hhcGUuY2xhc3NlZChDTEFTUy5hcmVhKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGlzVGFyZ2V0SWQgJiZcclxuXHRcdFx0XHRcdGlzVGFyZ2V0SW5kZXggJiZcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpICYmXHJcblx0XHRcdFx0XHRpc1NlbGVjdGVkXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHR0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgeCB2YWx1ZXMgZm9yIHRoZSBjaGFydC5cclxuXHQgKiBAZnVuY3Rpb24geFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHggSWYgeCBpcyBnaXZlbiwgeCB2YWx1ZXMgb2YgZXZlcnkgdGFyZ2V0IHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGN1cnJlbnQgeCB2YWx1ZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIHRhcmdldCBpZHMuXHJcblx0ICogQHJldHVybnMge29iamVjdH0geHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBHZXQgY3VycmVudCB4IHZhbHVlc1xyXG5cdCAqICBjaGFydC54KCk7XHJcblx0ICpcclxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xyXG5cdCAqICBjaGFydC54KFsxMDAsIDIwMCwgMzAwLCA0MDAsIC4uLl0pO1xyXG5cdCAqL1xyXG5cdHgoeD86IG51bWJlcltdKTogeyBba2V5OiBzdHJpbmddIDogbnVtYmVyW10gfSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7YXhpcywgZGF0YX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSBheGlzLmlzQ3VzdG9tWCgpICYmIGF4aXMuaXNDYXRlZ29yaXplZCgpO1xyXG5cclxuXHRcdGlmIChpc0FycmF5KHgpKSB7XHJcblx0XHRcdGlmIChpc0NhdGVnb3JpemVkKSB7XHJcblx0XHRcdFx0dGhpcy5jYXRlZ29yaWVzKHgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldFgoZGF0YS50YXJnZXRzLCB4KTtcclxuXHJcblx0XHRcdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWVcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc0NhdGVnb3JpemVkID8gdGhpcy5jYXRlZ29yaWVzKCkgOiBkYXRhLnhzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IHggdmFsdWVzIGZvciB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIHhzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0geHMgSWYgeHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyB4IHZhbHVlcyB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBjdXJyZW50IHggdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSB0YXJnZXQgaWRzLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHhzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gR2V0IGN1cnJlbnQgeCB2YWx1ZXNcclxuXHQgKiAgY2hhcnQueHMoKTtcclxuXHQgKlxyXG5cdCAqICAvLyBVcGRhdGUgeCB2YWx1ZXMgZm9yIGFsbCB0YXJnZXRzXHJcblx0ICogIGNoYXJ0LnhzKHtcclxuXHQgKiAgICBkYXRhMTogWzEwLCAyMCwgMzAsIDQwLCAuLi5dLFxyXG5cdCAqICAgIGRhdGEyOiBbMTAwLCAyMDAsIDMwMCwgNDAwLCAuLi5dXHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdHhzKHhzPzogeyBba2V5OiBzdHJpbmddIDogbnVtYmVyW10gfSk6IHsgW2tleTogc3RyaW5nXSA6IG51bWJlcltdIH0ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdGlmIChpc09iamVjdCh4cykpIHtcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0WHMoJCQuZGF0YS50YXJnZXRzLCB4cyk7XHJcblxyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAkJC5kYXRhLnhzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3pvb21JZGVudGl0eSBhcyBkM1pvb21JZGVudGl0eSwgem9vbVRyYW5zZm9ybSBhcyBkM1pvb21UcmFuc2Zvcm19IGZyb20gXCJkMy16b29tXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGV4dGVuZCwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1N0cmluZywgcGFyc2VEYXRlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZG9tYWluIGlzIHdpdGhpbiB6b29tIHJhbmdlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRvbWFpbiBkb21haW4gdmFsdWVcclxuICogQHBhcmFtIHtBcnJheX0gcmFuZ2Ugem9vbSByYW5nZSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhpblJhbmdlKGRvbWFpbjogbnVtYmVyW10sIHJhbmdlOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IFttaW4sIG1heF0gPSByYW5nZTtcclxuXHJcblx0cmV0dXJuIGRvbWFpbi5ldmVyeSgodiwgaSkgPT4gKFxyXG5cdFx0aSA9PT0gMCA/ICh2ID49IG1pbikgOiAodiA8PSBtYXgpXHJcblx0KSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBab29tIGJ5IGdpdmluZyB4IGRvbWFpbi5cclxuICogLSAqKk5PVEU6KipcclxuICogIC0gRm9yIGB3aGVlbGAgdHlwZSB6b29tLCB0aGUgbWluaW11bSB6b29tIHJhbmdlIHdpbGwgYmUgc2V0IGFzIHRoZSBnaXZlbiBkb21haW4uIFRvIGdldCB0aGUgaW5pdGlhbCBzdGF0ZSwgWy51bnpvb20oKV0oI3Vuem9vbSkgc2hvdWxkIGJlIGNhbGxlZC5cclxuICogIC0gVG8gYmUgdXNlZCBbem9vbS5lbmFibGVkXShPcHRpb25zLmh0bWwjLnpvb20pIG9wdGlvbiBzaG91bGQgYmUgc2V0IGFzIGB0cnV0aHlgLlxyXG4gKiBAZnVuY3Rpb24gem9vbVxyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRvbWFpblZhbHVlIElmIGRvbWFpbiBpcyBnaXZlbiwgdGhlIGNoYXJ0IHdpbGwgYmUgem9vbWVkIHRvIHRoZSBnaXZlbiBkb21haW4uIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gZG9tYWluIHZhbHVlIGluIGFycmF5XHJcbiAqIEBleGFtcGxlXHJcbiAqICAvLyBab29tIHRvIHNwZWNpZmllZCBkb21haW5cclxuICogIGNoYXJ0Lnpvb20oWzEwLCAyMF0pO1xyXG4gKlxyXG4gKiAgLy8gR2V0IHRoZSBjdXJyZW50IHpvb21lZCBkb21haW5cclxuICogIGNoYXJ0Lnpvb20oKTtcclxuICovXHJcbmNvbnN0IHpvb20gPSBmdW5jdGlvbihkb21haW5WYWx1ZT86IG51bWJlcltdKTogbnVtYmVyW10ge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRsZXQgZG9tYWluID0gZG9tYWluVmFsdWU7XHJcblx0bGV0IHJlc3VsdERvbWFpbjtcclxuXHJcblx0aWYgKGNvbmZpZy56b29tX2VuYWJsZWQgJiYgZG9tYWluICYmIHdpdGhpblJhbmdlKGRvbWFpbiwgJCQuZ2V0Wm9vbURvbWFpbigpKSkge1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuYXhpcy5pc1RpbWVTZXJpZXMoKTtcclxuXHJcblx0XHRpZiAoaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0ZG9tYWluID0gZG9tYWluLm1hcCh4ID0+IGZuKHgpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcclxuXHRcdFx0Y29uc3QgeFNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cclxuXHRcdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBbeFNjYWxlKGRvbWFpblswXSksIHhTY2FsZShkb21haW5bMV0pXSk7XHJcblx0XHRcdHJlc3VsdERvbWFpbiA9IGRvbWFpbjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKGRvbWFpbik7XHJcblx0XHRcdHNjYWxlLnpvb20gPSBzY2FsZS54O1xyXG5cdFx0XHQkJC5heGlzLnguc2NhbGUoc2NhbGUuem9vbSk7XHJcblxyXG5cdFx0XHRyZXN1bHREb21haW4gPSBzY2FsZS56b29tLm9yZ0RvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHR3aXRoWTogY29uZmlnLnpvb21fcmVzY2FsZSxcclxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdCQkLnNldFpvb21SZXNldEJ1dHRvbigpO1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbSwgJCQuYXBpLCByZXN1bHREb21haW4pO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXN1bHREb21haW4gPSBzY2FsZS56b29tID9cclxuXHRcdFx0c2NhbGUuem9vbS5kb21haW4oKSA6IHNjYWxlLngub3JnRG9tYWluKCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzdWx0RG9tYWluO1xyXG59O1xyXG5cclxuZXh0ZW5kKHpvb20sIHtcclxuXHQvKipcclxuXHQgKiBFbmFibGUgYW5kIGRpc2FibGUgem9vbWluZy5cclxuXHQgKiBAZnVuY3Rpb24gem9vbeKApGVuYWJsZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfGJvb2xlYW59IGVuYWJsZWQgUG9zc2libGUgc3RyaW5nIHZhbHVlcyBhcmUgXCJ3aGVlbFwiIG9yIFwiZHJhZ1wiLiBJZiBlbmFibGVkIGlzIHRydWUsIFwid2hlZWxcIiB3aWxsIGJlIHVzZWQuIElmIGZhbHNlIGlzIGdpdmVuLCB6b29taW5nIHdpbGwgYmUgZGlzYWJsZWQuPGJyPldoZW4gc2V0IHRvIGZhbHNlLCB0aGUgY3VycmVudCB6b29taW5nIHN0YXR1cyB3aWxsIGJlIHJlc2V0LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEVuYWJsZSB6b29taW5nIHVzaW5nIHRoZSBtb3VzZSB3aGVlbFxyXG5cdCAqICBjaGFydC56b29tLmVuYWJsZSh0cnVlKTtcclxuXHQgKiAgLy8gT3JcclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoXCJ3aGVlbFwiKTtcclxuXHQgKlxyXG5cdCAqICAvLyBFbmFibGUgem9vbWluZyBieSBkcmFnZ2luZ1xyXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShcImRyYWdcIik7XHJcblx0ICpcclxuXHQgKiAgLy8gRGlzYWJsZSB6b29taW5nXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKGZhbHNlKTtcclxuXHQgKi9cclxuXHRlbmFibGU6IGZ1bmN0aW9uKGVuYWJsZWQ6IGJvb2xlYW4gfCBcIndoZWVsXCIgfCBcImRyYWdcIiB8IGFueSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCBlbmFibGVUeXBlOiBhbnkgPSBlbmFibGVkO1xyXG5cclxuXHRcdGlmIChlbmFibGVkKSB7XHJcblx0XHRcdGVuYWJsZVR5cGUgPSBpc1N0cmluZyhlbmFibGVkKSAmJiAvXihkcmFnfHdoZWVsKSQvLnRlc3QoZW5hYmxlZCkgP1xyXG5cdFx0XHRcdHt0eXBlOiBlbmFibGVkfSA6IGVuYWJsZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnpvb21fZW5hYmxlZCA9IGVuYWJsZVR5cGU7XHJcblxyXG5cdFx0aWYgKCEkJC56b29tKSB7XHJcblx0XHRcdCQkLmluaXRab29tKCk7XHJcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoKTtcclxuXHRcdH0gZWxzZSBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0JCQuYmluZFpvb21FdmVudChmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG9yIGdldCB4IEF4aXMgbWF4aW11bSB6b29tIHJhbmdlIHZhbHVlXHJcblx0ICogQGZ1bmN0aW9uIHpvb23igKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gW21heF0gbWF4aW11bSB2YWx1ZSB0byBzZXQgZm9yIHpvb21cclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB6b29tIG1heCB2YWx1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFNldCBtYXhpbXVtIHJhbmdlIHZhbHVlXHJcblx0ICogIGNoYXJ0Lnpvb20ubWF4KDIwKTtcclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKG1heD86IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBvcmc6IHt4RG9tYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAobWF4ID09PSAwIHx8IG1heCkge1xyXG5cdFx0XHRjb25maWcuem9vbV94X21heCA9IGdldE1pbk1heChcIm1heFwiLCBbeERvbWFpblsxXSwgbWF4XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy56b29tX3hfbWF4O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBvciBnZXQgeCBBeGlzIG1pbmltdW0gem9vbSByYW5nZSB2YWx1ZVxyXG5cdCAqIEBmdW5jdGlvbiB6b29t4oCkbWluXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IFttaW5dIG1pbmltdW0gdmFsdWUgdG8gc2V0IGZvciB6b29tXHJcblx0ICogQHJldHVybnMge251bWJlcn0gem9vbSBtaW4gdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBTZXQgbWluaW11bSByYW5nZSB2YWx1ZVxyXG5cdCAqICBjaGFydC56b29tLm1pbigtMSk7XHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbihtaW4/OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnOiB7eERvbWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG1pbiA9PT0gMCB8fCBtaW4pIHtcclxuXHRcdFx0Y29uZmlnLnpvb21feF9taW4gPSBnZXRNaW5NYXgoXCJtaW5cIiwgW3hEb21haW5bMF0sIG1pbl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWcuem9vbV94X21pbjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgem9vbSByYW5nZVxyXG5cdCAqIEBmdW5jdGlvbiB6b29t4oCkcmFuZ2VcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3JhbmdlXSB6b29tIHJhbmdlXHJcblx0ICogQHJldHVybnMge29iamVjdH0gem9vbSByYW5nZSB2YWx1ZVxyXG5cdCAqIHtcclxuXHQgKiAgIG1pbjogMCxcclxuXHQgKiAgIG1heDogMTAwXHJcblx0ICogfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGNoYXJ0Lnpvb20ucmFuZ2Uoe1xyXG5cdCAqICAgICAgbWluOiAxMCxcclxuXHQgKiAgICAgIG1heDogMTAwXHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdHJhbmdlOiBmdW5jdGlvbihyYW5nZSk6IHttaW46IChudW1iZXJ8dW5kZWZpbmVkKVtdLCBtYXg6IChudW1iZXJ8dW5kZWZpbmVkKVtdfSB7XHJcblx0XHRjb25zdCB6b29tID0gdGhpcy56b29tO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChyYW5nZSkpIHtcclxuXHRcdFx0Y29uc3Qge21pbiwgbWF4fSA9IHJhbmdlO1xyXG5cclxuXHRcdFx0aXNEZWZpbmVkKG1pbikgJiYgem9vbS5taW4obWluKTtcclxuXHRcdFx0aXNEZWZpbmVkKG1heCkgJiYgem9vbS5tYXgobWF4KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRtaW46IHpvb20ubWluKCksXHJcblx0XHRcdG1heDogem9vbS5tYXgoKVxyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdHpvb20sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuem9vbSB6b29tZWQgYXJlYVxyXG5cdCAqIEBmdW5jdGlvbiB1bnpvb21cclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC51bnpvb20oKTtcclxuXHQgKi9cclxuXHR1bnpvb20oKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5zY2FsZS56b29tKSB7XHJcblx0XHRcdGNvbmZpZy5zdWJjaGFydF9zaG93ID9cclxuXHRcdFx0XHQkJC5icnVzaC5nZXRTZWxlY3Rpb24oKS5jYWxsKCQkLmJydXNoLm1vdmUsIG51bGwpIDpcclxuXHRcdFx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKGQzWm9vbUlkZW50aXR5KTtcclxuXHJcblx0XHRcdCQkLnVwZGF0ZVpvb20odHJ1ZSk7XHJcblx0XHRcdCQkLnpvb20ucmVzZXRCdG4gJiYgJCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgdHJhbnNmb3JtXHJcblx0XHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YCk7XHJcblxyXG5cdFx0XHRpZiAoZDNab29tVHJhbnNmb3JtKGV2ZW50UmVjdHMubm9kZSgpKSAhPT0gZDNab29tSWRlbnRpdHkpIHtcclxuXHRcdFx0XHQkJC56b29tLnRyYW5zZm9ybShldmVudFJlY3RzLCBkM1pvb21JZGVudGl0eSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdFx0d2l0aFRyYW5zaXRpb246IHRydWUsXHJcblx0XHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGVcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0UGF0aEJveH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcuXHJcblx0ICogRGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG1vdXNlIE9iamVjdFxyXG5cdCAqL1xyXG5cdGRyYWcobW91c2UpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8XHJcblx0XHRcdCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCB8fCAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXHJcblx0XHRcdChjb25maWcuem9vbV9lbmFibGVkICYmICEkJC56b29tLmFsdERvbWFpbikgfHwgLy8gc2tpcCBpZiB6b29tYWJsZSBiZWNhdXNlIG9mIGNvbmZsaWN0IGRyYWcgYmVoYXZpb3JcclxuXHRcdFx0IWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9tdWx0aXBsZSAvLyBza2lwIHdoZW4gc2luZ2xlIHNlbGVjdGlvbiBiZWNhdXNlIGRyYWcgaXMgdXNlZCBmb3IgbXVsdGlwbGUgc2VsZWN0aW9uXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IFtzeCwgc3ldID0gc3RhdGUuZHJhZ1N0YXJ0O1xyXG5cdFx0Y29uc3QgW214LCBteV0gPSBtb3VzZTtcclxuXHJcblx0XHRjb25zdCBtaW5YID0gTWF0aC5taW4oc3gsIG14KTtcclxuXHRcdGNvbnN0IG1heFggPSBNYXRoLm1heChzeCwgbXgpO1xyXG5cdFx0Y29uc3QgbWluWSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gc3RhdGUubWFyZ2luLnRvcCA6IE1hdGgubWluKHN5LCBteSk7XHJcblx0XHRjb25zdCBtYXhZID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyBzdGF0ZS5oZWlnaHQgOiBNYXRoLm1heChzeSwgbXkpO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5kcmFnYXJlYX1gKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgbWluWClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIG1pblkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbWF4WCAtIG1pblgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIG1heFkgLSBtaW5ZKTtcclxuXHJcblx0XHQvLyBUT0RPOiBiaW5hcnkgc2VhcmNoIHdoZW4gbXVsdGlwbGUgeHNcclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0LmZpbHRlcihkID0+IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGU6IGQzU2VsZWN0aW9uID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xyXG5cdFx0XHRcdGNvbnN0IGlzSW5jbHVkZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLklOQ0xVREVEKTtcclxuXHRcdFx0XHRsZXQgaXNXaXRoaW46IGFueSA9IGZhbHNlO1xyXG5cdFx0XHRcdGxldCB0b2dnbGU7XHJcblxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmNpcmNsZSkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHg6IG51bWJlciA9ICtzaGFwZS5hdHRyKFwiY3hcIikgKiAxO1xyXG5cdFx0XHRcdFx0Y29uc3QgeTogbnVtYmVyID0gK3NoYXBlLmF0dHIoXCJjeVwiKSAqIDE7XHJcblxyXG5cdFx0XHRcdFx0dG9nZ2xlID0gJCQudG9nZ2xlUG9pbnQ7XHJcblx0XHRcdFx0XHRpc1dpdGhpbiA9IG1pblggPCB4ICYmIHggPCBtYXhYICYmIG1pblkgPCB5ICYmIHkgPCBtYXhZO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5iYXIpKSB7XHJcblx0XHRcdFx0XHRjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSBnZXRQYXRoQm94KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRcdHRvZ2dsZSA9ICQkLnRvZ2dsZVBhdGg7XHJcblx0XHRcdFx0XHRpc1dpdGhpbiA9ICEobWF4WCA8IHggfHwgeCArIHdpZHRoIDwgbWluWCkgJiYgIShtYXhZIDwgeSB8fCB5ICsgaGVpZ2h0IDwgbWluWSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRpZiAoaXNXaXRoaW4gXiBpc0luY2x1ZGVkKSB7XHJcblx0XHRcdFx0XHRzaGFwZS5jbGFzc2VkKENMQVNTLklOQ0xVREVELCAhaXNJbmNsdWRlZCk7XHJcblx0XHRcdFx0XHQvLyBUT0RPOiBpbmNsdWRlZC91bmluY2x1ZGVkIGNhbGxiYWNrIGhlcmVcclxuXHRcdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcclxuXHRcdFx0XHRcdHRvZ2dsZS5jYWxsKCQkLCAhaXNTZWxlY3RlZCwgc2hhcGUsIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGRyYWcgc3RhcnRzLlxyXG5cdCAqIEFkZHMgYW5kIFNob3dzIHRoZSBkcmFnIGFyZWEuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gbW91c2UgT2JqZWN0XHJcblx0ICovXHJcblx0ZHJhZ3N0YXJ0KG1vdXNlKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmRyYWdTdGFydCA9IG1vdXNlO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmRyYWdhcmVhKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMC4xXCIpO1xyXG5cclxuXHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGRyYWcgZmluaXNoZXMuXHJcblx0ICogUmVtb3ZlcyB0aGUgZHJhZyBhcmVhLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZHJhZ2VuZCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7IC8vIGRvIG5vdGhpbmcgaWYgbm90IHNlbGVjdGFibGVcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5kcmFnYXJlYX1gKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQsIGZhbHNlKTtcclxuXHJcblx0XHQkJC5zZXREcmFnU3RhdHVzKGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHRzZXREcmFnU3RhdHVzKGlzRHJhZ2dpbmc6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUuZHJhZ2dpbmcgPSBpc0RyYWdnaW5nO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2Vhc2VMaW5lYXIgYXMgZDNFYXNlTGluZWFyfSBmcm9tIFwiZDMtZWFzZVwiO1xyXG5pbXBvcnQge3RyYW5zaXRpb24gYXMgZDNUcmFuc2l0aW9ufSBmcm9tIFwiZDMtdHJhbnNpdGlvblwiO1xyXG5pbXBvcnQge2dlbmVyYXRlV2FpdH0gZnJvbSBcIi4uLy4uL21vZHVsZS9nZW5lcmF0b3JcIjtcclxuaW1wb3J0IHtkaWZmRG9tYWlufSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGZsb3dcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJncyBvcHRpb24gb2JqZWN0XHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVGbG93KGFyZ3MpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7ZGF0YSwgc3RhdGUsICRlbH0gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnN0IGZsb3dMZW5ndGggPSBhcmdzLmZsb3cubGVuZ3RoO1xyXG5cclxuXHRcdFx0Ly8gc2V0IGZsYWdcclxuXHRcdFx0c3RhdGUuZmxvd2luZyA9IHRydWU7XHJcblxyXG5cdFx0XHQvLyByZW1vdmUgaGVhZCBkYXRhIGFmdGVyIHJlbmRlcmVkXHJcblx0XHRcdGRhdGEudGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRcdGQudmFsdWVzLnNwbGljZSgwLCBmbG93TGVuZ3RoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgZWxlbWVudHMgcmVsYXRlZCB0byB4IHNjYWxlXHJcblx0XHRcdGlmICgkJC51cGRhdGVYR3JpZCkge1xyXG5cdFx0XHRcdCQkLnVwZGF0ZVhHcmlkKHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0YXJnZXQgZWxlbWVudHNcclxuXHRcdFx0Y29uc3QgZWxlbWVudHMgPSB7fTtcclxuXHJcblx0XHRcdFtcImF4aXMueFwiLCBcImdyaWQueFwiLCBcImdyaWRMaW5lcy54XCIsIFwicmVnaW9uLmxpc3RcIiwgXCJ0ZXh0XCIsIFwiYmFyXCIsIFwibGluZVwiLCBcImFyZWFcIiwgXCJjaXJjbGVcIl1cclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSB2LnNwbGl0KFwiLlwiKTtcclxuXHRcdFx0XHRcdGxldCBub2RlID0gJGVsW25hbWVbMF1dO1xyXG5cclxuXHRcdFx0XHRcdGlmIChub2RlICYmIG5hbWUubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdFx0XHRub2RlID0gbm9kZVtuYW1lWzFdXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAobm9kZSAmJiBub2RlLnNpemUoKSkge1xyXG5cdFx0XHRcdFx0XHRlbGVtZW50c1t2XSA9IG5vZGU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHRcdCQkLnNldEZsb3dMaXN0KGVsZW1lbnRzLCBhcmdzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGZsb3cgbGlzdFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50cyBUYXJnZXQgZWxlbWVudHNcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJncyBvcHRpb24gb2JqZWN0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRGbG93TGlzdChlbGVtZW50cywgYXJncyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2Zsb3csIHRhcmdldHN9ID0gYXJncztcclxuXHRcdGNvbnN0IHtcclxuXHRcdFx0ZHVyYXRpb24gPSBhcmdzLmR1cmF0aW9uLFxyXG5cdFx0XHRpbmRleDogZmxvd0luZGV4LFxyXG5cdFx0XHRsZW5ndGg6IGZsb3dMZW5ndGgsXHJcblx0XHRcdG9yZ0RhdGFDb3VudCxcclxuXHRcdH0gPSBmbG93O1xyXG5cclxuXHRcdGNvbnN0IHRyYW5zZm9ybSA9ICQkLmdldEZsb3dUcmFuc2Zvcm0odGFyZ2V0cywgb3JnRGF0YUNvdW50LCBmbG93SW5kZXgsIGZsb3dMZW5ndGgpO1xyXG5cdFx0Y29uc3Qgd2FpdCA9IGdlbmVyYXRlV2FpdCgpO1xyXG5cdFx0Y29uc3QgZ3QgPSBkM1RyYW5zaXRpb24oKS5lYXNlKGQzRWFzZUxpbmVhcilcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKTtcclxuXHJcblx0XHR3YWl0LmFkZChPYmplY3Qua2V5cyhlbGVtZW50cykubWFwKHYgPT4ge1xyXG5cdFx0XHRsZXQgbiA9IGVsZW1lbnRzW3ZdO1xyXG5cclxuXHRcdFx0aWYgKHYgPT09IFwiYXhpcy54XCIpIHtcclxuXHRcdFx0XHRuID0gbi50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmNhbGwoZyA9PiAkJC5heGlzLnguc2V0VHJhbnNpdGlvbihndCkuY3JlYXRlKGcpKTtcclxuXHRcdFx0fSBlbHNlIGlmICh2ID09PSBcInJlZ2lvbi5saXN0XCIpIHtcclxuXHRcdFx0XHRuID0gbi5maWx0ZXIoJCQuaXNSZWdpb25PblgpXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0biA9IG4udHJhbnNpdGlvbihndCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbjtcclxuXHRcdH0pKTtcclxuXHJcblx0XHRndC5jYWxsKHdhaXQsICgpID0+IHtcclxuXHRcdFx0JCQuY2xlYW5VcEZsb3coZWxlbWVudHMsIGFyZ3MpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2xlYW4gdXAgZmxvd1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50cyBUYXJnZXQgZWxlbWVudHNcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJncyBvcHRpb24gb2JqZWN0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjbGVhblVwRmxvdyhlbGVtZW50cywgYXJncyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3N2Z319ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbnN0IHtmbG93LCBzaGFwZSwgeHZ9ID0gYXJncztcclxuXHRcdGNvbnN0IHtjeCwgY3ksIHhGb3JUZXh0LCB5Rm9yVGV4dH0gPSBzaGFwZS5wb3M7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGRvbmUgPSAoKSA9PiB7fSxcclxuXHRcdFx0bGVuZ3RoOiBmbG93TGVuZ3RoXHJcblx0XHR9ID0gZmxvdztcclxuXHJcblx0XHQvLyBSZW1vdmUgZmxvd2VkIGVsZW1lbnRzXHJcblx0XHRpZiAoZmxvd0xlbmd0aCkge1xyXG5cdFx0XHRbXCJjaXJjbGVcIiwgXCJ0ZXh0XCIsIFwic2hhcGVcIiwgXCJldmVudFJlY3RcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB0YXJnZXQ6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZmxvd0xlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR0YXJnZXQucHVzaChgLiR7Q0xBU1Nbdl19LSR7aX1gKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTW2Ake3Z9c2BdfWApIC8vIGNpcmNsZXMsIHNoYXBlcywgdGV4dHMsIGV2ZW50UmVjdHNcclxuXHRcdFx0XHRcdC5zZWxlY3RBbGwodGFyZ2V0KVxyXG5cdFx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHN2Zy5zZWxlY3QoYC4ke0NMQVNTLnhncmlkfWApXHJcblx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRyYXcgYWdhaW4gZm9yIHJlbW92aW5nIGZsb3dlZCBlbGVtZW50cyBhbmQgcmV2ZXJ0aW5nIGF0dHJcclxuXHRcdE9iamVjdC5rZXlzKGVsZW1lbnRzKS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRjb25zdCBuID0gZWxlbWVudHNbdl07XHJcblxyXG5cdFx0XHRpZiAodiAhPT0gXCJheGlzLnhcIikge1xyXG5cdFx0XHRcdG4uYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHYgPT09IFwiZ3JpZC54XCIpIHtcclxuXHRcdFx0XHRuLmF0dHIoc3RhdGUueGdyaWRBdHRyKTtcclxuXHRcdFx0fSBlbHNlIGlmICh2ID09PSBcImdyaWRMaW5lcy54XCIpIHtcclxuXHRcdFx0XHRuLmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyAwIDogeHYpXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogeHYpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwiZ3JpZExpbmVzLnhcIikge1xyXG5cdFx0XHRcdG4uc2VsZWN0KFwibGluZVwiKS5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IHh2KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyBzdGF0ZS53aWR0aCA6IHh2KTtcclxuXHJcblx0XHRcdFx0bi5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHh2KTtcclxuXHRcdFx0fSBlbHNlIGlmICgvXihhcmVhfGJhcnxsaW5lKSQvLnRlc3QodikpIHtcclxuXHRcdFx0XHRuLmF0dHIoXCJkXCIsIHNoYXBlLnR5cGVbdl0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwidGV4dFwiKSB7XHJcblx0XHRcdFx0bi5hdHRyKFwieFwiLCB4Rm9yVGV4dClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5Rm9yVGV4dClcclxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCAkJC5vcGFjaXR5Rm9yVGV4dC5iaW5kKCQkKSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdGlmICgkJC5pc0NpcmNsZVBvaW50KCkpIHtcclxuXHRcdFx0XHRcdG4uYXR0cihcImN4XCIsIGN4KS5hdHRyKFwiY3lcIiwgY3kpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zdCB4RnVuYyA9IGQgPT4gY3goZCkgLSBjb25maWcucG9pbnRfcjtcclxuXHRcdFx0XHRcdGNvbnN0IHlGdW5jID0gZCA9PiBjeShkKSAtIGNvbmZpZy5wb2ludF9yO1xyXG5cclxuXHRcdFx0XHRcdG4uYXR0cihcInhcIiwgeEZ1bmMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5RnVuYylcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeFwiLCBjeCkgLy8gd2hlbiBwYXR0ZXJuIGlzIHVzZWQsIGl0IHBvc3NpYmx5IGNvbnRhaW4gJ2NpcmNsZScgYWxzby5cclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjeVwiLCBjeSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwicmVnaW9uLmxpc3RcIikge1xyXG5cdFx0XHRcdG4uc2VsZWN0KFwicmVjdFwiKS5maWx0ZXIoJCQuaXNSZWdpb25PblgpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiAkJC5yZWRyYXdFdmVudFJlY3QoKTtcclxuXHJcblx0XHQvLyBjYWxsYmFjayBmb3IgZW5kIG9mIGZsb3dcclxuXHRcdGRvbmUuY2FsbCgkJC5hcGkpO1xyXG5cclxuXHRcdHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgZmxvdyB0cmFuc2Zvcm0gdmFsdWVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0cyB0YXJnZXRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gb3JnRGF0YUNvdW50IG9yaWdpbmFsIGRhdGEgY291bnRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZmxvd0luZGV4IGZsb3cgaW5kZXhcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZmxvd0xlbmd0aCBmbG93IGxlbmd0aFxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRGbG93VHJhbnNmb3JtKHRhcmdldHMsIG9yZ0RhdGFDb3VudCwgZmxvd0luZGV4LCBmbG93TGVuZ3RoKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtkYXRhLCBzY2FsZToge3h9fSA9ICQkO1xyXG5cdFx0Y29uc3QgZGF0YVZhbHVlcyA9IGRhdGEudGFyZ2V0c1swXS52YWx1ZXM7XHJcblxyXG5cdFx0bGV0IGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleChkYXRhVmFsdWVzLCBmbG93SW5kZXgpO1xyXG5cdFx0bGV0IGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoZGF0YVZhbHVlcywgZmxvd0luZGV4ICsgZmxvd0xlbmd0aCk7XHJcblx0XHRsZXQgdHJhbnNsYXRlWDtcclxuXHJcblx0XHQvLyB1cGRhdGUgeCBkb21haW4gdG8gZ2VuZXJhdGUgYXhpcyBlbGVtZW50cyBmb3IgZmxvd1xyXG5cdFx0Y29uc3Qgb3JnRG9tYWluID0geC5kb21haW4oKTtcclxuXHRcdGNvbnN0IGRvbWFpbiA9ICQkLnVwZGF0ZVhEb21haW4odGFyZ2V0cywgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgdHJhbnNmb3JtIHRvIGZsb3dcclxuXHRcdGlmICghb3JnRGF0YUNvdW50KSB7IC8vIGlmIGVtcHR5XHJcblx0XHRcdGlmIChkYXRhVmFsdWVzLmxlbmd0aCAhPT0gMSkge1xyXG5cdFx0XHRcdHRyYW5zbGF0ZVggPSB4KG9yZ0RvbWFpblswXSkgLSB4KGRvbWFpblswXSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKCQkLmF4aXMuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0XHRcdGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleChkYXRhVmFsdWVzLCAwKTtcclxuXHRcdFx0XHRcdGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoZGF0YVZhbHVlcywgZGF0YVZhbHVlcy5sZW5ndGggLSAxKTtcclxuXHRcdFx0XHRcdHRyYW5zbGF0ZVggPSB4KGZsb3dTdGFydC54KSAtIHgoZmxvd0VuZC54KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9IGRpZmZEb21haW4oZG9tYWluKSAvIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKG9yZ0RhdGFDb3VudCA9PT0gMSB8fCAoZmxvd1N0YXJ0ICYmIGZsb3dTdGFydC54KSA9PT0gKGZsb3dFbmQgJiYgZmxvd0VuZC54KSkge1xyXG5cdFx0XHR0cmFuc2xhdGVYID0geChvcmdEb21haW5bMF0pIC0geChkb21haW5bMF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dHJhbnNsYXRlWCA9ICQkLmF4aXMuaXNUaW1lU2VyaWVzKCkgP1xyXG5cdFx0XHRcdHgob3JnRG9tYWluWzBdKSAtIHgoZG9tYWluWzBdKSA6XHJcblx0XHRcdFx0eChmbG93U3RhcnQueCkgLSB4KGZsb3dFbmQueCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgc2NhbGVYID0gKGRpZmZEb21haW4ob3JnRG9tYWluKSAvIGRpZmZEb21haW4oZG9tYWluKSk7XHJcblxyXG5cdFx0cmV0dXJuIGB0cmFuc2xhdGUoJHt0cmFuc2xhdGVYfSwwKSBzY2FsZSgke3NjYWxlWH0sMSlgO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdG1vdXNlIGFzIGQzTW91c2UsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNib29sZWFufSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBhcmVhIHRoYXQgZGV0ZWN0cyB0aGUgZXZlbnQuXHJcblx0ICogQWRkIGEgY29udGFpbmVyIGZvciB0aGUgem9uZSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdEV2ZW50UmVjdCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZXZlbnRSZWN0cylcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXdzIHRoZSBhcmVhIHRoYXQgZGV0ZWN0cyB0aGUgZXZlbnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdFdmVudFJlY3QoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc011bHRpcGxlWCA9ICQkLmlzTXVsdGlwbGVYKCk7XHJcblx0XHRsZXQgZXZlbnRSZWN0VXBkYXRlO1xyXG5cclxuXHRcdGNvbnN0IHpvb21FbmFibGVkID0gY29uZmlnLnpvb21fZW5hYmxlZDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YClcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIHpvb21FbmFibGVkICYmIHpvb21FbmFibGVkLnR5cGUgIT09IFwiZHJhZ1wiID8gKFxyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIm5zLXJlc2l6ZVwiIDogXCJldy1yZXNpemVcIlxyXG5cdFx0XHQpIDogbnVsbClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0c011bHRpcGxlLCBpc011bHRpcGxlWClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0c1NpbmdsZSwgIWlzTXVsdGlwbGVYKTtcclxuXHJcblx0XHQvLyBjbGVhciBvbGQgcmVjdHNcclxuXHRcdGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Ly8gb3BlbiBhcyBwdWJsaWMgY29uc3RpYWJsZVxyXG5cdFx0JGVsLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XHJcblxyXG5cdFx0aWYgKGlzTXVsdGlwbGVYKSB7XHJcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICRlbC5ldmVudFJlY3QuZGF0YShbMF0pO1xyXG5cdFx0XHQvLyB1cGRhdGVcclxuXHRcdFx0Ly8gZW50ZXI6IG9ubHkgb25lIHJlY3Qgd2lsbCBiZSBhZGRlZFxyXG5cdFx0XHQvLyBleGl0OiBub3QgbmVlZGVkIGJlY2F1c2UgYWx3YXlzIG9ubHkgb25lIHJlY3QgZXhpc3RzXHJcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXHJcblx0XHRcdFx0Lm1lcmdlKGV2ZW50UmVjdFVwZGF0ZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyBTZXQgZGF0YSBhbmQgdXBkYXRlICRlbC5ldmVudFJlY3RcclxuXHRcdFx0Y29uc3QgeEF4aXNUaWNrVmFsdWVzID0gJCQuZ2V0TWF4RGF0YUNvdW50VGFyZ2V0KCk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgZGF0YSdzIGluZGV4IHZhbHVlIHRvIGJlIGFsaW5nZWQgd2l0aCB0aGUgeCBBeGlzXHJcblx0XHRcdCQkLnVwZGF0ZURhdGFJbmRleEJ5WCh4QXhpc1RpY2tWYWx1ZXMpO1xyXG5cdFx0XHQkJC51cGRhdGVYcyh4QXhpc1RpY2tWYWx1ZXMpO1xyXG5cdFx0XHQkJC51cGRhdGVQb2ludENsYXNzKHRydWUpO1xyXG5cclxuXHRcdFx0ZXZlbnRSZWN0cy5kYXR1bSh4QXhpc1RpY2tWYWx1ZXMpO1xyXG5cclxuXHRcdFx0JGVsLmV2ZW50UmVjdCA9IGV2ZW50UmVjdHMuc2VsZWN0QWxsKGAuJHtDTEFTUy5ldmVudFJlY3R9YCk7XHJcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICRlbC5ldmVudFJlY3QuZGF0YShkID0+IGQpO1xyXG5cclxuXHRcdFx0Ly8gZXhpdFxyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlXHJcblx0XHRcdGV2ZW50UmVjdFVwZGF0ZSA9ICQkLmdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0VXBkYXRlLmVudGVyKCkpXHJcblx0XHRcdFx0Lm1lcmdlKGV2ZW50UmVjdFVwZGF0ZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JGVsLmV2ZW50UmVjdCA9IGV2ZW50UmVjdFVwZGF0ZTtcclxuXHRcdCQkLnVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpO1xyXG5cclxuXHRcdGlmICgkJC5zdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIiAmJiAhJGVsLnN2Zy5vbihcInRvdWNoc3RhcnQuZXZlbnRSZWN0XCIpICYmICEkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0JCQuYmluZFRvdWNoT25FdmVudFJlY3QoaXNNdWx0aXBsZVgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYOiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCBnZXRFdmVudFJlY3QgPSAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IHRvdWNoID0gZDNFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuXHJcblx0XHRcdHJldHVybiBkM1NlbGVjdChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgZ2V0SW5kZXggPSBldmVudFJlY3QgPT4ge1xyXG5cdFx0XHRsZXQgaW5kZXggPSBldmVudFJlY3QgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKSAmJiBldmVudFJlY3QuYXR0cihcImNsYXNzXCIpXHJcblx0XHRcdFx0LnJlcGxhY2UobmV3IFJlZ0V4cChgKCR7Q0xBU1MuZXZlbnRSZWN0fS0/fHMpYCwgXCJnXCIpLCBcIlwiKSAqIDE7XHJcblxyXG5cdFx0XHRpZiAoaXNOYU4oaW5kZXgpIHx8IGluZGV4ID09PSBudWxsKSB7XHJcblx0XHRcdFx0aW5kZXggPSAtMTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGluZGV4O1xyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBzZWxlY3RSZWN0ID0gY29udGV4dCA9PiB7XHJcblx0XHRcdGlmIChpc011bHRpcGxlWCkge1xyXG5cdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKGNvbnRleHQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpO1xyXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoZXZlbnRSZWN0KTtcclxuXHJcblx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaChpbmRleCk7XHJcblxyXG5cdFx0XHRcdGluZGV4ID09PSAtMSA/XHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKSA6XHJcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKGNvbnRleHQsIGV2ZW50UmVjdCwgaW5kZXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGNhbGwgZXZlbnQucHJldmVudERlZmF1bHQoKVxyXG5cdFx0Ly8gYWNjb3JkaW5nICdpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2gucHJldmVudERlZmF1bHQnIG9wdGlvblxyXG5cdFx0Y29uc3QgcHJldmVudERlZmF1bHQgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoLnByZXZlbnREZWZhdWx0O1xyXG5cdFx0Y29uc3QgaXNQcmV2ZW50ZWQgPSAoaXNib29sZWFuKHByZXZlbnREZWZhdWx0KSAmJiBwcmV2ZW50RGVmYXVsdCkgfHwgZmFsc2U7XHJcblx0XHRjb25zdCBwcmV2ZW50VGhyZXNob2xkID0gKCFpc05hTihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IG51bGw7XHJcblx0XHRsZXQgc3RhcnRQeDtcclxuXHJcblx0XHRjb25zdCBwcmV2ZW50RXZlbnQgPSBldmVudCA9PiB7XHJcblx0XHRcdGNvbnN0IGV2ZW50VHlwZSA9IGV2ZW50LnR5cGU7XHJcblx0XHRcdGNvbnN0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblx0XHRcdGNvbnN0IGN1cnJlbnRYWSA9IHRvdWNoW2BjbGllbnQke2NvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIllcIiA6IFwiWFwifWBdO1xyXG5cclxuXHRcdFx0Ly8gcHJldmVudCBkb2N1bWVudCBzY3JvbGxpbmdcclxuXHRcdFx0aWYgKGV2ZW50VHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpIHtcclxuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQpIHtcclxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChwcmV2ZW50VGhyZXNob2xkICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRzdGFydFB4ID0gY3VycmVudFhZO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChldmVudFR5cGUgPT09IFwidG91Y2htb3ZlXCIpIHtcclxuXHRcdFx0XHRpZiAoaXNQcmV2ZW50ZWQgfHwgc3RhcnRQeCA9PT0gdHJ1ZSB8fCAoXHJcblx0XHRcdFx0XHRwcmV2ZW50VGhyZXNob2xkICE9PSBudWxsICYmIE1hdGguYWJzKHN0YXJ0UHggLSBjdXJyZW50WFkpID49IHByZXZlbnRUaHJlc2hvbGRcclxuXHRcdFx0XHQpKSB7XHJcblx0XHRcdFx0XHQvLyBvbmNlIHByZXZlbnRlZCwga2VlcCBwcmV2ZW50ZWQgZHVyaW5nIHdob2xlICd0b3VjaG1vdmUnIGNvbnRleHRcclxuXHRcdFx0XHRcdHN0YXJ0UHggPSB0cnVlO1xyXG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gYmluZCB0b3VjaCBldmVudHNcclxuXHRcdHN2Z1xyXG5cdFx0XHQub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdCB0b3VjaG1vdmUuZXZlbnRSZWN0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpO1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudDtcclxuXHJcblx0XHRcdFx0aWYgKCFldmVudFJlY3QuZW1wdHkoKSAmJiBldmVudFJlY3QuY2xhc3NlZChDTEFTUy5ldmVudFJlY3QpKSB7XHJcblx0XHRcdFx0XHQvLyBpZiB0b3VjaCBwb2ludHMgYXJlID4gMSwgbWVhbnMgZG9pbmcgem9vbWluZyBpbnRlcmFjdGlvbi4gSW4gdGhpcyBjYXNlIGRvIG5vdCBleGVjdXRlIHRvb2x0aXAgY29kZXMuXHJcblx0XHRcdFx0XHRpZiAoc3RhdGUuZHJhZ2dpbmcgfHwgc3RhdGUuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkgfHwgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRwcmV2ZW50RXZlbnQoZXZlbnQpO1xyXG5cdFx0XHRcdFx0c2VsZWN0UmVjdCh0aGlzKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0cnVlKVxyXG5cdFx0XHQub24oXCJ0b3VjaGVuZC5ldmVudFJlY3RcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9IGdldEV2ZW50UmVjdCgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdCkpIHtcclxuXHRcdFx0XHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgISQkLnRvZ2dsZVNoYXBlIHx8IHN0YXRlLmNhbmNlbENsaWNrKSB7XHJcblx0XHRcdFx0XHRcdHN0YXRlLmNhbmNlbENsaWNrICYmIChzdGF0ZS5jYW5jZWxDbGljayA9IGZhbHNlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZXMgdGhlIGxvY2F0aW9uIGFuZCBzaXplIG9mIHRoZSBldmVudFJlY3QuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UmVjdFVwZGF0ZSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRXZlbnRSZWN0KGV2ZW50UmVjdFVwZGF0ZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGUsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgeFNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cdFx0Y29uc3QgZXZlbnRSZWN0RGF0YSA9IGV2ZW50UmVjdFVwZGF0ZSB8fCAkJC4kZWwuZXZlbnRSZWN0LmRhdGEoKTsgLy8gc2V0IHVwZGF0ZSBzZWxlY3Rpb24gaWYgbnVsbFxyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCB4O1xyXG5cdFx0bGV0IHk7XHJcblx0XHRsZXQgdztcclxuXHRcdGxldCBoO1xyXG5cclxuXHRcdGlmICgkJC5pc011bHRpcGxlWCgpKSB7XHJcblx0XHRcdC8vIFRPRE86IHJvdGF0ZWQgbm90IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0eCA9IDA7XHJcblx0XHRcdHkgPSAwO1xyXG5cdFx0XHR3ID0gc3RhdGUud2lkdGg7XHJcblx0XHRcdGggPSBzdGF0ZS5oZWlnaHQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgcmVjdFc7XHJcblx0XHRcdGxldCByZWN0WDtcclxuXHJcblx0XHRcdGlmICgkJC5heGlzLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRcdHJlY3RXID0gJCQuZ2V0RXZlbnRSZWN0V2lkdGgoKTtcclxuXHRcdFx0XHRyZWN0WCA9IGQgPT4geFNjYWxlKGQueCkgLSAocmVjdFcgLyAyKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBnZXRQcmV2TmV4dFggPSBkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZC5pbmRleDtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XHRwcmV2OiAkJC5nZXRQcmV2WChpbmRleCksXHJcblx0XHRcdFx0XHRcdG5leHQ6ICQkLmdldE5leHRYKGluZGV4KVxyXG5cdFx0XHRcdFx0fTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRyZWN0VyA9IGQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IGdldFByZXZOZXh0WChkKTtcclxuXHJcblx0XHRcdFx0XHQvLyBpZiB0aGVyZSB0aGlzIGlzIGEgc2luZ2xlIGRhdGEgcG9pbnQgbWFrZSB0aGUgZXZlbnRSZWN0IGZ1bGwgd2lkdGggKG9yIGhlaWdodClcclxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwgJiYgeC5uZXh0ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiBpc1JvdGF0ZWQgPyBzdGF0ZS5oZWlnaHQgOiBzdGF0ZS53aWR0aDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHgucHJldiA9IHhTY2FsZS5kb21haW4oKVswXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoeC5uZXh0ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHgubmV4dCA9IHhTY2FsZS5kb21haW4oKVsxXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoMCwgKHhTY2FsZSh4Lm5leHQpIC0geFNjYWxlKHgucHJldikpIC8gMik7XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmVjdFggPSBkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHggPSBnZXRQcmV2TmV4dFgoZCk7XHJcblx0XHRcdFx0XHRjb25zdCB0aGlzWCA9IGQueDtcclxuXHJcblx0XHRcdFx0XHQvLyBpZiB0aGVyZSB0aGlzIGlzIGEgc2luZ2xlIGRhdGEgcG9pbnQgcG9zaXRpb24gdGhlIGV2ZW50UmVjdCBhdCAwXHJcblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsICYmIHgubmV4dCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gMDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHgucHJldiA9IHhTY2FsZS5kb21haW4oKVswXTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gKHhTY2FsZSh0aGlzWCkgKyB4U2NhbGUoeC5wcmV2KSkgLyAyO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAwIDogcmVjdFg7XHJcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyByZWN0WCA6IDA7XHJcblx0XHRcdHcgPSBpc1JvdGF0ZWQgPyBzdGF0ZS53aWR0aCA6IHJlY3RXO1xyXG5cdFx0XHRoID0gaXNSb3RhdGVkID8gcmVjdFcgOiBzdGF0ZS5oZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0ZXZlbnRSZWN0RGF0YS5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NFdmVudC5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIHgpXHJcblx0XHRcdC5hdHRyKFwieVwiLCB5KVxyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIHcpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGgpO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdFJlY3RGb3JTaW5nbGUoY29udGV4dCwgZXZlbnRSZWN0LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzU2VsZWN0aW9uRW5hYmxlZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkO1xyXG5cdFx0Y29uc3QgaXNTZWxlY3Rpb25Hcm91cGVkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ7XHJcblx0XHRjb25zdCBpc1Rvb2x0aXBHcm91cGVkID0gY29uZmlnLnRvb2x0aXBfZ3JvdXBlZDtcclxuXHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9ICQkLmdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXgpO1xyXG5cclxuXHRcdGlmIChpc1Rvb2x0aXBHcm91cGVkKSB7XHJcblx0XHRcdCQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgY29udGV4dCk7XHJcblx0XHRcdCQkLnNob3dHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHRcdGlmICghaXNTZWxlY3Rpb25FbmFibGVkIHx8IGlzU2VsZWN0aW9uR3JvdXBlZCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtpbmRleH1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcclxuXHJcblx0XHRcdFx0aWYgKGlzU2VsZWN0aW9uRW5hYmxlZCkge1xyXG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIGlzU2VsZWN0aW9uR3JvdXBlZCA/IFwicG9pbnRlclwiIDogbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIWlzVG9vbHRpcEdyb3VwZWQpIHtcclxuXHRcdFx0XHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHRcdFx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblxyXG5cdFx0XHRcdFx0IWlzU2VsZWN0aW9uR3JvdXBlZCAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhpbmRleCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhbGwoc2VsZWN0ZWQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGQgPSBzZWxlY3RlZC5kYXRhKCk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1NlbGVjdGlvbkVuYWJsZWQgJiZcclxuXHRcdFx0XHRcdChpc1NlbGVjdGlvbkdyb3VwZWQgfHwgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkpXHJcblx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRldmVudFJlY3Quc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCFpc1Rvb2x0aXBHcm91cGVkKSB7XHJcblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChkLCBjb250ZXh0KTtcclxuXHRcdFx0XHRcdCQkLnNob3dHcmlkRm9jdXMoZCk7XHJcblxyXG5cdFx0XHRcdFx0JCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblx0XHRcdFx0XHRzZWxlY3RlZC5lYWNoKGQgPT4gJCQuZXhwYW5kQ2lyY2xlc0JhcnMoaW5kZXgsIGQuaWQpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZENpcmNsZXNCYXJzKGluZGV4OiBudW1iZXIsIGlkOiBzdHJpbmcsIHJlc2V0OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtiYXIsIGNpcmNsZX19ID0gJCQ7XHJcblxyXG5cdFx0Y2lyY2xlICYmIGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCAmJlxyXG5cdFx0XHQkJC5leHBhbmRDaXJjbGVzKGluZGV4LCBpZCwgcmVzZXQpO1xyXG5cclxuXHRcdGJhciAmJiAkJC5leHBhbmRCYXJzKGluZGV4LCBpZCwgcmVzZXQpO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKGNvbnRleHQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHQvLyBkbyBub3RoaW5nIHdoZW4gZHJhZ2dpbmdcclxuXHRcdGlmICgkJC5kcmFnZ2luZyB8fCAkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2UoY29udGV4dCk7XHJcblx0XHRjb25zdCBjbG9zZXN0ID0gJCQuZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzVG9TaG93LCBtb3VzZSk7XHJcblxyXG5cdFx0aWYgKHN0YXRlLm1vdXNlb3ZlciAmJiAoIWNsb3Nlc3QgfHwgY2xvc2VzdC5pZCAhPT0gc3RhdGUubW91c2VvdmVyLmlkKSkge1xyXG5cdFx0XHRjb25maWcuZGF0YV9vbm91dC5jYWxsKCQkLmFwaSwgc3RhdGUubW91c2VvdmVyKTtcclxuXHRcdFx0c3RhdGUubW91c2VvdmVyID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghY2xvc2VzdCkge1xyXG5cdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNhbWVYRGF0YSA9IChcclxuXHRcdFx0JCQuaXNCdWJibGVUeXBlKGNsb3Nlc3QpIHx8ICQkLmlzU2NhdHRlclR5cGUoY2xvc2VzdCkgfHwgIWNvbmZpZy50b29sdGlwX2dyb3VwZWRcclxuXHRcdCkgPyBbY2xvc2VzdF0gOiAkJC5maWx0ZXJCeVgodGFyZ2V0c1RvU2hvdywgY2xvc2VzdC54KTtcclxuXHJcblx0XHQvLyBzaG93IHRvb2x0aXAgd2hlbiBjdXJzb3IgaXMgY2xvc2UgdG8gc29tZSBwb2ludFxyXG5cdFx0Y29uc3Qgc2VsZWN0ZWREYXRhID0gc2FtZVhEYXRhLm1hcChkID0+ICQkLmFkZE5hbWUoZCkpO1xyXG5cclxuXHRcdCQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgY29udGV4dCk7XHJcblxyXG5cdFx0Ly8gZXhwYW5kIHBvaW50c1xyXG5cdFx0JCQuZXhwYW5kQ2lyY2xlc0JhcnMoY2xvc2VzdC5pbmRleCwgY2xvc2VzdC5pZCwgdHJ1ZSk7XHJcblxyXG5cdFx0Ly8gU2hvdyB4Z3JpZCBmb2N1cyBsaW5lXHJcblx0XHQkJC5zaG93R3JpZEZvY3VzKHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0Ly8gU2hvdyBjdXJzb3IgYXMgcG9pbnRlciBpZiBwb2ludCBpcyBjbG9zZSB0byBtb3VzZSBwb3NpdGlvblxyXG5cdFx0aWYgKCQkLmlzQmFyVHlwZShjbG9zZXN0LmlkKSB8fCAkJC5kaXN0KGNsb3Nlc3QsIG1vdXNlKSA8IGNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSkge1xyXG5cdFx0XHQkJC4kZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKTtcclxuXHJcblx0XHRcdGlmICghc3RhdGUubW91c2VvdmVyKSB7XHJcblx0XHRcdFx0Y29uZmlnLmRhdGFfb25vdmVyLmNhbGwoJCQuYXBpLCBjbG9zZXN0KTtcclxuXHRcdFx0XHRzdGF0ZS5tb3VzZW92ZXIgPSBjbG9zZXN0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5zZWxlY3QgRXZlbnRSZWN0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dW5zZWxlY3RSZWN0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7YmFyLCBjaXJjbGUsIHRvb2x0aXB9fSA9ICQkO1xyXG5cclxuXHRcdCQkLiRlbC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3R9YCkuc3R5bGUoXCJjdXJzb3JcIiwgbnVsbCk7XHJcblx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblxyXG5cdFx0aWYgKHRvb2x0aXApIHtcclxuXHRcdFx0JCQuaGlkZVRvb2x0aXAoKTtcclxuXHRcdFx0JCQuX2hhbmRsZUxpbmtlZENoYXJ0cyhmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2lyY2xlICYmICFjb25maWcucG9pbnRfZm9jdXNfb25seSAmJiAkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHRcdGJhciAmJiAkJC51bmV4cGFuZEJhcnMoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgZXZlbnRSZWN0IGZvciBlYWNoIGRhdGEgb24gdGhlIHgtYXhpcy5cclxuXHQgKiBSZWdpc3RlciB0b3VjaCBhbmQgZHJhZyBldmVudHMuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UmVjdEVudGVyIGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICogQHJldHVybnMge29iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0RW50ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHJlY3QgPSBldmVudFJlY3RFbnRlci5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NFdmVudC5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gXCJwb2ludGVyXCIgOiBudWxsKVxyXG5cdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yU2luZ2xlWC5iaW5kKHRoaXMpKGQsICQkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhbGwoJCQuZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xyXG5cdFx0XHRyZWN0XHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGQgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXHJcblx0XHRcdFx0XHRpZiAoc3RhdGUuZHJhZ2dpbmcgfHwgc3RhdGUuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbmZpZy50b29sdGlwX2dyb3VwZWQgJiYgJCQuc2V0T3Zlck91dCh0cnVlLCBkLmluZGV4KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nIHdoaWxlIGRyYWdnaW5nL2Zsb3dpbmdcclxuXHRcdFx0XHRcdGlmIChzdGF0ZS5kcmFnZ2luZyB8fCBzdGF0ZS5mbG93aW5nIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gZC5pbmRleDtcclxuXHRcdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLiRlbC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3R9LSR7aW5kZXh9YCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkgJiZcclxuXHRcdFx0XHRcdFx0Y29uZmlnLmxpbmVfc3RlcF90eXBlID09PSBcInN0ZXAtYWZ0ZXJcIiAmJlxyXG5cdFx0XHRcdFx0XHRkM01vdXNlKHRoaXMpWzBdIDwgJCQuc2NhbGUueCgkJC5nZXRYVmFsdWUoZC5pZCwgaW5kZXgpKVxyXG5cdFx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRcdGluZGV4IC09IDE7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aW5kZXggPT09IC0xID9cclxuXHRcdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOiAkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKHRoaXMsIGV2ZW50UmVjdCwgaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEFzIG9mIGluZGl2aWR1YWwgZGF0YSBwb2ludChvciA8cGF0aD4pIGVsZW1lbnQgY2FuJ3QgYmluZCBtb3VzZW92ZXIvb3V0IGV2ZW50XHJcblx0XHRcdFx0XHQvLyB0byBkZXRlcm1pbmUgY3VycmVudCBpbnRlcmFjdGluZyBlbGVtZW50LCBzbyB1c2UgJ21vdXNlbW92ZScgZXZlbnQgaW5zdGVhZC5cclxuXHRcdFx0XHRcdGlmICghY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGluZGV4ICE9PSAtMSwgZC5pbmRleCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcclxuXHRcdFx0XHRcdC8vIGNoYXJ0IGlzIGRlc3Ryb3llZFxyXG5cdFx0XHRcdFx0aWYgKCFjb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQoZmFsc2UsIGQuaW5kZXgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH0sXHJcblxyXG5cdGNsaWNrSGFuZGxlckZvclNpbmdsZVgoZCwgY3R4KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IGN0eDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCBzdGF0ZS5jYW5jZWxDbGljaykge1xyXG5cdFx0XHRzdGF0ZS5jYW5jZWxDbGljayAmJiAoc3RhdGUuY2FuY2VsQ2xpY2sgPSBmYWxzZSk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qge2luZGV4fSA9IGQ7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2luZGV4fWApXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQyKSB7XHJcblx0XHRcdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICQkLmlzV2l0aGluU2hhcGUodGhpcywgZDIpKSB7XHJcblx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSh0aGlzLCBkMiwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0Y29uZmlnLmRhdGFfb25jbGljay5iaW5kKCQkLmFwaSkoZDIsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlIGFuIGV2ZW50UmVjdCxcclxuXHQgKiBSZWdpc3RlciB0b3VjaCBhbmQgZHJhZyBldmVudHMuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGV2ZW50UmVjdEVudGVyIGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICogQHJldHVybnMge29iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlRXZlbnRSZWN0c0Zvck11bHRpcGxlWHMoZXZlbnRSZWN0RW50ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0LCBpbnB1dFR5cGV9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0Y29uc3QgcmVjdCA9IGV2ZW50UmVjdEVudGVyXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgMClcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB3aWR0aClcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaGVpZ2h0KVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmV2ZW50UmVjdClcclxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUy5iaW5kKHRoaXMpKCQkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhbGwoJCQuZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkpO1xyXG5cclxuXHRcdGlmIChpbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xyXG5cdFx0XHRyZWN0XHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyIG1vdXNlbW92ZVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzKHRoaXMpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gY2hhcnQgaXMgZGVzdHJveWVkXHJcblx0XHRcdFx0XHRpZiAoISQkLmNvbmZpZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH0sXHJcblxyXG5cdGNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMoY3R4KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IGN0eDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKHRhcmdldHNUb1Nob3cpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2UodGhpcyk7XHJcblx0XHRjb25zdCBjbG9zZXN0ID0gJCQuZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzVG9TaG93LCBtb3VzZSk7XHJcblxyXG5cdFx0aWYgKCFjbG9zZXN0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgaWYgc2VsZWN0aW9uIGVuYWJsZWRcclxuXHRcdGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcclxuXHRcdFx0JCQuJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChjbG9zZXN0LmlkKX1gKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2Nsb3Nlc3QuaW5kZXh9YClcclxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGNsb3Nlc3QpKSB7XHJcblx0XHRcdFx0XHRcdCQkLnRvZ2dsZVNoYXBlKHRoaXMsIGNsb3Nlc3QsIGNsb3Nlc3QuaW5kZXgpO1xyXG5cdFx0XHRcdFx0XHRjb25maWcuZGF0YV9vbmNsaWNrLmJpbmQoJCQuYXBpKShjbG9zZXN0LCB0aGlzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0ZXZlbnQgYXMgZDNFdmVudFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtcclxuXHRicnVzaFggYXMgZDNCcnVzaFgsXHJcblx0YnJ1c2hZIGFzIGQzQnJ1c2hZLFxyXG5cdGJydXNoU2VsZWN0aW9uIGFzIGQzQnJ1c2hTZWxlY3Rpb25cclxufSBmcm9tIFwiZDMtYnJ1c2hcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2JydXNoRW1wdHksIGNhcGl0YWxpemUsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGdldFJhbmRvbSwgcGFyc2VEYXRlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBicnVzaC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRCcnVzaCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCAkZWw6IHtzdWJjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdC8vIHNldCB0aGUgYnJ1c2hcclxuXHRcdCQkLmJydXNoID0gaXNSb3RhdGVkID8gZDNCcnVzaFkoKSA6IGQzQnJ1c2hYKCk7XHJcblxyXG5cdFx0Ly8gc2V0IFwiYnJ1c2hcIiBldmVudFxyXG5cdFx0Y29uc3QgYnJ1c2hIYW5kbGVyID0gKCkgPT4ge1xyXG5cdFx0XHQkJC5yZWRyYXdGb3JCcnVzaCgpO1xyXG5cdFx0fTtcclxuXHRcdGNvbnN0IGdldEJydXNoU2l6ZSA9ICgpID0+IHtcclxuXHRcdFx0Y29uc3QgYnJ1c2ggPSAkJC4kZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9IC5vdmVybGF5YCk7XHJcblx0XHRcdGNvbnN0IGJydXNoU2l6ZSA9IHt3aWR0aDogMCwgaGVpZ2h0OiAwfTtcclxuXHJcblx0XHRcdGlmIChicnVzaC5zaXplKCkpIHtcclxuXHRcdFx0XHRicnVzaFNpemUud2lkdGggPSArYnJ1c2guYXR0cihcIndpZHRoXCIpO1xyXG5cdFx0XHRcdGJydXNoU2l6ZS5oZWlnaHQgPSArYnJ1c2guYXR0cihcImhlaWdodFwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGJydXNoU2l6ZVtpc1JvdGF0ZWQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiXTtcclxuXHRcdH07XHJcblxyXG5cdFx0bGV0IGxhc3REb21haW47XHJcblx0XHRsZXQgdGltZW91dDtcclxuXHJcblx0XHQkJC5icnVzaFxyXG5cdFx0XHQub24oXCJzdGFydFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0JCQuc3RhdGUuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgJCQuaGlkZVRvb2x0aXAoKTtcclxuXHRcdFx0XHRicnVzaEhhbmRsZXIoKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm9uKFwiYnJ1c2hcIiwgYnJ1c2hIYW5kbGVyKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdGxhc3REb21haW4gPSBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHQkJC5icnVzaC51cGRhdGVSZXNpemUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0dGltZW91dCAmJiBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcblx0XHRcdHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdFx0XHRsYXN0RG9tYWluICYmIGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uLm5vZGUoKSkgJiZcclxuXHRcdFx0XHRcdHRoaXMubW92ZShzZWxlY3Rpb24sIGxhc3REb21haW4ubWFwKHNjYWxlLnN1Ylgub3JnU2NhbGUoKSkpO1xyXG5cdFx0XHR9LCAwKTtcclxuXHRcdH07XHJcblxyXG5cdFx0JCQuYnJ1c2gudXBkYXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMuZXh0ZW50KCkoKTtcclxuXHJcblx0XHRcdGlmIChleHRlbnRbMV0uZmlsdGVyKHYgPT4gaXNOYU4odikpLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdHN1YmNoYXJ0Lm1haW4gJiYgc3ViY2hhcnQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApLmNhbGwodGhpcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBzZXQgdGhlIGJydXNoIGV4dGVudFxyXG5cdFx0JCQuYnJ1c2guc2NhbGUgPSBmdW5jdGlvbihzY2FsZSkge1xyXG5cdFx0XHRjb25zdCBoID0gY29uZmlnLnN1YmNoYXJ0X3NpemVfaGVpZ2h0IHx8IGdldEJydXNoU2l6ZSgpO1xyXG5cdFx0XHRsZXQgZXh0ZW50ID0gJCQuZ2V0RXh0ZW50KCk7XHJcblxyXG5cdFx0XHRpZiAoIWV4dGVudCAmJiBzY2FsZS5yYW5nZSkge1xyXG5cdFx0XHRcdGV4dGVudCA9IFtbMCwgMF0sIFtzY2FsZS5yYW5nZSgpWzFdLCBoXV07XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNBcnJheShleHRlbnQpKSB7XHJcblx0XHRcdFx0ZXh0ZW50ID0gZXh0ZW50Lm1hcCgodiwgaSkgPT4gW3YsIGkgPiAwID8gaCA6IGldKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gW1t4MCwgeTBdLCBbeDEsIHkxXV0sIHdoZXJlIFt4MCwgeTBdIGlzIHRoZSB0b3AtbGVmdCBjb3JuZXIgYW5kIFt4MSwgeTFdIGlzIHRoZSBib3R0b20tcmlnaHQgY29ybmVyXHJcblx0XHRcdGlzUm90YXRlZCAmJiBleHRlbnRbMV0ucmV2ZXJzZSgpO1xyXG5cdFx0XHR0aGlzLmV4dGVudChleHRlbnQpO1xyXG5cclxuXHRcdFx0Ly8gd2hlbiBleHRlbnQgdXBkYXRlcywgYnJ1c2ggc2VsZWN0aW9uIGFsc28gYmUgcmUtYXBwbGllZFxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvaXNzdWVzLzI5MThcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH07XHJcblxyXG5cdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uID0gKCkgPT4gKFxyXG5cdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdHN1YmNoYXJ0Lm1haW4gPyBzdWJjaGFydC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9YCkgOiBkM1NlbGVjdChbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgc3ViY2hhcnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0U3ViY2hhcnQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXAsIGhhc0F4aXN9LCAkZWw6IHtkZWZzLCBzdmcsIHN1YmNoYXJ0LCBheGlzfX0gPSAkJDtcclxuXHJcblx0XHRpZiAoIWhhc0F4aXMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHZpc2liaWxpdHkgPSBjb25maWcuc3ViY2hhcnRfc2hvdyA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIjtcclxuXHRcdGNvbnN0IGNsaXBJZCA9IGAke2NsaXAuaWR9LXN1YmNoYXJ0YDtcclxuXHRcdGNvbnN0IGNsaXBQYXRoID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcElkKTtcclxuXHJcblx0XHRjbGlwLmlkU3ViY2hhcnQgPSBjbGlwSWQ7XHJcblx0XHQkJC5hcHBlbmRDbGlwKGRlZnMsIGNsaXBJZCk7XHJcblx0XHQkJC5pbml0QnJ1c2goKTtcclxuXHJcblx0XHRzdWJjaGFydC5tYWluID0gc3ZnLmFwcGVuZChcImdcIikuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJjb250ZXh0XCIpKTtcclxuXHJcblx0XHRjb25zdCB7bWFpbn0gPSBzdWJjaGFydDtcclxuXHJcblx0XHRtYWluLnN0eWxlKFwidmlzaWJpbGl0eVwiLCB2aXNpYmlsaXR5KTtcclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnQgYXJlYVxyXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0KTtcclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgYmFyIGNoYXJ0IGFyZWFcclxuXHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgbGluZSBjaGFydCBhcmVhXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydExpbmVzKTtcclxuXHJcblx0XHQvLyBBZGQgZXh0ZW50IHJlY3QgZm9yIEJydXNoXHJcblx0XHRtYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcFBhdGgpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYnJ1c2gpXHJcblx0XHRcdC5jYWxsKCQkLmJydXNoKTtcclxuXHJcblx0XHQvLyBBVFRFTlRJT046IFRoaXMgbXVzdCBiZSBjYWxsZWQgQUZURVIgY2hhcnQgYWRkZWRcclxuXHRcdC8vIEFkZCBBeGlzXHJcblx0XHRheGlzLnN1YlggPSBtYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5heGlzWClcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwic3ViWFwiKSlcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IFwiXCIgOiBjbGlwLnBhdGhYQXhpcylcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWcuc3ViY2hhcnRfYXhpc194X3Nob3cgPyB2aXNpYmlsaXR5IDogXCJoaWRkZW5cIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHN1YiBjaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRzICQkLmRhdGEudGFyZ2V0c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtzdWJjaGFydDoge21haW59fX0gPSAkJDtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRCYXIgPSAkJC5jbGFzc0NoYXJ0QmFyLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NCYXJzID0gJCQuY2xhc3NCYXJzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydExpbmUgPSAkJC5jbGFzc0NoYXJ0TGluZS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NBcmVhcyA9ICQkLmNsYXNzQXJlYXMuYmluZCgkJCk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdC8vIC0tIEJhciAtLS8vXHJcblx0XHRcdGNvbnN0IGJhclVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEJhcnN9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEJhcn1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKTtcclxuXHRcdFx0Y29uc3QgYmFyRW50ZXIgPSBiYXJVcGRhdGUuZW50ZXIoKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXHJcblx0XHRcdFx0Lm1lcmdlKGJhclVwZGF0ZSk7XHJcblxyXG5cdFx0XHQvLyBCYXJzIGZvciBlYWNoIGRhdGFcclxuXHRcdFx0YmFyRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXJzKTtcclxuXHJcblx0XHRcdC8vIC0tIExpbmUgLS0vL1xyXG5cdFx0XHRjb25zdCBsaW5lVXBkYXRlID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0TGluZXN9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydExpbmV9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpO1xyXG5cdFx0XHRjb25zdCBsaW5lRW50ZXIgPSBsaW5lVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0TGluZSlcclxuXHRcdFx0XHQubWVyZ2UobGluZVVwZGF0ZSk7XHJcblxyXG5cdFx0XHQvLyBMaW5lcyBmb3IgZWFjaCBkYXRhXHJcblx0XHRcdGxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcclxuXHJcblx0XHRcdC8vIEFyZWFcclxuXHRcdFx0JCQuaGFzVHlwZShcImFyZWFcIikgJiYgbGluZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXJlYXMpO1xyXG5cclxuXHRcdFx0Ly8gLS0gQnJ1c2ggLS0vL1xyXG5cdFx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYnJ1c2h9IHJlY3RgKVxyXG5cdFx0XHRcdC5hdHRyKGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gc3RhdGUud2lkdGgyIDogc3RhdGUuaGVpZ2h0Mik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBiYXIgb2YgdGhlIHN1YiBjaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkdXJhdGlvbkZvckV4aXQgVHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlQmFyRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsOiB7c3ViY2hhcnR9fSA9ICQkO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmJhciA9IHN1YmNoYXJ0Lm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfWApXHJcblx0XHRcdC5kYXRhKCQkLmJhckRhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmJhclxyXG5cdFx0XHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmJhciA9IHN1YmNoYXJ0LmJhclxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQmFyLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgXCJub25lXCIpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5tZXJnZShzdWJjaGFydC5iYXIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgYmFyIG9mIHRoZSBzdWJjaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkcmF3QmFyT25TdWIgcGF0aCBpbiBzdWJjaGFydCBsaW5lXHJcblx0ICogQHBhcmFtIHtib29sZWFufSB3aXRoVHJhbnNpdGlvbiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd0JhckZvclN1YmNoYXJ0KGRyYXdCYXJPblN1Yjogc3RyaW5nLCB3aXRoVHJhbnNpdGlvbjogYm9vbGVhbiwgZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3Qge2Jhcn0gPSB0aGlzLiRlbC5zdWJjaGFydDtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyBiYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogYmFyKVxyXG5cdFx0XHQuYXR0cihcImRcIiwgZHJhd0Jhck9uU3ViKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxpbmUgb2YgdGhlIHN1YiBjaGFydFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbkZvckV4aXQgRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlTGluZUZvclN1YmNoYXJ0KGR1cmF0aW9uRm9yRXhpdCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbDoge3N1YmNoYXJ0fX0gPSAkJDtcclxuXHJcblx0XHRzdWJjaGFydC5saW5lID0gc3ViY2hhcnQubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmxpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxpbmV9YClcclxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmxpbmVcclxuXHRcdFx0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRzdWJjaGFydC5saW5lID0gc3ViY2hhcnQubGluZVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzTGluZS5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2Uoc3ViY2hhcnQubGluZSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRoZSBsaW5lIG9mIHRoZSBzdWJjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRyYXdMaW5lT25TdWIgcGF0aCBpbiBzdWJjaGFydCBsaW5lXHJcblx0ICogQHBhcmFtIHtib29sZWFufSB3aXRoVHJhbnNpdGlvbiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHRyZWRyYXdMaW5lRm9yU3ViY2hhcnQoZHJhd0xpbmVPblN1Yjogc3RyaW5nLCB3aXRoVHJhbnNpdGlvbjogYm9vbGVhbiwgZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3Qge2xpbmV9ID0gdGhpcy4kZWwuc3ViY2hhcnQ7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gbGluZS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOiBsaW5lKVxyXG5cdFx0XHQuYXR0cihcImRcIiwgZHJhd0xpbmVPblN1YilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBhcmVhIG9mIHRoZSBzdWIgY2hhcnRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25Gb3JFeGl0IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUFyZWFGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWw6IHtzdWJjaGFydH19ID0gJCQ7XHJcblxyXG5cdFx0c3ViY2hhcnQuYXJlYSA9IHN1YmNoYXJ0Lm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdWJjaGFydC5hcmVhXHJcblx0XHRcdC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0c3ViY2hhcnQuYXJlYSA9IHN1YmNoYXJ0LmFyZWFcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyZWEuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JCQuc3RhdGUub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XHJcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2Uoc3ViY2hhcnQuYXJlYSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRoZSBhcmVhIG9mIHRoZSBzdWJjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGRyYXdBcmVhT25TdWIgcGF0aCBpbiBzdWJjaGFydCBsaW5lXHJcblx0ICogQHBhcmFtIHtib29sZWFufSB3aXRoVHJhbnNpdGlvbiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHRyZWRyYXdBcmVhRm9yU3ViY2hhcnQoZHJhd0FyZWFPblN1Yjogc3RyaW5nLCB3aXRoVHJhbnNpdGlvbjogYm9vbGVhbiwgZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3Qge2FyZWF9ID0gdGhpcy4kZWwuc3ViY2hhcnQ7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gYXJlYS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOiBhcmVhKVxyXG5cdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWFPblN1YilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCB0aGlzLmNvbG9yKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIHRoaXMuc3RhdGUub3JnQXJlYU9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyBzdWJjaGFydC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFN1YmNoYXJ0IHdoZXRoZXIgb3Igbm90IHRvIHNob3cgc3ViY2hhcnRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gZHVyYXRpb25cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2hhcGUgU2hhcGUncyBpbmZvXHJcblx0ICovXHJcblx0cmVkcmF3U3ViY2hhcnQod2l0aFN1YmNoYXJ0OiBib29sZWFuLCBkdXJhdGlvbjogbnVtYmVyLCBzaGFwZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7c3ViY2hhcnQ6IHttYWlufX19ID0gJCQ7XHJcblxyXG5cdFx0bWFpbi5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpO1xyXG5cclxuXHRcdC8vIHN1YmNoYXJ0XHJcblx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcclxuXHRcdFx0Ly8gcmVmbGVjdCBtYWluIGNoYXJ0IHRvIGV4dGVudCBvbiBzdWJjaGFydCBpZiB6b29tZWRcclxuXHRcdFx0aWYgKGQzRXZlbnQgJiYgZDNFdmVudC50eXBlID09PSBcInpvb21cIikge1xyXG5cdFx0XHRcdCQkLmJydXNoLnVwZGF0ZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgc3ViY2hhcnQgZWxlbWVudHMgaWYgbmVlZGVkXHJcblx0XHRcdGlmICh3aXRoU3ViY2hhcnQpIHtcclxuXHRcdFx0XHQvLyBleHRlbnQgcmVjdFxyXG5cdFx0XHRcdCFicnVzaEVtcHR5KCQkKSAmJiAkJC5icnVzaC51cGRhdGUoKTtcclxuXHJcblx0XHRcdFx0T2JqZWN0LmtleXMoc2hhcGUudHlwZSkuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBjYXBpdGFsaXplKHYpO1xyXG5cdFx0XHRcdFx0Y29uc3QgZHJhdyA9ICQkW2BnZW5lcmF0ZURyYXcke25hbWV9YF0oc2hhcGUuaW5kaWNlc1t2XSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdFx0JCRbYHVwZGF0ZSR7bmFtZX1Gb3JTdWJjaGFydGBdKGR1cmF0aW9uKTtcclxuXHRcdFx0XHRcdCQkW2ByZWRyYXcke25hbWV9Rm9yU3ViY2hhcnRgXShkcmF3LCBkdXJhdGlvbiwgZHVyYXRpb24pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRoZSBicnVzaC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd0ZvckJydXNoKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZzoge3N1YmNoYXJ0X29uYnJ1c2g6IG9uQnJ1c2gsIHpvb21fcmVzY2FsZTogd2l0aFl9LCBzY2FsZX0gPSAkJDtcclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2UsXHJcblx0XHRcdHdpdGhZLFxyXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdG9uQnJ1c2guYmluZCgkJC5hcGkpKHNjYWxlLngub3JnRG9tYWluKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYW5zZm9ybSBjb250ZXh0XHJcblx0ICogQHBhcmFtIHtib29sZWFufSB3aXRoVHJhbnNpdGlvbiBpbmRpY2F0ZXMgdHJhbnNpdGlvbiBpcyBlbmFibGVkXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRyYW5zaXRpb25zIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGdlbmVyYXRlVHJhbnNpdGlvbnMgbWV0aG9kIG9mIEF4aXMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0cmFuc2Zvcm1Db250ZXh0KHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsLnN1YmNoYXJ0O1xyXG5cdFx0bGV0IHN1YlhBeGlzO1xyXG5cclxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzU3ViWCkge1xyXG5cdFx0XHRzdWJYQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNTdWJYO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3ViWEF4aXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9YCk7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRzdWJYQXhpcyA9IHN1YlhBeGlzLnRyYW5zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJjb250ZXh0XCIpKTtcclxuXHRcdHN1YlhBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwic3ViWFwiKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGV4dGVudCB2YWx1ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gZGVmYXVsdCBleHRlbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEV4dGVudCgpOiBudW1iZXJbXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGxldCBleHRlbnQgPSBjb25maWcuYXhpc194X2V4dGVudDtcclxuXHJcblx0XHRpZiAoZXh0ZW50KSB7XHJcblx0XHRcdGlmIChpc0Z1bmN0aW9uKGV4dGVudCkpIHtcclxuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQuYmluZCgkJC5hcGkpKCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSwgc2NhbGUuc3ViWCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoJCQuYXhpcy5pc1RpbWVTZXJpZXMoKSAmJiBleHRlbnQuZXZlcnkoaXNOYU4pKSB7XHJcblx0XHRcdFx0Y29uc3QgZm4gPSBwYXJzZURhdGUuYmluZCgkJCk7XHJcblxyXG5cdFx0XHRcdGV4dGVudCA9IGV4dGVudC5tYXAodiA9PiBzY2FsZS5zdWJYKGZuKHYpKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXh0ZW50O1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdG1vdXNlIGFzIGQzTW91c2UsXHJcblx0ZXZlbnQgYXMgZDNFdmVudCxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3RcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZHJhZyBhcyBkM0RyYWd9IGZyb20gXCJkMy1kcmFnXCI7XHJcbmltcG9ydCB7em9vbSBhcyBkM1pvb219IGZyb20gXCJkMy16b29tXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FsbEZuLCBkaWZmRG9tYWluLCBnZXRNaW5NYXgsIGlzRGVmaW5lZCwgaXNGdW5jdGlvbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB6b29tLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFpvb20oKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuc2NhbGUuem9vbSA9IG51bGw7XHJcblxyXG5cdFx0JCQuZ2VuZXJhdGVab29tKCk7XHJcblx0XHQkJC5pbml0Wm9vbUJlaGF2aW91cigpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEJpbmQgem9vbSBldmVudFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gYmluZCBXZWF0aGVyIGJpbmQgb3IgdW5ib3VuZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0YmluZFpvb21FdmVudChiaW5kID0gdHJ1ZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XHJcblxyXG5cdFx0JCQucmVkcmF3RXZlbnRSZWN0KCk7XHJcblxyXG5cdFx0Y29uc3QgZXZlbnRSZWN0cyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3RzfWApO1xyXG5cclxuXHRcdGlmICh6b29tRW5hYmxlZCAmJiBiaW5kKSB7XHJcblx0XHRcdC8vIERvIG5vdCBiaW5kIHpvb20gZXZlbnQgd2hlbiBzdWJjaGFydCBpcyBzaG93blxyXG5cdFx0XHQhY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiZcclxuXHRcdFx0XHQkJC5iaW5kWm9vbU9uRXZlbnRSZWN0KGV2ZW50UmVjdHMsIHpvb21FbmFibGVkLnR5cGUpO1xyXG5cdFx0fSBlbHNlIGlmIChiaW5kID09PSBmYWxzZSkge1xyXG5cdFx0XHQkJC5hcGkudW56b29tKCk7XHJcblxyXG5cdFx0XHRldmVudFJlY3RzXHJcblx0XHRcdFx0Lm9uKFwiLnpvb21cIiwgbnVsbClcclxuXHRcdFx0XHQub24oXCIuZHJhZ1wiLCBudWxsKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSB6b29tXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVpvb20oKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBvcmcsIHNjYWxlfSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHpvb20gPSBkM1pvb20oKS5kdXJhdGlvbigwKVxyXG5cdFx0XHQub24oXCJzdGFydFwiLCAkJC5vblpvb21TdGFydC5iaW5kKCQkKSlcclxuXHRcdFx0Lm9uKFwiem9vbVwiLCAkJC5vblpvb20uYmluZCgkJCkpXHJcblx0XHRcdC5vbihcImVuZFwiLCAkJC5vblpvb21FbmQuYmluZCgkJCkpO1xyXG5cclxuXHRcdC8vIGdldCB6b29tIGV4dGVudFxyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0em9vbS5vcmdTY2FsZUV4dGVudCA9ICgpOiBbbnVtYmVyLCBudW1iZXJdID0+IHtcclxuXHRcdFx0Y29uc3QgZXh0ZW50ID0gY29uZmlnLnpvb21fZXh0ZW50IHx8IFsxLCAxMF07XHJcblxyXG5cdFx0XHRyZXR1cm4gW2V4dGVudFswXSwgTWF0aC5tYXgoJCQuZ2V0TWF4RGF0YUNvdW50KCkgLyBleHRlbnRbMV0sIGV4dGVudFsxXSldO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHR6b29tLnVwZGF0ZVNjYWxlRXh0ZW50ID0gZnVuY3Rpb24oKTogem9vbSB7XHJcblx0XHRcdGNvbnN0IHJhdGlvID0gZGlmZkRvbWFpbigkJC5zY2FsZS54Lm9yZ0RvbWFpbigpKSAvIGRpZmZEb21haW4oJCQuZ2V0Wm9vbURvbWFpbigpKTtcclxuXHRcdFx0Y29uc3QgZXh0ZW50ID0gdGhpcy5vcmdTY2FsZUV4dGVudCgpO1xyXG5cclxuXHRcdFx0dGhpcy5zY2FsZUV4dGVudChbZXh0ZW50WzBdICogcmF0aW8sIGV4dGVudFsxXSAqIHJhdGlvXSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH07XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBVcGRhdGUgc2NhbGUgYWNjb3JkaW5nIHpvb20gdHJhbnNmb3JtIHZhbHVlXHJcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gdHJhbnNmb3JtIHRyYW5zZm9ybSBvYmplY3RcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHpvb20udXBkYXRlVHJhbnNmb3JtU2NhbGUgPSAodHJhbnNmb3JtOiBvYmplY3QpOiB2b2lkID0+IHtcclxuXHRcdFx0Ly8gaW4gY2FzZSBvZiByZXNpemUsIHVwZGF0ZSByYW5nZSBvZiBvcmdYU2NhbGVcclxuXHRcdFx0b3JnLnhTY2FsZSAmJiBvcmcueFNjYWxlLnJhbmdlKHNjYWxlLngucmFuZ2UoKSk7XHJcblxyXG5cdFx0XHQvLyByZXNjYWxlIGZyb20gdGhlIG9yaWdpbmFsIHNjYWxlXHJcblx0XHRcdGNvbnN0IG5ld1NjYWxlID0gdHJhbnNmb3JtW1xyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInJlc2NhbGVZXCIgOiBcInJlc2NhbGVYXCJcclxuXHRcdFx0XShvcmcueFNjYWxlIHx8IHNjYWxlLngpO1xyXG5cclxuXHRcdFx0Y29uc3QgZG9tYWluID0gJCQudHJpbVhEb21haW4obmV3U2NhbGUuZG9tYWluKCkpO1xyXG5cdFx0XHRjb25zdCByZXNjYWxlID0gY29uZmlnLnpvb21fcmVzY2FsZTtcclxuXHJcblx0XHRcdG5ld1NjYWxlLmRvbWFpbihkb21haW4sIG9yZy54RG9tYWluKTtcclxuXHJcblx0XHRcdHNjYWxlLnpvb20gPSAkJC5nZXRDdXN0b21pemVkU2NhbGUobmV3U2NhbGUpO1xyXG5cdFx0XHQkJC5heGlzLnguc2NhbGUoc2NhbGUuem9vbSk7XHJcblxyXG5cdFx0XHRpZiAocmVzY2FsZSkge1xyXG5cdFx0XHRcdC8vIGNvcHkgY3VycmVudCBpbml0aWFsIHggc2NhbGUgaW4gY2FzZSBvZiByZXNjYWxlIG9wdGlvbiBpcyB1c2VkXHJcblx0XHRcdFx0IW9yZy54U2NhbGUgJiYgKG9yZy54U2NhbGUgPSBzY2FsZS54LmNvcHkoKSk7XHJcblx0XHRcdFx0c2NhbGUueC5kb21haW4oZG9tYWluKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQkJC56b29tID0gem9vbTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiAnc3RhcnQnIGV2ZW50IGxpc3RlbmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvblpvb21TdGFydCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudC5zb3VyY2VFdmVudDtcclxuXHJcblx0XHRpZiAoIWV2ZW50KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkJC56b29tLnN0YXJ0RXZlbnQgPSBldmVudDtcclxuXHRcdGNhbGxGbigkJC5jb25maWcuem9vbV9vbnpvb21zdGFydCwgJCQuYXBpLCBldmVudCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogJ3pvb20nIGV2ZW50IGxpc3RlbmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvblpvb20oKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgb3JnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xyXG5cdFx0Y29uc3Qge3NvdXJjZUV2ZW50fSA9IGV2ZW50O1xyXG5cclxuXHRcdGlmIChcclxuXHRcdFx0IWNvbmZpZy56b29tX2VuYWJsZWQgfHxcclxuXHRcdFx0IWV2ZW50LnNvdXJjZUV2ZW50IHx8XHJcblx0XHRcdCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggPT09IDAgfHxcclxuXHRcdFx0KCFzY2FsZS56b29tICYmIHNvdXJjZUV2ZW50LnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID4gLTEgJiYgc291cmNlRXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEpXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzTW91c2Vtb3ZlID0gc291cmNlRXZlbnQudHlwZSA9PT0gXCJtb3VzZW1vdmVcIjtcclxuXHRcdGNvbnN0IGlzWm9vbU91dCA9IHNvdXJjZUV2ZW50LndoZWVsRGVsdGEgPCAwO1xyXG5cdFx0Y29uc3Qge3RyYW5zZm9ybX0gPSBldmVudDtcclxuXHJcblx0XHRpZiAoIWlzTW91c2Vtb3ZlICYmIGlzWm9vbU91dCAmJiBzY2FsZS54LmRvbWFpbigpLmV2ZXJ5KCh2LCBpKSA9PiB2ICE9PSBvcmcueERvbWFpbltpXSkpIHtcclxuXHRcdFx0c2NhbGUueC5kb21haW4ob3JnLnhEb21haW4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnpvb20udXBkYXRlVHJhbnNmb3JtU2NhbGUodHJhbnNmb3JtKTtcclxuXHJcblx0XHRpZiAoJCQuYXhpcy5pc0NhdGVnb3JpemVkKCkgJiYgc2NhbGUueC5vcmdEb21haW4oKVswXSA9PT0gb3JnLnhEb21haW5bMF0pIHtcclxuXHRcdFx0c2NhbGUueC5kb21haW4oW29yZy54RG9tYWluWzBdIC0gMWUtMTAsIHNjYWxlLngub3JnRG9tYWluKClbMV1dKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2UsXHJcblx0XHRcdHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlLFxyXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxyXG5cdFx0XHR3aXRoRXZlbnRSZWN0OiBmYWxzZSxcclxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdCQkLnN0YXRlLmNhbmNlbENsaWNrID0gaXNNb3VzZW1vdmU7XHJcblx0XHRjYWxsRm4oY29uZmlnLnpvb21fb256b29tLCAkJC5hcGksIHNjYWxlLnpvb20uZG9tYWluKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqICdlbmQnIGV2ZW50IGxpc3RlbmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvblpvb21FbmQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGxldCB7c3RhcnRFdmVudH0gPSAkJC56b29tO1xyXG5cdFx0bGV0IGV2ZW50ID0gZDNFdmVudCAmJiBkM0V2ZW50LnNvdXJjZUV2ZW50O1xyXG5cclxuXHRcdGlmICgoc3RhcnRFdmVudCAmJiBzdGFydEV2ZW50LnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID4gLTEpKSB7XHJcblx0XHRcdHN0YXJ0RXZlbnQgPSBzdGFydEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGNsaWNrLCBkbyBub3RoaW5nLiBvdGhlcndpc2UsIGNsaWNrIGludGVyYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXHJcblx0XHRpZiAoIXN0YXJ0RXZlbnQgfHxcclxuXHRcdFx0KGV2ZW50ICYmIHN0YXJ0RXZlbnQuY2xpZW50WCA9PT0gZXZlbnQuY2xpZW50WCAmJiBzdGFydEV2ZW50LmNsaWVudFkgPT09IGV2ZW50LmNsaWVudFkpXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cdFx0JCQudXBkYXRlWm9vbSgpO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuem9vbV9vbnpvb21lbmQsICQkLmFwaSwgc2NhbGVbc2NhbGUuem9vbSA/IFwiem9vbVwiIDogXCJzdWJYXCJdLmRvbWFpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgem9vbSBkb21haW5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHpvb20gZG9tYWluXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRab29tRG9tYWluKCk6IFtudW1iZXIsIG51bWJlcl0ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnfSA9ICQkO1xyXG5cdFx0bGV0IFttaW4sIG1heF0gPSBvcmcueERvbWFpbjtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWluKSkge1xyXG5cdFx0XHRtaW4gPSBnZXRNaW5NYXgoXCJtaW5cIiwgW21pbiwgY29uZmlnLnpvb21feF9taW5dKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWF4KSkge1xyXG5cdFx0XHRtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgW21heCwgY29uZmlnLnpvb21feF9tYXhdKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gW21pbiwgbWF4XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgem9vbVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgRm9yY2UgdW56b29tXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVab29tKGZvcmNlOiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3ViWCwgeCwgem9vbX0gPSAkJC5zY2FsZTtcclxuXHJcblx0XHRpZiAoem9vbSkge1xyXG5cdFx0XHRjb25zdCB6b29tRG9tYWluID0gem9vbS5kb21haW4oKTtcclxuXHRcdFx0Y29uc3QgeERvbWFpbiA9IHN1YlguZG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IGRlbHRhID0gMC4wMTU7IC8vIGFyYml0cmFyeSB2YWx1ZVxyXG5cclxuXHRcdFx0Y29uc3QgaXNmdWxseVNob3duID0gKHpvb21Eb21haW5bMF0gPD0geERvbWFpblswXSB8fCAoem9vbURvbWFpblswXSAtIGRlbHRhKSA8PSB4RG9tYWluWzBdKSAmJlxyXG5cdFx0XHRcdCh4RG9tYWluWzFdIDw9IHpvb21Eb21haW5bMV0gfHwgeERvbWFpblsxXSA8PSAoem9vbURvbWFpblsxXSAtIGRlbHRhKSk7XHJcblxyXG5cdFx0XHQvLyBjaGVjayBpZiB0aGUgem9vbWVkIGNoYXJ0IGlzIGZ1bGx5IHNob3duLCB0aGVuIHJlc2V0IHNjYWxlIHdoZW4gem9vbSBpcyBvdXQgYXMgaW5pdGlhbFxyXG5cdFx0XHRpZiAoZm9yY2UgfHwgaXNmdWxseVNob3duKSB7XHJcblx0XHRcdFx0JCQuYXhpcy54LnNjYWxlKHN1YlgpO1xyXG5cdFx0XHRcdHguZG9tYWluKHN1Ylgub3JnRG9tYWluKCkpO1xyXG5cdFx0XHRcdCQkLnNjYWxlLnpvb20gPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQXR0YWNoIHpvb20gZXZlbnQgb24gPHJlY3Q+XHJcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGV2ZW50UmVjdHMgZXZlbXQgPHJlY3Q+IGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSB6b29tIHR5cGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRab29tT25FdmVudFJlY3QoZXZlbnRSZWN0cywgdHlwZTogXCJkcmFnXCIgfCBcIndoZWVsXCIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGJlaGF2aW91ciA9IHR5cGUgPT09IFwiZHJhZ1wiID8gJCQuem9vbUJlaGF2aW91ciA6ICQkLnpvb207XHJcblxyXG5cdFx0ZXZlbnRSZWN0c1xyXG5cdFx0XHQuY2FsbChiZWhhdmlvdXIpXHJcblx0XHRcdC5vbihcImRibGNsaWNrLnpvb21cIiwgbnVsbCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgZHJhZyBiZWhhdmlvdXIgdXNlZCBmb3Igem9vbWluZy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRab29tQmVoYXZpb3VyKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IHN0YXJ0ID0gMDtcclxuXHRcdGxldCBlbmQgPSAwO1xyXG5cdFx0bGV0IHpvb21SZWN0O1xyXG5cclxuXHRcdGNvbnN0IHByb3AgPSB7XHJcblx0XHRcdGF4aXM6IGlzUm90YXRlZCA/IFwieVwiIDogXCJ4XCIsXHJcblx0XHRcdGF0dHI6IGlzUm90YXRlZCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCIsXHJcblx0XHRcdGluZGV4OiBpc1JvdGF0ZWQgPyAxIDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHQkJC56b29tQmVoYXZpb3VyID0gZDNEcmFnKClcclxuXHRcdFx0LmNsaWNrRGlzdGFuY2UoNClcclxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JCQuc2V0RHJhZ1N0YXR1cyh0cnVlKTtcclxuXHJcblx0XHRcdFx0aWYgKCF6b29tUmVjdCkge1xyXG5cdFx0XHRcdFx0em9vbVJlY3QgPSAkJC4kZWwubWFpbi5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIHN0YXRlLmNsaXAucGF0aClcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy56b29tQnJ1c2gpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiAwKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCBpc1JvdGF0ZWQgPyAwIDogc3RhdGUuaGVpZ2h0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRzdGFydCA9IGQzTW91c2UodGhpcylbcHJvcC5pbmRleF07XHJcblx0XHRcdFx0ZW5kID0gc3RhcnQ7XHJcblxyXG5cdFx0XHRcdHpvb21SZWN0XHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIHN0YXJ0KVxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCAwKTtcclxuXHJcblx0XHRcdFx0JCQub25ab29tU3RhcnQoKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm9uKFwiZHJhZ1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0ZW5kID0gZDNNb3VzZSh0aGlzKVtwcm9wLmluZGV4XTtcclxuXHJcblx0XHRcdFx0em9vbVJlY3RcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXhpcywgTWF0aC5taW4oc3RhcnQsIGVuZCkpXHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF0dHIsIE1hdGguYWJzKGVuZCAtIHN0YXJ0KSk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlLnpvb20gfHwgJCQuc2NhbGUueDtcclxuXHJcblx0XHRcdFx0JCQuc2V0RHJhZ1N0YXR1cyhmYWxzZSk7XHJcblxyXG5cdFx0XHRcdHpvb21SZWN0XHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIDApXHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF0dHIsIDApO1xyXG5cclxuXHRcdFx0XHRpZiAoc3RhcnQgPiBlbmQpIHtcclxuXHRcdFx0XHRcdFtzdGFydCwgZW5kXSA9IFtlbmQsIHN0YXJ0XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChzdGFydCA8IDApIHtcclxuXHRcdFx0XHRcdGVuZCArPSBNYXRoLmFicyhzdGFydCk7XHJcblx0XHRcdFx0XHRzdGFydCA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoc3RhcnQgIT09IGVuZCkge1xyXG5cdFx0XHRcdFx0JCQuYXBpLnpvb20oW3N0YXJ0LCBlbmRdLm1hcCh2ID0+IHNjYWxlLmludmVydCh2KSkpO1xyXG5cdFx0XHRcdFx0JCQub25ab29tRW5kKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICgkJC5pc011bHRpcGxlWCgpKSB7XHJcblx0XHRcdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMuYmluZCh0aGlzKSgkJCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQuc291cmNlRXZlbnQgfHwgZDNFdmVudDtcclxuXHRcdFx0XHRcdFx0Y29uc3QgW3gsIHldID0gXCJjbGllbnRYXCIgaW4gZXZlbnQgPyBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV0gOiBbZXZlbnQueCwgZXZlbnQueV07XHJcblx0XHRcdFx0XHRcdGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XHJcblxyXG5cdFx0XHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JTaW5nbGVYLmJpbmQodGFyZ2V0KShkM1NlbGVjdCh0YXJnZXQpLmRhdHVtKCksICQkKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHNldFpvb21SZXNldEJ1dHRvbigpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCByZXNldEJ1dHRvbiA9IGNvbmZpZy56b29tX3Jlc2V0QnV0dG9uO1xyXG5cclxuXHRcdGlmIChyZXNldEJ1dHRvbiAmJiBjb25maWcuem9vbV9lbmFibGVkLnR5cGUgPT09IFwiZHJhZ1wiKSB7XHJcblx0XHRcdGlmICghJCQuem9vbS5yZXNldEJ0bikge1xyXG5cdFx0XHRcdCQkLnpvb20ucmVzZXRCdG4gPSAkJC4kZWwuY2hhcnQuYXBwZW5kKFwiZGl2XCIpXHJcblx0XHRcdFx0XHQuY2xhc3NlZChDTEFTUy5idXR0b24sIHRydWUpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwic3BhblwiKVxyXG5cdFx0XHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGlzRnVuY3Rpb24ocmVzZXRCdXR0b24ub25jbGljaykgJiYgcmVzZXRCdXR0b24ub25jbGljay5iaW5kKCQkLmFwaSkodGhpcyk7XHJcblx0XHRcdFx0XHRcdCQkLmFwaS51bnpvb20oKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQuY2xhc3NlZChDTEFTUy5idXR0b25ab29tUmVzZXQsIHRydWUpXHJcblx0XHRcdFx0XHQudGV4dChyZXNldEJ1dHRvbi50ZXh0IHx8IFwiUmVzZXQgWm9vbVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQkJC56b29tLnJlc2V0QnRuLnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRDbGlwKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NsaXB9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2xpcElkIG5lZWRzIHRvIGJlIHVuaXF1ZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBleGlzdFxyXG5cdFx0Y2xpcC5pZCA9IGAkeyQkLnN0YXRlLmRhdGV0aW1lSWR9LWNsaXBgO1xyXG5cdFx0Y2xpcC5pZFhBeGlzID0gYCR7Y2xpcC5pZH0teGF4aXNgO1xyXG5cdFx0Y2xpcC5pZFlBeGlzID0gYCR7Y2xpcC5pZH0teWF4aXNgO1xyXG5cdFx0Y2xpcC5pZEdyaWQgPSBgJHtjbGlwLmlkfS1ncmlkYDtcclxuXHJcblx0XHQvLyBEZWZpbmUgJ2NsaXAtcGF0aCcgYXR0cmlidXRlIHZhbHVlc1xyXG5cdFx0Y2xpcC5wYXRoID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcC5pZCk7XHJcblx0XHRjbGlwLnBhdGhYQXhpcyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRYQXhpcyk7XHJcblx0XHRjbGlwLnBhdGhZQXhpcyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRZQXhpcyk7XHJcblx0XHRjbGlwLnBhdGhHcmlkID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcC5pZEdyaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldENsaXBQYXRoKGlkOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCghY29uZmlnLmNsaXBQYXRoICYmIC8tY2xpcCQvLnRlc3QoaWQpKSB8fFxyXG5cdFx0XHQoIWNvbmZpZy5heGlzX3hfY2xpcFBhdGggJiYgLy1jbGlwLXhheGlzJC8udGVzdChpZCkpIHx8XHJcblx0XHRcdCghY29uZmlnLmF4aXNfeV9jbGlwUGF0aCAmJiAvLWNsaXAteWF4aXMkLy50ZXN0KGlkKSkpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaXNJRTkgPSB3aW5kb3cubmF2aWdhdG9yID9cclxuXHRcdFx0d2luZG93Lm5hdmlnYXRvci5hcHBWZXJzaW9uXHJcblx0XHRcdFx0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcIm1zaWUgOS5cIikgPj0gMCA6IGZhbHNlO1xyXG5cclxuXHRcdHJldHVybiBgdXJsKCR7KGlzSUU5ID8gXCJcIiA6IGRvY3VtZW50LlVSTC5zcGxpdChcIiNcIilbMF0pfSMke2lkfSlgO1xyXG5cdH0sXHJcblxyXG5cdGFwcGVuZENsaXAocGFyZW50LCBpZDogc3RyaW5nKTogdm9pZCB7XHJcblx0XHRpZCAmJiBwYXJlbnQuYXBwZW5kKFwiY2xpcFBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJpZFwiLCBpZClcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBYKGZvckhvcml6b250YWw/OiBib29sZWFuKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IHttYXJnaW59ID0gdGhpcy5zdGF0ZTtcclxuXHRcdC8vIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnRcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID8gLSgxICsgbGVmdCkgOiAtKGxlZnQgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcFkoZm9ySG9yaXpvbnRhbD86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3Qge21hcmdpbn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID8gLTIwIDogLW1hcmdpbi50b3A7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwWCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcFkoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBZKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZQXhpc0NsaXBYKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5heGlzX3lfaW5uZXIgP1xyXG5cdFx0XHQtMSA6ICQkLmdldEF4aXNDbGlwWCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZQXhpc0NsaXBZKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwWSgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcFdpZHRoKGZvckhvcml6b250YWw/OiBib29sZWFuKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYXJnaW4sIHdpZHRofSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgbGVmdCA9IE1hdGgubWF4KDMwLCBtYXJnaW4ubGVmdCk7XHJcblx0XHRjb25zdCByaWdodCA9IE1hdGgubWF4KDMwLCBtYXJnaW4ucmlnaHQpO1xyXG5cclxuXHRcdC8vIHdpZHRoICsgYXhpcyBsaW5lIHdpZHRoICsgcGFkZGluZyBmb3IgbGVmdC9yaWdodFxyXG5cdFx0cmV0dXJuIGZvckhvcml6b250YWwgP1xyXG5cdFx0XHR3aWR0aCArIDIgKyBsZWZ0ICsgcmlnaHQgOiBtYXJnaW4ubGVmdCArIDIwO1xyXG5cdH0sXHJcblxyXG5cdGdldEF4aXNDbGlwSGVpZ2h0KGZvckhvcml6b250YWw/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCB7bWFyZ2luLCBoZWlnaHR9ID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHQvLyBsZXNzIHRoYW4gMjAgaXMgbm90IGVub3VnaCB0byBzaG93IHRoZSBheGlzIGxhYmVsICdvdXRlcicgd2l0aG91dCBsZWdlbmRcclxuXHRcdHJldHVybiAoZm9ySG9yaXpvbnRhbCA/IG1hcmdpbi5ib3R0b20gOiAobWFyZ2luLnRvcCArIGhlaWdodCkpICsgMjA7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwV2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBXaWR0aCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwSGVpZ2h0KCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwSGVpZ2h0KCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZQXhpc0NsaXBXaWR0aCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFdpZHRoKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpICsgKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAyMCA6IDApO1xyXG5cdH0sXHJcblxyXG5cdGdldFlBeGlzQ2xpcEhlaWdodCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVYQXhpc1RpY2tDbGlwKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NsaXAsIHhBeGlzSGVpZ2h0fSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgbmV3WEF4aXNIZWlnaHQgPSAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInhcIik7XHJcblxyXG5cdFx0Y2xpcC5pZFhBeGlzVGlja1RleHRzID0gYCR7Y2xpcC5pZH0teGF4aXN0aWNrdGV4dHNgO1xyXG5cdFx0Y2xpcC5wYXRoWEF4aXNUaWNrVGV4dHMgPSAkJC5nZXRDbGlwUGF0aChjbGlwLmlkWEF4aXNUaWNrVGV4dHMpO1xyXG5cclxuXHRcdGlmICghJCQuY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSAmJlxyXG5cdFx0XHQkJC5nZXRBeGlzVGlja1JvdGF0ZShcInhcIikgJiZcclxuXHRcdFx0bmV3WEF4aXNIZWlnaHQgIT09IHhBeGlzSGVpZ2h0XHJcblx0XHQpIHtcclxuXHRcdFx0JCQuc2V0WEF4aXNUaWNrQ2xpcFdpZHRoKCk7XHJcblx0XHRcdCQkLnNldFhBeGlzVGlja1RleHRDbGlwUGF0aFdpZHRoKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuc3RhdGUueEF4aXNIZWlnaHQgPSBuZXdYQXhpc0hlaWdodDtcclxuXHR9LFxyXG5cclxuXHRzZXRYQXhpc1RpY2tDbGlwV2lkdGgoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2N1cnJlbnQ6IHttYXhUaWNrV2lkdGhzfX19ID0gJCQ7XHJcblxyXG5cdFx0Y29uc3QgeEF4aXNUaWNrUm90YXRlID0gJCQuZ2V0QXhpc1RpY2tSb3RhdGUoXCJ4XCIpO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSAmJiB4QXhpc1RpY2tSb3RhdGUpIHtcclxuXHRcdFx0Y29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihNYXRoLlBJIC8gMTgwICogTWF0aC5hYnMoeEF4aXNUaWNrUm90YXRlKSk7XHJcblxyXG5cdFx0XHRtYXhUaWNrV2lkdGhzLnguY2xpcFBhdGggPSAoJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ4XCIpIC0gMjApIC8gc2luUm90YXRpb247XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtYXhUaWNrV2lkdGhzLnguY2xpcFBhdGggPSBudWxsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHNldFhBeGlzVGlja1RleHRDbGlwUGF0aFdpZHRoKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7Y2xpcCwgY3VycmVudH0sICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRzdmcuc2VsZWN0KGAjJHtjbGlwLmlkWEF4aXNUaWNrVGV4dHN9IHJlY3RgKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgY3VycmVudC5tYXhUaWNrV2lkdGhzLnguY2xpcFBhdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgMzApO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRzZWxlY3RBbGwgYXMgZDNTZWxlY3RBbGxcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtpc0FycmF5LCBpc1ZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8vIEdyaWQgcG9zaXRpb24gYW5kIHRleHQgYW5jaG9yIGhlbHBlcnNcclxuY29uc3QgZ2V0R3JpZFRleHRBbmNob3IgPSBkID0+IGlzVmFsdWUoZC5wb3NpdGlvbikgfHwgXCJlbmRcIjtcclxuY29uc3QgZ2V0R3JpZFRleHREeCA9IGQgPT4gKGQucG9zaXRpb24gPT09IFwic3RhcnRcIiA/IDQgOiAoZC5wb3NpdGlvbiA9PT0gXCJtaWRkbGVcIiA/IDAgOiAtNCkpO1xyXG5cclxuLyoqXHJcbiAqIEdldCBncmlkIHRleHQgeCB2YWx1ZSBnZXR0ZXIgZnVuY3Rpb25cclxuICogQHBhcmFtIHtib29sZWFufSBpc1ggSXMgeCBBeGlzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCB2YWx1ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IEhlaWdodCB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRHcmlkVGV4dFgoaXNYLCB3aWR0aCwgaGVpZ2h0KTogRnVuY3Rpb24ge1xyXG5cdHJldHVybiBkID0+IHtcclxuXHRcdGxldCB4ID0gaXNYID8gMCA6IHdpZHRoO1xyXG5cclxuXHRcdGlmIChkLnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcclxuXHRcdFx0eCA9IGlzWCA/IC1oZWlnaHQgOiAwO1xyXG5cdFx0fSBlbHNlIGlmIChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiKSB7XHJcblx0XHRcdHggPSAoaXNYID8gLWhlaWdodCA6IHdpZHRoKSAvIDI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSBjb29yZGluYXRlIGF0dHJpYnV0ZXMgdmFsdWVcclxuICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGVsIFRhcmdldCBub2RlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNtb290aExpbmVzKGVsLCB0eXBlOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRpZiAodHlwZSA9PT0gXCJncmlkXCIpIHtcclxuXHRcdGVsLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnN0IGcgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHJcblx0XHRcdFtcIngxXCIsIFwieDJcIiwgXCJ5MVwiLCBcInkyXCJdXHJcblx0XHRcdFx0LmZvckVhY2godiA9PiBnLmF0dHIodiwgTWF0aC5jZWlsKCtnLmF0dHIodikpKSk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRoYXNHcmlkKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBbXCJ4XCIsIFwieVwiXVxyXG5cdFx0XHQuc29tZSh2ID0+IGNvbmZpZ1tgZ3JpZF8ke3Z9X3Nob3dgXSB8fCBjb25maWdbYGdyaWRfJHt2fV9saW5lc2BdLmxlbmd0aCk7XHJcblx0fSxcclxuXHJcblx0aW5pdEdyaWQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuaGFzR3JpZCgpICYmICQkLmluaXRHcmlkTGluZXMoKTtcclxuXHRcdCQkLmluaXRGb2N1c0dyaWQoKTtcclxuXHR9LFxyXG5cclxuXHRpbml0R3JpZExpbmVzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjbGlwfSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcuZ3JpZF94X2xpbmVzLmxlbmd0aCB8fCBjb25maWcuZ3JpZF95X2xpbmVzLmxlbmd0aCkge1xyXG5cdFx0XHQkZWwuZ3JpZExpbmVzLm1haW4gPSAkZWwubWFpbi5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5jaGFydH0ke2NvbmZpZy5ncmlkX2xpbmVzX2Zyb250ID8gXCIgKyAqXCIgOiBcIlwifWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcC5wYXRoR3JpZClcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGAke0NMQVNTLmdyaWR9ICR7Q0xBU1MuZ3JpZExpbmVzfWApO1xyXG5cclxuXHRcdFx0JGVsLmdyaWRMaW5lcy5tYWluLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkTGluZXMpO1xyXG5cdFx0XHQkZWwuZ3JpZExpbmVzLm1haW4uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWRMaW5lcyk7XHJcblxyXG5cdFx0XHQkZWwuZ3JpZExpbmVzLnggPSBkM1NlbGVjdEFsbChbXSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWEdyaWQod2l0aG91dFVwZGF0ZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGUsIHN0YXRlLCAkZWw6IHttYWluLCBncmlkfX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCB4Z3JpZERhdGEgPSAkJC5nZW5lcmF0ZUdyaWREYXRhKGNvbmZpZy5ncmlkX3hfdHlwZSwgc2NhbGUueCk7XHJcblx0XHRjb25zdCB0aWNrT2Zmc2V0ID0gJCQuYXhpcy5pc0NhdGVnb3JpemVkKCkgPyAkJC5heGlzLngudGlja09mZnNldCgpIDogMDtcclxuXHRcdGNvbnN0IHBvcyA9IGQgPT4gKChzY2FsZS56b29tIHx8IHNjYWxlLngpKGQpICsgdGlja09mZnNldCkgKiAoaXNSb3RhdGVkID8gLTEgOiAxKTtcclxuXHJcblx0XHRzdGF0ZS54Z3JpZEF0dHIgPSBpc1JvdGF0ZWQgPyB7XHJcblx0XHRcdFwieDFcIjogMCxcclxuXHRcdFx0XCJ4MlwiOiBzdGF0ZS53aWR0aCxcclxuXHRcdFx0XCJ5MVwiOiBwb3MsXHJcblx0XHRcdFwieTJcIjogcG9zLFxyXG5cdFx0fSA6IHtcclxuXHRcdFx0XCJ4MVwiOiBwb3MsXHJcblx0XHRcdFwieDJcIjogcG9zLFxyXG5cdFx0XHRcInkxXCI6IDAsXHJcblx0XHRcdFwieTJcIjogc3RhdGUuaGVpZ2h0LFxyXG5cdFx0fTtcclxuXHJcblx0XHRncmlkLnggPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueGdyaWRzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnhncmlkfWApXHJcblx0XHRcdC5kYXRhKHhncmlkRGF0YSk7XHJcblxyXG5cdFx0Z3JpZC54LmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRncmlkLnggPSBncmlkLnguZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkKVxyXG5cdFx0XHQubWVyZ2UoZ3JpZC54KTtcclxuXHJcblx0XHRpZiAoIXdpdGhvdXRVcGRhdGUpIHtcclxuXHRcdFx0Z3JpZC54LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgZ3JpZCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRPYmplY3Qua2V5cyhzdGF0ZS54Z3JpZEF0dHIpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRcdFx0Z3JpZC5hdHRyKGlkLCBzdGF0ZS54Z3JpZEF0dHJbaWRdKVxyXG5cdFx0XHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICgpID0+IChcclxuXHRcdFx0XHRcdFx0XHRncmlkLmF0dHIoaXNSb3RhdGVkID8gXCJ5MVwiIDogXCJ4MVwiKSA9PT0gKGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCA6IDApID9cclxuXHRcdFx0XHRcdFx0XHRcdFwiMFwiIDogXCIxXCJcclxuXHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVlHcmlkKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge2dyaWQsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGdyaWRWYWx1ZXMgPSAkJC5heGlzLnkudGlja1ZhbHVlcygpIHx8ICQkLnNjYWxlLnkudGlja3MoY29uZmlnLmdyaWRfeV90aWNrcyk7XHJcblx0XHRjb25zdCBwb3MgPSBkID0+IE1hdGguY2VpbCgkJC5zY2FsZS55KGQpKTtcclxuXHJcblx0XHRncmlkLnkgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnlncmlkfWApXHJcblx0XHRcdC5kYXRhKGdyaWRWYWx1ZXMpO1xyXG5cclxuXHRcdGdyaWQueS5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Z3JpZC55ID0gZ3JpZC55XHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWQpXHJcblx0XHRcdC5tZXJnZShncmlkLnkpO1xyXG5cclxuXHRcdGdyaWQueS5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gcG9zIDogMClcclxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyBwb3MgOiBzdGF0ZS53aWR0aClcclxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCA6IHBvcyk7XHJcblxyXG5cdFx0c21vb3RoTGluZXMoZ3JpZC55LCBcImdyaWRcIik7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlR3JpZChkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbDoge2dyaWQsIGdyaWRMaW5lc319ID0gJCQ7XHJcblxyXG5cdFx0IWdyaWRMaW5lcy5tYWluICYmICQkLmluaXRHcmlkTGluZXMoKTtcclxuXHJcblx0XHQvLyBoaWRlIGlmIGFyYyB0eXBlXHJcblx0XHRncmlkLm1haW4uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsICQkLmhhc0FyY1R5cGUoKSA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIik7XHJcblxyXG5cdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cdFx0JCQudXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbik7XHJcblx0XHQkJC51cGRhdGVZR3JpZExpbmVzKGR1cmF0aW9uKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgWCBHcmlkIGxpbmVzXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIERyYXRpb24gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVhHcmlkTGluZXMoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7Z3JpZExpbmVzLCBtYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uZmlnLmdyaWRfeF9zaG93ICYmICQkLnVwZGF0ZVhHcmlkKCk7XHJcblxyXG5cdFx0bGV0IHhMaW5lcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy54Z3JpZExpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnhncmlkTGluZX1gKVxyXG5cdFx0XHQuZGF0YShjb25maWcuZ3JpZF94X2xpbmVzKTtcclxuXHJcblx0XHQvLyBleGl0XHJcblx0XHR4TGluZXMuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQvLyBlbnRlclxyXG5cdFx0Y29uc3QgeGdyaWRMaW5lID0geExpbmVzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHR4Z3JpZExpbmUuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHR4Z3JpZExpbmUuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBpc1JvdGF0ZWQgPyBcIlwiIDogXCJyb3RhdGUoLTkwKVwiKVxyXG5cdFx0XHQuYXR0cihcImR5XCIsIC01KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHR4TGluZXMgPSB4Z3JpZExpbmUubWVyZ2UoeExpbmVzKTtcclxuXHJcblx0XHR4TGluZXNcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAke0NMQVNTLnhncmlkTGluZX0gJHtkLmNsYXNzIHx8IFwiXCJ9YC50cmltKCkpXHJcblx0XHRcdC5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgZ2V0R3JpZFRleHRBbmNob3IpXHJcblx0XHRcdC5hdHRyKFwiZHhcIiwgZ2V0R3JpZFRleHREeClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC50ZXh0KGQgPT4gZC50ZXh0KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cclxuXHRcdGdyaWRMaW5lcy54ID0geExpbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBZIEdyaWQgbGluZXNcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHVyYXRpb24gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aWR0aCwgaGVpZ2h0fSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRjb25maWcuZ3JpZF95X3Nob3cgJiYgJCQudXBkYXRlWUdyaWQoKTtcclxuXHJcblx0XHRsZXQgeWdyaWRMaW5lcyA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRMaW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy55Z3JpZExpbmV9YClcclxuXHRcdFx0LmRhdGEoY29uZmlnLmdyaWRfeV9saW5lcyk7XHJcblxyXG5cdFx0Ly8gZXhpdFxyXG5cdFx0eWdyaWRMaW5lcy5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQvLyBlbnRlclxyXG5cdFx0Y29uc3QgeWdyaWRMaW5lID0geWdyaWRMaW5lcy5lbnRlcigpLmFwcGVuZChcImdcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lLmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJyb3RhdGUoLTkwKVwiIDogXCJcIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lcyA9IHlncmlkTGluZS5tZXJnZSh5Z3JpZExpbmVzKTtcclxuXHJcblx0XHQvLyB1cGRhdGVcclxuXHRcdGNvbnN0IHl2ID0gJCQueXYuYmluZCgkJCk7XHJcblxyXG5cdFx0eWdyaWRMaW5lc1xyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueWdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcclxuXHRcdFx0LnNlbGVjdChcImxpbmVcIilcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8geXYgOiAwKVxyXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHl2IDogd2lkdGgpXHJcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8gMCA6IHl2KVxyXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IGhlaWdodCA6IHl2KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cclxuXHRcdHlncmlkTGluZXMuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIGdldEdyaWRUZXh0QW5jaG9yKVxyXG5cdFx0XHQuYXR0cihcImR4XCIsIGdldEdyaWRUZXh0RHgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQuYXR0cihcImR5XCIsIC01KVxyXG5cdFx0XHQuYXR0cihcInhcIiwgZ2V0R3JpZFRleHRYKGlzUm90YXRlZCwgd2lkdGgsIGhlaWdodCkpXHJcblx0XHRcdC5hdHRyKFwieVwiLCB5dilcclxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0JGVsLmdyaWRMaW5lcy55ID0geWdyaWRMaW5lcztcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdHcmlkKHdpdGhUcmFuc2l0aW9uOiBib29sZWFuKTogYW55W10ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRjb25maWc6IHtheGlzX3JvdGF0ZWQ6IGlzUm90YXRlZH0sXHJcblx0XHRcdHN0YXRlOiB7d2lkdGgsIGhlaWdodH0sXHJcblx0XHRcdCRlbDoge2dyaWRMaW5lc31cclxuXHRcdH0gPSAkJDtcclxuXHRcdGNvbnN0IHh2ID0gJCQueHYuYmluZCgkJCk7XHJcblxyXG5cdFx0bGV0IGxpbmVzID0gZ3JpZExpbmVzLnguc2VsZWN0KFwibGluZVwiKTtcclxuXHRcdGxldCB0ZXh0cyA9IGdyaWRMaW5lcy54LnNlbGVjdChcInRleHRcIik7XHJcblxyXG5cdFx0bGluZXMgPSAod2l0aFRyYW5zaXRpb24gPyBsaW5lcy50cmFuc2l0aW9uKCkgOiBsaW5lcylcclxuXHRcdFx0LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyAwIDogeHYpXHJcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gd2lkdGggOiB4dilcclxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyB4diA6IDApXHJcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8geHYgOiBoZWlnaHQpO1xyXG5cclxuXHRcdHRleHRzID0gKHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBnZXRHcmlkVGV4dFgoIWlzUm90YXRlZCwgd2lkdGgsIGhlaWdodCkpXHJcblx0XHRcdC5hdHRyKFwieVwiLCB4dilcclxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxpbmVzLnRyYW5zaXRpb24oKSA6IGxpbmVzKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpLFxyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0ZXh0cy50cmFuc2l0aW9uKCkgOiB0ZXh0cykuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHRpbml0Rm9jdXNHcmlkKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjbGlwfSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNGcm9udCA9IGNvbmZpZy5ncmlkX2Zyb250O1xyXG5cdFx0Y29uc3QgY2xhc3NOYW1lID0gYC4ke0NMQVNTW2lzRnJvbnQgJiYgJGVsLmdyaWRMaW5lcy5tYWluID8gXCJncmlkTGluZXNcIiA6IFwiY2hhcnRcIl19JHtpc0Zyb250ID8gXCIgKyAqXCIgOiBcIlwifWA7XHJcblxyXG5cdFx0Y29uc3QgZ3JpZCA9ICRlbC5tYWluLmluc2VydChcImdcIiwgY2xhc3NOYW1lKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwLnBhdGhHcmlkKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmdyaWQpO1xyXG5cclxuXHRcdCRlbC5ncmlkLm1haW4gPSBncmlkO1xyXG5cclxuXHRcdGNvbmZpZy5ncmlkX3hfc2hvdyAmJlxyXG5cdFx0XHRncmlkLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkcyk7XHJcblxyXG5cdFx0Y29uZmlnLmdyaWRfeV9zaG93ICYmXHJcblx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWRzKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmdyaWRfZm9jdXNfc2hvdykge1xyXG5cdFx0XHRncmlkLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkRm9jdXMpXHJcblx0XHRcdFx0LmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkRm9jdXMpO1xyXG5cclxuXHRcdFx0Ly8gdG8gc2hvdyB4eSBmb2N1cyBncmlkIGxpbmUsIHNob3VsZCBiZSAndG9vbHRpcC5ncm91cGVkPWZhbHNlJ1xyXG5cdFx0XHRpZiAoY29uZmlnLmdyaWRfZm9jdXNfeSAmJiAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xyXG5cdFx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZEZvY3VzKVxyXG5cdFx0XHRcdFx0LmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWRGb2N1cyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IGdyaWQgZm9jdXMgbGluZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgU2VsZWN0ZWQgZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2hvd0dyaWRGb2N1cyhkYXRhPyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aWR0aCwgaGVpZ2h0fX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBmb2N1c0VsID0gJCQuJGVsLm1haW4uc2VsZWN0QWxsKGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c30sIGxpbmUuJHtDTEFTUy55Z3JpZEZvY3VzfWApO1xyXG5cclxuXHRcdGNvbnN0IGRhdGFUb1Nob3cgPSAoZGF0YSB8fCBbZm9jdXNFbC5kYXR1bSgpXSkuZmlsdGVyKGQgPT4gZCAmJiBpc1ZhbHVlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cclxuXHRcdC8vIEhpZGUgd2hlbiBidWJibGUvc2NhdHRlci9zdGFuZm9yZCBwbG90IGV4aXN0c1xyXG5cdFx0aWYgKCFjb25maWcudG9vbHRpcF9zaG93IHx8IGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc0VkZ2UgPSBjb25maWcuZ3JpZF9mb2N1c19lZGdlICYmICFjb25maWcudG9vbHRpcF9ncm91cGVkO1xyXG5cdFx0Y29uc3QgeHggPSAkJC54eC5iaW5kKCQkKTtcclxuXHJcblx0XHRmb2N1c0VsXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXHJcblx0XHRcdC5kYXRhKGRhdGFUb1Nob3cuY29uY2F0KGRhdGFUb1Nob3cpKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3QgZWwgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBwb3MgPSB7XHJcblx0XHRcdFx0XHR4OiB4eChkKSxcclxuXHRcdFx0XHRcdHk6ICQkLmdldFlTY2FsZUJ5SWQoZC5pZCkoZC52YWx1ZSlcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdGxldCB4eTtcclxuXHJcblx0XHRcdFx0aWYgKGVsLmNsYXNzZWQoQ0xBU1MueGdyaWRGb2N1cykpIHtcclxuXHRcdFx0XHRcdC8vIHdpbGwgY29udGFpbiAneDEsIHkxLCB4MiwgeTInIG9yZGVyXHJcblx0XHRcdFx0XHR4eSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRcdFtcclxuXHRcdFx0XHRcdFx0XHRudWxsLCAvLyB4MVxyXG5cdFx0XHRcdFx0XHRcdHBvcy54LCAvLyB5MVxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSA/IHBvcy55IDogd2lkdGgsIC8vIHgyXHJcblx0XHRcdFx0XHRcdFx0cG9zLnggLy8geTJcclxuXHRcdFx0XHRcdFx0XSA6IFtcclxuXHRcdFx0XHRcdFx0XHRwb3MueCxcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgPyBwb3MueSA6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0cG9zLngsXHJcblx0XHRcdFx0XHRcdFx0aGVpZ2h0XHJcblx0XHRcdFx0XHRcdF07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IGlzWTIgPSAkJC5heGlzLmdldElkKGQuaWQpID09PSBcInkyXCI7XHJcblxyXG5cdFx0XHRcdFx0eHkgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFx0XHRbXHJcblx0XHRcdFx0XHRcdFx0cG9zLnksIC8vIHgxXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlICYmICFpc1kyID8gcG9zLnggOiBudWxsLCAvLyB5MVxyXG5cdFx0XHRcdFx0XHRcdHBvcy55LCAvLyB4MlxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSAmJiBpc1kyID8gcG9zLnggOiBoZWlnaHQgLy8geTJcclxuXHRcdFx0XHRcdFx0XSA6IFtcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgJiYgaXNZMiA/IHBvcy54IDogbnVsbCxcclxuXHRcdFx0XHRcdFx0XHRwb3MueSxcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgJiYgIWlzWTIgPyBwb3MueCA6IHdpZHRoLFxyXG5cdFx0XHRcdFx0XHRcdHBvcy55XHJcblx0XHRcdFx0XHRcdF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRbXCJ4MVwiLCBcInkxXCIsIFwieDJcIiwgXCJ5MlwiXVxyXG5cdFx0XHRcdFx0LmZvckVhY2goKHYsIGkpID0+IGVsLmF0dHIodiwgeHlbaV0pKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0c21vb3RoTGluZXMoZm9jdXNFbCwgXCJncmlkXCIpO1xyXG5cdFx0JCQuc2hvd0NpcmNsZUZvY3VzKGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdGhpZGVHcmlkRm9jdXMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHtpbnB1dFR5cGV9LCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoaW5wdXRUeXBlID09PSBcIm1vdXNlXCIpIHtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfSwgbGluZS4ke0NMQVNTLnlncmlkRm9jdXN9YClcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG5cclxuXHRcdFx0JCQuaGlkZUNpcmNsZUZvY3VzKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlR3JpZEZvY3VzKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7aW5wdXRUeXBlLCB3aWR0aCwgaGVpZ2h0LCByZXNpemluZ30sICRlbDoge2dyaWR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgeGdyaWRGb2N1cyA9IGdyaWQubWFpbi5zZWxlY3QoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfWApO1xyXG5cclxuXHRcdGlmIChpbnB1dFR5cGUgPT09IFwidG91Y2hcIikge1xyXG5cdFx0XHRpZiAoeGdyaWRGb2N1cy5lbXB0eSgpKSB7XHJcblx0XHRcdFx0cmVzaXppbmcgJiYgJCQuc2hvd0NpcmNsZUZvY3VzKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JCQuc2hvd0dyaWRGb2N1cygpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdFx0eGdyaWRGb2N1c1xyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IC0xMClcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHdpZHRoIDogLTEwKVxyXG5cdFx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8gLTEwIDogMClcclxuXHRcdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IC0xMCA6IGhlaWdodCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbmVlZCB0byByZXR1cm4gJ3RydWUnIGFzIG9mIGJlaW5nIHB1c2hlZCB0byB0aGUgcmVkcmF3IGxpc3RcclxuXHRcdC8vIHJlZjogZ2V0UmVkcmF3TGlzdCgpXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdyaWREYXRhKHR5cGU6IHN0cmluZywgc2NhbGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHRpY2tOdW0gPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoXCIudGlja1wiKVxyXG5cdFx0XHQuc2l6ZSgpO1xyXG5cdFx0bGV0IGdyaWREYXRhOiBEYXRlW10gPSBbXTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gXCJ5ZWFyXCIpIHtcclxuXHRcdFx0Y29uc3QgeERvbWFpbiA9ICQkLmdldFhEb21haW4oKTtcclxuXHRcdFx0Y29uc3QgZmlyc3RZZWFyID0geERvbWFpblswXS5nZXRGdWxsWWVhcigpO1xyXG5cdFx0XHRjb25zdCBsYXN0WWVhciA9IHhEb21haW5bMV0uZ2V0RnVsbFllYXIoKTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSBmaXJzdFllYXI7IGkgPD0gbGFzdFllYXI7IGkrKykge1xyXG5cdFx0XHRcdGdyaWREYXRhLnB1c2gobmV3IERhdGUoYCR7aX0tMDEtMDEgMDA6MDA6MDBgKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGdyaWREYXRhID0gc2NhbGUudGlja3MoMTApO1xyXG5cclxuXHRcdFx0aWYgKGdyaWREYXRhLmxlbmd0aCA+IHRpY2tOdW0pIHsgLy8gdXNlIG9ubHkgaW50XHJcblx0XHRcdFx0Z3JpZERhdGEgPSBncmlkRGF0YS5maWx0ZXIoZCA9PiBTdHJpbmcoZCkuaW5kZXhPZihcIi5cIikgPCAwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBncmlkRGF0YTtcclxuXHR9LFxyXG5cclxuXHRnZXRHcmlkRmlsdGVyVG9SZW1vdmUocGFyYW1zKTogRnVuY3Rpb24ge1xyXG5cdFx0cmV0dXJuIHBhcmFtcyA/IGxpbmUgPT4ge1xyXG5cdFx0XHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0XHRcdChpc0FycmF5KHBhcmFtcykgPyBwYXJhbXMuY29uY2F0KCkgOiBbcGFyYW1zXSkuZm9yRWFjaChwYXJhbSA9PiB7XHJcblx0XHRcdFx0aWYgKCgoXCJ2YWx1ZVwiIGluIHBhcmFtICYmIGxpbmUudmFsdWUgPT09IHBhcmFtLnZhbHVlKSB8fCAoXCJjbGFzc1wiIGluIHBhcmFtICYmIGxpbmUuY2xhc3MgPT09IHBhcmFtLmNsYXNzKSkpIHtcclxuXHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZvdW5kO1xyXG5cdFx0fSA6ICgpID0+IHRydWU7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgZm9yWD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0b1JlbW92ZSA9ICQkLmdldEdyaWRGaWx0ZXJUb1JlbW92ZShwYXJhbXMpO1xyXG5cdFx0Y29uc3QgdG9TaG93ID0gbGluZSA9PiAhdG9SZW1vdmUobGluZSk7XHJcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gZm9yWCA/IENMQVNTLnhncmlkTGluZXMgOiBDTEFTUy55Z3JpZExpbmVzO1xyXG5cdFx0Y29uc3QgY2xhc3NMaW5lID0gZm9yWCA/IENMQVNTLnhncmlkTGluZSA6IENMQVNTLnlncmlkTGluZTtcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3QoYC4ke2NsYXNzTGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Y2xhc3NMaW5lfWApXHJcblx0XHRcdC5maWx0ZXIodG9SZW1vdmUpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0Y29uc3QgZ3JpZExpbmVzID0gYGdyaWRfJHtmb3JYID8gXCJ4XCIgOiBcInlcIn1fbGluZXNgO1xyXG5cclxuXHRcdGNvbmZpZ1tncmlkTGluZXNdID0gY29uZmlnW2dyaWRMaW5lc10uZmlsdGVyKHRvU2hvdyk7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiOyAvLyBzZWxlY3Rpb25cclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzVmFsdWUsIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7QXhpc1R5cGV9IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRSZWdpb24oKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cclxuXHRcdCRlbC5yZWdpb24ubWFpbiA9ICRlbC5tYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgJCQuc3RhdGUuY2xpcC5wYXRoKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnJlZ2lvbnMpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJlZ2lvbihkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCEkZWwucmVnaW9uLm1haW4pIHtcclxuXHRcdFx0JCQuaW5pdFJlZ2lvbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGhpZGUgaWYgYXJjIHR5cGVcclxuXHRcdCRlbC5yZWdpb24ubWFpbi5zdHlsZShcInZpc2liaWxpdHlcIiwgJCQuaGFzQXJjVHlwZSgpID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcclxuXHJcblx0XHQvLyBzZWxlY3QgPGc+IGVsZW1lbnRcclxuXHRcdGxldCBsaXN0ID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5yZWdpb25zfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnJlZ2lvbn1gKVxyXG5cdFx0XHQuZGF0YShjb25maWcucmVnaW9ucyk7XHJcblxyXG5cdFx0bGlzdC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRsaXN0ID0gbGlzdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5tZXJnZShsaXN0KVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzUmVnaW9uLmJpbmQoJCQpKTtcclxuXHJcblx0XHRsaXN0XHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIik7XHJcblxyXG5cdFx0JGVsLnJlZ2lvbi5saXN0ID0gbGlzdDtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdSZWdpb24od2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCByZWdpb25zID0gJCQuJGVsLnJlZ2lvbi5saXN0LnNlbGVjdChcInJlY3RcIik7XHJcblxyXG5cdFx0cmVnaW9ucyA9ICh3aXRoVHJhbnNpdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpIDogcmVnaW9ucylcclxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLnJlZ2lvblguYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwieVwiLCAkJC5yZWdpb25ZLmJpbmQoJCQpKVxyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLnJlZ2lvbldpZHRoLmJpbmQoJCQpKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5yZWdpb25IZWlnaHQuYmluZCgkJCkpO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpIDogcmVnaW9ucylcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgZCA9PiAoaXNWYWx1ZShkLm9wYWNpdHkpID8gZC5vcGFjaXR5IDogXCIwLjFcIikpXHJcblx0XHRcdFx0Lm9uKFwiZW5kXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IHJlY3QgYWZ0ZXIgdHJhbnNpdGlvblxyXG5cdFx0XHRcdFx0ZDNTZWxlY3QodGhpcy5wYXJlbnROb2RlKVxyXG5cdFx0XHRcdFx0XHQuc2VsZWN0QWxsKFwicmVjdDpub3QoW3hdKVwiKVxyXG5cdFx0XHRcdFx0XHQucmVtb3ZlKCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0Z2V0UmVnaW9uWFkodHlwZTogQXhpc1R5cGUsIGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaXNYID0gdHlwZSA9PT0gXCJ4XCI7XHJcblx0XHRsZXQga2V5ID0gXCJzdGFydFwiO1xyXG5cdFx0bGV0IGN1cnJTY2FsZTtcclxuXHRcdGxldCBwb3MgPSAwO1xyXG5cclxuXHRcdGlmIChkLmF4aXMgPT09IFwieVwiIHx8IGQuYXhpcyA9PT0gXCJ5MlwiKSB7XHJcblx0XHRcdGlmICghaXNYKSB7XHJcblx0XHRcdFx0a2V5ID0gXCJlbmRcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKChpc1ggPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRcdGN1cnJTY2FsZSA9IHNjYWxlW2QuYXhpc107XHJcblx0XHRcdFx0cG9zID0gY3VyclNjYWxlKGRba2V5XSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoKGlzWCA/ICFpc1JvdGF0ZWQgOiBpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XHJcblx0XHRcdGN1cnJTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHRcdFx0cG9zID0gY3VyclNjYWxlKCQkLmF4aXMuaXNUaW1lU2VyaWVzKCkgPyBwYXJzZURhdGUuY2FsbCgkJCwgZFtrZXldKSA6IGRba2V5XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvcztcclxuXHR9LFxyXG5cclxuXHRyZWdpb25YKGQpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uWFkoXCJ4XCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdHJlZ2lvblkoZCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25YWShcInlcIiwgZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0UmVnaW9uU2l6ZSh0eXBlLCBkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1dpZHRoID0gdHlwZSA9PT0gXCJ3aWR0aFwiO1xyXG5cdFx0Y29uc3Qgc3RhcnQgPSAkJFtpc1dpZHRoID8gXCJyZWdpb25YXCIgOiBcInJlZ2lvbllcIl0oZCk7XHJcblx0XHRsZXQgY3VyclNjYWxlO1xyXG5cdFx0bGV0IGtleSA9IFwiZW5kXCI7XHJcblx0XHRsZXQgZW5kID0gc3RhdGVbdHlwZV07XHJcblxyXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcclxuXHRcdFx0aWYgKCFpc1dpZHRoKSB7XHJcblx0XHRcdFx0a2V5ID0gXCJzdGFydFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoKGlzV2lkdGggPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRcdGN1cnJTY2FsZSA9IHNjYWxlW2QuYXhpc107XHJcblx0XHRcdFx0ZW5kID0gY3VyclNjYWxlKGRba2V5XSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoKGlzV2lkdGggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRjdXJyU2NhbGUgPSBzY2FsZS56b29tIHx8IHNjYWxlLng7XHJcblx0XHRcdGVuZCA9IGN1cnJTY2FsZSgkJC5heGlzLmlzVGltZVNlcmllcygpID8gcGFyc2VEYXRlLmNhbGwoJCQsIGRba2V5XSkgOiBkW2tleV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBlbmQgPCBzdGFydCA/IDAgOiBlbmQgLSBzdGFydDtcclxuXHR9LFxyXG5cclxuXHRyZWdpb25XaWR0aChkKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblNpemUoXCJ3aWR0aFwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRyZWdpb25IZWlnaHQoZCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25TaXplKFwiaGVpZ2h0XCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdGlzUmVnaW9uT25YKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiAhZC5heGlzIHx8IGQuYXhpcyA9PT0gXCJ4XCI7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge3JnYiBhcyBkM1JnYn0gZnJvbSBcImQzLWNvbG9yXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm59IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNlbGVjdCBhIHBvaW50XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgcG9pbnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIEluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2VsZWN0UG9pbnQodGFyZ2V0LCBkLCBpOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGN4ID0gKGlzUm90YXRlZCA/ICQkLmNpcmNsZVkgOiAkJC5jaXJjbGVYKS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGN5ID0gKGlzUm90YXRlZCA/ICQkLmNpcmNsZVggOiAkJC5jaXJjbGVZKS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IHIgPSAkJC5wb2ludFNlbGVjdFIuYmluZCgkJCk7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29uc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0Ly8gYWRkIHNlbGVjdGVkLWNpcmNsZSBvbiBsb3cgbGF5ZXIgZ1xyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcclxuXHRcdFx0LmRhdGEoW2RdKVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiY2lyY2xlXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKCkgPT4gJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zZWxlY3RlZENpcmNsZSwgaSkpXHJcblx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpXHJcblx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpXHJcblx0XHRcdC5hdHRyKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgZDIgPT4gJCQucG9pbnRTZWxlY3RSKGQyKSAqIDEuNClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgcik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5lbGVjdCBhIHBvaW50XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgcG9pbnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIEluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dW5zZWxlY3RQb2ludCh0YXJnZXQsIGQsIGk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuZGF0YV9vbnVuc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIHNlbGVjdGVkLWNpcmNsZSBmcm9tIGxvdyBsYXllciBnXHJcblx0XHQkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgMClcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBwb2ludHNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkIHdoZXRoZXIgb3Igbm90IHRvIHNlbGVjdC5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIEluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dG9nZ2xlUG9pbnQoc2VsZWN0ZWQsIHRhcmdldCwgZCwgaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCBtZXRob2QgPSBgJHtzZWxlY3RlZCA/IFwiXCIgOiBcInVuXCJ9c2VsZWN0UG9pbnRgO1xyXG5cclxuXHRcdHRoaXNbbWV0aG9kXSh0YXJnZXQsIGQsIGkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNlbGVjdCBhIHBhdGhcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRhcmdldCBwYXRoXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNlbGVjdFBhdGgodGFyZ2V0LCBkKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuZGF0YV9vbnNlbGVjdGVkLCAkJC5hcGksIGQsIHRhcmdldC5ub2RlKCkpO1xyXG5cclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fYnJpZ2h0ZW4pIHtcclxuXHRcdFx0dGFyZ2V0LnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAoKSA9PiBkM1JnYigkJC5jb2xvcihkKSkuYnJpZ2h0ZXIoMC43NSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuZWxlY3QgYSBwYXRoXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRhcmdldCBwYXRoXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKi9cclxuXHR1bnNlbGVjdFBhdGgodGFyZ2V0LCBkKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuZGF0YV9vbnVuc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbikge1xyXG5cdFx0XHR0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsICgpID0+ICQkLmNvbG9yKGQpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2YgbGluZXNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHNlbGVjdGVkIHdoZXRoZXIgb3Igbm90IHRvIHNlbGVjdC5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIEluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dG9nZ2xlUGF0aChzZWxlY3RlZCwgdGFyZ2V0LCBkLCBpOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXNbXHJcblx0XHRcdGAke3NlbGVjdGVkID8gXCJcIiA6IFwidW5cIn1zZWxlY3RQYXRoYFxyXG5cdFx0XSh0YXJnZXQsIGQsIGkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHRvZ2dsZSBtZXRob2Qgb2YgdGhlIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0aGF0IHNoYXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHRvZ2dsZSBtZXRob2RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvZ2dsZSh0aGF0LCBkKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiB0aGF0Lm5vZGVOYW1lID09PSBcInBhdGhcIiA/XHJcblx0XHRcdCQkLnRvZ2dsZVBhdGggOiAoXHJcblx0XHRcdFx0JCQuaXNTdGVwVHlwZShkKSA/XHJcblx0XHRcdFx0XHQoKSA9PiB7fSA6IC8vIGNpcmNsZSBpcyBoaWRkZW4gaW4gc3RlcCBjaGFydCwgc28gdHJlYXQgYXMgd2l0aGluIHRoZSBjbGljayBhcmVhXHJcblx0XHRcdFx0XHQkJC50b2dnbGVQb2ludFxyXG5cdFx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBzaGFwZXNcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGhhdCBzaGFwZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgSW5kZXggbnVtYmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0b2dnbGVTaGFwZSh0aGF0LCBkLCBpOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGF0KTtcclxuXHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGF0LCBkKS5iaW5kKCQkKTtcclxuXHRcdGxldCB0b2dnbGVkU2hhcGU7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpKSB7XHJcblx0XHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX211bHRpcGxlKSB7XHJcblx0XHRcdFx0bGV0IHNlbGVjdG9yID0gYC4ke0NMQVNTLnNoYXBlc31gO1xyXG5cclxuXHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRcdHNlbGVjdG9yICs9ICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWFpbi5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpKSB7XHJcblx0XHRcdFx0XHRcdFx0dG9nZ2xlZFNoYXBlID0gc2hhcGU7XHJcblx0XHRcdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCF0b2dnbGVkU2hhcGUgfHwgdG9nZ2xlZFNoYXBlLm5vZGUoKSAhPT0gc2hhcGUubm9kZSgpKSB7XHJcblx0XHRcdFx0c2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgIWlzU2VsZWN0ZWQpO1xyXG5cdFx0XHRcdHRvZ2dsZSghaXNTZWxlY3RlZCwgc2hhcGUsIGQsIGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge21vdXNlIGFzIGQzTW91c2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldFJhbmRvbSwgZ2V0UmVjdFNlZ0xpc3QsIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRCYXIoKTogdm9pZCB7XHJcblx0XHRjb25zdCB7JGVsfSA9IHRoaXM7XHJcblxyXG5cdFx0JGVsLmJhciA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcclxuXHRcdFx0Ly8gc2hvdWxkIHBvc2l0aW9uZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2hhcGUgbm9kZSB0byBub3Qgb3ZlcmxhcCBvdGhlcnNcclxuXHRcdFx0Lmluc2VydChcImdcIiwgXCI6Zmlyc3QtY2hpbGRcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEJhcnMpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldHNGb3JCYXIodGFyZ2V0cyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydEJhciA9ICQkLmNsYXNzQ2hhcnRCYXIuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0JhcnMgPSAkJC5jbGFzc0JhcnMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHJcblx0XHRpZiAoISRlbC5iYXIpIHtcclxuXHRcdFx0JCQuaW5pdEJhcigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1haW5CYXJVcGRhdGUgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QmFyc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEJhcn1gKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydEJhcihkKSArIGNsYXNzRm9jdXMoZCkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5CYXJFbnRlciA9IG1haW5CYXJVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEJhcilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cclxuXHRcdC8vIEJhcnMgZm9yIGVhY2ggZGF0YVxyXG5cdFx0bWFpbkJhckVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0JhcnMpXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUJhcihkdXJhdGlvbkZvckV4aXQ6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGJhckRhdGEgPSAkJC5iYXJEYXRhLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NCYXIgPSAkJC5jbGFzc0Jhci5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGluaXRpYWxPcGFjaXR5ID0gJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCk7XHJcblxyXG5cdFx0JGVsLmJhciA9ICRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcn1gKVxyXG5cdFx0XHQuZGF0YShiYXJEYXRhKTtcclxuXHJcblx0XHQkZWwuYmFyLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdCRlbC5iYXIgPSAkZWwuYmFyLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2UoJGVsLmJhcilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBpbml0aWFsT3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3QmFyKGRyYXdCYXIsIHdpdGhUcmFuc2l0aW9uPzogYm9vbGVhbikge1xyXG5cdFx0Y29uc3Qge2Jhcn0gPSB0aGlzLiRlbDtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiBiYXIpXHJcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCB0aGlzLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdGdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgbWF4RGF0YUNvdW50ID0gJCQuZ2V0TWF4RGF0YUNvdW50KCk7XHJcblx0XHRjb25zdCBpc0dyb3VwZWQgPSBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoO1xyXG5cdFx0Y29uc3QgdGlja0ludGVydmFsID0gKHNjYWxlLnpvb20gfHwgJCQpICYmICEkJC5heGlzLmlzQ2F0ZWdvcml6ZWQoKSA/XHJcblx0XHRcdCQkLnh4KHNjYWxlLnN1YlguZG9tYWluKClbMV0pIC8gbWF4RGF0YUNvdW50IDogYXhpcy50aWNrSW50ZXJ2YWwobWF4RGF0YUNvdW50KTtcclxuXHRcdGxldCByZXN1bHQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0V2lkdGggPSAoaWQ/OiBzdHJpbmcpID0+IHtcclxuXHRcdFx0Y29uc3Qgd2lkdGggPSBpZCA/IGNvbmZpZy5iYXJfd2lkdGhbaWRdIDogY29uZmlnLmJhcl93aWR0aDtcclxuXHRcdFx0Y29uc3QgcmF0aW8gPSBpZCA/IHdpZHRoLnJhdGlvIDogY29uZmlnLmJhcl93aWR0aF9yYXRpbztcclxuXHRcdFx0Y29uc3QgbWF4ID0gaWQgPyB3aWR0aC5tYXggOiBjb25maWcuYmFyX3dpZHRoX21heDtcclxuXHRcdFx0Y29uc3QgdyA9IGlzTnVtYmVyKHdpZHRoKSA/XHJcblx0XHRcdFx0d2lkdGggOiBiYXJUYXJnZXRzTnVtID8gKHRpY2tJbnRlcnZhbCAqIHJhdGlvKSAvIGJhclRhcmdldHNOdW0gOiAwO1xyXG5cclxuXHRcdFx0cmV0dXJuIG1heCAmJiB3ID4gbWF4ID8gbWF4IDogdztcclxuXHRcdH07XHJcblxyXG5cdFx0cmVzdWx0ID0gZ2V0V2lkdGgoKTtcclxuXHJcblx0XHRpZiAoIWlzR3JvdXBlZCAmJiBpc09iamVjdFR5cGUoY29uZmlnLmJhcl93aWR0aCkpIHtcclxuXHRcdFx0cmVzdWx0ID0ge3dpZHRoOiByZXN1bHQsIHRvdGFsOiBbXX07XHJcblxyXG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRpZiAoY29uZmlnLmJhcl93aWR0aFt2LmlkXSkge1xyXG5cdFx0XHRcdFx0cmVzdWx0W3YuaWRdID0gZ2V0V2lkdGgodi5pZCk7XHJcblx0XHRcdFx0XHRyZXN1bHQudG90YWwucHVzaChyZXN1bHRbdi5pZF0gfHwgcmVzdWx0LndpZHRoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QmFycyhpOiBudW1iZXIsIGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IHN1ZmZpeCA9IChpc1ZhbHVlKGkpID8gYC0ke2l9YCA6IGBgKTtcclxuXHJcblx0XHRyZXR1cm4gKGlkID8gbWFpblxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWApIDogbWFpbilcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfSR7c3VmZml4fWApO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJhcnMoaTogbnVtYmVyLCBpZDogc3RyaW5nLCByZXNldDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJlc2V0ICYmICQkLnVuZXhwYW5kQmFycygpO1xyXG5cdFx0JCQuZ2V0QmFycyhpLCBpZCkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0dW5leHBhbmRCYXJzKGk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0dGhpcy5nZXRCYXJzKGkpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZURyYXdCYXIoYmFySW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc0dyb3VwZWQgPSBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoO1xyXG5cdFx0Y29uc3QgYmFyUmFkaXVzID0gY29uZmlnLmJhcl9yYWRpdXM7XHJcblx0XHRjb25zdCBiYXJSYWRpdXNSYXRpbyA9IGNvbmZpZy5iYXJfcmFkaXVzX3JhdGlvO1xyXG5cclxuXHRcdC8vIGdldCB0aGUgYmFyIHJhZGl1c1xyXG5cdFx0Y29uc3QgZ2V0UmFkaXVzID0gaXNOdW1iZXIoYmFyUmFkaXVzKSAmJiBiYXJSYWRpdXMgPiAwID9cclxuXHRcdFx0KCkgPT4gYmFyUmFkaXVzIDogKFxyXG5cdFx0XHRcdGlzTnVtYmVyKGJhclJhZGl1c1JhdGlvKSA/IHcgPT4gdyAqIGJhclJhZGl1c1JhdGlvIDogbnVsbFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xyXG5cdFx0XHQvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcclxuXHRcdFx0Y29uc3QgcG9pbnRzID0gZ2V0UG9pbnRzKGQsIGkpO1xyXG5cclxuXHRcdFx0Ly8gc3dpdGNoIHBvaW50cyBpZiBheGlzIGlzIHJvdGF0ZWQsIG5vdCBhcHBsaWNhYmxlIGZvciBzdWIgY2hhcnRcclxuXHRcdFx0Y29uc3QgaW5kZXhYID0gK2lzUm90YXRlZDtcclxuXHRcdFx0Y29uc3QgaW5kZXhZID0gKyFpbmRleFg7XHJcblxyXG5cdFx0XHRjb25zdCBpc05lZ2F0aXZlID0gZC52YWx1ZSA8IDA7XHJcblx0XHRcdGNvbnN0IHBhdGhSYWRpdXMgPSBbXCJcIiwgXCJcIl07XHJcblx0XHRcdGxldCByYWRpdXMgPSAwO1xyXG5cclxuXHRcdFx0aWYgKGdldFJhZGl1cyAmJiAhaXNHcm91cGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpc1JvdGF0ZWQgPyBpbmRleFkgOiBpbmRleFg7XHJcblx0XHRcdFx0Y29uc3QgYmFyVyA9IHBvaW50c1syXVtpbmRleF0gLSBwb2ludHNbMF1baW5kZXhdO1xyXG5cclxuXHRcdFx0XHRyYWRpdXMgPSBnZXRSYWRpdXMoYmFyVyk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGFyYyA9IGBhJHtyYWRpdXN9LCR7cmFkaXVzfSAke2lzTmVnYXRpdmUgPyBgMSAwIDBgIDogYDAgMCAxYH0gYDtcclxuXHJcblx0XHRcdFx0cGF0aFJhZGl1c1srIWlzUm90YXRlZF0gPSBgJHthcmN9JHtyYWRpdXN9LCR7cmFkaXVzfWA7XHJcblx0XHRcdFx0cGF0aFJhZGl1c1sraXNSb3RhdGVkXSA9IGAke2FyY30ke1stcmFkaXVzLCByYWRpdXNdW2lzUm90YXRlZCA/IFwic29ydFwiIDogXCJyZXZlcnNlXCJdKCl9YDtcclxuXHJcblx0XHRcdFx0aXNOZWdhdGl2ZSAmJiBwYXRoUmFkaXVzLnJldmVyc2UoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcGF0aCBzdHJpbmcgZGF0YSBzaG91bGRuJ3QgYmUgY29udGFpbmluZyBuZXcgbGluZSBjaGFyc1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy81MzBcclxuXHRcdFx0Y29uc3QgcGF0aCA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0YEgke3BvaW50c1sxXVtpbmRleFhdIC0gcmFkaXVzfSAke3BhdGhSYWRpdXNbMF19ViR7cG9pbnRzWzJdW2luZGV4WV0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1sxXX1IJHtwb2ludHNbM11baW5kZXhYXX1gIDpcclxuXHRcdFx0XHRgViR7cG9pbnRzWzFdW2luZGV4WV0gKyAoaXNOZWdhdGl2ZSA/IC1yYWRpdXMgOiByYWRpdXMpfSAke3BhdGhSYWRpdXNbMF19SCR7cG9pbnRzWzJdW2luZGV4WF0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1sxXX1WJHtwb2ludHNbM11baW5kZXhZXX1gO1xyXG5cclxuXHRcdFx0cmV0dXJuIGBNJHtwb2ludHNbMF1baW5kZXhYXX0sJHtwb2ludHNbMF1baW5kZXhZXX0ke3BhdGh9emA7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViPzogYm9vbGVhbik6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBheGlzID0gaXNTdWIgPyAkJC5heGlzLnN1YlggOiAkJC5heGlzLng7XHJcblx0XHRjb25zdCBiYXJUYXJnZXRzTnVtID0gJCQuZ2V0SW5kaWNlc01heChiYXJJbmRpY2VzKSArIDE7XHJcblx0XHRjb25zdCBiYXJXID0gJCQuZ2V0QmFyVyhheGlzLCBiYXJUYXJnZXRzTnVtKTtcclxuXHRcdGNvbnN0IGJhclggPSAkJC5nZXRTaGFwZVgoYmFyVywgYmFySW5kaWNlcywgISFpc1N1Yik7XHJcblx0XHRjb25zdCBiYXJZID0gJCQuZ2V0U2hhcGVZKCEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgYmFyT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNCYXJUeXBlLCBiYXJJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IHlTY2FsZSA9ICQkLmdldFlTY2FsZUJ5SWQuYmluZCgkJCk7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0XHRcdGNvbnN0IHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKCQkLmdldFNoYXBlWU1pbihkLmlkKSk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGJhck9mZnNldChkLCBpKSB8fCB5MDsgLy8gb2Zmc2V0IGlzIGZvciBzdGFja2VkIGJhciBjaGFydFxyXG5cdFx0XHRjb25zdCB3aWR0aCA9IGlzTnVtYmVyKGJhclcpID8gYmFyVyA6IGJhcldbZC5pZF0gfHwgYmFyVy53aWR0aDtcclxuXHRcdFx0Y29uc3QgcG9zWCA9IGJhclgoZCk7XHJcblx0XHRcdGxldCBwb3NZID0gYmFyWShkKTtcclxuXHJcblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCAmJiAoXHJcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcclxuXHRcdFx0KSkge1xyXG5cdFx0XHRcdHBvc1kgPSB5MDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cG9zWSAtPSAoeTAgLSBvZmZzZXQpO1xyXG5cclxuXHRcdFx0Ly8gNCBwb2ludHMgdGhhdCBtYWtlIGEgYmFyXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0sXHJcblx0XHRcdFx0W3Bvc1gsIHBvc1ldLFxyXG5cdFx0XHRcdFtwb3NYICsgd2lkdGgsIHBvc1ldLFxyXG5cdFx0XHRcdFtwb3NYICsgd2lkdGgsIG9mZnNldF1cclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5CYXIodGhhdCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKHRoYXQpO1xyXG5cdFx0Y29uc3QgbGlzdCA9IGdldFJlY3RTZWdMaXN0KHRoYXQpO1xyXG5cdFx0Y29uc3QgW3NlZzAsIHNlZzFdID0gbGlzdDtcclxuXHRcdGNvbnN0IHggPSBNYXRoLm1pbihzZWcwLngsIHNlZzEueCk7XHJcblx0XHRjb25zdCB5ID0gTWF0aC5taW4oc2VnMC55LCBzZWcxLnkpO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gdGhpcy5jb25maWcuYmFyX3NlbnNpdGl2aXR5O1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhhdC5nZXRCQm94KCk7XHJcblx0XHRjb25zdCBzeCA9IHggLSBvZmZzZXQ7XHJcblx0XHRjb25zdCBleCA9IHggKyB3aWR0aCArIG9mZnNldDtcclxuXHRcdGNvbnN0IHN5ID0geSArIGhlaWdodCArIG9mZnNldDtcclxuXHRcdGNvbnN0IGV5ID0geSAtIG9mZnNldDtcclxuXHJcblx0XHRyZXR1cm4gc3ggPCBtb3VzZVswXSAmJlxyXG5cdFx0XHRtb3VzZVswXSA8IGV4ICYmXHJcblx0XHRcdGV5IDwgbW91c2VbMV0gJiZcclxuXHRcdFx0bW91c2VbMV0gPCBzeTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtLRVl9IGZyb20gXCIuLi8uLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IHtnZXRNaW5NYXgsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBpc09iamVjdH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRCdWJibGUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwiYnViYmxlXCIpKSB7XHJcblx0XHRcdGNvbmZpZy5wb2ludF9zaG93ID0gdHJ1ZTtcclxuXHRcdFx0Y29uZmlnLnBvaW50X3R5cGUgPSBcImNpcmNsZVwiO1xyXG5cdFx0XHRjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkgPSAyNTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdXNlciBhZ2VudCdzIGNvbXB1dGVkIHZhbHVlXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEJhc2VMZW5ndGgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBLRVkuYnViYmxlQmFzZUxlbmd0aDtcclxuXHRcdGxldCBiYXNlTGVuZ3RoID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIWJhc2VMZW5ndGgpIHtcclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCBiYXNlTGVuZ3RoID0gZ2V0TWluTWF4KFwibWluXCIsIFt3aWR0aCwgaGVpZ2h0XSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBiYXNlTGVuZ3RoO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcmFkaXVzIHZhbHVlIGZvciBidWJibGUgY2lyY2xlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QnViYmxlUihkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCBtYXhSID0gJCQuY29uZmlnLmJ1YmJsZV9tYXhSO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKG1heFIpKSB7XHJcblx0XHRcdG1heFIgPSBtYXhSLmJpbmQoJCQuYXBpKShkKTtcclxuXHRcdH0gZWxzZSBpZiAoIWlzTnVtYmVyKG1heFIpKSB7XHJcblx0XHRcdG1heFIgPSAoJCQuZ2V0QmFzZUxlbmd0aCgpIC8gKCQkLmdldE1heERhdGFDb3VudCgpICogMikpICsgMTI7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsICQkLmdldE1pbk1heERhdGEoKS5tYXgubWFwKGQgPT4gKFxyXG5cdFx0XHQkJC5pc0J1YmJsZVpUeXBlKGQpID9cclxuXHRcdFx0XHQkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInlcIikgOiAoXHJcblx0XHRcdFx0XHRpc09iamVjdChkLnZhbHVlKSA/IGQudmFsdWUubWlkIDogZC52YWx1ZVxyXG5cdFx0XHRcdClcclxuXHRcdCkpKTtcclxuXHRcdGNvbnN0IG1heEFyZWEgPSBtYXhSICogbWF4UiAqIE1hdGguUEk7XHJcblx0XHRjb25zdCBhcmVhID0gKCQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInpcIikgOiBkLnZhbHVlKSAqIChtYXhBcmVhIC8gbWF4KTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KGFyZWEgLyBNYXRoLlBJKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYnViYmxlIGRpbWVuc2lvbiBkYXRhXHJcblx0ICogQHBhcmFtIHtvYmplY3R8QXJyYXl9IGQgZGF0YSB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0geSBvciB6XHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEJ1YmJsZVpEYXRhKGQsIHR5cGU6IFwieVwiIHwgXCJ6XCIpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIGlzT2JqZWN0KGQpID8gZFt0eXBlXSA6IGRbdHlwZSA9PT0gXCJ5XCIgPyAwIDogMV07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lIGlmIGJ1YmJsZSBoYXMgZGltZW5zaW9uIGRhdGFcclxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gZCBkYXRhIHZhbHVlXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpc0J1YmJsZVpUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuaXNCdWJibGVUeXBlKGQpICYmIChcclxuXHRcdFx0KGlzT2JqZWN0KGQudmFsdWUpICYmIChcInpcIiBpbiBkLnZhbHVlIHx8IFwieVwiIGluIGQudmFsdWUpKSB8fFxyXG5cdFx0XHQoaXNBcnJheShkLnZhbHVlKSAmJiBkLnZhbHVlLmxlbmd0aCA9PT0gMilcclxuXHRcdCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0YXJlYSBhcyBkM0FyZWEsXHJcblx0bGluZSBhcyBkM0xpbmVcclxufSBmcm9tIFwiZDMtc2hhcGVcIjtcclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldFJhbmRvbSwgaXNBcnJheSwgaXNEZWZpbmVkLCBpc0Z1bmN0aW9uLCBpc1VuZGVmaW5lZCwgaXNWYWx1ZSwgcGFyc2VEYXRlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0TGluZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHskZWx9ID0gdGhpcztcclxuXHJcblx0XHQkZWwubGluZSA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0TGluZXMpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0TGluZSA9ICQkLmNsYXNzQ2hhcnRMaW5lLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NMaW5lcyA9ICQkLmNsYXNzTGluZXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHJcblx0XHRpZiAoISRlbC5saW5lKSB7XHJcblx0XHRcdCQkLmluaXRMaW5lKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbWFpbkxpbmVVcGRhdGUgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0TGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRMaW5lfWApXHJcblx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0TGluZShkKSArIGNsYXNzRm9jdXMoZCkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5MaW5lRW50ZXIgPSBtYWluTGluZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0TGluZSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cclxuXHRcdC8vIExpbmVzIGZvciBlYWNoIGRhdGFcclxuXHRcdG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTGluZXMpO1xyXG5cclxuXHRcdC8vIEFyZWFzXHJcblx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiQXJlYVwiKSkge1xyXG5cdFx0XHRtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYXMuYmluZCgkJCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1FTU86IGNhbiBub3Qga2VlcCBzYW1lIGNvbG9yLi4uXHJcblx0XHQvLyBtYWluTGluZVVwZGF0ZS5leGl0KCkucmVtb3ZlKCk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlTGluZShkdXJhdGlvbkZvckV4aXQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtmb3JtYXQ6IHtleHRyYUxpbmVDbGFzc2VzfSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCRlbC5saW5lID0gJGVsLm1haW5cclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGluZX1gKVxyXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0JGVsLmxpbmUuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0JGVsLmxpbmUgPSAkZWwubGluZS5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHskJC5jbGFzc0xpbmUuYmluZCgkJCkoZCl9ICR7ZXh0cmFMaW5lQ2xhc3NlcyhkKSB8fCBcIlwifWApXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKCRlbC5saW5lKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJzaGFwZS1yZW5kZXJpbmdcIiwgZCA9PiAoJCQuaXNTdGVwVHlwZShkKSA/IFwiY3Jpc3BFZGdlc1wiIDogXCJcIikpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0xpbmUoZHJhd0xpbmUsIHdpdGhUcmFuc2l0aW9uPzogYm9vbGVhbikge1xyXG5cdFx0Y29uc3Qge2xpbmV9ID0gdGhpcy4kZWw7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gbGluZS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6IGxpbmUpXHJcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdMaW5lKVxyXG5cdFx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCB0aGlzLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgY3VydmUgaW50ZXJwb2xhdGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q3VydmUoZCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzUm90YXRlZFN0ZXBUeXBlID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZCAmJiAkJC5pc1N0ZXBUeXBlKGQpO1xyXG5cclxuXHRcdC8vIHdoZW4gaXMgc3RlcCAmIHJvdGF0ZWQsIHNob3VsZCBiZSBjb21wdXRlZCBpbiBkaWZmZXJlbnQgd2F5XHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy80NzFcclxuXHRcdHJldHVybiBpc1JvdGF0ZWRTdGVwVHlwZSA/IGNvbnRleHQgPT4ge1xyXG5cdFx0XHRjb25zdCBzdGVwID0gJCQuZ2V0SW50ZXJwb2xhdGUoZCkoY29udGV4dCk7XHJcblxyXG5cdFx0XHQvLyBrZWVwIHRoZSBvcmlnaW5hbCBtZXRob2RcclxuXHRcdFx0c3RlcC5vcmdQb2ludCA9IHN0ZXAucG9pbnQ7XHJcblxyXG5cdFx0XHQvLyB0byBnZXQgcm90YXRlZCBwYXRoIGRhdGFcclxuXHRcdFx0c3RlcC5wb2ludFJvdGF0ZWQgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0dGhpcy5fcG9pbnQgPT09IDEgJiYgKHRoaXMuX3BvaW50ID0gMik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHkxID0gdGhpcy5feSAqICgxIC0gdGhpcy5fdCkgKyB5ICogdGhpcy5fdDtcclxuXHJcblx0XHRcdFx0dGhpcy5fY29udGV4dC5saW5lVG8odGhpcy5feCwgeTEpO1xyXG5cdFx0XHRcdHRoaXMuX2NvbnRleHQubGluZVRvKHgsIHkxKTtcclxuXHJcblx0XHRcdFx0dGhpcy5feCA9IHg7XHJcblx0XHRcdFx0dGhpcy5feSA9IHk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRzdGVwLnBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xyXG5cdFx0XHRcdHRoaXMuX3BvaW50ID09PSAwID8gdGhpcy5vcmdQb2ludCh4LCB5KSA6IHRoaXMucG9pbnRSb3RhdGVkKHgsIHkpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0cmV0dXJuIHN0ZXA7XHJcblx0XHR9IDogJCQuZ2V0SW50ZXJwb2xhdGUoZCk7XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVEcmF3TGluZShsaW5lSW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogKGQpID0+IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGxpbmVDb25uZWN0TnVsbCA9IGNvbmZpZy5saW5lX2Nvbm5lY3ROdWxsO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRjb25zdCBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldExpbmVQb2ludHMobGluZUluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IHlTY2FsZSA9ICQkLmdldFlTY2FsZUJ5SWQuYmluZCgkJCk7XHJcblxyXG5cdFx0Y29uc3QgeFZhbHVlID0gZCA9PiAoaXNTdWIgPyAkJC5zdWJ4eCA6ICQkLnh4KS5jYWxsKCQkLCBkKTtcclxuXHRcdGNvbnN0IHlWYWx1ZSA9IChkLCBpKSA9PiAoXHJcblx0XHRcdCQkLmlzR3JvdXBlZChkLmlkKSA/XHJcblx0XHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzBdWzFdIDpcclxuXHRcdFx0XHR5U2NhbGUoZC5pZCwgaXNTdWIpKCQkLmdldEJhc2VWYWx1ZShkKSlcclxuXHRcdCk7XHJcblxyXG5cdFx0bGV0IGxpbmUgPSBkM0xpbmUoKTtcclxuXHJcblx0XHRsaW5lID0gaXNSb3RhdGVkID9cclxuXHRcdFx0bGluZS54KHlWYWx1ZSkueSh4VmFsdWUpIDogbGluZS54KHhWYWx1ZSkueSh5VmFsdWUpO1xyXG5cclxuXHRcdGlmICghbGluZUNvbm5lY3ROdWxsKSB7XHJcblx0XHRcdGxpbmUgPSBsaW5lLmRlZmluZWQoZCA9PiAkJC5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHggPSBpc1N1YiA/IHNjYWxlLnN1YlggOiBzY2FsZS54O1xyXG5cclxuXHRcdHJldHVybiBkID0+IHtcclxuXHRcdFx0Y29uc3QgeSA9IHlTY2FsZShkLmlkLCBpc1N1Yik7XHJcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xyXG5cdFx0XHRsZXQgeDAgPSAwO1xyXG5cdFx0XHRsZXQgeTAgPSAwO1xyXG5cdFx0XHRsZXQgcGF0aDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0xpbmVUeXBlKGQpKSB7XHJcblx0XHRcdFx0Y29uc3QgcmVnaW9ucyA9IGNvbmZpZy5kYXRhX3JlZ2lvbnNbZC5pZF07XHJcblxyXG5cdFx0XHRcdGlmIChyZWdpb25zKSB7XHJcblx0XHRcdFx0XHRwYXRoID0gJCQubGluZVdpdGhSZWdpb25zKHZhbHVlcywgeCwgeSwgcmVnaW9ucyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpKSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlcyA9ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRwYXRoID0gbGluZS5jdXJ2ZSgkJC5nZXRDdXJ2ZShkKSkodmFsdWVzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xyXG5cdFx0XHRcdFx0eDAgPSB4KHZhbHVlc1swXS54KTtcclxuXHRcdFx0XHRcdHkwID0geSh2YWx1ZXNbMF0udmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGlzUm90YXRlZCA/IGBNICR7eTB9ICR7eDB9YCA6IGBNICR7eDB9ICR7eTB9YDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGggfHwgXCJNIDAgMFwiO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdldExpbmVQb2ludHMobGluZUluZGljZXMsIGlzU3ViVmFsdWU/OiBib29sZWFuKTpGdW5jdGlvbiB7IC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1N1YiA9ICEhaXNTdWJWYWx1ZTtcclxuXHRcdGNvbnN0IHggPSAkJC5nZXRTaGFwZVgoMCwgbGluZUluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoaXNTdWIpO1xyXG5cdFx0Y29uc3QgbGluZU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzTGluZVR5cGUsIGxpbmVJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGUgPSAkJC5nZXRZU2NhbGVCeUlkLmJpbmQoJCQpO1xyXG5cclxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgkJC5nZXRTaGFwZVlNaW4oZC5pZCkpO1xyXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBsaW5lT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYXJlYSBjaGFydFxyXG5cdFx0XHRjb25zdCBwb3NYID0geChkKTtcclxuXHRcdFx0bGV0IHBvc1kgPSB5KGQpO1xyXG5cclxuXHRcdFx0Ly8gZml4IHBvc1kgbm90IHRvIG92ZXJmbG93IG9wcG9zaXRlIHF1YWRyYW50XHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkICYmIChcclxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxyXG5cdFx0XHQpKSB7XHJcblx0XHRcdFx0cG9zWSA9IHkwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyAxIHBvaW50IHRoYXQgbWFya3MgdGhlIGxpbmUgcG9zaXRpb25cclxuXHRcdFx0Y29uc3QgcG9pbnQgPSBbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludCwgLy8gZnJvbSBoZXJlIGFuZCBiZWxvdywgbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0bGluZVdpdGhSZWdpb25zKGQsIHgsIHksIF9yZWdpb25zKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuYXhpcy5pc1RpbWVTZXJpZXMoKTtcclxuXHRcdGNvbnN0IHhPZmZzZXQgPSAkJC5heGlzLmlzQ2F0ZWdvcml6ZWQoKSA/IDAuNSA6IDA7XHJcblx0XHRjb25zdCByZWdpb25zOiBhbnlbXSA9IFtdO1xyXG5cdFx0Y29uc3QgZGFzaGFycmF5ID0gXCIyIDJcIjsgLy8gZGVmYXVsdCB2YWx1ZVxyXG5cclxuXHRcdGxldCB4cDtcclxuXHRcdGxldCB5cDtcclxuXHRcdGxldCBkaWZmO1xyXG5cdFx0bGV0IGRpZmZ4MjtcclxuXHJcblx0XHQvLyBjaGVjayB3ZWF0aGVyIGRhdGEgaXMgd2l0aGluIHJlZ2lvblxyXG5cdFx0Y29uc3QgaXNXaXRoaW5SZWdpb25zID0gKHdpdGhpblgsIHdpdGhpblJlZ2lvbnMpID0+IHtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIHJlZzsgKHJlZyA9IHdpdGhpblJlZ2lvbnNbaV0pOyBpKyspIHtcclxuXHRcdFx0XHRpZiAocmVnLnN0YXJ0IDwgd2l0aGluWCAmJiB3aXRoaW5YIDw9IHJlZy5lbmQpIHtcclxuXHRcdFx0XHRcdHJldHVybiByZWcuc3R5bGU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIENoZWNrIHN0YXJ0L2VuZCBvZiByZWdpb25zXHJcblx0XHRpZiAoaXNEZWZpbmVkKF9yZWdpb25zKSkge1xyXG5cdFx0XHRjb25zdCBnZXRWYWx1ZSA9ICh2OiBEYXRlIHwgYW55LCBkZWY6IG51bWJlcik6IERhdGUgfCBhbnkgPT4gKFxyXG5cdFx0XHRcdGlzVW5kZWZpbmVkKHYpID8gZGVmIDogKGlzVGltZVNlcmllcyA/IHBhcnNlRGF0ZS5jYWxsKCQkLCB2KSA6IHYpXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgcmVnOyAocmVnID0gX3JlZ2lvbnNbaV0pOyBpKyspIHtcclxuXHRcdFx0XHRjb25zdCBzdGFydCA9IGdldFZhbHVlKHJlZy5zdGFydCwgZFswXS54KTtcclxuXHRcdFx0XHRjb25zdCBlbmQgPSBnZXRWYWx1ZShyZWcuZW5kLCBkW2QubGVuZ3RoIC0gMV0ueCk7XHJcblx0XHRcdFx0Y29uc3Qgc3R5bGUgPSByZWcuc3R5bGUgfHwge2Rhc2hhcnJheX07XHJcblxyXG5cdFx0XHRcdHJlZ2lvbnNbaV0gPSB7c3RhcnQsIGVuZCwgc3R5bGV9O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IHNjYWxlc1xyXG5cdFx0Y29uc3QgeFZhbHVlID0gaXNSb3RhdGVkID8gZHQgPT4geShkdC52YWx1ZSkgOiBkdCA9PiB4KGR0LngpO1xyXG5cdFx0Y29uc3QgeVZhbHVlID0gaXNSb3RhdGVkID8gZHQgPT4geChkdC54KSA6IGR0ID0+IHkoZHQudmFsdWUpO1xyXG5cclxuXHRcdC8vIERlZmluZSBzdmcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGZvciByZWdpb25cclxuXHRcdGNvbnN0IGdlbmVyYXRlTSA9IHBvaW50cyA9PiBgTSR7cG9pbnRzWzBdWzBdfSwke3BvaW50c1swXVsxXX1MJHtwb2ludHNbMV1bMF19LCR7cG9pbnRzWzFdWzFdfWA7XHJcblxyXG5cdFx0Y29uc3Qgc1dpdGhSZWdpb24gPSBpc1RpbWVTZXJpZXMgPyAoZDAsIGQxLCBrLCB0aW1lc2VyaWVzRGlmZikgPT4ge1xyXG5cdFx0XHRjb25zdCB4MCA9IGQwLnguZ2V0VGltZSgpO1xyXG5cdFx0XHRjb25zdCB4RGlmZiA9IGQxLnggLSBkMC54O1xyXG5cdFx0XHRjb25zdCB4djAgPSBuZXcgRGF0ZSh4MCArIHhEaWZmICogayk7XHJcblx0XHRcdGNvbnN0IHh2MSA9IG5ldyBEYXRlKHgwICsgeERpZmYgKiAoayArIHRpbWVzZXJpZXNEaWZmKSk7XHJcblxyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFtbeSh5cChrKSksIHgoeHYwKV0sIFt5KHlwKGsgKyBkaWZmKSksIHgoeHYxKV1dIDpcclxuXHRcdFx0XHRbW3goeHYwKSwgeSh5cChrKSldLCBbeCh4djEpLCB5KHlwKGsgKyBkaWZmKSldXTtcclxuXHJcblx0XHRcdHJldHVybiBnZW5lcmF0ZU0ocG9pbnRzKTtcclxuXHRcdH0gOiAoZDAsIGQxLCBrLCBvdGhlckRpZmYpID0+IHtcclxuXHRcdFx0Y29uc3QgcG9pbnRzID0gaXNSb3RhdGVkID9cclxuXHRcdFx0XHRbW3koeXAoayksIHRydWUpLCB4KHhwKGspKV0sIFt5KHlwKGsgKyBvdGhlckRpZmYpLCB0cnVlKSwgeCh4cChrICsgb3RoZXJEaWZmKSldXSA6XHJcblx0XHRcdFx0W1t4KHhwKGspLCB0cnVlKSwgeSh5cChrKSldLCBbeCh4cChrICsgb3RoZXJEaWZmKSwgdHJ1ZSksIHkoeXAoayArIG90aGVyRGlmZikpXV07XHJcblxyXG5cdFx0XHRyZXR1cm4gZ2VuZXJhdGVNKHBvaW50cyk7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEdlbmVyYXRlXHJcblx0XHRsZXQgcGF0aCA9IFwiXCI7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIGRhdGE7IChkYXRhID0gZFtpXSk7IGkrKykge1xyXG5cdFx0XHRjb25zdCBwcmV2RGF0YSA9IGRbaSAtIDFdO1xyXG5cdFx0XHRjb25zdCBoYXNQcmV2RGF0YSA9IHByZXZEYXRhICYmIGlzVmFsdWUocHJldkRhdGEudmFsdWUpO1xyXG5cdFx0XHRsZXQgc3R5bGUgPSBpc1dpdGhpblJlZ2lvbnMoZGF0YS54LCByZWdpb25zKTtcclxuXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzExNzJcclxuXHRcdFx0aWYgKCFpc1ZhbHVlKGRhdGEudmFsdWUpKSB7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIERyYXcgYXMgbm9ybWFsXHJcblx0XHRcdGlmIChpc1VuZGVmaW5lZChyZWdpb25zKSB8fCAhc3R5bGUgfHwgIWhhc1ByZXZEYXRhKSB7XHJcblx0XHRcdFx0cGF0aCArPSBgJHtpICYmIGhhc1ByZXZEYXRhID8gXCJMXCIgOiBcIk1cIn0ke3hWYWx1ZShkYXRhKX0sJHt5VmFsdWUoZGF0YSl9YDtcclxuXHRcdFx0fSBlbHNlIGlmIChoYXNQcmV2RGF0YSkge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRzdHlsZSA9IHN0eWxlLmRhc2hhcnJheS5zcGxpdChcIiBcIik7XHJcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0c3R5bGUgPSBkYXNoYXJyYXkuc3BsaXQoXCIgXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gRHJhdyB3aXRoIHJlZ2lvbiAvLyBUT0RPOiBGaXggZm9yIGhvcml6b3RhbCBjaGFydHNcclxuXHRcdFx0XHR4cCA9ICQkLmdldFNjYWxlKHByZXZEYXRhLnggKyB4T2Zmc2V0LCBkYXRhLnggKyB4T2Zmc2V0LCBpc1RpbWVTZXJpZXMpO1xyXG5cdFx0XHRcdHlwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEudmFsdWUsIGRhdGEudmFsdWUpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBkeCA9IHgoZGF0YS54KSAtIHgocHJldkRhdGEueCk7XHJcblx0XHRcdFx0Y29uc3QgZHkgPSB5KGRhdGEudmFsdWUpIC0geShwcmV2RGF0YS52YWx1ZSk7XHJcblx0XHRcdFx0Y29uc3QgZGQgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcclxuXHJcblx0XHRcdFx0ZGlmZiA9IHN0eWxlWzBdIC8gZGQ7XHJcblx0XHRcdFx0ZGlmZngyID0gZGlmZiAqIHN0eWxlWzFdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBqID0gZGlmZjsgaiA8PSAxOyBqICs9IGRpZmZ4Mikge1xyXG5cdFx0XHRcdFx0cGF0aCArPSBzV2l0aFJlZ2lvbihwcmV2RGF0YSwgZGF0YSwgaiwgZGlmZik7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdG8gbWFrZSBzdXJlIGNvcnJlY3QgbGluZSBkcmF3aW5nXHJcblx0XHRcdFx0XHRpZiAoaiArIGRpZmZ4MiA+PSAxKSB7XHJcblx0XHRcdFx0XHRcdHBhdGggKz0gc1dpdGhSZWdpb24ocHJldkRhdGEsIGRhdGEsIDEsIDApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXRoO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWFHcmFkaWVudCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7ZGF0ZXRpbWVJZH0sICRlbDoge2RlZnN9fSA9ICQkO1xyXG5cclxuXHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRjb25zdCBpZCA9IGAke2RhdGV0aW1lSWR9LWFyZWFHcmFkaWVudCR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpICYmIGRlZnMuc2VsZWN0KGAjJHtpZH1gKS5lbXB0eSgpKSB7XHJcblx0XHRcdFx0Y29uc3QgY29sb3IgPSAkJC5jb2xvcihkKTtcclxuXHRcdFx0XHRjb25zdCB7XHJcblx0XHRcdFx0XHR4ID0gWzAsIDBdLFxyXG5cdFx0XHRcdFx0eSA9IFswLCAxXSxcclxuXHRcdFx0XHRcdHN0b3BzID0gW1swLCBjb2xvciwgMV0sIFsxLCBjb2xvciwgMF1dXHJcblx0XHRcdFx0fSA9IGNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50O1xyXG5cclxuXHRcdFx0XHRjb25zdCBsaW5lYXJHcmFkaWVudCA9IGRlZnMuYXBwZW5kKFwibGluZWFyR3JhZGllbnRcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiaWRcIiwgYCR7aWR9YClcclxuXHRcdFx0XHRcdC5hdHRyKFwieDFcIiwgeFswXSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgeFsxXSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTFcIiwgeVswXSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgeVsxXSk7XHJcblxyXG5cdFx0XHRcdHN0b3BzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBzdG9wQ29sb3IgPSBpc0Z1bmN0aW9uKHZbMV0pID8gdlsxXS5iaW5kKCQkLmFwaSkoZC5pZCkgOiB2WzFdO1xyXG5cclxuXHRcdFx0XHRcdGxpbmVhckdyYWRpZW50LmFwcGVuZChcInN0b3BcIilcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJvZmZzZXRcIiwgdlswXSlcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJzdG9wLWNvbG9yXCIsIHN0b3BDb2xvciB8fCBjb2xvcilcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJzdG9wLW9wYWNpdHlcIiwgdlsyXSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWFDb2xvcihkKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQgP1xyXG5cdFx0XHRgdXJsKCMkeyQkLnN0YXRlLmRhdGV0aW1lSWR9LWFyZWFHcmFkaWVudCR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9KWAgOlxyXG5cdFx0XHQkJC5jb2xvcihkKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmVhKGR1cmF0aW9uRm9yRXhpdDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50ICYmICQkLnVwZGF0ZUFyZWFHcmFkaWVudCgpO1xyXG5cclxuXHRcdCRlbC5hcmVhID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwuYXJlYS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwuYXJlYSA9ICRlbC5hcmVhLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3RhdGUub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XHJcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2UoJGVsLmFyZWEpO1xyXG5cclxuXHRcdCRlbC5hcmVhXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgc3RhdGUub3JnQXJlYU9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyZWEoZHJhd0FyZWEsIHdpdGhUcmFuc2l0aW9uPzogYm9vbGVhbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge29yZ0FyZWFPcGFjaXR5fSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/ICQkLiRlbC5hcmVhLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpIDogJCQuJGVsLmFyZWEpXHJcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdBcmVhKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlQXJlYUNvbG9yLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZCA9PiBTdHJpbmcoJCQuaXNBcmVhUmFuZ2VUeXBlKGQpID8gb3JnQXJlYU9wYWNpdHkgLyAxLjc1IDogb3JnQXJlYU9wYWNpdHkpKVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSBhcmVhIHBhdGggZGF0YVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmVhSW5kaWNlcyBJbmRpY2VzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc1N1YiBXZWF0aGVyIGlzIHN1YiBheGlzXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVEcmF3QXJlYShhcmVhSW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogKGQpID0+IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgbGluZUNvbm5lY3ROdWxsID0gY29uZmlnLmxpbmVfY29ubmVjdE51bGw7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QXJlYVBvaW50cyhhcmVhSW5kaWNlcywgaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gJCQuZ2V0WVNjYWxlQnlJZC5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cdFx0Y29uc3QgdmFsdWUwID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHR5U2NhbGUoZC5pZCwgaXNTdWIpKFxyXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XHJcblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwiaGlnaFwiKSA6ICQkLmdldFNoYXBlWU1pbihkLmlkKVxyXG5cdFx0XHQpKTtcclxuXHRcdGNvbnN0IHZhbHVlMSA9IChkLCBpKSA9PiAoJCQuaXNHcm91cGVkKGQuaWQpID9cclxuXHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzFdWzFdIDpcclxuXHRcdFx0eVNjYWxlKGQuaWQsIGlzU3ViKShcclxuXHRcdFx0XHQkJC5pc0FyZWFSYW5nZVR5cGUoZCkgP1xyXG5cdFx0XHRcdFx0JCQuZ2V0QXJlYVJhbmdlRGF0YShkLCBcImxvd1wiKSA6IGQudmFsdWVcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRsZXQgdmFsdWVzID0gbGluZUNvbm5lY3ROdWxsID8gJCQuZmlsdGVyUmVtb3ZlTnVsbChkLnZhbHVlcykgOiBkLnZhbHVlcztcclxuXHRcdFx0bGV0IHgwID0gMDtcclxuXHRcdFx0bGV0IHkwID0gMDtcclxuXHRcdFx0bGV0IHBhdGg7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNBcmVhVHlwZShkKSkge1xyXG5cdFx0XHRcdGxldCBhcmVhID0gZDNBcmVhKCk7XHJcblxyXG5cdFx0XHRcdGFyZWEgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFx0YXJlYS55KHhWYWx1ZSlcclxuXHRcdFx0XHRcdFx0LngwKHZhbHVlMClcclxuXHRcdFx0XHRcdFx0LngxKHZhbHVlMSkgOlxyXG5cdFx0XHRcdFx0YXJlYS54KHhWYWx1ZSlcclxuXHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0XHQueTAoY29uZmlnLmFyZWFfYWJvdmUgPyAwIDogdmFsdWUwKVxyXG5cdFx0XHRcdFx0XHQueTEodmFsdWUxKTtcclxuXHJcblx0XHRcdFx0aWYgKCFsaW5lQ29ubmVjdE51bGwpIHtcclxuXHRcdFx0XHRcdGFyZWEgPSBhcmVhLmRlZmluZWQoZCA9PiAkJC5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdHZhbHVlcyA9ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHBhdGggPSBhcmVhLmN1cnZlKCQkLmdldEN1cnZlKGQpKSh2YWx1ZXMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh2YWx1ZXNbMF0pIHtcclxuXHRcdFx0XHRcdHgwID0gJCQuc2NhbGUueCh2YWx1ZXNbMF0ueCk7XHJcblx0XHRcdFx0XHR5MCA9ICQkLmdldFlTY2FsZUJ5SWQoZC5pZCkodmFsdWVzWzBdLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHBhdGggPSBpc1JvdGF0ZWQgPyBgTSAke3kwfSAke3gwfWAgOiBgTSAke3gwfSAke3kwfWA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBwYXRoIHx8IFwiTSAwIDBcIjtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yj86IGJvb2xlYW4pOiBGdW5jdGlvbiB7XHJcblx0XHQvLyBwYXJ0aWFsIGR1cGxpY2F0aW9uIG9mIGdlbmVyYXRlR2V0QmFyUG9pbnRzXHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgeCA9ICQkLmdldFNoYXBlWCgwLCBhcmVhSW5kaWNlcywgISFpc1N1Yik7XHJcblx0XHRjb25zdCB5ID0gJCQuZ2V0U2hhcGVZKCEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgYXJlYU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzQXJlYVR5cGUsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IHlTY2FsZSA9ICQkLmdldFlTY2FsZUJ5SWQuYmluZCgkJCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoJCQuZ2V0U2hhcGVZTWluKGQuaWQpKTtcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gYXJlYU9mZnNldChkLCBpKSB8fCB5MDsgLy8gb2Zmc2V0IGlzIGZvciBzdGFja2VkIGFyZWEgY2hhcnRcclxuXHRcdFx0Y29uc3QgcG9zWCA9IHgoZCk7XHJcblx0XHRcdGxldCBwb3NZID0geShkKTtcclxuXHJcblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCAmJiAoXHJcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcclxuXHRcdFx0KSkge1xyXG5cdFx0XHRcdHBvc1kgPSB5MDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gMSBwb2ludCB0aGF0IG1hcmtzIHRoZSBhcmVhIHBvc2l0aW9uXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0sXHJcblx0XHRcdFx0W3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSxcclxuXHRcdFx0XHRbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldLCAvLyBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSAvLyBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5TdGVwKHRoYXQsIHk6IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHkgLSBkM01vdXNlKHRoYXQpWzFdKSA8IDMwO1xyXG5cdH0sXHJcblxyXG5cdHNob3VsZERyYXdQb2ludHNGb3JMaW5lKGQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IGxpbmVQb2ludCA9IHRoaXMuY29uZmlnLmxpbmVfcG9pbnQ7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmVQb2ludCA9PT0gdHJ1ZSB8fFxyXG5cdFx0XHQoaXNBcnJheShsaW5lUG9pbnQpICYmIGxpbmVQb2ludC5pbmRleE9mKGQuaWQpICE9PSAtMSk7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdG5hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzLFxyXG5cdG1vdXNlIGFzIGQzTW91c2UsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IHtnZXRCb3VuZGluZ1JlY3QsIGdldFJhbmRvbSwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzT2JqZWN0VHlwZSwgaXNWYWx1ZSwgdG9BcnJheSwgbm90RW1wdHl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuY29uc3QgZ2V0VHJhbnNpdGlvbk5hbWUgPSAoKSA9PiBnZXRSYW5kb20oKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRoYXNWYWxpZFBvaW50VHlwZSh0eXBlPzogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL14oY2lyY2xlfHJlY3QoYW5nbGUpP3xwb2x5Z29ufGVsbGlwc2V8dXNlKSQvaS50ZXN0KHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZSk7XHJcblx0fSxcclxuXHJcblx0aGFzVmFsaWRQb2ludERyYXdNZXRob2RzKHR5cGU/OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHBvaW50VHlwZSA9IHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZTtcclxuXHJcblx0XHRyZXR1cm4gaXNPYmplY3RUeXBlKHBvaW50VHlwZSkgJiZcclxuXHRcdFx0aXNGdW5jdGlvbihwb2ludFR5cGUuY3JlYXRlKSAmJiBpc0Z1bmN0aW9uKHBvaW50VHlwZS51cGRhdGUpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlKGQpOiBcIjFcIiB8IFwiMFwiIHtcclxuXHRcdGNvbnN0IHt3aXRob3V0RmFkZUlufSA9IHRoaXMuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXHJcblx0XHRcdHdpdGhvdXRGYWRlSW5bZC5pZF0gPyB0aGlzLm9wYWNpdHlGb3JDaXJjbGUoZCkgOiBcIjBcIjtcclxuXHR9LFxyXG5cclxuXHRvcGFjaXR5Rm9yQ2lyY2xlKGQpOiBcIjAuNVwiIHwgXCIxXCIgfCBcIjBcIiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBvcGFjaXR5ID0gY29uZmlnLnBvaW50X3Nob3cgJiYgIWNvbmZpZy5wb2ludF9mb2N1c19vbmx5ID8gXCIxXCIgOiBcIjBcIjtcclxuXHJcblx0XHRyZXR1cm4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkgP1xyXG5cdFx0XHQodGhpcy5pc0J1YmJsZVR5cGUoZCkgfHwgdGhpcy5pc1NjYXR0ZXJUeXBlKGQpID9cclxuXHRcdFx0XHRcIjAuNVwiIDogb3BhY2l0eSkgOiBcIjBcIjtcclxuXHR9LFxyXG5cclxuXHRpbml0Q2lyY2xlKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0JCQucG9pbnQgPSAkJC5nZW5lcmF0ZVBvaW50KCk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydENpcmNsZXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldEZvckNpcmNsZSh0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBkYXRhLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gdCB8fCBkYXRhLnRhcmdldHM7XHJcblx0XHRjb25zdCBjbGFzc0NpcmNsZXMgPSAkJC5jbGFzc0NpcmNsZXMuYmluZCgkJCk7XHJcblxyXG5cdFx0aWYgKCEkZWwuY2lyY2xlICYmIGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdCQkLmluaXRDaXJjbGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYWluQ2lyY2xlID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydENpcmNsZXN9YClcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NpcmNsZXMpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5DaXJjbGVFbnRlciA9IG1haW5DaXJjbGUuZW50ZXIoKTtcclxuXHJcblx0XHQvLyBDaXJjbGVzIGZvciBlYWNoIGRhdGEgcG9pbnQgb24gbGluZXNcclxuXHRcdGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIG1haW5DaXJjbGVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlcywgZC5pZCkpO1xyXG5cclxuXHRcdG1haW5DaXJjbGVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaXJjbGVzKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkgPyBcInBvaW50ZXJcIiA6IG51bGwpKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgZGF0ZSBmb3Igc2VsZWN0ZWQgY2lyY2xlc1xyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHQkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHQuaWQpfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgJHtDTEFTUy5zZWxlY3RlZENpcmNsZX1gKVxyXG5cdFx0XHRcdC5lYWNoKGQgPT4ge1xyXG5cdFx0XHRcdFx0ZC52YWx1ZSA9IHQudmFsdWVzW2QuaW5kZXhdLnZhbHVlO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQ2lyY2xlKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgZm9jdXNPbmx5ID0gY29uZmlnLnBvaW50X2ZvY3VzX29ubHk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdGNvbnN0IGNpcmNsZXMgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGV9YClcclxuXHRcdFx0XHQuZGF0YShkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGRhdGEgPSAhJCQuaXNCYXJUeXBlKGQpICYmIChcclxuXHRcdFx0XHRcdFx0ISQkLmlzTGluZVR5cGUoZCkgfHwgJCQuc2hvdWxkRHJhd1BvaW50c0ZvckxpbmUoZClcclxuXHRcdFx0XHRcdCkgJiYgJCQubGFiZWxpc2hEYXRhKGQpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBmb2N1c09ubHkgPyBbZGF0YVswXV0gOiBkYXRhO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y2lyY2xlcy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRjb25zdCBmbiA9ICQkLnBvaW50KFwiY3JlYXRlXCIsIHRoaXMsICQkLnBvaW50Ui5iaW5kKCQkKSwgJCQuY29sb3IpO1xyXG5cclxuXHRcdFx0Y2lyY2xlcy5lbnRlcigpXHJcblx0XHRcdFx0LmFwcGVuZChmbilcclxuXHRcdFx0XHQubWVyZ2UoY2lyY2xlcylcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5pbml0aWFsT3BhY2l0eUZvckNpcmNsZS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0XHQkZWwuY2lyY2xlID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfSAuJHtDTEFTUy5jaXJjbGV9YCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVkcmF3Q2lyY2xlKGN4OiBGdW5jdGlvbiwgY3k6IEZ1bmN0aW9uLCB3aXRoVHJhbnNpdGlvbjogYm9vbGVhbiwgZmxvdykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7cmVuZGVyZWR9LCAkZWw6IHtjaXJjbGUsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2VsZWN0ZWRDaXJjbGVzID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfWApO1xyXG5cclxuXHRcdGlmICghJCQuY29uZmlnLnBvaW50X3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJ1cGRhdGVcIiwgJCQsIGN4LCBjeSwgJCQuY29sb3IsIHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpO1xyXG5cdFx0Y29uc3QgcG9zQXR0ciA9ICQkLmlzQ2lyY2xlUG9pbnQoKSA/IFwiY1wiIDogXCJcIjtcclxuXHJcblx0XHRjb25zdCB0OiBhbnkgPSBnZXRSYW5kb20oKTtcclxuXHRcdGNvbnN0IG9wYWNpdHlTdHlsZUZuID0gJCQub3BhY2l0eUZvckNpcmNsZS5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCBtYWluQ2lyY2xlczogYW55W10gPSBbXTtcclxuXHJcblx0XHRjaXJjbGUuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdGxldCByZXN1bHQ6IGQzU2VsZWN0aW9uIHwgYW55ID0gZm4uYmluZCh0aGlzKShkKTtcclxuXHJcblx0XHRcdHJlc3VsdCA9ICgod2l0aFRyYW5zaXRpb24gfHwgIXJlbmRlcmVkKSA/IHJlc3VsdC50cmFuc2l0aW9uKHQpIDogcmVzdWx0KVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eVN0eWxlRm4pO1xyXG5cclxuXHRcdFx0bWFpbkNpcmNsZXMucHVzaChyZXN1bHQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0bWFpbkNpcmNsZXMsXHJcblx0XHRcdHNlbGVjdGVkQ2lyY2xlc1xyXG5cdFx0XHRcdC5hdHRyKGAke3Bvc0F0dHJ9eGAsIGN4KVxyXG5cdFx0XHRcdC5hdHRyKGAke3Bvc0F0dHJ9eWAsIGN5KVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IGZvY3VzZWQgZGF0YSBwb2ludCBjaXJjbGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBTZWxlY3RlZCBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzaG93Q2lyY2xlRm9jdXMoZD8pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKHN0YXRlLnRyYW5zaXRpbmcgPT09IGZhbHNlICYmIGNvbmZpZy5wb2ludF9mb2N1c19vbmx5KSB7XHJcblx0XHRcdGxldCB7Y2lyY2xlfSA9ICRlbDtcclxuXHRcdFx0Y29uc3Qge2hhc1JhZGFyfSA9IHN0YXRlO1xyXG5cdFx0XHRjb25zdCBjeCA9IChoYXNSYWRhciA/ICQkLnJhZGFyQ2lyY2xlWCA6ICQkLmNpcmNsZVgpLmJpbmQoJCQpO1xyXG5cdFx0XHRjb25zdCBjeSA9IChoYXNSYWRhciA/ICQkLnJhZGFyQ2lyY2xlWSA6ICQkLmNpcmNsZVkpLmJpbmQoJCQpO1xyXG5cdFx0XHRjb25zdCBmbiA9ICQkLnBvaW50KFwidXBkYXRlXCIsICQkLCBjeCwgY3ksICQkLmNvbG9yLCBmYWxzZSk7XHJcblxyXG5cdFx0XHRpZiAoZCkge1xyXG5cdFx0XHRcdGNpcmNsZSA9IGNpcmNsZVxyXG5cdFx0XHRcdFx0LmZpbHRlcih0ID0+IGQuc29tZSh2ID0+IHYuaWQgPT09IHQuaWQpKVxyXG5cdFx0XHRcdFx0LmRhdGEoZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNpcmNsZVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgdGhpcy51cGRhdGVQb2ludENsYXNzLmJpbmQodGhpcykpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNWYWx1ZShkLnZhbHVlKSkge1xyXG5cdFx0XHRcdFx0XHRmbi5iaW5kKHRoaXMpKGQpO1xyXG5cdFx0XHRcdFx0XHQkJC5leHBhbmRDaXJjbGVzKGQuaW5kZXgsIGQuaWQpO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnN0eWxlLnZpc2liaWxpdHkgPSBcIlwiO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcclxuXHRcdFx0XHRcdFx0JCQudW5leHBhbmRDaXJjbGVzKGQuaW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgZm9jdXNlZCBkYXRhIHBvaW50IGNpcmNsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGlkZUNpcmNsZUZvY3VzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcucG9pbnRfZm9jdXNfb25seSkge1xyXG5cdFx0XHQkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHRcdFx0JGVsLmNpcmNsZS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y2lyY2xlWChkKTogbnVtYmVyIHwgbnVsbCB7XHJcblx0XHRyZXR1cm4gdGhpcy54eChkKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVDaXJjbGVZKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKCQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKSwgZmFsc2UpO1xyXG5cclxuXHRcdCQkLmNpcmNsZVkgPSAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCBpZCA9IGQuaWQ7XHJcblxyXG5cdFx0XHRyZXR1cm4gJCQuaXNHcm91cGVkKGlkKSA/XHJcblx0XHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzBdWzFdIDpcclxuXHRcdFx0XHQkJC5nZXRZU2NhbGVCeUlkKGlkKSgkJC5nZXRCYXNlVmFsdWUoZCkpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRDaXJjbGVzKGk6IG51bWJlciwgaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xyXG5cclxuXHRcdHJldHVybiAoaWQgPyAkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiAkJC4kZWwubWFpbilcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlfSR7c3VmZml4fWApO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZENpcmNsZXMoaTogbnVtYmVyLCBpZDogc3RyaW5nLCByZXNldD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHIgPSAkJC5wb2ludEV4cGFuZGVkUi5iaW5kKCQkKTtcclxuXHJcblx0XHRyZXNldCAmJiAkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHJcblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpLCBpZCkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XHJcblx0XHRjb25zdCBzY2FsZSA9IHIoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcjtcclxuXHRcdGNvbnN0IHJhdGlvID0gMSAtIHNjYWxlO1xyXG5cclxuXHRcdGlmICgkJC5pc0NpcmNsZVBvaW50KCkpIHtcclxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwiclwiLCByKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHRyYW5zZm9ybSBtdXN0IGJlIGFwcGxpZWQgdG8gZWFjaCBub2RlIGluZGl2aWR1YWxseVxyXG5cdFx0XHRjaXJjbGVzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMudGFnTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInJcIiwgcik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuZ2V0QkJveCgpO1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHJhdGlvICogKCtwb2ludC5hdHRyKFwieFwiKSArIHdpZHRoIC8gMik7XHJcblx0XHRcdFx0XHRjb25zdCB5ID0gcmF0aW8gKiAoK3BvaW50LmF0dHIoXCJ5XCIpICsgaGVpZ2h0IC8gMik7XHJcblxyXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eH0gJHt5fSkgc2NhbGUoJHtzY2FsZX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1bmV4cGFuZENpcmNsZXMoaSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgciA9ICQkLnBvaW50Ui5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVEKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIGZhbHNlKTtcclxuXHJcblx0XHRjaXJjbGVzLmF0dHIoXCJyXCIsIHIpO1xyXG5cclxuXHRcdCEkJC5pc0NpcmNsZVBvaW50KCkgJiZcclxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3IoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcn0pYCk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRSKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0bGV0IHIgPSBwb2ludFI7XHJcblxyXG5cdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcclxuXHRcdFx0ciA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlVHlwZShkKSkge1xyXG5cdFx0XHRyID0gJCQuZ2V0QnViYmxlUihkKTtcclxuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwb2ludFIpKSB7XHJcblx0XHRcdHIgPSBwb2ludFIuYmluZCgkJC5hcGkpKGQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50RXhwYW5kZWRSKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHNjYWxlID0gJCQuaXNCdWJibGVUeXBlKGQpID8gMS4xNSA6IDEuNzU7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCA/XHJcblx0XHRcdChjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX3IgfHwgJCQucG9pbnRSKGQpICogc2NhbGUpIDogJCQucG9pbnRSKGQpO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50U2VsZWN0UihkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNlbGVjdFIgPSAkJC5jb25maWcucG9pbnRfc2VsZWN0X3I7XHJcblxyXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oc2VsZWN0UikgP1xyXG5cdFx0XHRzZWxlY3RSKGQpIDogKHNlbGVjdFIgfHwgJCQucG9pbnRSKGQpICogNCk7XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5DaXJjbGUobm9kZSwgcj86IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKG5vZGUpO1xyXG5cdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KG5vZGUpO1xyXG5cdFx0Y29uc3QgcHJlZml4ID0gdGhpcy5pc0NpcmNsZVBvaW50KG5vZGUpID8gXCJjXCIgOiBcIlwiO1xyXG5cdFx0bGV0IGN4ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eGApO1xyXG5cdFx0bGV0IGN5ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eWApO1xyXG5cclxuXHRcdC8vIGlmIG5vZGUgZG9uJ3QgaGF2ZSBjeC95IG9yIHgveSBhdHRyaWJ1dGUgdmFsdWVcclxuXHRcdGlmICghKGN4IHx8IGN5KSAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XHJcblx0XHRcdGNvbnN0IHt4LCB5fSA9IGdldEJvdW5kaW5nUmVjdChub2RlKTtcclxuXHJcblx0XHRcdGN4ID0geDtcclxuXHRcdFx0Y3kgPSB5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoXHJcblx0XHRcdE1hdGgucG93KGN4IC0gbW91c2VbMF0sIDIpICsgTWF0aC5wb3coY3kgLSBtb3VzZVsxXSwgMilcclxuXHRcdCkgPCAociB8fCB0aGlzLmNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSk7XHJcblx0fSxcclxuXHJcblx0aW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgaWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY29weUF0dHIgPSAoZnJvbSwgdGFyZ2V0KSA9PiB7XHJcblx0XHRcdGNvbnN0IGF0dHJpYnMgPSBmcm9tLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbmFtZTsgKG5hbWUgPSBhdHRyaWJzW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0bmFtZSA9IG5hbWUubmFtZTtcclxuXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIGZyb20uZ2V0QXR0cmlidXRlKG5hbWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHBvaW50LCBcImltYWdlL3N2Zyt4bWxcIik7XHJcblx0XHRjb25zdCBub2RlID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XHJcblxyXG5cdFx0Y2xvbmUuaWQgPSBpZDtcclxuXHRcdGNsb25lLnN0eWxlLmZpbGwgPSBcImluaGVyaXRcIjtcclxuXHRcdGNsb25lLnN0eWxlLnN0cm9rZSA9IFwiaW5oZXJpdFwiO1xyXG5cclxuXHRcdGNvcHlBdHRyKG5vZGUsIGNsb25lKTtcclxuXHJcblx0XHRpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZDNTZWxlY3QoY2xvbmUpO1xyXG5cclxuXHRcdFx0aWYgKFwiaW5uZXJIVE1MXCIgaW4gY2xvbmUpIHtcclxuXHRcdFx0XHRwYXJlbnQuaHRtbChub2RlLmlubmVySFRNTCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dG9BcnJheShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb3B5QXR0cih2LCBwYXJlbnQuYXBwZW5kKHYudGFnTmFtZSkubm9kZSgpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCQkLiRlbC5kZWZzLm5vZGUoKS5hcHBlbmRDaGlsZChjbG9uZSk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRGcm9tRGVmcyhpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy4kZWwuZGVmcy5zZWxlY3QoYCMke2lkfWApO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVBvaW50Q2xhc3MoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NpcmNsZX0gPSAkJC4kZWw7XHJcblx0XHRsZXQgcG9pbnRDbGFzcyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChkKSB8fCBjaXJjbGUpIHtcclxuXHRcdFx0cG9pbnRDbGFzcyA9IGQgPT09IHRydWUgP1xyXG5cdFx0XHRcdGNpcmNsZS5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGxldCBjbGFzc05hbWUgPSAkJC5jbGFzc0NpcmNsZS5iaW5kKCQkKShkKTtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5pbmRleE9mKENMQVNTLkVYUEFOREVEKSA+IC0xKSB7XHJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSArPSBgICR7Q0xBU1MuRVhQQU5ERUR9YDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNsYXNzTmFtZSk7XHJcblx0XHRcdFx0fSkgOiAkJC5jbGFzc0NpcmNsZShkKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnRDbGFzcztcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVBvaW50KCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7ZGF0ZXRpbWVJZH19ID0gJCQ7XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID8gY29uZmlnLnBvaW50X3BhdHRlcm4gOiBbY29uZmlnLnBvaW50X3R5cGVdO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIC4uLmFyZ3MpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBpZDogc3RyaW5nID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcclxuXHRcdFx0XHRjb25zdCBlbGVtZW50ID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdGlkcy5pbmRleE9mKGlkKSA8IDAgJiYgaWRzLnB1c2goaWQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcclxuXHJcblx0XHRcdFx0aWYgKCQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0cG9pbnQgPSAkJFtwb2ludF07XHJcblx0XHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVmFsaWRQb2ludERyYXdNZXRob2RzKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcG9pbnRJZCA9IGAke2RhdGV0aW1lSWR9LXBvaW50LSR7aWR9YDtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50RnJvbURlZnMgPSAkJC5wb2ludEZyb21EZWZzKHBvaW50SWQpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChwb2ludEZyb21EZWZzLnNpemUoKSA8IDEpIHtcclxuXHRcdFx0XHRcdFx0JCQuaW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgcG9pbnRJZCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1ldGhvZCA9PT0gXCJjcmVhdGVcIikge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuY3VzdG9tLmNyZWF0ZS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIHBvaW50SWQsIC4uLmFyZ3MpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtZXRob2QgPT09IFwidXBkYXRlXCIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmN1c3RvbS51cGRhdGUuYmluZChjb250ZXh0KShlbGVtZW50LCAuLi5hcmdzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBwb2ludFttZXRob2RdLmJpbmQoY29udGV4dCkoZWxlbWVudCwgLi4uYXJncyk7XHJcblx0XHRcdH07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGN1c3RvbToge1xyXG5cdFx0Y3JlYXRlKGVsZW1lbnQsIGlkLCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcInVzZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieGxpbms6aHJlZlwiLCBgIyR7aWR9YClcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIHRoaXMudXBkYXRlUG9pbnRDbGFzcy5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBmaWxsU3R5bGVGbixcclxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xyXG5cdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50Lm5vZGUoKS5nZXRCQm94KCk7XHJcblxyXG5cdFx0XHRjb25zdCB4UG9zRm4yID0gZCA9PiB4UG9zRm4oZCkgLSB3aWR0aCAvIDI7XHJcblx0XHRcdGNvbnN0IHlQb3NGbjIgPSBkID0+IHlQb3NGbihkKSAtIGhlaWdodCAvIDI7XHJcblx0XHRcdGxldCBtYWluQ2lyY2xlcyA9IGVsZW1lbnQ7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uTmFtZSA9IGdldFRyYW5zaXRpb25OYW1lKCk7XHJcblxyXG5cdFx0XHRcdGZsb3cgJiYgbWFpbkNpcmNsZXMuYXR0cihcInhcIiwgeFBvc0ZuMik7XHJcblxyXG5cdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXMudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSk7XHJcblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCB4UG9zRm4yKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCB5UG9zRm4yKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vICdjaXJjbGUnIGRhdGEgcG9pbnRcclxuXHRjaXJjbGU6IHtcclxuXHRcdGNyZWF0ZShlbGVtZW50LCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcImNpcmNsZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgdGhpcy51cGRhdGVQb2ludENsYXNzLmJpbmQodGhpcykpXHJcblx0XHRcdFx0LmF0dHIoXCJyXCIsIHNpemVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0Ly8gd2hlbiAnLmxvYWQoKScgY2FsbGVkLCBidWJibGUgc2l6ZSBzaG91bGQgYmUgdXBkYXRlZFxyXG5cdFx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSkge1xyXG5cdFx0XHRcdG1haW5DaXJjbGVzLmF0dHIoXCJyXCIsICQkLnBvaW50Ui5iaW5kKCQkKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdGNvbnN0IHRyYW5zaXRpb25OYW1lID0gZ2V0VHJhbnNpdGlvbk5hbWUoKTtcclxuXHJcblx0XHRcdFx0ZmxvdyAmJiBtYWluQ2lyY2xlcy5hdHRyKFwiY3hcIiwgeFBvc0ZuKTtcclxuXHJcblx0XHRcdFx0aWYgKG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiKSkge1xyXG5cdFx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlcy50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKGdldFRyYW5zaXRpb25OYW1lKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihcImN4XCIsIHhQb3NGbilcclxuXHRcdFx0XHQuYXR0cihcImN5XCIsIHlQb3NGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyAncmVjdGFuZ2xlJyBkYXRhIHBvaW50XHJcblx0cmVjdGFuZ2xlOiB7XHJcblx0XHRjcmVhdGUoZWxlbWVudCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xyXG5cdFx0XHRjb25zdCByZWN0U2l6ZUZuID0gZCA9PiBzaXplRm4oZCkgKiAyLjA7XHJcblxyXG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHJlY3RTaXplRm4pXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgcmVjdFNpemVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0XHRjb25zdCByID0gJCQuY29uZmlnLnBvaW50X3I7XHJcblx0XHRcdGNvbnN0IHJlY3RYUG9zRm4gPSBkID0+IHhQb3NGbihkKSAtIHI7XHJcblx0XHRcdGNvbnN0IHJlY3RZUG9zRm4gPSBkID0+IHlQb3NGbihkKSAtIHI7XHJcblxyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSBnZXRUcmFuc2l0aW9uTmFtZSgpO1xyXG5cclxuXHRcdFx0XHRmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJ4XCIsIHJlY3RYUG9zRm4pO1xyXG5cclxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKGdldFRyYW5zaXRpb25OYW1lKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgcmVjdFhQb3NGbilcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgcmVjdFlQb3NGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRjdXJ2ZVN0ZXBCZWZvcmUgYXMgZDNDdXJ2ZVN0ZXBCZWZvcmUsXHJcblx0Y3VydmVTdGVwQWZ0ZXIgYXMgZDNDdXJ2ZVN0ZXBBZnRlcixcclxuXHRjdXJ2ZUJhc2lzQ2xvc2VkIGFzIGQzQ3VydmVCYXNpc0Nsb3NlZCxcclxuXHRjdXJ2ZUJhc2lzT3BlbiBhcyBkM0N1cnZlQmFzaXNPcGVuLFxyXG5cdGN1cnZlQmFzaXMgYXMgZDNDdXJ2ZUJhc2lzLFxyXG5cdGN1cnZlQnVuZGxlIGFzIGQzQ3VydmVCdW5kbGUsXHJcblx0Y3VydmVDYXJkaW5hbENsb3NlZCBhcyBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXHJcblx0Y3VydmVDYXJkaW5hbE9wZW4gYXMgZDNDdXJ2ZUNhcmRpbmFsT3BlbixcclxuXHRjdXJ2ZUNhcmRpbmFsIGFzIGQzQ3VydmVDYXJkaW5hbCxcclxuXHRjdXJ2ZUNhdG11bGxSb21DbG9zZWQgYXMgZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXHJcblx0Y3VydmVDYXRtdWxsUm9tT3BlbiBhcyBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXHJcblx0Y3VydmVDYXRtdWxsUm9tIGFzIGQzQ3VydmVDYXRtdWxsUm9tLFxyXG5cdGN1cnZlTGluZWFyQ2xvc2VkIGFzIGQzQ3VydmVMaW5lYXJDbG9zZWQsXHJcblx0Y3VydmVMaW5lYXIgYXMgZDNDdXJ2ZUxpbmVhcixcclxuXHRjdXJ2ZU1vbm90b25lWCBhcyBkM0N1cnZlTW9ub3RvbmVYLFxyXG5cdGN1cnZlTW9ub3RvbmVZIGFzIGQzQ3VydmVNb25vdG9uZVksXHJcblx0Y3VydmVOYXR1cmFsIGFzIGQzQ3VydmVOYXR1cmFsLFxyXG5cdGN1cnZlU3RlcCBhcyBkM0N1cnZlU3RlcFxyXG59IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0VW5pcXVlLCBpc09iamVjdFR5cGUsIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgbm90RW1wdHl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgc2hhcGUgZHJhdyBmdW5jdGlvblxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXREcmF3U2hhcGUoKSB7XHJcblx0XHR0eXBlIFNIQVBFID0ge1xyXG5cdFx0XHRhcmVhPzogYW55O1xyXG5cdFx0XHRiYXI/OiBhbnk7XHJcblx0XHRcdGxpbmU/OiBhbnk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCB7aGFzUmFkYXJ9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBzaGFwZSA9IHt0eXBlOiA8U0hBUEU+IHt9LCBpbmRpY2VzOiA8U0hBUEU+IHt9LCBwb3M6IHt9fTtcclxuXHJcblx0XHQvLyBzZXR1cCBkcmF3ZXIgLSBNRU1POiB0aGVzZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBheGlzIHVwZGF0ZWRcclxuXHRcdGlmICgkJC5oYXNUeXBlT2YoXCJMaW5lXCIpIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzVHlwZShcInNjYXR0ZXJcIikpIHtcclxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKTtcclxuXHJcblx0XHRcdHNoYXBlLmluZGljZXMubGluZSA9IGluZGljZXM7XHJcblx0XHRcdHNoYXBlLnR5cGUubGluZSA9ICQkLmdlbmVyYXRlRHJhd0xpbmUgPyAkJC5nZW5lcmF0ZURyYXdMaW5lKGluZGljZXMsIGZhbHNlKSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlT2YoXCJBcmVhXCIpKSB7XHJcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0FyZWFUeXBlKTtcclxuXHJcblx0XHRcdFx0c2hhcGUuaW5kaWNlcy5hcmVhID0gaW5kaWNlcztcclxuXHRcdFx0XHRzaGFwZS50eXBlLmFyZWEgPSAkJC5nZW5lcmF0ZURyYXdBcmVhID8gJCQuZ2VuZXJhdGVEcmF3QXJlYShpbmRpY2VzLCBmYWxzZSkgOiB1bmRlZmluZWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xyXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzQmFyVHlwZSk7XHJcblxyXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmJhciA9IGluZGljZXM7XHJcblx0XHRcdHNoYXBlLnR5cGUuYmFyID0gJCQuZ2VuZXJhdGVEcmF3QmFyID8gJCQuZ2VuZXJhdGVEcmF3QmFyKGluZGljZXMpIDogdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghJCQuaGFzQXJjVHlwZSgpIHx8IGhhc1JhZGFyKSB7XHJcblx0XHRcdHNoYXBlLnBvcyA9IHtcclxuXHRcdFx0XHR4Rm9yVGV4dDogJCQuZ2VuZXJhdGVYWUZvclRleHQoc2hhcGUuaW5kaWNlcywgdHJ1ZSksXHJcblx0XHRcdFx0eUZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsIGZhbHNlKSxcclxuXHJcblx0XHRcdFx0Ly8gZ2VuZXJhdGUgY2lyY2xlIHgveSBmdW5jdGlvbnMgZGVwZW5kaW5nIG9uIHVwZGF0ZWQgcGFyYW1zXHJcblx0XHRcdFx0Y3g6IChoYXNSYWRhciA/ICQkLnJhZGFyQ2lyY2xlWCA6IChpc1JvdGF0ZWQgPyAkJC5jaXJjbGVZIDogJCQuY2lyY2xlWCkpLmJpbmQoJCQpLFxyXG5cdFx0XHRcdGN5OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVkgOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpKS5iaW5kKCQkKVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzaGFwZTtcclxuXHR9LFxyXG5cclxuXHRnZXRTaGFwZUluZGljZXModHlwZUZpbHRlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHhzID0gY29uZmlnLmRhdGFfeHM7XHJcblx0XHRjb25zdCBoYXNYcyA9IG5vdEVtcHR5KHhzKTtcclxuXHRcdGNvbnN0IGluZGljZXMgPSB7fTtcclxuXHRcdGxldCBpOiBhbnkgPSBoYXNYcyA/IHt9IDogMDtcclxuXHJcblx0XHRpZiAoaGFzWHMpIHtcclxuXHRcdFx0Z2V0VW5pcXVlKE9iamVjdC5rZXlzKHhzKS5tYXAodiA9PiB4c1t2XSkpXHJcblx0XHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRpW3ZdID0gMDtcclxuXHRcdFx0XHRcdGluZGljZXNbdl0gPSB7fTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cy5maWx0ZXIodHlwZUZpbHRlciwgJCQpKVxyXG5cdFx0XHQuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0XHRjb25zdCB4S2V5ID0gZC5pZCBpbiB4cyA/IHhzW2QuaWRdIDogXCJcIjtcclxuXHRcdFx0XHRjb25zdCBpbmQgPSB4S2V5ID8gaW5kaWNlc1t4S2V5XSA6IGluZGljZXM7XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGogPSAwLCBncm91cHM7IChncm91cHMgPSBjb25maWcuZGF0YV9ncm91cHNbal0pOyBqKyspIHtcclxuXHRcdFx0XHRcdGlmIChncm91cHMuaW5kZXhPZihkLmlkKSA8IDApIHtcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgayA9IDAsIHJvdzsgKHJvdyA9IGdyb3Vwc1trXSk7IGsrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAocm93IGluIGluZCkge1xyXG5cdFx0XHRcdFx0XHRcdGluZFtkLmlkXSA9IGluZFtyb3ddO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNVbmRlZmluZWQoaW5kW2QuaWRdKSkge1xyXG5cdFx0XHRcdFx0aW5kW2QuaWRdID0geEtleSA/IGlbeEtleV0rKyA6IGkrKztcclxuXHRcdFx0XHRcdGluZC5fX21heF9fID0gKHhLZXkgPyBpW3hLZXldIDogaSkgLSAxO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGluZGljZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGluZGljZXMgdmFsdWUgYmFzZWQgb24gZGF0YSBJRCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBpbmRpY2VzIEluZGljZXMgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIERhdGEgaWQgdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBJbmRpY2VzIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kaWNlcyhpbmRpY2VzLCBpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCB4cyA9IHRoaXMuY29uZmlnLmRhdGFfeHM7XHJcblxyXG5cdFx0cmV0dXJuIG5vdEVtcHR5KHhzKSA/XHJcblx0XHRcdGluZGljZXNbeHNbaWRdXSA6IGluZGljZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGluZGljZXMgbWF4IG51bWJlclxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBpbmRpY2VzIEluZGljZXMgb2JqZWN0XHJcblx0ICogQHJldHVybnMge251bWJlcn0gTWF4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kaWNlc01heChpbmRpY2VzKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBub3RFbXB0eSh0aGlzLmNvbmZpZy5kYXRhX3hzKSA/XHJcblx0XHRcdC8vIGlmIGlzIG11bHRpcGxlIHhzLCByZXR1cm4gdG90YWwgc3VtIG9mIHhzJyBfX21heF9fIHZhbHVlXHJcblx0XHRcdE9iamVjdC5rZXlzKGluZGljZXMpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IGluZGljZXNbdl0uX19tYXhfXyB8fCAwKVxyXG5cdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3VycikgOiBpbmRpY2VzLl9fbWF4X187XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVYKG9mZnNldCwgaW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogKGQpID0+IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGN1cnJTY2FsZSA9IGlzU3ViID8gc2NhbGUuc3ViWCA6IChzY2FsZS56b29tIHx8IHNjYWxlLngpO1xyXG5cdFx0Y29uc3QgYmFyUGFkZGluZyA9IGNvbmZpZy5iYXJfcGFkZGluZztcclxuXHRcdGNvbnN0IHN1bSA9IChwLCBjKSA9PiBwICsgYztcclxuXHRcdGNvbnN0IGhhbGZXaWR0aCA9IGlzT2JqZWN0VHlwZShvZmZzZXQpICYmIG9mZnNldC50b3RhbC5sZW5ndGggPyBvZmZzZXQudG90YWwucmVkdWNlKHN1bSkgLyAyIDogMDtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGNvbnN0IGluZCA9ICQkLmdldEluZGljZXMoaW5kaWNlcywgZC5pZCk7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gZC5pZCBpbiBpbmQgPyBpbmRbZC5pZF0gOiAwO1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzTnVtID0gKGluZC5fX21heF9fIHx8IDApICsgMTtcclxuXHRcdFx0bGV0IHggPSAwO1xyXG5cclxuXHRcdFx0aWYgKG5vdEVtcHR5KGQueCkpIHtcclxuXHRcdFx0XHRjb25zdCB4UG9zID0gY3VyclNjYWxlKGQueCk7XHJcblxyXG5cdFx0XHRcdGlmIChoYWxmV2lkdGgpIHtcclxuXHRcdFx0XHRcdHggPSB4UG9zIC0gKG9mZnNldFtkLmlkXSB8fCBvZmZzZXQud2lkdGgpICtcclxuXHRcdFx0XHRcdFx0b2Zmc2V0LnRvdGFsLnNsaWNlKDAsIGluZGV4ICsgMSkucmVkdWNlKHN1bSkgLVxyXG5cdFx0XHRcdFx0XHRoYWxmV2lkdGg7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHggPSB4UG9zIC0gKGlzTnVtYmVyKG9mZnNldCkgPyBvZmZzZXQgOiBvZmZzZXQud2lkdGgpICogKHRhcmdldHNOdW0gLyAyIC0gaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYWRqdXN0IHggcG9zaXRpb24gZm9yIGJhci5wYWRkaW5nIG9wdGlvbnFcclxuXHRcdFx0aWYgKG9mZnNldCAmJiB4ICYmIHRhcmdldHNOdW0gPiAxICYmIGJhclBhZGRpbmcpIHtcclxuXHRcdFx0XHRpZiAoaW5kZXgpIHtcclxuXHRcdFx0XHRcdHggKz0gYmFyUGFkZGluZyAqIGluZGV4O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHRhcmdldHNOdW0gPiAyKSB7XHJcblx0XHRcdFx0XHR4IC09ICh0YXJnZXRzTnVtIC0gMSkgKiBiYXJQYWRkaW5nIC8gMjtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldHNOdW0gPT09IDIpIHtcclxuXHRcdFx0XHRcdHggLT0gYmFyUGFkZGluZyAvIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4geDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVZKGlzU3ViPzogYm9vbGVhbik6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzU3RhY2tOb3JtYWxpemVkID0gJCQuaXNTdGFja05vcm1hbGl6ZWQoKTtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGNvbnN0IHZhbHVlID0gaXNTdGFja05vcm1hbGl6ZWQgPyAkJC5nZXRSYXRpbyhcImluZGV4XCIsIGQsIHRydWUpIDogKFxyXG5cdFx0XHRcdCQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInlcIikgOiBkLnZhbHVlXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gJCQuZ2V0WVNjYWxlQnlJZChkLmlkLCBpc1N1YikodmFsdWUpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgc2hhcGUgYmFzZWQgeSBBeGlzIG1pbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBEYXRhIGlkXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFNoYXBlWU1pbihpZDogc3RyaW5nKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IFt5TWluXSA9ICQkLnNjYWxlWyQkLmF4aXMuZ2V0SWQoaWQpXS5kb21haW4oKTtcclxuXHJcblx0XHRyZXR1cm4gISQkLmlzR3JvdXBlZChpZCkgJiYgeU1pbiA+IDAgPyB5TWluIDogMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgU2hhcGUncyBvZmZzZXQgZGF0YVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHR5cGVGaWx0ZXIgVHlwZSBmaWx0ZXIgZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0U2hhcGVPZmZzZXREYXRhKHR5cGVGaWx0ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5vcmRlclRhcmdldHMoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKSkpO1xyXG5cdFx0Y29uc3QgaXNTdGFja05vcm1hbGl6ZWQgPSAkJC5pc1N0YWNrTm9ybWFsaXplZCgpO1xyXG5cclxuXHRcdGNvbnN0IHNoYXBlT2Zmc2V0VGFyZ2V0cyA9IHRhcmdldHMubWFwKHRhcmdldCA9PiB7XHJcblx0XHRcdGxldCByb3dWYWx1ZXMgPSB0YXJnZXQudmFsdWVzO1xyXG5cdFx0XHRjb25zdCB2YWx1ZXMgPSB7fTtcclxuXHJcblx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKHRhcmdldCkpIHtcclxuXHRcdFx0XHRyb3dWYWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHJvd1ZhbHVlcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IHJvd1ZhbHVlTWFwQnlYVmFsdWUgPSByb3dWYWx1ZXMucmVkdWNlKChvdXQsIGQpID0+IHtcclxuXHRcdFx0XHRjb25zdCBrZXkgPSBOdW1iZXIoZC54KTtcclxuXHJcblx0XHRcdFx0b3V0W2tleV0gPSBkO1xyXG5cdFx0XHRcdHZhbHVlc1trZXldID0gaXNTdGFja05vcm1hbGl6ZWQgPyAkJC5nZXRSYXRpbyhcImluZGV4XCIsIGQsIHRydWUpIDogZC52YWx1ZTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG91dDtcclxuXHRcdFx0fSwge30pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRpZDogdGFyZ2V0LmlkLFxyXG5cdFx0XHRcdHJvd1ZhbHVlcyxcclxuXHRcdFx0XHRyb3dWYWx1ZU1hcEJ5WFZhbHVlLFxyXG5cdFx0XHRcdHZhbHVlc1xyXG5cdFx0XHR9O1xyXG5cdFx0fSk7XHJcblx0XHRjb25zdCBpbmRleE1hcEJ5VGFyZ2V0SWQgPSB0YXJnZXRzLnJlZHVjZSgob3V0LCB7aWR9LCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbaWRdID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0cmV0dXJuIHtpbmRleE1hcEJ5VGFyZ2V0SWQsIHNoYXBlT2Zmc2V0VGFyZ2V0c307XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVPZmZzZXQodHlwZUZpbHRlciwgaW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NoYXBlT2Zmc2V0VGFyZ2V0cywgaW5kZXhNYXBCeVRhcmdldElkfSA9ICQkLmdldFNoYXBlT2Zmc2V0RGF0YSh0eXBlRmlsdGVyKTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGlkeCkgPT4ge1xyXG5cdFx0XHRjb25zdCBpbmQgPSAkJC5nZXRJbmRpY2VzKGluZGljZXMsIGQuaWQpO1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9ICQkLmdldFlTY2FsZUJ5SWQoZC5pZCwgaXNTdWIpO1xyXG5cdFx0XHRjb25zdCB5MCA9IHNjYWxlKCQkLmdldFNoYXBlWU1pbihkLmlkKSk7XHJcblxyXG5cdFx0XHRjb25zdCBkYXRhWEFzTnVtYmVyID0gTnVtYmVyKGQueCk7XHJcblx0XHRcdGxldCBvZmZzZXQgPSB5MDtcclxuXHJcblx0XHRcdHNoYXBlT2Zmc2V0VGFyZ2V0c1xyXG5cdFx0XHRcdC5maWx0ZXIodCA9PiB0LmlkICE9PSBkLmlkKVxyXG5cdFx0XHRcdC5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGluZFt0LmlkXSA9PT0gaW5kW2QuaWRdICYmIGluZGV4TWFwQnlUYXJnZXRJZFt0LmlkXSA8IGluZGV4TWFwQnlUYXJnZXRJZFtkLmlkXSkge1xyXG5cdFx0XHRcdFx0XHRsZXQgcm93ID0gdC5yb3dWYWx1ZXNbaWR4XTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSB4IHZhbHVlcyBsaW5lIHVwXHJcblx0XHRcdFx0XHRcdGlmICghcm93IHx8IE51bWJlcihyb3cueCkgIT09IGRhdGFYQXNOdW1iZXIpIHtcclxuXHRcdFx0XHRcdFx0XHRyb3cgPSB0LnJvd1ZhbHVlTWFwQnlYVmFsdWVbZGF0YVhBc051bWJlcl07XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmIChyb3cgJiYgcm93LnZhbHVlICogZC52YWx1ZSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IHNjYWxlKHQudmFsdWVzW2RhdGFYQXNOdW1iZXJdKSAtIHkwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpblNoYXBlKHRoYXQsIGQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhhdCk7XHJcblx0XHRsZXQgaXNXaXRoaW47XHJcblxyXG5cdFx0aWYgKCEkJC5pc1RhcmdldFRvU2hvdyhkLmlkKSkge1xyXG5cdFx0XHRpc1dpdGhpbiA9IGZhbHNlO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZSh0aGF0Lm5vZGVOYW1lKSkge1xyXG5cdFx0XHRpc1dpdGhpbiA9ICQkLmlzU3RlcFR5cGUoZCkgP1xyXG5cdFx0XHRcdCQkLmlzV2l0aGluU3RlcCh0aGF0LCAkJC5nZXRZU2NhbGVCeUlkKGQuaWQpKGQudmFsdWUpKSA6XHJcblx0XHRcdFx0JCQuaXNXaXRoaW5DaXJjbGUodGhhdCwgJCQuaXNCdWJibGVUeXBlKGQpID8gJCQucG9pbnRTZWxlY3RSKGQpICogMS41IDogMCk7XHJcblx0XHR9IGVsc2UgaWYgKHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiKSB7XHJcblx0XHRcdGlzV2l0aGluID0gc2hhcGUuY2xhc3NlZChDTEFTUy5iYXIpID8gJCQuaXNXaXRoaW5CYXIodGhhdCkgOiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc1dpdGhpbjtcclxuXHR9LFxyXG5cclxuXHRnZXRJbnRlcnBvbGF0ZShkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gJCQuZ2V0SW50ZXJwb2xhdGVUeXBlKGQpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdFwiYmFzaXNcIjogZDNDdXJ2ZUJhc2lzLFxyXG5cdFx0XHRcImJhc2lzLWNsb3NlZFwiOiBkM0N1cnZlQmFzaXNDbG9zZWQsXHJcblx0XHRcdFwiYmFzaXMtb3BlblwiOiBkM0N1cnZlQmFzaXNPcGVuLFxyXG5cdFx0XHRcImJ1bmRsZVwiOiBkM0N1cnZlQnVuZGxlLFxyXG5cdFx0XHRcImNhcmRpbmFsXCI6IGQzQ3VydmVDYXJkaW5hbCxcclxuXHRcdFx0XCJjYXJkaW5hbC1jbG9zZWRcIjogZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkLFxyXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIjogZDNDdXJ2ZUNhcmRpbmFsT3BlbixcclxuXHRcdFx0XCJjYXRtdWxsLXJvbVwiOiBkM0N1cnZlQ2F0bXVsbFJvbSxcclxuXHRcdFx0XCJjYXRtdWxsLXJvbS1jbG9zZWRcIjogZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXHJcblx0XHRcdFwiY2F0bXVsbC1yb20tb3BlblwiOiBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXHJcblx0XHRcdFwibW9ub3RvbmUteFwiOiBkM0N1cnZlTW9ub3RvbmVYLFxyXG5cdFx0XHRcIm1vbm90b25lLXlcIjogZDNDdXJ2ZU1vbm90b25lWSxcclxuXHRcdFx0XCJuYXR1cmFsXCI6IGQzQ3VydmVOYXR1cmFsLFxyXG5cdFx0XHRcImxpbmVhci1jbG9zZWRcIjogZDNDdXJ2ZUxpbmVhckNsb3NlZCxcclxuXHRcdFx0XCJsaW5lYXJcIjogZDNDdXJ2ZUxpbmVhcixcclxuXHRcdFx0XCJzdGVwXCI6IGQzQ3VydmVTdGVwLFxyXG5cdFx0XHRcInN0ZXAtYWZ0ZXJcIjogZDNDdXJ2ZVN0ZXBBZnRlcixcclxuXHRcdFx0XCJzdGVwLWJlZm9yZVwiOiBkM0N1cnZlU3RlcEJlZm9yZVxyXG5cdFx0fVtpbnRlcnBvbGF0aW9uXTtcclxuXHR9LFxyXG5cclxuXHRnZXRJbnRlcnBvbGF0ZVR5cGUoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHR5cGUgPSBjb25maWcuc3BsaW5lX2ludGVycG9sYXRpb25fdHlwZTtcclxuXHRcdGNvbnN0IGludGVycG9sYXRpb24gPSAkJC5pc0ludGVycG9sYXRpb25UeXBlKHR5cGUpID8gdHlwZSA6IFwiY2FyZGluYWxcIjtcclxuXHJcblx0XHRyZXR1cm4gJCQuaXNTcGxpbmVUeXBlKGQpID9cclxuXHRcdFx0aW50ZXJwb2xhdGlvbiA6IChcclxuXHRcdFx0XHQkJC5pc1N0ZXBUeXBlKGQpID9cclxuXHRcdFx0XHRcdGNvbmZpZy5saW5lX3N0ZXBfdHlwZSA6IFwibGluZWFyXCJcclxuXHRcdFx0KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIE1vZHVsZXMgZXhwb3J0cyBmb3IgQXhpcyBiYXNlZCBjaGFydFxyXG4gKi9cclxuLy8gQ2hhcnRcclxuaW1wb3J0IGFwaUF4aXMgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9heGlzXCI7XHJcbmltcG9ydCBhcGlDYXRlZ29yeSBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2NhdGVnb3J5XCI7XHJcbmltcG9ydCBhcGlGbG93IGZyb20gXCIuLi8uLi9DaGFydC9hcGkvZmxvd1wiO1xyXG5pbXBvcnQgYXBpWEdyaWQgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9ncmlkLnhcIjtcclxuaW1wb3J0IGFwaVlHcmlkIGZyb20gXCIuLi8uLi9DaGFydC9hcGkvZ3JpZC55XCI7XHJcbmltcG9ydCBhcGlHcm91cCBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2dyb3VwXCI7XHJcbmltcG9ydCBhcGlSZWdpb24gZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9yZWdpb25zXCI7XHJcbmltcG9ydCBhcGlTZWxlY3Rpb24gZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9zZWxlY3Rpb25cIjtcclxuaW1wb3J0IGFwaVggZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS94XCI7XHJcbmltcG9ydCBhcGlab29tIGZyb20gXCIuLi8uLi9DaGFydC9hcGkvem9vbVwiO1xyXG5cclxuLy8gQ2hhcnRJbnRlcm5hbFxyXG5pbXBvcnQgZHJhZyBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZHJhZ1wiO1xyXG5pbXBvcnQgZmxvdyBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZmxvd1wiO1xyXG5pbXBvcnQgZXZlbnRyZWN0IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9ldmVudHJlY3RcIjtcclxuaW1wb3J0IHN1YmNoYXJ0IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9zdWJjaGFydFwiO1xyXG5pbXBvcnQgem9vbSBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvem9vbVwiO1xyXG5cclxuaW1wb3J0IGNsaXAgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NsaXBcIjtcclxuaW1wb3J0IGdyaWQgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2dyaWRcIjtcclxuaW1wb3J0IHJlZ2lvbiBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvcmVnaW9uXCI7XHJcbmltcG9ydCBzZWxlY3Rpb24gZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3NlbGVjdGlvblwiO1xyXG5cclxuaW1wb3J0IGJhciBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9iYXJcIjtcclxuaW1wb3J0IGJ1YmJsZSBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9idWJibGVcIjtcclxuaW1wb3J0IGxpbmUgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvbGluZVwiO1xyXG5pbXBvcnQgcG9pbnQgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcG9pbnRcIjtcclxuaW1wb3J0IHNoYXBlIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL3NoYXBlL3NoYXBlXCI7XHJcblxyXG5leHBvcnQgY29uc3QgYXBpID0gW1xyXG5cdGFwaUF4aXMsXHJcblx0YXBpQ2F0ZWdvcnksXHJcblx0YXBpRmxvdyxcclxuXHRhcGlYR3JpZCxcclxuXHRhcGlZR3JpZCxcclxuXHRhcGlHcm91cCxcclxuXHRhcGlSZWdpb24sXHJcblx0YXBpU2VsZWN0aW9uLFxyXG5cdGFwaVgsXHJcblx0YXBpWm9vbVxyXG5dO1xyXG5cclxuZXhwb3J0IGNvbnN0IGludGVybmFsID0gW1xyXG5cdGRyYWcsXHJcblx0ZmxvdyxcclxuXHRzdWJjaGFydCxcclxuXHR6b29tLFxyXG5cclxuXHRjbGlwLFxyXG5cdGdyaWQsXHJcblx0cmVnaW9uLFxyXG5cdHNlbGVjdGlvbixcclxuXHRldmVudHJlY3QsXHJcblxyXG5cdGJhcixcclxuXHRidWJibGUsXHJcblx0bGluZSxcclxuXHRwb2ludCxcclxuXHRzaGFwZVxyXG5dO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7XHJcblx0YXJjIGFzIGQzQXJjLFxyXG5cdHBpZSBhcyBkM1BpZVxyXG59IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge2ludGVycG9sYXRlIGFzIGQzSW50ZXJwb2xhdGV9IGZyb20gXCJkMy1pbnRlcnBvbGF0ZVwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbiwgZW5kYWxsLCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNVbmRlZmluZWQsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRQaWUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZGF0YVR5cGUgPSBjb25maWcuZGF0YV90eXBlO1xyXG5cdFx0Y29uc3QgcGFkZGluZyA9IGNvbmZpZy5waWVfcGFkZGluZztcclxuXHRcdGNvbnN0IHN0YXJ0aW5nQW5nbGUgPSBjb25maWdbYCR7ZGF0YVR5cGV9X3N0YXJ0aW5nQW5nbGVgXSB8fCAwO1xyXG5cdFx0Y29uc3QgcGFkQW5nbGUgPSAoXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJwaWVcIikgJiYgcGFkZGluZyA/IHBhZGRpbmcgKiAwLjAxIDpcclxuXHRcdFx0XHRjb25maWdbYCR7ZGF0YVR5cGV9X3BhZEFuZ2xlYF1cclxuXHRcdCkgfHwgMDtcclxuXHRcdGNvbnN0IHNvcnRWYWx1ZTogYW55ID0gJCQuaXNPcmRlckFzYygpIHx8ICQkLmlzT3JkZXJEZXNjKCkgP1xyXG5cdFx0XHQoYSwgYikgPT4gKCQkLmlzT3JkZXJBc2MoKSA/IGEgLSBiIDogYiAtIGEpIDogbnVsbDtcclxuXHJcblx0XHQkJC5waWUgPSBkM1BpZSgpXHJcblx0XHRcdC5zdGFydEFuZ2xlKHN0YXJ0aW5nQW5nbGUpXHJcblx0XHRcdC5lbmRBbmdsZShzdGFydGluZ0FuZ2xlICsgKDIgKiBNYXRoLlBJKSlcclxuXHRcdFx0LnBhZEFuZ2xlKHBhZEFuZ2xlKVxyXG5cdFx0XHQuc29ydFZhbHVlcyhzb3J0VmFsdWUpXHJcblx0XHRcdC52YWx1ZSgoZDogYW55KSA9PiBkLnZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLnZhbHVlLCAwKSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkaXVzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCByYWRpdXMgPSBjb25maWcucGllX2lubmVyUmFkaXVzO1xyXG5cdFx0Y29uc3QgcGFkZGluZyA9IGNvbmZpZy5waWVfcGFkZGluZztcclxuXHRcdGNvbnN0IHcgPSBjb25maWcuZ2F1Z2Vfd2lkdGggfHwgY29uZmlnLmRvbnV0X3dpZHRoO1xyXG5cdFx0Y29uc3QgZ2F1Z2VBcmNXaWR0aCA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggKlxyXG5cdFx0XHRjb25maWcuZ2F1Z2VfYXJjc19taW5XaWR0aDtcclxuXHJcblx0XHRzdGF0ZS5yYWRpdXNFeHBhbmRlZCA9IE1hdGgubWluKHN0YXRlLmFyY1dpZHRoLCBzdGF0ZS5hcmNIZWlnaHQpIC8gMiAqIChcclxuXHRcdFx0JCQuaGFzTXVsdGlBcmNHYXVnZSgpID8gMC44NSA6IDEpO1xyXG5cdFx0c3RhdGUucmFkaXVzID0gc3RhdGUucmFkaXVzRXhwYW5kZWQgKiAwLjk1O1xyXG5cdFx0c3RhdGUuaW5uZXJSYWRpdXNSYXRpbyA9IHcgPyAoc3RhdGUucmFkaXVzIC0gdykgLyBzdGF0ZS5yYWRpdXMgOiAwLjY7XHJcblx0XHRzdGF0ZS5nYXVnZUFyY1dpZHRoID0gdyB8fCAoXHJcblx0XHRcdGdhdWdlQXJjV2lkdGggPD0gc3RhdGUucmFkaXVzIC0gc3RhdGUuaW5uZXJSYWRpdXMgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzIDpcclxuXHRcdFx0XHQoZ2F1Z2VBcmNXaWR0aCA8PSBzdGF0ZS5yYWRpdXMgPyBnYXVnZUFyY1dpZHRoIDogc3RhdGUucmFkaXVzKVxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cyB8fCAoXHJcblx0XHRcdHBhZGRpbmcgPyBwYWRkaW5nICogKHN0YXRlLmlubmVyUmFkaXVzUmF0aW8gKyAwLjEpIDogMFxyXG5cdFx0KTtcclxuXHJcblx0XHQvLyBOT1RFOiBpbm5lclJhZGl1cyBjYW4gYmUgYW4gb2JqZWN0IGJ5IHVzZXIgc2V0dGluZywgb25seSBmb3IgJ3BpZScgdHlwZVxyXG5cdFx0c3RhdGUuaW5uZXJSYWRpdXMgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgJCQuaGFzVHlwZShcImdhdWdlXCIpID9cclxuXHRcdFx0c3RhdGUucmFkaXVzICogc3RhdGUuaW5uZXJSYWRpdXNSYXRpbyA6IGlubmVyUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdGdldElubmVyUmFkaXVzKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHtpbm5lclJhZGl1c30gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRpZiAoIWlzTnVtYmVyKGlubmVyUmFkaXVzKSAmJiBkKSB7XHJcblx0XHRcdGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXNbZC5kYXRhLmlkXSB8fCAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbm5lclJhZGl1cztcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuc3ZnQXJjID0gJCQuZ2V0U3ZnQXJjKCk7XHJcblx0XHQkJC5zdmdBcmNFeHBhbmRlZCA9ICQkLmdldFN2Z0FyY0V4cGFuZGVkKCk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQW5nbGUoZFZhbHVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGxldCBwaWUgPSAkJC5waWU7XHJcblx0XHRsZXQgZCA9IGRWYWx1ZTtcclxuXHRcdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICghY29uZmlnKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJhZGl1cyA9IE1hdGguUEkgKiAoY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSk7XHJcblx0XHRjb25zdCBnU3RhcnQgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcclxuXHJcblx0XHRpZiAoZC5kYXRhICYmICQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgISQkLmhhc011bHRpQXJjR2F1Z2UoKSkge1xyXG5cdFx0XHQvLyB0byBwcmV2ZW50IGV4Y2x1ZGluZyB0b3RhbCBkYXRhIHN1bSBkdXJpbmcgdGhlIGluaXQod2hlbiBkYXRhLmhpZGUgb3B0aW9uIGlzIHVzZWQpLCB1c2UgJCQucmVuZGVyZWQgc3RhdGUgdmFsdWVcclxuXHRcdFx0Y29uc3QgdG90YWxTdW0gPSAkJC5nZXRUb3RhbERhdGFTdW0oc3RhdGUucmVuZGVyZWQpO1xyXG5cclxuXHRcdFx0Ly8gaWYgZ2F1Z2VfbWF4IGxlc3MgdGhhbiB0b3RhbFN1bSwgbWFrZSB0b3RhbFN1bSB0byBtYXggdmFsdWVcclxuXHRcdFx0aWYgKHRvdGFsU3VtID4gY29uZmlnLmdhdWdlX21heCkge1xyXG5cdFx0XHRcdGNvbmZpZy5nYXVnZV9tYXggPSB0b3RhbFN1bTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZ0VuZCA9IHJhZGl1cyAqICh0b3RhbFN1bSAvIChjb25maWcuZ2F1Z2VfbWF4IC0gY29uZmlnLmdhdWdlX21pbikpO1xyXG5cclxuXHRcdFx0cGllID0gcGllXHJcblx0XHRcdFx0LnN0YXJ0QW5nbGUoZ1N0YXJ0KVxyXG5cdFx0XHRcdC5lbmRBbmdsZShnRW5kICsgZ1N0YXJ0KTtcclxuXHRcdH1cclxuXHJcblx0XHRwaWUoJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygpKVxyXG5cdFx0XHQuZm9yRWFjaCgodCwgaSkgPT4ge1xyXG5cdFx0XHRcdGlmICghZm91bmQgJiYgdC5kYXRhLmlkID09PSBkLmRhdGEuaWQpIHtcclxuXHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGQgPSB0O1xyXG5cdFx0XHRcdFx0ZC5pbmRleCA9IGk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRpZiAoaXNOYU4oZC5zdGFydEFuZ2xlKSkge1xyXG5cdFx0XHRkLnN0YXJ0QW5nbGUgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc05hTihkLmVuZEFuZ2xlKSkge1xyXG5cdFx0XHRkLmVuZEFuZ2xlID0gZC5zdGFydEFuZ2xlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkLmRhdGEgJiYgJCQuaGFzTXVsdGlBcmNHYXVnZSgpKSB7XHJcblx0XHRcdGNvbnN0IG1heFZhbHVlID0gJCQuZ2V0TWluTWF4RGF0YSgpLm1heFswXS52YWx1ZTtcclxuXHJcblx0XHRcdC8vIGlmIGdhdWdlX21heCBsZXNzIHRoYW4gbWF4VmFsdWUsIG1ha2UgbWF4VmFsdWUgdG8gbWF4IHZhbHVlXHJcblx0XHRcdGlmIChtYXhWYWx1ZSA+IGNvbmZpZy5nYXVnZV9tYXgpIHtcclxuXHRcdFx0XHRjb25maWcuZ2F1Z2VfbWF4ID0gbWF4VmFsdWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGdNaW4gPSBjb25maWcuZ2F1Z2VfbWluO1xyXG5cdFx0XHRjb25zdCBnTWF4ID0gY29uZmlnLmdhdWdlX21heDtcclxuXHRcdFx0Y29uc3QgZ1RpYyA9IHJhZGl1cyAvIChnTWF4IC0gZ01pbik7XHJcblx0XHRcdGNvbnN0IGdWYWx1ZSA9IGQudmFsdWUgPCBnTWluID8gMCA6IGQudmFsdWUgPCBnTWF4ID8gZC52YWx1ZSAtIGdNaW4gOiAoZ01heCAtIGdNaW4pO1xyXG5cclxuXHRcdFx0ZC5zdGFydEFuZ2xlID0gZ1N0YXJ0O1xyXG5cdFx0XHRkLmVuZEFuZ2xlID0gZ1N0YXJ0ICsgZ1RpYyAqIGdWYWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZm91bmQgPyBkIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHRnZXRTdmdBcmMoKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXIgPSAkJC5nZXRJbm5lclJhZGl1cygpO1xyXG5cdFx0Y29uc3Qgc2luZ2xlQXJjV2lkdGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aDtcclxuXHRcdGNvbnN0IGhhc011bHRpQXJjR2F1Z2UgPSAkJC5oYXNNdWx0aUFyY0dhdWdlKCk7XHJcblxyXG5cdFx0bGV0IGFyYyA9IGQzQXJjKClcclxuXHRcdFx0Lm91dGVyUmFkaXVzKChkOiBhbnkpID0+IChcclxuXHRcdFx0XHRoYXNNdWx0aUFyY0dhdWdlID8gKHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogZC5pbmRleCkgOiBzdGF0ZS5yYWRpdXMpKVxyXG5cdFx0XHQuaW5uZXJSYWRpdXMoKGQ6IGFueSkgPT4gKGhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogKGQuaW5kZXggKyAxKSA6XHJcblx0XHRcdFx0aXNOdW1iZXIoaXIpID8gaXIgOiAwKSk7XHJcblxyXG5cdFx0Y29uc3QgbmV3QXJjID0gZnVuY3Rpb24oZCwgd2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRsZXQgcGF0aDogc3RyaW5nIHwgbnVsbCA9IFwiTSAwIDBcIjtcclxuXHJcblx0XHRcdGlmIChkLnZhbHVlIHx8IGQuZGF0YSkge1xyXG5cdFx0XHRcdGlmICghaXNOdW1iZXIoaXIpKSB7XHJcblx0XHRcdFx0XHRhcmMgPSBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICF3aXRob3V0VXBkYXRlICYmICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cclxuXHRcdFx0XHRpZiAod2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRcdFx0cGF0aCA9IGFyYyhkKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHVwZGF0ZWQpIHtcclxuXHRcdFx0XHRcdHBhdGggPSBhcmModXBkYXRlZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aDtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gVE9ETzogZXh0ZW5kcyBhbGwgZnVuY3Rpb25cclxuXHRcdG5ld0FyYy5jZW50cm9pZCA9IGFyYy5jZW50cm9pZDtcclxuXHJcblx0XHRyZXR1cm4gbmV3QXJjO1xyXG5cdH0sXHJcblxyXG5cdGdldFN2Z0FyY0V4cGFuZGVkKHJhdGU/OiBudW1iZXIpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBuZXdSYXRlID0gcmF0ZSB8fCAxO1xyXG5cdFx0Y29uc3Qgc2luZ2xlQXJjV2lkdGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aDtcclxuXHRcdGNvbnN0IGhhc011bHRpQXJjR2F1Z2UgPSAkJC5oYXNNdWx0aUFyY0dhdWdlKCk7XHJcblx0XHRjb25zdCBleHBhbmRXaWR0aCA9IE1hdGgubWluKHN0YXRlLnJhZGl1c0V4cGFuZGVkICogbmV3UmF0ZSAtIHN0YXRlLnJhZGl1cyxcclxuXHRcdFx0c2luZ2xlQXJjV2lkdGggKiAwLjggLSAoMSAtIG5ld1JhdGUpICogMTAwXHJcblx0XHQpO1xyXG5cclxuXHRcdGNvbnN0IGFyYyA9IGQzQXJjKClcclxuXHRcdFx0Lm91dGVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIGQuaW5kZXggKyBleHBhbmRXaWR0aCA6XHJcblx0XHRcdFx0c3RhdGUucmFkaXVzRXhwYW5kZWQgKiBuZXdSYXRlKVxyXG5cdFx0XHQpXHJcblx0XHRcdC5pbm5lclJhZGl1cygoZDogYW55KSA9PiAoaGFzTXVsdGlBcmNHYXVnZSA/XHJcblx0XHRcdFx0c3RhdGUucmFkaXVzIC0gc2luZ2xlQXJjV2lkdGggKiAoZC5pbmRleCArIDEpIDogc3RhdGUuaW5uZXJSYWRpdXMpKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblxyXG5cdFx0XHRpZiAodXBkYXRlZCkge1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRoYXNNdWx0aUFyY0dhdWdlID8gYXJjIDogYXJjLmlubmVyUmFkaXVzKCQkLmdldElubmVyUmFkaXVzKGQpKVxyXG5cdFx0XHRcdCkodXBkYXRlZCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIFwiTSAwIDBcIjtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmMoZCwgd2l0aG91dFVwZGF0ZTogYm9vbGVhbiwgZm9yY2U/OiBib29sZWFuKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBmb3JjZSB8fCB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gdGhpcy5zdmdBcmMoZCwgd2l0aG91dFVwZGF0ZSkgOiBcIk0gMCAwXCI7XHJcblx0fSxcclxuXHJcblx0dHJhbnNmb3JtRm9yQXJjTGFiZWwoZCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3JhZGl1cywgcmFkaXVzRXhwYW5kZWR9fSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdGxldCB0cmFuc2xhdGUgPSBcIlwiO1xyXG5cclxuXHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdGlmICgkJC5oYXNNdWx0aUFyY0dhdWdlKCkpIHtcclxuXHRcdFx0XHRjb25zdCB5MSA9IE1hdGguc2luKHVwZGF0ZWQuZW5kQW5nbGUgLSBNYXRoLlBJIC8gMik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHggPSBNYXRoLmNvcyh1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDIpICogKHJhZGl1c0V4cGFuZGVkICsgMjUpO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSB5MSAqIChyYWRpdXNFeHBhbmRlZCArIDE1IC0gTWF0aC5hYnMoeTEgKiAxMCkpICsgMztcclxuXHJcblx0XHRcdFx0dHJhbnNsYXRlID0gYHRyYW5zbGF0ZSgke3h9LCR7eX0pYDtcclxuXHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVHlwZShcImdhdWdlXCIpIHx8ICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0Y29uc3QgYyA9IHRoaXMuc3ZnQXJjLmNlbnRyb2lkKHVwZGF0ZWQpO1xyXG5cdFx0XHRcdGNvbnN0IHggPSBpc05hTihjWzBdKSA/IDAgOiBjWzBdO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSBpc05hTihjWzFdKSA/IDAgOiBjWzFdO1xyXG5cdFx0XHRcdGNvbnN0IGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblxyXG5cdFx0XHRcdGxldCByYXRpbyA9ICgkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgY29uZmlnLmRvbnV0X2xhYmVsX3JhdGlvKSB8fFxyXG5cdFx0XHRcdFx0KCQkLmhhc1R5cGUoXCJwaWVcIikgJiYgY29uZmlnLnBpZV9sYWJlbF9yYXRpbyk7XHJcblxyXG5cdFx0XHRcdGlmIChyYXRpbykge1xyXG5cdFx0XHRcdFx0cmF0aW8gPSBpc0Z1bmN0aW9uKHJhdGlvKSA/IHJhdGlvLmJpbmQoJCQuYXBpKShkLCByYWRpdXMsIGgpIDogcmF0aW87XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gcmFkaXVzICYmIChcclxuXHRcdFx0XHRcdFx0aCA/ICgzNiAvIHJhZGl1cyA+IDAuMzc1ID8gMS4xNzUgLSAzNiAvIHJhZGl1cyA6IDAuOCkgKiByYWRpdXMgLyBoIDogMFxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt4ICogcmF0aW99LCR7eSAqIHJhdGlvfSlgO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRyYW5zbGF0ZTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VG9BcmNEYXRhKGQpOiBvYmplY3Qge1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTmFtZSh7XHJcblx0XHRcdGlkOiBkLmRhdGEuaWQsXHJcblx0XHRcdHZhbHVlOiBkLnZhbHVlLFxyXG5cdFx0XHRyYXRpbzogdGhpcy5nZXRSYXRpbyhcImFyY1wiLCBkKSxcclxuXHRcdFx0aW5kZXg6IGQuaW5kZXgsXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR0ZXh0Rm9yQXJjTGFiZWwoc2VsZWN0aW9uOiBkM1NlbGVjdGlvbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblxyXG5cdFx0aWYgKCQkLnNob3VsZFNob3dBcmNMYWJlbCgpKSB7XHJcblx0XHRcdHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBub2RlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdGNvbnN0IHJhdGlvID0gJCQuZ2V0UmF0aW8oXCJhcmNcIiwgdXBkYXRlZCk7XHJcblx0XHRcdFx0Y29uc3QgaXNVbmRlclRocmVzaG9sZCA9ICEoXHJcblx0XHRcdFx0XHQhaGFzR2F1Z2UgJiYgISQkLm1lZXRzQXJjTGFiZWxUaHJlc2hvbGQocmF0aW8pXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0aWYgKGlzVW5kZXJUaHJlc2hvbGQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHt2YWx1ZX0gPSB1cGRhdGVkIHx8IGQ7XHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0ID0gKFxyXG5cdFx0XHRcdFx0XHQkJC5nZXRBcmNMYWJlbEZvcm1hdCgpIHx8ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdFxyXG5cdFx0XHRcdFx0KSh2YWx1ZSwgcmF0aW8sIGQuZGF0YS5pZCkudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdFx0XHRzZXRUZXh0VmFsdWUobm9kZSwgdGV4dCwgWy0xLCAxXSwgaGFzR2F1Z2UpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRub2RlLnRleHQoXCJcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR0ZXh0Rm9yR2F1Z2VNaW5NYXgodmFsdWU6IG51bWJlciwgaXNNYXg/OiBib29sZWFuKTogbnVtYmVyIHwgc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBmb3JtYXQgPSBjb25maWcuZ2F1Z2VfbGFiZWxfZXh0ZW50cztcclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0LmJpbmQoJCQuYXBpKSh2YWx1ZSwgaXNNYXgpIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQXJjKHRhcmdldElkczogc3RyaW5nW10pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge3RyYW5zaXRpbmd9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Ly8gTUVNTzogYXZvaWQgdG8gY2FuY2VsIHRyYW5zaXRpb25cclxuXHRcdGlmICh0cmFuc2l0aW5nKSB7XHJcblx0XHRcdGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xyXG5cdFx0XHRcdGlmICghdHJhbnNpdGluZykge1xyXG5cdFx0XHRcdFx0Y2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XHJcblxyXG5cdFx0XHRcdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkfWApLnNpemUoKSA+IDAgJiZcclxuXHRcdFx0XHRcdFx0JCQuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCAxMCk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbmV3VGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcclxuXHJcblx0XHQkZWwuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBgLiR7Q0xBU1MuY2hhcnRBcmN9YCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRpZiAoISQkLnNob3VsZEV4cGFuZChkLmRhdGEuaWQpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBleHBhbmREdXJhdGlvbiA9ICQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwiZHVyYXRpb25cIik7XHJcblx0XHRcdFx0Y29uc3Qgc3ZnQXJjRXhwYW5kZWRTdWIgPSAkJC5nZXRTdmdBcmNFeHBhbmRlZCgkJC5nZXRFeHBhbmRDb25maWcoZC5kYXRhLmlkLCBcInJhdGVcIikpO1xyXG5cclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5zZWxlY3RBbGwoXCJwYXRoXCIpXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0XHQuZHVyYXRpb24oZXhwYW5kRHVyYXRpb24pXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgJCQuc3ZnQXJjRXhwYW5kZWQpXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0XHQuZHVyYXRpb24oZXhwYW5kRHVyYXRpb24gKiAyKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIHN2Z0FyY0V4cGFuZGVkU3ViKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dW5leHBhbmRBcmModGFyZ2V0SWRzOiBzdHJpbmdbXSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7dHJhbnNpdGluZ30sICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpbmcpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG5ld1RhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBgLiR7Q0xBU1MuY2hhcnRBcmN9YCkpXHJcblx0XHRcdC5zZWxlY3RBbGwoXCJwYXRoXCIpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGQgPT4gJCQuZ2V0RXhwYW5kQ29uZmlnKGQuZGF0YS5pZCwgXCJkdXJhdGlvblwiKSlcclxuXHRcdFx0LmF0dHIoXCJkXCIsICQkLnN2Z0FyYyk7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdEFsbChgJHtDTEFTUy5hcmN9YClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGV4cGFuZCBjb25maWcgdmFsdWVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgZGF0YSBJRFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgY29uZmlnIGtleTogJ2R1cmF0aW9uIHwgcmF0ZSdcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RXhwYW5kQ29uZmlnKGlkOiBzdHJpbmcsIGtleTogXCJkdXJhdGlvblwiIHwgXCJyYXRlXCIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRlZiA9IHtcclxuXHRcdFx0ZHVyYXRpb246IDUwLFxyXG5cdFx0XHRyYXRlOiAwLjk4XHJcblx0XHR9O1xyXG5cdFx0bGV0IHR5cGU7XHJcblxyXG5cdFx0aWYgKCQkLmlzRG9udXRUeXBlKGlkKSkge1xyXG5cdFx0XHR0eXBlID0gXCJkb251dFwiO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5pc0dhdWdlVHlwZShpZCkpIHtcclxuXHRcdFx0dHlwZSA9IFwiZ2F1Z2VcIjtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNQaWVUeXBlKGlkKSkge1xyXG5cdFx0XHR0eXBlID0gXCJwaWVcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHlwZSA/IGNvbmZpZ1tgJHt0eXBlfV9leHBhbmRfJHtrZXl9YF0gOiBkZWZba2V5XTtcclxuXHR9LFxyXG5cclxuXHRzaG91bGRFeHBhbmQoaWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gKCQkLmlzRG9udXRUeXBlKGlkKSAmJiBjb25maWcuZG9udXRfZXhwYW5kKSB8fFxyXG5cdFx0XHQoJCQuaXNHYXVnZVR5cGUoaWQpICYmIGNvbmZpZy5nYXVnZV9leHBhbmQpIHx8XHJcblx0XHRcdCgkJC5pc1BpZVR5cGUoaWQpICYmIGNvbmZpZy5waWVfZXhwYW5kKTtcclxuXHR9LFxyXG5cclxuXHRzaG91bGRTaG93QXJjTGFiZWwoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBbXCJwaWVcIiwgXCJkb251dFwiLCBcImdhdWdlXCJdXHJcblx0XHRcdC5zb21lKHYgPT4gJCQuaGFzVHlwZSh2KSAmJiBjb25maWdbYCR7dn1fbGFiZWxfc2hvd2BdKTtcclxuXHR9LFxyXG5cclxuXHRtZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvOiBudW1iZXIpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0aHJlc2hvbGQgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgPyBjb25maWcuZG9udXRfbGFiZWxfdGhyZXNob2xkIDogY29uZmlnLnBpZV9sYWJlbF90aHJlc2hvbGQ7XHJcblxyXG5cdFx0cmV0dXJuIHJhdGlvID49IHRocmVzaG9sZDtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmNMYWJlbEZvcm1hdCgpOiBudW1iZXIgfCBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCBmb3JtYXQgPSBjb25maWcucGllX2xhYmVsX2Zvcm1hdDtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XHJcblx0XHRcdGZvcm1hdCA9IGNvbmZpZy5nYXVnZV9sYWJlbF9mb3JtYXQ7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmhhc1R5cGUoXCJkb251dFwiKSkge1xyXG5cdFx0XHRmb3JtYXQgPSBjb25maWcuZG9udXRfbGFiZWxfZm9ybWF0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQuYmluZCgkJC5hcGkpIDogZm9ybWF0O1xyXG5cdH0sXHJcblxyXG5cdGdldEFyY1RpdGxlKCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0eXBlID0gKCQkLmhhc1R5cGUoXCJkb251dFwiKSAmJiBcImRvbnV0XCIpIHx8ICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgXCJnYXVnZVwiKTtcclxuXHJcblx0XHRyZXR1cm4gdHlwZSA/ICQkLmNvbmZpZ1tgJHt0eXBlfV90aXRsZWBdIDogXCJcIjtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydEFyYyA9ICQkLmNsYXNzQ2hhcnRBcmMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0FyY3MgPSAkJC5jbGFzc0FyY3MuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IG1haW5QaWVVcGRhdGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QXJjfWApXHJcblx0XHRcdC5kYXRhKCQkLnBpZSh0YXJnZXRzKSlcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRBcmMoZCkgKyBjbGFzc0ZvY3VzKGQuZGF0YSkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5QaWVFbnRlciA9IG1haW5QaWVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEFyYyk7XHJcblxyXG5cdFx0bWFpblBpZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyY3MpXHJcblx0XHRcdC5tZXJnZShtYWluUGllVXBkYXRlKTtcclxuXHJcblx0XHRtYWluUGllRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcImR5XCIsIGhhc0dhdWdlICYmICEkJC5oYXNNdWx0aVRhcmdldHMoKSA/IFwiLS4xZW1cIiA6IFwiLjM1ZW1cIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi4sIGJ1dCBub3QgYmFkIHRvIHVwZGF0ZSBjb2xvciBpbiByZWRyYXdcclxuXHRcdC8vIG1haW5QaWVVcGRhdGUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRBcmMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cclxuXHRcdCRlbC5hcmNzID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QXJjcylcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiYXJjXCIpKTtcclxuXHJcblx0XHQkJC5zZXRBcmNUaXRsZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhcmMgdGl0bGUgdGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0QXJjVGl0bGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0aXRsZSA9ICQkLmdldEFyY1RpdGxlKCk7XHJcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcclxuXHJcblx0XHRpZiAodGl0bGUpIHtcclxuXHRcdFx0Y29uc3QgdGV4dCA9ICQkLiRlbC5hcmNzLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTW2hhc0dhdWdlID8gXCJjaGFydEFyY3NHYXVnZVRpdGxlXCIgOiBcImNoYXJ0QXJjc1RpdGxlXCJdKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpO1xyXG5cclxuXHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0dGV4dFxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi0wLjNlbVwiKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMjdweFwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2V0VGV4dFZhbHVlKHRleHQsIHRpdGxlLCBoYXNHYXVnZSA/IHVuZGVmaW5lZCA6IFstMC42LCAxLjM1XSwgdHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVkcmF3QXJjKGR1cmF0aW9uOiBudW1iZXIsIGR1cmF0aW9uRm9yRXhpdDogbnVtYmVyLCB3aXRoVHJhbnNmb3JtPzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzSW50ZXJhY3Rpb24gPSBjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZDtcclxuXHJcblx0XHRsZXQgbWFpbkFyYyA9IG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY31gKVxyXG5cdFx0XHQuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRtYWluQXJjLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdG1haW5BcmMgPSBtYWluQXJjLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJjLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gJCQuY29sb3IoZC5kYXRhKSlcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGQgPT4gKGhhc0ludGVyYWN0aW9uICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGlmICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpKSB7XHJcblx0XHRcdFx0XHRkLnN0YXJ0QW5nbGUgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcclxuXHRcdFx0XHRcdGQuZW5kQW5nbGUgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnQgPSBkO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2UobWFpbkFyYyk7XHJcblxyXG5cdFx0JCQuaGFzTXVsdGlBcmNHYXVnZSgpICYmICQkLnJlZHJhd011bHRpQXJjR2F1Z2UoKTtcclxuXHJcblx0XHRtYWluQXJjXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gKCEkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmIHdpdGhUcmFuc2Zvcm0gPyBcInNjYWxlKDApXCIgOiBcIlwiKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0cmV0dXJuIGQgPT09IHRoaXMuX2N1cnJlbnQgPyBcIjBcIiA6IFwiMVwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuZWFjaCgoKSA9PiB7XHJcblx0XHRcdFx0c3RhdGUudHJhbnNpdGluZyA9IHRydWU7XHJcblx0XHRcdH0pXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQuYXR0clR3ZWVuKFwiZFwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cclxuXHRcdFx0XHRpZiAoIXVwZGF0ZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybiAoKSA9PiBcIk0gMCAwXCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5zdGFydEFuZ2xlKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudC5zdGFydEFuZ2xlID0gMDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc05hTih0aGlzLl9jdXJyZW50LmVuZEFuZ2xlKSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudC5lbmRBbmdsZSA9IHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGludGVycG9sYXRlID0gZDNJbnRlcnBvbGF0ZSh0aGlzLl9jdXJyZW50LCB1cGRhdGVkKTtcclxuXHJcblx0XHRcdFx0dGhpcy5fY3VycmVudCA9IGludGVycG9sYXRlKDApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhdGVkID0gaW50ZXJwb2xhdGUodCk7XHJcblxyXG5cdFx0XHRcdFx0aW50ZXJwb2xhdGVkLmRhdGEgPSBkLmRhdGE7IC8vIGRhdGEuaWQgd2lsbCBiZSB1cGRhdGVkIGJ5IGludGVycG9yYXRvclxyXG5cdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhpbnRlcnBvbGF0ZWQsIHRydWUpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH0pXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHdpdGhUcmFuc2Zvcm0gPyBcInNjYWxlKDEpXCIgOiBcIlwiKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4ge1xyXG5cdFx0XHRcdGxldCBjb2xvcjtcclxuXHJcblx0XHRcdFx0aWYgKCQkLmxldmVsQ29sb3IpIHtcclxuXHRcdFx0XHRcdGNvbG9yID0gJCQubGV2ZWxDb2xvcihkLmRhdGEudmFsdWVzWzBdLnZhbHVlKTtcclxuXHJcblx0XHRcdFx0XHQvLyB1cGRhdGUgZGF0YSdzIGNvbG9yXHJcblx0XHRcdFx0XHRjb25maWcuZGF0YV9jb2xvcnNbZC5kYXRhLmlkXSA9IGNvbG9yO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb2xvciA9ICQkLmNvbG9yKGQuZGF0YS5pZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gY29sb3I7XHJcblx0XHRcdH0pXHJcblx0XHRcdC8vIFdoZXJlIGdhdWdlIHJlYWRpbmcgY29sb3Igd291bGQgcmVjZWl2ZSBjdXN0b21pemF0aW9uLlxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxyXG5cdFx0XHQuY2FsbChlbmRhbGwsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICgkJC5sZXZlbENvbG9yKSB7XHJcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0XHRjb25zdCBkOiBhbnkgPSBwYXRoLmRhdHVtKCk7XHJcblxyXG5cdFx0XHRcdFx0JCQudXBkYXRlTGVnZW5kSXRlbUNvbG9yKGQuZGF0YS5pZCwgcGF0aC5zdHlsZShcImZpbGxcIikpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3RhdGUudHJhbnNpdGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdGNhbGxGbihjb25maWcub25yZW5kZXJlZCwgJCQuYXBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gYmluZCBhcmMgZXZlbnRzXHJcblx0XHRoYXNJbnRlcmFjdGlvbiAmJiAkJC5iaW5kQXJjRXZlbnQobWFpbkFyYyk7XHJcblxyXG5cdFx0JCQucmVkcmF3QXJjVGV4dChkdXJhdGlvbik7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3TXVsdGlBcmNHYXVnZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB7aGlkZGVuVGFyZ2V0SWRzfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdGNvbnN0IGFyY0xhYmVsTGluZXMgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY3N9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjTGFiZWxMaW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmFyY0RhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5BcmNMYWJlbExpbmUgPSBhcmNMYWJlbExpbmVzLmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAke0NMQVNTLmFyY0xhYmVsTGluZX0gJHtDTEFTUy50YXJnZXR9ICR7Q0xBU1MudGFyZ2V0fS0ke2QuZGF0YS5pZH1gKVxyXG5cdFx0XHQubWVyZ2UoYXJjTGFiZWxMaW5lcyk7XHJcblxyXG5cdFx0bWFpbkFyY0xhYmVsTGluZVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gKCQkLmxldmVsQ29sb3IgPyAkJC5sZXZlbENvbG9yKGQuZGF0YS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IoZC5kYXRhKSkpXHJcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBcIlwiIDogXCJub25lXCIpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRsZXQgbGluZUxlbmd0aCA9IDA7XHJcblx0XHRcdFx0Y29uc3QgbGluZVRoaWNrbmVzcyA9IDI7XHJcblx0XHRcdFx0bGV0IHggPSAwO1xyXG5cdFx0XHRcdGxldCB5ID0gMDtcclxuXHRcdFx0XHRsZXQgdHJhbnNmb3JtID0gXCJcIjtcclxuXHJcblx0XHRcdFx0aWYgKGhpZGRlblRhcmdldElkcy5pbmRleE9mKGQuZGF0YS5pZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBpbm5lckxpbmVMZW5ndGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCAqXHJcblx0XHRcdFx0XHRcdCh1cGRhdGVkLmluZGV4ICsgMSk7XHJcblx0XHRcdFx0XHRjb25zdCBsaW5lQW5nbGUgPSB1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDI7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNJbm5lclJhZGl1cyA9IHN0YXRlLnJhZGl1cyAtIGlubmVyTGluZUxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnN0IGxpbmVQb3NpdGlvbmluZ0FuZ2xlID0gbGluZUFuZ2xlIC0gKGFyY0lubmVyUmFkaXVzID09PSAwID8gMCA6ICgxIC8gYXJjSW5uZXJSYWRpdXMpKTtcclxuXHJcblx0XHRcdFx0XHRsaW5lTGVuZ3RoID0gc3RhdGUucmFkaXVzRXhwYW5kZWQgLSBzdGF0ZS5yYWRpdXMgKyBpbm5lckxpbmVMZW5ndGg7XHJcblx0XHRcdFx0XHR4ID0gTWF0aC5jb3MobGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXM7XHJcblx0XHRcdFx0XHR5ID0gTWF0aC5zaW4obGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXM7XHJcblx0XHRcdFx0XHR0cmFuc2Zvcm0gPSBgcm90YXRlKCR7bGluZUFuZ2xlICogMTgwIC8gTWF0aC5QSX0sICR7eH0sICR7eX0pYDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGQzU2VsZWN0KHRoaXMpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBsaW5lTGVuZ3RoKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgbGluZVRoaWNrbmVzcylcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSlcclxuXHRcdFx0XHRcdC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgYDAsICR7bGluZUxlbmd0aCArIGxpbmVUaGlja25lc3N9LCAwYCk7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGJpbmRBcmNFdmVudChhcmMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNUb3VjaCA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xyXG5cdFx0Y29uc3QgaXNNb3VzZSA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiO1xyXG5cclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gc2VsZWN0QXJjKF90aGlzLCBhcmNEYXRhLCBpZCkge1xyXG5cdFx0XHQvLyB0cmFuc2l0aW9uc1xyXG5cdFx0XHQkJC5leHBhbmRBcmMoaWQpO1xyXG5cdFx0XHQkJC5hcGkuZm9jdXMoaWQpO1xyXG5cdFx0XHQkJC50b2dnbGVGb2N1c0xlZ2VuZChpZCwgdHJ1ZSk7XHJcblx0XHRcdCQkLnNob3dUb29sdGlwKFthcmNEYXRhXSwgX3RoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gdW5zZWxlY3RBcmMoYXJjRGF0YT8pIHtcclxuXHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHQkJC51bmV4cGFuZEFyYyhpZCk7XHJcblx0XHRcdCQkLmFwaS5yZXZlcnQoKTtcclxuXHRcdFx0JCQucmV2ZXJ0TGVnZW5kKCk7XHJcblx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0YXJjXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0bGV0IGFyY0RhdGE7XHJcblxyXG5cdFx0XHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRhcmNEYXRhID0gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKTtcclxuXHJcblx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSAmJiAkJC50b2dnbGVTaGFwZSh0aGlzLCBhcmNEYXRhLCBpKTtcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suYmluZCgkJC5hcGkpKGFyY0RhdGEsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gbW91c2UgZXZlbnRzXHJcblx0XHRpZiAoaXNNb3VzZSkge1xyXG5cdFx0XHRhcmNcclxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLnRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xyXG5cdFx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdFx0c2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcclxuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQodHJ1ZSwgYXJjRGF0YSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcclxuXHRcdFx0XHRcdGlmIChzdGF0ZS50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpO1xyXG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgYXJjRGF0YSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChbYXJjRGF0YV0sIHRoaXMpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRvdWNoIGV2ZW50c1xyXG5cdFx0aWYgKGlzVG91Y2ggJiYgJCQuaGFzQXJjVHlwZSgpICYmICEkJC5yYWRhcnMpIHtcclxuXHRcdFx0Y29uc3QgZ2V0RXZlbnRBcmMgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdG91Y2ggPSBkM0V2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBldmVudEFyYztcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoc3RhdGUudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZ2V0RXZlbnRBcmMoKTtcclxuXHRcdFx0XHRjb25zdCBkYXR1bTogYW55ID0gZXZlbnRBcmMuZGF0dW0oKTtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gKGRhdHVtICYmIGRhdHVtLmRhdGEgJiYgZGF0dW0uZGF0YS5pZCkgPyAkJC51cGRhdGVBbmdsZShkYXR1bSkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goYXJjRGF0YSk7XHJcblxyXG5cdFx0XHRcdGlzVW5kZWZpbmVkKGlkKSA/XHJcblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpIDogc2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdCQkLiRlbC5zdmdcclxuXHRcdFx0XHQub24oXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZXIpXHJcblx0XHRcdFx0Lm9uKFwidG91Y2htb3ZlXCIsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyY1RleHQoZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge21haW4sIGFyY3N9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblx0XHRjb25zdCBoYXNNdWx0aUFyY0dhdWdlID0gJCQuaGFzTXVsdGlBcmNHYXVnZSgpO1xyXG5cdFx0bGV0IHRleHQ7XHJcblxyXG5cdFx0Ly8gZm9yIGdhdWdlIHR5cGUsIHVwZGF0ZSB0ZXh0IHdoZW4gaGFzIG5vIHRpdGxlICYgbXVsdGkgZGF0YVxyXG5cdFx0aWYgKCEoaGFzR2F1Z2UgJiYgJCQuZGF0YS50YXJnZXRzLmxlbmd0aCA9PT0gMSAmJiBjb25maWcuZ2F1Z2VfdGl0bGUpKSB7XHJcblx0XHRcdHRleHQgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRBcmN9YClcclxuXHRcdFx0XHQuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+ICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpID8gQ0xBU1MuZ2F1Z2VWYWx1ZSA6IG51bGwpKVxyXG5cdFx0XHRcdC5jYWxsKCQkLnRleHRGb3JBcmNMYWJlbC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC50cmFuc2Zvcm1Gb3JBcmNMYWJlbC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgZCA9PiAoXHJcblx0XHRcdFx0XHQkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPT09IDEgJiYgIWhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdFx0XHRgJHtNYXRoLnJvdW5kKHN0YXRlLnJhZGl1cyAvIDUpfXB4YCA6IG51bGxcclxuXHRcdFx0XHQpKVxyXG5cdFx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+ICgkJC5pc1RhcmdldFRvU2hvdyhkLmRhdGEuaWQpICYmICQkLmlzQXJjVHlwZShkLmRhdGEpID8gXCIxXCIgOiBcIjBcIikpO1xyXG5cclxuXHRcdFx0aGFzTXVsdGlBcmNHYXVnZSAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBcIi0uMWVtXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NUaXRsZX1gKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmhhc1R5cGUoXCJkb251dFwiKSB8fCBoYXNHYXVnZSA/IFwiMVwiIDogXCIwXCIpO1xyXG5cclxuXHRcdGlmIChoYXNHYXVnZSkge1xyXG5cdFx0XHRjb25zdCBpc0Z1bGxDaXJjbGUgPSBjb25maWcuZ2F1Z2VfZnVsbENpcmNsZTtcclxuXHRcdFx0Y29uc3Qgc3RhcnRBbmdsZSA9IC0xICogTWF0aC5QSSAvIDI7XHJcblx0XHRcdGNvbnN0IGVuZEFuZ2xlID0gKGlzRnVsbENpcmNsZSA/IC00IDogLTEpICogc3RhcnRBbmdsZTtcclxuXHJcblx0XHRcdGlzRnVsbENpcmNsZSAmJiB0ZXh0ICYmIHRleHQuYXR0cihcImR5XCIsIGAke01hdGgucm91bmQoc3RhdGUucmFkaXVzIC8gMTQpfWApO1xyXG5cclxuXHRcdFx0bGV0IGJhY2tncm91bmRBcmMgPSAkJC4kZWwuYXJjcy5zZWxlY3QoXHJcblx0XHRcdFx0YCR7aGFzTXVsdGlBcmNHYXVnZSA/IFwiZ1wiIDogXCJcIn0uJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfWBcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGlmIChoYXNNdWx0aUFyY0dhdWdlKSB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gMDtcclxuXHJcblx0XHRcdFx0YmFja2dyb3VuZEFyYyA9IGJhY2tncm91bmRBcmNcclxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoYHBhdGguJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfWApXHJcblx0XHRcdFx0XHQuZGF0YSgkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmVudGVyKClcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBgJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfSAke0NMQVNTLmNoYXJ0QXJjc0JhY2tncm91bmR9LSR7aX1gKVxyXG5cdFx0XHRcdFx0Lm1lcmdlKGJhY2tncm91bmRBcmMpXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZDEgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAoc3RhdGUuaGlkZGVuVGFyZ2V0SWRzLmluZGV4T2YoZDEuaWQpID49IDApIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJNIDAgMFwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBkID0ge1xyXG5cdFx0XHRcdFx0XHRcdGRhdGE6IFt7dmFsdWU6IGNvbmZpZy5nYXVnZV9tYXh9XSxcclxuXHRcdFx0XHRcdFx0XHRzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRcdGVuZEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpbmRleCsrXHJcblx0XHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMuZXhpdCgpLnJlbW92ZSgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMuYXR0cihcImRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgZCA9IHtcclxuXHRcdFx0XHRcdFx0ZGF0YTogW3t2YWx1ZTogY29uZmlnLmdhdWdlX21heH1dLFxyXG5cdFx0XHRcdFx0XHRzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRlbmRBbmdsZVxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VVbml0fWApXHJcblx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi43NWVtXCIpXHJcblx0XHRcdFx0LnRleHQoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBjb25maWcuZ2F1Z2VfdW5pdHMgOiBcIlwiKTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuZ2F1Z2VfbGFiZWxfc2hvdykge1xyXG5cdFx0XHRcdGFyY3Muc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NHYXVnZU1pbn1gKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCBgJHstMSAqIChzdGF0ZS5pbm5lclJhZGl1cyArICgoc3RhdGUucmFkaXVzIC0gc3RhdGUuaW5uZXJSYWRpdXMpIC8gKGlzRnVsbENpcmNsZSA/IDEgOiAyKSkpfXB4YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIxLjJlbVwiKVxyXG5cdFx0XHRcdFx0LnRleHQoJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9taW4sIGZhbHNlKSk7XHJcblxyXG5cdFx0XHRcdC8vIHNob3cgbWF4IHRleHQgd2hlbiBpc24ndCBmdWxsQ2lyY2xlXHJcblx0XHRcdFx0IWlzRnVsbENpcmNsZSAmJiBhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXh9YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7c3RhdGUuaW5uZXJSYWRpdXMgKyAoKHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzKSAvIDIpfXB4YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIxLjJlbVwiKVxyXG5cdFx0XHRcdFx0LnRleHQoJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9tYXgsIHRydWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRHYXVnZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge2FyY3N9fSA9ICQkO1xyXG5cdFx0Y29uc3QgYXBwZW5kVGV4dCA9IGNsYXNzTmFtZSA9PiB7XHJcblx0XHRcdGFyY3MuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NOYW1lKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XHJcblx0XHRcdGFyY3MuYXBwZW5kKCQkLmhhc011bHRpQXJjR2F1Z2UoKSA/IFwiZ1wiIDogXCJwYXRoXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kKTtcclxuXHJcblx0XHRcdGNvbmZpZy5nYXVnZV91bml0cyAmJiBhcHBlbmRUZXh0KENMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdCk7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cpIHtcclxuXHRcdFx0XHRhcHBlbmRUZXh0KENMQVNTLmNoYXJ0QXJjc0dhdWdlTWluKTtcclxuXHRcdFx0XHQhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgJiYgYXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZU1heCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRHYXVnZUxhYmVsSGVpZ2h0KCk6IDIwIHwgMCB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuZ2F1Z2VfbGFiZWxfc2hvdyA/IDIwIDogMDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0ZXZlbnQgYXMgZDNFdmVudFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtLRVl9IGZyb20gXCIuLi8uLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldE1pbk1heCwgZ2V0UmFuZ2UsIGlzRGVmaW5lZCwgaXNFbXB0eSwgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBzZXRUZXh0VmFsdWUsIHRvQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgcG9zaXRpb24gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFufSBpc0Nsb2Nrd2lzZSBJZiB0aGUgZGlyZWN0aW9uIGlzIGNsb2Nrd2lzZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBDb29yZGluYXRlIHR5cGUgJ3gnIG9yICd5J1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZWRnZSBOdW1iZXIgb2YgZWRnZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcG9zIFRoZSBpbmRleGVkIHBvc2l0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYW5nZSBSYW5nZSB2YWx1ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmF0aW8gUmF0aW8gdmFsdWVcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGlzQ2xvY2t3aXNlOiBib29sZWFuLCB0eXBlOiBcInhcIiB8IFwieVwiLCBlZGdlOiBudW1iZXIsIHBvczogbnVtYmVyLCByYW5nZTogbnVtYmVyLCByYXRpbzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRjb25zdCBpbmRleCA9IGlzQ2xvY2t3aXNlICYmIHBvcyA+IDAgPyBlZGdlIC0gcG9zIDogcG9zO1xyXG5cdGNvbnN0IHIgPSAyICogTWF0aC5QSTtcclxuXHRjb25zdCBmdW5jID0gdHlwZSA9PT0gXCJ4XCIgPyBNYXRoLnNpbiA6IE1hdGguY29zO1xyXG5cclxuXHRyZXR1cm4gcmFuZ2UgKiAoMSAtIHJhdGlvICogZnVuYyhpbmRleCAqIHIgLyBlZGdlKSk7XHJcbn1cclxuXHJcbi8vIGNhY2hlIGtleVxyXG5jb25zdCBjYWNoZUtleSA9IEtFWS5yYWRhclBvaW50cztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0UmFkYXIoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2N1cnJlbnR9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJyYWRhclwiKSkge1xyXG5cdFx0XHQkZWwucmFkYXIgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0UmFkYXJzKTtcclxuXHJcblx0XHRcdC8vIGxldmVsXHJcblx0XHRcdCRlbC5yYWRhci5sZXZlbHMgPSAkZWwucmFkYXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGV2ZWxzKTtcclxuXHJcblx0XHRcdC8vIGF4aXNcclxuXHRcdFx0JGVsLnJhZGFyLmF4ZXMgPSAkZWwucmFkYXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYXhpcyk7XHJcblxyXG5cdFx0XHQvLyBzaGFwZXNcclxuXHRcdFx0JGVsLnJhZGFyLnNoYXBlcyA9ICRlbC5yYWRhci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5zaGFwZXMpO1xyXG5cclxuXHRcdFx0Y3VycmVudC5kYXRhTWF4ID0gY29uZmlnLnJhZGFyX2F4aXNfbWF4IHx8ICQkLmdldE1pbk1heERhdGEoKS5tYXhbMF0udmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkYXJTaXplKCk6IFtudW1iZXIsIG51bWJlcl0ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHthcmNXaWR0aCwgYXJjSGVpZ2h0fX0gPSAkJDtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoIDwgNCA/IC0yMCA6IDEwO1xyXG5cdFx0Y29uc3Qgc2l6ZSA9IChNYXRoLm1pbihhcmNXaWR0aCwgYXJjSGVpZ2h0KSAtIHBhZGRpbmcpIC8gMjtcclxuXHJcblx0XHRyZXR1cm4gW3NpemUsIHNpemVdO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmIChpc0VtcHR5KGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcykpIHtcclxuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gZ2V0UmFuZ2UoMCwgZ2V0TWluTWF4KFwibWF4XCIsIHRhcmdldHMubWFwKHYgPT4gdi52YWx1ZXMubGVuZ3RoKSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmdlbmVyYXRlUmFkYXJQb2ludHMoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRSYWRhclBvc2l0aW9uKHR5cGUsIGluZGV4OiBudW1iZXIsIHJhbmdlLCByYXRpbzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IGVkZ2UgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xyXG5cdFx0Y29uc3QgaXNDbG9ja3dpc2UgPSBjb25maWcucmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZTtcclxuXHJcblx0XHRjb25zdCBwb3MgPSB0b0FycmF5KHR5cGUpLm1hcCh2ID0+IGdldFBvc2l0aW9uKFxyXG5cdFx0XHRpc0Nsb2Nrd2lzZSxcclxuXHRcdFx0dixcclxuXHRcdFx0ZWRnZSxcclxuXHRcdFx0aW5kZXgsXHJcblx0XHRcdGlzRGVmaW5lZChyYW5nZSkgPyByYW5nZSA6ICh0eXBlID09PSBcInhcIiA/IHdpZHRoIDogaGVpZ2h0KSxcclxuXHRcdFx0aXNOdW1iZXIocmF0aW8pID8gcmF0aW8gOiBjb25maWcucmFkYXJfc2l6ZV9yYXRpb1xyXG5cdFx0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHBvcy5sZW5ndGggPT09IDEgPyBwb3NbMF0gOiBwb3M7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgZGF0YSBwb2ludHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlUmFkYXJQb2ludHMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzO1xyXG5cclxuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cdFx0Y29uc3QgcG9pbnRzID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KSB8fCB7fTtcclxuXHRcdGNvbnN0IHNpemUgPSBwb2ludHMuX3NpemU7XHJcblxyXG5cdFx0Ly8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb25seSB3aGVuIHRoZSBwcmV2aW91cyBkaW1lbnNpb24gaGFzIGJlZW4gY2hhbmdlZFxyXG5cdFx0aWYgKCFzaXplIHx8IChzaXplLndpZHRoICE9PSB3aWR0aCAmJiBzaXplLmhlaWdodCAhPT0gaGVpZ2h0KSkge1xyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0cG9pbnRzW2QuaWRdID0gZC52YWx1ZXMubWFwKCh2LCBpKSA9PiAoXHJcblx0XHRcdFx0XHQkJC5nZXRSYWRhclBvc2l0aW9uKFtcInhcIiwgXCJ5XCJdLCBpLCB1bmRlZmluZWQsICQkLmdldFJhdGlvKFwicmFkYXJcIiwgdikpXHJcblx0XHRcdFx0KSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cG9pbnRzLl9zaXplID0ge3dpZHRoLCBoZWlnaHR9O1xyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIHBvaW50cyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVkcmF3UmFkYXIoZHVyYXRpb25Gb3JFeGl0OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtyYWRhciwgbWFpbn0gPSAkJC4kZWw7XHJcblx0XHRjb25zdCB0cmFuc2xhdGUgPSAkJC5nZXRUcmFuc2xhdGUoXCJyYWRhclwiKTtcclxuXHJcblx0XHQvLyBBZGp1c3QgcmFkYXIsIGNpcmNsZXMgYW5kIHRleHRzJyBwb3NpdGlvblxyXG5cdFx0aWYgKHRyYW5zbGF0ZSkge1xyXG5cdFx0XHRyYWRhci5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfWApLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlKTtcclxuXHRcdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0VGV4dHN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xyXG5cclxuXHRcdFx0JCQuZ2VuZXJhdGVSYWRhclBvaW50cygpO1xyXG5cdFx0XHQkJC51cGRhdGVSYWRhckxldmVsKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVJhZGFyQXhlcygpO1xyXG5cdFx0XHQkJC51cGRhdGVSYWRhclNoYXBlKGR1cmF0aW9uRm9yRXhpdCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRSYWRhclBvaW50cygpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0XHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2QuaWRdW2ldO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVSYWRhckxldmVsKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3JhZGFyfX0gPSAkJDtcclxuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cdFx0Y29uc3QgZGVwdGggPSBjb25maWcucmFkYXJfbGV2ZWxfZGVwdGg7XHJcblx0XHRjb25zdCBlZGdlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IHNob3dUZXh0ID0gY29uZmlnLnJhZGFyX2xldmVsX3RleHRfc2hvdztcclxuXHJcblx0XHRjb25zdCByYWRhckxldmVscyA9IHJhZGFyLmxldmVscztcclxuXHRcdGNvbnN0IGxldmVsRGF0YSA9IGdldFJhbmdlKDAsIGRlcHRoKTtcclxuXHJcblx0XHRjb25zdCByYWRpdXMgPSBjb25maWcucmFkYXJfc2l6ZV9yYXRpbyAqIE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0Y29uc3QgbGV2ZWxSYXRpbyA9IGxldmVsRGF0YS5tYXAobCA9PiByYWRpdXMgKiAoKGwgKyAxKSAvIGRlcHRoKSk7XHJcblx0XHRjb25zdCBsZXZlbFRleHRGb3JtYXQgPSAoY29uZmlnLnJhZGFyX2xldmVsX3RleHRfZm9ybWF0IHx8IGZ1bmN0aW9uKCkge30pLmJpbmQoJCQuYXBpKTtcclxuXHJcblx0XHQvLyBHZW5lcmF0ZSBwb2ludHNcclxuXHRcdGNvbnN0IHBvaW50cyA9IGxldmVsRGF0YS5tYXAodiA9PiB7XHJcblx0XHRcdGNvbnN0IHJhbmdlID0gbGV2ZWxSYXRpb1t2XTtcclxuXHRcdFx0Y29uc3QgcG9zID0gZ2V0UmFuZ2UoMCwgZWRnZSkubWFwKGkgPT4gKFxyXG5cdFx0XHRcdCQkLmdldFJhZGFyUG9zaXRpb24oW1wieFwiLCBcInlcIl0sIGksIHJhbmdlLCAxKSkuam9pbihcIixcIilcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiBwb3Muam9pbihcIiBcIik7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCBsZXZlbCA9IHJhZGFyTGV2ZWxzXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxldmVsfWApXHJcblx0XHRcdC5kYXRhKGxldmVsRGF0YSk7XHJcblxyXG5cdFx0bGV2ZWwuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdGNvbnN0IGxldmVsRW50ZXIgPSBsZXZlbC5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MubGV2ZWx9ICR7Q0xBU1MubGV2ZWx9LSR7aX1gKTtcclxuXHJcblx0XHRsZXZlbEVudGVyLmFwcGVuZChcInBvbHlnb25cIilcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWcucmFkYXJfbGV2ZWxfc2hvdyA/IG51bGwgOiBcImhpZGRlblwiKTtcclxuXHJcblx0XHRpZiAoc2hvd1RleHQpIHtcclxuXHRcdFx0aWYgKHJhZGFyTGV2ZWxzLnNlbGVjdChcInRleHRcIikuZW1wdHkoKSkge1xyXG5cdFx0XHRcdHJhZGFyTGV2ZWxzXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCBcIi0uNWVtXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiLS43ZW1cIilcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXHJcblx0XHRcdFx0XHQudGV4dCgoKSA9PiBsZXZlbFRleHRGb3JtYXQoMCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsZXZlbEVudGVyLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImR4XCIsIFwiLS41ZW1cIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxyXG5cdFx0XHRcdC50ZXh0KGQgPT4gbGV2ZWxUZXh0Rm9ybWF0KFxyXG5cdFx0XHRcdFx0c3RhdGUuY3VycmVudC5kYXRhTWF4IC8gbGV2ZWxEYXRhLmxlbmd0aCAqIChkICsgMSlcclxuXHRcdFx0XHQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXZlbEVudGVyXHJcblx0XHRcdC5tZXJnZShsZXZlbClcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKCR7d2lkdGggLSBsZXZlbFJhdGlvW2RdfSwgJHtoZWlnaHQgLSBsZXZlbFJhdGlvW2RdfSlgKVxyXG5cdFx0XHQuc2VsZWN0QWxsKFwicG9seWdvblwiKVxyXG5cdFx0XHQuYXR0cihcInBvaW50c1wiLCBkID0+IHBvaW50c1tkXSk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGxldmVsIHRleHQgcG9zaXRpb25cclxuXHRcdGlmIChzaG93VGV4dCkge1xyXG5cdFx0XHRyYWRhckxldmVscy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIGQgPT4gKGlzVW5kZWZpbmVkKGQpID8gd2lkdGggOiBwb2ludHNbZF0uc3BsaXQoXCIsXCIpWzBdKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgZCA9PiAoaXNVbmRlZmluZWQoZCkgPyBoZWlnaHQgOiAwKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkYXJBeGVzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7cmFkYXJ9fSA9ICQkO1xyXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XHJcblx0XHRjb25zdCBjYXRlZ29yaWVzID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cclxuXHRcdGxldCBheGlzID0gcmFkYXIuYXhlcy5zZWxlY3RBbGwoXCJnXCIpXHJcblx0XHRcdC5kYXRhKGNhdGVnb3JpZXMpO1xyXG5cclxuXHRcdGF4aXMuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdGNvbnN0IGF4aXNFbnRlciA9IGF4aXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGAke0NMQVNTLmF4aXN9LSR7aX1gKTtcclxuXHJcblx0XHRjb25maWcucmFkYXJfYXhpc19saW5lX3Nob3cgJiYgYXhpc0VudGVyLmFwcGVuZChcImxpbmVcIik7XHJcblx0XHRjb25maWcucmFkYXJfYXhpc190ZXh0X3Nob3cgJiYgYXhpc0VudGVyLmFwcGVuZChcInRleHRcIik7XHJcblxyXG5cdFx0YXhpcyA9IGF4aXNFbnRlci5tZXJnZShheGlzKTtcclxuXHJcblx0XHQvLyBheGlzIGxpbmVcclxuXHRcdGlmIChjb25maWcucmFkYXJfYXhpc19saW5lX3Nob3cpIHtcclxuXHRcdFx0YXhpcy5zZWxlY3QoXCJsaW5lXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB3aWR0aClcclxuXHRcdFx0XHQuYXR0cihcInkxXCIsIGhlaWdodClcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIChkLCBpKSA9PiAkJC5nZXRSYWRhclBvc2l0aW9uKFwieFwiLCBpKSlcclxuXHRcdFx0XHQuYXR0cihcInkyXCIsIChkLCBpKSA9PiAkJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXhpcyB0ZXh0XHJcblx0XHRpZiAoY29uZmlnLnJhZGFyX2F4aXNfdGV4dF9zaG93KSB7XHJcblx0XHRcdGNvbnN0IHt4ID0gMCwgeSA9IDB9ID0gY29uZmlnLnJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbjtcclxuXHJcblx0XHRcdGF4aXMuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi41ZW1cIilcclxuXHRcdFx0XHQuY2FsbChzZWxlY3Rpb24gPT4ge1xyXG5cdFx0XHRcdFx0c2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0XHRzZXRUZXh0VmFsdWUoZDNTZWxlY3QodGhpcyksIFN0cmluZyhkKSwgWy0wLjYsIDEuMl0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQuZGF0dW0oKGQsIGkpID0+ICh7aW5kZXg6IGl9KSlcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodGhpcy53aWR0aCkpIHtcclxuXHRcdFx0XHRcdFx0Ly8gY2FjaGUgZXZhbHVhdGVkIGF4aXMgdGV4dCB3aWR0aFxyXG5cdFx0XHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIDI7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IHBvc1ggPSAkJC5nZXRSYWRhclBvc2l0aW9uKFwieFwiLCBkLmluZGV4LCB1bmRlZmluZWQsIDEpO1xyXG5cdFx0XHRcdFx0bGV0IHBvc1kgPSBNYXRoLnJvdW5kKCQkLmdldFJhZGFyUG9zaXRpb24oXCJ5XCIsIGQuaW5kZXgsIHVuZGVmaW5lZCwgMSkpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChwb3NYID4gd2lkdGgpIHtcclxuXHRcdFx0XHRcdFx0cG9zWCArPSB0aGlzLndpZHRoICsgeDtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoTWF0aC5yb3VuZChwb3NYKSA8IHdpZHRoKSB7XHJcblx0XHRcdFx0XHRcdHBvc1ggLT0gdGhpcy53aWR0aCArIHg7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHBvc1kgPiBoZWlnaHQpIHtcclxuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHZlcnRpY2FsIGNlbnRlcmVkIGVkZ2UgYXhpcyB0ZXh0IGR5IHBvc2l0aW9uXHJcblx0XHRcdFx0XHRcdGlmIChwb3NZIC8gMiA9PT0gaGVpZ2h0ICYmIHRoaXMuZmlyc3RDaGlsZC50YWdOYW1lID09PSBcInRzcGFuXCIpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiZHlcIiwgXCIwZW1cIik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHBvc1kgKz0geTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG9zWSA8IGhlaWdodCkge1xyXG5cdFx0XHRcdFx0XHRwb3NZIC09IHk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGB0cmFuc2xhdGUoJHtwb3NYfSAke3Bvc1l9KWA7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuYmluZEV2ZW50KCk7XHJcblx0fSxcclxuXHJcblx0YmluZEV2ZW50KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtpbnB1dFR5cGUsIHRyYW5zaXRpbmd9LCAkZWw6IHtyYWRhciwgc3ZnfX0gPSAkJDtcclxuXHRcdGNvbnN0IGZvY3VzT25seSA9IGNvbmZpZy5wb2ludF9mb2N1c19vbmx5O1xyXG5cclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCkge1xyXG5cdFx0XHRjb25zdCBpc01vdXNlID0gaW5wdXRUeXBlID09PSBcIm1vdXNlXCI7XHJcblx0XHRcdGNvbnN0IGdldEluZGV4ID0gKCkgPT4ge1xyXG5cdFx0XHRcdGxldCB0YXJnZXQgPSBkM0V2ZW50LnRhcmdldDtcclxuXHJcblx0XHRcdFx0Ly8gaW4gY2FzZSBvZiBtdWx0aWxpbmVkIGF4aXMgdGV4dFxyXG5cdFx0XHRcdGlmICgvdHNwYW4vaS50ZXN0KHRhcmdldC50YWdOYW1lKSkge1xyXG5cdFx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBkOiBhbnkgPSBkM1NlbGVjdCh0YXJnZXQpLmRhdHVtKCk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBkICYmIE9iamVjdC5rZXlzKGQpLmxlbmd0aCA9PT0gMSA/IGQuaW5kZXggOiB1bmRlZmluZWQ7XHJcblx0XHRcdH07XHJcblx0XHRcdGNvbnN0IGhpZGUgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBnZXRJbmRleCgpO1xyXG5cdFx0XHRcdGNvbnN0IG5vSW5kZXggPSBpc1VuZGVmaW5lZChpbmRleCk7XHJcblxyXG5cdFx0XHRcdGlmIChpc01vdXNlIHx8IG5vSW5kZXgpIHtcclxuXHRcdFx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblxyXG5cdFx0XHRcdFx0Zm9jdXNPbmx5ID9cclxuXHRcdFx0XHRcdFx0JCQuaGlkZUNpcmNsZUZvY3VzKCkgOlxyXG5cdFx0XHRcdFx0XHQkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaXNNb3VzZSkge1xyXG5cdFx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBpbmRleCk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHJhZGFyLmF4ZXMuc2VsZWN0QWxsKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5vbihpc01vdXNlID8gXCJtb3VzZW92ZXIgXCIgOiBcInRvdWNoc3RhcnRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKHRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KCk7XHJcblxyXG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvclNpbmdsZShzdmcubm9kZSgpLCBudWxsLCBpbmRleCk7XHJcblx0XHRcdFx0XHRpc01vdXNlID8gJCQuc2V0T3Zlck91dCh0cnVlLCBpbmRleCkgOiAkJC5jYWxsT3Zlck91dEZvclRvdWNoKGluZGV4KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsIGlzTW91c2UgPyBoaWRlIDogbnVsbCk7XHJcblxyXG5cdFx0XHRpZiAoIWlzTW91c2UpIHtcclxuXHRcdFx0XHRzdmcub24oXCJ0b3VjaHN0YXJ0XCIsIGhpZGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkYXJTaGFwZShkdXJhdGlvbkZvckV4aXQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHM7XHJcblx0XHRjb25zdCBwb2ludHMgPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGNvbnN0IGFyZWFzID0gJCQuJGVsLnJhZGFyLnNoYXBlc1xyXG5cdFx0XHQuc2VsZWN0QWxsKFwicG9seWdvblwiKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKTtcclxuXHJcblx0XHRjb25zdCBhcmVhc0VudGVyID0gYXJlYXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NDaGFydFJhZGFyLmJpbmQoJCQpKTtcclxuXHJcblx0XHRhcmVhcy5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRhcmVhc0VudGVyXHJcblx0XHRcdC5hcHBlbmQoXCJwb2x5Z29uXCIpXHJcblx0XHRcdC5tZXJnZShhcmVhcylcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuYXR0cihcInBvaW50c1wiLCBkID0+IHBvaW50c1tkLmlkXS5qb2luKFwiIFwiKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgcG9pbnQgeCBjb29yZGluYXRlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmFkYXJDaXJjbGVYKGQpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KVtkLmlkXVtkLmluZGV4XVswXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgZGF0YSBwb2ludCB5IGNvb3JkaW5hdGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyYWRhckNpcmNsZVkoZCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpW2QuaWRdW2QuaW5kZXhdWzFdO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogTW9kdWxlcyBleHBvcnRzIGZvciBBcmMgYmFzZWQgY2hhcnRcclxuICovXHJcbi8vIHNoYXBlXHJcbmltcG9ydCBhcmMgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYXJjXCI7XHJcbmltcG9ydCByYWRhciBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9yYWRhclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGludGVybmFsID0gW1xyXG5cdGFyYyxcclxuXHRyYWRhclxyXG5dO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHR0aW1lUGFyc2UgYXMgZDNUaW1lUGFyc2UsXHJcblx0dGltZUZvcm1hdCBhcyBkM1RpbWVGb3JtYXQsXHJcblx0dXRjUGFyc2UgYXMgZDNVdGNQYXJzZSxcclxuXHR1dGNGb3JtYXQgYXMgZDNVdGNGb3JtYXRcclxufSBmcm9tIFwiZDMtdGltZS1mb3JtYXRcIjtcclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQgU3RvcmUgZnJvbSBcIi4uL2NvbmZpZy9TdG9yZS9TdG9yZVwiO1xyXG5pbXBvcnQgT3B0aW9ucyBmcm9tIFwiLi4vY29uZmlnL09wdGlvbnMvT3B0aW9uc1wiO1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ2FjaGUgZnJvbSBcIi4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2dlbmVyYXRlUmVzaXplfSBmcm9tIFwiLi4vbW9kdWxlL2dlbmVyYXRvclwiO1xyXG5pbXBvcnQge2V4dGVuZCwgbm90RW1wdHksIGNvbnZlcnRJbnB1dFR5cGUsIGdldE9wdGlvbiwgaXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzU3RyaW5nLCBjYWxsRm4sIHNvcnRWYWx1ZX0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vLyBBeGlzXHJcbmltcG9ydCBBeGlzIGZyb20gXCIuL0F4aXMvQXhpc1wiO1xyXG5cclxuLy8gZGF0YVxyXG5pbXBvcnQgZGF0YUNvbnZlcnQgZnJvbSBcIi4vZGF0YS9kYXRhLmNvbnZlcnRcIjtcclxuaW1wb3J0IGRhdGEgZnJvbSBcIi4vZGF0YS9kYXRhXCI7XHJcbmltcG9ydCBkYXRhTG9hZCBmcm9tIFwiLi9kYXRhL2RhdGEubG9hZFwiO1xyXG5cclxuLy8gaW50ZXJhY3Rpb25zXHJcbmltcG9ydCBpbnRlcmFjdGlvbiBmcm9tIFwiLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25cIjtcclxuXHJcbi8vIGludGVybmFsc1xyXG5pbXBvcnQgY2xhc3NNb2R1bGUgZnJvbSBcIi4vaW50ZXJuYWxzL2NsYXNzXCI7XHJcbmltcG9ydCBjYXRlZ29yeSBmcm9tIFwiLi9pbnRlcm5hbHMvY2F0ZWdvcnlcIjsgLy8gdXNlZCB0byByZXRyaWV2ZSByYWRhciBBeGlzIG5hbWVcclxuaW1wb3J0IGNvbG9yIGZyb20gXCIuL2ludGVybmFscy9jb2xvclwiO1xyXG5pbXBvcnQgZG9tYWluIGZyb20gXCIuL2ludGVybmFscy9kb21haW5cIjtcclxuaW1wb3J0IGZvcm1hdCBmcm9tIFwiLi9pbnRlcm5hbHMvZm9ybWF0XCI7XHJcbmltcG9ydCBsZWdlbmQgZnJvbSBcIi4vaW50ZXJuYWxzL2xlZ2VuZFwiO1xyXG5pbXBvcnQgcmVkcmF3IGZyb20gXCIuL2ludGVybmFscy9yZWRyYXdcIjtcclxuaW1wb3J0IHNjYWxlIGZyb20gXCIuL2ludGVybmFscy9zY2FsZVwiO1xyXG5pbXBvcnQgc2l6ZSBmcm9tIFwiLi9pbnRlcm5hbHMvc2l6ZVwiO1xyXG5pbXBvcnQgdGV4dCBmcm9tIFwiLi9pbnRlcm5hbHMvdGV4dFwiO1xyXG5pbXBvcnQgdGl0bGUgZnJvbSBcIi4vaW50ZXJuYWxzL3RpdGxlXCI7XHJcbmltcG9ydCB0b29sdGlwIGZyb20gXCIuL2ludGVybmFscy90b29sdGlwXCI7XHJcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSBcIi4vaW50ZXJuYWxzL3RyYW5zZm9ybVwiO1xyXG5pbXBvcnQgdHlwZSBmcm9tIFwiLi9pbnRlcm5hbHMvdHlwZVwiO1xyXG5cclxuaW1wb3J0IHtpbnRlcm5hbCBhcyBheGlzSW50ZXJuYWx9IGZyb20gXCIuLi9jb25maWcvcmVzb2x2ZXIvYXhpc1wiO1xyXG5pbXBvcnQge2ludGVybmFsIGFzIGFyY0ludGVybmFsfSBmcm9tIFwiLi4vY29uZmlnL3Jlc29sdmVyL2FyY1wiO1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGNoYXJ0IGNsYXNzLlxyXG4gKiAtIE5vdGU6IEluc3RhbnRpYXRlZCBpbnRlcm5hbGx5LCBub3QgZXhwb3NlZCBmb3IgcHVibGljLlxyXG4gKiBAY2xhc3MgQ2hhcnRJbnRlcm5hbFxyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFydEludGVybmFsIHtcclxuXHRwdWJsaWMgYXBpO1x0Ly8gQVBJIGludGVyZmFjZVxyXG5cdHB1YmxpYyBjb25maWc7IC8vIGNvbmZpZyBvYmplY3RcclxuXHRwdWJsaWMgY2FjaGU7IC8vIGNhY2hlIGluc3RhbmNlXHJcblx0cHVibGljICRlbDsgLy8gZWxlbWVudHNcclxuXHRwdWJsaWMgc3RhdGU7IC8vIHN0YXRlIHZhcmlhYmxlc1xyXG5cdHB1YmxpYyBjaGFydHM7IC8vIGFsbCBDaGFydCBpbnN0YW5jZXMgYXJyYXkgd2l0aGluIHBhZ2UgKGVxdWl2YWxlbnQgb2YgJ2JiLmluc3RhbmNlcycpXHJcblxyXG5cdC8vIGRhdGEgb2JqZWN0XHJcblx0cHVibGljIGRhdGEgPSB7XHJcblx0XHR4czoge30sXHJcblx0XHR0YXJnZXRzOiBbXVxyXG5cdH07XHJcblxyXG5cdC8vIEF4aXNcclxuXHRwdWJsaWMgYXhpczsgLy8gQXhpc1xyXG5cclxuXHQvLyBzY2FsZXNcclxuXHRwdWJsaWMgc2NhbGUgPSB7XHJcblx0XHR4OiBudWxsLFxyXG5cdFx0eTogbnVsbCxcclxuXHRcdHkyOiBudWxsLFxyXG5cdFx0c3ViWDogbnVsbCxcclxuXHRcdHN1Ylk6IG51bGwsXHJcblx0XHRzdWJZMjogbnVsbCxcclxuXHRcdHpvb206IG51bGxcclxuXHR9XHJcblxyXG5cdC8vIG9yaWdpbmFsIHZhbHVlc1xyXG5cdHB1YmxpYyBvcmcgPSB7XHJcblx0XHR4U2NhbGU6IG51bGwsXHJcblx0XHR4RG9tYWluOiBudWxsXHJcblx0fTtcclxuXHJcblx0Ly8gZm9ybWF0dGVyIGZ1bmN0aW9uXHJcblx0cHVibGljIGNvbG9yO1xyXG5cdHB1YmxpYyBwYXR0ZXJucztcclxuXHRwdWJsaWMgbGV2ZWxDb2xvcjtcclxuXHRwdWJsaWMgcG9pbnQ7XHJcblx0cHVibGljIGJydXNoO1xyXG5cclxuXHQvLyBmb3JtYXQgZnVuY3Rpb25cclxuXHRwdWJsaWMgZm9ybWF0ID0ge1xyXG5cdFx0ZXh0cmFMaW5lQ2xhc3NlczogbnVsbCxcclxuXHRcdHhBeGlzVGljazogbnVsbCxcclxuXHRcdGRhdGFUaW1lOiBudWxsLCAvLyBkYXRhVGltZUZvcm1hdFxyXG5cdFx0ZGVmYXVsdEF4aXNUaW1lOiBudWxsLCAvLyBkZWZhdWx0QXhpc1RpbWVGb3JtYXRcclxuXHRcdGF4aXNUaW1lOiBudWxsIC8vIGF4aXNUaW1lRm9ybWF0XHJcblx0fTtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBpKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuYXBpID0gYXBpOyAvLyBDaGFydCBpbnN0YW5jZVxyXG5cdFx0JCQuY29uZmlnID0gbmV3IE9wdGlvbnMoKTtcclxuXHRcdCQkLmNhY2hlID0gbmV3IENhY2hlKCk7XHJcblxyXG5cdFx0Y29uc3Qgc3RvcmUgPSBuZXcgU3RvcmUoKTtcclxuXHJcblx0XHQkJC4kZWwgPSBzdG9yZS5nZXRTdG9yZShcImVsZW1lbnRcIik7XHJcblx0XHQkJC5zdGF0ZSA9IHN0b3JlLmdldFN0b3JlKFwic3RhdGVcIik7XHJcblx0fVxyXG5cclxuXHRiZWZvcmVJbml0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGJlZm9yZUluaXRcIik7XHJcblxyXG5cdFx0Ly8gY2FuIGRvIHNvbWV0aGluZ1xyXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmJlZm9yZWluaXQsICQkLmFwaSk7XHJcblx0fVxyXG5cclxuXHRhZnRlckluaXQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkYWZ0ZXJJbml0XCIpO1xyXG5cclxuXHRcdC8vIGNhbiBkbyBzb21ldGhpbmdcclxuXHRcdGNhbGxGbigkJC5jb25maWcub25hZnRlcmluaXQsICQkLmFwaSk7XHJcblx0fVxyXG5cclxuXHRpbml0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHJcblx0XHRzdGF0ZS5oYXNBeGlzID0gISQkLmhhc0FyY1R5cGUoKTtcclxuXHRcdHN0YXRlLmhhc1JhZGFyID0gIXN0YXRlLmhhc0F4aXMgJiYgJCQuaGFzVHlwZShcInJhZGFyXCIpO1xyXG5cclxuXHRcdCQkLmluaXRQYXJhbXMoKTtcclxuXHJcblx0XHRjb25zdCBiaW5kdG8gPSB7XHJcblx0XHRcdGVsZW1lbnQ6IGNvbmZpZy5iaW5kdG8sXHJcblx0XHRcdGNsYXNzbmFtZTogXCJiYlwiXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb25maWcuYmluZHRvKSkge1xyXG5cdFx0XHRiaW5kdG8uZWxlbWVudCA9IGNvbmZpZy5iaW5kdG8uZWxlbWVudCB8fCBcIiNjaGFydFwiO1xyXG5cdFx0XHRiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgYmluZCBlbGVtZW50XHJcblx0XHQkZWwuY2hhcnQgPSBpc0Z1bmN0aW9uKGJpbmR0by5lbGVtZW50Lm5vZGUpID9cclxuXHRcdFx0Y29uZmlnLmJpbmR0by5lbGVtZW50IDogZDNTZWxlY3QoYmluZHRvLmVsZW1lbnQgfHwgW10pO1xyXG5cclxuXHRcdGlmICgkZWwuY2hhcnQuZW1wdHkoKSkge1xyXG5cdFx0XHQkZWwuY2hhcnQgPSBkM1NlbGVjdChkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuY2hhcnQuaHRtbChcIlwiKS5jbGFzc2VkKGJpbmR0by5jbGFzc25hbWUsIHRydWUpO1xyXG5cclxuXHRcdCQkLmluaXRUb1JlbmRlcigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3NcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlZCBGb3JjZSB0byByZW5kZXIgcHJvY2Vzc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFRvUmVuZGVyKGZvcmNlZD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc0hpZGRlbiA9ICgpID0+IGNoYXJ0LnN0eWxlKFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIgfHwgY2hhcnQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiO1xyXG5cclxuXHRcdGNvbnN0IGlzTGF6eSA9IGNvbmZpZy5yZW5kZXIubGF6eSB8fCBpc0hpZGRlbigpO1xyXG5cdFx0Y29uc3QgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xyXG5cclxuXHRcdGlmIChpc0xhenkgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBjb25maWcucmVuZGVyLm9ic2VydmUgIT09IGZhbHNlICYmICFmb3JjZWQpIHtcclxuXHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9uLCBvYnNlcnZlcikgPT4ge1xyXG5cdFx0XHRcdGlmICghaXNIaWRkZW4oKSkge1xyXG5cdFx0XHRcdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG5cdFx0XHRcdFx0IXN0YXRlLnJlbmRlcmVkICYmICQkLmluaXRUb1JlbmRlcih0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pLm9ic2VydmUoY2hhcnQubm9kZSgpLCB7XHJcblx0XHRcdFx0YXR0cmlidXRlczogdHJ1ZSxcclxuXHRcdFx0XHRhdHRyaWJ1dGVGaWx0ZXI6IFtcImNsYXNzXCIsIFwic3R5bGVcIl1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc0xhenkgfHwgZm9yY2VkKSB7XHJcblx0XHRcdGNvbnN0IGNvbnZlcnRlZERhdGEgPSAkJC5jb252ZXJ0RGF0YShjb25maWcsICQkLmluaXRXaXRoRGF0YSk7XHJcblxyXG5cdFx0XHRjb252ZXJ0ZWREYXRhICYmICQkLmluaXRXaXRoRGF0YShjb252ZXJ0ZWREYXRhKTtcclxuXHRcdFx0JCQuYWZ0ZXJJbml0KCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpbml0UGFyYW1zKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgZm9ybWF0LCBzdGF0ZX0gPSA8YW55PiAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Ly8gZGF0ZXRpbWUgdG8gYmUgdXNlZCBmb3IgdW5pcXVlbmVzc1xyXG5cdFx0c3RhdGUuZGF0ZXRpbWVJZCA9IGBiYi0keytuZXcgRGF0ZSgpfWA7XHJcblxyXG5cdFx0JCQuY29sb3IgPSAkJC5nZW5lcmF0ZUNvbG9yKCk7XHJcblx0XHQkJC5sZXZlbENvbG9yID0gJCQuZ2VuZXJhdGVMZXZlbENvbG9yKCk7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1BvaW50VHlwZSgpKSB7XHJcblx0XHRcdCQkLnBvaW50ID0gJCQuZ2VuZXJhdGVQb2ludCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5oYXNBeGlzKSB7XHJcblx0XHRcdCQkLmluaXRDbGlwKCk7XHJcblxyXG5cdFx0XHRmb3JtYXQuZXh0cmFMaW5lQ2xhc3NlcyA9ICQkLmdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MoKTtcclxuXHRcdFx0Zm9ybWF0LmRhdGFUaW1lID0gY29uZmlnLmRhdGFfeExvY2FsdGltZSA/IGQzVGltZVBhcnNlIDogZDNVdGNQYXJzZTtcclxuXHRcdFx0Zm9ybWF0LmF4aXNUaW1lID0gY29uZmlnLmF4aXNfeF9sb2NhbHRpbWUgPyBkM1RpbWVGb3JtYXQgOiBkM1V0Y0Zvcm1hdDtcclxuXHJcblx0XHRcdGNvbnN0IGlzRHJhZ1pvb20gPSAkJC5jb25maWcuem9vbV9lbmFibGVkICYmICQkLmNvbmZpZy56b29tX2VuYWJsZWQudHlwZSA9PT0gXCJkcmFnXCI7XHJcblxyXG5cdFx0XHRmb3JtYXQuZGVmYXVsdEF4aXNUaW1lID0gZCA9PiB7XHJcblx0XHRcdFx0Y29uc3Qge3gsIHpvb219ID0gJCQuc2NhbGU7XHJcblx0XHRcdFx0Y29uc3QgaXNab29tZWQgPSBpc0RyYWdab29tID8gem9vbSA6XHJcblx0XHRcdFx0XHR6b29tICYmIHgub3JnRG9tYWluKCkudG9TdHJpbmcoKSAhPT0gem9vbS5kb21haW4oKS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBzcGVjaWZpZXI6IHN0cmluZyA9IChkLmdldE1pbGxpc2Vjb25kcygpICYmIFwiLiVMXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXRTZWNvbmRzKCkgJiYgXCIuOiVTXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXRNaW51dGVzKCkgJiYgXCIlSTolTVwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0SG91cnMoKSAmJiBcIiVJICVwXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXREYXRlKCkgIT09IDEgJiYgXCIlYiAlZFwiKSB8fFxyXG5cdFx0XHRcdFx0KGlzWm9vbWVkICYmIGQuZ2V0RGF0ZSgpID09PSAxICYmIFwiJWJcXCcleVwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0TW9udGgoKSAmJiBcIiUtbS8lLWRcIikgfHwgXCIlWVwiO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZm9ybWF0LmF4aXNUaW1lKHNwZWNpZmllcikoZCk7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuaXNMZWdlbmRSaWdodCA9IGNvbmZpZy5sZWdlbmRfcG9zaXRpb24gPT09IFwicmlnaHRcIjtcclxuXHRcdHN0YXRlLmlzTGVnZW5kSW5zZXQgPSBjb25maWcubGVnZW5kX3Bvc2l0aW9uID09PSBcImluc2V0XCI7XHJcblxyXG5cdFx0c3RhdGUuaXNMZWdlbmRUb3AgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1yaWdodFwiO1xyXG5cclxuXHRcdHN0YXRlLmlzTGVnZW5kTGVmdCA9IGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1sZWZ0XCIgfHxcclxuXHRcdFx0Y29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwiYm90dG9tLWxlZnRcIjtcclxuXHJcblx0XHRzdGF0ZS5yb3RhdGVkUGFkZGluZ1JpZ2h0ID0gaXNSb3RhdGVkICYmICFjb25maWcuYXhpc194X3Nob3cgPyAwIDogMzA7XHJcblxyXG5cdFx0c3RhdGUuaW5wdXRUeXBlID0gY29udmVydElucHV0VHlwZShcclxuXHRcdFx0Y29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV9tb3VzZSxcclxuXHRcdFx0Y29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaFxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdGluaXRXaXRoRGF0YShkYXRhKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IDxhbnk+IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgc3RhdGUsICRlbCwgb3JnfSA9ICQkO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXN9ID0gc3RhdGU7XHJcblxyXG5cdFx0Ly8gZm9yIGFyYyB0eXBlLCBzZXQgYXhlcyB0byBub3QgYmUgc2hvd25cclxuXHRcdC8vICQkLmhhc0FyY1R5cGUoKSAmJiBbXCJ4XCIsIFwieVwiLCBcInkyXCJdLmZvckVhY2goaWQgPT4gKGNvbmZpZ1tgYXhpc18ke2lkfV9zaG93YF0gPSBmYWxzZSkpO1xyXG5cclxuXHRcdGlmIChoYXNBeGlzKSB7XHJcblx0XHRcdCQkLmF4aXMgPSBuZXcgQXhpcygkJCk7XHJcblx0XHRcdGNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuaW5pdFpvb20oKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0IGRhdGEgYXMgdGFyZ2V0c1xyXG5cdFx0JCQuZGF0YS54cyA9IHt9O1xyXG5cdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2ZpbHRlcikge1xyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKGNvbmZpZy5kYXRhX2ZpbHRlci5iaW5kKCQkLmFwaSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzIHRvIGhpZGUgaWYgbmVlZGVkXHJcblx0XHRpZiAoY29uZmlnLmRhdGFfaGlkZSkge1xyXG5cdFx0XHQkJC5hZGRIaWRkZW5UYXJnZXRJZHMoXHJcblx0XHRcdFx0Y29uZmlnLmRhdGFfaGlkZSA9PT0gdHJ1ZSA/XHJcblx0XHRcdFx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmRhdGFfaGlkZVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfaGlkZSkge1xyXG5cdFx0XHQkJC5hZGRIaWRkZW5MZWdlbmRJZHMoXHJcblx0XHRcdFx0Y29uZmlnLmxlZ2VuZF9oaWRlID09PSB0cnVlID9cclxuXHRcdFx0XHRcdCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cykgOiBjb25maWcubGVnZW5kX2hpZGVcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0IHNpemVzIGFuZCBzY2FsZXNcclxuXHRcdCQkLnVwZGF0ZVNpemVzKCk7XHJcblx0XHQkJC51cGRhdGVTY2FsZXModHJ1ZSk7XHJcblxyXG5cdFx0Ly8gcmV0cmlldmUgc2NhbGUgYWZ0ZXIgdGhlICd1cGRhdGVTY2FsZXMoKScgaXMgY2FsbGVkXHJcblx0XHRjb25zdCB7eCwgeSwgeTIsIHN1YlgsIHN1YlksIHN1YlkyfSA9IHNjYWxlO1xyXG5cclxuXHRcdC8vIFNldCBkb21haW5zIGZvciBlYWNoIHNjYWxlXHJcblx0XHRpZiAoeCkge1xyXG5cdFx0XHR4LmRvbWFpbihzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpKSk7XHJcblx0XHRcdHN1YlguZG9tYWluKHguZG9tYWluKCkpO1xyXG5cclxuXHRcdFx0Ly8gU2F2ZSBvcmlnaW5hbCB4IGRvbWFpbiBmb3Igem9vbSB1cGRhdGVcclxuXHRcdFx0b3JnLnhEb21haW4gPSB4LmRvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh5KSB7XHJcblx0XHRcdHkuZG9tYWluKCQkLmdldFlEb21haW4oJCQuZGF0YS50YXJnZXRzLCBcInlcIikpO1xyXG5cdFx0XHRzdWJZLmRvbWFpbih5LmRvbWFpbigpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoeTIpIHtcclxuXHRcdFx0eTIuZG9tYWluKCQkLmdldFlEb21haW4oJCQuZGF0YS50YXJnZXRzLCBcInkyXCIpKTtcclxuXHRcdFx0c3ViWTIgJiYgc3ViWTIuZG9tYWluKHkyLmRvbWFpbigpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyAtLSBCYXNpYyBFbGVtZW50cyAtLVxyXG5cdFx0JGVsLnN2ZyA9ICRlbC5jaGFydC5hcHBlbmQoXCJzdmdcIilcclxuXHRcdFx0LnN0eWxlKFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG5cclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiBzdGF0ZS5pbnB1dFR5cGUpIHtcclxuXHRcdFx0Y29uc3QgaXNUb3VjaCA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xyXG5cclxuXHRcdFx0JGVsLnN2Zy5vbihpc1RvdWNoID8gXCJ0b3VjaHN0YXJ0XCIgOiBcIm1vdXNlZW50ZXJcIiwgKCkgPT4gY2FsbEZuKGNvbmZpZy5vbm92ZXIsICQkLmFwaSkpXHJcblx0XHRcdFx0Lm9uKGlzVG91Y2ggPyBcInRvdWNoZW5kXCIgOiBcIm1vdXNlbGVhdmVcIiwgKCkgPT4gY2FsbEZuKGNvbmZpZy5vbm91dCwgJCQuYXBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnN2Z19jbGFzc25hbWUgJiYgJGVsLnN2Zy5hdHRyKFwiY2xhc3NcIiwgY29uZmlnLnN2Z19jbGFzc25hbWUpO1xyXG5cclxuXHRcdC8vIERlZmluZSBkZWZzXHJcblx0XHRjb25zdCBoYXNDb2xvclBhdHRlcm5zID0gKGlzRnVuY3Rpb24oY29uZmlnLmNvbG9yX3RpbGVzKSAmJiAkJC5wYXR0ZXJucyk7XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMgfHwgaGFzQ29sb3JQYXR0ZXJucykge1xyXG5cdFx0XHQkZWwuZGVmcyA9ICRlbC5zdmcuYXBwZW5kKFwiZGVmc1wiKTtcclxuXHJcblx0XHRcdGlmIChoYXNBeGlzKSB7XHJcblx0XHRcdFx0W1wiaWRcIiwgXCJpZFhBeGlzXCIsIFwiaWRZQXhpc1wiLCBcImlkWEF4aXNUaWNrVGV4dHNcIiwgXCJpZEdyaWRcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdCQkLmFwcGVuZENsaXAoJGVsLmRlZnMsIHN0YXRlLmNsaXBbdl0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZXQgY29sb3IgcGF0dGVybnNcclxuXHRcdFx0aWYgKGhhc0NvbG9yUGF0dGVybnMpIHtcclxuXHRcdFx0XHQkJC5wYXR0ZXJucy5mb3JFYWNoKHAgPT4gJGVsLmRlZnMuYXBwZW5kKCgpID0+IHAubm9kZSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xyXG5cclxuXHRcdC8vIEJpbmQgcmVzaXplIGV2ZW50XHJcblx0XHQkJC5iaW5kUmVzaXplKCk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIHJlZ2lvbnNcclxuXHRcdGNvbnN0IG1haW4gPSAkZWwuc3ZnLmFwcGVuZChcImdcIikuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcclxuXHJcblx0XHQkZWwubWFpbiA9IG1haW47XHJcblxyXG5cdFx0Ly8gaW5pdGlhbGl6ZSBzdWJjaGFydCB3aGVuIHN1YmNoYXJ0IHNob3cgb3B0aW9uIGlzIHNldFxyXG5cdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQuaW5pdFN1YmNoYXJ0KCk7XHJcblxyXG5cdFx0Y29uZmlnLnRvb2x0aXBfc2hvdyAmJiAkJC5pbml0VG9vbHRpcCgpO1xyXG5cdFx0Y29uZmlnLnRpdGxlX3RleHQgJiYgJCQuaW5pdFRpdGxlKCk7XHJcblx0XHRjb25maWcubGVnZW5kX3Nob3cgJiYgJCQuaW5pdExlZ2VuZCgpO1xyXG5cclxuXHRcdC8vIC0tIE1haW4gUmVnaW9uIC0tXHJcblxyXG5cdFx0Ly8gdGV4dCB3aGVuIGVtcHR5XHJcblx0XHRpZiAoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dCkge1xyXG5cdFx0XHRtYWluLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGAke0NMQVNTLnRleHR9ICR7Q0xBU1MuZW1wdHl9YClcclxuXHRcdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpIC8vIGhvcml6b250YWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeCBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMuXHJcblx0XHRcdFx0LmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKTsgLy8gdmVydGljYWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeSBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMsIGV4Y2VwdCBJRS5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHQvLyBSZWdpb25zXHJcblx0XHRcdGNvbmZpZy5yZWdpb25zLmxlbmd0aCAmJiAkJC5pbml0UmVnaW9uKCk7XHJcblxyXG5cdFx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICdmYWxzZSdcclxuXHRcdFx0IWNvbmZpZy5jbGlwUGF0aCAmJiAkJC5heGlzLmluaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnQgYXJlYVxyXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydClcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgc3RhdGUuY2xpcC5wYXRoKTtcclxuXHJcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRpbml0XCIpO1xyXG5cclxuXHRcdGlmIChoYXNBeGlzKSB7XHJcblx0XHRcdC8vIENvdmVyIHdob2xlIHdpdGggcmVjdHMgZm9yIGV2ZW50c1xyXG5cdFx0XHQkJC5pbml0RXZlbnRSZWN0ICYmICQkLmluaXRFdmVudFJlY3QoKTtcclxuXHJcblx0XHRcdC8vIEdyaWRzXHJcblx0XHRcdCQkLmluaXRHcmlkKCk7XHJcblxyXG5cdFx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICd0cnVlJ1xyXG5cdFx0XHRjb25maWcuY2xpcFBhdGggJiYgJCQuYXhpcyAmJiAkJC5heGlzLmluaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5pbml0Q2hhcnRFbGVtZW50cygpO1xyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gRHJhdyB3aXRoIHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZURpbWVuc2lvbigpO1xyXG5cclxuXHRcdC8vIG9uaW5pdCBjYWxsYmFja1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy5vbmluaXQsICQkLmFwaSk7XHJcblxyXG5cdFx0Ly8gU2V0IGJhY2tncm91bmRcclxuXHRcdCQkLnNldEJhY2tncm91bmQoKTtcclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2UsXHJcblx0XHRcdHdpdGhUcmFuc2Zvcm06IHRydWUsXHJcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JBeGlzOiBmYWxzZSxcclxuXHRcdFx0aW5pdGlhbGl6aW5nOiB0cnVlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBkYXRhLm9ubWluL21heCBjYWxsYmFja1xyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX29ubWluIHx8IGNvbmZpZy5kYXRhX29ubWF4KSB7XHJcblx0XHRcdGNvbnN0IG1pbk1heCA9ICQkLmdldE1pbk1heERhdGEoKTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcuZGF0YV9vbm1pbiwgJCQuYXBpLCBtaW5NYXgubWluKTtcclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29ubWF4LCAkJC5hcGksIG1pbk1heC5tYXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLnJlbmRlcmVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdGluaXRDaGFydEVsZW1lbnRzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXMsIGhhc1JhZGFyfSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgdHlwZXM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMpIHtcclxuXHRcdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiB0eXBlcy5wdXNoKFwiQmFyXCIpO1xyXG5cdFx0XHQkJC5oYXNUeXBlKFwiYnViYmxlXCIpICYmIHR5cGVzLnB1c2goXCJCdWJibGVcIik7XHJcblx0XHRcdCQkLmhhc1R5cGVPZihcIkxpbmVcIikgJiYgdHlwZXMucHVzaChcIkxpbmVcIik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIWhhc1JhZGFyKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChcIkFyY1wiLCBcIlBpZVwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goXCJHYXVnZVwiKTtcclxuXHRcdFx0fSBlbHNlIGlmIChoYXNSYWRhcikge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goXCJSYWRhclwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHR5cGVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdCQkW2Bpbml0JHt2fWBdKCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRub3RFbXB0eSgkJC5jb25maWcuZGF0YV9sYWJlbHMpICYmICQkLmluaXRUZXh0KCk7XHJcblx0fVxyXG5cclxuXHRzZXRDaGFydEVsZW1lbnRzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbDoge1xyXG5cdFx0XHRjaGFydCwgc3ZnLCBkZWZzLCBtYWluLCB0b29sdGlwLCBsZWdlbmQsIHRpdGxlLCBncmlkLFxyXG5cdFx0XHRhcmNzOiBhcmMsXHJcblx0XHRcdGNpcmNsZTogY2lyY2xlcyxcclxuXHRcdFx0YmFyOiBiYXJzLFxyXG5cdFx0XHRsaW5lOiBsaW5lcyxcclxuXHRcdFx0YXJlYTogYXJlYXMsXHJcblx0XHRcdHRleHQ6IHRleHRzXHJcblx0XHR9fSA9ICQkO1xyXG5cclxuXHRcdCQkLmFwaS4kID0ge1xyXG5cdFx0XHRjaGFydCxcclxuXHRcdFx0c3ZnLFxyXG5cdFx0XHRkZWZzLFxyXG5cdFx0XHRtYWluLFxyXG5cdFx0XHR0b29sdGlwLFxyXG5cdFx0XHRsZWdlbmQsXHJcblx0XHRcdHRpdGxlLFxyXG5cdFx0XHRncmlkLFxyXG5cdFx0XHRhcmMsXHJcblx0XHRcdGNpcmNsZXMsXHJcblx0XHRcdGJhcjoge2JhcnN9LFxyXG5cdFx0XHRsaW5lOiB7bGluZXMsIGFyZWFzfSxcclxuXHRcdFx0dGV4dDoge3RleHRzfVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBiYWNrZ3JvdW5kIGVsZW1lbnQvaW1hZ2VcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEJhY2tncm91bmQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnOiB7YmFja2dyb3VuZDogYmd9LCBzdGF0ZSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHJcblx0XHRpZiAobm90RW1wdHkoYmcpKSB7XHJcblx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzdmcuc2VsZWN0KFwiZ1wiKVxyXG5cdFx0XHRcdC5pbnNlcnQoYmcuaW1nVXJsID8gXCJpbWFnZVwiIDogXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xyXG5cclxuXHRcdFx0aWYgKGJnLmltZ1VybCkge1xyXG5cdFx0XHRcdGVsZW1lbnQuYXR0cihcImhyZWZcIiwgYmcuaW1nVXJsKTtcclxuXHRcdFx0fSBlbHNlIGlmIChiZy5jb2xvcikge1xyXG5cdFx0XHRcdGVsZW1lbnRcclxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgYmcuY29sb3IpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBzdGF0ZS5jbGlwLnBhdGgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlbGVtZW50XHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBiZy5jbGFzcyB8fCBudWxsKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRhcmdldGVkIGVsZW1lbnQgd2l0aCBnaXZlbiBkYXRhXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldHMgRGF0YSBvYmplY3QgZm9ybWF0dGVkIGFzICd0YXJnZXQnXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVUYXJnZXRzKHRhcmdldHMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtoYXNBeGlzLCBoYXNSYWRhcn0gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHQvLyBUZXh0XHJcblx0XHQkJC51cGRhdGVUYXJnZXRzRm9yVGV4dCh0YXJnZXRzKTtcclxuXHJcblx0XHQvLyBjaXJjbGVcclxuXHRcdGlmICgkJC5oYXNQb2ludFR5cGUoKSB8fCBoYXNSYWRhcikge1xyXG5cdFx0XHQkJC51cGRhdGVUYXJnZXRGb3JDaXJjbGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmICQkLnVwZGF0ZVRhcmdldHNGb3JCYXIodGFyZ2V0cyk7IC8vIEJhclxyXG5cdFx0XHQkJC5oYXNUeXBlT2YoXCJMaW5lXCIpICYmICQkLnVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpOyAvLyBMaW5lXHJcblxyXG5cdFx0XHQvLyBTdWIgQ2hhcnRcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0ICYmXHJcblx0XHRcdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gQXJjICYgUmFkYXJcclxuXHRcdFx0JCQuaGFzQXJjVHlwZSh0YXJnZXRzKSAmJiAoXHJcblx0XHRcdFx0aGFzUmFkYXIgP1xyXG5cdFx0XHRcdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclJhZGFyKHRhcmdldHMpIDpcclxuXHRcdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JBcmModGFyZ2V0cylcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGYWRlLWluIGVhY2ggY2hhcnRcclxuXHRcdCQkLnNob3dUYXJnZXRzKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBEaXNwbGF5IHRhcmdldGVkIGVsZW1lbnRzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzaG93VGFyZ2V0cygpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdEFsbChgLiR7Q0xBU1MudGFyZ2V0fWApXHJcblx0XHRcdC5maWx0ZXIoZCA9PiAkJC5pc1RhcmdldFRvU2hvdyhkLmlkKSlcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH1cclxuXHJcblx0Z2V0V2l0aE9wdGlvbihvcHRpb25zKSB7XHJcblx0XHRjb25zdCB3aXRoT3B0aW9ucyA9IHtcclxuXHRcdFx0WTogdHJ1ZSxcclxuXHRcdFx0U3ViY2hhcnQ6IHRydWUsXHJcblx0XHRcdFRyYW5zaXRpb246IHRydWUsXHJcblx0XHRcdEV2ZW50UmVjdDogdHJ1ZSxcclxuXHRcdFx0RGltZW5zaW9uOiB0cnVlLFxyXG5cdFx0XHRUcmltWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0VHJhbnNmb3JtOiBmYWxzZSxcclxuXHRcdFx0VXBkYXRlWERvbWFpbjogZmFsc2UsXHJcblx0XHRcdFVwZGF0ZU9yZ1hEb21haW46IGZhbHNlLFxyXG5cdFx0XHRMZWdlbmQ6IGZhbHNlLFxyXG5cdFx0XHRVcGRhdGVYQXhpczogXCJVcGRhdGVYRG9tYWluXCIsXHJcblx0XHRcdFRyYW5zaXRpb25Gb3JFeGl0OiBcIlRyYW5zaXRpb25cIixcclxuXHRcdFx0VHJhbnNpdGlvbkZvckF4aXM6IFwiVHJhbnNpdGlvblwiXHJcblx0XHR9O1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHdpdGhPcHRpb25zKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdGxldCBkZWZWYWwgPSB3aXRoT3B0aW9uc1trZXldO1xyXG5cclxuXHRcdFx0aWYgKGlzU3RyaW5nKGRlZlZhbCkpIHtcclxuXHRcdFx0XHRkZWZWYWwgPSB3aXRoT3B0aW9uc1tkZWZWYWxdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aXRoT3B0aW9uc1trZXldID0gZ2V0T3B0aW9uKG9wdGlvbnMsIGB3aXRoJHtrZXl9YCwgZGVmVmFsKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB3aXRoT3B0aW9ucztcclxuXHR9XHJcblxyXG5cdGluaXRpYWxPcGFjaXR5KGQpOiBcIjFcIiB8IFwiMFwiIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHt3aXRob3V0RmFkZUlufSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwgJiZcclxuXHRcdFx0d2l0aG91dEZhZGVJbltkLmlkXSA/IFwiMVwiIDogXCIwXCI7XHJcblx0fVxyXG5cclxuXHRiaW5kUmVzaXplKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCByZXNpemVGdW5jdGlvbiA9IGdlbmVyYXRlUmVzaXplKCk7XHJcblx0XHRjb25zdCBsaXN0OiBGdW5jdGlvbltdID0gW107XHJcblxyXG5cdFx0bGlzdC5wdXNoKCgpID0+IGNhbGxGbihjb25maWcub25yZXNpemUsICQkLCAkJC5hcGkpKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLnJlc2l6ZV9hdXRvKSB7XHJcblx0XHRcdGxpc3QucHVzaCgoKSA9PiB7XHJcblx0XHRcdFx0c3RhdGUucmVzaXppbmcgPSB0cnVlO1xyXG5cdFx0XHRcdCQkLmFwaS5mbHVzaChmYWxzZSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxpc3QucHVzaCgoKSA9PiB7XHJcblx0XHRcdGNhbGxGbihjb25maWcub25yZXNpemVkLCAkJCwgJCQuYXBpKTtcclxuXHRcdFx0c3RhdGUucmVzaXppbmcgPSBmYWxzZTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGFkZCByZXNpemUgZnVuY3Rpb25zXHJcblx0XHRsaXN0LmZvckVhY2godiA9PiByZXNpemVGdW5jdGlvbi5hZGQodikpO1xyXG5cclxuXHRcdCQkLnJlc2l6ZUZ1bmN0aW9uID0gcmVzaXplRnVuY3Rpb247XHJcblxyXG5cdFx0Ly8gYXR0YWNoIHJlc2l6ZSBldmVudFxyXG5cdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24gPSByZXNpemVGdW5jdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsIHBsdWdpbiBob29rXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBoYXNlIFRoZSBsaWZlY3ljbGUgcGhhc2VcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFyZ3VtZW50c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsbFBsdWdpbkhvb2socGhhc2UsIC4uLmFyZ3MpOiB2b2lkIHtcclxuXHRcdHRoaXMuY29uZmlnLnBsdWdpbnMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0aWYgKHBoYXNlID09PSBcIiRiZWZvcmVJbml0XCIpIHtcclxuXHRcdFx0XHR2LiQkID0gdGhpcztcclxuXHRcdFx0XHR0aGlzLmFwaS5wbHVnaW5zLnB1c2godik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZbcGhhc2VdKC4uLmFyZ3MpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG5leHRlbmQoQ2hhcnRJbnRlcm5hbC5wcm90b3R5cGUsIFtcclxuXHQvLyBjb21tb25cclxuXHRkYXRhQ29udmVydCxcclxuXHRkYXRhLFxyXG5cdGRhdGFMb2FkLFxyXG5cdGNhdGVnb3J5LFxyXG5cdGNsYXNzTW9kdWxlLFxyXG5cdGNvbG9yLFxyXG5cdGRvbWFpbixcclxuXHRpbnRlcmFjdGlvbixcclxuXHRmb3JtYXQsXHJcblx0bGVnZW5kLFxyXG5cdHJlZHJhdyxcclxuXHRzY2FsZSxcclxuXHRzaXplLFxyXG5cdHRleHQsXHJcblx0dGl0bGUsXHJcblx0dG9vbHRpcCxcclxuXHR0cmFuc2Zvcm0sXHJcblx0dHlwZSxcclxuXHQuLi5hcmNJbnRlcm5hbCxcclxuXHQuLi5heGlzSW50ZXJuYWxcclxuXSk7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc0RlZmluZWQsIGlzT2JqZWN0VHlwZX0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCBPcHRpb25zIGZyb20gXCIuL09wdGlvbnMvT3B0aW9uc1wiO1xyXG5cclxuLyoqXHJcbiAqIExvYWQgY29uZmlndXJhdGlvbiBvcHRpb25cclxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBVc2VyJ3MgZ2VuZXJhdGlvbiBjb25maWcgdmFsdWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkQ29uZmlnKGNvbmZpZzogT3B0aW9ucyk6IHZvaWQge1xyXG5cdGNvbnN0IHRoaXNDb25maWc6IE9wdGlvbnMgPSB0aGlzLmNvbmZpZztcclxuXHRsZXQgdGFyZ2V0O1xyXG5cdGxldCBrZXlzO1xyXG5cdGxldCByZWFkO1xyXG5cclxuXHRjb25zdCBmaW5kID0gKCkgPT4ge1xyXG5cdFx0Y29uc3Qga2V5ID0ga2V5cy5zaGlmdCgpO1xyXG5cclxuXHRcdGlmIChrZXkgJiYgdGFyZ2V0ICYmIGlzT2JqZWN0VHlwZSh0YXJnZXQpICYmIGtleSBpbiB0YXJnZXQpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0W2tleV07XHJcblx0XHRcdHJldHVybiBmaW5kKCk7XHJcblx0XHR9IGVsc2UgaWYgKCFrZXkpIHtcclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH07XHJcblxyXG5cdE9iamVjdC5rZXlzKHRoaXNDb25maWcpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdHRhcmdldCA9IGNvbmZpZztcclxuXHRcdGtleXMgPSBrZXkuc3BsaXQoXCJfXCIpO1xyXG5cdFx0cmVhZCA9IGZpbmQoKTtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKHJlYWQpKSB7XHJcblx0XHRcdHRoaXNDb25maWdba2V5XSA9IHJlYWQ7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7bm90RW1wdHksIGlzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogUmVzaXplIHRoZSBjaGFydC5cclxuXHQgKiBAZnVuY3Rpb24gcmVzaXplXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHNpemUgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVscy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFJlc2l6ZSB0byA2NDB4NDgwXHJcblx0ICogY2hhcnQucmVzaXplKHtcclxuXHQgKiAgICB3aWR0aDogNjQwLFxyXG5cdCAqICAgIGhlaWdodDogNDgwXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0cmVzaXplKHNpemU/OiB7d2lkdGg/OiBudW1iZXIsIGhlaWdodD86IG51bWJlcn0pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5yZW5kZXJlZCkge1xyXG5cdFx0XHRjb25maWcuc2l6ZV93aWR0aCA9IHNpemUgPyBzaXplLndpZHRoIDogbnVsbDtcclxuXHRcdFx0Y29uZmlnLnNpemVfaGVpZ2h0ID0gc2l6ZSA/IHNpemUuaGVpZ2h0IDogbnVsbDtcclxuXHJcblx0XHRcdHRoaXMuZmx1c2goZmFsc2UsIHRydWUpO1xyXG5cdFx0XHQkJC5yZXNpemVGdW5jdGlvbigpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvcmNlIHRvIHJlZHJhdy5cclxuXHQgKiBAZnVuY3Rpb24gZmx1c2hcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtzb2Z0XSBGb3Igc29mdCByZWRyYXcuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5mbHVzaCgpO1xyXG5cdCAqXHJcblx0ICogLy8gZm9yIHNvZnQgcmVkcmF3XHJcblx0ICogY2hhcnQuZmx1c2godHJ1ZSk7XHJcblx0ICovXHJcblx0Zmx1c2goc29mdD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRpZiAoc3RhdGUucmVuZGVyZWQpIHtcclxuXHRcdFx0Ly8gcmVzZXQgcG9zc2libGUgem9vbSBzY2FsZSB3aGVuIGlzIGNhbGxlZCBmcm9tIHJlc2l6ZSBldmVudFxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXHJcblx0XHRcdGlmIChzdGF0ZS5yZXNpemluZykgeyAvLyBhcmd1bWVudHNbMV0gaXMgZ2l2ZW4gd2hlbiBpcyBjYWxsZWQgZnJvbSByZXNpemVcclxuXHRcdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC51cGRhdGVSZXNpemUoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyByZS11cGRhdGUgY29uZmlnIGluZm9cclxuXHRcdFx0XHQkJC5heGlzICYmICQkLmF4aXMuc2V0T3JpZW50KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLnNjYWxlLnpvb20gPSBudWxsO1xyXG5cclxuXHRcdFx0c29mdCA/ICQkLnJlZHJhdyh7XHJcblx0XHRcdFx0d2l0aFRyYW5zZm9ybTogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0XHRcdH0pIDogJCQudXBkYXRlQW5kUmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcclxuXHRcdFx0XHR3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0JCQuaW5pdFRvUmVuZGVyKHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc2V0IHRoZSBjaGFydCBvYmplY3QgYW5kIHJlbW92ZSBlbGVtZW50IGFuZCBldmVudHMgY29tcGxldGVseS5cclxuXHQgKiBAZnVuY3Rpb24gZGVzdHJveVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEByZXR1cm5zIHtudWxsfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuZGVzdHJveSgpO1xyXG5cdCAqL1xyXG5cdGRlc3Ryb3koKTogbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7JGVsOiB7Y2hhcnQsIHN2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG5vdEVtcHR5KCQkKSkge1xyXG5cdFx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiR3aWxsRGVzdHJveVwiKTtcclxuXHRcdFx0JCQuY2hhcnRzLnNwbGljZSgkJC5jaGFydHMuaW5kZXhPZih0aGlzKSwgMSk7XHJcblxyXG5cdFx0XHQvLyBjbGVhciB0aW1lcnMgJiYgcGVuZGluZyB0cmFuc2l0aW9uXHJcblx0XHRcdHN2Zy5zZWxlY3QoXCIqXCIpLmludGVycnVwdCgpO1xyXG5cdFx0XHQkJC5yZXNpemVGdW5jdGlvbi5jbGVhcigpO1xyXG5cclxuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24pO1xyXG5cdFx0XHRjaGFydC5jbGFzc2VkKFwiYmJcIiwgZmFsc2UpLmh0bWwoXCJcIik7XHJcblxyXG5cdFx0XHQvLyByZWxlYXNpbmcgcmVmZXJlbmNlc1xyXG5cdFx0XHRPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0a2V5ID09PSBcImludGVybmFsXCIgJiYgT2JqZWN0LmtleXMoJCQpLmZvckVhY2goayA9PiB7XHJcblx0XHRcdFx0XHQkJFtrXSA9IG51bGw7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHRoaXNba2V5XSA9IG51bGw7XHJcblx0XHRcdFx0ZGVsZXRlIHRoaXNba2V5XTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IG9yIHNldCBzaW5nbGUgY29uZmlnIG9wdGlvbiB2YWx1ZS5cclxuXHQgKiBAZnVuY3Rpb24gY29uZmlnXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG9wdGlvbiBrZXkgbmFtZS5cclxuXHQgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIGFjY2VwdGVkIGZvciBpbmRpY2F0ZWQgb3B0aW9uLlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZHJhd10gU2V0IHRvIHJlZHJhdyB3aXRoIHRoZSBuZXcgb3B0aW9uIGNoYW5nZXMuXHJcblx0ICogLSAqKk5PVEU6KiogRG9lc24ndCBndWFyYW50ZWUgd29yayBpbiBhbGwgY2lyY3Vtc3RhbmNlcy4gSXQgY2FuIGJlIGFwcGxpZWQgZm9yIGxpbWl0ZWQgb3B0aW9ucyBvbmx5LlxyXG5cdCAqIEByZXR1cm5zIHsqfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0dGVyXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIpO1xyXG5cdCAqXHJcblx0ICogLy8gU2V0dGVyXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCk7XHJcblx0ICpcclxuXHQgKiAvLyBTZXR0ZXIgJiByZWRyYXcgd2l0aCB0aGUgbmV3IG9wdGlvblxyXG5cdCAqIGNoYXJ0LmNvbmZpZyhcImdhdWdlLm1heFwiLCAxMDAsIHRydWUpO1xyXG5cdCAqL1xyXG5cdGNvbmZpZyhuYW1lOiBzdHJpbmcsIHZhbHVlPzogYW55LCByZWRyYXc/OiBib29sZWFuKTogYW55IHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBrZXkgPSBuYW1lICYmIG5hbWUucmVwbGFjZSgvXFwuL2csIFwiX1wiKTtcclxuXHRcdGxldCByZXM7XHJcblxyXG5cdFx0aWYgKGtleSBpbiBjb25maWcpIHtcclxuXHRcdFx0aWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuXHRcdFx0XHRjb25maWdba2V5XSA9IHZhbHVlO1xyXG5cdFx0XHRcdHJlcyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZWRyYXcgJiYgdGhpcy5mbHVzaCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlcyA9IGNvbmZpZ1trZXldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgY29sb3JcclxuXHQgKiBAZnVuY3Rpb24gY29sb3JcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgaWQgdG8gZ2V0IHRoZSBjb2xvclxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5jb2xvcihcImRhdGExXCIpO1xyXG5cdCAqL1xyXG5cdGNvbG9yKGlkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuY29sb3IoaWQpOyAvLyBtb3JlIHBhdHRlcm5zXHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7RGF0YUl0ZW19IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2V4dGVuZCwgaXNVbmRlZmluZWQsIGlzQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxudHlwZSBkYXRhUGFyYW0gPSB7eDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyLCBpZDogc3RyaW5nLCBpbmRleDogbnVtYmVyfVtdO1xyXG5cclxuLyoqXHJcbiAqIEdldCBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcbiAqIEBmdW5jdGlvbiBkYXRhXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHRhcmdldElkcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIEFQSSByZXR1cm5zIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGRhdGEuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBhbGwgb2YgZGF0YSB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IERhdGEgb2JqZWN0c1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBHZXQgb25seSBkYXRhMSBkYXRhXHJcbiAqIGNoYXJ0LmRhdGEoXCJkYXRhMVwiKTtcclxuICogLy8gLS0+IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogQXJyYXkoNil9LCAuLi5dXHJcbiAqXHJcbiAqIC8vIEdldCBkYXRhMSBhbmQgZGF0YTIgZGF0YVxyXG4gKiBjaGFydC5kYXRhKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG4gKlxyXG4gKiAvLyBHZXQgYWxsIGRhdGFcclxuICogY2hhcnQuZGF0YSgpO1xyXG4gKi9cclxuZnVuY3Rpb24gZGF0YSh0YXJnZXRJZHM6IHN0cmluZ3xzdHJpbmdbXSk6IERhdGFJdGVtW10ge1xyXG5cdGNvbnN0IHt0YXJnZXRzfSA9IHRoaXMuaW50ZXJuYWwuZGF0YTtcclxuXHJcblx0aWYgKCFpc1VuZGVmaW5lZCh0YXJnZXRJZHMpKSB7XHJcblx0XHRjb25zdCBpZHM6IGFueSA9IGlzQXJyYXkodGFyZ2V0SWRzKSA/IHRhcmdldElkcyA6IFt0YXJnZXRJZHNdO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXRzLmZpbHRlcih0ID0+IGlkcy5zb21lKHYgPT4gdiA9PT0gdC5pZCkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRhcmdldHM7XHJcbn1cclxuXHJcbmV4dGVuZChkYXRhLCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgc2hvd24gaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBmdW5jdGlvbiBkYXRh4oCkc2hvd25cclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgQVBJIGZpbHRlcnMgdGhlIGRhdGEgd2l0aCBzcGVjaWZpZWQgdGFyZ2V0IGlkcy4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGFsbCBzaG93biBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBEYXRhIG9iamVjdHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIG9ubHkgZGF0YTEgZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oXCJkYXRhMVwiKTtcclxuXHQgKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cclxuXHQgKlxyXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIGRhdGExIGFuZCBkYXRhMiBkYXRhXHJcblx0ICogY2hhcnQuZGF0YS5zaG93bihbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIEdldCBhbGwgc2hvd24gZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oKTtcclxuXHQgKi9cclxuXHRzaG93bjogZnVuY3Rpb24odGFyZ2V0SWRzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IERhdGFJdGVtW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZmlsdGVyVGFyZ2V0c1RvU2hvdyh0aGlzLmRhdGEodGFyZ2V0SWRzKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHZhbHVlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBmdW5jdGlvbiBkYXRh4oCkdmFsdWVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHRhcmdldElkcyBUaGlzIEFQSSByZXR1cm5zIHRoZSB2YWx1ZXMgb2Ygc3BlY2lmaWVkIHRhcmdldC4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIG51bGwgd2lsbCBiZSByZXRydW5lZFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZsYXQ9dHJ1ZV0gR2V0IGZsYXR0ZW4gdmFsdWVzXHJcblx0ICogQHJldHVybnMge0FycmF5fSBEYXRhIHZhbHVlc1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IGRhdGExIHZhbHVlc1xyXG5cdCAqIGNoYXJ0LmRhdGEudmFsdWVzKFwiZGF0YTFcIik7XHJcblx0ICogLy8gLS0+IFsxMCwgMjAsIDMwLCA0MF1cclxuXHQgKi9cclxuXHR2YWx1ZXM6IGZ1bmN0aW9uKHRhcmdldElkcz86IHN0cmluZyB8IHN0cmluZ1tdLCBmbGF0OiBib29sZWFuID0gdHJ1ZSk6IG51bWJlcltdfG51bWJlcltdW10ge1xyXG5cdFx0bGV0IHZhbHVlcyA9IG51bGw7XHJcblxyXG5cdFx0aWYgKHRhcmdldElkcykge1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzID0gdGhpcy5kYXRhKHRhcmdldElkcyk7XHJcblxyXG5cdFx0XHRpZiAodGFyZ2V0cyAmJiBpc0FycmF5KHRhcmdldHMpKSB7XHJcblx0XHRcdFx0dmFsdWVzID0gW107XHJcblxyXG5cdFx0XHRcdHRhcmdldHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGRhdGFWYWx1ZSA9IHYudmFsdWVzLm1hcChkID0+IGQudmFsdWUpO1xyXG5cclxuXHRcdFx0XHRcdGZsYXQgPyAodmFsdWVzID0gdmFsdWVzLmNvbmNhdChkYXRhVmFsdWUpKSA6IHZhbHVlcy5wdXNoKGRhdGFWYWx1ZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IG5hbWVzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRuYW1lc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBuYW1lcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbmFtZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgbmFtZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXHJcblx0ICogQHJldHVybnMge29iamVjdH0gQ29ycmVzcG9uZGluZyBuYW1lcyBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZSwgaWYgc3BlY2lmaWVkIG5hbWVzIHZhbHVlcy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IG5hbWVzXHJcblx0ICogY2hhcnQuZGF0YS5uYW1lcygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwidGVzdDFcIiwgZGF0YTI6IFwidGVzdDJcIn1cclxuXHQgKlxyXG5cdCAqIC8vIFVwZGF0ZSBuYW1lc1xyXG5cdCAqIGNoYXJ0LmRhdGEubmFtZXMoe1xyXG5cdCAqICBkYXRhMTogXCJOZXcgTmFtZSAxXCIsXHJcblx0ICogIGRhdGEyOiBcIk5ldyBOYW1lIDJcIlxyXG5cdCAqfSk7XHJcblx0ICovXHJcblx0bmFtZXM6IGZ1bmN0aW9uKG5hbWVzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0+KToge1trZXk6IHN0cmluZ106IHN0cmluZ30ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdC8vIHJlc2V0IGV4aXN0aW5nIGxlZ2VuZCBpdGVtIGRpbWVuc2lvbiBjYWNoZSBkYXRhXHJcblx0XHQkJC5jYWNoZS5yZW1vdmUoS0VZLmxlZ2VuZEl0ZW1UZXh0Qm94KTtcclxuXHJcblx0XHRyZXR1cm4gJCQudXBkYXRlRGF0YUF0dHJpYnV0ZXMoXCJuYW1lc1wiLCBuYW1lcyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgY29sb3JzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRjb2xvcnNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gY29sb3JzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjb2xvcnMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgY29sb3JzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBbZGF0YS5jb2xvcnNdKC4vT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0Y29sb3JzKS5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBDb3JyZXNwb25kaW5nIGRhdGEgY29sb3IgdmFsdWUgYWNjb3JkaW5nIGl0cyBrZXkgdmFsdWUuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBjb2xvcnNcclxuXHQgKiBjaGFydC5kYXRhLmNvbG9ycygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwiIzAwYzczY1wiLCBkYXRhMjogXCIjZmE3MTcxXCJ9XHJcblx0ICpcclxuXHQgKiAvLyBVcGRhdGUgY29sb3JzXHJcblx0ICogY2hhcnQuZGF0YS5jb2xvcnMoe1xyXG5cdCAqICBkYXRhMTogXCIjRkZGRkZGXCIsXHJcblx0ICogIGRhdGEyOiBcIiMwMDAwMDBcIlxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGNvbG9yczogZnVuY3Rpb24oY29sb3JzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0+KTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcyhcImNvbG9yc1wiLCBjb2xvcnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4ZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuXHQgKiAtICoqTk9URToqKiBJZiBhbGwgZGF0YSBpcyByZWxhdGVkIHRvIG9uZSBvZiB0aGUgYXhlcywgdGhlIGRvbWFpbiBvZiBheGlzIHdpdGhvdXQgcmVsYXRlZCBkYXRhIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGRvbWFpbiBmcm9tIHRoZSBheGlzIHdpdGggcmVsYXRlZCBkYXRhXHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRheGVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGF4ZXMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGF4ZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgYXhlcyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXNcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBDb3JyZXNwb25kaW5nIGF4ZXMgdmFsdWUgZm9yIGRhdGEsIGlmIHNwZWNpZmllZCBheGVzIHZhbHVlLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEuYXhlcygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwieVwifVxyXG5cdCAqXHJcblx0ICogLy8gVXBkYXRlIGF4ZXNcclxuXHQgKiBjaGFydC5kYXRhLmF4ZXMoe1xyXG5cdCAqICBkYXRhMTogXCJ5XCIsXHJcblx0ICogIGRhdGEyOiBcInkyXCJcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRheGVzOiBmdW5jdGlvbihheGVzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4pOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiYXhlc1wiLCBheGVzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG1pbmltdW0gZGF0YSB2YWx1ZSBib3VuZCB0byB0aGUgY2hhcnRcclxuXHQgKiBAZnVuY3Rpb24gZGF0YeKApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5taW4oKTtcclxuXHQgKiAvLyAtLT4gW3t4OiAwLCB2YWx1ZTogMzAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAwfSwgLi4uXVxyXG5cdCAqL1xyXG5cdG1pbjogZnVuY3Rpb24oKTogZGF0YVBhcmFtIHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLmdldE1pbk1heERhdGEoKS5taW47XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBtYXhpbXVtIGRhdGEgdmFsdWUgYm91bmQgdG8gdGhlIGNoYXJ0XHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IERhdGEgb2JqZWN0c1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEubWF4KCk7XHJcblx0ICogLy8gLS0+IFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi5dXHJcblx0ICovXHJcblx0bWF4OiBmdW5jdGlvbigpOiBkYXRhUGFyYW0ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1heDtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2RhdGF9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXN9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7aXNGdW5jdGlvbiwgdG9BcnJheSwgZ2V0Q3NzUnVsZXN9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZSB0byBiYXNlNjRcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gYmUgZW5jb2RlZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9XaW5kb3dCYXNlNjQvQmFzZTY0X2VuY29kaW5nX2FuZF9kZWNvZGluZ1xyXG4gKi9cclxuY29uc3QgYjY0RW5jb2RlVW5pY29kZSA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiBidG9hKFxyXG5cdGVuY29kZVVSSUNvbXBvbmVudChzdHIpXHJcblx0XHQucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgKG1hdGNoLCBwOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoYDB4JHtwfWApKSlcclxuKTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHN2ZyBub2RlIHRvIGRhdGEgdXJsXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgdGFyZ2V0IG5vZGVcclxuICogQHBhcmFtIHtvYmplY3R9IHNpemUgb2JqZWN0IGNvbnRhaW5pbmcge3dpZHRoLCBoZWlnaHR9XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlVG9TdmdEYXRhVXJsKG5vZGUsIHNpemUpIHtcclxuXHRjb25zdCBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcclxuXHRjb25zdCBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xyXG5cdGNvbnN0IGNzc1RleHQgPSBnZXRDc3NSdWxlcyh0b0FycmF5KGRvY3VtZW50LnN0eWxlU2hlZXRzKSlcclxuXHRcdC5maWx0ZXIoKHI6IGFueSkgPT4gci5jc3NUZXh0KVxyXG5cdFx0Lm1hcCgocjogYW55KSA9PiByLmNzc1RleHQpO1xyXG5cclxuXHRjbG9uZS5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBkM05hbWVzcGFjZXMueGh0bWwpO1xyXG5cclxuXHRjb25zdCBub2RlWG1sID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhjbG9uZSk7XHJcblxyXG5cdC8vIGVzY2FwZSBjc3MgZm9yIFhNTFxyXG5cdGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cclxuXHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0LmpvaW4oXCJcXG5cIikpKTtcclxuXHJcblx0Y29uc3Qgc3R5bGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN0eWxlKTtcclxuXHJcblx0Ly8gZm9yZWlnbk9iamVjdCBub3Qgc3VwcG9ydGVkIGluIElFMTEgYW5kIGJlbG93XHJcblx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDgzNDY3NSh2PXZzLjg1KS5hc3B4XHJcblx0Y29uc3QgZGF0YVN0ciA9IGA8c3ZnIHhtbG5zPVwiJHtkM05hbWVzcGFjZXMuc3ZnfVwiIHdpZHRoPVwiJHtzaXplLndpZHRofVwiIGhlaWdodD1cIiR7c2l6ZS5oZWlnaHR9XCI+XHJcblx0XHRcdDxmb3JlaWduT2JqZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj5cclxuXHRcdFx0XHQke3N0eWxlWG1sfVxyXG5cdFx0XHRcdCR7bm9kZVhtbC5yZXBsYWNlKC8odXJsXFwoKVteI10rL2csIFwiJDFcIil9XHJcblx0XHRcdDwvZm9yZWlnbk9iamVjdD48L3N2Zz5gXHJcblx0XHQucmVwbGFjZShcIi9cXG4vZ1wiLCBcIiUwQVwiKTtcclxuXHJcblx0cmV0dXJuIGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCR7YjY0RW5jb2RlVW5pY29kZShkYXRhU3RyKX1gO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogRXhwb3J0IGNoYXJ0IGFzIGFuIGltYWdlLlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIElFMTEgYW5kIGJlbG93IG5vdCB3b3JrIHByb3Blcmx5IGR1ZSB0byB0aGUgbGFjayBvZiB0aGUgZmVhdHVyZSg8YSBocmVmPVwiaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDgzNDY3NSh2PXZzLjg1KS5hc3B4XCI+Zm9yZWlnbk9iamVjdDwvYT4pIHN1cHBvcnRcclxuXHQgKiAgIC0gVGhlIGJhc2ljIENTUyBmaWxlKGV4LiBiaWxsYm9hcmQuY3NzKSBzaG91bGQgYmUgYXQgc2FtZSBkb21haW4gYXMgQVBJIGNhbGwgY29udGV4dCB0byBnZXQgY29ycmVjdCBzdHlsZWQgZXhwb3J0IGltYWdlLlxyXG5cdCAqIEBmdW5jdGlvbiBleHBvcnRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21pbWVUeXBlPWltYWdlL3BuZ10gVGhlIGRlc2lyZWQgb3V0cHV0IGltYWdlIGZvcm1hdC4gKGV4LiAnaW1hZ2UvcG5nJyBmb3IgcG5nLCAnaW1hZ2UvanBlZycgZm9yIGpwZWcgZm9ybWF0KVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBleHBvcnQgaXMgcmVhZHkuXHJcblx0ICogQHJldHVybnMge3N0cmluZ30gZGF0YVVSSVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGNoYXJ0LmV4cG9ydCgpO1xyXG5cdCAqICAvLyAtLT4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITi4uLlwiXHJcblx0ICpcclxuXHQgKiAgLy8gSW5pdGlhbGl6ZSB0aGUgZG93bmxvYWQgYXV0b21hdGljYWxseVxyXG5cdCAqICBjaGFydC5leHBvcnQoXCJpbWFnZS9wbmdcIiwgZGF0YVVybCA9PiB7XHJcblx0ICogICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuXHQgKlxyXG5cdCAqICAgICBsaW5rLmRvd25sb2FkID0gYCR7RGF0ZS5ub3coKX0ucG5nYDtcclxuXHQgKiAgICAgbGluay5ocmVmID0gZGF0YVVybDtcclxuXHQgKiAgICAgbGluay5pbm5lckhUTUwgPSBcIkRvd25sb2FkIGNoYXJ0IGFzIGltYWdlXCI7XHJcblx0ICpcclxuXHQgKiAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcclxuXHQgKiAgfSk7XHJcblx0ICovXHJcblx0ZXhwb3J0KG1pbWVUeXBlPzogc3RyaW5nLCBjYWxsYmFjaz86IChkYXRhVXJsOiBzdHJpbmcpID0+IHZvaWQpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge3N0YXRlLCAkZWw6IHtjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzdGF0ZS5jdXJyZW50O1xyXG5cdFx0Y29uc3Qgc3ZnRGF0YVVybCA9IG5vZGVUb1N2Z0RhdGFVcmwoY2hhcnQubm9kZSgpLCB7d2lkdGgsIGhlaWdodH0pO1xyXG5cclxuXHRcdGlmIChjYWxsYmFjayAmJiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG5cdFx0XHRjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuXHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XHJcblx0XHRcdGltZy5vbmxvYWQgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuXHRcdFx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuXHRcdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcclxuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcclxuXHJcblx0XHRcdFx0Y2FsbGJhY2suYmluZCh0aGlzKShjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlKSk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpbWcuc3JjID0gc3ZnRGF0YVVybDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3ZnRGF0YVVybDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5cclxudHlwZSBmb2N1c1BhcmFtID0gc3RyaW5nIHwgc3RyaW5nW107XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVGhpcyBBUEkgaGlnaGxpZ2h0cyBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgZmFkZSBvdXQgdGhlIG90aGVycy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWQuXHJcblx0ICogQGZ1bmN0aW9uIGZvY3VzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZHMgdG8gYmUgaGlnaGxpZ2h0ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gZGF0YTEgd2lsbCBiZSBoaWdobGlnaHRlZCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIGZhZGVkIG91dFxyXG5cdCAqICBjaGFydC5mb2N1cyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSBmYWRlZCBvdXRcclxuXHQgKiBjaGFydC5mb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWRcclxuXHQgKiBjaGFydC5mb2N1cygpO1xyXG5cdCAqL1xyXG5cdGZvY3VzKHRhcmdldElkc1ZhbHVlPzogZm9jdXNQYXJhbSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICQkLiRlbC5zdmcuc2VsZWN0QWxsKFxyXG5cdFx0XHQkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzLmZpbHRlcigkJC5pc1RhcmdldFRvU2hvdywgJCQpKVxyXG5cdFx0KTtcclxuXHJcblx0XHR0aGlzLnJldmVydCgpO1xyXG5cdFx0dGhpcy5kZWZvY3VzKCk7XHJcblxyXG5cdFx0Y2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIHRydWUpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCBmYWxzZSk7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSAmJiAhc3RhdGUuaGFzUmFkYXIpIHtcclxuXHRcdFx0JCQuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0XHQkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiZcclxuXHRcdFx0XHQkJC5tYXJrT3ZlcmxhcHBlZCh0YXJnZXRJZHNWYWx1ZSwgJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgdHJ1ZSk7XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcclxuXHRcdHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcyA9IHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBBUEkgZmFkZXMgb3V0IHNwZWNpZmllZCB0YXJnZXRzIGFuZCByZXZlcnRzIHRoZSBvdGhlcnMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIGZhZGVkIG91dC5cclxuXHQgKiBAZnVuY3Rpb24gZGVmb2N1c1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSB0YXJnZXRJZHNWYWx1ZSBUYXJnZXQgaWRzIHRvIGJlIGZhZGVkIG91dC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQuZGVmb2N1cyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQuZGVmb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxyXG5cdCAqIGNoYXJ0LmRlZm9jdXMoKTtcclxuXHQgKi9cclxuXHRkZWZvY3VzKHRhcmdldElkc1ZhbHVlPzogZm9jdXNQYXJhbSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICQkLiRlbC5zdmcuc2VsZWN0QWxsKFxyXG5cdFx0XHQkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzLmZpbHRlcigkJC5pc1RhcmdldFRvU2hvdywgJCQpKVxyXG5cdFx0KTtcclxuXHJcblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdCQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0XHQkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiZcclxuXHRcdFx0XHQkJC51bmRvTWFya092ZXJsYXBwZWQoJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdHN0YXRlLmZvY3VzZWRUYXJnZXRJZHMgPSBzdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHRcdHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIEFQSSByZXZlcnRzIHNwZWNpZmllZCB0YXJnZXRzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBAZnVuY3Rpb24gcmV2ZXJ0XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZHMgdG8gYmUgcmV2ZXJ0ZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQucmV2ZXJ0KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5yZXZlcnQoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIGNoYXJ0LnJldmVydCgpO1xyXG5cdCAqL1xyXG5cdHJldmVydCh0YXJnZXRJZHNWYWx1ZT86IGZvY3VzUGFyYW0pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJGVsLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpOyAvLyBzaG91bGQgYmUgZm9yIGFsbCB0YXJnZXRzXHJcblxyXG5cdFx0Y2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIGZhbHNlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgZmFsc2UpO1xyXG5cdFx0JCQuaGFzQXJjVHlwZSgpICYmICQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHQkJC5zaG93TGVnZW5kKHRhcmdldElkcy5maWx0ZXIoJCQuaXNMZWdlbmRUb1Nob3cuYmluZCgkJCkpKTtcclxuXHRcdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IFtdO1xyXG5cdFx0c3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzID0gW107XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBEZWZpbmUgbGVnZW5kXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNvbnN0IGxlZ2VuZCA9IHtcclxuXHQvKipcclxuXHQgKiBTaG93IGxlZ2VuZCBmb3IgZWFjaCB0YXJnZXQuXHJcblx0ICogQGZ1bmN0aW9uIGxlZ2VuZOKApHNob3dcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXHJcblx0ICogLSBJZiB0YXJnZXRJZHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBzaG93bi5cclxuXHQgKiAtIElmIG9ubHkgb25lIHRhcmdldCBpcyB0aGUgY2FuZGlkYXRlLCBTdHJpbmcgY2FuIGJlIHBhc3NlZC5cclxuXHQgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBTaG93IGxlZ2VuZCBmb3IgZGF0YTEuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMSBhbmQgZGF0YTIuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBTaG93IGFsbCBsZWdlbmQuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coKTtcclxuXHQgKi9cclxuXHRzaG93OiBmdW5jdGlvbih0YXJnZXRJZHM/OiBzdHJpbmcgfCBzdHJpbmdbXSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdCQkLnNob3dMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XHJcblx0XHQkJC51cGRhdGVBbmRSZWRyYXcoe3dpdGhMZWdlbmQ6IHRydWV9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGxlZ2VuZCBmb3IgZWFjaCB0YXJnZXQuXHJcblx0ICogQGZ1bmN0aW9uIGxlZ2VuZOKApGhpZGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXHJcblx0ICogLSBJZiB0YXJnZXRJZHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uXHJcblx0ICogLSBJZiBvbmx5IG9uZSB0YXJnZXQgaXMgdGhlIGNhbmRpZGF0ZSwgU3RyaW5nIGNhbiBiZSBwYXNzZWQuXHJcblx0ICogLSBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEhpZGUgbGVnZW5kIGZvciBkYXRhMS5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZShcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gSGlkZSBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZShbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIEhpZGUgYWxsIGxlZ2VuZC5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZSgpO1xyXG5cdCAqL1xyXG5cdGhpZGU6IGZ1bmN0aW9uKHRhcmdldElkcz86IHN0cmluZyB8IHN0cmluZ1tdKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0JCQuaGlkZUxlZ2VuZCgkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpKTtcclxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdyh7d2l0aExlZ2VuZDogdHJ1ZX0pO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtsZWdlbmR9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNTdHJpbmcsIGlzQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIExvYWQgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXHJcblx0ICogLSA8Yj5Ob3RlOjwvYj5cclxuXHQgKiAgIC0gdW5sb2FkIHNob3VsZCBiZSB1c2VkIGlmIHNvbWUgZGF0YSBuZWVkcyB0byBiZSB1bmxvYWRlZCBzaW11bHRhbmVvdXNseS5cclxuXHQgKiAgICAgSWYgeW91IGNhbGwgdW5sb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSBsb2FkIGluc3RlYWQgb2YgdW5sb2FkIHBhcmFtLCBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxyXG5cdCAqICAgLSBkb25lIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGRhdGEgbG9hZGVkLCBidXQgaXQncyBub3QgYWZ0ZXIgcmVuZGVyaW5nLlxyXG5cdCAqICAgICBJdCdzIGJlY2F1c2UgcmVuZGVyaW5nIHdpbGwgZmluaXNoIGFmdGVyIHNvbWUgdHJhbnNpdGlvbiBhbmQgdGhlcmUgaXMgc29tZSB0aW1lIGxhZyBiZXR3ZWVuIGxvYWRpbmcgYW5kIHJlbmRlcmluZ1xyXG5cdCAqIEBmdW5jdGlvbiBsb2FkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IC0gdXJsPGJyPi0ganNvbjxicj4tIHJvd3M8YnI+LSBjb2x1bW5zIHwgVGhlIGRhdGEgd2lsbCBiZSBsb2FkZWQuIElmIGRhdGEgdGhhdCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGlkIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB1cGRhdGVkLiBPdGhlcndpc2UsIG5ldyB0YXJnZXQgd2lsbCBiZSBhZGRlZCB8XHJcblx0ICogICAgfCBkYXRhIHwgRGF0YSBvYmplY3RzIHRvIGJlIGxvYWRlZC4gQ2hlY2tvdXQgdGhlIGV4YW1wbGUuIHxcclxuXHQgKiAgICB8IG5hbWVzIHwgU2FtZSBhcyBkYXRhLm5hbWVzKCkgfFxyXG5cdCAqICAgIHwgeHMgfCBTYW1lIGFzIGRhdGEueHMgb3B0aW9uICB8XHJcblx0ICogICAgfCBjbGFzc2VzIHwgVGhlIGNsYXNzZXMgc3BlY2lmaWVkIGJ5IGRhdGEuY2xhc3NlcyB3aWxsIGJlIHVwZGF0ZWQuIGNsYXNzZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcclxuXHQgKiAgICB8IGNhdGVnb3JpZXMgfCBUaGUgY2F0ZWdvcmllcyBzcGVjaWZpZWQgYnkgYXhpcy54LmNhdGVnb3JpZXMgb3IgZGF0YS54IHdpbGwgYmUgdXBkYXRlZC4gY2F0ZWdvcmllcyBtdXN0IGJlIEFycmF5LiB8XHJcblx0ICogICAgfCBheGVzIHwgVGhlIGF4ZXMgc3BlY2lmaWVkIGJ5IGRhdGEuYXhlcyB3aWxsIGJlIHVwZGF0ZWQuIGF4ZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcclxuXHQgKiAgICB8IGNvbG9ycyB8IFRoZSBjb2xvcnMgc3BlY2lmaWVkIGJ5IGRhdGEuY29sb3JzIHdpbGwgYmUgdXBkYXRlZC4gY29sb3JzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XHJcblx0ICogICAgfCBoZWFkZXJzIHwgIFNldCByZXF1ZXN0IGhlYWRlciBpZiBsb2FkaW5nIHZpYSBgZGF0YS51cmxgLjxicj5Ac2VlIFtkYXRh4oCkaGVhZGVyc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0aGVhZGVycykgfFxyXG5cdCAqICAgIHwga2V5cyB8ICBDaG9vc2Ugd2hpY2ggSlNPTiBvYmplY3RzIGtleXMgY29ycmVzcG9uZCB0byBkZXNpcmVkIGRhdGEuPGJyPioqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS48YnI+QHNlZSBbZGF0YeKApGtleXNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGtleXMpIHxcclxuXHQgKiAgICB8IG1pbWVUeXBlIHwgIFNldCAnanNvbicgaWYgbG9hZGluZyBKU09OIHZpYSB1cmwuPGJyPkBzZWUgW2RhdGHigKRtaW1lVHlwZV0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0bWltZVR5cGUpIHxcclxuXHQgKiAgICB8IC0gdHlwZTxicj4tIHR5cGVzIHwgVGhlIHR5cGUgb2YgdGFyZ2V0cyB3aWxsIGJlIHVwZGF0ZWQuIHR5cGUgbXVzdCBiZSBTdHJpbmcgYW5kIHR5cGVzIG11c3QgYmUgT2JqZWN0LiB8XHJcblx0ICogICAgfCB1bmxvYWQgfCBTcGVjaWZ5IHRoZSBkYXRhIHdpbGwgYmUgdW5sb2FkZWQgYmVmb3JlIGxvYWRpbmcgbmV3IGRhdGEuIElmIHRydWUgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgdW5sb2FkZWQuIElmIHRhcmdldCBpZHMgZ2l2ZW4gYXMgU3RyaW5nIG9yIEFycmF5LCBzcGVjaWZpZWQgdGFyZ2V0cyB3aWxsIGJlIHVubG9hZGVkLiBJZiBhYnNlbnQgb3IgZmFsc2UgZ2l2ZW4sIHVubG9hZCB3aWxsIG5vdCBvY2N1ci4gfFxyXG5cdCAqICAgIHwgZG9uZSB8IFRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQufFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFGcm9tVVJMKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gTG9hZCBkYXRhMSBhbmQgdW5sb2FkIGRhdGEyIGFuZCBkYXRhM1xyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICBjb2x1bW5zOiBbXHJcblx0ICogICAgICAgIFtcImRhdGExXCIsIDEwMCwgMjAwLCAxNTAsIC4uLl0sXHJcblx0ICogICAgICAgIC4uLlxyXG5cdCAqICAgIF0sXHJcblx0ICogICAgdW5sb2FkOiBbXCJkYXRhMlwiLCBcImRhdGEzXCJdLFxyXG5cdCAqICAgIHVybDogXCIuLi5cIixcclxuXHQgKiAgICBkb25lOiBmdW5jdGlvbigpIHsgLi4uIH1cclxuXHQgKiB9KTtcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIG15QVBJLmpzb25cclxuXHQgKiAvLyB7XHJcblx0ICogLy8gICBcImRhdGExXCI6IFsyMjAsIDI0MCwgMjcwLCAyNTAsIDI4MF0sXHJcblx0ICogLy8gICBcImRhdGEyXCI6IFsxODAsIDE1MCwgMzAwLCA3MCwgMTIwXVxyXG5cdCAqIC8vIH1cclxuXHQgKlxyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICB1cmw6ICcuL2RhdGEvbXlBUEkuanNvbicsXHJcblx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIixcclxuXHQgKlxyXG5cdCAqICAgICAvLyBzZXQgcmVxdWVzdCBoZWFkZXIgaWYgaXMgbmVlZGVkXHJcblx0ICogICAgIGhlYWRlcnM6IHtcclxuXHQgKiAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvanNvblwiXHJcblx0ICogICAgIH1cclxuXHQgKiB9KTtcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICBkYXRhOiBbXHJcblx0ICogICAgICAgLy8gZXF1aXZhbGVudCBhczogY29sdW1uczogW1tcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1dXHJcblx0ICogICAgICAge1wiZGF0YTFcIjogMzB9LCB7XCJkYXRhMVwiOiAyMDB9LCB7XCJkYXRhMVwiOiAxMDB9XHJcblx0ICpcclxuXHQgKiAgICAgICAvLyBvclxyXG5cdCAqICAgICAgIC8vIGVxdWl2YWxlbnQgYXM6IGNvbHVtbnM6IFtbXCJkYXRhMVwiLCAxMCwgMjBdLCBbXCJkYXRhMlwiLCAxMywgMzBdXVxyXG5cdCAqICAgICAgIC8vIHtcImRhdGExXCI6IDEwLCBcImRhdGEyXCI6IDEzfSwge1wiZGF0YTFcIjogMjAsIFwiZGF0YTJcIjogMzB9fVxyXG5cdCAqICAgICBdXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bG9hZChhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB4cyBpZiBzcGVjaWZpZWRcclxuXHRcdGFyZ3MueHMgJiYgJCQuYWRkWHMoYXJncy54cyk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIG5hbWVzIGlmIGV4aXN0c1xyXG5cdFx0XCJuYW1lc1wiIGluIGFyZ3MgJiYgdGhpcy5kYXRhLm5hbWVzKGFyZ3MubmFtZXMpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjbGFzc2VzIGlmIGV4aXN0c1xyXG5cdFx0XCJjbGFzc2VzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmNsYXNzZXMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25maWcuZGF0YV9jbGFzc2VzW2lkXSA9IGFyZ3MuY2xhc3Nlc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2F0ZWdvcmllcyBpZiBleGlzdHNcclxuXHRcdGlmIChcImNhdGVnb3JpZXNcIiBpbiBhcmdzICYmICQkLmF4aXMuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGFyZ3MuY2F0ZWdvcmllcztcclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgYXhlcyBpZiBleGlzdHNcclxuXHRcdFwiYXhlc1wiIGluIGFyZ3MgJiYgT2JqZWN0LmtleXMoYXJncy5heGVzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfYXhlc1tpZF0gPSBhcmdzLmF4ZXNbaWRdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNvbG9ycyBpZiBleGlzdHNcclxuXHRcdFwiY29sb3JzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmNvbG9ycykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGNvbmZpZy5kYXRhX2NvbG9yc1tpZF0gPSBhcmdzLmNvbG9yc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyB1bmxvYWQgaWYgbmVlZGVkXHJcblx0XHRpZiAoXCJ1bmxvYWRcIiBpbiBhcmdzICYmIGFyZ3MudW5sb2FkICE9PSBmYWxzZSkge1xyXG5cdFx0XHQvLyBUT0RPOiBkbyBub3QgdW5sb2FkIGlmIHRhcmdldCB3aWxsIGxvYWQgKGluY2x1ZGVkIGluIHVybC9yb3dzL2NvbHVtbnMpXHJcblx0XHRcdCQkLnVubG9hZCgkJC5tYXBUb1RhcmdldElkcyhhcmdzLnVubG9hZCA9PT0gdHJ1ZSA/IG51bGwgOiBhcmdzLnVubG9hZCksICgpID0+XHJcblx0XHRcdFx0JCQubG9hZEZyb21BcmdzKGFyZ3MpXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC5sb2FkRnJvbUFyZ3MoYXJncyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5sb2FkIGRhdGEgdG8gdGhlIGNoYXJ0Ljxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSB0b2dnbGVzLlxyXG5cdCAqIC0gPGI+Tm90ZTo8L2I+XHJcblx0ICogSWYgeW91IGNhbGwgbG9hZCBBUEkgc29vbiBhZnRlci9iZWZvcmUgdW5sb2FkLCB1bmxvYWQgcGFyYW0gb2YgbG9hZCBzaG91bGQgYmUgdXNlZC4gT3RoZXJ3aXNlIGNoYXJ0IHdpbGwgbm90IGJlIHJlbmRlcmVkIHByb3Blcmx5IGJlY2F1c2Ugb2YgY2FuY2VsIG9mIGFuaW1hdGlvbi48YnI+XHJcblx0ICogYGRvbmVgIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGRhdGEgbG9hZGVkLCBidXQgaXQncyBub3QgYWZ0ZXIgcmVuZGVyaW5nLiBJdCdzIGJlY2F1c2UgcmVuZGVyaW5nIHdpbGwgZmluaXNoIGFmdGVyIHNvbWUgdHJhbnNpdGlvbiBhbmQgdGhlcmUgaXMgc29tZSB0aW1lIGxhZyBiZXR3ZWVuIGxvYWRpbmcgYW5kIHJlbmRlcmluZy5cclxuXHQgKiBAZnVuY3Rpb24gdW5sb2FkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3NWYWx1ZVxyXG5cdCAqICB8IGtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgfCBpZHMgfCBTdHJpbmcgJnZlcnQ7IEFycmF5IHwgVGFyZ2V0IGlkIGRhdGEgdG8gYmUgdW5sb2FkZWQuIElmIG5vdCBnaXZlbiwgYWxsIGRhdGEgd2lsbCBiZSB1bmxvYWRlZC4gfFxyXG5cdCAqICB8IGRvbmUgfCBGdWN0aW9uIHwgQ2FsbGJhY2sgYWZ0ZXIgZGF0YSBpcyB1bmxvYWRlZC4gfFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFVubG9hZCBkYXRhMiBhbmQgZGF0YTNcclxuXHQgKiAgY2hhcnQudW5sb2FkKHtcclxuXHQgKiAgICBpZHM6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXHJcblx0ICogICAgZG9uZTogZnVuY3Rpb24oKSB7XHJcblx0ICogICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSB1bmxvYWRlZFxyXG5cdCAqICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICovXHJcblx0dW5sb2FkKGFyZ3NWYWx1ZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0bGV0IGFyZ3MgPSBhcmdzVmFsdWUgfHwge307XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkoYXJncykpIHtcclxuXHRcdFx0YXJncyA9IHtpZHM6IGFyZ3N9O1xyXG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhhcmdzKSkge1xyXG5cdFx0XHRhcmdzID0ge2lkczogW2FyZ3NdfTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpZHMgPSAkJC5tYXBUb1RhcmdldElkcyhhcmdzLmlkcyk7XHJcblxyXG5cdFx0JCQudW5sb2FkKGlkcywgKCkgPT4ge1xyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQkJC5jYWNoZS5yZW1vdmUoaWRzKTtcclxuXHRcdFx0YXJncy5kb25lICYmIGFyZ3MuZG9uZS5jYWxsKHRoaXMpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZW5kYWxsfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBTaG93L0hpZGUgZGF0YSBzZXJpZXNcclxuICogQHBhcmFtIHtib29sZWFufSBzaG93IFNob3cgb3IgaGlkZVxyXG4gKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHNWYWx1ZSBUYXJnZXQgaWQgdmFsdWVzXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbnNcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNob3dIaWRlKHNob3c6IGJvb2xlYW4sIHRhcmdldElkc1ZhbHVlOiBzdHJpbmdbXSwgb3B0aW9uczogYW55KTogdm9pZCB7XHJcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkc1ZhbHVlKTtcclxuXHJcblx0JCRbYCR7c2hvdyA/IFwicmVtb3ZlXCIgOiBcImFkZFwifUhpZGRlblRhcmdldElkc2BdKHRhcmdldElkcyk7XHJcblxyXG5cdGNvbnN0IHRhcmdldHMgPSAkJC4kZWwuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzKSk7XHJcblx0Y29uc3Qgb3BhY2l0eSA9IHNob3cgPyBcIjFcIiA6IFwiMFwiO1xyXG5cclxuXHR0YXJnZXRzLnRyYW5zaXRpb24oKVxyXG5cdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5LCBcImltcG9ydGFudFwiKVxyXG5cdFx0LmNhbGwoZW5kYWxsLCAoKSA9PiB7XHJcblx0XHRcdHRhcmdldHMuc3R5bGUoXCJvcGFjaXR5XCIsIG51bGwpLnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5KTtcclxuXHRcdH0pO1xyXG5cclxuXHRvcHRpb25zLndpdGhMZWdlbmQgJiYgJCRbYCR7c2hvdyA/IFwic2hvd1wiIDogXCJoaWRlXCJ9TGVnZW5kYF0odGFyZ2V0SWRzKTtcclxuXHJcblx0JCQucmVkcmF3KHtcclxuXHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0fSk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTaG93IGRhdGEgc2VyaWVzIG9uIGNoYXJ0XHJcblx0ICogQGZ1bmN0aW9uIHNob3dcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gW3RhcmdldElkc1ZhbHVlXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgd2l0aExlZ2VuZCB8IGJvb2xlYW4gfCBmYWxzZSB8IHdoZXRoZXIgb3Igbm90IGRpc3BsYXkgbGVnZW5kIHxcclxuXHQgKlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gc2hvdyAnZGF0YTEnXHJcblx0ICogY2hhcnQuc2hvdyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gc2hvdyAnZGF0YTEnIGFuZCAnZGF0YTMnXHJcblx0ICogY2hhcnQuc2hvdyhbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcclxuXHQgKi9cclxuXHRzaG93KHRhcmdldElkc1ZhbHVlPzogc3RyaW5nW10gfCBzdHJpbmcsIG9wdGlvbnMgPSB7fSk6IHZvaWQge1xyXG5cdFx0c2hvd0hpZGUuY2FsbCh0aGlzLCB0cnVlLCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSBkYXRhIHNlcmllcyBmcm9tIGNoYXJ0XHJcblx0ICogQGZ1bmN0aW9uIGhpZGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gW3RhcmdldElkc1ZhbHVlXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgd2l0aExlZ2VuZCB8IGJvb2xlYW4gfCBmYWxzZSB8IHdoZXRoZXIgb3Igbm90IGRpc3BsYXkgbGVnZW5kIHxcclxuXHQgKlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gaGlkZSAnZGF0YTEnXHJcblx0ICogY2hhcnQuaGlkZShcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gaGlkZSAnZGF0YTEnIGFuZCAnZGF0YTMnXHJcblx0ICogY2hhcnQuaGlkZShbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcclxuXHQgKi9cclxuXHRoaWRlKHRhcmdldElkc1ZhbHVlPzogc3RyaW5nW10sIG9wdGlvbnMgPSB7fSk6IHZvaWQge1xyXG5cdFx0c2hvd0hpZGUuY2FsbCh0aGlzLCBmYWxzZSwgdGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZSBkYXRhIHNlcmllcyBvbiBjaGFydC4gV2hlbiB0YXJnZXQgZGF0YSBpcyBoaWRkZW4sIGl0IHdpbGwgc2hvdy4gSWYgaXMgc2hvd24sIGl0IHdpbGwgaGlkZSBpbiB2aWNlIHZlcnNhLlxyXG5cdCAqIEBmdW5jdGlvbiB0b2dnbGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gW3RhcmdldElkc10gVGhlIHRhcmdldCBpZCB2YWx1ZS5cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBkZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBib29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XHJcblx0ICpcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHRvZ2dsZSAnZGF0YTEnXHJcblx0ICogY2hhcnQudG9nZ2xlKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyB0b2dnbGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xyXG5cdCAqIGNoYXJ0LnRvZ2dsZShbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcclxuXHQgKi9cclxuXHR0b2dnbGUodGFyZ2V0SWRzOiBzdHJpbmd8c3RyaW5nW10sIG9wdGlvbnMgPSB7fSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IHtzaG93OiA8c3RyaW5nW10+IFtdLCBoaWRlOiA8c3RyaW5nW10+IFtdfTtcclxuXHJcblx0XHQvLyBzb3J0IHNob3cgJiBoaWRlIHRhcmdldCBpZHNcclxuXHRcdCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcylcclxuXHRcdFx0LmZvckVhY2goKGlkOiBzdHJpbmcpID0+IHRhcmdldHNbJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gXCJoaWRlXCIgOiBcInNob3dcIl0ucHVzaChpZCkpO1xyXG5cclxuXHRcdC8vIHBlcmZvcm0gc2hvdyAmIGhpZGUgdGFzayBzZXBhcmF0ZWx5XHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy80NTRcclxuXHRcdHRhcmdldHMuc2hvdy5sZW5ndGggJiYgdGhpcy5zaG93KHRhcmdldHMuc2hvdywgb3B0aW9ucyk7XHJcblx0XHR0YXJnZXRzLmhpZGUubGVuZ3RoICYmIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oaWRlKHRhcmdldHMuaGlkZSwgb3B0aW9ucyksIDApO1xyXG5cdH1cclxufTtcclxuXHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1ZhbHVlLCBpc0RlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIERlZmluZSB0b29sdGlwXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNvbnN0IHRvb2x0aXAgPSB7XHJcblx0LyoqXHJcblx0ICogU2hvdyB0b29sdGlwXHJcblx0ICogQGZ1bmN0aW9uIHRvb2x0aXDigKRzaG93XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCBpbmRleCB8IE51bWJlciB8IERldGVybWluZSBmb2N1cyBieSBpbmRleCB8XHJcblx0ICogICAgfCB4IHwgTnVtYmVyICZ2ZXJ0OyBEYXRlIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IHggQXhpcyBpbmRleCB8XHJcblx0ICogICAgfCBtb3VzZSB8IEFycmF5IHwgRGV0ZXJtaW5lIHggYW5kIHkgY29vcmRpbmF0ZSB2YWx1ZSByZWxhdGl2ZSB0aGUgdGFyZ2V0ZWQgJy5iYi1ldmVudC1yZWN0JyB4IEF4aXMuPGJyPkl0IHNob3VsZCBiZSB1c2VkIGFsb25nIHdpdGggYGRhdGFgLCBgaW5kZXhgIG9yIGB4YCB2YWx1ZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgc2V0IGFzIGBbMCwwXWAgfFxyXG5cdCAqICAgIHwgZGF0YSB8IE9iamVjdCB8IFdoZW4gW2RhdGEueHNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNHhzKSBvcHRpb24gaXMgdXNlZCBvciBbdG9vbHRpcC5ncm91cGVkXShPcHRpb25zLmh0bWwjLnRvb2x0aXApIHNldCB0byAnZmFsc2UnLCBgc2hvdWxkIGJlIHVzZWQgZ2l2aW5nIHRoaXMgcGFyYW1gLjxicj48YnI+KipLZXk6Kio8YnI+LSB4IHtudW1iZXIgJnZlcmJhcjsgRGF0ZX06IHggQXhpcyB2YWx1ZTxicj4tIGluZGV4IHtudW1iZXJ9OiB4IEF4aXMgaW5kZXggKHVzZWxlc3MgZm9yIGRhdGEueHMpPGJyPi0gaWQge3N0cmluZ306IGRhdGEgaWQ8YnI+LSB2YWx1ZSB7bnVtYmVyfTogVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgZm9yIHRvb2x0aXAuIHxcclxuXHQgKlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIHNob3cgdGhlIDJuZCB4IEF4aXMgY29vcmRpbmF0ZSB0b29sdGlwXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgaW5kZXg6IDFcclxuXHQgKiAgfSk7XHJcblx0ICpcclxuXHQgKiAgLy8gc2hvdyB0b29sdGlwIGZvciB0aGUgM3JkIHggQXhpcyBpbiB4OjUwIGFuZCB5OjEwMCBjb29yZGluYXRlIG9mICcuYmItZXZlbnQtcmVjdCcgb2YgdGhlIHggQXhpcy5cclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICB4OiAyLFxyXG5cdCAqICAgIG1vdXNlOiBbNTAsIDEwMF1cclxuXHQgKiAgfSk7XHJcblx0ICpcclxuXHQgKiAgLy8gc2hvdyB0b29sdGlwIGZvciB0aW1lc2VyaWVzIHggYXhpc1xyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIHg6IG5ldyBEYXRlKFwiMjAxOC0wMS0wMiAwMDowMFwiKVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyB3aGVuIGRhdGEueHMgaXMgdXNlZFxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIGRhdGE6IHtcclxuXHQgKiAgICAgICAgeDogMywgIC8vIHggQXhpcyB2YWx1ZVxyXG5cdCAqICAgICAgICBpZDogXCJkYXRhMVwiLCAgLy8gZGF0YSBpZFxyXG5cdCAqICAgICAgICB2YWx1ZTogNTAwICAvLyBkYXRhIHZhbHVlXHJcblx0ICogICAgfVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyB3aGVuIGRhdGEueHMgaXNuJ3QgdXNlZCwgYnV0IHRvb2x0aXAuZ3JvdXBlZD1mYWxzZSBpcyBzZXRcclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICBkYXRhOiB7XHJcblx0ICogICAgICAgIGluZGV4OiAzLCAgLy8gb3IgJ3gnIGtleSB2YWx1ZVxyXG5cdCAqICAgICAgICBpZDogXCJkYXRhMVwiLCAgLy8gZGF0YSBpZFxyXG5cdCAqICAgICAgICB2YWx1ZTogNTAwICAvLyBkYXRhIHZhbHVlXHJcblx0ICogICAgfVxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHRzaG93OiBmdW5jdGlvbihhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2lucHV0VHlwZX19ID0gJCQ7XHJcblx0XHRsZXQgaW5kZXg7XHJcblx0XHRsZXQgbW91c2U7XHJcblxyXG5cdFx0Ly8gZGV0ZXJtaW5lIG1vdXNlIHBvc2l0aW9uIG9uIHRoZSBjaGFydFxyXG5cdFx0aWYgKGFyZ3MubW91c2UpIHtcclxuXHRcdFx0bW91c2UgPSBhcmdzLm1vdXNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGRldGVybWluZSBmb2N1cyBkYXRhXHJcblx0XHRpZiAoYXJncy5kYXRhKSB7XHJcblx0XHRcdGNvbnN0IHtkYXRhfSA9IGFyZ3M7XHJcblx0XHRcdGNvbnN0IHkgPSAkJC5nZXRZU2NhbGVCeUlkKGRhdGEuaWQpKGRhdGEudmFsdWUpO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcclxuXHRcdFx0XHQvLyBpZiBtdWx0aXBsZSB4cywgdGFyZ2V0IHBvaW50IHdpbGwgYmUgZGV0ZXJtaW5lZCBieSBtb3VzZVxyXG5cdFx0XHRcdG1vdXNlID0gWyQkLnNjYWxlLngoZGF0YS54KSwgeV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKCFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0XHRtb3VzZSA9IFswLCB5XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGluZGV4ID0gaXNWYWx1ZShkYXRhLmluZGV4KSA/IGRhdGEuaW5kZXggOiAkJC5nZXRJbmRleEJ5WChkYXRhLngpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLngpKSB7XHJcblx0XHRcdGluZGV4ID0gJCQuZ2V0SW5kZXhCeVgoYXJncy54KTtcclxuXHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKGFyZ3MuaW5kZXgpKSB7XHJcblx0XHRcdGluZGV4ID0gYXJncy5pbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBlbXVsYXRlIGV2ZW50cyB0byBzaG93XHJcblx0XHQoaW5wdXRUeXBlID09PSBcIm1vdXNlXCIgP1xyXG5cdFx0XHRbXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW1vdmVcIl0gOiBbXCJ0b3VjaHN0YXJ0XCJdXHJcblx0XHQpLmZvckVhY2goZXZlbnROYW1lID0+IHtcclxuXHRcdFx0JCQuZGlzcGF0Y2hFdmVudChldmVudE5hbWUsIGluZGV4LCBtb3VzZSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIHRvb2x0aXBcclxuXHQgKiBAZnVuY3Rpb24gdG9vbHRpcOKApGhpZGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKi9cclxuXHRoaWRlOiBmdW5jdGlvbigpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHQvLyByZXNldCBsYXN0IHRvdWNoIHBvaW50IGluZGV4XHJcblx0XHQkJC5pbnB1dFR5cGUgPT09IFwidG91Y2hcIiAmJiAkJC5jYWxsT3Zlck91dEZvclRvdWNoKCk7XHJcblxyXG5cdFx0JCQuaGlkZVRvb2x0aXAodHJ1ZSk7XHJcblx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHQkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHRcdCQkLnVuZXhwYW5kQmFycygpO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHt0b29sdGlwfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vQ2hhcnRJbnRlcm5hbC9DaGFydEludGVybmFsXCI7XHJcbmltcG9ydCB7bG9hZENvbmZpZ30gZnJvbSBcIi4uL2NvbmZpZy9jb25maWdcIjtcclxuaW1wb3J0IHtleHRlbmQsIGlzRnVuY3Rpb259IGZyb20gXCIuLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuaW1wb3J0IGFwaUNoYXJ0IGZyb20gXCIuL2FwaS9jaGFydFwiO1xyXG5pbXBvcnQgYXBpQ29sb3IgZnJvbSBcIi4vYXBpL2NvbG9yXCI7XHJcbmltcG9ydCBhcGlEYXRhIGZyb20gXCIuL2FwaS9kYXRhXCI7XHJcbmltcG9ydCBhcGlFeHBvcnQgZnJvbSBcIi4vYXBpL2V4cG9ydFwiO1xyXG5pbXBvcnQgYXBpRm9jdXMgZnJvbSBcIi4vYXBpL2ZvY3VzXCI7XHJcbmltcG9ydCBhcGlMZWdlbmQgZnJvbSBcIi4vYXBpL2xlZ2VuZFwiO1xyXG5pbXBvcnQgYXBpTG9hZCBmcm9tIFwiLi9hcGkvbG9hZFwiO1xyXG5pbXBvcnQgYXBpU2hvdyBmcm9tIFwiLi9hcGkvc2hvd1wiO1xyXG5pbXBvcnQgYXBpVG9vbHRpcCBmcm9tIFwiLi9hcGkvdG9vbHRpcFwiO1xyXG5cclxuaW1wb3J0IHthcGkgYXMgYXBpQXhpc30gZnJvbSBcIi4uL2NvbmZpZy9yZXNvbHZlci9heGlzXCI7XHJcblxyXG4vKipcclxuICogTWFpbiBjaGFydCBjbGFzcy5cclxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgdmlhIGBiYi5nZW5lcmF0ZSgpYC5cclxuICogQGNsYXNzIENoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuICogIGRhdGE6IHtcclxuICogICAgY29sdW1uczogW1xyXG4gKlx0ICAgIFtcInhcIiwgXCIyMDE1LTExLTAyXCIsIFwiMjAxNS0xMi0wMVwiLCBcIjIwMTYtMDEtMDFcIiwgXCIyMDE2LTAyLTAxXCIsIFwiMjAxNi0wMy0wMVwiXSxcclxuICogXHQgICAgW1wiY291bnQxXCIsIDExLCA4LCA3LCA2LCA1IF0sXHJcbiAqXHQgICAgW1wiY291bnQyXCIsIDksIDMsIDYsIDIsIDggXVxyXG4gKiAgIF19XHJcbiAqIH1cclxuICogQHNlZSB7QGxpbmsgYmIuZ2VuZXJhdGV9IGZvciB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAqL1xyXG4vKipcclxuICogQWNjZXNzIGluc3RhbmNlJ3MgcHJpbWFyeSBub2RlIGVsZW1lbnRzXHJcbiAqIEBtZW1iZXIge29iamVjdH0gJFxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gJCBBY2Nlc3MgaW5zdGFuY2UncyBwcmltYXJ5IG5vZGUgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuY2hhcnQgV3JhcHBlciBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnN2ZyBNYWluIHN2ZyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmRlZnMgRGVmaW5pdGlvbiBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLm1haW4gTWFpbiBncm91cGluZyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRvb2x0aXAgVG9vbHRpcCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxlZ2VuZCBMZWdlbmQgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50aXRsZSBUaXRsZSBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmdyaWQgR3JpZCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmFyYyBBcmMgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5jaXJjbGVzIERhdGEgcG9pbnQgY2lyY2xlIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAkLmJhciBCYXIgZWxlbWVudCBvYmplY3RcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuYmFyLmJhcnMgQmFyIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAkLmxpbmUgTGluZSBlbGVtZW50IG9iamVjdFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmxpbmVzIExpbmUgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGluZS5hcmVhcyBBcmVhcyBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge29iamVjdH0gJC50ZXh0IFRleHQgZWxlbWVudCBvYmplY3RcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudGV4dC50ZXh0cyBEYXRhIGxhYmVsIHRleHQgZWxlbWVudHNcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xyXG4gKlxyXG4gKiBjaGFydC4kLmNoYXJ0OyAvLyB3cmFwcGVyIGVsZW1lbnRcclxuICogY2hhcnQuJC5saW5lLmNpcmNsZXM7ICAvLyBhbGwgZGF0YSBwb2ludCBjaXJjbGUgZWxlbWVudHNcclxuICovXHJcbi8qKlxyXG4gKiBQbHVnaW4gaW5zdGFuY2UgYXJyYXlcclxuICogQG1lbWJlciB7QXJyYXl9IHBsdWdpbnNcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XHJcbiAqICAgICAuLi5cclxuICogICAgIHBsdWdpbnM6IFtcclxuICogICAgICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXHJcbiAqICAgICAgICBuZXcgUGx1Z2luQSgpXHJcbiAqICAgICBdXHJcbiAqICB9KTtcclxuICpcclxuICogIGNoYXJ0LnBsdWdpbnM7IC8vIFtTdGFuZm9yZCwgUGx1Z2luQV0gLSBpbnN0YW5jZSBhcnJheVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnQge1xyXG5cdHB1YmxpYyBwbHVnaW5zID0gW107XHJcblx0cHVibGljIGludGVybmFsOiBDaGFydEludGVybmFsO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcblx0XHRjb25zdCBjdHggPSB0aGlzO1xyXG5cdFx0Ly8gY29uc3Qge3R5cGUsIHR5cGVzfSA9IG9wdGlvbnMuZGF0YTtcclxuXHRcdC8vIGxldCBpc0FyYyA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmICh0eXBlKSB7XHJcblx0XHQvLyBcdGlzQXJjID0gVFlQRVMuQXJjLmluZGV4T2YodHlwZSkgPiAtMTtcclxuXHRcdC8vIH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdC8vIFx0Zm9yIChjb25zdCB4IGluIHR5cGVzKSB7XHJcblx0XHQvLyBcdFx0aWYgKFRZUEVTLkFyYy5pbmRleE9mKHR5cGVzW3hdKSA+IC0xKSB7XHJcblx0XHQvLyBcdFx0XHRpc0FyYyA9IHRydWU7XHJcblx0XHQvLyBcdFx0XHRicmVhaztcclxuXHRcdC8vIFx0XHR9XHJcblx0XHQvLyBcdH1cclxuXHRcdC8vIH1cclxuXHJcblx0XHRjb25zdCAkJCA9IG5ldyBDaGFydEludGVybmFsKGN0eCk7XHJcblxyXG5cdFx0dGhpcy5pbnRlcm5hbCA9ICQkO1xyXG5cclxuXHRcdC8vIGJpbmQgdG8gbmFtZXNwYWNlZCBBUElzXHJcblx0XHQoZnVuY3Rpb24gYmluZFRoaXMoZm4sIHRhcmdldCwgYXJnVGhpcykge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhmbikuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGlzRnVuYyA9IGlzRnVuY3Rpb24oZm5ba2V5XSk7XHJcblx0XHRcdFx0Y29uc3QgaXNDaGlsZCA9IHRhcmdldCAhPT0gYXJnVGhpcztcclxuXHRcdFx0XHRjb25zdCBoYXNDaGlsZCA9IE9iamVjdC5rZXlzKGZuW2tleV0pLmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgKCghaXNDaGlsZCAmJiBoYXNDaGlsZCkgfHwgaXNDaGlsZCkpIHtcclxuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gZm5ba2V5XS5iaW5kKGFyZ1RoaXMpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIWlzRnVuYykge1xyXG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSB7fTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGhhc0NoaWxkICYmIGJpbmRUaGlzKGZuW2tleV0sIHRhcmdldFtrZXldLCBhcmdUaGlzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KShDaGFydC5wcm90b3R5cGUsIHRoaXMsIHRoaXMpO1xyXG5cclxuXHRcdGxvYWRDb25maWcuY2FsbCgkJCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0JCQuYmVmb3JlSW5pdCgpO1xyXG5cdFx0JCQuaW5pdCgpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gZXh0ZW5kIGNvbW1vbiBBUElzIGFzIHBhcnQgb2YgQ2hhcnQgY2xhc3NcclxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwgW1xyXG5cdGFwaUNoYXJ0LFxyXG5cdGFwaUNvbG9yLFxyXG5cdGFwaURhdGEsXHJcblx0YXBpRXhwb3J0LFxyXG5cdGFwaUZvY3VzLFxyXG5cdGFwaUxlZ2VuZCxcclxuXHRhcGlMb2FkLFxyXG5cdGFwaVNob3csXHJcblx0YXBpVG9vbHRpcCxcclxuXHQuLi5hcGlBeGlzXHJcbl0pO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDaGFydCBmcm9tIFwiLi9DaGFydC9DaGFydFwiO1xyXG5pbXBvcnQge2lzT2JqZWN0LCBtZXJnZU9ian0gZnJvbSBcIi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxyXG5leHBvcnQge2JiLCBiYiBhcyBkZWZhdWx0fTtcclxuXHJcbmxldCBkZWZhdWx0cyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgYmJcclxuICogQHZlcnNpb24gMi4wLjAtYWxwaGFcclxuICovXHJcbmNvbnN0IGJiID0ge1xyXG5cdC8qKlxyXG5cdCAqIFZlcnNpb24gaW5mb3JtYXRpb25cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gdmVyc2lvbiB2ZXJzaW9uXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgICBiYi52ZXJzaW9uOyAgLy8gXCIxLjAuMFwiXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICovXHJcblx0dmVyc2lvbjogXCIyLjAuMC1hbHBoYVwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSBjaGFydFxyXG5cdCAqIEBwYXJhbSB7T3B0aW9uc30gY29uZmlnIGNoYXJ0IG9wdGlvbnNcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKiBAcmV0dXJucyB7Q2hhcnR9XHJcblx0ICogQHNlZSB7QGxpbmsgT3B0aW9uc30gZm9yIGRpZmZlcmVudCBnZW5lcmF0aW9uIG9wdGlvbnNcclxuXHQgKiBAc2VlIHtAbGluayBDaGFydH0gZm9yIGRpZmZlcmVudCBtZXRob2RzIEFQSVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIDwhLS0gY2hhcnQgaG9sZGVyIC0tPlxyXG5cdCAqIDxkaXYgaWQ9XCJMaW5lQ2hhcnRcIj48L2Rpdj5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAgLy8gZ2VuZXJhdGUgY2hhcnQgd2l0aCBvcHRpb25zXHJcblx0ICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuXHQgKiAgICAgIFwiYmluZHRvXCI6IFwiI0xpbmVDaGFydFwiXHJcblx0ICogICAgICBcImRhdGFcIjoge1xyXG5cdCAqICAgICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICogICAgICAgICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMCwgNDAwLCAxNTAsIDI1MF0sXHJcblx0ICogICAgICAgICAgICAgIFtcImRhdGEyXCIsIDUwLCAyMCwgMTAsIDQwLCAxNSwgMjVdXHJcblx0ICogICAgICAgICAgIF1cclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICpcclxuXHQgKiAgLy8gY2FsbCBzb21lIEFQSVxyXG5cdCAqICAvLyBleCkgZ2V0IHRoZSBkYXRhIG9mICdkYXRhMSdcclxuXHQgKiAgY2hhcnQuZGF0YShcImRhdGExXCIpO1xyXG5cdCAqL1xyXG5cdGdlbmVyYXRlKGNvbmZpZykge1xyXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IG1lcmdlT2JqKHt9LCBkZWZhdWx0cywgY29uZmlnKTtcclxuXHRcdGNvbnN0IGluc3QgPSBuZXcgQ2hhcnQob3B0aW9ucyk7XHJcblxyXG5cdFx0aW5zdC5pbnRlcm5hbC5jaGFydHMgPSB0aGlzLmluc3RhbmNlO1xyXG5cdFx0dGhpcy5pbnN0YW5jZS5wdXNoKGluc3QpO1xyXG5cclxuXHRcdHJldHVybiBpbnN0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBvciBnZXQgZ2xvYmFsIGRlZmF1bHQgb3B0aW9ucy5cclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgLSBUaGUgb3B0aW9ucyB2YWx1ZXMgc2V0dGluZ3MgYXJlIHZhbGlkIHdpdGhpbiBwYWdlIGNvbnRleHQgb25seS5cclxuXHQgKiAgIC0gSWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCB3aWxsIG92ZXJyaWRlIHRoZSBsYXN0IHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBjaGFydCBvcHRpb25zXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICogQHJldHVybnMge09wdGlvbnN9XHJcblx0ICogQHNlZSB7QGxpbmsgT3B0aW9uc31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFNldCBzYW1lIG9wdGlvbiB2YWx1ZSBhcyBmb3IgYC5nZW5lcmF0ZSgpYFxyXG5cdCAqIGJiLmRlZmF1bHRzKHtcclxuXHQgKiAgIGRhdGE6IHtcclxuXHQgKiAgICAgdHlwZTogXCJiYXJcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH0pO1xyXG5cdCAqXHJcblx0ICogYmIuZGVmYXVsdHMoKTsgIC8vIHtkYXRhOnt0eXBlOiBcImJhclwifX1cclxuXHQgKlxyXG5cdCAqIC8vIGRhdGEudHlwZSBkZWZhdWx0cyB0byAnYmFyJ1xyXG5cdCAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xyXG5cdCAqL1xyXG5cdGRlZmF1bHRzKG9wdGlvbnM/KSB7XHJcblx0XHRpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcclxuXHRcdFx0ZGVmYXVsdHMgPSBvcHRpb25zO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkZWZhdWx0cztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBBbiBhcnJheSBjb250YWluaW5nIGluc3RhbmNlIGNyZWF0ZWRcclxuXHQgKiBAcHJvcGVydHkge0FycmF5fSBpbnN0YW5jZSBpbnN0YW5jZSBhcnJheVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIGdlbmVyYXRlIGNoYXJ0c1xyXG5cdCAqICB2YXIgY2hhcnQxID0gYmIuZ2VuZXJhdGUoLi4uKTtcclxuXHQgKiAgdmFyIGNoYXJ0MiA9IGJiLmdlbmVyYXRlKC4uLik7XHJcblx0ICpcclxuXHQgKiAgYmIuaW5zdGFuY2U7ICAvLyBbIGNoYXJ0MSwgY2hhcnQyLCAuLi4gXVxyXG5cdCAqIEBtZW1iZXJvZiBiYlxyXG5cdCAqL1xyXG5cdGluc3RhbmNlOiBbXSxcclxuXHJcblx0LyoqXHJcblx0ICogTmFtZXNwYWNlIGZvciBwbHVnaW5zXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHBsdWdpbiBwbHVnaW4gbmFtZXNwYWNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gU3RhbmZvcmQgZGlhZ3JhbSBwbHVnaW5cclxuXHQgKiAgYmIucGx1Z2luLnN0YW5mb3JkO1xyXG5cdCAqIEBtZW1iZXJvZiBiYlxyXG5cdCAqL1xyXG5cdHBsdWdpbjoge31cclxufTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==