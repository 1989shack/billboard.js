(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-brush"), require("d3-dsv"), require("d3-drag"), require("d3-scale"), require("d3-transition"), require("d3-shape"), require("d3-zoom"), require("d3-axis"), require("d3-ease"), require("d3-color"), require("d3-interpolate"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-brush", "d3-dsv", "d3-drag", "d3-scale", "d3-transition", "d3-shape", "d3-zoom", "d3-axis", "d3-ease", "d3-color", "d3-interpolate"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-brush"), require("d3-dsv"), require("d3-drag"), require("d3-scale"), require("d3-transition"), require("d3-shape"), require("d3-zoom"), require("d3-axis"), require("d3-ease"), require("d3-color"), require("d3-interpolate")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__36__, __WEBPACK_EXTERNAL_MODULE__37__, __WEBPACK_EXTERNAL_MODULE__38__, __WEBPACK_EXTERNAL_MODULE__39__, __WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__41__, __WEBPACK_EXTERNAL_MODULE__42__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__45__, __WEBPACK_EXTERNAL_MODULE__46__, __WEBPACK_EXTERNAL_MODULE__47__, __WEBPACK_EXTERNAL_MODULE__48__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(32);
module.exports = __webpack_require__(49);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(3);

var socket = __webpack_require__(5);

var overlay = __webpack_require__(9);

var _require = __webpack_require__(15),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(17);

var reloadApp = __webpack_require__(18);

var createSocketUrl = __webpack_require__(21);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(30);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost:8080"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(4)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(6);
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(7);

var BaseClient = __webpack_require__(8);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(6);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* sockjs-client v1.4.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.4.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(10);

var _require = __webpack_require__(11),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var xml_entities_1 = __webpack_require__(12);
exports.XmlEntities = xml_entities_1.XmlEntities;
var html4_entities_1 = __webpack_require__(13);
exports.Html4Entities = html4_entities_1.Html4Entities;
var html5_entities_1 = __webpack_require__(14);
exports.Html5Entities = html5_entities_1.Html5Entities;
exports.AllHtmlEntities = html5_entities_1.Html5Entities;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};
var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};
var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};
var XmlEntities = /** @class */ (function () {
    function XmlEntities() {
    }
    XmlEntities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/[<>"'&]/g, function (s) {
            return CHAR_S_INDEX[s];
        });
    };
    XmlEntities.encode = function (str) {
        return new XmlEntities().encode(str);
    };
    XmlEntities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&#?[0-9a-zA-Z]+;?/g, function (s) {
            if (s.charAt(1) === '#') {
                var code = s.charAt(2).toLowerCase() === 'x' ?
                    parseInt(s.substr(3), 16) :
                    parseInt(s.substr(2));
                if (isNaN(code) || code < -32768 || code > 65535) {
                    return '';
                }
                return String.fromCharCode(code);
            }
            return ALPHA_INDEX[s] || s;
        });
    };
    XmlEntities.decode = function (str) {
        return new XmlEntities().decode(str);
    };
    XmlEntities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var alpha = CHAR_INDEX[c];
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
            if (c < 32 || c > 126) {
                result += '&#' + c + ';';
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonUTF = function (str) {
        return new XmlEntities().encodeNonUTF(str);
    };
    XmlEntities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLenght = str.length;
        var result = '';
        var i = 0;
        while (i < strLenght) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    XmlEntities.encodeNonASCII = function (str) {
        return new XmlEntities().encodeNonASCII(str);
    };
    return XmlEntities;
}());
exports.XmlEntities = XmlEntities;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];
var alphaIndex = {};
var numIndex = {};
(function () {
    var i = 0;
    var length = HTML_ALPHA.length;
    while (i < length) {
        var a = HTML_ALPHA[i];
        var c = HTML_CODES[i];
        alphaIndex[a] = String.fromCharCode(c);
        numIndex[c] = a;
        i++;
    }
})();
var Html4Entities = /** @class */ (function () {
    function Html4Entities() {
    }
    Html4Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1).toLowerCase() === 'x' ?
                    parseInt(entity.substr(2), 16) :
                    parseInt(entity.substr(1));
                if (!(isNaN(code) || code < -32768 || code > 65535)) {
                    chr = String.fromCharCode(code);
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html4Entities.decode = function (str) {
        return new Html4Entities().decode(str);
    };
    Html4Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var alpha = numIndex[str.charCodeAt(i)];
            result += alpha ? "&" + alpha + ";" : str.charAt(i);
            i++;
        }
        return result;
    };
    Html4Entities.encode = function (str) {
        return new Html4Entities().encode(str);
    };
    Html4Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var cc = str.charCodeAt(i);
            var alpha = numIndex[cc];
            if (alpha) {
                result += "&" + alpha + ";";
            }
            else if (cc < 32 || cc > 126) {
                result += "&#" + cc + ";";
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonUTF = function (str) {
        return new Html4Entities().encodeNonUTF(str);
    };
    Html4Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    Html4Entities.encodeNonASCII = function (str) {
        return new Html4Entities().encodeNonASCII(str);
    };
    return Html4Entities;
}());
exports.Html4Entities = Html4Entities;


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];
var alphaIndex = {};
var charIndex = {};
createIndexes(alphaIndex, charIndex);
var Html5Entities = /** @class */ (function () {
    function Html5Entities() {
    }
    Html5Entities.prototype.decode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        return str.replace(/&(#?[\w\d]+);?/g, function (s, entity) {
            var chr;
            if (entity.charAt(0) === "#") {
                var code = entity.charAt(1) === 'x' ?
                    parseInt(entity.substr(2).toLowerCase(), 16) :
                    parseInt(entity.substr(1));
                if (!(isNaN(code) || code < -32768 || code > 65535)) {
                    chr = String.fromCharCode(code);
                }
            }
            else {
                chr = alphaIndex[entity];
            }
            return chr || s;
        });
    };
    Html5Entities.decode = function (str) {
        return new Html5Entities().decode(str);
    };
    Html5Entities.prototype.encode = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var charInfo = charIndex[str.charCodeAt(i)];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            result += str.charAt(i);
            i++;
        }
        return result;
    };
    Html5Entities.encode = function (str) {
        return new Html5Entities().encode(str);
    };
    Html5Entities.prototype.encodeNonUTF = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            var charInfo = charIndex[c];
            if (charInfo) {
                var alpha = charInfo[str.charCodeAt(i + 1)];
                if (alpha) {
                    i++;
                }
                else {
                    alpha = charInfo[''];
                }
                if (alpha) {
                    result += "&" + alpha + ";";
                    i++;
                    continue;
                }
            }
            if (c < 32 || c > 126) {
                result += '&#' + c + ';';
            }
            else {
                result += str.charAt(i);
            }
            i++;
        }
        return result;
    };
    Html5Entities.encodeNonUTF = function (str) {
        return new Html5Entities().encodeNonUTF(str);
    };
    Html5Entities.prototype.encodeNonASCII = function (str) {
        if (!str || !str.length) {
            return '';
        }
        var strLength = str.length;
        var result = '';
        var i = 0;
        while (i < strLength) {
            var c = str.charCodeAt(i);
            if (c <= 255) {
                result += str[i++];
                continue;
            }
            result += '&#' + c + ';';
            i++;
        }
        return result;
    };
    Html5Entities.encodeNonASCII = function (str) {
        return new Html5Entities().encodeNonASCII(str);
    };
    return Html5Entities;
}());
exports.Html5Entities = Html5Entities;
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo = void 0;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            addChar && (charInfo[chr2] = alpha);
        }
        else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            addChar && (charInfo[''] = alpha);
        }
    }
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(16).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(15),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(19);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(20);
module.exports = new EventEmitter();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(22);

var getCurrentScriptSource = __webpack_require__(29);

function createSocketUrl(resourceQuery, currentLocation) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL
    .substr(1) // replace first `&` with `?` to have a valid query string
    .replace('&', '?'), true);
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();
    urlParts = url.parse(scriptHost || '/', true, true);
  } // Use parameter to allow passing location in unit tests


  if (typeof currentLocation === 'string' && currentLocation !== '') {
    currentLocation = url.parse(currentLocation);
  } else {
    currentLocation = self.location;
  }

  return getSocketUrl(urlParts, currentLocation);
}
/*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */


function getSocketUrl(urlParts, loc) {
  var auth = urlParts.auth,
      query = urlParts.query;
  var hostname = urlParts.hostname,
      protocol = urlParts.protocol,
      port = urlParts.port;

  if (!port || port === '0') {
    port = loc.port;
  } // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384


  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {
    hostname = loc.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = loc.protocol;
  } // all of these sock url params are optionally passed in through
  // resourceQuery, so we need to fall back to the default if
  // they are not provided


  var sockHost = query.sockHost || hostname;
  var sockPath = query.sockPath || '/sockjs-node';
  var sockPort = query.sockPort || port;

  if (sockPort === 'location') {
    sockPort = loc.port;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(23);
var util = __webpack_require__(25);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(26);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)(module)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(27);
exports.encode = exports.stringify = __webpack_require__(28);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 31
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 30;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(33);
            var content = __webpack_require__(34);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);



module.exports = content.locals || {};

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(35);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px sans-serif;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc rect {\n  stroke: #fff;\n  stroke-width: 1; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused, .bb-circles.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step, .bb-circles.bb-focused path.bb-line, .bb-circles.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused, .bb-circles.bb-defocused {\n  opacity: 0.3 !important; }\n  .bb-target.bb-defocused .text-overlapping, .bb-circles.bb-defocused .text-overlapping {\n    opacity: .05 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px sans-serif; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10;\n  user-select: none; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: #fff; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__36__;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__37__;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__38__;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__39__;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__41__;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__42__;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__46__;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__48__;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "default", function() { return /* reexport */ bb; });
__webpack_require__.d(__webpack_exports__, "bb", function() { return /* reexport */ bb; });

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(36);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(37);

// CONCATENATED MODULE: ./src/config/classes.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcLabelLine: "bb-arc-label-line",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartCircles: "bb-chart-circles",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legend: "bb-legend",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  main: "bb-main",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridFocus: "bb-ygrid-focus",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_",
  TextOverlapping: "text-overlapping"
});
// CONCATENATED MODULE: ./src/config/Store/Element.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Elements class.
 * @class Elements
 * @ignore
 * @private
 */
var Element = function () {
  return {
    chart: null,
    main: null,
    svg: null,
    axis: {
      // axes
      x: null,
      y: null,
      y2: null,
      subX: null
    },
    defs: null,
    tooltip: null,
    legend: null,
    title: null,
    subchart: {
      main: null,
      // $$.context
      bar: null,
      // $$.contextBar
      line: null,
      // $$.contextLine
      area: null // $$.contextArea

    },
    arcs: null,
    bar: null,
    // mainBar,
    line: null,
    // mainLine,
    area: null,
    // mainArea,
    circle: null,
    // mainCircle,
    radar: null,
    text: null,
    // mainText,
    grid: {
      main: null,
      // grid (also focus)
      x: null,
      // xgrid,
      y: null // ygrid,

    },
    gridLines: {
      main: null,
      // gridLines
      x: null,
      // xgridLines,
      y: null // ygridLines

    },
    region: {
      main: null,
      // region
      list: null // mainRegion

    },
    eventRect: null
  };
};


// CONCATENATED MODULE: ./src/config/Store/State.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * State class.
 * @class State
 * @ignore
 * @private
 */
var State = function () {
  return {
    width: 0,
    width2: 0,
    height: 0,
    height2: 0,
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin2: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin3: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    arcWidth: 0,
    arcHeight: 0,
    xAxisHeight: 0,
    hasAxis: !1,
    hasRadar: !1,
    current: {
      width: 0,
      height: 0,
      dataMax: 0,
      maxTickWidths: {
        x: {
          size: 0,
          ticks: [],
          clipPath: 0,
          domain: ""
        },
        y: {
          size: 0,
          domain: ""
        },
        y2: {
          size: 0,
          domain: ""
        }
      },
      // current used chart type list
      types: []
    },
    // legend
    isLegendRight: !1,
    isLegendInset: !1,
    isLegendTop: !1,
    isLegendLeft: !1,
    legendStep: 0,
    legendItemWidth: 0,
    legendItemHeight: 0,
    legendHasRendered: !1,
    axis: {
      x: {
        padding: {
          left: 0,
          right: 0
        },
        tickCount: 0
      }
    },
    rotatedPadding: {
      left: 30,
      right: 0,
      top: 5
    },
    withoutFadeIn: {},
    inputType: "",
    datetimeId: "",
    // clip id string
    clip: {
      id: "",
      idXAxis: "",
      idYAxis: "",
      idXAxisTickTexts: "",
      idGrid: "",
      idSubchart: "",
      // clipIdForSubchart
      path: "",
      pathXAxis: "",
      pathYAxis: "",
      pathXAxisTickTexts: "",
      pathGrid: ""
    },
    // status
    dragStart: null,
    dragging: !1,
    flowing: !1,
    cancelClick: !1,
    mouseover: !1,
    rendered: !1,
    transiting: !1,
    resizing: !1,
    // resize event called
    toggling: !1,
    // legend toggle
    hasNegativeValue: !1,
    hasPositiveValue: !0,
    orgAreaOpacity: "0.2",
    // ID strings
    hiddenTargetIds: [],
    hiddenLegendIds: [],
    focusedTargetIds: [],
    defocusedTargetIds: [],
    // value for Arc
    radius: 0,
    innerRadius: 0,
    innerRadiusRatio: 0,
    gaugeArcWidth: 0,
    radiusExpanded: 0,
    // xgrid attribute
    xgridAttr: {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }
  };
};


// CONCATENATED MODULE: ./src/config/Store/Store.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

 // mapping

var Store_classes = {
  element: Element,
  state: State
};
/**
 * Internal store class.
 * @class Store
 * @ignore
 * @private
 */

var Store = /*#__PURE__*/function () {
  function Store() {
    var _this = this;

    Object.keys(Store_classes).forEach(function (v) {
      _this[v] = new Store_classes[v]();
    });
  }

  var _proto = Store.prototype;
  return _proto.getStore = function getStore(name) {
    return this[name];
  }, Store;
}();


// CONCATENATED MODULE: ./src/config/Options/common/main.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * main config options
 */
/* harmony default export */ var common_main = ({
  /**
   * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
   * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
   * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
   * @name bindto
   * @memberof Options
   * @property {string|HTMLElement|d3.selection|object} [bindto="#chart"] Specify the element where chart will be drawn.
   * @property {string|HTMLElement|d3.selection} bindto.element="#chart" Specify the element where chart will be drawn.
   * @property {string} [bindto.classname=bb] Specify the class name of bind element.<br>
   *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
   * @default #chart
   * @example
   * bindto: "#myContainer"
   *
   * // or HTMLElement
   * bindto: document.getElementById("myContainer")
   *
   * // or D3 selection object
   * bindto: d3.select("#myContainer")
   *
   * // or to change default classname
   * bindto: {
   *    element: "#chart",
   *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
   * }
   */
  bindto: "#chart",

  /**
   * Set chart background.
   * @name background
   * @memberof Options
   * @property {object} background background object
   * @property {string} background.class Specify the class name for background element.
   * @property {string} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.
   * @property {string} background.imgUrl Specify the image url string for background.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)
   * @example
   * background: {
   *    class: "myClass",
   *    color: "red",
   *
   *    // Set image url for background.
   *    // If specified, 'color' option will be ignored.
   *    imgUrl: "https://naver.github.io/billboard.js/img/logo/billboard.js.svg",
   * }
   */
  background: {},

  /**
   * Set 'clip-path' attribute for chart element
   * - **NOTE:**
   *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
   *  > Is to make chart element positioned over axis element.
   * @name clipPath
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  clipPath: !0,

  /**
   * Set svg element's class name
   * @name svg
   * @memberof Options
   * @type {object}
   * @property {object} [svg] svg object
   * @property {string} [svg.classname] class name for svg element
   * @example
   * svg: {
   *   classname: "test_class"
   * }
   */
  svg_classname: undefined,

  /**
   * The desired size of the chart element.
   * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
   * @name size
   * @memberof Options
   * @type {object}
   * @property {object} [size] size object
   * @property {number} [size.width] width of the chart element
   * @property {number} [size.height] height of the chart element
   * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
   * @example
   * size: {
   *   width: 640,
   *   height: 480
   * }
   */
  size_width: undefined,
  size_height: undefined,

  /**
   * The padding of the chart element.
   * @name padding
   * @memberof Options
   * @type {object}
   * @property {object} [padding] padding object
   * @property {number} [padding.top] padding on the top of chart
   * @property {number} [padding.right] padding on the right of chart
   * @property {number} [padding.bottom] padding on the bottom of chart
   * @property {number} [padding.left] padding on the left of chart
   * @example
   * padding: {
   *   top: 20,
   *   right: 20,
   *   bottom: 20,
   *   left: 20
   * }
   */
  padding_left: undefined,
  padding_right: undefined,
  padding_top: undefined,
  padding_bottom: undefined,

  /**
   * Set chart resize options
   * @name resize
   * @memberof Options
   * @type {object}
   * @property {object} [resize] resize object
   * @property {boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
   * @example
   *  resize: {
   *      auto: false
   *  }
   */
  resize_auto: !0,

  /**
   * Set a callback to execute when mouse/touch enters the chart.
   * @name onover
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * // @param {Chart} ctx - Instance itself
   * onover: function(ctx) {
   *   ...
   * }
   */
  onover: undefined,

  /**
   * Set a callback to execute when mouse/touch leaves the chart.
   * @name onout
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * // @param {Chart} ctx - Instance itself
   * onout: function(ctx) {
   *   ...
   * }
   */
  onout: undefined,

  /**
   * Set a callback to execute when user resizes the screen.
   * @name onresize
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * // @param {Chart} ctx - Instance itself
   * onresize: function(ctx) {
   *   ...
   * }
   */
  onresize: undefined,

  /**
   * Set a callback to execute when screen resize finished.
   * @name onresized
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * // @param {Chart} ctx - Instance itself
   * onresized: function(ctx) {
   *   ...
   * }
   */
  onresized: undefined,

  /**
   * Set a callback to execute before the chart is initialized
   * @name onbeforeinit
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * // @param {Chart} ctx - Instance itself
   * onbeforeinit: function(ctx) {
   *   ...
   * }
   */
  onbeforeinit: undefined,

  /**
   * Set a callback to execute when the chart is initialized.
   * @name oninit
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * // @param {Chart} ctx - Instance itself
   * oninit: function(ctx) {
   *   ...
   * }
   */
  oninit: undefined,

  /**
   * Set a callback to execute after the chart is initialized
   * @name onafterinit
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * // @param {Chart} ctx - Instance itself
   * onafterinit: function(ctx) {
   *   ...
   * }
   */
  onafterinit: undefined,

  /**
   * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
   * @name onrendered
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * // @param {Chart} ctx - Instance itself
   * onrendered: function(ctx) {
   *   ...
   * }
   */
  onrendered: undefined,

  /**
   * Set duration of transition (in milliseconds) for chart animation.<br><br>
   * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
   * @name transition
   * @memberof Options
   * @type {object}
   * @property {object} [transition] transition object
   * @property {number} [transition.duration=350] duration in milliseconds
   * @example
   * transition: {
   *    duration: 500
   * }
   */
  transition_duration: 350,

  /**
   * Set scatter options
   * @name scatter
   * @memberof Options
   * @type {object}
   * @property {object} [scatter] scatter object
   * @property {boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.
   * @example
   *  scatter: {
   *      connectNull: true,
   *      step: {
   *          type: "step-after"
   *      },
   *
   *      // hide all data points ('point.show=false' also has similar effect)
   *      point: false,
   *
   *      // show data points for only indicated datas
   *      point: [
   *          "data1", "data3"
   *      ],
   *
   *      zerobased: false
   *  }
   */
  scatter_zerobased: !1,

  /**
   * Set plugins
   * @name plugins
   * @memberof Options
   * @type {Array}
   * @example
   *  plugins: [
   *    new bb.plugin.stanford({ ... }),
   *    new PluginA(),
   *    ...
   * ]
   */
  plugins: [],

  /**
   * Control the render timing
   * @name render
   * @memberof Options
   * @type {object}
   * @property {object} [render] render object
   * @property {boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
   * @property {boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
   * @example
   *  render: {
   *    lazy: true,
   *    observe: true
   * }
   *
   * @example
   *	// <!-- render.lazy will detect visibility defined -->
   *  // (a) <div id='chart' class='hide'></div>
   *  // (b) <div id='chart' style='display:none'></div>
   *
   *  // render.lazy enabled by default when element is hidden
   *  var chart = bb.generate({ ... });
   *
   *  // chart will be rendered automatically when element's visibility changes
   *  // Note: works only for inlined css property or class attribute changes
   *  document.getElementById('chart').classList.remove('hide')  // (a)
   *  document.getElementById('chart').style.display = 'block';  // (b)
   *
   * @example
   *	// chart won't be rendered and not observing bind element's visiblity changes
   *  var chart = bb.generate({
   *     render: {
   *          lazy: true,
   *          observe: false
   *     }
   *  });
   *
   *  // call at any point when you want to render
   *  chart.flush();
   */
  render: {},

  /**
   * Show rectangles inside the chart.<br><br>
   * This option accepts array including object that has axis, start, end and class.
   * The keys start, end and class are optional.
   * axis must be x, y or y2. start and end should be the value where regions start and end.
   * If not specified, the edge values will be used.
   * If timeseries x axis, date string, Date object and unixtime integer can be used.
   * If class is set, the region element will have it as class.
   * @name regions
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   *  regions: [
   *    {
   *      axis: "x",
   *      start: 1,
   *      end: 4,
   *      class: "region-1-4"
   *    }
   *  ]
   */
  regions: []
});
// CONCATENATED MODULE: ./src/config/Options/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data config options
 */
/* harmony default export */ var data_data = ({
  /**
   * Converts data id value
   * @name data․idConverter
   * @memberof Options
   * @type {Function}
   * @default function(id) { return id; }
   * @example
   * data: {
   *    idConverter: function(id) {
   *       // when id is 'data1', converts to be 'data2'
   *       // 'data2' should be given as the initial data value
   *       if (id === "data1") {
   *          return "data2";
   *       } else {
   *          return id;
   *       }
   *    }
   * }
   */
  data_idConverter: function data_idConverter(id) {
    return id;
  },

  /**
   * Set custom data name.
   * @name data․names
   * @memberof Options
   * @type {object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
   * @example
   * data: {
   *   names: {
   *     data1: "Data Name 1",
   *     data2: "Data Name 2"
   *   }
   * }
   */
  data_names: {},

  /**
   * Set custom data class.<br><br>
   * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
   * @name data․classes
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   classes: {
   *     data1: "additional-data1-class",
   *     data2: "additional-data2-class"
   *   }
   * }
   */
  data_classes: {},

  /**
   * Set chart type at once.<br><br>
   * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
   * **Available Values:**
   * - area
   * - area-line-range
   * - area-spline
   * - area-spline-range
   * - area-step
   * - bar
   * - bubble
   * - donut
   * - gauge
   * - line
   * - pie
   * - radar
   * - scatter
   * - spline
   * - step
   * @name data․type
   * @memberof Options
   * @type {string}
   * @default line
   * @example
   * data: {
   *    type: "bar"
   * }
   */
  data_type: undefined,

  /**
   * Set chart type for each data.<br>
   * This setting overwrites data.type setting.
   * - **NOTE:** `radar` type can't be combined with other types.
   * @name data․types
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   types: {
   *     data1: "bar",
   *     data2: "spline"
   *   }
   * }
   */
  data_types: {},

  /**
   *  This option changes the order of stacking data and pieces of pie/donut.
   *  - If `null` specified, it will be the order the data loaded.
   *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
   *
   *  **Available Values:**
   *  - `desc`: In descending order
   *  - `asc`: In ascending order
   *  - `null`: It keeps the data load order
   *  - `function(data1, data2) { ... }`: Array.sort compareFunction
   * @name data․order
   * @memberof Options
   * @type {string|Function|null}
   * @default desc
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
   * @example
   * data: {
   *   // in descending order (default)
   *   order: "desc"
   *
   *   // in ascending order
   *   order: "asc"
   *
   *   // keeps data input order
   *   order: null
   *
   *   // specifying sort function
   *   order: function(a, b) {
   *       // param data passed format
   *       {
   *          id: "data1", id_org: "data1", values: [
   *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
   *              ...
   *          ]
   *       }
   *   }
   * }
   */
  data_order: "desc",

  /**
   * Set color converter function.<br><br>
   * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
   * @name data․color
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
   * @example
   * data: {
   *   color: function(color, d) { ... }
   * }
   */
  data_color: undefined,

  /**
   * Set color for each data.
   * @name data․colors
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   colors: {
   *     data1: "#ff0000",
   *     data2: function(d) {
   *        return "#000";
   *     }
   *     ...
   *   }
   * }
   */
  data_colors: {},

  /**
   * Hide each data when the chart appears.<br><br>
   * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
   * @name data․hide
   * @memberof Options
   * @type {boolean|Array}
   * @default false
   * @example
   * data: {
   *   // all of data will be hidden
   *   hide: true
   *
   *   // specified data will be hidden
   *   hide: ["data1", ...]
   * }
   */
  data_hide: !1,

  /**
   * Filter values to be shown
   * The data value is the same as the returned by `.data()`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
   * @name data․filter
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * data: {
   *   // filter for id value
   *   filter: function(v) {
   *      // v: [{id: "data1", id_org: "data1", values: [
   *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
   *      //    }, ...]
   *      return v.id !== "data1";
   *   }
   */
  data_filter: undefined,

  /**
   * Set a callback for click event on each data point.<br><br>
   * This callback will be called when each data point clicked and will receive `d` and element as the arguments.
   * - `d` is the data clicked and element is the element clicked.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onclick
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onclick: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onclick: function data_onclick() {},

  /**
   * Set a callback for mouse/touch over event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.
   * - `d` is the data where mouse cursor moves onto.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onover
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onover: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onover: function data_onover() {},

  /**
   * Set a callback for mouse/touch out event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.
   * - `d` is the data where mouse cursor moves out.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onout
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onout: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onout: function data_onout() {},

  /**
   * Set a callback for minimum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmin
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmin: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmin: undefined,

  /**
   * Set a callback for maximum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmax
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmax: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmax: undefined,

  /**
   * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
   * @name data․url
   * @memberof Options
   * @type {string}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
   * @example
   * data: {
   *     url: "/data/test.csv"
   * }
   */
  data_url: undefined,

  /**
   * XHR header value
   * - **NOTE:** Should be used with `data.url` option
   * @name data․headers
   * @memberof Options
   * @type {string}
   * @default undefined
   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
   * @example
   * data: {
   *     url: "/data/test.csv",
   *     headers: {
   *        "Content-Type": "text/xml",
   *        ...
   *     }
   * }
   */
  data_headers: undefined,

  /**
   * Parse a JSON object for data. See also data.keys.
   * @name data․json
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [data․keys](#.data%25E2%2580%25A4keys)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_json: undefined,

  /**
   * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
   * @name data․rows
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
   * @example
   * data: {
   *   rows: [
   *     ["A", "B", "C"],
   *     [90, 120, 300],
   *     [40, 160, 240],
   *     [50, 200, 290],
   *     [120, 160, 230],
   *     [80, 130, 300],
   *     [90, 220, 320]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {high:150, mid: 140, low: 110}, 120
   *        [150, 140, 110], 120
   *      ],
   *      [[155, 130, 115], 55],
   *      [[160, 135, 120], 60]
   *   ],
   *   types: {
   *       data1: "area-line-range",
   *       data2: "line"
   *   }
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {y:10, z: 140}, 120
   *        [10, 140], 120
   *      ],
   *      [[100, 30], 55],
   *      [[50, 100], 60]
   *   ],
   *   types: {
   *       data1: "bubble",
   *       data2: "line"
   *   }
   * }
   */
  data_rows: undefined,

  /**
   * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
   * @name data․columns
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
   * @example
   * data: {
   *   columns: [
   *      ["data1", 30, 20, 50, 40, 60, 50],
   *      ["data2", 200, 130, 90, 240, 130, 220],
   *      ["data3", 300, 200, 160, 400, 250, 250]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   columns: [
   *      ["data1",
   *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
   *          [150, 140, 110],
   *          [150, 140, 110]
   *      ]
   *   ],
   *   type: "area-line-range"
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   columns: [
   *      ["data1",
   *          [10, 140],  // or {y:10, z: 140}
   *          [100, 30],
   *          [50, 100]
   *      ]
   *   ],
   *   type: "bubble"
   * }
   */
  data_columns: undefined,

  /**
   * Used if loading JSON via data.url.
   * - **Available Values:**
   *   - json
   *   - csv
   *   - tsv
   * @name data․mimeType
   * @memberof Options
   * @type {string}
   * @default csv
   * @example
   * data: {
   *     mimeType: "json"
   * }
   */
  data_mimeType: "csv",

  /**
   * Choose which JSON object keys correspond to desired data.
   * - **NOTE:** Only for JSON object given as array.
   * @name data․keys
   * @memberof Options
   * @type {string}
   * @default undefined
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_keys: undefined,

  /**
   * Set text label to be displayed when there's no data to show.
   * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
   * @name data․empty․label․text
   * @memberof Options
   * @type {string}
   * @default ""
   * @example
   * data: {
   *   empty: {
   *     label: {
   *       text: "No Data"
   *     }
   *   }
   * }
   */
  data_empty_label_text: ""
});
// CONCATENATED MODULE: ./src/config/Options/common/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * color config options
 */
/* harmony default export */ var common_color = ({
  /**
   * Set color of the data values
   * @name color
   * @memberof Options
   * @type {object}
   * @property {object} color color object
   * @property {string|object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
   * @property {Array|null} [color.pattern=[]] Set custom color pattern. Passing `null` will not set a color for these elements, which requires the usage of custom CSS-based theming to work.
   * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
   *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
   *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
   *    - `bb-colorize-pattern-red`
   *    - `bb-colorize-pattern-fff`
   * @property {object} [color.threshold] color threshold for gauge and tooltip color
   * @property {string} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
   * @property {Array} [color.threshold.values] Threshold values for each steps
   * @property {number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
   * @example
   *  color: {
   *      pattern: ["#1f77b4", "#aec7e8", ...],
   *
   *      // Set colors' patterns
   *      // it should return an array of SVGPatternElement
   *      tiles: function() {
   *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
   *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
   *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
   *
   *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
   *         pattern.setAttribute("width", "32");
   *         pattern.setAttribute("height", "32");
   *
   *         g.style.fill = "#000";
   *         g.style.opacity = "0.2";
   *
   *         circle1.setAttribute("cx", "3");
   *         circle1.setAttribute("cy", "3");
   *         circle1.setAttribute("r", "3");
   *
   *         g.appendChild(circle1);
   *         pattern.appendChild(g);
   *
   *         return [pattern];
   *      },
   *
   *      // for threshold usage, pattern values should be set for each steps
   *      pattern: ["grey", "green", "yellow", "orange", "red"],
   *      threshold: {
   *          unit: "value",
   *
   *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
   *          values: [10, 20, 30, 40, 50],
   *
   *          // the equation for max:
   *          // - unit == 'value': max => 30
   *          // - unit != 'value': max => value*100/30
   *          max: 30
   *      },
   *
   *      // set all data to 'red'
   *      onover: "red",
   *
   *      // set different color for data
   *      onover: {
   *          data1: "red",
   *          data2: "yellow"
   *      },
   *
   *      // will pass data object to the callback
   *      onover: function(d) {
   *          return d.id === "data1" ? "red" : "green";
   *      }
   *  }
   */
  color_pattern: [],
  color_tiles: undefined,
  color_threshold: {},
  color_onover: undefined
});
// CONCATENATED MODULE: ./src/config/Options/common/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * interaction config options
 */
/* harmony default export */ var interaction = ({
  /**
   * Interaction options
   * @name interaction
   * @memberof Options
   * @type {object}
   * @property {object} interaction Intersection object
   * @property {boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
   *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
   * @property {boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
   * @property {boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
   * @property {boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
   * @property {boolean|number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
   * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
   * @example
   * interaction: {
   *    enabled: false,
   *    brighten: false,
   *    inputType: {
   *        mouse: true,
   *        touch: false
   *
   *        // or declare preventDefault explicitly.
   *        // In this case touch inputType is enabled by default
   *        touch: {
   *            preventDefault: true
   *
   *            // or threshold pixel value (pixel moved from touchstart to touchmove)
   *            preventDefault: 5
   *        }
   *    }
   * }
   */
  interaction_enabled: !0,
  interaction_brighten: !0,
  interaction_inputType_mouse: !0,
  interaction_inputType_touch: {}
});
// CONCATENATED MODULE: ./src/config/Options/common/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * legend config options
 */
/* harmony default export */ var common_legend = ({
  /**
   * Legend options
   * @name legend
   * @memberof Options
   * @type {object}
   * @property {object} legend Legend object
   * @property {boolean} [legend.show=true] Show or hide legend.
   * @property {boolean} [legend.hide=false] Hide legend
   *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
   * @property {string|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
   * @property {string|Function} [legend.contents.template=undefined] Set item's template.<br>
   *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
   *    - {=COLOR}: data color value
   *    - {=TITLE}: data title value
   *  - If set `function` value, will pass following arguments to the given function:
   *   - title {string}: data's id value
   *   - color {string}: color string
   *   - data {Array}: data array
   * @property {string} [legend.position=bottom] Change the position of legend.<br>
   *  Available values are: `bottom`, `right` and `inset` are supported.
   * @property {object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
   *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
   *  - **anchor** decides the position of the legend:
   *   - top-left
   *   - top-right
   *   - bottom-left
   *   - bottom-right
   *  - **x** and **y**:
   *   - set the position of the legend based on the anchor.
   *  - **step**:
   *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
   * @property {boolean} [legend.equally=false] Set to all items have same width size.
   * @property {boolean} [legend.padding=0] Set padding value
   * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
   * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
   * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
   * @property {number} [legend.item.tile.width=10] Set width of item tile element
   * @property {number} [legend.item.tile.height=10] Set height of item tile element
   * @property {boolean} [legend.usePoint=false] Whether to use custom points in legend.
   * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
   * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
   * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
   * @example
   *  legend: {
   *      show: true,
   *      hide: true,
   *      //or hide: "data1"
   *      //or hide: ["data1", "data2"]
   *      contents: {
   *          bindto: "#legend",   // <ul id='legend'></ul>
   *
   *          // will be as: <li style='background-color:#1f77b4'>data1</li>
   *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
   *
   *          // or using function
   *          template: function(id, color, data) {
   *               // if you want omit some legend, return falsy value
   *               if (id !== "data1") {
   *                    return "<li style='background-color:"+ color +">"+ id +"</li>";
   *               }
   *          }
   *      },
   *      position: "bottom",  // bottom, right, inset
   *      inset: {
   *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
   *          x: 20,
   *          y: 10,
   *          step: 2
   *      },
   *      equally: false,
   *      padding: 10,
   *      item: {
   *          onclick: function(id) { ... },
   *          onover: function(id) { ... },
   *          onout: function(id) { ... },
   *
   *          // set tile's size
   *          tile: {
   *              width: 20,
   *              height: 15
   *          }
   *      },
   *      usePoint: true
   *  }
   */
  legend_show: !0,
  legend_hide: !1,
  legend_contents_bindto: undefined,
  legend_contents_template: undefined,
  legend_position: "bottom",
  legend_inset_anchor: "top-left",
  legend_inset_x: 10,
  legend_inset_y: 0,
  legend_inset_step: undefined,
  legend_item_onclick: undefined,
  legend_item_onover: undefined,
  legend_item_onout: undefined,
  legend_equally: !1,
  legend_padding: 0,
  legend_item_tile_width: 10,
  legend_item_tile_height: 10,
  legend_usePoint: !1
});
// CONCATENATED MODULE: ./src/config/Options/common/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * title config options
 */
/* harmony default export */ var common_title = ({
  /**
   * Set title options
   * @name title
   * @memberof Options
   * @type {object}
   * @property {object} title Title object
   * @property {string} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
   * @property {number} [title.padding.top=0] Top padding value.
   * @property {number} [title.padding.right=0] Right padding value.
   * @property {number} [title.padding.bottom=0] Bottom padding value.
   * @property {number} [title.padding.left=0] Left padding value.
   * @property {string} [title.position=center] Available values are: 'center', 'right' and 'left'.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
   * @example
   *  title: {
   *      text: "Title Text",
   *
   *      // or Multiline title text
   *      text: "Main title text\nSub title text",
   *
   *      padding: {
   *          top: 10,
   *          right: 10,
   *          bottom: 10,
   *          left: 10
   *      },
   *      position: "center"
   *  }
   */
  title_text: undefined,
  title_padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  title_position: "center"
});
// CONCATENATED MODULE: ./src/config/Options/common/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * tooltip config options
 */
/* harmony default export */ var common_tooltip = ({
  /**
   * Tooltip options
   * @name tooltip
   * @memberof Options
   * @type {object}
   * @property {object} tooltip Tooltip object
   * @property {boolean} [tooltip.show=true] Show or hide tooltip.
   * @property {boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
   * @property {boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
   *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
   * @property {boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
   * @property {string} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
   * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
   *  Specified function receives x of the data point to show.
   * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   *  If undefined returned, the row of that value will be skipped.
   * @property {Function} [tooltip.position] Set custom position function for the tooltip.<br>
   *  This option can be used to modify the tooltip position by returning object that has top and left.
   * @property {Function|object} [tooltip.contents] Set custom HTML for the tooltip.<br>
   *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
   * @property {string|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
   *  - **NOTE:** When is specified, will not be updating tooltip's position.
   * @property {string} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
   *  Within template, below syntax will be replaced using template-like syntax string:
   *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
   *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
   *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
   *    - **{=TITLE}**: title value.
   *    - **{=COLOR}**: data color.
   *    - **{=VALUE}**: data value.
   * @property {object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
   *  - **NOTE:** It should contain `{ key: Array, ... }` value
   *    - 'key' name is used as substitution within template as '{=KEY}'
   *    - The value array length should match with the data length
   * @property {boolean} [tooltip.init.show=false] Show tooltip at the initialization.
   * @property {number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
   * @property {object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
   * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
   * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
   * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
   * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
   * @property {string|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
   *  **Available Values:**
   *  - `desc`: In descending data value order
   *  - `asc`: In ascending data value order
   *  - `null`: It keeps the data display order<br>
   *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
   *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
   *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
   * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
   * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
   * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
   * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
   * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
   * @example
   *  tooltip: {
   *      show: true,
   *      doNotHide: true,
   *      grouped: false,
   *      format: {
   *          title: function(x) { return "Data " + x; },
   *          name: function(name, ratio, id, index) { return name; },
   *          value: function(value, ratio, id, index) { return ratio; }
   *      },
   *      position: function(data, width, height, element) {
   *          return {top: 0, left: 0}
   *      },
   *
   *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
   *          return ... // formatted html as you want
   *      },
   *
   *       // specify tooltip contents using template
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
   *      		'}}</ul>'
   *      }
   *
   *       // with additional text value
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	text: {
   *      		// a) 'key' name is used as substitution within template as '{=KEY}'
   *      		// b) the length should match with the data length
   *      		VAR1: ["text1", "text2"],
   *      		VAR2: ["comment1", "comment2"],
   *      	},
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
   *      		'}}</ul>'
   *      }
   *
   *      // sort tooltip data value display in ascending order
   *      order: "asc",
   *
   *      // specifying sort function
   *      order: function(a, b) {
   *         // param data passed format
   *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
   *           ...
   *      },
   *
   *      // show at the initialization
   *      init: {
   *          show: true,
   *          x: 2,
   *          position: {
   *              top: "150px",
   *              left: "250px"
   *          }
   *      },
   *
   *      // fires prior tooltip is shown
   *      onshow: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires prior tooltip is hidden
   *      onhide: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is shown
   *      onshown: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is hidden
   *      onhidden: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
   *      // Useful for timeseries correlation
   *      linked: true,
   *
   *      // Specify name to interact those with the same name only.
   *      linked: {
   *          name: "some-group"
   *      }
   *  }
   */
  tooltip_show: !0,
  tooltip_doNotHide: !1,
  tooltip_grouped: !0,
  tooltip_format_title: undefined,
  tooltip_format_name: undefined,
  tooltip_format_value: undefined,
  tooltip_position: undefined,
  tooltip_contents: {},
  tooltip_init_show: !1,
  tooltip_init_x: 0,
  tooltip_init_position: {
    top: "0px",
    left: "50px"
  },
  tooltip_linked: !1,
  tooltip_linked_name: "",
  tooltip_onshow: function tooltip_onshow() {},
  tooltip_onhide: function tooltip_onhide() {},
  tooltip_onshown: function tooltip_onshown() {},
  tooltip_onhidden: function tooltip_onhidden() {},
  tooltip_order: null
});
// CONCATENATED MODULE: ./src/config/Options/data/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Axis based chart data config options
 */
/* harmony default export */ var data_axis = ({
  /**
   * Specify the key of x values in the data.<br><br>
   * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
   * @name data․x
   * @memberof Options
   * @type {string}
   * @default undefined
   * @example
   * data: {
   *   x: "date"
   * }
   */
  data_x: undefined,

  /**
   * Specify the keys of the x values for each data.<br><br>
   * This option can be used if we want to show the data that has different x values.
   * @name data․xs
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   xs: {
   *      data1: "x1",
   *      data2: "x2"
   *   }
   * }
   */
  data_xs: {},

  /**
   * Set a format specifier to parse string specifed as x.
   * @name data․xFormat
   * @memberof Options
   * @type {string}
   * @default %Y-%m-%d
   * @example
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "01012019", "02012019", "03012019"],
   *        ["data1", 30, 200, 100]
   *    ],
   *    // Format specifier to parse as datetime for given 'x' string value
   *    xFormat: "%m%d%Y"
   * },
   * axis: {
   *    x: {
   *        type: "timeseries"
   *    }
   * }
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   */
  data_xFormat: "%Y-%m-%d",

  /**
   * Set localtime format to parse x axis.
   * @name data․xLocaltime
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *   xLocaltime: false
   * }
   */
  data_xLocaltime: !0,

  /**
   * Sort on x axis.
   * @name data․xSort
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *   xSort: false
   * }
   */
  data_xSort: !0,

  /**
   * Set groups for the data for stacking.
   * @name data․groups
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * data: {
   *   groups: [
   *     ["data1", "data2"],
   *     ["data3"]
   *   ]
   * }
   */
  data_groups: [],

  /**
   * Set y axis the data related to. y and y2 can be used.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @name data․axes
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   axes: {
   *     data1: "y",
   *     data2: "y2"
   *   }
   * }
   */
  data_axes: {},

  /**
   * Set labels options
   * @name data․labels
   * @memberof Options
   * @type {object}
   * @property {object} data Data object
   * @property {boolean} [data.labels=false] Show or hide labels on each data points
   * @property {boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
   * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
   * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
   *  - `v` is the value of the data point where the label is shown.
   *  - `id` is the id of the data where the label is shown.
   *  - `i` is the index of the data point where the label is shown.
   *  - `j` is the sub index of the data point where the label is shown.<br><br>
   * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
   * @property {string|object} [data.labels.colors] Set label text colors.
   * @property {object} [data.labels.position] Set each dataset position, relative the original.
   * @property {number} [data.labels.position.x=0] x coordinate position, relative the original.
   * @property {number} [data.labels.position.y=0] y coordinate position, relative the original.
   * @memberof Options
   * @type {object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
   * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
   * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
   * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
   * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
   * @example
   * data: {
   *   labels: true,
   *
   *   // or set specific options
   *   labels: {
   *     format: function(v, id, i, j) { ... },
   *
   *     // it's possible to set for each data
   *     format: {
   *         data1: function(v, id, i, j) { ... },
   *         ...
   *     },
   *
   *     // align text to center of the 'bar' shape (works only for 'bar' type)
   *     centered: true,
   *
   *     // apply for all label texts
   *     colors: "red",
   *
   *     // or set different colors per dataset
   *     // for not specified dataset, will have the default color value
   *     colors: {
   *        data1: "yellow",
   *        data3: "green"
   *     },
   *
   *     // set x, y coordinate position
   *     position: {
   *        x: -10,
   *        y: 10
   *     },
   *
   *     // or set x, y coordinate position by each dataset
   *     position: {
   *        data1: {x: 5, y: 5},
   *        data2: {x: 10, y: -20}
   *     }
   *   }
   * }
   */
  data_labels: {},
  data_labels_colors: undefined,
  data_labels_position: {},

  /**
   * Define regions for each data.<br>
   * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
   * - The object type should be as:
   *   - start {number}: Start data point number. If not set, the start will be the first data point.
   *   - [end] {number}: End data point number. If not set, the end will be the last data point.
   *   - [style.dasharray="2 2"] {object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
   * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
   * @name data․regions
   * @memberof Options
   * @type {object}
   * @default {}
   * @example
   * data: {
   *   regions: {
   *     data1: [{
   *         start: 1,
   *         end: 2,
   *         style: {
   *             dasharray: "5 2"
   *         }
   *     }, {
   *         start: 3
   *     }],
   *     ...
   *   }
   * }
   */
  data_regions: {},

  /**
   * Set the stacking to be normalized
   * - **NOTE:**
   *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
   *   - y Axis will be set in percentage value (0 ~ 100%)
   *   - Must have postive values
   * @name data․stack․normalize
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
   * @example
   * data: {
   *   stack: {
   *      normalize: true
   *   }
   * }
   */
  data_stack_normalize: !1
});
// CONCATENATED MODULE: ./src/config/Options/data/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data.selection config options
 */
/* harmony default export */ var data_selection = ({
  /**
   * Set data selection enabled<br><br>
   * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
   * @name data․selection․enabled
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
   * @example
   * data: {
   *    selection: {
   *       enabled: true
   *    }
   * }
   */
  data_selection_enabled: !1,

  /**
   * Set grouped selection enabled.<br><br>
   * If this option set true, multiple data points that have same x value will be selected by one selection.
   * @name data․selection․grouped
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       grouped: true
   *    }
   * }
   */
  data_selection_grouped: !1,

  /**
   * Set a callback for each data point to determine if it's selectable or not.<br><br>
   * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
   * @name data․selection․isselectable
   * @memberof Options
   * @type {Function}
   * @default function() { return true; }
   * @example
   * data: {
   *    selection: {
   *       isselectable: function(d) { ... }
   *    }
   * }
   */
  data_selection_isselectable: function data_selection_isselectable() {
    return !0;
  },

  /**
   * Set multiple data points selection enabled.<br><br>
   * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
   * @name data․selection․multiple
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * data: {
   *    selection: {
   *       multiple: false
   *    }
   * }
   */
  data_selection_multiple: !0,

  /**
   * Enable to select data points by dragging.
   * If this option set true, data points can be selected by dragging.
   * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
   * @name data․selection․draggable
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       draggable: true
   *   }
   * }
   */
  data_selection_draggable: !1,

  /**
   * Set a callback for on data selection.
   * @name data․onselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onselected: function data_onselected() {},

  /**
   * Set a callback for on data un-selection.
   * @name data․onunselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onunselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onunselected: function data_onunselected() {}
});
// CONCATENATED MODULE: ./src/config/Options/axis/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var axis_x = ({
  /**
   * Set clip-path attribute for x axis element
   * @name axis․x․clipPath
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo]()
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_x_clipPath: !0,

  /**
   * Show or hide x axis.
   * @name axis․x․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     show: false
   *   }
   * }
   */
  axis_x_show: !0,

  /**
   * Set type of x axis.<br><br>
   * **Available Values:**
   * - timeseries
   * - category
   * - indexed
   * @name axis․x․type
   * @memberof Options
   * @type {string}
   * @default indexed
   * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
   * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
   * @example
   * axis: {
   *   x: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_x_type: "indexed",

  /**
   * Set how to treat the timezone of x values.<br>
   * If true, treat x value as localtime. If false, convert to UTC internally.
   * @name axis․x․localtime
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     localtime: false
   *   }
   * }
   */
  axis_x_localtime: !0,

  /**
   * Set category names on category axis.
   * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @name axis․x․categories
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * axis: {
   *   x: {
   *     categories: ["Category 1", "Category 2", ...]
   *   }
   * }
   */
  axis_x_categories: [],

  /**
   * centerize ticks on category axis.
   * @name axis․x․tick․centered
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       centered: true
   *     }
   *   }
   * }
   */
  axis_x_tick_centered: !1,

  /**
   * A function to format tick value. Format string is also available for timeseries data.
   * @name axis․x․tick․format
   * @memberof Options
   * @type {Function|string}
   * @default undefined
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *        // for timeseries, a 'datetime' object is given as parameter
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *
   *       // for category, index(Number) and categoryName(String) are given as parameter
   *       format: function(index, categoryName) {
   *           return categoryName.substr(0, 10);
   *       },
   *
   *        // for timeseries format specifier
   *        format: "%Y-%m-%d %H:%M:%S"
   *     }
   *   }
   * }
   */
  axis_x_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.x.tick.culling.max.
   * @name axis․x․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default
   * - true for indexed axis and timeseries axis
   * - false for category axis
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_x_tick_culling: {},

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․x․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 10
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_culling_max: 10,

  /**
   * The number of x axis ticks to show.<br><br>
   * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
   * @name axis․x․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_x_tick_count: undefined,

  /**
   * Show or hide x axis tick line.
   * @name axis․x․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_x_tick_show: !0,

  /**
   * Show or hide x axis tick text.
   * @name axis․x․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_show: !0,

  /**
   * Set the x Axis tick text's position relatively its original position
   * @name axis․x․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Fit x axis ticks.
   * - **true**: ticks will be positioned nicely to have same intervals.
   * - **false**: ticks will be positioned according to x value of the data points.
   * @name axis․x․tick․fit
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
   * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       fit: false
   *     }
   *   }
   * }
   */
  axis_x_tick_fit: !0,

  /**
   * Set the x values of ticks manually.<br><br>
   * If this option is provided, the position of the ticks will be determined based on those values.<br>
   * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.
   * @name axis․x․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       values: [1, 2, 4, 8, 16, 32, ...],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_values: null,

  /**
   * Rotate x axis tick text if there is not enough space for 'category' and 'timeseries' type axis.
   * - **NOTE:** The conditions where `autorotate` is enabled are:
   *   - axis.x.type='category' or 'timeseries
   *   - axis.x.tick.multiline=false
   *   - axis.x.tick.culling=false
   *   - axis.x.tick.fit=true
   * @name axis․x․tick․autorotate
   * @memberof Options
   * @type {boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickAutorotate)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 15,
   *       autorotate: true,
   *       multiline: false,
   *       culling: false,
   *       fit: true
   *     }
   *   }
   * }
   */
  axis_x_tick_autorotate: !1,

  /**
   * Rotate x axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.
   * - As long as `axis_x_tick_fit` is set to `true` it will calculate an overflow for the y2 axis and add this value to the right padding.
   * @name axis․x․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_x_tick_rotate: 0,

  /**
   * Show x axis outer tick.
   * @name axis․x․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_x_tick_outer: !0,

  /**
   * Set tick text to be multiline
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
   * @name axis․x․tick․multiline
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       multiline: false
   *     }
   *   }
   * }
   * @example
   * // example of line break with '\n'
   * // In this case, 'axis.x.tick.width' is ignored
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "long\ntext", "Another\nLong\nText"],
   *        ...
   *    ],
   * }
   */
  axis_x_tick_multiline: !0,

  /**
   * Set tick width
   * - **NOTE:**
   *  > When x tick text contains `\n`, this option is ignored.
   * @name axis․x․tick․width
   * @memberof Options
   * @type {number}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       width: 50
   *     }
   *   }
   * }
   */
  axis_x_tick_width: null,

  /**
   * Set to display system tooltip(via 'title' attribute) for tick text
   * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
   * @name axis․x․tick․tooltip
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       tooltip: true
   *     }
   *   }
   * }
   */
  axis_x_tick_tooltip: !1,

  /**
   * Set max value of x axis range.
   * @name axis․x․max
   * @memberof Options
   * @property {number} max Set the max value
   * @property {boolean} [max.fit=false] When specified `max.value` is greater than the bound data value, setting `true` will make x axis max to be fitted to the bound data max value.
   * - **NOTE:** If the bound data max value is greater than the `max.value`, the x axis max will be limited as the given `max.value`.
   * @property {number} [max.value] Set the max value
   * @example
   * axis: {
   *   x: {
   *     max: 100,
   *
   *     max: {
   *       // 'fit=true' will make x axis max to be limited as the bound data value max when 'max.value' is greater.
   *       // - when bound data max is '10' and max.value: '100' ==>  x axis max will be '10'
   *       // - when bound data max is '1000' and max.value: '100' ==> x axis max will be '100'
   *       fit: true,
   *       value: 100
   *     }
   *   }
   * }
   */
  axis_x_max: undefined,

  /**
   * Set min value of x axis range.
   * @name axis․x․min
   * @memberof Options
   * @property {number} min Set the min value
   * @property {boolean} [min.fit=false] When specified `min.value` is lower than the bound data value, setting `true` will make x axis min to be fitted to the bound data min value.
   * - **NOTE:** If the bound data min value is lower than the `min.value`, the x axis min will be limited as the given `min.value`.
   * @property {number} [min.value] Set the min value
   * @example
   * axis: {
   *   x: {
   *     min: -100,
   *
   *     min: {
   *       // 'fit=true' will make x axis min to be limited as the bound data value min when 'min.value' is lower.
   *       // - when bound data min is '-10' and min.value: '-100' ==>  x axis min will be '-10'
   *       // - when bound data min is '-1000' and min.value: '-100' ==> x axis min will be '-100'
   *       fit: true,
   *       value: -100
   *     }
   *   }
   * }
   */
  axis_x_min: undefined,

  /**
   * Set padding for x axis.<br><br>
   * If this option is set, the range of x axis will increase/decrease according to the values.
   * If no padding is needed in the rage of x axis, 0 should be set.
   * - **NOTE:**
   *   The padding values aren't based on pixels. It differs according axis types<br>
   *   - **category:** The unit of tick value
   *     ex. the given value `1`, is same as the width of 1 tick width
   *   - **timeseries:** Numeric time value
   *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
   * @name axis․x․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   x: {
   *     padding: {
   *       // when axis type is 'category'
   *       left: 1,  // set left padding width of equivalent value of a tick's width
   *       right: 0.5  // set right padding width as half of equivalent value of tick's width
   *
   *       // when axis type is 'timeseries'
   *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
   *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_x_padding: {},

  /**
   * Set height of x axis.<br><br>
   * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
   * @name axis․x․height
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     height: 20
   *   }
   * }
   */
  axis_x_height: undefined,

  /**
   * Set default extent for subchart and zoom. This can be an array or function that returns an array.
   * @name axis․x․extent
   * @memberof Options
   * @type {Array|Function}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     // extent range as a pixel value
   *     extent: [0, 200],
   *
   *     // when axis is 'timeseries', parsable datetime string
   *     extent: ["2019-03-01", "2019-03-05"],
   *
   *     // return extent value
   *     extent: function(domain, scale) {
   *    	 var extent = domain.map(function(v) {
   *     	    return scale(v);
   *     	 });
   *
   *   	 // it should return a format of array
   *   	 // ex) [0, 584]
   *     	 return extent;
   *     }
   *   }
   * }
   */
  axis_x_extent: undefined,

  /**
   * Set label on x axis.<br><br>
   * You can set x axis label and change its position by this option.
   * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
   * Available position differs according to the axis direction (vertical or horizontal).
   * If string set, the position will be the default.
   *
   *  - **If it's horizontal axis:**
   *    - inner-right [default]
   *    - inner-center
   *    - inner-left
   *    - outer-right
   *    - outer-center
   *    - outer-left
   *  - **If it's vertical axis:**
   *    - inner-top [default]
   *    - inner-middle
   *    - inner-bottom
   *    - outer-top
   *    - outer-middle
   *    - outer-bottom
   * @name axis․x․label
   * @memberof Options
   * @type {string|object}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     label: "Your X Axis"
   *   }
   * }
   *
   * axis: {
   *   x: {
   *     label: {
   *        text: "Your X Axis",
   *        position: "outer-center"
   *     }
   *   }
   * }
   */
  axis_x_label: {},

  /**
   * Set additional axes for x Axis.
   * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․x․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * x: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main x Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_x_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y Axis  config options
 */
/* harmony default export */ var axis_y = ({
  /**
   * Set clip-path attribute for y axis element
   * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.
   * @name axis․y․clipPath
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_y_clipPath: !0,

  /**
   * Show or hide y axis.
   * @name axis․y․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     show: false
   *   }
   * }
   */
  axis_y_show: !0,

  /**
   * Set type of y axis.<br><br>
   * **Available Values:**
   *   - timeseries
   *   - indexed
   * @name axis․y․type
   * @memberof Options
   * @type {string}
   * @default "indexed"
   * @example
   * axis: {
   *   y: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_y_type: undefined,

  /**
   * Set max value of y axis.
   * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․max
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     max: 1000
   *   }
   * }
   */
  axis_y_max: undefined,

  /**
   * Set min value of y axis.
   * - **NOTE:**
   *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․min
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     min: 1000
   *   }
   * }
   */
  axis_y_min: undefined,

  /**
   * Change the direction of y axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y․inverted
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inverted: true
   *   }
   * }
   */
  axis_y_inverted: !1,

  /**
   * Set center value of y axis.
   * @name axis․y․center
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     center: 0
   *   }
   * }
   */
  axis_y_center: undefined,

  /**
   * Show y axis inside of the chart.
   * @name axis․y․inner
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inner: true
   *   }
   * }
   */
  axis_y_inner: !1,

  /**
   * Set label on y axis.<br><br>
   * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y․label
   * @memberof Options
   * @type {string|object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y: {
   *     label: "Your Y Axis"
   *   }
   * }
   *
   * axis: {
   *   y: {
   *     label: {
   *        text: "Your Y Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y_label: {},

  /**
   * Set formatter for y axis tick text.<br><br>
   * This option accepts d3.format object as well as a function you define.
   * @name axis․y․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 5
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_culling_max: 5,

  /**
   * Show y axis outer tick.
   * @name axis․y․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y_tick_outer: !0,

  /**
   * Set y axis tick values manually.
   * @name axis․y․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_values: null,

  /**
   * Rotate y axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y_tick_rotate: 0,

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y_tick_count: undefined,

  /**
   * Show or hide y axis tick line.
   * @name axis․y․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.
   * @name axis․y․tick․stepSize
   * @memberof Options
   * @type {number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y_tick_stepSize: null,

  /**
   * Show or hide y axis tick text.
   * @name axis․y․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_show: !0,

  /**
   * Set the y Axis tick text's position relatively its original position
   * @name axis․y․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․time
   * @memberof Options
   * @private
   * @type {object}
   * @property {object} time time object
   * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       time: {
   *          // ticks at 15-minute intervals
   *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
   *          value: d3.timeMinute.every(15)
   *       }
   *     }
   *   }
   * }
   */
  // @TODO: not fully implemented yet
  axis_y_tick_time_value: undefined,

  /**
   * Set padding for y axis.<br><br>
   * You can set padding for y axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:**
   *   - Given values are translated relative to the y Axis domain value for padding
   *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axis․y․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   y: {
   *     padding: {
   *       top: 0,
   *       bottom: 0
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_y_padding: {},

  /**
   * Set default range of y axis.<br><br>
   * This option set the default value for y axis when there is no data on init.
   * @name axis․y․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y_default: undefined,

  /**
   * Set additional axes for y Axis.
   * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y2.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y2 Axis  config options
 */
/* harmony default export */ var axis_y2 = ({
  /**
   * Show or hide y2 axis.
   * - **NOTE**:
   *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
   *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
   * @name axis․y2․show
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     show: true
   *   }
   * }
   */
  axis_y2_show: !1,

  /**
   * Set max value of y2 axis.
   * @name axis․y2․max
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     max: 1000
   *   }
   * }
   */
  axis_y2_max: undefined,

  /**
   * Set min value of y2 axis.
   * @name axis․y2․min
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     min: -1000
   *   }
   * }
   */
  axis_y2_min: undefined,

  /**
   * Change the direction of y2 axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y2․inverted
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inverted: true
   *   }
   * }
   */
  axis_y2_inverted: !1,

  /**
   * Set center value of y2 axis.
   * @name axis․y2․center
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     center: 0
   *   }
   * }
   */
  axis_y2_center: undefined,

  /**
   * Show y2 axis inside of the chart.
   * @name axis․y2․inner
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inner: true
   *   }
   * }
   */
  axis_y2_inner: !1,

  /**
   * Set label on y2 axis.<br><br>
   * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y2․label
   * @memberof Options
   * @type {string|object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y2: {
   *     label: "Your Y2 Axis"
   *   }
   * }
   *
   * axis: {
   *   y2: {
   *     label: {
   *        text: "Your Y2 Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y2_label: {},

  /**
   * Set formatter for y2 axis tick text.<br><br>
   * This option works in the same way as axis.y.format.
   * @name axis․y2․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       format: d3.format("$,")
   *       //or format: function(d) { return "$" + d; }
   *     }
   *   }
   * }
   */
  axis_y2_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y2․tick․culling
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y2․tick․culling․max
   * @memberof Options
   * @type {number}
   * @default 5
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling_max: 5,

  /**
   * Show or hide y2 axis outer tick.
   * @name axis․y2․tick․outer
   * @memberof Options
   * @type {boolean}
   * @default true
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_outer: !0,

  /**
   * Set y2 axis tick values manually.
   * @name axis․y2․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_values: null,

  /**
   * Rotate y2 axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y2․tick․rotate
   * @memberof Options
   * @type {number}
   * @default 0
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y2_tick_rotate: 0,

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axis․y2․tick․count
   * @memberof Options
   * @type {number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y2_tick_count: undefined,

  /**
   * Show or hide y2 axis tick line.
   * @name axis․y2․tick․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.
   * @name axis․y2․tick․stepSize
   * @memberof Options
   * @type {number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y2_tick_stepSize: null,

  /**
   * Show or hide y2 axis tick text.
   * @name axis․y2․tick․text․show
   * @memberof Options
   * @type {boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_show: !0,

  /**
   * Set the y2 Axis tick text's position relatively its original position
   * @name axis․y2․tick․text․position
   * @memberof Options
   * @type {object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set padding for y2 axis.<br><br>
   * You can set padding for y2 axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:**
   *   - Given values are translated relative to the y2 Axis domain value for padding
   *   - For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axis․y2․padding
   * @memberof Options
   * @type {object|number}
   * @default {}
   * @example
   * axis: {
   *   y2: {
   *     padding: {
   *       top: 100,
   *       bottom: 100
   *     }
   *
   *     // or set both values at once.
   *     padding: 10
   * }
   */
  axis_y2_padding: {},

  /**
   * Set default range of y2 axis.<br><br>
   * This option set the default value for y2 axis when there is no data on init.
   * @name axis․y2․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y2_default: undefined,

  /**
   * Set additional axes for y2 Axis.
   * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y2․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y2: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y2 Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y2_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/axis.ts


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var source, i = 1; i < arguments.length; i++) source = arguments[i] == null ? {} : arguments[i], i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); return target; }

/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * y Axis  config options
 */

/* harmony default export */ var axis_axis = (_objectSpread(_objectSpread(_objectSpread({
  /**
   * Switch x and y axis position.
   * @name axis․rotated
   * @memberof Options
   * @type {boolean}
   * @default false
   * @example
   * axis: {
   *   rotated: true
   * }
   */
  axis_rotated: !1
}, axis_x), axis_y), axis_y2));
// CONCATENATED MODULE: ./src/config/Options/common/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * grid config options
 */
/* harmony default export */ var common_grid = ({
  /**
   * Set related options
   * @name grid
   * @memberof Options
   * @type {object}
   * @property {boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
   * @property {object} x Grid x object
   * @property {boolean} [x.show=false] Show grids along x axis.
   * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
   *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
   *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
   * @property {object} y Grid y object
   * @property {boolean} [y.show=false] Show grids along x axis.
   * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
   *  This option accepts array including object that has value, text, position and class.
   * @property {number} [y.ticks=10] Number of y grids to be shown.
   * @property {object} focus Grid focus object
   * @property {boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {boolean} [focus.show=true] Show grid line when focus.
   * @property {boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {object} lines Grid lines object
   * @property {boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
   * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
   * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
   * @example
   * grid: {
   *   x: {
   *     show: true,
   *     lines: [
   *       {value: 2, text: "Label on 2"},
   *       {value: 5, text: "Label on 5", class: "label-5"},
   *       {value: 6, text: "Label on 6", position: "start"}
   *     ]
   *   },
   *   y: {
   *     show: true,
   *     lines: [
   *       {value: 100, text: "Label on 100"},
   *       {value: 200, text: "Label on 200", class: "label-200"},
   *       {value: 300, text: "Label on 300", position: 'middle'}
   *     ],
   *     ticks: 5
   *   },
   *   front: true,
   *   focus: {
   *      show: false,
   *
   *      // Below options are available when 'tooltip.grouped=false' option is set
   *      edge: true,
   *      y: true
   *   },
   *   lines: {
   *      front: false
   *   }
   * }
   */
  grid_x_show: !1,
  grid_x_type: "tick",
  grid_x_lines: [],
  grid_y_show: !1,
  grid_y_lines: [],
  grid_y_ticks: 10,
  grid_focus_edge: !1,
  grid_focus_show: !0,
  grid_focus_y: !1,
  grid_front: !1,
  grid_lines_front: !0
});
// CONCATENATED MODULE: ./src/config/Options/common/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * point config options
 */
/* harmony default export */ var common_point = ({
  /**
   * Set point options
   * @name point
   * @memberof Options
   * @type {object}
   * @property {object} point Point object
   * @property {boolean} [point.show=true] Whether to show each point in line.
   * @property {number|Function} [point.r=2.5] The radius size of each point.
   *  - **NOTE:** Disabled for 'bubble' type
   * @property {boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
   * @property {number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
   *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
   * @property {boolean} [point.focus.only=false] Show point only when is focused.
   * @property {number} [point.sensitivity=10] The senstivity value for interaction boundary.
   * @property {number} [point.select.r=point.r*4] The radius size of each point on selected.
   * @property {string} [point.type="circle"] The type of point to be drawn
   * - **NOTE:**
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
   * - **NOTE:**
   *   - This is an `experimental` feature and can have some unexpected behaviors.
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   *   - svg shape tag interpreted as string<br>
   *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
   * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
   * @see [Demo: point focus only](https://naver.github.io/billboard.js/demo/#Point.FocusOnly)
   * @example
   *  point: {
   *      show: false,
   *      r: 5,
   *
   *      // or customize the radius
   *      r: function(d) {
   *          ...
   *          return r;
   *      },
   *
   *      focus: {
   *          expand: {
   *              enabled: true,
   *              r: 1
   *          },
   *          only: true
   *      },
   *      select: {
   *          r: 3
   *      },
   *
   *      // having lower value, means how closer to be for interaction
   *      sensitivity: 3,
   *
   *      // valid values are "circle" or "rectangle"
   *      type: "rectangle",
   *
   *      // or indicate as pattern
   *      pattern: [
   *        "circle",
   *        "rectangle",
   *        "<polygon points='0 6 4 0 -4 0'></polygon>"
   *     ],
   *  }
   */
  point_show: !0,
  point_r: 2.5,
  point_sensitivity: 10,
  point_focus_expand_enabled: !0,
  point_focus_expand_r: undefined,
  point_focus_only: !1,
  point_pattern: [],
  point_select_r: undefined,
  point_type: "circle"
});
// CONCATENATED MODULE: ./src/config/Options/common/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var common_subchart = ({
  /**
   * Set subchart options
   * @name subchart
   * @memberof Options
   * @type {object}
   * @property {object} subchart Subchart object
   * @property {boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
   * @property {boolean} [subchart.axis.x.show=true] Show or hide x axis.
   * @property {boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
   * @property {boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
   * @property {number} [subchart.size.height] Change the height of the subchart.
   * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
   *  Specified function receives the current zoomed x domain.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
   * @example
   *  subchart: {
   *      axis: {
   *      	x: {
   *      	  show: true,
   *      	    tick: {
   *      	      show: true,
   *      	      text: {
   *      	        show: false
   *      	      }
   *      	    }
   *      	}
   *      },
   *      show: true,
   *      size: {
   *          height: 20
   *      },
   *      onbrush: function(domain) { ... }
   *  }
   */
  subchart_show: !1,
  subchart_size_height: 60,
  subchart_axis_x_show: !0,
  subchart_axis_x_tick_show: !0,
  subchart_axis_x_tick_text_show: !0,
  subchart_onbrush: function subchart_onbrush() {}
});
// CONCATENATED MODULE: ./src/config/Options/common/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * zoom config options
 */
/* harmony default export */ var common_zoom = ({
  /**
   * Set zoom options
   * @name zoom
   * @memberof Options
   * @type {object}
   * @property {object} zoom Zoom object
   * @property {boolean} [zoom.enabled=false] Enable zooming.
   * @property {string} [zoom.enabled.type='wheel'] Set zoom interaction type.
   *  - **Available types:**
   *    - wheel
   *    - drag
   * @property {boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
   *  If true set, y domain will be updated according to the zoomed region.
   * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
   * @property {number|Date} [zoom.x.min] Set x Axis minimum zoom range
   * @property {number|Date} [zoom.x.max] Set x Axis maximum zoom range
   * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
   *  Specified function receives the zoom event.
   * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
   *  Specified function receives the zoomed domain.
   * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
   *  Specified function receives the zoomed domain.
   * @property {boolean|object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
   * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.
   * @property {string} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
   * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
   * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
   * @example
   *  zoom: {
   *      enabled: {
   *          type: "drag"
   *      },
   *      rescale: true,
   *      extent: [1, 100]  // enable more zooming
   *      x: {
   *          min: -1,  // set min range
   *          max: 10  // set max range
   *      },
   *      onzoomstart: function(event) { ... },
   *      onzoom: function(domain) { ... },
   *      onzoomend: function(domain) { ... },
   *
   *      // show reset button when is zoomed-in
   *      resetButton: true,
   *
   *      resetButton: {
   *          // onclick callback when reset button is clicked
   *          onclick: function(button) {
   *            button; // Reset button element reference
   *            ...
   *          },
   *
   *          // customized text value for reset zoom button
   *          text: "Unzoom"
   *      }
   *  }
   */
  zoom_enabled: undefined,
  zoom_extent: undefined,
  zoom_privileged: !1,
  zoom_rescale: !1,
  zoom_onzoom: undefined,
  zoom_onzoomstart: undefined,
  zoom_onzoomend: undefined,
  zoom_resetButton: !0,
  zoom_x_min: undefined,
  zoom_x_max: undefined
});
// CONCATENATED MODULE: ./src/config/Options/shape/area.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * area config options
 */
/* harmony default export */ var shape_area = ({
  /**
   * Set area options
   * @name area
   * @memberof Options
   * @type {object}
   * @property {object} area Area object
   * @property {boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
   * @property {boolean} [area.above=false] Set background area above the data chart line.
   * @property {boolean|object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
   * Or customize by giving below object value:
   *  - x {Array}: `x1`, `x2` value
   *  - y {Array}: `y1`, `y2` value
   *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
   * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
   * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
   * @example
   *  area: {
   *      zerobased: false,
   *      above: true,
   *
   *      // will generate follwing linearGradient:
   *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
   *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
   *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
   *      // </linearGradient>
   *      linearGradient: true,
   *
   *      // Or customized gradient
   *      linearGradient: {
   *      	x: [0, 0],  // x1, x2 attributes
   *      	y: [0, 0],  // y1, y2 attributes
   *      	stops: [
   *      	  // offset, stop-color, stop-opacity
   *      	  [0, "#7cb5ec", 1],
   *
   *      	  // setting 'null' for stop-color, will set its original data color
   *      	  [0.5, null, 0],
   *
   *      	  // setting 'function' for stop-color, will pass data id as argument.
   *      	  // It should return color string or null value
   *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
   *      	]
   *      }
   *  }
   */
  area_zerobased: !0,
  area_above: !1,
  area_linearGradient: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bar config options
 */
/* harmony default export */ var shape_bar = ({
  /**
   * Set bar options
   * @name bar
   * @memberof Options
   * @type {object}
   * @property {object} bar Bar object
   * @property {number} [bar.padding=0] The padding pixel value between each bar.
   * @property {number} [bar.radius] Set the radius of bar edge in pixel.
   * - **NOTE:** Works only for non-stacked bar
   * @property {number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
   * @property {number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
   * @property {number} [bar.width] Change the width of bar chart.
   * @property {number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
   * @property {number} [bar.width.max] The maximum width value for ratio.
   * @property {number} [bar.width.dataname] Change the width of bar for indicated dataset only.
   * - **NOTE:**
   *   - Works only for non-stacked bar
   *   - Bars are centered accoding its total width value
   * @property {number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
   * @property {number} [bar.width.dataname.max] The maximum width value for ratio.
   * @property {boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
   * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
   * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
   * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
   * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
   * @example
   *  bar: {
   *      padding: 1,
   *
   *      // the 'radius' option can be used only for non-stacking bars
   *      radius: 10,
   *      // or
   *      radius: {
   *          ratio: 0.5
   *      }
   *
   *      // will not have offset between each bar elements for interaction
   *      sensitivity: 0,
   *
   *      width: 10,
   *
   *      // or
   *      width: {
   *          ratio: 0.2,
   *          max: 20
   *      },
   *
   *      // or specify width per dataset
   *      width: {
   *          data1: 20,
   *          data2: {
   *              ratio: 0.2,
   *              max: 20
   *          }
   *      },
   *
   *      zerobased: false
   *  }
   */
  bar_padding: 0,
  bar_radius: undefined,
  bar_radius_ratio: undefined,
  bar_sensitivity: 2,
  bar_width: undefined,
  bar_width_ratio: .6,
  bar_width_max: undefined,
  bar_zerobased: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bubble config options
 */
/* harmony default export */ var bubble = ({
  /**
   * Set bubble options
   * @name bubble
   * @memberof Options
   * @type {object}
   * @property {object} bubble bubble object
   * @property {number|Function} [bubble.maxR=35] Set the max bubble radius value
   * @property {boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.
   * @example
   *  bubble: {
   *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
   *      // And the lesser will have radius relatively from tha max value.
   *      maxR: 50,
   *
   *      // or set radius callback
   *      maxR: function(d) {
   *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
   *          ...
   *          return Math.sqrt(d.value * 2);
   *      },
   *      zerobased: false
   *  }
   */
  bubble_maxR: 35,
  bubble_zerobased: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * line config options
 */
/* harmony default export */ var shape_line = ({
  /**
   * Set line options
   * @name line
   * @memberof Options
   * @type {object}
   * @property {object} line Line object
   * @property {boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
   *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
   * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
   * @property {boolean} [line.step.type=step] Change step type for step chart.<br>
   * **Available values:**
   * - step
   * - step-before
   * - step-after
   * @property {boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
   * @property {boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.
   * @example
   *  line: {
   *      connectNull: true,
   *      classes: [
   *          "line-class1",
   *          "line-class2"
   *      ],
   *      step: {
   *          type: "step-after"
   *      },
   *
   *      // hide all data points ('point.show=false' also has similar effect)
   *      point: false,
   *
   *      // show data points for only indicated datas
   *      point: [
   *          "data1", "data3"
   *      ],
   *
   *      zerobased: false
   *  }
   */
  line_connectNull: !1,
  line_step_type: "step",
  line_zerobased: !1,
  line_classes: undefined,
  line_point: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/spline.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var spline = ({
  /**
   * Set spline options
   * - **Available interpolation type values:**
   *  - basis (d3.curveBasis)
   *  - basis-closed (d3.curveBasisClosed)
   *  - basis-open (d3.curveBasisOpen)
   *  - bundle (d3.curveBundle)
   *  - cardinal (d3.curveCardinal)
   *  - cardinal-closed (d3.curveCardinalClosed)
   *  - cardinal-open (d3.curveCardinalOpen)
   *  - catmull-rom (d3.curveCatmullRom)
   *  - catmull-rom-closed (d3.curveCatmullRomClosed)
   *  - catmull-rom-open (d3.curveCatmullRomOpen)
   *  - monotone-x (d3.curveMonotoneX)
   *  - monotone-y (d3.curveMonotoneY)
   *  - natural (d3.curveNatural)
   *  - linear-closed (d3.curveLinearClosed)
   *  - linear (d3.curveLinear)
   *  - step (d3.curveStep)
   *  - step-after (d3.curveStepAfter)
   *  - step-before (d3.curveStepBefore)
   * @name spline
   * @memberof Options
   * @type {object}
   * @property {object} spline Spline object
   * @property {object} spline.interpolation Spline interpolation object
   * @property {string} [spline.interpolation.type="cardinal"] Interpolation type
   * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
   * @example
   *  spline: {
   *      interpolation: {
   *          type: "cardinal"
   *      }
   *  }
   */
  spline_interpolation_type: "cardinal"
});
// CONCATENATED MODULE: ./src/config/Options/shape/donut.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * donut config options
 */
/* harmony default export */ var donut = ({
  /**
   * Set donut options
   * @name donut
   * @memberof Options
   * @type {object}
   * @property {object} donut Donut object
   * @property {boolean} [donut.label.show=true] Show or hide label on each donut piece.
   * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
   * @property {number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
   * @property {boolean} [donut.expand=true] Enable or disable expanding donut pieces.
   * @property {number} [donut.expand.rate=0.98] Set expand rate.
   * @property {number} [donut.expand.duration=50] Set expand transition time in ms.
   * @property {number} [donut.width] Set width of donut chart.
   * @property {string} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
   * @property {number} [donut.padAngle=0] Set padding between data.
   * @property {number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  donut: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *          	...
   *          	return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      width: 10,
   *      padAngle: 0.2,
   *      startingAngle: 1,
   *      title: "Donut Title"
   *
   *      // title with line break
   *      title: "Title1\nTitle2"
   *  }
   */
  donut_label_show: !0,
  donut_label_format: undefined,
  donut_label_threshold: .05,
  donut_label_ratio: undefined,
  donut_width: undefined,
  donut_title: "",
  donut_expand: {},
  donut_expand_rate: .98,
  donut_expand_duration: 50,
  donut_padAngle: 0,
  donut_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/gauge.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * gauge config options
 */
/* harmony default export */ var gauge = ({
  /**
   * Set gauge options
   * @name gauge
   * @memberof Options
   * @type {object}
   * @property {object} gauge Gauge object
   * @property {boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
   * @property {boolean} [gauge.label.show=true] Show or hide label on gauge.
   * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
   * @property {Function} [gauge.label.extents] Set customized min/max label text.
   * @property {boolean} [gauge.expand=true] Enable or disable expanding gauge.
   * @property {number} [gauge.expand.rate=0.98] Set expand rate.
   * @property {number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
   * @property {number} [gauge.min=0] Set min value of the gauge.
   * @property {number} [gauge.max=100] Set max value of the gauge.
   * @property {number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.
   * @property {string} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
   * @property {string} [gauge.units] Set units of the gauge.
   * @property {number} [gauge.width] Set width of gauge chart.
   * @property {string} [gauge.type="single"] Set type of gauge to be displayed.<br><br>
   * **Available Values:**
   * - single
   * - multi
   * @property {string} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.
   * @example
   *  gauge: {
   *      fullCircle: false,
   *      label: {
   *          show: false,
   *          format: function(value, ratio) {
   *              return value;
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          extents: function(value, isMax) {
   *              return (isMax ? "Max:" : "Min:") + value;
   *          }
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      min: -100,
   *      max: 200,
   *      type: "single"  // or 'multi'
   *      title: "Title Text",
   *      units: "%",
   *      width: 10,
   *      arcs: {
   *          minWidth: 5
   *      }
   *  }
   */
  gauge_fullCircle: !1,
  gauge_label_show: !0,
  gauge_label_format: undefined,
  gauge_label_extents: undefined,
  gauge_min: 0,
  gauge_max: 100,
  gauge_type: "single",
  gauge_startingAngle: -1 * Math.PI / 2,
  gauge_title: "",
  gauge_units: undefined,
  gauge_width: undefined,
  gauge_arcs_minWidth: 5,
  gauge_expand: {},
  gauge_expand_rate: .98,
  gauge_expand_duration: 50
});
// CONCATENATED MODULE: ./src/config/Options/shape/pie.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var pie = ({
  /**
   * Set pie options
   * @name pie
   * @memberof Options
   * @type {object}
   * @property {object} pie Pie object
   * @property {boolean} [pie.label.show=true] Show or hide label on each pie piece.
   * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
   * @property {number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
   * @property {boolean|object} [pie.expand=true] Enable or disable expanding pie pieces.
   * @property {number} [pie.expand.rate=0.98] Set expand rate.
   * @property {number} [pie.expand.duration=50] Set expand transition time in ms.
   * @property {number|object} [pie.innerRadius=0] Sets the inner radius of pie arc.
   * @property {number} [pie.padAngle=0] Set padding between data.
   * @property {number} [pie.padding=0] Sets the gap between pie arcs.
   * @property {object} donut Donut object
   * @property {number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  pie: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *              ...
   *              return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      innerRadius: 0,
   *
   *      // set different innerRadius for each data
   *      innerRadius: {
   *      	data1: 10,
   *      	data2: 0
   *      }
   *
   *      padAngle: 0.1,
   *      padding: 0,
   *      startingAngle: 1
   *  }
   */
  pie_label_show: !0,
  pie_label_format: undefined,
  pie_label_threshold: .05,
  pie_label_ratio: undefined,
  pie_expand: {},
  pie_expand_rate: .98,
  pie_expand_duration: 50,
  pie_innerRadius: 0,
  pie_padAngle: 0,
  pie_padding: 0,
  pie_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var shape_radar = ({
  /**
   * Set radar options
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break.
   * @name radar
   * @memberof Options
   * @type {object}
   * @property {object} radar Radar object
   * @property {number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
   * @property {boolean} [radar.axis.line.show=true] Show or hide axis line.
   * @property {number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
   * @property {number} [radar.axis.text.position.y=0] y coordinate position, relative the original.
   * @property {boolean} [radar.axis.text.show=true] Show or hide axis text.
   * @property {boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
   * @property {number} [radar.level.depth=3] Set the level depth.
   * @property {boolean} [radar.level.show=true] Show or hide level.
   * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
   * @property {boolean} [radar.level.text.show=true] Show or hide level text.
   * @property {number} [radar.size.ratio=0.87] Set size ratio.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
   * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
   * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
   * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
   * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
   * @example
   *  radar: {
   *      axis: {
   *          max: 50,
   *          line: {
   *              show: false
   *          },
   *          text: {
   *              position: {
   *              	x: 0,
   *              	y: 0
   *              },
   *              show: false
   *          }
   *      },
   *      direction: {
   *          clockwise: true
   *      },
   *      level: {
   *          show: false,
   *          text: {
   *              format: function(x) {
   *                  return x + "%";
   *              },
   *              show: true
   *          }
   *      },
   *      size: {
   *          ratio: 0.7
   *      }
   *  }
   */
  radar_axis_max: undefined,
  radar_axis_line_show: !0,
  radar_axis_text_show: !0,
  radar_axis_text_position: {},
  radar_level_depth: 3,
  radar_level_show: !0,
  radar_level_text_format: function radar_level_text_format(x) {
    return x % 1 === 0 ? x : x.toFixed(2);
  },
  radar_level_text_show: !0,
  radar_size_ratio: .87,
  radar_direction_clockwise: !1
});
// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(38);

// CONCATENATED MODULE: ./src/module/browser.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @private
 */

/* eslint-disable no-new-func, no-undef */


var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    browser_doc = win && win.document;
/* eslint-enable no-new-func, no-undef */
// CONCATENATED MODULE: ./src/module/util.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */






var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isboolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof v === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return Array.isArray(arr);
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
};

/**
 * Get specified key value from object
 * If default value is given, will return if given key value not found
 * @param {object} options Source object
 * @param {string} key Key value
 * @param {*} defaultValue Default value
 * @returns {*}
 * @private
 */
function getOption(options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
}
/**
 * Check if value exist in the given object
 * @param {object} dict Target object to be checked
 * @param {*} value Value to be checked
 * @returns {boolean}
 * @private
 */


function hasValue(dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
}
/**
 * Call function with arguments
 * @param {Function} fn Function to be called
 * @param {*} args Arguments
 * @returns {boolean} true: fn is function, false: fn is not function
 * @private
 */


function callFn(fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
}
/**
 * Call function after all transitions ends
 * @param {d3.transition} transition Transition
 * @param {Fucntion} cb Callback function
 * @private
 */


function endall(transition, cb) {
  var n = 0;
  transition.each(function () {
    return ++n;
  }).on("end", function () {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];

    --n || cb.apply.apply(cb, [this].concat(args));
  });
}
/**
 * Replace tag sign to html entity
 * @param {string} str Target string value
 * @returns {string}
 * @private
 */


function sanitise(str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
}
/**
 * Set text value. If there's multiline add nodes.
 * @param {d3Selection} node Text node
 * @param {string} text Text value string
 * @param {Array} dy dy value for multilined text
 * @param {boolean} toMiddle To be alingned vertically middle
 * @private
 */


function setTextValue(node, text, dy, toMiddle) {
  if (dy === void 0 && (dy = [-1, 1]), toMiddle === void 0 && (toMiddle = !1), node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"),
          len = toMiddle ? multiline.length - 1 : 1;
      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", (i === 0 ? dy[0] * len : dy[1]) + "em").text(v);
      });
    }
  }
}
/**
 * Substitution of SVGPathSeg API polyfill
 * @param {SVGGraphicsElement} path Target svg element
 * @returns {Array}
 * @private
 */


function getRectSegList(path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height
  } // seg3
  ];
}
/**
 * Get svg bounding path box dimension
 * @param {SVGGraphicsElement} path Target svg element
 * @returns {object}
 * @private
 */


function getPathBox(path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Return brush selection array
 * @param {object} $el Selection object
 * @returns {d3.brushSelection}
 * @private
 */


function getBrushSelection(_ref) {
  var selection,
      $el = _ref.$el,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = $el.subchart.main || $el.main;
  return event && event.type === "brush" ? selection = event.selection : main && (selection = main.select("." + config_classes.brush).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
}
/**
 * Get boundingClientRect.
 * Cache the evaluated value once it was called.
 * @param {HTMLElement} node Target element
 * @returns {object}
 * @private
 */


var getBoundingRect = function (node) {
  return node.rect || (node.rect = node.getBoundingClientRect());
};
/**
 * Retrun random number
 * @param {boolean} asStr Convert returned value as string
 * @returns {number|string}
 * @private
 */


function getRandom(asStr) {
  asStr === void 0 && (asStr = !0);
  var rand = Math.random();
  return asStr ? rand + "" : rand;
}
/**
 * Check if brush is empty
 * @param {object} ctx Bursh context
 * @returns {boolean}
 * @private
 */


function brushEmpty(ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
}
/**
 * Extend target from source object
 * @param {object} target Target object
 * @param {object} source Source object
 * @returns {object}
 * @private
 */


function extend(target, source) {
  // exclude name with only numbers
  for (var p in target === void 0 && (target = {}), isArray(source) && source.forEach(function (v) {
    return extend(target, v);
  }), source) /^\d+$/.test(p) || p in target || (target[p] = source[p]);

  return target;
}
/**
 * Return first letter capitalized
 * @param {string} str Target string
 * @returns {string} capitalized string
 * @private
 */


var capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
};
/**
 * Convert to array
 * @param {object} v Target to be converted
 * @returns {Array}
 * @private
 */


/**
 * Get css rules for specified stylesheets
 * @param {Array} styleSheets The stylesheets to get the rules from
 * @returns {Array}
 * @private
 */
function getCssRules(styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from " + sheet.href + ": " + e.toString());
    }
  }), rules;
}
/**
 * Gets the SVGMatrix of an SVGGElement
 * @param {SVGElement} node Node element
 * @returns {SVGMatrix} matrix
 * @private
 */


var getTranslation = function (node) {
  var transform = node ? node.transform : null,
      baseVal = transform && transform.baseVal;
  return baseVal && baseVal.numberOfItems ? baseVal.getItem(0).matrix : {
    a: 0,
    b: 0,
    c: 0,
    d: 0,
    e: 0,
    f: 0
  };
};
/**
 * Get unique value from array
 * @param {Array} data Source data
 * @returns {Array} Unique array value
 * @private
 */


function getUnique(data) {
  var isDate = data[0] instanceof Date,
      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
  return isDate ? d.map(function (v) {
    return new Date(v);
  }) : d;
}
/**
 * Merge array
 * @param {Array} arr Source array
 * @returns {Array}
 * @private
 */


function mergeArray(arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
}
/**
 * Merge object returning new object
 * @param {object} target Target object
 * @param {object} objectN Source object
 * @returns {object} merged target object
 * @private
 */


function mergeObj(target) {
  for (var _len3 = arguments.length, objectN = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) objectN[_key3 - 1] = arguments[_key3];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}
/**
 * Sort value
 * @param {Array} data value to be sorted
 * @param {boolean} isAsc true: asc, false: desc
 * @returns {number|string|Date} sorted date
 * @private
 */


function util_sortValue(data, isAsc) {
  isAsc === void 0 && (isAsc = !0);
  var fn;
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
}
/**
 * Get min/max value
 * @param {string} type 'min' or 'max'
 * @param {Array} data Array data value
 * @returns {number|Date|undefined}
 * @private
 */


function getMinMax(type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, res) : res[0] instanceof Date && (res = util_sortValue(res, type === "min")[0]) : res = undefined, res;
}
/**
 * Get range
 * @param {number} start Start number
 * @param {number} end End number
 * @param {number} step Step number
 * @returns {Array}
 * @private
 */


var getRange = function (start, end, step) {
  step === void 0 && (step = 1);
  var res = [],
      n = Math.max(0, Math.ceil((end - start) / step)) | 0;

  for (var i = start; i < n; i++) res.push(start + i * step);

  return res;
},
    emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType, params) {
        params === void 0 && (params = getParams()), el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType, params) {
        params === void 0 && (params = getParams());
        var mouseEvent = browser_doc.createEvent("MouseEvent"); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent

        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, win, 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(mergeObj({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
}; // emulate event


/**
 * Process the template  & return bound string
 * @param {string} tpl Template string
 * @param {object} data Data value to be replaced
 * @returns {string}
 * @private
 */
function tplProcess(tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=" + x + "}", "g"), data[x]);

  return res;
}
/**
 * Get parsed date value
 * (It must be called in 'ChartInternal' context)
 * @param {Date|string|number} date Value of date to be parsed
 * @returns {Date}
 * @private
 */


function parseDate(date) {
  var parsedDate;
  if (date instanceof Date) parsedDate = date;else if (isString(date)) {
    var config = this.config,
        format = this.format;
    parsedDate = format.dataTime(config.data_xFormat)(date);
  } else isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date));
  return (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '" + date + "' to Date object"), parsedDate;
}
/**
 * Return if the current doc is visible or not
 * @returns {boolean}
 * @private
 */


function isTabVisible() {
  return !browser_doc.hidden;
}
/**
 * Get the current input type
 * @param {boolean} mouse Config value: interaction.inputType.mouse
 * @param {boolean} touch Config value: interaction.inputType.touch
 * @returns {string} "mouse" | "touch" | null
 * @private
 */


function convertInputType(mouse, touch) {
  var isMobile = !1; // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop

  if (/Mobi/.test(win.navigator.userAgent) && touch) {
    // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
    var hasTouchPoints = win.navigator && "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0,
        hasTouch = "ontouchmove" in win || win.DocumentTouch && browser_doc instanceof win.DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
    // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

    isMobile = hasTouchPoints || hasTouch;
  }

  var hasMouse = !(!mouse || isMobile) && "onmouseover" in win;
  return hasMouse && "mouse" || isMobile && "touch" || null;
}
// CONCATENATED MODULE: ./src/config/Options/Options.ts


function Options_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function Options_objectSpread(target) { for (var source, i = 1; i < arguments.length; i++) source = arguments[i] == null ? {} : arguments[i], i % 2 ? Options_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Options_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); return target; }

/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
// common






 // Axis based












 // Non-Axis based






/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */

var Options = function () {
  var config = [data_data, common_color, interaction, common_legend, common_title, common_tooltip].concat([donut, gauge, pie, shape_radar], [data_axis, data_selection, axis_axis, common_grid, common_point, common_subchart, common_zoom], [shape_area, shape_bar, bubble, shape_line, spline]);
  return mergeObj.apply(void 0, [Options_objectSpread({}, common_main)].concat(config));
};


// CONCATENATED MODULE: ./src/module/Cache.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Constant for cache key
 * - NOTE: Prefixed with '$', will be resetted when .load() is called
 * @private
 */
var KEY = {
  bubbleBaseLength: "$baseLength",
  colorPattern: "__colorPattern__",
  dataMinMax: "$dataMinMax",
  dataTotalSum: "$dataTotalSum",
  dataTotalPerIndex: "$totalPerIndex",
  legendItemTextBox: "legendItemTextBox",
  radarPoints: "$radarPoints",
  setOverOut: "setOverOut",
  callOverOutForTouch: "callOverOutForTouch",
  textRect: "textRect"
};

var Cache_Cache = /*#__PURE__*/function () {
  function Cache() {
    _defineProperty(this, "cache", {});
  }

  var _proto = Cache.prototype;
  return _proto.add =
  /**
   * Add cache
   * @param {string} key Cache key
   * @param {*} value Value to be stored
   * @param {boolean} isDataType Weather the cache is data typed '{id:'data', id_org: 'data', values: [{x:0, index:0,...}, ...]}'
   * @returns {*} Added data value
   * @private
   */
  function add(key, value, isDataType) {
    return isDataType === void 0 && (isDataType = !1), this.cache[key] = isDataType ? this.cloneTarget(value) : value, this.cache[key];
  }
  /**
   * Remove cache
   * @param {string|Array} key Cache key
   * @private
   */
  , _proto.remove = function remove(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  }
  /**
   * Get cahce
   * @param {string|Array} key Cache key
   * @param {boolean} isDataType Weather the cache is data typed '{id:'data', id_org: 'data', values: [{x:0, index:0,...}, ...]}'
   * @returns {*}
   * @private
   */
  , _proto.get = function get(key, isDataType) {
    if (isDataType === void 0 && (isDataType = !1), isDataType) {
      for (var id, targets = [], i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    var value = this.cache[key];
    return isValue(value) ? value : null;
  }
  /**
   * Reset cached data
   * @param {boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
   */
  , _proto.reset = function reset(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }
  /**
   * Clone data target object
   * @param {object} target Data object
   * @returns {object}
   * @private
   */
  // eslint-disable-next-line camelcase
  , _proto.cloneTarget = function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  }, Cache;
}();


// CONCATENATED MODULE: ./src/module/generator.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


var generator_setTimeout = win.setTimeout,
    generator_clearTimeout = win.clearTimeout;
/**
 * Generate resize queue function
 * @returns {Fucntion}
 * @private
 */

function generateResize() {
  var timeout,
      fn = [],
      callResizeFn = function () {
    callResizeFn.clear(), timeout = generator_setTimeout(function () {
      fn.forEach(function (f) {
        return f();
      });
    }, 200);
  };

  return callResizeFn.clear = function () {
    timeout && (generator_clearTimeout(timeout), timeout = null);
  }, callResizeFn.add = function (f) {
    return fn.push(f);
  }, callResizeFn.remove = function (f) {
    return fn.splice(fn.indexOf(f), 1);
  }, callResizeFn;
}
/**
 * Generate transition queue function
 * @returns {Function}
 * @private
 */

function generateWait() {
  var transitionsToWait = [],
      f = function (t, callback) {
    // eslint-disable-next-line
    function loop() {
      for (var _t, done = 0, i = 0; _t = transitionsToWait[i]; i++) {
        if (_t === !0 || _t.empty && _t.empty()) {
          done++;
          continue;
        }

        try {
          _t.transition();
        } catch (e) {
          done++;
        }
      }

      timer && generator_clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = generator_setTimeout(loop, 50);
    }

    var timer;
    loop();
  };

  return f.add = function (t) {
    isArray(t) ? transitionsToWait = transitionsToWait.concat(t) : transitionsToWait.push(t);
  }, f;
}
// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(39);

// CONCATENATED MODULE: ./src/ChartInternal/data/convert.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Data convert
 * @memberof ChartInternal
 * @private
 */

/* harmony default export */ var convert = ({
  /**
   * Convert data according its type
   * @param {object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @returns {object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_" + v;
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) this.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = this.convertJsonToData(data.json, data.keys);else if (data.rows) data = this.convertRowsToData(data.rows);else if (data.columns) data = this.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return isArray(data) && data;
  },

  /**
   * Convert URL data
   * @param {string} url Remote URL
   * @param {string} mimeType MIME type string: json | csv | tsv
   * @param {object} headers Header object
   * @param {object} keys Key object
   * @param {Function} done Callback function
   * @private
   */
  convertUrlToData: function convertUrlToData(url, mimeType, headers, keys, done) {
    var _this = this;

    mimeType === void 0 && (mimeType = "csv");
    var req = new XMLHttpRequest();
    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert" + capitalize(mimeType) + "ToData"](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error(url + ": Something went wrong loading!");
    }, req.send();
  },

  /**
   * Convert CSV/TSV data
   * @param {object} parser Parser object
   * @param {object} xsv Data
   * @private
   * @returns {object}
   */
  convertCsvTsvToData: function convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];
    return rows.forEach(function (row, i) {
      if (i > 0) {
        var newRow = {};
        row.forEach(function (v, j) {
          if (isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRow[keys[j]] = v;
        }), newRows.push(newRow);
      }
    }), newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];
    return columns.forEach(function (col, i) {
      var key = col[0];
      col.forEach(function (v, j) {
        if (j > 0) {
          if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRows[j - 1][key] = v;
        }
      });
    }), newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var _this3 = this,
        $$ = this,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        isCategorized = !1,
        isTimeSeries = !1,
        isCustomX = !1;

    axis && (isCategorized = axis.isCategorized(), isTimeSeries = axis.isTimeSeries(), isCustomX = axis.isCustomX());
    var xsData,
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];
    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      isCustomX || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"" + id + "\".");
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter.bind($$.api)(id),
          xKey = $$.getXKey(id),
          isCategory = isCustomX && isCategorized,
          hasCategory = isCategory && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +value, (isCategory || state.hasRadar) && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(value) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), state.hasNegativeValue = $$.hasNegativeValueInTargets(targets), state.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.cache.add(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_data_data = ({
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return !!(config.data_stack_normalize && config.data_groups.length);
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|number|string} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @returns {number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this,
        config = $$.config;
    Object.keys(xs).forEach(function (id) {
      config.data_xs[id] = xs[id];
    });
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this,
        config = $$.config;
    return data && (name = config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },

  /**
   * Get all values on given index
   * @param {number} index Index
   * @param {boolean} filterNull Filter nullish value
   * @returns {Array}
   * @private
   */
  getAllValuesOnIndex: function getAllValuesOnIndex(index, filterNull) {
    filterNull === void 0 && (filterNull = !1);
    var $$ = this,
        value = $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
    return filterNull && (value = value.filter(function (v) {
      return isValue(v.value);
    })), value;
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        axis = $$.axis,
        x = axis && axis.isCategorized() ? index : rawX || index;

    if (axis && axis.isTimeSeries()) {
      var fn = parseDate.bind($$);
      x = rawX ? fn(rawX) : fn($$.getXValue(id, index));
    } else axis && axis.isCustomX() && !axis.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index));

    return x;
  },
  updateXs: function updateXs(values) {
    values.length && (this.axis.xs = values.map(function (v) {
      return v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.axis.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.axis.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param {object} data Data object
   * @returns {number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        hasAxis = $$.state.hasAxis,
        value = data.value;
    return value && hasAxis && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @returns {{min: {number}, max: {number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(value)), max = Math.max.apply(Math, [i ? max : -Infinity].concat(value));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @returns {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = KEY.dataMinMax,
        minMaxData = $$.cache.get(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.cache.add(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @returns {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        cacheKey = KEY.dataTotalPerIndex,
        sum = $$.cache.get(cacheKey);
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @param {boolean} subtractHidden Subtract hidden data from total
   * @returns {number}
   * @private
   */
  getTotalDataSum: function getTotalDataSum(subtractHidden) {
    var $$ = this,
        cacheKey = KEY.dataTotalSum,
        total = $$.cache.get(cacheKey);

    if (!isNumber(total)) {
      var sum = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.cache.add(cacheKey, total = sum);
    }

    return subtractHidden && (total -= $$.getHiddenTotalDataSum()), total;
  },

  /**
   * Get total hidden data sum
   * @returns {number}
   * @private
   */
  getHiddenTotalDataSum: function getHiddenTotalDataSum() {
    var $$ = this,
        api = $$.api,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        total = 0;
    return hiddenTargetIds.length && (total = api.data.values.bind(api)(hiddenTargetIds).reduce(function (p, c) {
      return p + c;
    })), total;
  },

  /**
   * Get filtered data by value
   * @param {object} data Data
   * @param {number} value Value to be filtered
   * @returns {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @returns {number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, this.data.targets.map(function (t) {
      return t.values.length;
    }));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget() {
    var target = this.filterTargetsToShow() || [],
        length = target.length;
    return length > 1 ? (target = target.map(function (t) {
      return t.values;
    }).reduce(function (a, b) {
      return a.concat(b);
    }).map(function (v) {
      return v.x;
    }), target = util_sortValue(getUnique(target)).map(function (x, index) {
      return {
        x: x,
        index: index
      };
    })) : length && (target = target[0].values), target;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.state.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.state.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        axis = $$.axis,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = axis && axis.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), util_sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        hasAxis = $$.state.hasAxis,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, value) : isObject(value) && "high" in value ? data.push.apply(data, Object.values(value)) : $$.isBubbleZType(v) ? data.push(hasAxis && $$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue Target value
   * @returns {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = [].concat(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();
    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order.bind($$.api)), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isboolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.$el.chart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        data = values.filter(function (v) {
      return v && isValue(v.value);
    }),
        minDist = config.point_sensitivity;
    return data.filter(function (v) {
      return $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = main.select("." + config_classes.bars + $$.getTargetSelectorSuffix(v.id) + " ." + config_classes.bar + "-" + v.index).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), data.filter(function (v) {
      return !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        scale = $$.scale,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = (scale.zoom || scale.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @returns {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = !!axis && axis.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length - 1, value = converted[x].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_" + name];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {string} type Ratio for given type
   * @param {object} d Data value object
   * @param {boolean} asPercent Convert the return as percent or not
   * @returns {number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        api = $$.api,
        ratio = 0;
    if (d && api.data.shown().length) if (ratio = d.ratio || d.value, type === "arc") ratio = $$.pie.padAngle()() ? d.value / $$.getTotalDataSum(!0) : (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));else if (type === "index") {
      var dataValues = api.data.values.bind(api),
          total = this.getTotalPerIndex();

      if (state.hiddenTargetIds.length) {
        var hiddenSum = dataValues(state.hiddenTargetIds, !1);
        hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
          return acc.map(function (v, i) {
            return (isNumber(v) ? v : 0) + curr[i];
          });
        }), total = total.map(function (v, i) {
          return v - hiddenSum[i];
        }));
      }

      d.ratio = isNumber(d.value) && total && total[d.index] > 0 ? d.value / total[d.index] : 0, ratio = d.ratio;
    } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0) + "") / state.current.dataMax * config.radar_size_ratio);
    return asPercent && ratio ? ratio * 100 : ratio;
  },

  /**
   * Sort data index to be aligned with x axis.
   * @param {Array} tickValues Tick array values
   * @private
   */
  updateDataIndexByX: function updateDataIndexByX(tickValues) {
    var $$ = this,
        tickValueMap = tickValues.reduce(function (out, tick, index) {
      return out[+tick.x] = index, out;
    }, {});
    $$.data.targets.forEach(function (t) {
      t.values.forEach(function (value, valueIndex) {
        var index = tickValueMap[+value.x];
        index === undefined && (index = valueIndex), value.index = index;
      });
    });
  },

  /**
   * Determine if bubble has dimension data
   * @param {object|Array} d data value
   * @returns {boolean}
   * @private
   */
  isBubbleZType: function isBubbleZType(d) {
    var $$ = this;
    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var load = ({
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    // Update current state chart type and elements list after redraw
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), $$.updateTypesElements(), args.done && args.done.call($$.api);
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.cache.reset();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      data && $$.load($$.convertDataToTargets(data), args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        state = $$.state,
        $el = $$.$el,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.cache.reset(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ( // Update current state chart type and elements list after redraw
    $el.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call(endall, done), targetIds.forEach(function (id) {
      state.withoutFadeIn[id] = !1, $el.legend && $el.legend.selectAll("." + config_classes.legendItem + $$.getTargetSelectorSuffix(id)).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    }), $$.updateTypesElements()) : void done();
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(40);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var interactions_interaction = ({
  /**
   * Handle data.onover/out callback options
   * @param {boolean} isOver Over or not
   * @param {number|object} d data object
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        hasRadar = $$.state.hasRadar,
        main = $$.$el.main,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      if (config.color_onover && $$.setOverColor(isOver, d, isArc), isArc) callback(d, main.select("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).node());else if (!config.tooltip_grouped) {
        var last = $$.cache.get(KEY.setOverOut) || [],
            shape = main.selectAll("." + config_classes.shape + "-" + d).filter(function (d) {
          return $$.isWithinShape(this, d);
        });
        shape.each(function (d) {
          var _this = this;

          (last.length === 0 || last.every(function (v) {
            return v !== _this;
          })) && (callback(d, this), last.push(this));
        }), last.length > 0 && shape.empty() && (callback = config.data_onout.bind($$.api), last.forEach(function (v) {
          return callback(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(v).datum(), v);
        }), last = []), $$.cache.add(KEY.setOverOut, last);
      } else isOver && (config.point_focus_only && hasRadar ? $$.showCircleFocus($$.getAllValuesOnIndex(d, !0)) : $$.expandCirclesBars(d, null, !0)), $$.isMultipleX() || main.selectAll("." + config_classes.shape + "-" + d).each(function (d) {
        callback(d, this);
      });
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {number|object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        last = $$.cache.get(KEY.callOverOutForTouch);
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), $$.cache.add(KEY.callOverOutForTouch, d));
  },

  /**
   * Return draggable selection function
   * @returns {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      // @ts-ignore
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      // @ts-ignore
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {string} type event type
   * @param {number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        hasRadar = $$.state.hasRadar,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        radar = _$$$$el.radar,
        isMultipleX = $$.isMultipleX(),
        selector = hasRadar ? "." + config_classes.axis + "-" + index + " text" : "." + (isMultipleX ? config_classes.eventRect : config_classes.eventRect + "-" + index),
        eventRect = (hasRadar ? radar.axes : main).select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX || $$.config.axis_rotated ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/class.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_class = ({
  generateClass: function generateClass(prefix, targetId) {
    return " " + prefix + " " + (prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return this.generateClass(config_classes.region, i) + " " + ("class" in d ? d.class : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " " + config_classes.target + "-" + additionalClassSuffix), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " " + (this.state.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " " + (this.state.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? ("-" + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    var pfx = prefix || "",
        target = this.getTargetSelectorSuffix(id);
    // select target & circle
    return pfx + "." + (config_classes.target + target) + ", " + pfx + "." + (config_classes.circles + target);
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var _this = this,
        ids = idsValue || [];

    return ids.length ? ids.map(function (id) {
      return _this.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return "." + (config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var _this2 = this;

    return ids && ids.length ? ids.map(function (id) {
      return _this2.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var category = ({
  /**
   * Category Name
   * @param {number} i Index number
   * @returns {string} category Name
   * @private
   */
  categoryName: function categoryName(i) {
    var categories = this.config.axis_x_categories;
    return i < categories.length ? categories[i] : i;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(41);

// CONCATENATED MODULE: ./src/ChartInternal/internals/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {string} color Color string
 * @param {string} id ID to be set
 * @returns {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


/* harmony default export */ var internals_color = ({
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @returns {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var cacheKey = KEY.colorPattern,
        body = browser_doc.body,
        pattern = body[cacheKey];

    if (!pattern) {
      var span = browser_doc.createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = win.getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body[cacheKey] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles.bind($$.api)(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = $$.state.datetimeId + "-pattern-" + color + "-" + index;
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#" + p.id + ")";
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id].bind($$.api)(d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback.bind($$.api)(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restate in its previous color value
   * @param {boolean} isOver true: set overed color, false: restore
   * @param {number|object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (_ref) {
      var id = _ref.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) ? color = function () {
      return onover;
    } : isFunction(onover) && (color = color.bind($$.api)), isObject(d) ? main.selectAll("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).style("fill", color(d)) : main.selectAll("." + config_classes.shape + "-" + d).style("fill", color);
  }
});
// CONCATENATED MODULE: ./src/config/const.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Chart type constant
 * @private
 */
var TYPE = {
  AREA: "area",
  AREA_LINE_RANGE: "area-line-range",
  AREA_SPLINE: "area-spline",
  AREA_SPLINE_RANGE: "area-spline-range",
  AREA_STEP: "area-step",
  BAR: "bar",
  BUBBLE: "bubble",
  DONUT: "donut",
  GAUGE: "gauge",
  LINE: "line",
  PIE: "pie",
  RADAR: "radar",
  SCATTER: "scatter",
  SPLINE: "spline",
  STEP: "step"
};
/**
 * chart types by category
 * @private
 */

var TYPE_BY_CATEGORY = {
  Area: [TYPE.AREA, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE, TYPE.AREA_STEP],
  AreaRange: [TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE],
  Arc: [TYPE.PIE, TYPE.DONUT, TYPE.GAUGE, TYPE.RADAR],
  Line: [TYPE.LINE, TYPE.SPLINE, TYPE.AREA, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE, TYPE.AREA_LINE_RANGE, TYPE.STEP, TYPE.AREA_STEP],
  Step: [TYPE.STEP, TYPE.AREA_STEP],
  Spline: [TYPE.SPLINE, TYPE.AREA_SPLINE, TYPE.AREA_SPLINE_RANGE]
};
// CONCATENATED MODULE: ./src/ChartInternal/internals/domain.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_domain = ({
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has" + (isMin ? "Negative" : "Positive") + "ValueInTargets"](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },

  /**
   * Check if hidden targets bound to the given axis id
   * @param {string} id ID to be checked
   * @returns {boolean}
   * @private
   */
  isHiddenTargetWithYDomain: function isHiddenTargetWithYDomain(id) {
    var $$ = this;
    return $$.state.hiddenTargetIds.some(function (v) {
      return $$.axis.getId(v) === id;
    });
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        scale = $$.scale,
        pfx = "axis_" + axisId;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;
    if (yTargets.length === 0) // use domain of the other axis if target of axisId is none
      return $$.isHiddenTargetWithYDomain(axisId) ? scale[axisId].domain() : axisId === "y2" ? scale.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.
      // So, it needs to call to get y2 domain here
      $$.getYDomain(targets, "y2", xDomain);
    var yMin = config[pfx + "_min"],
        yMax = config[pfx + "_max"],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config[pfx + "_center"],
        isZeroBased = [TYPE.BAR, TYPE.BUBBLE, TYPE.SCATTER].concat(TYPE_BY_CATEGORY.Line).some(function (v) {
      var type = v.indexOf("area") > -1 ? "area" : v;
      return $$.hasType(v, yTargets) && config[type + "_zerobased"];
    }),
        isInverted = config[pfx + "_inverted"],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain(scale.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    } // if padding is set, the domain will be updated relative the current domain value
    // ex) $$.height=300, padding.top=150, domainLength=4  --> domain=6


    var p = config[pfx + "_padding"];
    notEmpty(p) && ["bottom", "top"].forEach(function (v) {
      padding[v] = axis.getPadding(p, v, padding[v], domainLength);
    }), isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        configValue = $$.config["axis_x_" + type],
        dataValue = getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    })),
        value = isObject(configValue) ? configValue.value : configValue;
    return value = isDefined(value) && $$.axis.isTimeSeries() ? parseDate(value) : value, isObject(configValue) && configValue.fit && (type === "min" && value < dataValue || type === "max" && value > dataValue) && (value = undefined), isDefined(value) ? value : dataValue;
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        axis = $$.axis,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    axis.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        isCategorized = $$.axis.isCategorized(),
        isTimeSeries = $$.axis.isTimeSeries(),
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        padding = $$.getXDomainPadding(xDomain),
        _xDomain = xDomain,
        firstX = _xDomain[0],
        lastX = _xDomain[1],
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || isCategorized || (isTimeSeries ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = isTimeSeries ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = isTimeSeries ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        subX = _$$$scale.subX,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && (x.domain(domain || util_sortValue($$.getXDomain(targets))), org.xDomain = x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), subX.domain(x.domain()), $$.brush && $$.brush.scale(subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? org.xDomain : getBrushSelection($$).map(subX.invert);
      x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && x.domain($$.trimXDomain(x.orgDomain())), x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        min = zoomDomain[0],
        max = zoomDomain[1];
    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/format.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get formatted
 * @param {object} $$ Context
 * @param {string} typeValue Axis type
 * @param {number} v Value to be formatted
 * @returns {number | string}
 * @private
 */
function getFormat($$, typeValue, v) {
  var config = $$.config,
      type = "axis_" + typeValue + "_tick_format",
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
}

/* harmony default export */ var internals_format = ({
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        yFormat = $$.yFormat,
        y2Format = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (yFormat = $$.defaultArcValueFormat, y2Format = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis && $$.axis.getId(id) === "y2" ? y2Format : yFormat;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return (ratio * 100).toFixed(1) + "%";
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format.bind($$.api);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var internals_legend = ({
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.legendItemTextBox = {}, $$.state.legendHasRendered = !1, config.legend_show ? (!config.legend_contents_bindto && ($el.legend = $$.$el.svg.append("g").classed(config_classes.legend, !0).attr("transform", $$.getTranslate("legend"))), $$.updateLegend()) : $$.state.hiddenLegendIds = $$.mapToIds($$.data.targets);
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        scale = $$.scale,
        $el = $$.$el,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !scale.zoom), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), state.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.bind($$.api)(v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $el.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @param {Obejct} size Size object
   * @private
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        isLegendTop = _$$$state.isLegendTop,
        isLegendLeft = _$$$state.isLegendLeft,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        current = _$$$state.current,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : current.height - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : current.width - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.state.margin3 = {
      top: isLegendRight ? 0 : isLegendInset ? insetLegendPosition.top : current.height - height,
      right: NaN,
      bottom: 0,
      left: isLegendRight ? current.width - width : isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @param {boolean} withTransition whether or not to transition.
   * @private
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this,
        legend = $$.$el.legend;
    (withTransition ? legend.transition() : legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @param {number} step Step value
   * @private
   */
  updateLegendStep: function updateLegendStep(step) {
    this.state.legendStep = step;
  },

  /**
   * Update legend item width
   * @param {number} width Width value
   * @private
   */
  updateLegendItemWidth: function updateLegendItemWidth(width) {
    this.state.legendItemWidth = width;
  },

  /**
   * Update legend item height
   * @param {number} height Height value
   * @private
   */
  updateLegendItemHeight: function updateLegendItemHeight(height) {
    this.state.legendItemHeight = height;
  },

  /**
   * Update legend item color
   * @param {string} id Corresponding data ID value
   * @param {string} color Color value
   * @private
   */
  updateLegendItemColor: function updateLegendItemColor(id, color) {
    this.$el.legend.select("." + config_classes.legendItem + "-" + id + " line").style("stroke", color);
  },

  /**
   * Get the width of the legend
   * @returns {number} width
   * @private
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this,
        _$$$state2 = $$.state,
        width = _$$$state2.current.width,
        isLegendRight = _$$$state2.isLegendRight,
        isLegendInset = _$$$state2.isLegendInset,
        legendItemWidth = _$$$state2.legendItemWidth,
        legendStep = _$$$state2.legendStep;
    return $$.config.legend_show ? isLegendRight || isLegendInset ? legendItemWidth * (legendStep + 1) : width : 0;
  },

  /**
   * Get the height of the legend
   * @returns {number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this,
        _$$$state3 = $$.state,
        current = _$$$state3.current,
        isLegendRight = _$$$state3.isLegendRight,
        legendItemHeight = _$$$state3.legendItemHeight,
        legendStep = _$$$state3.legendStep;
    return $$.config.legend_show ? isLegendRight ? current.height : Math.max(20, legendItemHeight) * (legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @param {d3.selection} legendItem Legend item node
   * @returns {string|null} opacity
   * @private
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @param {d3.selection} legendItem Legend item node
   * @returns {string|null} opacity
   * @private
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @param {Array} targetIds ID's of target
   * @param {boolean} focus whether or not to focus.
   * @private
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        legend = $$.$el.legend,
        targetIdz = $$.mapToTargetIds(targetIds);
    legend && legend.selectAll("." + config_classes.legendItem).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this,
        legend = $$.$el.legend;
    legend && legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @param {Array} targetIds ID's of target
   * @private
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    config.legend_show || (config.legend_show = !0, $el.legend ? $el.legend.style("visibility", "visible") : $$.initLegend(), !$$.state.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), $el.legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @param {Array} targetIds ID's of target
   * @private
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Get legend item textbox dimension
   * @param {string} id Data ID
   * @param {HTMLElement|d3.selection} textElement Text node element
   * @returns {object} Bounding rect
   * @private
   */
  getLegendItemTextBox: function getLegendItemTextBox(id, textElement) {
    var data,
        $$ = this,
        cache = $$.cache,
        cacheKey = KEY.legendItemTextBox;
    return id && (data = cache.get(cacheKey) || {}, !data[id] && (data[id] = $$.getTextRect(textElement, config_classes.legendItem), cache.add(cacheKey, data)), data = data[id]), data;
  },

  /**
   * Set legend item style & bind events
   * @param {d3.selection} item Item node
   * @private
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        hasGauge = $$.hasType("gauge");
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, api, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? (api.hide(), api.show(id)) : (api.toggle(id), !isTouch && $$.isTargetToShow(id) ? api.focus(id) : api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, api, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), hasGauge && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, api, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), hasGauge && $$.markOverlapped(id, $$, "." + config_classes.gaugeValue), !state.transiting && $$.isTargetToShow(id) && api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = state.isLegendRight || state.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = $$.getLegendItemTextBox(id, textElement),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = state.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    state.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), state.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : state.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        l = legend.selectAll("." + config_classes.legendItem).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#" + state.datetimeId + "-point-" + data : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = legend.select("." + config_classes.legendBackground + " rect"), state.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = legend.insert("g", "." + config_classes.legendItem).attr("class", config_classes.legendBackground).append("rect"));
    var texts = legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = legend.selectAll("rect." + config_classes.legendItemEvent).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = legend.selectAll("." + config_classes.legendItemPoint).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = legend.selectAll("line." + config_classes.legendItemTile).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.levelColor ? function (id) {
        return $$.levelColor($$.cache.get(id).values[0].value);
      } : $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(42);

// CONCATENATED MODULE: ./src/ChartInternal/internals/redraw.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_redraw = ({
  redraw: function redraw(options, transitionsValue) {
    options === void 0 && (options = {});
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        main = $el.main,
        targetsToShow = $$.filterTargetsToShow($$.data.targets),
        initializing = options.initializing,
        flow = options.flow,
        wth = $$.getWithOption(options),
        duration = wth.Transition ? config.transition_duration : 0,
        durationForExit = wth.TransitionForExit ? duration : 0,
        durationForAxis = wth.TransitionForAxis ? duration : 0,
        transitions = transitionsValue || $$.axis && $$.axis.generateTransitions(durationForAxis);
    // text
    // title
    $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.hasDataLabel() && $$.updateText(durationForExit), (!$$.hasArcType() || state.hasRadar) && $$.updateCircleY && $$.updateCircleY(), !state.resizing && ($$.hasPointType() || state.hasRadar) && $$.updateCircle(), state.hasAxis ? ($$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), config.data_empty_label_text && main.select("text." + config_classes.text + "." + config_classes.empty).attr("x", state.width / 2).attr("y", state.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.hasGrid() && $$.updateGrid(duration), config.regions.length && $$.updateRegion(duration), $$.hasType("bar") && $$.updateBar(durationForExit), $$.hasTypeOf("Line") && $$.updateLine(durationForExit), $$.hasTypeOf("Area") && $$.updateArea(durationForExit), $el.text && main.selectAll("." + config_classes.selectedCircles).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && $$.bindZoomEvent()) : ($el.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $el.radar && $$.redrawRadar(durationForExit)), $$.redrawTitle && $$.redrawTitle(), initializing && $$.updateTypesElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
  },

  /**
   * Generate redraw list
   * @param {object} targets targets data to be shown
   * @param {object} flow flow object
   * @param {number} duration duration value
   * @param {boolean} withSubchart whether or not to show subchart
   * @private
   */
  generateRedrawList: function generateRedrawList(targets, flow, duration, withSubchart) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        shape = $$.getDrawShape();
    state.hasAxis && config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
    // generate flow
    var flowFn = flow && $$.generateFlow({
      targets: targets,
      flow: flow,
      duration: flow.duration,
      shape: shape,
      xv: $$.xv.bind($$)
    }),
        isTransition = (duration || flowFn) && isTabVisible(),
        redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
        afterRedraw = flow || config.onrendered ? function () {
      flowFn && flowFn(), callFn(config.onrendered, $$.api);
    } : null;
    if (afterRedraw) // Only use transition when current tab is visible.
      if (isTransition && redrawList.length) {
        // Wait for end of transitions for callback
        var waitForDraw = generateWait(); // transition should be derived from one transition

        Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
          redrawList.reduce(function (acc, t1) {
            return acc.concat(t1);
          }, []).forEach(function (t) {
            return waitForDraw.add(t);
          });
        }).call(waitForDraw, afterRedraw);
      } else state.transiting || afterRedraw(); // update fadein condition

    $$.mapToIds($$.data.targets).forEach(function (id) {
      state.withoutFadeIn[id] = !0;
    });
  },
  getRedrawList: function getRedrawList(shape, flow, flowFn, isTransition) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        hasAxis = _$$$state.hasAxis,
        hasRadar = _$$$state.hasRadar,
        grid = $$.$el.grid,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        list = [];

    if (hasAxis) {
      var _shape$type = shape.type,
          area = _shape$type.area,
          bar = _shape$type.bar,
          line = _shape$type.line;
      (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition)), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), !flow && grid.main && list.push($$.updateGridFocus());
    }

    return (!$$.hasArcType() || hasRadar) && notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition)), ($$.hasPointType() || hasRadar) && !config.point_focus_only && $$.redrawCircle && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
  },
  updateAndRedraw: function updateAndRedraw(options) {
    options === void 0 && (options = {});
    var transitions,
        $$ = this,
        config = $$.config,
        state = $$.state;
    // same with redraw
    // NOT same with redraw
    // Draw with new sizes & scales
    options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (state.hasAxis && (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0)), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
  },
  redrawWithoutRescale: function redrawWithoutRescale() {
    this.redraw({
      withY: !1,
      withSubchart: !1,
      withEventRect: !1,
      withTransitionForAxis: !1
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/scale.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_scale = ({
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {number} min Min value
   * @param {number} max Max value
   * @param {Array} domain Domain value
   * @param {Function} offset The offset getter to be sum
   * @returns {Function} scale
   * @private
   */
  getXScale: function getXScale(min, max, domain, offset) {
    var $$ = this,
        scale = $$.scale.zoom || $$.getScale(min, max, $$.axis.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {number} min Min value
   * @param {number} max Max value
   * @param {Array} domain Domain value
   * @returns {Function} Scale function
   * @private
   */
  getYScale: function getYScale(min, max, domain) {
    var $$ = this,
        scale = $$.getScale(min, max, $$.axis.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get y Axis scale
   * @param {string} id Axis id
   * @param {boolean} isSub Weather is sub Axis
   * @returns {Function} Scale function
   * @private
   */
  getYScaleById: function getYScaleById(id, isSub) {
    isSub === void 0 && (isSub = !1);
    var isY2 = this.axis.getId(id) === "y2",
        key = isSub ? isY2 ? "subY2" : "subY" : isY2 ? "y2" : "y";
    return this.scale[key];
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue Scale function
   * @param {Function} offsetValue Offset getter to be sum
   * @returns {Function} Scale function
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.axis.x.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.axis.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },

  /**
   * Update scale
   * @param {boolean} isInit Param is given at the init rendering
   * @param {boolean} updateXDomain If update x domain
   * @private
   */
  updateScales: function updateScales(isInit, updateXDomain) {
    updateXDomain === void 0 && (updateXDomain = !0);
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        format = $$.format,
        org = $$.org,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        width2 = _$$$state.width2,
        height2 = _$$$state.height2,
        hasAxis = _$$$state.hasAxis;

    if (hasAxis) {
      var isRotated = config.axis_rotated,
          min = {
        x: isRotated ? 1 : 0,
        y: isRotated ? 0 : height,
        subX: isRotated ? 1 : 0,
        subY: isRotated ? 0 : height2
      },
          max = {
        x: isRotated ? height : width,
        y: isRotated ? width : 1,
        subX: isRotated ? height : width,
        subY: isRotated ? width2 : 1
      },
          xDomain = updateXDomain && scale.x && scale.x.orgDomain(),
          xSubDomain = updateXDomain && org.xDomain; // update edges

      // y Axis
      scale.x = $$.getXScale(min.x, max.x, xDomain, function () {
        return axis.x.tickOffset();
      }), scale.subX = $$.getXScale(min.x, max.x, xSubDomain, function (d) {
        return d % 1 ? 0 : axis.subX.tickOffset();
      }), format.xAxisTick = axis.getXAxisTickFormat(), axis.setAxis("x", scale.x, config.axis_x_tick_outer, isInit), config.subchart_show && axis.setAxis("subX", scale.subX, config.axis_x_tick_outer, isInit), scale.y = $$.getYScale(min.y, max.y, scale.y ? scale.y.domain() : config.axis_y_default), scale.subY = $$.getYScale(min.subY, max.subY, scale.subY ? scale.subY.domain() : config.axis_y_default), axis.setAxis("y", scale.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && (scale.y2 = $$.getYScale(min.y, max.y, scale.y2 ? scale.y2.domain() : config.axis_y2_default), scale.subY2 = $$.getYScale(min.subY, max.subY, scale.subY2 ? scale.subY2.domain() : config.axis_y2_default), axis.setAxis("y2", scale.y2, config.axis_y2_tick_outer, isInit));
    } else // update for arc
    $$.updateArc && $$.updateArc();
  },

  /**
   * Get the zoom or unzoomed scaled value
   * @param {Date|number|object} d Data value
   * @returns {number|null}
   * @private
   */
  xx: function xx(d) {
    var $$ = this,
        config = $$.config,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom,
        fn = config.zoom_enabled && zoom ? zoom : x;
    return d ? fn(isValue(d.x) ? d.x : d) : null;
  },
  xv: function xv(d) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        x = $$.scale.x,
        value = $$.getBaseValue(d);
    return axis.isTimeSeries() ? value = parseDate.call($$, value) : axis.isCategorized() && isString(value) && (value = config.axis_x_categories.indexOf(value)), Math.ceil(x(value));
  },
  yv: function yv(d) {
    var $$ = this,
        _$$$scale2 = $$.scale,
        y = _$$$scale2.y,
        y2 = _$$$scale2.y2,
        yScale = d.axis && d.axis === "y2" ? y2 : y;
    return Math.ceil(yScale($$.getBaseValue(d)));
  },
  subxx: function subxx(d) {
    return d ? this.scale.subX(d.x) : null;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(43);

// CONCATENATED MODULE: ./src/ChartInternal/shape/shape.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var shape_shape = ({
  /**
   * Get the shape draw function
   * @returns {object}
   * @private
   */
  getDrawShape: function getDrawShape() {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        hasRadar = $$.state.hasRadar,
        shape = {
      type: {},
      indices: {},
      pos: {}
    };

    // setup drawer - MEMO: these must be called after axis updated
    if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
      var indices = $$.getShapeIndices($$.isLineType);

      if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
        var _indices = $$.getShapeIndices($$.isAreaType);

        shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
      }
    }

    if ($$.hasType("bar")) {
      var _indices2 = $$.getShapeIndices($$.isBarType);

      shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
    }

    if (!$$.hasArcType() || hasRadar) {
      // generate circle x/y functions depending on updated params
      var cx = hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX,
          cy = hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY;
      shape.pos = {
        xForText: $$.generateXYForText(shape.indices, !0),
        yForText: $$.generateXYForText(shape.indices, !1),
        cx: (cx || function () {}).bind($$),
        cy: (cy || function () {}).bind($$)
      };
    }

    return shape;
  },
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        xs = config.data_xs,
        hasXs = notEmpty(xs),
        indices = {},
        i = hasXs ? {} : 0;
    return hasXs && getUnique(Object.keys(xs).map(function (v) {
      return xs[v];
    })).forEach(function (v) {
      i[v] = 0, indices[v] = {};
    }), $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, xKey = (d.id in xs) ? xs[d.id] : "", ind = xKey ? indices[xKey] : indices, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in ind) {
        ind[d.id] = ind[_row4];
        break;
      }

      isUndefined(ind[d.id]) && (ind[d.id] = xKey ? i[xKey]++ : i++, ind.__max__ = (xKey ? i[xKey] : i) - 1);
    }), indices;
  },

  /**
   * Get indices value based on data ID value
   * @param {object} indices Indices object
   * @param {string} id Data id value
   * @returns {object} Indices object
   * @private
   */
  getIndices: function getIndices(indices, id) {
    var xs = this.config.data_xs;
    return notEmpty(xs) ? indices[xs[id]] : indices;
  },

  /**
   * Get indices max number
   * @param {object} indices Indices object
   * @returns {number} Max number
   * @private
   */
  getIndicesMax: function getIndicesMax(indices) {
    return notEmpty(this.config.data_xs) ? // if is multiple xs, return total sum of xs' __max__ value
    Object.keys(indices).map(function (v) {
      return indices[v].__max__ || 0;
    }).reduce(function (acc, curr) {
      return acc + curr;
    }) : indices.__max__;
  },
  getShapeX: function getShapeX(offset, indices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        currScale = isSub ? scale.subX : scale.zoom || scale.x,
        barPadding = config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var ind = $$.getIndices(indices, d.id),
          index = d.id in ind ? ind[d.id] : 0,
          targetsNum = (ind.__max__ || 0) + 1,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = currScale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
      return $$.getYScaleById(d.id, isSub)(value);
    };
  },

  /**
   * Get shape based y Axis min value
   * @param {string} id Data id
   * @returns {number}
   * @private
   */
  getShapeYMin: function getShapeYMin(id) {
    var $$ = this,
        _$$$scale$$$$axis$get = $$.scale[$$.axis.getId(id)].domain(),
        yMin = _$$$scale$$$$axis$get[0];

    return !$$.isGrouped(id) && yMin > 0 ? yMin : 0;
  },

  /**
   * Get Shape's offset data
   * @param {Function} typeFilter Type filter function
   * @returns {object}
   * @private
   */
  getShapeOffsetData: function getShapeOffsetData(typeFilter) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        isStackNormalized = $$.isStackNormalized(),
        shapeOffsetTargets = targets.map(function (target) {
      var rowValues = target.values,
          values = {};
      $$.isStepType(target) && (rowValues = $$.convertValuesToStep(rowValues));
      var rowValueMapByXValue = rowValues.reduce(function (out, d) {
        var key = +d.x;
        return out[key] = d, values[key] = isStackNormalized ? $$.getRatio("index", d, !0) : d.value, out;
      }, {});
      return {
        id: target.id,
        rowValues: rowValues,
        rowValueMapByXValue: rowValueMapByXValue,
        values: values
      };
    }),
        indexMapByTargetId = targets.reduce(function (out, _ref, index) {
      var id = _ref.id;
      return out[id] = index, out;
    }, {});
    return {
      indexMapByTargetId: indexMapByTargetId,
      shapeOffsetTargets: shapeOffsetTargets
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        _$$$getShapeOffsetDat = $$.getShapeOffsetData(typeFilter),
        shapeOffsetTargets = _$$$getShapeOffsetDat.shapeOffsetTargets,
        indexMapByTargetId = _$$$getShapeOffsetDat.indexMapByTargetId;

    return function (d, idx) {
      var ind = $$.getIndices(indices, d.id),
          scale = $$.getYScaleById(d.id, isSub),
          y0 = scale($$.getShapeYMin(d.id)),
          dataXAsNumber = +d.x,
          offset = y0;
      return shapeOffsetTargets.filter(function (t) {
        return t.id !== d.id;
      }).forEach(function (t) {
        if (ind[t.id] === ind[d.id] && indexMapByTargetId[t.id] < indexMapByTargetId[d.id]) {
          var row = t.rowValues[idx]; // check if the x values line up

          row && +row.x === dataXAsNumber || (row = t.rowValueMapByXValue[dataXAsNumber]), row && row.value * d.value >= 0 && (offset += scale(t.values[dataXAsNumber]) - y0);
        }
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScaleById(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        config = $$.config,
        type = config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? config.line_step_type : "linear";
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/size.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_size = ({
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this,
        state = $$.state;
    state.current.width = $$.getCurrentWidth(), state.current.height = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $el.title && $el.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_" + axisId + "_axes"].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_" + axisId + "_axes"].length,
        axisWidth = hasAxis ? $$.getAxisWidthByAxisId(axisId, withoutRecompute) : 0;
    return padding = isValue(config.padding_left) ? config.padding_left : hasAxis && isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : hasAxis && (!config.axis_y_show || config.axis_y_inner) ? $$.axis.getAxisLabelPosition("y").isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight(withoutTickTextOverflow) {
    withoutTickTextOverflow === void 0 && (withoutTickTextOverflow = !1);
    var padding,
        $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        defaultPadding = 10,
        legendWidthOnRight = $$.state.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = hasAxis ? $$.getAxisWidthByAxisId("y2") : 0,
        xAxisTickTextOverflow = withoutTickTextOverflow ? 0 : $$.axis.getXAxisTickTextY2Overflow(defaultPadding);
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : $$.axis && config.axis_rotated ? defaultPadding + legendWidthOnRight : $$.axis && (!config.axis_y2_show || config.axis_y2_inner) ? Math.max(2 + legendWidthOnRight + ($$.axis.getAxisLabelPosition("y2").isOuter ? 20 : 0), xAxisTickTextOverflow) : Math.max(ceil10(axisWidth) + legendWidthOnRight, xAxisTickTextOverflow), padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {string} key property/attribute name
   * @returns {number}
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset" + capitalize(key), parent = this.$el.chart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser_doc.body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.$el.chart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $el.main.select("." + leftAxisClass).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $el.chart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  updateDimension: function updateDimension(withoutAxis) {
    var $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        $el = $$.$el;
    // pass 'withoutAxis' param to not animate at the init rendering
    hasAxis && !withoutAxis && ($$.axis.x && config.axis_rotated ? ($$.axis.x.create($el.axis.x), $$.axis.subX && $$.axis.subX.create($el.axis.subX)) : ($$.axis.y && $$.axis.y.create($el.axis.y), $$.axis.y2 && $$.axis.y2.create($el.axis.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
  },
  updateSvgSize: function updateSvgSize() {
    var $$ = this,
        state = $$.state,
        svg = $$.$el.svg;

    if (svg.attr("width", state.current.width).attr("height", state.current.height), state.hasAxis) {
      var brush = svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), svg.selectAll(["#" + state.clip.id, "#" + state.clip.idGrid]).select("rect").attr("width", state.width).attr("height", state.height), svg.select("#" + state.clip.idXAxis).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), svg.select("#" + state.clip.idYAxis).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), state.clip.idSubchart && svg.select("#" + state.clip.idSubchart).select("rect").attr("width", state.width).attr("height", brushSize.height), svg.select("." + config_classes.zoomRect).attr("width", state.width).attr("height", state.height);
    }
  },

  /**
   * Update size values
   * @param {boolean} isInit If is called at initialization
   * @private
   */
  updateSizes: function updateSizes(isInit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        isRotated = config.axis_rotated,
        hasArc = $$.hasArcType();
    isInit || $$.setContainerSize();
    var currLegend = {
      width: legend ? $$.getLegendWidth() : 0,
      height: legend ? $$.getLegendHeight() : 0
    },
        legendHeightForBottom = state.isLegendRight || state.isLegendInset ? 0 : currLegend.height,
        xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
        subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
        subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
    // for main
    // for subchart
    // for legend
    // for arc
    state.margin = isRotated ? {
      top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
    } : {
      top: 4 + $$.getCurrentPaddingTop(),
      // for top tick text
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: hasArc ? 0 : $$.getCurrentPaddingLeft()
    }, state.margin2 = isRotated ? {
      top: state.margin.top,
      right: NaN,
      bottom: 20 + legendHeightForBottom,
      left: $$.state.rotatedPadding.left
    } : {
      top: state.current.height - subchartHeight - legendHeightForBottom,
      right: NaN,
      bottom: subchartXAxisHeight + legendHeightForBottom,
      left: state.margin.left
    }, state.margin3 = {
      top: 0,
      right: NaN,
      bottom: 0,
      left: 0
    }, $$.updateSizeForLegend && $$.updateSizeForLegend(currLegend), state.width = state.current.width - state.margin.left - state.margin.right, state.height = state.current.height - state.margin.top - state.margin.bottom, state.width < 0 && (state.width = 0), state.height < 0 && (state.height = 0), state.width2 = isRotated ? state.margin.left - state.rotatedPadding.left - state.rotatedPadding.right : state.width, state.height2 = isRotated ? state.height : state.current.height - state.margin2.top - state.margin2.bottom, state.width2 < 0 && (state.width2 = 0), state.height2 < 0 && (state.height2 = 0), state.arcWidth = state.width - (state.isLegendRight ? currLegend.width + 10 : 0), state.arcHeight = state.height - (state.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && (state.arcHeight += state.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), state.isLegendRight && hasArc && (state.margin3.left = state.arcWidth / 2 + state.radiusExpanded * 1.1), !hasArc && config.axis_x_show && config.axis_x_tick_autorotate && $$.updateXAxisTickClip();
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/text.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_text = ({
  opacityForText: function opacityForText() {
    return this.hasDataLabel() ? "1" : "0";
  },

  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $el = this.$el;
    $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartTexts);
  },

  /**
   * Update chartText
   * @param {object} targets $$.data.targets
   * @private
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.$el.main.select("." + config_classes.chartTexts).selectAll("." + config_classes.chartText).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").style("opacity", "0").attr("class", classChartText).style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $el.text = $el.main.selectAll("." + config_classes.texts).selectAll("." + config_classes.text).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $el.text.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $el.text = $el.text.enter().append("text").merge($$.$el.text).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {boolean} forFlow Weather is flow
   * @param {boolean} withTransition transition is enabled
   * @returns {Array}
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    // need to return 'true' as of being pushed to the redraw list
    // ref: getRedrawList()
    return $$.$el.text.each(function (d, i) {
      var _this2 = this,
          text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x.bind(this)(d, i)).attr("y", function (d) {
        return y.bind(_this2)(d, i);
      }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    }), !0;
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @param {HTMLElement|d3.selection} element Target element
   * @param {string} className Class name
   * @returns {object} value of element.getBoundingClientRect()
   * @private
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = KEY.textRect + "-" + text.replace(/\W/g, "_"),
        rect = $$.cache.get(cacheKey);
    return rect || ($$.$el.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = getBoundingRect(v.node());
    }).remove(), $$.cache.add(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {object} indices Indices values
   * @param {boolean} forX whether or not to x
   * @returns {number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet" + capitalize(v) + "Points"](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @param {object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} Position value
   * @private
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = getBoundingRect(textElement),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Get data.labels.position value
   * @param {string} id Data id value
   * @param {string} type x | y
   * @returns {number} Position value
   * @private
   */
  getTextPos: function getTextPos(id, type) {
    var pos = this.config.data_labels_position;
    return (id in pos ? pos[id] : pos)[type] || 0;
  },

  /**
   * Gets the x coordinate of the text
   * @param {object} points Data points position
   * @param {object} d Data object
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} x coordinate
   * @private
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated;
    // show labels regardless of the domain if value is null
    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > state.width) {
      var _getBoundingRect = getBoundingRect(textElement),
          width = _getBoundingRect.width;

      xPos = state.width - width;
    } else xPos < 0 && (xPos = 4);
    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + $$.getTextPos(d.id, "x");
  },

  /**
   * Gets the y coordinate of the text
   * @param {object} points Data points position
   * @param {object} d Data object
   * @param {HTMLElement} textElement Data label text element
   * @returns {number} y coordinate
   * @private
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = getBoundingRect(textElement),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !state.hasPositiveValue && state.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > state.height && (yPos = state.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + $$.getTextPos(d.id, "y");
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Mark overlapping text nodes with "text-overlapping" class
   * @param {string} id Axis id
   * @param {ChartInternal} $$ ChartInternal context
   * @param {string} selector Selector string
   * @private
   */
  markOverlapped: function markOverlapped(id, $$, selector) {
    var textNodes = $$.$el.arcs.selectAll(selector),
        filteredTextNodes = textNodes.filter(function (node) {
      return node.data.id !== id;
    }),
        textNode = textNodes.filter(function (node) {
      return node.data.id === id;
    }),
        translate = getTranslation(textNode.node()),
        calcHypo = function (x, y) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    textNode.node() && filteredTextNodes.each(function () {
      var coordinate = getTranslation(this),
          filteredTextNode = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          nodeForWidth = calcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ? textNode : filteredTextNode,
          overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) < Math.ceil(nodeForWidth.node().getComputedTextLength()),
          overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) < parseInt(textNode.style("font-size"), 0);
      filteredTextNode.classed(config_classes.TextOverlapping, overlapsX && overlapsY);
    });
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Remove "text-overlapping" class on selected text nodes
   * @param {ChartInternal} $$ ChartInternal context
   * @param {string} selector Selector string
   * @private
   */
  undoMarkOverlapped: function undoMarkOverlapped($$, selector) {
    $$.$el.arcs.selectAll(selector).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([this, this.previousSibling]).classed(config_classes.TextOverlapping, !1);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get the text position
 * @param {string} pos right, left or center
 * @param {number} width chart width
 * @returns {string|number} text-anchor value or position in pixel
 * @private
 */

function getTextPos(pos, width) {
  pos === void 0 && (pos = "left");
  var position,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
}

/* harmony default export */ var internals_title = ({
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.title_text) {
      $el.title = $el.svg.append("g");
      var text = $el.title.append("text").style("text-anchor", getTextPos(config.title_position)).attr("class", config_classes.title);
      setTextValue(text, config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        title = $$.$el.title;

    if (title) {
      var y = $$.yForTitle.call($$);
      /g/i.test(title.node().tagName) ? title.attr("transform", "translate(" + getTextPos(config.title_position, current.width) + ", " + y + ")") : title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @returns {number} x attribute value
   * @private
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        current = $$.state.current,
        position = config.title_position || "left",
        textRectWidth = $$.getTextRect($$.$el.title, config_classes.title).width;
    return /(right|center)/.test(position) ? (x = current.width - textRectWidth, position.indexOf("right") >= 0 ? x = current.width - textRectWidth - config.title_padding.right : position.indexOf("center") >= 0 && (x = (current.width - textRectWidth) / 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @returns {number} y attribute value
   * @private
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.$el.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @returns {number} padding value
   * @private
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_tooltip = ({
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($el.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $el.tooltip.empty() && ($el.tooltip = $el.chart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.axis.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = parseDate.call($$, config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $el.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $el.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }

    $$.bindTooltipResizePos();
  },

  /**
   * Get the tooltip HTML string
   * @param  {Array} args Arguments
   * @returns {string} Formatted HTML string
   * @private
   */
  getTooltipHTML: function getTooltipHTML() {
    var $$ = this,
        api = $$.api,
        config = $$.config;
    return isFunction(config.tooltip_contents) ? config.tooltip_contents.bind(api).apply(void 0, arguments) : $$.getTooltipContent.apply($$, arguments);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {string} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        _map = ["title", "name", "value"].map(function (v) {
      var fn = config["tooltip_format_" + v];
      return isFunction(fn) ? fn.bind(api) : fn;
    }),
        titleFormat = _map[0],
        nameFormat = _map[1],
        valueFormat = _map[2];

    titleFormat = titleFormat || defaultTitleFormat, nameFormat = nameFormat || function (name) {
      return name;
    }, valueFormat = valueFormat || ($$.isStackNormalized() ? function (v, ratio) {
      return (ratio * 100).toFixed(2) + "%";
    } : defaultValueFormat);

    var order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.axis && $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template,
        targetIds = $$.mapToTargetIds();

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order.bind(api));

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr),
        len = d.length;

    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">" + title + "</th></tr>" : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(param))), $$.isAreaRangeType(row)) {
        var _map2 = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(param)));
        }),
            high = _map2[0],
            low = _map2[1];

        value = "<b>Mid:</b> " + value + " <b>High:</b> " + high + " <b>Low:</b> " + low;
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(param))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:" + color + "\" width=\"10\" height=\"10\"></rect></svg>",
            NAME: name,
            VALUE: value
          };

          if (tplStr && isObject(contents.text)) {
            var index = targetIds.indexOf(row.id);
            Object.keys(contents.text).forEach(function (key) {
              contentValue[key] = contents.text[key][index];
            });
          }

          text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return text + "</table>";
  },

  /**
   * Get the content template string
   * @param {string} tplStr Tempalte string
   * @returns {Array} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">" + (this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>") + "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>").replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {object} dataToShow data
   * @param {string} tWidth Width value of tooltip element
   * @param {string} tHeight Height value of tooltip element
   * @param {HTMLElement} element Tooltip element
   * @returns {object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        current = _$$$state.current,
        isLegendRight = _$$$state.isLegendRight,
        inputType = _$$$state.inputType,
        hasGauge = $$.hasType("gauge") && !config.gauge_fullCircle,
        svgLeft = $$.getSvgLeft(!0),
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        left = _d3Mouse[0],
        top = _d3Mouse[1],
        chartRight = svgLeft + current.width - $$.getCurrentPaddingRight(!0),
        chartLeft = $$.getCurrentPaddingLeft(!0),
        size = 20;

    // Determine tooltip position
    if (top += size, $$.hasArcType()) {
      var raw = inputType === "touch" || $$.hasType("radar");
      raw || (top += hasGauge ? height : height / 2, left += (width - (isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = scale.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + size, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + chartLeft + size + ($$.zoomScale ? left : dataScale));
    } // when tooltip left + tWidth > chart's width


    left + tWidth + 15 > chartRight && (left -= tWidth + chartLeft), top + tHeight > current.height && (top -= hasGauge ? tHeight * 3 : tHeight + 30);
    var pos = {
      top: top,
      left: left
    }; // make sure to not be positioned out of viewport

    return Object.keys(pos).forEach(function (v) {
      pos[v] < 0 && (pos[v] = 0);
    }), pos;
  },

  /**
   * Show the tooltip
   * @param {object} selectedData Data object
   * @param {HTMLElement} element Tooltip element
   * @private
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        tooltip = $$.$el.tooltip,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = tooltip.datum(),
          _ref = datum || {},
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 0 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 0 : _ref$height,
          dataStr = JSON.stringify(selectedData);

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$.api, selectedData), tooltip.html($$.getTooltipHTML(selectedData, // data
        $$.axis ? $$.axis.getXAxisTickFormat() : $$.categoryName.bind($$), // defaultTitleFormat
        $$.getYFormat(forArc), // defaultValueFormat
        $$.color // color
        )).style("display", null).style("visibility", null) // for IE9
        .datum(datum = {
          index: index,
          current: dataStr,
          width: width = tooltip.property("offsetWidth"),
          height: height = tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$.api, selectedData), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        var fnPos = config.tooltip_position || $$.tooltipPosition,
            pos = fnPos.call(this, dataToShow, width, height, element); // Get tooltip dimensions

        ["top", "left"].forEach(function (v) {
          var value = pos[v];
          tooltip.style(v, value + "px"), v !== "left" || datum.xPosInPercent || (datum.xPosInPercent = value / state.current.width * 100);
        });
      }
    }
  },

  /**
   * Adjust tooltip position on resize event
   * @private
   */
  bindTooltipResizePos: function bindTooltipResizePos() {
    var $$ = this,
        resizeFunction = $$.resizeFunction,
        state = $$.state,
        tooltip = $$.$el.tooltip;
    resizeFunction.add(function () {
      if (tooltip.style("display") === "block") {
        var current = state.current,
            _tooltip$datum = tooltip.datum(),
            width = _tooltip$datum.width,
            xPosInPercent = _tooltip$datum.xPosInPercent,
            _value = current.width / 100 * xPosInPercent,
            diff = current.width - (_value + width);

        diff < 0 && (_value += diff), tooltip.style("left", _value + "px");
      }
    });
  },

  /**
   * Hide the tooltip
   * @param {boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        api = $$.api,
        config = $$.config,
        tooltip = $$.$el.tooltip;

    if (tooltip.style("display") !== "none" && (!config.tooltip_doNotHide || force)) {
      var selectedData = JSON.parse(tooltip.datum().current);
      // hide tooltip
      callFn(config.tooltip_onhide, api, selectedData), tooltip.style("display", "none").style("visibility", "hidden") // for IE9
      .datum(null), callFn(config.tooltip_onhidden, api, selectedData);
    }
  },

  /**
   * Toggle display for linked chart instances
   * @param {boolean} show true: show, false: hide
   * @param {number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this,
        charts = $$.charts,
        config = $$.config;

    if (config.tooltip_linked && charts.length > 1) {
      var linkedName = config.tooltip_linked_name;
      charts.forEach(function (c) {
        if (c !== $$.api) {
          var _c$internal = c.internal,
              _config = _c$internal.config,
              $el = _c$internal.$el,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser_doc.body.contains($el.chart.node());

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.$el.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/transform.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_transform = ({
  getTranslate: function getTranslate(target, index) {
    index === void 0 && (index = 0);
    var x,
        y,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        hasGauge = $$.hasType("gauge"),
        padding = 0;
    if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel(state.margin.left), y = asHalfPixel(state.margin.top);else if (target === "context") x = asHalfPixel(state.margin2.left), y = asHalfPixel(state.margin2.top);else if (target === "legend") x = state.margin3.left, y = state.margin3.top + (hasGauge ? 10 : 0);else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : state.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? state.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : state.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subX") x = 0, y = isRotated ? 0 : state.height2;else if (target === "arc") x = state.arcWidth / 2, y = state.arcHeight / 2;else if (target === "radar") {
      var _$$$getRadarSize = $$.getRadarSize(),
          width = _$$$getRadarSize[0];

      x = state.width / 2 - width, y = asHalfPixel(state.margin.top);
    }
    return "translate(" + x + ", " + y + ")";
  },
  transformMain: function transformMain(withTransition, transitions) {
    var xAxis,
        yAxis,
        y2Axis,
        $$ = this,
        main = $$.$el.main;
    transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = main.select("." + config_classes.axisX), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = main.select("." + config_classes.axisY), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = main.select("." + config_classes.axisY2), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? main.transition() : main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), main.select("." + config_classes.chartArcs).attr("transform", $$.getTranslate("arc"));
  },
  transformAll: function transformAll(withTransition, transitions) {
    var $$ = this,
        config = $$.config,
        hasAxis = $$.state.hasAxis,
        $el = $$.$el;
    $$.transformMain(withTransition, transitions), hasAxis && config.subchart_show && $$.transformContext(withTransition, transitions), $el.legend && $$.transformLegend(withTransition);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/type.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_type = ({
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config,
        withoutFadeIn = $$.state.withoutFadeIn;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },

  /**
   * Updte current used chart types
   * @private
   */
  updateTypesElements: function updateTypesElements() {
    var $$ = this,
        current = $$.state.current;
    // Update current chart elements reference
    Object.keys(TYPE).forEach(function (v) {
      var t = TYPE[v],
          has = $$.hasType(t, null, !0),
          idx = current.types.indexOf(t);
      idx === -1 && has ? current.types.push(t) : idx > -1 && !has && current.types.splice(idx, 1);
    }), $$.setChartElements();
  },

  /**
   * Check if given chart types exists
   * @param {string} type Chart type
   * @param {Array} targetsValue Data array
   * @param {boolean} checkFromData Force to check type cotains from data targets
   * @returns {boolean}
   * @private
   */
  hasType: function hasType(type, targetsValue, checkFromData) {
    checkFromData === void 0 && (checkFromData = !1);
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        types = config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return !checkFromData && current.types.length && current.types.indexOf(type) > -1 ? has = !0 : targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      t !== type && (t || type !== "line") || (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @param {string} type Type key
   * @param {object} targets Target data
   * @param {Array} exclude Excluded types
   * @returns {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets, exclude) {
    var _this = this;

    // 실제 노드 존재 여부도 확인필요
    return exclude === void 0 && (exclude = []), !TYPE_BY_CATEGORY[type] // @ts-ignore
    .filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {object} d Data object
   * @param {string|Array} type chart type
   * @returns {boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },
  hasPointType: function hasPointType() {
    var $$ = this;
    return $$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter");
  },

  /**
   * Check if contains arc types chart
   * @param {object} targets Target data
   * @param {Array} exclude Excluded types
   * @returns {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  hasMultiArcGauge: function hasMultiArcGauge() {
    return this.hasType("gauge") && this.config.gauge_type === "multi";
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPE_BY_CATEGORY.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPE_BY_CATEGORY.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint(node) {
    var config = this.config,
        pattern = config.point_pattern,
        isCircle = !1;
    return isCircle = !!(node && node.tagName === "circle") || config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0), isCircle;
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {object} d Data object
   * @returns {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/ChartInternal.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */








 // data



 // interactions

 // internals


 // used to retrieve radar Axis name














/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */

var ChartInternal_ChartInternal = /*#__PURE__*/function () {
  // API interface
  // config object
  // cache instance
  // elements
  // state variables
  // all Chart instances array within page (equivalent of 'bb.instances')
  // data object
  // Axis
  // Axis
  // scales
  // original values
  // formatter function
  // format function
  function ChartInternal(api) {
    _defineProperty(this, "api", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "cache", void 0), _defineProperty(this, "$el", void 0), _defineProperty(this, "state", void 0), _defineProperty(this, "charts", void 0), _defineProperty(this, "data", {
      xs: {},
      targets: []
    }), _defineProperty(this, "axis", void 0), _defineProperty(this, "scale", {
      x: null,
      y: null,
      y2: null,
      subX: null,
      subY: null,
      subY2: null,
      zoom: null
    }), _defineProperty(this, "org", {
      xScale: null,
      xDomain: null
    }), _defineProperty(this, "color", void 0), _defineProperty(this, "patterns", void 0), _defineProperty(this, "levelColor", void 0), _defineProperty(this, "point", void 0), _defineProperty(this, "brush", void 0), _defineProperty(this, "format", {
      extraLineClasses: null,
      xAxisTick: null,
      dataTime: null,
      // dataTimeFormat
      defaultAxisTime: null,
      // defaultAxisTimeFormat
      axisTime: null // axisTimeFormat

    });
    var $$ = this;
    $$.api = api, $$.config = new Options(), $$.cache = new Cache_Cache();
    var store = new Store();
    $$.$el = store.getStore("element"), $$.state = store.getStore("state");
  }

  var _proto = ChartInternal.prototype;
  return _proto.beforeInit = function beforeInit() {
    var $$ = this;
    $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$.api);
  }, _proto.afterInit = function afterInit() {
    var $$ = this;
    $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$.api);
  }, _proto.init = function init() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    state.hasAxis = !$$.hasArcType(), state.hasRadar = !state.hasAxis && $$.hasType("radar"), $$.initParams();
    var bindto = {
      element: config.bindto,
      classname: "bb"
    };
    isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $el.chart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $el.chart.empty() && ($el.chart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.body.appendChild(browser_doc.createElement("div")))), $el.chart.html("").classed(bindto.classname, !0), $$.initToRender();
  }
  /**
   * Initialize the rendering process
   * @param {boolean} forced Force to render process
   * @private
   */
  , _proto.initToRender = function initToRender(forced) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        chart = $$.$el.chart,
        isHidden = function () {
      return chart.style("display") === "none" || chart.style("visibility") === "hidden";
    },
        isLazy = config.render.lazy || isHidden(),
        MutationObserver = win.MutationObserver;

    if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
      isHidden() || (observer.disconnect(), !state.rendered && $$.initToRender(!0));
    }).observe(chart.node(), {
      attributes: !0,
      attributeFilter: ["class", "style"]
    }), !isLazy || forced) {
      var convertedData = $$.convertData(config, $$.initWithData);
      convertedData && $$.initWithData(convertedData), $$.afterInit();
    }
  }, _proto.initParams = function initParams() {
    var $$ = this,
        _ref = $$,
        config = _ref.config,
        format = _ref.format,
        state = _ref.state,
        isRotated = config.axis_rotated;

    if (state.datetimeId = "bb-" + +new Date(), $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.hasPointType() && ($$.point = $$.generatePoint()), state.hasAxis) {
      $$.initClip(), format.extraLineClasses = $$.generateExtraLineClass(), format.dataTime = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], format.axisTime = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";

      format.defaultAxisTime = function (d) {
        var _$$$scale = $$.scale,
            x = _$$$scale.x,
            zoom = _$$$scale.zoom,
            isZoomed = isDragZoom ? zoom : zoom && x.orgDomain().toString() !== zoom.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return format.axisTime(specifier)(d);
      };
    }

    state.isLegendRight = config.legend_position === "right", state.isLegendInset = config.legend_position === "inset", state.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", state.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", state.rotatedPaddingRight = isRotated && !config.axis_x_show ? 0 : 30, state.inputType = convertInputType(config.interaction_inputType_mouse, config.interaction_inputType_touch);
  }, _proto.initWithData = function initWithData(data) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        $el = $$.$el,
        org = $$.org,
        hasAxis = state.hasAxis,
        hasInteraction = config.interaction_enabled;
    hasAxis && ($$.axis = $$.getAxisInstance(), config.zoom_enabled && $$.initZoom()), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter.bind($$.api))), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.updateSizes(), $$.updateScales(!0);
    // retrieve scale after the 'updateScales()' is called
    var x = scale.x,
        y = scale.y,
        y2 = scale.y2,
        subX = scale.subX,
        subY = scale.subY,
        subY2 = scale.subY2; // Set domains for each scale

    if (x && (x.domain(util_sortValue($$.getXDomain($$.data.targets))), subX.domain(x.domain()), org.xDomain = x.domain()), y && (y.domain($$.getYDomain($$.data.targets, "y")), subY.domain(y.domain())), y2 && (y2.domain($$.getYDomain($$.data.targets, "y2")), subY2 && subY2.domain(y2.domain())), $el.svg = $el.chart.append("svg").style("overflow", "hidden").style("display", "block"), hasInteraction && state.inputType) {
      var isTouch = state.inputType === "touch";
      $el.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
        return callFn(config.onover, $$.api);
      }).on(isTouch ? "touchend" : "mouseleave", function () {
        return callFn(config.onout, $$.api);
      });
    }

    config.svg_classname && $el.svg.attr("class", config.svg_classname);
    // Define defs
    var hasColorPatterns = isFunction(config.color_tiles) && $$.patterns;
    (hasAxis || hasColorPatterns) && ($el.defs = $el.svg.append("defs"), hasAxis && ["id", "idXAxis", "idYAxis", "idGrid"].forEach(function (v) {
      $$.appendClip($el.defs, state.clip[v]);
    }), hasColorPatterns && $$.patterns.forEach(function (p) {
      return $el.defs.append(function () {
        return p.node;
      });
    })), $$.updateSvgSize(), $$.bindResize();
    // Define regions
    var main = $el.svg.append("g").classed(config_classes.main, !0).attr("transform", $$.getTranslate("main"));

    // data.onmin/max callback
    if ($el.main = main, config.subchart_show && $$.initSubchart(), config.tooltip_show && $$.initTooltip(), config.title_text && $$.initTitle(), config.legend_show && $$.initLegend(), config.data_empty_label_text && main.append("text").attr("class", config_classes.text + " " + config_classes.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
    .attr("dominant-baseline", "middle"), hasAxis && (config.regions.length && $$.initRegion(), !config.clipPath && $$.axis.init()), main.append("g").attr("class", config_classes.chart).attr("clip-path", state.clip.path), $$.callPluginHook("$init"), hasAxis && (hasInteraction && $$.initEventRect && $$.initEventRect(), $$.initGrid(), config.clipPath && $$.axis && $$.axis.init()), $$.initChartElements(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$.api), $$.setBackground(), $$.redraw({
      withTransition: !1,
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withTransitionForAxis: !1,
      initializing: !0
    }), config.data_onmin || config.data_onmax) {
      var minMax = $$.getMinMaxData();
      callFn(config.data_onmin, $$.api, minMax.min), callFn(config.data_onmax, $$.api, minMax.max);
    }

    state.rendered = !0;
  }, _proto.initChartElements = function initChartElements() {
    var $$ = this,
        _$$$state = $$.state,
        hasAxis = _$$$state.hasAxis,
        hasRadar = _$$$state.hasRadar,
        types = [];
    hasAxis ? ($$.hasType("bar") && types.push("Bar"), $$.hasType("bubble") && types.push("Bubble"), $$.hasTypeOf("Line") && types.push("Line")) : (!hasRadar && types.push("Arc", "Pie"), $$.hasType("gauge") ? types.push("Gauge") : hasRadar && types.push("Radar")), types.forEach(function (v) {
      $$["init" + v]();
    }), notEmpty($$.config.data_labels) && $$.initText();
  }, _proto.setChartElements = function setChartElements() {
    var $$ = this,
        _$$$$el = $$.$el,
        chart = _$$$$el.chart,
        svg = _$$$$el.svg,
        defs = _$$$$el.defs,
        main = _$$$$el.main,
        tooltip = _$$$$el.tooltip,
        legend = _$$$$el.legend,
        title = _$$$$el.title,
        grid = _$$$$el.grid,
        arc = _$$$$el.arcs,
        circles = _$$$$el.circle,
        bars = _$$$$el.bar,
        lines = _$$$$el.line,
        areas = _$$$$el.area,
        texts = _$$$$el.text;
    $$.api.$ = {
      chart: chart,
      svg: svg,
      defs: defs,
      main: main,
      tooltip: tooltip,
      legend: legend,
      title: title,
      grid: grid,
      arc: arc,
      circles: circles,
      bar: {
        bars: bars
      },
      line: {
        lines: lines,
        areas: areas
      },
      text: {
        texts: texts
      }
    };
  }
  /**
   * Set background element/image
   * @private
   */
  , _proto.setBackground = function setBackground() {
    var $$ = this,
        bg = $$.config.background,
        state = $$.state,
        svg = $$.$el.svg;

    if (notEmpty(bg)) {
      var element = svg.select("g").insert(bg.imgUrl ? "image" : "rect", ":first-child");
      bg.imgUrl ? element.attr("href", bg.imgUrl) : bg.color && element.style("fill", bg.color).attr("clip-path", state.clip.path), element.attr("class", bg.class || null).attr("width", "100%").attr("height", "100%");
    }
  }
  /**
   * Update targeted element with given data
   * @param {object} targets Data object formatted as 'target'
   * @private
   */
  , _proto.updateTargets = function updateTargets(targets) {
    var $$ = this,
        _$$$state2 = $$.state,
        hasAxis = _$$$state2.hasAxis,
        hasRadar = _$$$state2.hasRadar;
    $$.updateTargetsForText(targets), ($$.hasPointType() || hasRadar) && $$.updateTargetForCircle && $$.updateTargetForCircle(), hasAxis ? ($$.hasType("bar") && $$.updateTargetsForBar(targets), $$.hasTypeOf("Line") && $$.updateTargetsForLine(targets), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets)) : $$.hasArcType(targets) && (hasRadar ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.showTargets();
  }
  /**
   * Display targeted elements
   * @private
   */
  , _proto.showTargets = function showTargets() {
    var $$ = this,
        config = $$.config,
        svg = $$.$el.svg;
    svg.selectAll("." + config_classes.target).filter(function (d) {
      return $$.isTargetToShow(d.id);
    }).transition().duration(config.transition_duration).style("opacity", "1");
  }, _proto.getWithOption = function getWithOption(options) {
    var withOptions = {
      Y: !0,
      Subchart: !0,
      Transition: !0,
      EventRect: !0,
      Dimension: !0,
      TrimXDomain: !0,
      Transform: !1,
      UpdateXDomain: !1,
      UpdateOrgXDomain: !1,
      Legend: !1,
      UpdateXAxis: "UpdateXDomain",
      TransitionForExit: "Transition",
      TransitionForAxis: "Transition"
    };
    return Object.keys(withOptions).forEach(function (key) {
      var defVal = withOptions[key];
      isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with" + key, defVal);
    }), withOptions;
  }, _proto.initialOpacity = function initialOpacity(d) {
    var $$ = this,
        withoutFadeIn = $$.state.withoutFadeIn;
    return $$.getBaseValue(d) !== null && withoutFadeIn[d.id] ? "1" : "0";
  }, _proto.bindResize = function bindResize() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        resizeFunction = generateResize(),
        list = [];
    list.push(function () {
      return callFn(config.onresize, $$, $$.api);
    }), config.resize_auto && list.push(function () {
      state.resizing = !0, $$.api.flush(!1);
    }), list.push(function () {
      callFn(config.onresized, $$, $$.api), state.resizing = !1;
    }), list.forEach(function (v) {
      return resizeFunction.add(v);
    }), $$.resizeFunction = resizeFunction, win.addEventListener("resize", $$.resizeFunction = resizeFunction);
  }
  /**
   * Call plugin hook
   * @param {string} phase The lifecycle phase
   * @param {Array} args Arguments
   * @private
   */
  , _proto.callPluginHook = function callPluginHook(phase) {
    for (var _this = this, _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

    this.config.plugins.forEach(function (v) {
      phase === "$beforeInit" && (v.$$ = _this, _this.api.plugins.push(v)), v[phase].apply(v, args);
    });
  }, ChartInternal;
}();


extend(ChartInternal_ChartInternal.prototype, [// common
convert, ChartInternal_data_data, load, category, internals_class, internals_color, internals_domain, interactions_interaction, internals_format, internals_legend, internals_redraw, internals_scale, shape_shape, internals_size, internals_text, internals_title, internals_tooltip, internals_transform, internals_type]);
// CONCATENATED MODULE: ./src/config/config.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Load configuration option
 * @param {object} config User's generation config value
 * @private
 */
function loadConfig(config) {
  var target,
      keys,
      read,
      thisConfig = this.config,
      find = function () {
    var key = keys.shift();
    return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
  };

  Object.keys(thisConfig).forEach(function (key) {
    target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
  });
}
// CONCATENATED MODULE: ./src/Chart/api/chart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_chart = ({
  /**
   * Resize the chart.
   * @function resize
   * @instance
   * @memberof Chart
   * @param {object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state;
    state.rendered && (config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0), $$.resizeFunction());
  },

  /**
   * Force to redraw.
   * @function flush
   * @instance
   * @memberof Chart
   * @param {boolean} [soft] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft) {
    var $$ = this.internal,
        state = $$.state;
    state.rendered ? (state.resizing ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.scale.zoom = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    })) : $$.initToRender(!0);
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @function destroy
   * @instance
   * @memberof Chart
   * @returns {null}
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal,
        _$$$$el = $$.$el,
        chart = _$$$$el.chart,
        svg = _$$$$el.svg;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), svg.select("*").interrupt(), $$.resizeFunction.clear(), win.removeEventListener("resize", $$.resizeFunction), chart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @function config
   * @instance
   * @memberof Chart
   * @param {string} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @returns {*}
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function (name, value, redraw) {
    var res,
        $$ = this.internal,
        config = $$.config,
        key = name && name.replace(/\./g, "_");
    return key in config && (isDefined(value) ? (config[key] = value, res = value, redraw && this.flush()) : res = config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_color = ({
  /**
   * Get the color
   * @function color
   * @instance
   * @memberof Chart
   * @param {string} id id to get the color
   * @returns {string}
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/Chart/api/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get data loaded in the chart.
 * @function data
 * @instance
 * @memberof Chart
 * @param {string|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @returns {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */
function api_data_data(targetIds) {
  var targets = this.internal.data.targets;

  if (!isUndefined(targetIds)) {
    var ids = isArray(targetIds) ? targetIds : [targetIds];
    return targets.filter(function (t) {
      return ids.some(function (v) {
        return v === t.id;
      });
    });
  }

  return targets;
}

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @function data․shown
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @returns {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @function data․values
   * @instance
   * @memberof Chart
   * @param {string|Array|null} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @param {boolean} [flat=true] Get flatten values
   * @returns {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetIds, flat) {
    flat === void 0 && (flat = !0);
    var values = null;

    if (targetIds) {
      var targets = this.data(targetIds);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @function data․names
   * @instance
   * @memberof Chart
   * @param {object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @returns {object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    var $$ = this.internal; // reset existing legend item dimension cache data

    return $$.cache.remove(KEY.legendItemTextBox), $$.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @function data․colors
   * @instance
   * @memberof Chart
   * @param {object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @returns {object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @function data․axes
   * @instance
   * @memberof Chart
   * @param {object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @returns {object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @function data․min
   * @instance
   * @memberof Chart
   * @returns {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @function data․max
   * @instance
   * @memberof Chart
   * @returns {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
});
/* harmony default export */ var api_data = ({
  data: api_data_data
});
// CONCATENATED MODULE: ./src/Chart/api/export.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Encode to base64
 * @param {string} str string to be encoded
 * @returns {string}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode(+("0x" + p));
  }));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node target node
 * @param {object} size object containing {width, height}
 * @returns {string}
 * @private
 */


function nodeToSvgDataUrl(node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser_doc.styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser_doc.createElement("style"); // escape css for XML

  style.appendChild(browser_doc.createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = ("<svg xmlns=\"" + external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg + "\" width=\"" + size.width + "\" height=\"" + size.height + "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t" + styleXml + "\n\t\t\t\t" + nodeXml.replace(/(url\()[^#]+/g, "$1") + "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64," + b64EncodeUnicode(dataStr);
}

/* harmony default export */ var api_export = ({
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @function export
   * @instance
   * @memberof Chart
   * @param {string} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @returns {string} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  export: function _export(mimeType, callback) {
    var _this = this,
        $$ = this.internal,
        state = $$.state,
        chart = $$.$el.chart,
        _state$current = state.current,
        width = _state$current.width,
        height = _state$current.height,
        svgDataUrl = nodeToSvgDataUrl(chart.node(), {
      width: width,
      height: height
    });

    if (callback && isFunction(callback)) {
      var img = new Image();
      img.crossOrigin = "Anonymous", img.onload = function () {
        var canvas = browser_doc.createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = width, canvas.height = height, ctx.drawImage(img, 0, 0), callback.bind(_this)(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/focus.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_focus = ({
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @function focus
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && !state.hasRadar && ($$.expandArc(targetIds), $$.hasType("gauge") && $$.markOverlapped(targetIdsValue, $$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !0), state.focusedTargetIds = targetIds, state.defocusedTargetIds = state.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @function defocus
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && ($$.unexpandArc(targetIds), $$.hasType("gauge") && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !1), state.focusedTargetIds = state.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), state.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @function revert
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIdsValue Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $el.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $el.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), state.focusedTargetIds = [], state.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/Chart/api/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define legend
 * @ignore
 */
var legend_legend = {
  /**
   * Show legend for each target.
   * @function legend․show
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @function legend․hide
   * @instance
   * @memberof Chart
   * @param {string|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
};
/* harmony default export */ var api_legend = ({
  legend: legend_legend
});
// CONCATENATED MODULE: ./src/Chart/api/load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_load = ({
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @function load
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded. Checkout the example. |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set request header if loading via `data.url`.<br>@see [data․headers](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [data․keys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [data․mimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json",
   *
   *     // set request header if is needed
   *     headers: {
   *       "Content-Type": "text/json"
   *     }
   * });
   * @example
   * chart.load({
   *     data: [
   *       // equivalent as: columns: [["data1", 30, 200, 100]]
   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
   *
   *       // or
   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
   *     ]
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.axis.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @function unload
   * @instance
   * @memberof Chart
   * @param {object} argsValue
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var _this = this,
        $$ = this.internal,
        args = argsValue || {};

    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.cache.remove(ids), args.done && args.done.call(_this);
    });
  }
});
// CONCATENATED MODULE: ./src/Chart/api/show.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Show/Hide data series
 * @param {boolean} show Show or hide
 * @param {Array} targetIdsValue Target id values
 * @param {object} options Options
 * @private
 */

function showHide(show, targetIdsValue, options) {
  var $$ = this.internal,
      targetIds = $$.mapToTargetIds(targetIdsValue);
  $$.state.toggling = !0, $$[(show ? "remove" : "add") + "HiddenTargetIds"](targetIds);
  var targets = $$.$el.svg.selectAll($$.selectorTargets(targetIds)),
      opacity = show ? "1" : "0";
  targets.transition().style("opacity", opacity, "important").call(endall, function () {
    targets.style("opacity", null).style("opacity", opacity);
  }), options.withLegend && $$[(show ? "show" : "hide") + "Legend"](targetIds), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0,
    withLegend: !0
  }), $$.state.toggling = !1;
}

/* harmony default export */ var api_show = ({
  /**
   * Show data series on chart
   * @function show
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIdsValue] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @function hide
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIdsValue] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @function toggle
   * @instance
   * @memberof Chart
   * @param {string|Array} [targetIds] The target id value.
   * @param {object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds, options) {
    var _this = this;

    options === void 0 && (options = {});
    var $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };
    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/Chart/api/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define tooltip
 * @ignore
 */

var tooltip_tooltip = {
  /**
   * Show tooltip
   * @function tooltip․show
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {number &verbar; Date}: x Axis value<br>- index {number}: x Axis index (useless for data.xs)<br>- id {string}: data id<br>- value {number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.
   *  chart.tooltip.show({
   *    x: 2,
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show(args) {
    var index,
        mouse,
        $$ = this.internal,
        config = $$.config,
        inputType = $$.state.inputType;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var data = args.data,
          y = $$.getYScaleById(data.id)(data.value);
      $$.isMultipleX() ? mouse = [$$.scale.x(data.x), y] : (!config.tooltip_grouped && (mouse = [0, y]), index = isValue(data.index) ? data.index : $$.getIndexByX(data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    (inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @function tooltip․hide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal; // reset last touch point index

    $$.inputType === "touch" && $$.callOverOutForTouch(), $$.hideTooltip(!0), $$.hideGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
};
/* harmony default export */ var api_tooltip = ({
  tooltip: tooltip_tooltip
});
// CONCATENATED MODULE: ./src/Chart/Chart.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */












/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
 */

/**
 * Access instance's primary node elements
 * @member {object} $
 * @property {object} $ Access instance's primary node elements
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {d3.selection} $.circles Data point circle elements
 * @property {object} $.bar Bar element object
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {object} $.line Line element object
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {object} $.text Text element object
 * @property {d3.selection} $.text.texts Data label text elements
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

/**
 * Plugin instance array
 * @member {Array} plugins
 * @memberof Chart
 * @example
 *  var chart = bb.generate({
 *     ...
 *     plugins: [
 *        new bb.plugin.stanford({ ... }),
 *        new PluginA()
 *     ]
 *  });
 *
 *  chart.plugins; // [Stanford, PluginA] - instance array
 */

var Chart_Chart = function Chart(options) {
  _defineProperty(this, "plugins", []), _defineProperty(this, "internal", void 0);
  var ctx = this,
      $$ = new ChartInternal_ChartInternal(ctx); // const {type, types} = options.data;
  // let isArc = false;
  // if (type) {
  // 	isArc = TYPES.Arc.indexOf(type) > -1;
  // } else if (types) {
  // 	for (const x in types) {
  // 		if (TYPES.Arc.indexOf(types[x]) > -1) {
  // 			isArc = true;
  // 			break;
  // 		}
  // 	}
  // }

  // bind to namespaced APIs
  this.internal = $$, function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      var isFunc = isFunction(fn[key]),
          isChild = target !== argThis,
          hasChild = Object.keys(fn[key]).length > 0;
      isFunc && (!isChild && hasChild || isChild) ? target[key] = fn[key].bind(argThis) : !isFunc && (target[key] = {}), hasChild && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this), loadConfig.call($$, options), $$.beforeInit(), $$.init();
}; // extend common APIs as part of Chart class



extend(Chart_Chart.prototype, [api_chart, api_color, api_data, api_export, api_focus, api_legend, api_load, api_show, api_tooltip]);
// CONCATENATED MODULE: ./src/Chart/api/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Set the min/max value
 * @param {Chart} $$ Chart instance
 * @param {string} type Set type 'min' or 'max'
 * @param {object} value Value to be set
 * @private
 */

function setMinMax($$, type, value) {
  var config = $$.config,
      axisY = "axis_y_" + type,
      axisY2 = "axis_y2_" + type;
  isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config["axis_x_" + type] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  }));
}
/**
 * Get the min/max value
 * @param {Chart} $$ Chart instance
 * @param {string} type Set type 'min' or 'max'
 * @returns {{x, y, y2}}
 * @private
 */


function axis_getMinMax($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_" + type],
    y: config["axis_y_" + type],
    y2: config["axis_y2_" + type]
  };
}
/**
 * Define axis
 * @ignore
 */


var api_axis_axis = {
  /**
   * Get and set axis labels.
   * @function axis․labels
   * @instance
   * @memberof Chart
   * @param {object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @function axis․min
   * @instance
   * @memberof Chart
   * @param {object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @returns {object|undefined}
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return isValue(_min) ? setMinMax($$, "min", _min) : axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @function axis․max
   * @instance
   * @memberof Chart
   * @param {object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @returns {object|undefined}
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @function axis․range
   * @instance
   * @memberof Chart
   * @param {object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @returns {object|undefined}
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
};
/* harmony default export */ var api_axis = ({
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/Chart/api/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_category = ({
  /**
   * Set specified category name on category axis.
   * @function category
   * @instance
   * @memberof Chart
   * @param {number} i index of category to be changed
   * @param {string} category category value to be changed
   * @returns {string}
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @function categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @returns {Array}
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_flow = ({
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @function flow
   * @instance
   * @memberof Chart
   * @param {object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [data․json](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [data․rows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [data․columns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
   *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0),
          isTimeSeries = $$.axis.isTimeSeries();
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, isTimeSeries || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: isTimeSeries ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: isTimeSeries ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, isTimeSeries || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = isTimeSeries ? parseDate.call($$, args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && isTimeSeries && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = isTimeSeries ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
});
// CONCATENATED MODULE: ./src/Chart/api/grid.x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update x grid lines.
 * @function xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @returns {object}
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 * // --> Returns: [{value: 1, text: "Label 1"}, {value: 4, text: "Label 4"}]
 */
function xgrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
}

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @function xgrids․add
   * @instance
   * @memberof Chart
   * @param {Array|object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @returns {object}
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @function xgrids․remove
   * @instance
   * @memberof Chart
   * @param {object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});
/* harmony default export */ var grid_x = ({
  xgrids: xgrids
});
// CONCATENATED MODULE: ./src/Chart/api/grid.y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update y grid lines.
 * @function ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @returns {object}
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 * // --> Returns: [{value: 100, text: "Label 1"}, {value: 400, text: "Label 4"}]
 */

function ygrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_y_lines = grids, $$.redrawWithoutRescale(), config.grid_y_lines) : config.grid_y_lines;
}

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @function ygrids․add
   * @instance
   * @memberof Chart
   * @param {Array|object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @returns {object}
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @function ygrids․remove
   * @instance
   * @memberof Chart
   * @param {object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
});
/* harmony default export */ var grid_y = ({
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/Chart/api/group.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var group = ({
  /**
   * Update groups for the targets.
   * @function groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @returns {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/Chart/api/regions.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Update regions.
 * @function regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @returns {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */
function regions_regions(regions) {
  var $$ = this.internal,
      config = $$.config;
  return regions ? (config.regions = regions, $$.redrawWithoutRescale(), regions) : config.regions;
}

extend(regions_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @function regions․add
   * @instance
   * @memberof Chart
   * @param {Array|object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @returns {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @function regions․remove
   * @instance
   * @memberof Chart
   * @param {object} optionsValue This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @returns {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.$el.main.select("." + config_classes.regions).selectAll(classes.map(function (c) {
      return "." + c;
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region.class || (region.class.split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
});
/* harmony default export */ var api_regions = ({
  regions: regions_regions
});
// CONCATENATED MODULE: ./src/Chart/api/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var api_selection = ({
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @function selected
   * @instance
   * @memberof Chart
   * @param {string} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @returns {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.$el.main.selectAll("." + (config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll("." + config_classes.shape).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @function select
   * @instance
   * @memberof Chart
   * @param {string|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable.bind($$.api)(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @function unselect
   * @instance
   * @memberof Chart
   * @param {string|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable.bind($$.api)(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/Chart/api/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_x = ({
  /**
   * Get and set x values for the chart.
   * @function x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @returns {object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        axis = $$.axis,
        data = $$.data,
        isCategorized = axis.isCustomX() && axis.isCategorized();
    return isArray(_x) && (isCategorized ? this.categories(_x) : ($$.updateTargetX(data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? this.categories() : data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @function xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @returns {object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(44);

// CONCATENATED MODULE: ./src/Chart/api/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Check if the given domain is within zoom range
 * @param {Array} domain domain value
 * @param {Array} range zoom range value
 * @returns {boolean}
 * @private
 */

function withinRange(domain, range) {
  var min = range[0],
      max = range[1];
  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
}
/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @function zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @returns {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */


var zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      config = $$.config,
      scale = $$.scale,
      domain = domainValue;

  if (config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.axis.isTimeSeries();

    if (isTimeSeries) {
      var fn = parseDate.bind($$);
      domain = domain.map(function (x) {
        return fn(x);
      });
    }

    if (config.subchart_show) {
      var xScale = scale.zoom || scale.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else scale.x.domain(domain), scale.zoom = scale.x, $$.axis.x.scale(scale.zoom), resultDomain = scale.zoom.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn(config.zoom_onzoom, $$.api, resultDomain);
  } else resultDomain = scale.zoom ? scale.zoom.domain() : scale.x.orgDomain();

  return resultDomain;
};

extend(zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @function zoom․enable
   * @instance
   * @memberof Chart
   * @param {string|boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable(enabled) {
    var $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @function zoom․max
   * @instance
   * @memberof Chart
   * @param {number} [max] maximum value to set for zoom
   * @returns {number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [xDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @function zoom․min
   * @instance
   * @memberof Chart
   * @param {number} [min] minimum value to set for zoom
   * @returns {number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [xDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @function zoom․range
   * @instance
   * @memberof Chart
   * @param {object} [range] zoom range
   * @returns {object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range) {
    var zoom = this.zoom;

    if (isObject(_range)) {
      var min = _range.min,
          max = _range.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
});
/* harmony default export */ var api_zoom = ({
  zoom: zoom_zoom,

  /**
   * Unzoom zoomed area
   * @function unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.scale.zoom) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.$el.main.select("." + config_classes.eventRects);
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(45);

// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRendererHelper.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper = /*#__PURE__*/function () {
  function AxisRendererHelper(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "scale", void 0);
    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])(),
        config = owner.config,
        params = owner.params;
    this.owner = owner, this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node <g class=tick> node
   * @returns {{w: number, h: number}}
   * @private
   */


  AxisRendererHelper.getSizeFor1Char = function getSizeFor1Char(node) {
    // default size for one character
    var size = {
      w: 5.5,
      h: 11.5
    };
    return node.empty() || node.select("text").text("0").call(function (el) {
      try {
        var _el$node$getBBox = el.node().getBBox(),
            width = _el$node$getBBox.width,
            height = _el$node$getBBox.height;

        width && height && (size.w = width, size.h = height);
      } catch (e) {} finally {
        el.text("");
      }
    }), this.getSizeFor1Char = function () {
      return size;
    }, size;
  }
  /**
   * Get tick transform setter function
   * @param {string} id Axis id
   * @returns {Function} transfrom setter function
   * @private
   */
  ;

  var _proto = AxisRendererHelper.prototype;
  return _proto.getTickTransformSetter = function getTickTransformSetter(id) {
    var config = this.config,
        fn = id === "x" ? function (value) {
      return "translate(" + (value + config.tickOffset) + ",0)";
    } : function (value) {
      return "translate(0," + value + ")";
    };
    return function (selection, scale) {
      selection.attr("transform", function (d) {
        return fn(Math.ceil(scale(d)));
      });
    };
  }, _proto.scaleExtent = function scaleExtent(domain) {
    var start = domain[0],
        stop = domain[domain.length - 1];
    return start < stop ? [start, stop] : [stop, start];
  }, _proto.generateTicks = function generateTicks(scale, isYAxes) {
    var tickStepSize = this.owner.params.tickStepSize,
        ticks = [];
    // When 'axis[y|y2].tick.stepSize' option is set
    if (isYAxes && tickStepSize) for (var _scale$domain = scale.domain(), start = _scale$domain[0], end = _scale$domain[1], interval = start; interval <= end;) ticks.push(interval), interval += tickStepSize;else if (scale.ticks) ticks = scale.ticks.apply(scale, this.config.tickArguments || []).map(function (v) {
      return (// round the tick value if is number
        isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
      );
    });else {
      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
    }
    return ticks;
  }, _proto.copyScale = function copyScale() {
    var newScale = this.scale.copy();
    return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
  }, _proto.textFormatted = function textFormatted(v) {
    var tickFormat = this.config.tickFormat,
        value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
        formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
    // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
    // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

    return isDefined(formatted) ? formatted : "";
  }, _proto.transitionise = function transitionise(selection) {
    var config = this.config;
    return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
  }, AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRenderer.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer = /*#__PURE__*/function () {
  function AxisRenderer(params) {
    params === void 0 && (params = {}), _defineProperty(this, "helper", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "params", void 0), _defineProperty(this, "g", void 0);
    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.config = config, this.params = params, this.helper = new AxisRendererHelper_AxisRendererHelper(this);
  }
  /**
   * Create axis element
   * @param {d3.selection} g Axis selection
   * @private
   */


  var _proto = AxisRenderer.prototype;
  return _proto.create = function create(g) {
    var ctx = this,
        config = this.config,
        helper = this.helper,
        params = this.params,
        scale = helper.scale,
        orient = config.orient,
        splitTickText = this.splitTickText.bind(this),
        isLeftRight = /^(left|right)$/.test(orient),
        isTopBottom = /^(top|bottom)$/.test(orient),
        tickTransform = helper.getTickTransformSetter(isTopBottom ? "x" : "y"),
        axisPx = tickTransform === helper.axisX ? "y" : "x",
        sign = /^(top|left)$/.test(orient) ? -1 : 1,
        rotate = params.tickTextRotate;
    this.config.range = scale.rangeExtent ? scale.rangeExtent() : helper.scaleExtent((params.orgXScale || scale).range());
    var $g,
        _config2 = config,
        innerTickSize = _config2.innerTickSize,
        tickLength = _config2.tickLength,
        range = _config2.range,
        id = params.id,
        tickTextPos = id && /^(x|y|y2)$/.test(id) ? params.config["axis_" + id + "_tick_text_position"] : {
      x: 0,
      y: 0
    },
        prefix = id === "subX" ? "subchart_axis_x" : "axis_" + id,
        axisShow = params.config[prefix + "_show"],
        tickShow = {
      tick: !!axisShow && params.config[prefix + "_tick_show"],
      text: !!axisShow && params.config[prefix + "_tick_text_show"]
    }; // // get the axis' tick position configuration

    g.each(function () {
      var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          scale0 = this.__chart__ || scale,
          scale1 = helper.copyScale();
      $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
      // update selection - data join
      var path = g.selectAll(".domain").data([0]); // enter + update selection

      if (path.enter().append("path").attr("class", "domain").merge(helper.transitionise(path)).attr("d", function () {
        var outerTickSized = config.outerTickSize * sign;
        return isTopBottom ? "M" + range[0] + "," + outerTickSized + "V0H" + range[1] + "V" + outerTickSized : "M" + outerTickSized + "," + range[0] + "H0V" + range[1] + "H" + outerTickSized;
      }), tickShow.tick || tickShow.text) {
        // count of tick data in array
        var ticks = config.tickValues || helper.generateTicks(scale1, isLeftRight),
            tick = g.selectAll(".tick").data(ticks, scale1),
            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
            tickExit = tick.exit().remove(); // update selection

        tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
        var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
            counts = [],
            tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
          var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helper.textFormatted(d)) ? helper.textFormatted(d).concat() : [helper.textFormatted(d)];
          return counts[index] = split.length, split.map(function (splitted) {
            return {
              index: index,
              splitted: splitted
            };
          });
        });
        tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
          return d.splitted;
        }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
          var dx = 0;
          return /(top|bottom)/.test(orient) && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180)) * (orient === "top" ? -1 : 1)), dx + (tickTextPos.x || 0);
        }()).attr("dy", function (d, i) {
          var dy = 0;
          return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
        });
        var lineUpdate = tick.select("line"),
            textUpdate = tick.select("text");

        // Append <title> for tooltip display
        if (tickEnter.select("line").attr(axisPx + "2", innerTickSize * sign), tickEnter.select("text").attr(axisPx, tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle) {
          var title = textUpdate.select("title");
          (title.empty() ? textUpdate.append("title") : title).text(function (index) {
            return params.tickTitle[index];
          });
        }

        if (scale1.bandwidth) {
          var x = scale1,
              dx = x.bandwidth() / 2;
          scale0 = function (d) {
            return x(d) + dx;
          }, scale1 = scale0;
        } else scale0.bandwidth ? scale0 = scale1 : tickTransform(tickExit, scale1);

        tickTransform(tickEnter, scale0), tickTransform(helper.transitionise(tick).style("opacity", "1"), scale1);
      }
    }), this.g = $g;
  }
  /**
   * Get tick x/y coordinate
   * @returns {{x: number, y: number}}
   * @private
   */
  , _proto.getTickXY = function getTickXY() {
    var config = this.config,
        pos = {
      x: 0,
      y: 0
    };
    return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
  }
  /**
   * Get tick size
   * @param {object} d data object
   * @returns {number}
   * @private
   */
  , _proto.getTickSize = function getTickSize(d) {
    var scale = this.helper.scale,
        config = this.config,
        _config3 = config,
        innerTickSize = _config3.innerTickSize,
        range = _config3.range,
        tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
    return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
  }
  /**
   * Set tick's line & text position
   * @param {d3.selection} lineUpdate Line selection
   * @param {d3.selection} textUpdate Text selection
   * @private
   */
  , _proto.setTickLineTextPosition = function setTickLineTextPosition(lineUpdate, textUpdate) {
    var tickPos = this.getTickXY(),
        _this$config = this.config,
        innerTickSize = _this$config.innerTickSize,
        orient = _this$config.orient,
        tickLength = _this$config.tickLength,
        tickOffset = _this$config.tickOffset,
        rotate = this.params.tickTextRotate,
        textAnchorForText = function (r) {
      var value = ["start", "end"];
      return orient === "top" && value.reverse(), r ? r > 0 ? value[0] : value[1] : "middle";
    },
        textTransform = function (r) {
      return r ? "rotate(" + r + ")" : null;
    },
        yForText = function (r) {
      var r2 = r / (orient === "bottom" ? 15 : 23);
      return r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;
    };

    orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -yForText(rotate) * 2).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
  } // this should be called only when category axis
  , _proto.splitTickText = function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
    // split given text by tick width size
    // eslint-disable-next-line
    function split(splitted, text) {
      for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
      if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

      return splitted.concat(text);
    }

    var params = this.params,
        tickText = this.helper.textFormatted(d),
        splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
    if (splitted.length) return splitted;
    if (isArray(tickText)) return tickText;
    var tickWidth = params.tickWidth;
    return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
  }, _proto.scale = function scale(x) {
    return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
  }, _proto.orient = function orient(x) {
    return arguments.length ? (this.config.orient = x in {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    } ? x + "" : "bottom", this) : this.config.orient;
  }, _proto.tickFormat = function tickFormat(format) {
    var config = this.config;
    return arguments.length ? (config.tickFormat = format, this) : config.tickFormat;
  }, _proto.tickCentered = function tickCentered(isCentered) {
    var config = this.config;
    return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
  }
  /**
   * Return tick's offset value.
   * The value will be set for 'category' axis type.
   * @returns {number}
   * @private
   */
  , _proto.tickOffset = function tickOffset() {
    return this.config.tickOffset;
  }
  /**
   * Get tick interval count
   * @private
   * @param {number} size Total data size
   * @returns {number}
   */
  , _proto.tickInterval = function tickInterval(size) {
    var interval;
    if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
      var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
      interval = length / (size || this.g.selectAll("line").size());
    }
    return interval === Infinity ? 0 : interval;
  }, _proto.ticks = function ticks() {
    for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
  }, _proto.tickCulling = function tickCulling(culling) {
    var config = this.config;
    return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
  }, _proto.tickValues = function tickValues(x) {
    var _this = this,
        config = this.config;

    if (isFunction(x)) config.tickValues = function () {
      return x(_this.helper.scale.domain());
    };else {
      if (!arguments.length) return config.tickValues;
      config.tickValues = x;
    }
    return this;
  }, _proto.setTransition = function setTransition(t) {
    return this.config.transition = t, this;
  }, AxisRenderer;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/Axis.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var Axis_Axis = ({
  getAxisInstance: function getAxisInstance() {
    return this.axis || new Axis_Axis_Axis(this);
  }
});

var Axis_Axis_Axis = /*#__PURE__*/function () {
  function Axis(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "x", void 0), _defineProperty(this, "subX", void 0), _defineProperty(this, "y", void 0), _defineProperty(this, "y2", void 0), _defineProperty(this, "axesList", {}), _defineProperty(this, "tick", {
      x: null,
      y: null,
      y2: null
    }), _defineProperty(this, "xs", []), _defineProperty(this, "orient", {
      x: "bottom",
      y: "left",
      y2: "right",
      subX: "bottom"
    }), this.owner = owner, this.setOrient();
  }

  var _proto = Axis.prototype;
  return _proto.getAxisClassName = function getAxisClassName(id) {
    return config_classes.axis + " " + config_classes["axis" + capitalize(id)];
  }, _proto.isHorizontal = function isHorizontal($$, forHorizontal) {
    var isRotated = $$.config.axis_rotated;
    return forHorizontal ? isRotated : !isRotated;
  }, _proto.isCategorized = function isCategorized() {
    var _this$owner = this.owner,
        config = _this$owner.config,
        state = _this$owner.state;
    return config.axis_x_type.indexOf("category") >= 0 || state.hasRadar;
  }, _proto.isCustomX = function isCustomX() {
    var config = this.owner.config;
    return !this.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
  }, _proto.isTimeSeries = function isTimeSeries(id) {
    id === void 0 && (id = "x");
    var config = this.owner.config;
    return config["axis_" + id + "_type"] === "timeseries";
  }, _proto.isTimeSeriesY = function isTimeSeriesY() {
    return this.isTimeSeries("y");
  }, _proto.init = function init() {
    var _this = this,
        $$ = this.owner,
        config = $$.config,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        axis = _$$$$el.axis,
        clip = $$.state.clip,
        isRotated = config.axis_rotated,
        target = ["x", "y"];

    config.axis_y2_show && target.push("y2"), target.forEach(function (v) {
      var classAxis = _this.getAxisClassName(v),
          classLabel = config_classes["axis" + v.toUpperCase() + "Label"];

      axis[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
        var res = null;
        return v === "x" ? res = clip.pathXAxis : v === "y" && config.axis_y_inner && (res = clip.pathYAxis), res;
      }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_" + v + "_show"] ? "visible" : "hidden"), axis[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", function () {
        return _this.textAnchorForAxisLabel(v);
      }), _this.generateAxes(v);
    });
  }
  /**
   * Set axis orient according option value
   * @private
   */
  , _proto.setOrient = function setOrient() {
    var $$ = this.owner,
        _$$$config = $$.config,
        isRotated = _$$$config.axis_rotated,
        yInner = _$$$config.axis_y_inner,
        y2Inner = _$$$config.axis_y2_inner;
    this.orient = {
      x: isRotated ? "left" : "bottom",
      y: isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left",
      y2: isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right",
      subX: isRotated ? "left" : "bottom"
    };
  }
  /**
   * Generate axes
   * It's used when axis' axes option is set
   * @param {string} id Axis id
   * @private
   */
  , _proto.generateAxes = function generateAxes(id) {
    var d3Axis,
        $$ = this.owner,
        config = $$.config,
        axes = [],
        axesConfig = config["axis_" + id + "_axes"],
        isRotated = config.axis_rotated;
    id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
      var tick = v.tick || {},
          scale = $$.scale[id].copy();
      v.domain && scale.domain(v.domain), axes.push(d3Axis(scale).ticks(tick.count).tickFormat(isFunction(tick.format) ? tick.format.bind($$.api) : function (x) {
        return x;
      }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
    }), this.axesList[id] = axes;
  }
  /**
   * Update axes nodes
   * @private
   */
  , _proto.updateAxes = function updateAxes() {
    var _this2 = this,
        $$ = this.owner,
        config = $$.config,
        main = $$.$el.main;

    Object.keys(this.axesList).forEach(function (id) {
      var axesConfig = config["axis_" + id + "_axes"],
          scale = $$.scale[id].copy(),
          range = scale.range();

      _this2.axesList[id].forEach(function (v, i) {
        var axisRange = v.scale().range(); // adjust range value with the current
        // https://github.com/naver/billboard.js/issues/859

        range.every(function (v, i) {
          return v === axisRange[i];
        }) || v.scale().range(range);
        var className = _this2.getAxisClassName(id) + "-" + (i + 1),
            g = main.select("." + className.replace(/\s/, "."));
        g.empty() ? g = main.append("g").attr("class", className).style("visibility", config["axis_" + id + "_show"] ? "visible" : "hidden").call(v) : (axesConfig[i].domain && scale.domain(axesConfig[i].domain), _this2.x.helper.transitionise(g).call(v.scale(scale))), g.attr("transform", $$.getTranslate(id, i + 1));
      });
    });
  }
  /**
   * Set Axis & tick values
   * called from: updateScales()
   * @param {string} id Axis id string
   * @param {Array} args Arguments
   * @private
   */
  , _proto.setAxis = function setAxis(id) {
    id !== "subX" && (this.tick[id] = this.getTickValues(id));

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

    this[id] = this.getAxis.apply(this, [id].concat(args));
  } // called from : getMaxTickWidth()
  , _proto.getAxis = function getAxis(id, scale, outerTick, noTransition, noTickTextRotate) {
    var tickFormat,
        $$ = this.owner,
        config = $$.config,
        isX = /^(x|subX)$/.test(id),
        type = isX ? "x" : id,
        isCategory = isX && this.isCategorized(),
        orient = this.orient[id],
        tickTextRotate = noTickTextRotate ? 0 : $$.getAxisTickRotate(type);
    if (isX) tickFormat = $$.format.xAxisTick;else {
      var fn = config["axis_" + id + "_tick_format"];
      isFunction(fn) && (tickFormat = fn.bind($$.api));
    }
    var tickValues = this.tick[type],
        axisParams = mergeObj({
      outerTick: outerTick,
      noTransition: noTransition,
      config: config,
      id: id,
      tickTextRotate: tickTextRotate
    }, isX && {
      isCategory: isCategory,
      tickMultiline: config.axis_x_tick_multiline,
      tickWidth: config.axis_x_tick_width,
      tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
      orgXScale: $$.scale.x
    });
    isX || (axisParams.tickStepSize = config["axis_" + type + "_tick_stepSize"]);
    var axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.scale.zoom || scale).orient(orient);

    if (isX && this.isTimeSeries() && tickValues && !isFunction(tickValues)) {
      var _fn = parseDate.bind($$);

      tickValues = tickValues.map(function (v) {
        return _fn(v);
      });
    } else !isX && this.isTimeSeriesY() && ( // https://github.com/d3/d3/blob/master/CHANGES.md#time-intervals-d3-time
    axis.ticks(config.axis_y_tick_time_value), tickValues = null);

    tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
      return x + "%";
    }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1));
    var tickCount = config["axis_" + type + "_tick_count"];
    return tickCount && axis.ticks(tickCount), axis;
  }, _proto.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
    var values,
        $$ = this.owner,
        config = $$.config,
        fit = config.axis_x_tick_fit,
        count = config.axis_x_tick_count;
    return (fit || count && fit) && (values = $$.mapTargetsToUniqueXs(targets), this.isCategorized() && count > values.length && (count = values.length), values = this.generateTickValues(values, count, this.isTimeSeries())), axis ? axis.tickValues(values) : this.x && (this.x.tickValues(values), this.subX && this.subX.tickValues(values)), values;
  }, _proto.getId = function getId(id) {
    var _this$owner2 = this.owner,
        config = _this$owner2.config,
        scale = _this$owner2.scale,
        axis = config.data_axes[id];
    return axis && scale[axis] || (axis = "y"), axis;
  }, _proto.getXAxisTickFormat = function getXAxisTickFormat() {
    var currFormat,
        $$ = this.owner,
        config = $$.config,
        format = $$.format,
        tickFormat = config.axis_x_tick_format,
        isTimeSeries = this.isTimeSeries(),
        isCategorized = this.isCategorized();
    return tickFormat ? isFunction(tickFormat) ? currFormat = tickFormat.bind($$.api) : isTimeSeries && (currFormat = function (date) {
      return date ? format.axisTime(tickFormat)(date) : "";
    }) : currFormat = isTimeSeries ? format.defaultAxisTime : isCategorized ? $$.categoryName : function (v) {
      return v < 0 ? v.toFixed(0) : v;
    }, isFunction(currFormat) ? function (v) {
      return currFormat.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
    } : currFormat;
  }, _proto.getTickValues = function getTickValues(id) {
    var $$ = this.owner,
        tickValues = $$.config["axis_" + id + "_tick_values"],
        axis = $$[id + "Axis"];
    return (isFunction(tickValues) ? tickValues.call($$.api) : tickValues) || (axis ? axis.tickValues() : undefined);
  }, _proto.getLabelOptionByAxisId = function getLabelOptionByAxisId(id) {
    return this.owner.config["axis_" + id + "_label"];
  }, _proto.getLabelText = function getLabelText(id) {
    var option = this.getLabelOptionByAxisId(id);
    return isString(option) ? option : option ? option.text : null;
  }, _proto.setLabelText = function setLabelText(id, text) {
    var $$ = this.owner,
        config = $$.config,
        option = this.getLabelOptionByAxisId(id);
    isString(option) ? config["axis_" + id + "_label"] = text : option && (option.text = text);
  }, _proto.getLabelPosition = function getLabelPosition(id, defaultPosition) {
    var isRotated = this.owner.config.axis_rotated,
        option = this.getLabelOptionByAxisId(id),
        position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
        has = function (v) {
      return !!~position.indexOf(v);
    };

    return {
      isInner: has("inner"),
      isOuter: has("outer"),
      isLeft: has("left"),
      isCenter: has("center"),
      isRight: has("right"),
      isTop: has("top"),
      isMiddle: has("middle"),
      isBottom: has("bottom")
    };
  }, _proto.getAxisLabelPosition = function getAxisLabelPosition(id) {
    return this.getLabelPosition(id, id === "x" ? ["inner-top", "inner-right"] : ["inner-right", "inner-top"]);
  }, _proto.getLabelPositionById = function getLabelPositionById(id) {
    return this.getAxisLabelPosition(id);
  }, _proto.xForAxisLabel = function xForAxisLabel(id) {
    var $$ = this.owner,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        position = this.getAxisLabelPosition(id),
        x = position.isMiddle ? -height / 2 : 0;
    return this.isHorizontal($$, id !== "x") ? x = position.isLeft ? 0 : position.isCenter ? width / 2 : width : position.isBottom && (x = -height), x;
  }, _proto.dxForAxisLabel = function dxForAxisLabel(id) {
    var $$ = this.owner,
        position = this.getAxisLabelPosition(id),
        dx = position.isBottom ? "0.5em" : "0";
    return this.isHorizontal($$, id !== "x") ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
  }, _proto.textAnchorForAxisLabel = function textAnchorForAxisLabel(id) {
    var $$ = this.owner,
        position = this.getAxisLabelPosition(id),
        anchor = position.isMiddle ? "middle" : "end";
    return this.isHorizontal($$, id !== "x") ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
  }, _proto.dyForAxisLabel = function dyForAxisLabel(id) {
    var dy,
        $$ = this.owner,
        config = $$.config,
        isRotated = config.axis_rotated,
        isInner = this.getAxisLabelPosition(id).isInner,
        tickRotate = config["axis_" + id + "_tick_rotate"] ? $$.getHorizontalAxisHeight(id) : 0,
        maxTickWidth = this.getMaxTickWidth(id);

    if (id === "x") {
      var xHeight = config.axis_x_height;
      dy = isRotated ? isInner ? "1.2em" : -25 - maxTickWidth : isInner ? "-0.5em" : xHeight ? xHeight - 10 : tickRotate ? tickRotate - 10 : "3em";
    } else dy = {
      y: ["-0.5em", 10, "3em", "1.2em", 10],
      y2: ["1.2em", -20, "-2.2em", "-0.5em", 15]
    }[id], dy = isRotated ? isInner ? dy[0] : tickRotate ? tickRotate * (id === "y2" ? -1 : 1) - dy[1] : dy[2] : isInner ? dy[3] : (dy[4] + (config["axis_" + id + "_inner"] ? 0 : maxTickWidth + dy[4])) * (id === "y" ? -1 : 1);

    return dy;
  }, _proto.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
    var $$ = this.owner,
        config = $$.config,
        current = $$.state.current,
        _$$$$el2 = $$.$el,
        svg = _$$$$el2.svg,
        chart = _$$$$el2.chart,
        currentTickMax = current.maxTickWidths[id],
        maxWidth = 0;
    if (withoutRecompute || !config["axis_" + id + "_show"] || $$.filterTargetsToShow().length === 0) return currentTickMax.size;

    if (svg) {
      var isYAxis = /^y2?$/.test(id),
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          scale = $$.scale[id].copy().domain($$["get" + (isYAxis ? "Y" : "X") + "Domain"](targetsToShow, id)),
          domain = scale.domain();
      // do not compute if domain is same
      if (domain[0] === domain[1] || isArray(currentTickMax.domain) && currentTickMax.domain[0] === currentTickMax.domain[1]) return currentTickMax.size;
      currentTickMax.domain = domain;
      var axis = this.getAxis(id, scale, !1, !1, !0),
          tickCount = config["axis_" + id + "_tick_count"],
          tickValues = config["axis_" + id + "_tick_values"];
      !tickValues && tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? this.isTimeSeriesY() : this.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
      var dummy = chart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
      axis.create(dummy), dummy.selectAll("text").each(function (d, i) {
        var currentTextWidth = this.getBoundingClientRect().width;
        maxWidth = Math.max(maxWidth, currentTextWidth), id === "x" && (currentTickMax.ticks[i] = currentTextWidth);
      }), dummy.remove();
    }

    return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
  }, _proto.getXAxisTickTextY2Overflow = function getXAxisTickTextY2Overflow(defaultPadding) {
    var $$ = this.owner,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        xAxisTickRotate = $$.getAxisTickRotate("x");

    if ((axis.isCategorized() || axis.isTimeSeries()) && config.axis_x_tick_fit && !config.axis_x_tick_culling && !config.axis_x_tick_multiline && xAxisTickRotate > 0 && xAxisTickRotate < 90) {
      var widthWithoutCurrentPaddingLeft = state.current.width - $$.getCurrentPaddingLeft(),
          maxOverflow = this.getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft - defaultPadding),
          xAxisTickTextY2Overflow = Math.max(0, maxOverflow) + defaultPadding;
      // for display inconsistencies between browsers
      return Math.min(xAxisTickTextY2Overflow, widthWithoutCurrentPaddingLeft / 2);
    }

    return 0;
  }, _proto.getXAxisTickMaxOverflow = function getXAxisTickMaxOverflow(xAxisTickRotate, widthWithoutCurrentPaddingLeft) {
    for (var $$ = this.owner, axis = $$.axis, config = $$.config, state = $$.state, isTimeSeries = axis.isTimeSeries(), tickTextWidths = state.current.maxTickWidths.x.ticks, tickCount = tickTextWidths.length, _state$axis$x$padding = state.axis.x.padding, left = _state$axis$x$padding.left, right = _state$axis$x$padding.right, maxOverflow = 0, remaining = tickCount - (isTimeSeries && config.axis_x_tick_fit ? .5 : 0), i = 0; i < tickCount; i++) {
      var tickIndex = i + 1,
          rotatedTickTextWidth = Math.cos(Math.PI * xAxisTickRotate / 180) * tickTextWidths[i],
          ticksBeforeTickText = tickIndex - (isTimeSeries ? 1 : .5) + left;

      // Skip ticks if there are no ticks before them
      if (!(ticksBeforeTickText <= 0)) {
        var tickLength = (widthWithoutCurrentPaddingLeft - rotatedTickTextWidth) / ticksBeforeTickText;
        maxOverflow = Math.max(maxOverflow, rotatedTickTextWidth - tickLength / 2 - ((remaining - tickIndex) * tickLength + right * tickLength));
      }
    }

    var tickOffset = 0;

    if (!isTimeSeries) {
      var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])().domain([left * -1, $$.getXDomainMax($$.data.targets) + 1 + right]).range([0, widthWithoutCurrentPaddingLeft - maxOverflow]);
      tickOffset = Math.ceil((scale(1) - scale(0)) / 2);
    }

    return maxOverflow + tickOffset;
  }
  /**
   * Get x Axis padding
   * @param {number} tickCount Tick count
   * @returns {object} Padding object values with 'left' & 'right' key
   * @private
   */
  , _proto.getXAxisPadding = function getXAxisPadding(tickCount) {
    var $$ = this.owner,
        padding = $$.config.axis_x_padding;

    if (isEmpty(padding) ? padding = {
      left: 0,
      right: 0
    } : (padding.left = padding.left || 0, padding.right = padding.right || 0), $$.axis.isTimeSeries()) {
      var firstX = +$$.getXDomainMin($$.data.targets),
          lastX = +$$.getXDomainMax($$.data.targets),
          timeDiff = lastX - firstX,
          range = timeDiff + padding.left + padding.right,
          relativeTickWidth = timeDiff / tickCount / range,
          left = padding.left / range / relativeTickWidth || 0,
          _right = padding.right / range / relativeTickWidth || 0;

      padding = {
        left: left,
        right: _right
      };
    }

    return padding;
  }, _proto.updateLabels = function updateLabels(withTransition) {
    var _this3 = this,
        $$ = this.owner,
        main = $$.$el.main,
        labels = {
      x: main.select("." + config_classes.axisX + " ." + config_classes.axisXLabel),
      y: main.select("." + config_classes.axisY + " ." + config_classes.axisYLabel),
      y2: main.select("." + config_classes.axisY2 + " ." + config_classes.axisY2Label)
    };

    Object.keys(labels).filter(function (id) {
      return !labels[id].empty();
    }).forEach(function (v) {
      var node = labels[v];
      (withTransition ? node.transition() : node).attr("x", function () {
        return _this3.xForAxisLabel(v);
      }).attr("dx", function () {
        return _this3.dxForAxisLabel(v);
      }).attr("dy", function () {
        return _this3.dyForAxisLabel(v);
      }).text(function () {
        return _this3.getLabelText(v);
      });
    });
  }, _proto.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
    var p = isNumber(padding) ? padding : padding[key];
    return isValue(p) ? this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
  }, _proto.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
    var $$ = this.owner,
        config = $$.config,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        length = config.axis_rotated ? width : height;
    return domainLength * (pixels / length);
  }, _proto.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
    var tickValues = values;

    if (tickCount) {
      var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

      if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
        var tickValue,
            isCategorized = this.isCategorized(),
            count = targetCount - 2,
            start = values[0],
            end = values[values.length - 1];
        tickValues = [start];

        for (var i = 0; i < count; i++) tickValue = +start + (end - start) / (count + 1) * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : isCategorized ? Math.round(tickValue) : tickValue);

        tickValues.push(end);
      }
    }

    return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
      return a - b;
    })), tickValues;
  }, _proto.generateTransitions = function generateTransitions(duration) {
    var $$ = this.owner,
        axis = $$.$el.axis,
        _map = ["x", "y", "y2", "subX"].map(function (v) {
      var ax = axis[v];
      return ax && duration && (ax = ax.transition().duration(duration)), ax;
    }),
        axisX = _map[0],
        axisY = _map[1],
        axisY2 = _map[2],
        axisSubX = _map[3];

    return {
      axisX: axisX,
      axisY: axisY,
      axisY2: axisY2,
      axisSubX: axisSubX
    };
  }, _proto.redraw = function redraw(transitions, isHidden, isInit) {
    var _this4 = this,
        $$ = this.owner,
        config = $$.config,
        $el = $$.$el,
        opacity = isHidden ? "0" : "1";

    ["x", "y", "y2", "subX"].forEach(function (id) {
      var axis = _this4[id],
          $axis = $el.axis[id];
      axis && $axis && (!isInit && (axis.config.withoutTransition = !config.transition_duration), $axis.style("opacity", opacity), axis.create(transitions["axis" + capitalize(id)]));
    }), this.updateAxes();
  }
  /**
   * Redraw axis
   * @param {Array} targetsToShow targets data to be shown
   * @param {object} wth option object
   * @param {d3.Transition} transitions Transition object
   * @param {object} flow flow object
   * @param {boolean} isInit called from initialization
   * @private
   */
  , _proto.redrawAxis = function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
    var xDomainForZoom,
        _this5 = this,
        $$ = this.owner,
        config = $$.config,
        scale = $$.scale,
        $el = $$.$el,
        hasZoom = !!scale.zoom;

    !hasZoom && this.isCategorized() && targetsToShow.length === 0 && scale.x.domain([0, $el.axis.x.selectAll(".tick").size()]), scale.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : this.x && (this.x.tickValues([]), this.subX && this.subX.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = scale.x.orgDomain()), ["y", "y2"].forEach(function (key) {
      var axisScale = scale[key];

      if (axisScale) {
        var tickValues = config["axis_" + key + "_tick_values"],
            tickCount = config["axis_" + key + "_tick_count"];

        if (axisScale.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
          var _axis = $$.axis[key],
              domain = axisScale.domain();

          _axis.tickValues(_this5.generateTickValues(domain, domain.every(function (v) {
            return v === 0;
          }) ? 1 : tickCount, _this5.isTimeSeriesY()));
        }
      }
    }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length && this.setCulling(), wth.Y && (scale.subY && scale.subY.domain($$.getYDomain(targetsToShow, "y")), scale.subY2 && scale.subY2.domain($$.getYDomain(targetsToShow, "y2")));
  }
  /**
   * Set manual culling
   * @private
   */
  , _proto.setCulling = function setCulling() {
    var $$ = this.owner,
        config = $$.config,
        _$$$state3 = $$.state,
        clip = _$$$state3.clip,
        current = _$$$state3.current,
        $el = $$.$el;
    ["subX", "x", "y", "y2"].forEach(function (type) {
      var axis = $el.axis[type],
          id = type === "subX" ? "x" : type,
          toCull = config["axis_" + id + "_tick_culling"]; // subchart x axis should be aligned with x axis culling

      if (axis && toCull) {
        var intervalForCulling,
            tickText = axis.selectAll(".tick text"),
            tickValues = util_sortValue(tickText.data()),
            tickSize = tickValues.length,
            cullingMax = config["axis_" + id + "_tick_culling_max"];

        if (tickSize) {
          for (var i = 1; i < tickSize; i++) if (tickSize / i < cullingMax) {
            intervalForCulling = i;
            break;
          }

          tickText.each(function (d) {
            this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
          });
        } else tickText.style("display", "block"); // set/unset x_axis_tick_clippath


        if (type === "x") {
          var clipPath = current.maxTickWidths.x.clipPath ? clip.pathXAxisTickTexts : null;
          $el.svg.selectAll("." + config_classes.axisX + " .tick text").attr("clip-path", clipPath);
        }
      }
    });
  }, Axis;
}();
// CONCATENATED MODULE: ./src/ChartInternal/interactions/drag.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var interactions_drag = ({
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _state$dragStart = state.dragStart,
            sx = _state$dragStart[0],
            sy = _state$dragStart[1],
            mx = mouse[0],
            my = mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? state.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? state.height : Math.max(sy, my);
        main.select("." + config_classes.dragarea).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).filter(function (d) {
          return config.data_selection_isselectable.bind($$.api)(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = +shape.attr("cx") * 1,
                y = +shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return; // @ts-ignore


          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (state.dragStart = mouse, main.select("." + config_classes.chart).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (main.select("." + config_classes.dragarea).transition().duration(100).style("opacity", "0").remove(), main.selectAll("." + config_classes.shape).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.state.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(46);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var interactions_flow = ({
  /**
   * Generate flow
   * @param {object} args option object
   * @returns {Function}
   * @private
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        data = $$.data,
        state = $$.state,
        $el = $$.$el;
    return function () {
      var flowLength = args.flow.length; // set flag

      state.flowing = !0, data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      }), $$.updateXGrid && $$.updateXGrid(!0);
      // target elements
      var elements = {};
      ["axis.x", "grid.x", "gridLines.x", "region.list", "text", "bar", "line", "area", "circle"].forEach(function (v) {
        var name = v.split("."),
            node = $el[name[0]];
        node && name.length > 1 && (node = node[name[1]]), node && node.size() && (elements[v] = node);
      }), $$.hideGridFocus(), $$.setFlowList(elements, args);
    };
  },

  /**
   * Set flow list
   * @param {object} elements Target elements
   * @param {object} args option object
   * @private
   */
  setFlowList: function setFlowList(elements, args) {
    var $$ = this,
        flow = args.flow,
        targets = args.targets,
        _flow = flow,
        _flow$duration = _flow.duration,
        duration = _flow$duration === void 0 ? args.duration : _flow$duration,
        flowIndex = _flow.index,
        flowLength = _flow.length,
        orgDataCount = _flow.orgDataCount,
        transform = $$.getFlowTransform(targets, orgDataCount, flowIndex, flowLength),
        wait = generateWait(),
        gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(duration);
    wait.add(Object.keys(elements).map(function (v) {
      var n = elements[v];
      return n = v === "axis.x" ? n.transition(gt).call(function (g) {
        return $$.axis.x.setTransition(gt).create(g);
      }) : v === "region.list" ? n.filter($$.isRegionOnX).transition(gt).attr("transform", transform) : n.transition(gt).attr("transform", transform), n;
    })), gt.call(wait, function () {
      $$.cleanUpFlow(elements, args);
    });
  },

  /**
   * Clean up flow
   * @param {object} elements Target elements
   * @param {object} args option object
   * @private
   */
  cleanUpFlow: function cleanUpFlow(elements, args) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        svg = $$.$el.svg,
        isRotated = config.axis_rotated,
        flow = args.flow,
        shape = args.shape,
        xv = args.xv,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        _flow2 = flow,
        _flow2$done = _flow2.done,
        done = _flow2$done === void 0 ? function () {} : _flow2$done,
        flowLength = _flow2.length;
    // draw again for removing flowed elements and reverting attr
    // callback for end of flow
    flowLength && (["circle", "text", "shape", "eventRect"].forEach(function (v) {
      var target = [];

      for (var i = 0; i < flowLength; i++) target.push("." + config_classes[v] + "-" + i);

      svg.selectAll("." + config_classes[v + "s"]) // circles, shapes, texts, eventRects
      .selectAll(target).remove();
    }), svg.select("." + config_classes.xgrid).remove()), Object.keys(elements).forEach(function (v) {
      var n = elements[v];
      if (v !== "axis.x" && n.attr("transform", null), v === "grid.x") n.attr(state.xgridAttr);else if (v === "gridLines.x") n.attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv);else if (v === "gridLines.x") n.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv), n.select("text").attr("x", isRotated ? state.width : 0).attr("y", xv);else if (/^(area|bar|line)$/.test(v)) n.attr("d", shape.type[v]);else if (v === "text") n.attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$));else if (v !== "circle") v === "region.list" && n.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$));else if ($$.isCirclePoint()) n.attr("cx", cx).attr("cy", cy);else {
        var xFunc = function (d) {
          return cx(d) - config.point_r;
        },
            yFunc = function (d) {
          return cy(d) - config.point_r;
        };

        n.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
        .attr("cy", cy);
      }
    }), config.interaction_enabled && $$.redrawEventRect(), done.call($$.api), state.flowing = !1;
  },

  /**
   * Get flow transform value
   * @param {object} targets target
   * @param {number} orgDataCount original data count
   * @param {number} flowIndex flow index
   * @param {number} flowLength flow length
   * @returns {string}
   * @private
   */
  getFlowTransform: function getFlowTransform(targets, orgDataCount, flowIndex, flowLength) {
    var translateX,
        $$ = this,
        data = $$.data,
        x = $$.scale.x,
        dataValues = data.targets[0].values,
        flowStart = $$.getValueOnIndex(dataValues, flowIndex),
        flowEnd = $$.getValueOnIndex(dataValues, flowIndex + flowLength),
        orgDomain = x.domain(),
        domain = $$.updateXDomain(targets, !0, !0);
    orgDataCount ? orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = x(orgDomain[0]) - x(domain[0]) : translateX = $$.axis.isTimeSeries() ? x(orgDomain[0]) - x(domain[0]) : x(flowStart.x) - x(flowEnd.x) : dataValues.length === 1 ? $$.axis.isTimeSeries() ? (flowStart = $$.getValueOnIndex(dataValues, 0), flowEnd = $$.getValueOnIndex(dataValues, dataValues.length - 1), translateX = x(flowStart.x) - x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = x(orgDomain[0]) - x(domain[0]);
    var scaleX = diffDomain(orgDomain) / diffDomain(domain);
    return "translate(" + translateX + ",0) scale(" + scaleX + ",1)";
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/eventrect.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var eventrect = ({
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.$el.main.select("." + config_classes.eventRects).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll("." + config_classes.eventRect).remove(), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), isMultipleX) eventRectUpdate = $el.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $el.eventRect
      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass && $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), eventRectUpdate = $el.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $el.eventRect = eventRectUpdate, $$.updateEventRect(eventRectUpdate), $$.state.inputType !== "touch" || $el.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        state = $$.state,
        svg = $$.$el.svg,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(" + config_classes.eventRect + "-?|s)", "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isboolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client" + (config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect(),
          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
        if (state.dragging || state.flowing || $$.hasArcType() || event.touches.length > 1) return;
        preventEvent(event), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }, !0).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || state.cancelClick) && state.cancelClick && (state.cancelClick = !1);
    }, !0);
  },

  /**
   * Updates the location and size of the eventRect.
   * @param {object} eventRectUpdate d3.select(CLASS.eventRects) object.
   * @private
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        xScale = scale.zoom || scale.x,
        eventRectData = eventRectUpdate || $$.$el.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = state.width, h = state.height;else {
      var rectW, rectX;
      if ($$.axis.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? state.height : state.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = d.x;
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? state.width : rectW, h = isRotated ? rectW : state.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || main.selectAll("." + config_classes.shape + "-" + index).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable.bind($$.api)(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config,
        _$$$$el = $$.$el,
        bar = _$$$$el.bar,
        circle = _$$$$el.circle;
    circle && config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), bar && $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if (state.mouseover && (!closest || closest.id !== state.mouseover.id) && (config.data_onout.call($$.api, state.mouseover), state.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.$el.svg.select("." + config_classes.eventRect).style("cursor", "pointer"), !state.mouseover && (config.data_onover.call($$.api, closest), state.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this,
        config = $$.config,
        _$$$$el2 = $$.$el,
        bar = _$$$$el2.bar,
        circle = _$$$$el2.circle,
        tooltip = _$$$$el2.tooltip;
    $$.$el.svg.select("." + config_classes.eventRect).style("cursor", null), $$.hideGridFocus(), tooltip && ($$.hideTooltip(), $$._handleLinkedCharts(!1)), circle && !config.point_focus_only && $$.unexpandCircles(), bar && $$.unexpandBars();
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @param {object} eventRectEnter d3.select(CLASS.eventRects) object.
   * @returns {object} d3.select(CLASS.eventRects) object.
   * @private
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return state.inputType === "mouse" && rect.on("mouseover", function (d) {
      state.dragging || state.flowing || $$.hasArcType() || config.tooltip_grouped && $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!(state.dragging || state.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.$el.svg.select("." + config_classes.eventRect + "-" + index);
        $$.isStepType(d) && config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.scale.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index), config.tooltip_grouped || $$.setOverOut(index !== -1, d.index);
      }
    }).on("mouseout", function (d) {
      !config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    if ($$.hasArcType() || !$$.toggleShape || state.cancelClick) return void (state.cancelClick && (state.cancelClick = !1));
    var index = d.index;
    main.selectAll("." + config_classes.shape + "-" + index).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.bind($$.api)(d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @param {object} eventRectEnter d3.select(CLASS.eventRects) object.
   * @returns {object} d3.select(CLASS.eventRects) object.
   * @private
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        inputType = _$$$state.inputType,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", width).attr("height", height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.$el.main.selectAll("." + config_classes.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll("." + config_classes.shape + "-" + closest.index).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.bind($$.api)(closest, this));
      });
    } // select if selection enabled

  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_subchart = ({
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        subchart = $$.$el.subchart,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.$el.svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.state.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = scale.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map(scale.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && subchart.main && subchart.main.select("." + config_classes.brush).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return (// @ts-ignore
        subchart.main ? subchart.main.select("." + config_classes.brush) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([])
      );
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        clip = _$$$state.clip,
        hasAxis = _$$$state.hasAxis,
        _$$$$el = $$.$el,
        defs = _$$$$el.defs,
        svg = _$$$$el.svg,
        subchart = _$$$$el.subchart,
        axis = _$$$$el.axis;

    if (hasAxis) {
      var visibility = config.subchart_show ? "visible" : "hidden",
          clipId = clip.id + "-subchart",
          clipPath = $$.getClipPath(clipId);
      clip.idSubchart = clipId, $$.appendClip(defs, clipId), $$.initBrush(), subchart.main = svg.append("g").attr("transform", $$.getTranslate("context"));
      var main = subchart.main;
      main.style("visibility", visibility), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars), main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), axis.subX = main.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subX")).attr("clip-path", config.axis_rotated ? "" : clip.pathXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
    }
  },

  /**
   * Update sub chart
   * @param {object} targets $$.data.targets
   * @private
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.subchart.main,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var barUpdate = main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", classChartBar),
          barEnter = barUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(barUpdate);
      barEnter.append("g").attr("class", classBars);
      // -- Line --//
      var lineUpdate = main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", classChartLine),
          lineEnter = lineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(lineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      lineEnter.append("g").attr("class", classLines), $$.hasType("area") && lineEnter.append("g").attr("class", classAreas), main.selectAll("." + config_classes.brush + " rect").attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? state.width2 : state.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @param {object} durationForExit Transition duration
   * @private
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.bar = subchart.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data($$.barData.bind($$)), subchart.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.bar = subchart.bar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge(subchart.bar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @param {string} drawBarOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   * @private
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var bar = this.$el.subchart.bar;
    (withTransition ? bar.transition(getRandom()).duration(duration) : bar).attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.line = subchart.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), subchart.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.line = subchart.line.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge(subchart.line).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {string} drawLineOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var line = this.$el.subchart.line;
    (withTransition ? line.transition(getRandom()).duration(duration) : line).attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @param {number} durationForExit Fade-out transition duration
   * @private
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.area = subchart.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), subchart.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.area = subchart.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge(subchart.area).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {string} drawAreaOnSub path in subchart line
   * @param {boolean} withTransition whether or not to transition
   * @param {number} duration transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var area = this.$el.subchart.area;
    (withTransition ? area.transition(getRandom()).duration(duration) : area).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.state.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {boolean} withSubchart whether or not to show subchart
   * @param {number} duration duration
   * @param {object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.subchart.main;
    main.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw" + name](shape.indices[v], !0);
      $$["update" + name + "ForSubchart"](duration), $$["redraw" + name + "ForSubchart"](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this,
        _$$$config = $$.config,
        onBrush = _$$$config.subchart_onbrush,
        withY = _$$$config.zoom_rescale,
        scale = $$.scale;
    $$.redraw({
      withTransition: !1,
      withY: withY,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), onBrush.bind($$.api)(scale.x.orgDomain());
  },

  /**
   * Transform context
   * @param {boolean} withTransition indicates transition is enabled
   * @param {object} transitions The return value of the generateTransitions method of Axis.
   * @private
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this,
        main = $$.$el.subchart.main;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = main.select("." + config_classes.axisX), withTransition && (subXAxis = subXAxis.transition())), main.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subX"));
  },

  /**
   * Get extent value
   * @returns {Array} default extent
   * @private
   */
  getExtent: function getExtent() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        extent = config.axis_x_extent;
    if (extent) if (isFunction(extent)) extent = extent.bind($$.api)($$.getXDomain($$.data.targets), scale.subX);else if ($$.axis.isTimeSeries() && extent.every(isNaN)) {
      var fn = parseDate.bind($$);
      extent = extent.map(function (v) {
        return scale.subX(fn(v));
      });
    }
    return extent;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var interactions_zoom = ({
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.scale.zoom = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent(bind) {
    bind === void 0 && (bind = !0);
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        zoomEnabled = config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = main.select("." + config_classes.eventRects);
    zoomEnabled && bind ? !config.subchart_show && $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        scale = $$.scale,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent
    // @ts-ignore
    // @ts-ignore

    /**
     * Update scale according zoom transform value
     * @param {object} transform transform object
     * @private
     */
    // @ts-ignore
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.scale.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      org.xScale && org.xScale.range(scale.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"](org.xScale || scale.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, org.xDomain), scale.zoom = $$.getCustomizedScale(newScale), $$.axis.x.scale(scale.zoom), rescale && (!org.xScale && (org.xScale = scale.x.copy()), scale.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        org = $$.org,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
        sourceEvent = event.sourceEvent;

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && (scale.zoom || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
      var isMousemove = sourceEvent.type === "mousemove",
          isZoomOut = sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && scale.x.domain().every(function (v, i) {
        return v !== org.xDomain[i];
      }) && scale.x.domain(org.xDomain), $$.zoom.updateTransformScale(transform), $$.axis.isCategorized() && scale.x.orgDomain()[0] === org.xDomain[0] && scale.x.domain([org.xDomain[0] - 1e-10, scale.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.state.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, scale.zoom.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        startEvent = $$.zoom.startEvent,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn(config.zoom_onzoomend, $$.api, scale[scale.zoom ? "zoom" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
   * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _org$xDomain = org.xDomain,
        min = _org$xDomain[0],
        max = _org$xDomain[1];
    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this,
        _$$$scale = $$.scale,
        subX = _$$$scale.subX,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom;

    if (zoom) {
      var zoomDomain = zoom.domain(),
          xDomain = subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.axis.x.scale(subX), x.domain(subX.orgDomain()), $$.scale.zoom = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @param {d3.selection} eventRects evemt <rect> element
   * @param {string} type zoom type
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var zoomRect,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      // @ts-ignore
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.$el.main.append("rect").attr("clip-path", state.clip.path).attr("class", config_classes.zoomBrush).attr("width", isRotated ? state.width : 0).attr("height", isRotated ? 0 : state.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      // @ts-ignore
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.scale.zoom || $$.scale.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event3 = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event3 ? [_event3.clientX, _event3.clientY] : [_event3.x, _event3.y],
            x = _ref2[0],
            y = _ref2[1],
            target = browser_doc.elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.$el.chart.append("div").classed(config_classes.button, !0).append("span").on("click", function () {
      isFunction(resetButton.onclick) && resetButton.onclick.bind($$.api)(this), $$.api.unzoom();
    }).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/clip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_clip = ({
  initClip: function initClip() {
    var $$ = this,
        clip = $$.state.clip;
    // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
    // Define 'clip-path' attribute values
    clip.id = $$.state.datetimeId + "-clip", clip.idXAxis = clip.id + "-xaxis", clip.idYAxis = clip.id + "-yaxis", clip.idGrid = clip.id + "-grid", clip.path = $$.getClipPath(clip.id), clip.pathXAxis = $$.getClipPath(clip.idXAxis), clip.pathYAxis = $$.getClipPath(clip.idYAxis), clip.pathGrid = $$.getClipPath(clip.idGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!win.navigator && win.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(" + (isIE9 ? "" : browser_doc.URL.split("#")[0]) + "#" + id + ")";
  },
  appendClip: function appendClip(parent, id) {
    id && parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    var margin = this.state.margin,
        left = Math.max(30, margin.left); // axis line width + padding for left

    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    var margin = this.state.margin;
    return forHorizontal ? -20 : -margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        _$$$state = $$.state,
        margin = _$$$state.margin,
        width = _$$$state.width,
        left = Math.max(30, margin.left),
        right = Math.max(30, margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? width + 2 + left + right : margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    var _this$state = this.state,
        margin = _this$state.margin,
        height = _this$state.height; // less than 20 is not enough to show the axis label 'outer' without legend

    return (forHorizontal ? margin.bottom : margin.top + height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  },
  updateXAxisTickClip: function updateXAxisTickClip() {
    var $$ = this,
        _$$$state2 = $$.state,
        clip = _$$$state2.clip,
        xAxisHeight = _$$$state2.xAxisHeight,
        defs = $$.$el.defs,
        newXAxisHeight = $$.getHorizontalAxisHeight("x");

    if (defs && !$$.clipXAxisTickTexts) {
      var clipId = $$.clipId + "-xaxisticktexts";
      $$.appendClip(defs, clipId), clip.pathXAxisTickTexts = $$.getClipPath(clip.idXAxisTickTexts), clip.idXAxisTickTexts = clipId;
    }

    !$$.config.axis_x_tick_multiline && $$.getAxisTickRotate("x") && newXAxisHeight !== xAxisHeight && ($$.setXAxisTickClipWidth(), $$.setXAxisTickTextClipPathWidth()), $$.state.xAxisHeight = newXAxisHeight;
  },
  setXAxisTickClipWidth: function setXAxisTickClipWidth() {
    var $$ = this,
        config = $$.config,
        maxTickWidths = $$.state.current.maxTickWidths,
        xAxisTickRotate = $$.getAxisTickRotate("x");

    if (!config.axis_x_tick_multiline && xAxisTickRotate) {
      var sinRotation = Math.sin(Math.PI / 180 * Math.abs(xAxisTickRotate));
      maxTickWidths.x.clipPath = ($$.getHorizontalAxisHeight("x") - 20) / sinRotation;
    } else maxTickWidths.x.clipPath = null;
  },
  setXAxisTickTextClipPathWidth: function setXAxisTickTextClipPathWidth() {
    var $$ = this,
        _$$$state3 = $$.state,
        clip = _$$$state3.clip,
        current = _$$$state3.current,
        svg = $$.$el.svg;
    svg && svg.select("#" + clip.idXAxisTickTexts + " rect").attr("width", current.maxTickWidths.x.clipPath).attr("height", 30);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
};

/**
 * Get grid text x value getter function
 * @param {boolean} isX Is x Axis
 * @param {number} width Width value
 * @param {number} height Height value
 * @returns {Function}
 * @private
 */
function getGridTextX(isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
}
/**
 * Update coordinate attributes value
 * @param {d3.selection} el Target node
 * @param {string} type Type
 * @private
 */


function smoothLines(el, type) {
  type === "grid" && el.each(function () {
    var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
    ["x1", "x2", "y1", "y2"].forEach(function (v) {
      return g.attr(v, Math.ceil(+g.attr(v)));
    });
  });
}

/* harmony default export */ var internals_grid = ({
  hasGrid: function hasGrid() {
    var config = this.config;
    return ["x", "y"].some(function (v) {
      return config["grid_" + v + "_show"] || config["grid_" + v + "_lines"].length;
    });
  },
  initGrid: function initGrid() {
    var $$ = this;
    $$.hasGrid() && $$.initGridLines(), $$.config.interaction_enabled && $$.initFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el;
    (config.grid_x_lines.length || config.grid_y_lines.length) && ($el.gridLines.main = $el.main.insert("g", "." + config_classes.chart + (config.grid_lines_front ? " + *" : "")).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid + " " + config_classes.gridLines), $el.gridLines.main.append("g").attr("class", config_classes.xgridLines), $el.gridLines.main.append("g").attr("class", config_classes.ygridLines), $el.gridLines.x = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        grid = _$$$$el.grid,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, scale.x),
        tickOffset = $$.axis.isCategorized() ? $$.axis.x.tickOffset() : 0,
        pos = function (d) {
      return (scale.zoom || scale.x)(d) + tickOffset * (isRotated ? -1 : 1);
    };

    state.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": state.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": state.height
    }, grid.x = main.select("." + config_classes.xgrids).selectAll("." + config_classes.xgrid).data(xgridData), grid.x.exit().remove(), grid.x = grid.x.enter().append("line").attr("class", config_classes.xgrid).merge(grid.x), withoutUpdate || grid.x.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys(state.xgridAttr).forEach(function (id) {
        grid.attr(id, state.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? state.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el2 = $$.$el,
        grid = _$$$$el2.grid,
        main = _$$$$el2.main,
        isRotated = config.axis_rotated,
        gridValues = $$.axis.y.tickValues() || $$.scale.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.scale.y(d));
    };

    grid.y = main.select("." + config_classes.ygrids).selectAll("." + config_classes.ygrid).data(gridValues), grid.y.exit().remove(), grid.y = grid.y.enter().append("line").attr("class", config_classes.ygrid).merge(grid.y), grid.y.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : state.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? state.height : pos), smoothLines(grid.y, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this,
        _$$$$el3 = $$.$el,
        grid = _$$$$el3.grid,
        gridLines = _$$$$el3.gridLines;
    // hide if arc type
    gridLines.main || $$.initGridLines(), grid.main.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.hideGridFocus(), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {number} duration Dration value
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$$el4 = $$.$el,
        gridLines = _$$$$el4.gridLines,
        main = _$$$$el4.main,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid();
    var xLines = main.select("." + config_classes.xgridLines).selectAll("." + config_classes.xgridLine).data(config.grid_x_lines); // exit

    xLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = xLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), xLines = xgridLine.merge(xLines), xLines.attr("class", function (d) {
      return (config_classes.xgridLine + " " + (d.class || "")).trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), gridLines.x = xLines;
  },

  /**
   * Update Y Grid lines
   * @param {number} duration Duration value
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        $el = $$.$el,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid();
    var ygridLines = $el.main.select("." + config_classes.ygridLines).selectAll("." + config_classes.ygridLine).data(config.grid_y_lines); // exit

    ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), ygridLines = ygridLine.merge(ygridLines);
    // update
    var yv = $$.yv.bind($$);
    ygridLines.attr("class", function (d) {
      return (config_classes.ygridLine + " " + (d.class || "")).trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? height : yv).transition().style("opacity", "1"), ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, width, height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), $el.gridLines.y = ygridLines;
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        gridLines = $$.$el.gridLines,
        xv = $$.xv.bind($$),
        lines = gridLines.x.select("line"),
        texts = gridLines.x.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, width, height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initFocusGrid: function initFocusGrid() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el,
        isFront = config.grid_front,
        className = "." + config_classes[isFront && $el.gridLines.main ? "gridLines" : "chart"] + (isFront ? " + *" : ""),
        grid = $el.main.insert("g", className).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid);
    $el.grid.main = grid, config.grid_x_show && grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && (grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus), config.grid_focus_y && !config.tooltip_grouped && grid.append("g").attr("class", config_classes.ygridFocus).append("line").attr("class", config_classes.ygridFocus));
  },

  /**
   * Show grid focus line
   * @param {Array} data Selected data
   * @private
   */
  showGridFocus: function showGridFocus(data) {
    var $$ = this,
        config = $$.config,
        _$$$state3 = $$.state,
        width = _$$$state3.width,
        height = _$$$state3.height,
        isRotated = config.axis_rotated,
        focusEl = $$.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus),
        dataToShow = (data || [focusEl.datum()]).filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    // Hide when bubble/scatter/stanford plot exists
    if (!(!config.tooltip_show || dataToShow.length === 0 || $$.hasType("bubble") || $$.hasArcType())) {
      var isEdge = config.grid_focus_edge && !config.tooltip_grouped,
          xx = $$.xx.bind($$);
      focusEl.style("visibility", "visible").data(dataToShow.concat(dataToShow)).each(function (d) {
        var xy,
            el = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            pos = {
          x: xx(d),
          y: $$.getYScaleById(d.id)(d.value)
        };
        if (el.classed(config_classes.xgridFocus)) xy = isRotated ? [null, // x1
        pos.x, // y1
        isEdge ? pos.y : width, // x2
        pos.x // y2
        ] : [pos.x, isEdge ? pos.y : null, pos.x, height];else {
          var isY2 = $$.axis.getId(d.id) === "y2";
          xy = isRotated ? [pos.y, // x1
          isEdge && !isY2 ? pos.x : null, // y1
          pos.y, // x2
          isEdge && isY2 ? pos.x : height // y2
          ] : [isEdge && isY2 ? pos.x : null, pos.y, isEdge && !isY2 ? pos.x : width, pos.y];
        }
        ["x1", "y1", "x2", "y2"].forEach(function (v, i) {
          return el.attr(v, xy[i]);
        });
      }), smoothLines(focusEl, "grid"), $$.showCircleFocus && $$.showCircleFocus(data);
    }
  },
  hideGridFocus: function hideGridFocus() {
    var $$ = this,
        inputType = $$.state.inputType,
        main = $$.$el.main;
    inputType === "mouse" && (main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus).style("visibility", "hidden"), $$.hideCircleFocus && $$.hideCircleFocus());
  },
  updateGridFocus: function updateGridFocus() {
    var $$ = this,
        _$$$state4 = $$.state,
        inputType = _$$$state4.inputType,
        width = _$$$state4.width,
        height = _$$$state4.height,
        resizing = _$$$state4.resizing,
        grid = $$.$el.grid,
        xgridFocus = grid.main.select("line." + config_classes.xgridFocus);
    if (inputType === "touch") xgridFocus.empty() ? resizing && $$.showCircleFocus() : $$.showGridFocus();else {
      var _isRotated = $$.config.axis_rotated;
      xgridFocus.attr("x1", _isRotated ? 0 : -10).attr("x2", _isRotated ? width : -10).attr("y1", _isRotated ? -10 : 0).attr("y2", _isRotated ? -10 : height);
    } // need to return 'true' as of being pushed to the redraw list
    // ref: getRedrawList()

    return !0;
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.$el.main.select("." + config_classes.axisX).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date(i + "-01-01 00:00:00"));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line.class === param.class) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.$el.main.select("." + classLines).selectAll("." + classLine).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_" + (forX ? "x" : "y") + "_lines";
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/region.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection



/* harmony default export */ var region = ({
  initRegion: function initRegion() {
    var $$ = this,
        $el = $$.$el;
    $el.region.main = $el.main.append("g").attr("clip-path", $$.state.clip.path).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $el.region.main || $$.initRegion(), $el.region.main.style("visibility", $$.hasArcType() ? "hidden" : "visible");
    // select <g> element
    var list = $el.main.select("." + config_classes.regions).selectAll("." + config_classes.region).data(config.regions);
    list.exit().transition().duration(duration).style("opacity", "0").remove(), list = list.enter().append("g").merge(list).attr("class", $$.classRegion.bind($$)), list.append("rect").style("fill-opacity", "0"), $el.region.list = list;
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.$el.region.list.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], pos = currScale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, pos = currScale($$.axis.isTimeSeries() ? parseDate.call($$, d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = state[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], end = currScale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, end = currScale($$.axis.isTimeSeries() ? parseDate.call($$, d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(47);

// CONCATENATED MODULE: ./src/ChartInternal/internals/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_selection = ({
  /**
   * Select a point
   * @param {object} target Target point
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @param {object} target Target point
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    // remove selected-circle from low layer g
    callFn(config.data_onunselected, $$.api, d, target.node()), $el.main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @param {boolean} selected whether or not to select.
   * @param {object} target Target object
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = (selected ? "" : "un") + "selectPoint";
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @param {object} target Target path
   * @param {object} d Data object
   * @private
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$.api, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {object} target Target path
   * @param {object} d Data object
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$.api, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @param {boolean} selected whether or not to select.
   * @param {object} target Target object
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  togglePath: function togglePath(selected, target, d, i) {
    this[(selected ? "" : "un") + "selectPath"](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @param {object} that shape
   * @param {object} d Data object
   * @returns {Function} toggle method
   * @private
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @param {object} that shape
   * @param {object} d Data object
   * @param {number} i Index number
   * @private
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable.bind($$.api)(d)) {
      if (!config.data_selection_multiple) {
        var selector = "." + config_classes.shapes;
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), main.selectAll(selector).selectAll("." + config_classes.shape).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/size.axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var size_axis = ({
  /**
   * Get Axis size according its position
   * @param {string} id Axis id value - x, y or y2
   * @returns {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        isRotated = $$.config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this;

    if ($$.axis) {
      var position = $$.axis && $$.axis.getLabelPositionById(id);
      return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
    }

    return 40;
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        _state = state,
        current = _state.current,
        rotatedPadding = _state.rotatedPadding,
        isLegendRight = _state.isLegendRight,
        isLegendInset = _state.isLegendInset,
        isRotated = config.axis_rotated,
        h = 30;
    if (id === "x" && !config.axis_x_show) return 8;
    if (id === "x" && config.axis_x_height) return config.axis_x_height;
    if (id === "y" && !config.axis_y_show) return !config.legend_show || isLegendRight || isLegendInset ? 1 : 10;
    if (id === "y2" && !config.axis_y2_show) return rotatedPadding.top;
    var rotate = $$.getAxisTickRotate(id); // Calculate x/y axis height when tick rotated

    return (id === "x" && !isRotated || /y2?/.test(id) && isRotated) && rotate && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - rotate) / 180), !config.axis_x_tick_multiline && current.height && h > current.height / 2 && (h = current.height / 2)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10);
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.axis.x.tickInterval());
  },

  /**
   * Get axis tick test rotate value
   * @param {string} id Axis id
   * @returns {number} rotate value
   * @private
   */
  getAxisTickRotate: function getAxisTickRotate(id) {
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        rotate = config["axis_" + id + "_tick_rotate"];

    if (id === "x") {
      var isCategorized = axis.isCategorized(),
          isTimeSeries = axis.isTimeSeries(),
          allowedXAxisTypes = isCategorized || isTimeSeries,
          tickCount = 0;
      config.axis_x_tick_fit && allowedXAxisTypes && (tickCount = state.current.maxTickWidths.x.ticks.length + (isTimeSeries ? -1 : 1), tickCount !== state.axis.x.tickCount && (state.axis.x.padding = $$.axis.getXAxisPadding(tickCount)), state.axis.x.tickCount = tickCount), $el.svg && config.axis_x_tick_fit && !config.axis_x_tick_multiline && !config.axis_x_tick_culling && config.axis_x_tick_autorotate && allowedXAxisTypes && (rotate = $$.needToRotateXAxisTickTexts() ? config.axis_x_tick_rotate : 0);
    }

    return rotate;
  },

  /**
   * Check weather axis tick text needs to be rotated
   * @returns {boolean}
   * @private
   */
  needToRotateXAxisTickTexts: function needToRotateXAxisTickTexts() {
    var $$ = this,
        _$$$state = $$.state,
        axis = _$$$state.axis,
        current = _$$$state.current,
        xAxisLength = current.width - $$.getCurrentPaddingLeft(!1) - $$.getCurrentPaddingRight(!0),
        tickCountWithPadding = axis.x.tickCount + axis.x.padding.left + axis.x.padding.right,
        maxTickWidth = $$.axis.getMaxTickWidth("x");
    return maxTickWidth > (xAxisLength / tickCountWithPadding || 0);
  }
});
// CONCATENATED MODULE: ./src/config/resolver/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Axis based chart
 */
// Chart









 // ChartInternal












var axis_api = [api_axis, api_category, api_flow, grid_x, grid_y, group, api_regions, api_selection, api_x, api_zoom];
var internal = [Axis_Axis, interactions_drag, interactions_flow, interactions_subchart, interactions_zoom, internals_clip, eventrect, internals_grid, region, internals_selection, size_axis];
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(48);

// CONCATENATED MODULE: ./src/ChartInternal/shape/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var shape_arc = ({
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        dataType = config.data_type,
        padding = config.pie_padding,
        startingAngle = config[dataType + "_startingAngle"] || 0,
        padAngle = ($$.hasType("pie") && padding ? padding * .01 : config[dataType + "_padAngle"]) || 0,
        sortValue = $$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().startAngle(startingAngle).endAngle(startingAngle + 2 * Math.PI).padAngle(padAngle).sortValues(sortValue).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width,
        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * config.gauge_arcs_minWidth;
    state.radiusExpanded = Math.min(state.arcWidth, state.arcHeight) / 2 * ($$.hasMultiArcGauge() ? .85 : 1), state.radius = state.radiusExpanded * .95, state.innerRadiusRatio = w ? (state.radius - w) / state.radius : .6, state.gaugeArcWidth = w || (gaugeArcWidth <= state.radius - state.innerRadius ? state.radius - state.innerRadius : gaugeArcWidth <= state.radius ? gaugeArcWidth : state.radius);
    var innerRadius = radius || (padding ? padding * (state.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    state.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? state.radius * state.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        innerRadius = $$.state.innerRadius;
    return !isNumber(innerRadius) && d && (innerRadius = innerRadius[d.data.id] || 0), innerRadius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded();
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;
    var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
        gStart = config.gauge_startingAngle;

    if (d.data && $$.isGaugeType(d.data) && !$$.hasMultiArcGauge()) {
      // to prevent excluding total data sum during the init(when data.hide option is used), use $$.rendered state value
      var totalSum = $$.getTotalDataSum(state.rendered); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    if (pie($$.filterTargetsToShow()).forEach(function (t, i) {
      found || t.data.id !== d.data.id || (found = !0, d = t, d.index = i);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), d.data && $$.hasMultiArcGauge()) {
      var maxValue = $$.getMinMaxData().max[0].value; // if gauge_max less than maxValue, make maxValue to max value

      maxValue > config.gauge_max && (config.gauge_max = maxValue);
      var gMin = config.gauge_min,
          gMax = config.gauge_max,
          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
      d.startAngle = gStart, d.endAngle = gStart + radius / (gMax - gMin) * gValue;
    }

    return found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        state = $$.state,
        ir = $$.getInnerRadius(),
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index : state.radius;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : isNumber(ir) ? ir : 0;
    }),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        state = $$.state,
        newRate = rate || 1,
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        expandWidth = Math.min(state.radiusExpanded * newRate - state.radius, singleArcWidth * .8 - (1 - newRate) * 100),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index + expandWidth : state.radiusExpanded * newRate;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : state.innerRadius;
    });
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? (hasMultiArcGauge ? arc : arc.innerRadius($$.getInnerRadius(d)))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        radius = _$$$state.radius,
        radiusExpanded = _$$$state.radiusExpanded,
        updated = $$.updateAngle(d),
        translate = "";
    if (updated) if ($$.hasMultiArcGauge()) {
      var y1 = Math.sin(updated.endAngle - Math.PI / 2),
          x = Math.cos(updated.endAngle - Math.PI / 2) * (radiusExpanded + 25),
          y = y1 * (radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
      translate = "translate(" + x + "," + y + ")";
    } else if (!$$.hasType("gauge") || $$.data.targets.length > 1) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio.bind($$.api)(d, radius, h) : ratio : radius && (h ? (36 / radius > .375 ? 1.175 - 36 / radius : .8) * radius / h : 0), translate = "translate(" + x * ratio + "," + y * ratio + ")";
    }
    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this,
        hasGauge = $$.hasType("gauge");
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          ratio = $$.getRatio("arc", updated),
          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var value = (updated || d).value,
            text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, d.data.id).toString();
        setTextValue(node, text, [-1, 1], hasGauge);
      } else node.text("");
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var $$ = this,
        config = $$.config,
        format = config.gauge_label_extents;
    return isFunction(format) ? format.bind($$.api)(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        $el = $$.$el;

    // MEMO: avoid to cancel transition
    if (transiting) {
      var interval = setInterval(function () {
        transiting || (clearInterval(interval), $el.legend.selectAll("." + config_classes.legendItemFocused).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $el.svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).each(function (d) {
      if ($$.shouldExpand(d.data.id)) {
        var expandDuration = $$.getExpandConfig(d.data.id, "duration"),
            svgArcExpandedSub = $$.getSvgArcExpanded($$.getExpandConfig(d.data.id, "rate"));
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        svg = $$.$el.svg;

    if (!transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).selectAll("path").transition().duration(function (d) {
        return $$.getExpandConfig(d.data.id, "duration");
      }).attr("d", $$.svgArc), svg.selectAll("" + config_classes.arc).style("opacity", "1");
    }
  },

  /**
   * Get expand config value
   * @param {string} id data ID
   * @param {string} key config key: 'duration | rate'
   * @returns {number}
   * @private
   */
  getExpandConfig: function getExpandConfig(id, key) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config[type + "_expand_" + key] : {
      duration: 50,
      rate: .98
    }[key];
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config[v + "_label_show"];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), isFunction(format) ? format.bind($$.api) : format;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config[type + "_title"] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.$el.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select("." + config_classes.chartArcs).selectAll("." + config_classes.chartArc).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this,
        $el = $$.$el;
    $el.arcs = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.$el.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arc).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), $$.hasMultiArcGauge() && $$.redrawMultiArcGauge(), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      state.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      var color;
      return $$.levelColor ? (color = $$.levelColor(d.data.values[0].value), config.data_colors[d.data.id] = color) : color = $$.color(d.data.id), color;
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call(endall, function () {
      if ($$.levelColor) {
        var path = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            d = path.datum();
        $$.updateLegendItemColor(d.data.id, path.style("fill"));
      }

      state.transiting = !1, callFn(config.onrendered, $$.api);
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  redrawMultiArcGauge: function redrawMultiArcGauge() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        arcLabelLines = $el.main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arcLabelLine).data($$.arcData.bind($$)),
        mainArcLabelLine = arcLabelLines.enter().append("rect").attr("class", function (d) {
      return config_classes.arcLabelLine + " " + config_classes.target + " " + config_classes.target + "-" + d.data.id;
    }).merge(arcLabelLines);
    mainArcLabelLine.style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
    }).style("display", config.gauge_label_show ? "" : "none").each(function (d) {
      var lineLength = 0,
          lineThickness = 2,
          x = 0,
          y = 0,
          transform = "";

      if (hiddenTargetIds.indexOf(d.data.id) < 0) {
        var updated = $$.updateAngle(d),
            innerLineLength = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
            lineAngle = updated.endAngle - Math.PI / 2,
            arcInnerRadius = state.radius - innerLineLength,
            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
        lineLength = state.radiusExpanded - state.radius + innerLineLength, x = Math.cos(linePositioningAngle) * arcInnerRadius, y = Math.sin(linePositioningAngle) * arcInnerRadius, transform = "rotate(" + lineAngle * 180 / Math.PI + ", " + x + ", " + y + ")";
      }

      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr("x", x).attr("y", y).attr("width", lineLength).attr("height", lineThickness).attr("transform", transform).style("stroke-dasharray", "0, " + (lineLength + lineThickness) + ", 0");
    });
  },
  bindArcEvent: function bindArcEvent(arc) {
    // eslint-disable-next-line
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    } // eslint-disable-next-line


    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        isMouse = state.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), config.data_onclick.bind($$.api)(arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!state.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.$el.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var text,
        $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        arcs = _$$$$el.arcs,
        hasGauge = $$.hasType("gauge"),
        hasMultiArcGauge = $$.hasMultiArcGauge();

    if (hasGauge && $$.data.targets.length === 1 && config.gauge_title || (text = main.selectAll("." + config_classes.chartArc).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ? Math.round(state.radius / 5) + "px" : null;
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    }), hasMultiArcGauge && text.attr("dy", "-.1em")), main.select("." + config_classes.chartArcsTitle).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          startAngle = -1 * Math.PI / 2,
          endAngle = (isFullCircle ? -4 : -1) * startAngle;
      isFullCircle && text && text.attr("dy", "" + Math.round(state.radius / 14));
      var backgroundArc = $$.$el.arcs.select((hasMultiArcGauge ? "g" : "") + "." + config_classes.chartArcsBackground);

      if (hasMultiArcGauge) {
        var index = 0;
        backgroundArc = backgroundArc.selectAll("path." + config_classes.chartArcsBackground).data($$.data.targets), backgroundArc.enter().append("path").attr("class", function (d, i) {
          return config_classes.chartArcsBackground + " " + config_classes.chartArcsBackground + "-" + i;
        }).merge(backgroundArc).attr("d", function (d1) {
          if (state.hiddenTargetIds.indexOf(d1.id) >= 0) return "M 0 0";
          var d = {
            data: [{
              value: config.gauge_max
            }],
            startAngle: startAngle,
            endAngle: endAngle,
            index: index++
          };
          return $$.getArc(d, !0, !0);
        }), backgroundArc.exit().remove();
      } else backgroundArc.attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: startAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      });

      arcs.select("." + config_classes.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && (arcs.select("." + config_classes.chartArcsGaugeMin).attr("dx", -1 * (state.innerRadius + (state.radius - state.innerRadius) / (isFullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && arcs.select("." + config_classes.chartArcsGaugeMax).attr("dx", state.innerRadius + (state.radius - state.innerRadius) / 2 + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.$el.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append($$.hasMultiArcGauge() ? "g" : "path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/area.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var ChartInternal_shape_area = ({
  initArea: function initArea(mainLineEnter) {
    var $$ = this;
    mainLineEnter.append("g").attr("class", $$.classAreas.bind($$));
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        defs = $$.$el.defs;
    $$.data.targets.forEach(function (d) {
      var id = datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id);

      if ($$.isAreaType(d) && defs.select("#" + id).empty()) {
        var color = $$.color(d),
            _config$area_linearGr = config.area_linearGradient,
            _config$area_linearGr2 = _config$area_linearGr.x,
            x = _config$area_linearGr2 === void 0 ? [0, 0] : _config$area_linearGr2,
            _config$area_linearGr3 = _config$area_linearGr.y,
            y = _config$area_linearGr3 === void 0 ? [0, 1] : _config$area_linearGr3,
            _config$area_linearGr4 = _config$area_linearGr.stops,
            stops = _config$area_linearGr4 === void 0 ? [[0, color, 1], [1, color, 0]] : _config$area_linearGr4,
            linearGradient = defs.append("linearGradient").attr("id", "" + id).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1].bind($$.api)(d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#" + $$.state.datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id) + ")" : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    config.area_linearGradient && $$.updateAreaGradient(), $el.area = $el.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), $el.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.area = $el.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($el.area), $el.area.style("opacity", state.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this,
        orgAreaOpacity = $$.state.orgAreaOpacity;
    return [(withTransition ? $$.$el.area.transition(getRandom()) : $$.$el.area).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? orgAreaOpacity / 1.75 : orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param {object} areaIndices Indices
   * @param {boolean} isSub Weather is sub axis
   * @returns {Function}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScale = $$.getYScaleById.bind($$),
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : $$.getShapeYMin(d.id));
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScale(d.id, isSub)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue) // @ts-ignore
        .y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.scale.x(values[0].x), y0 = $$.getYScaleById(d.id)(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        x = $$.getShapeX(0, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_shape_bar = ({
  initBar: function initBar() {
    var $el = this.$el;
    $el.bar = $el.main.select("." + config_classes.chart) // should positioned at the beginning of the shape node to not overlap others
    .insert("g", ":first-child").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$);
    $el.bar || $$.initBar();
    var mainBarUpdate = $$.$el.main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        $el = $$.$el,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $el.bar = $el.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data(barData), $el.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.bar = $el.bar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($el.bar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    var bar = this.$el.bar;
    return [(withTransition ? bar.transition(getRandom()) : bar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        maxDataCount = $$.getMaxDataCount(),
        isGrouped = config.data_groups.length,
        tickInterval = (scale.zoom || $$) && !$$.axis.isCategorized() ? $$.xx(scale.subX.domain()[1]) / maxDataCount : axis.tickInterval(maxDataCount),
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        main = $$.$el.main,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? main.selectAll("." + config_classes.bars + $$.getTargetSelectorSuffix(id)) : main).selectAll("." + config_classes.bar + suffix);
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a" + radius + "," + radius + " " + (isNegative ? "1 0 0" : "0 0 1") + " ";
        pathRadius[+!isRotated] = "" + arc + radius + "," + radius, pathRadius[+isRotated] = "" + arc + [-radius, radius][isRotated ? "sort" : "reverse"](), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H" + (points[1][indexX] - radius) + " " + pathRadius[0] + "V" + (points[2][indexY] - radius) + " " + pathRadius[1] + "H" + points[3][indexX] : "V" + (points[1][indexY] + (isNegative ? -radius : radius)) + " " + pathRadius[0] + "H" + (points[2][indexX] - radius) + " " + pathRadius[1] + "V" + points[3][indexY];
      return "M" + points[0][indexX] + "," + points[0][indexY] + path + "z";
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        axis = isSub ? $$.axis.subX : $$.axis.x,
        barTargetsNum = $$.getIndicesMax(barIndices) + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list = list,
        seg0 = _list[0],
        seg1 = _list[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var shape_bubble = ({
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value
   * @returns {number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        cacheKey = KEY.bubbleBaseLength,
        baseLength = $$.cache.get(cacheKey);
    return baseLength || $$.cache.add(cacheKey, baseLength = getMinMax("min", [width, height])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR.bind($$.api)(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  },

  /**
   * Get bubble dimension data
   * @param {object|Array} d data value
   * @param {string} type - y or z
   * @returns {number}
   * @private
   */
  getBubbleZData: function getBubbleZData(d, type) {
    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var ChartInternal_shape_line = ({
  initLine: function initLine() {
    var $el = this.$el;
    $el.line = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        $el = $$.$el,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classFocus = $$.classFocus.bind($$);
    $el.line || $$.initLine();
    var mainLineUpdate = $el.main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    // Areas
    mainLineEnter.append("g").attr("class", classLines), $$.hasTypeOf("Area") && $$.initArea(mainLineEnter);
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this,
        extraLineClasses = $$.format.extraLineClasses,
        $el = $$.$el;
    $el.line = $el.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), $el.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.line = $el.line.enter().append("path").attr("class", function (d) {
      return $$.classLine.bind($$)(d) + " " + (extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($el.line).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    var line = this.$el.line;
    return [(withTransition ? line.transition(getRandom()) : line).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @returns {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScale = $$.getYScaleById.bind($$),
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? scale.subX : scale.x;
    return function (d) {
      var path,
          y = yScale(d.id, isSub),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  // generateGetLinePoints(lineIndices, isSubValue?: boolean):Function { // partial duplication of generateGetBarPoints
  // 	const $$ = this;
  // 	const {config} = $$;
  // 	const isSub = !!isSubValue;
  // 	const x = $$.getShapeX(0, lineIndices, isSub);
  // 	const y = $$.getShapeY(isSub);
  // 	const lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub);
  // 	const yScale = $$.getYScaleById.bind($$);
  // 	return (d, i) => {
  // 		const y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id));
  // 		const offset = lineOffset(d, i) || y0; // offset is for stacked area chart
  // 		const posX = x(d);
  // 		let posY = y(d);
  // 		// fix posY not to overflow opposite quadrant
  // 		if (config.axis_rotated && (
  // 			(d.value > 0 && posY < y0) || (d.value < 0 && y0 < posY)
  // 		)) {
  // 			posY = y0;
  // 		}
  // 		// 1 point that marks the line position
  // 		const point = [posX, posY - (y0 - offset)];
  // 		return [
  // 			point,
  // 			point, // from here and below, needed for compatibility
  // 			point,
  // 			point
  // 		];
  // 	};
  // },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.axis.isTimeSeries(),
        xOffset = $$.axis.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? parseDate.call($$, v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M" + points[0][0] + "," + points[0][1] + "L" + points[1][0] + "," + points[1][1];
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          hasPrevData = prevData && isValue(prevData.value),
          style = isWithinRegions(data.x, regions);
      // https://github.com/naver/billboard.js/issues/1172
      if (isValue(data.value)) // Draw as normal
        if (isUndefined(regions) || !style || !hasPrevData) path += "" + (_i && hasPrevData ? "L" : "M") + xValue(data) + "," + yValue(data);else if (hasPrevData) {
          try {
            style = style.dasharray.split(" ");
          } catch (e) {
            style = dasharray.split(" ");
          } // Draw with region // TODO: Fix for horizotal charts


          xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
          var dx = x(data.x) - x(prevData.x),
              dy = y(data.value) - y(prevData.value),
              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = style[0] / dd, diffx2 = diff * style[1];

          for (var _j = diff; _j <= 1; _j += diffx2) path += sWithRegion(prevData, data, _j, diff), _j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
        }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        defs = $$.$el.defs;
    $$.data.targets.forEach(function (d) {
      var id = datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id);

      if ($$.isAreaType(d) && defs.select("#" + id).empty()) {
        var color = $$.color(d),
            _config$area_linearGr = config.area_linearGradient,
            _config$area_linearGr2 = _config$area_linearGr.x,
            x = _config$area_linearGr2 === void 0 ? [0, 0] : _config$area_linearGr2,
            _config$area_linearGr3 = _config$area_linearGr.y,
            y = _config$area_linearGr3 === void 0 ? [0, 1] : _config$area_linearGr3,
            _config$area_linearGr4 = _config$area_linearGr.stops,
            stops = _config$area_linearGr4 === void 0 ? [[0, color, 1], [1, color, 0]] : _config$area_linearGr4,
            linearGradient = defs.append("linearGradient").attr("id", "" + id).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1].bind($$.api)(d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#" + $$.state.datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id) + ")" : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    config.area_linearGradient && $$.updateAreaGradient(), $el.area = $el.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), $el.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.area = $el.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($el.area), $el.area.style("opacity", state.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this,
        orgAreaOpacity = $$.state.orgAreaOpacity;
    return [(withTransition ? $$.$el.area.transition(getRandom()) : $$.$el.area).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? orgAreaOpacity / 1.75 : orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param {object} areaIndices Indices
   * @param {boolean} isSub Weather is sub axis
   * @returns {Function}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScale = $$.getYScaleById.bind($$),
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScale(d.id, isSub)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : $$.getShapeYMin(d.id));
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScale(d.id, isSub)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue) // @ts-ignore
        .y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.scale.x(values[0].x), y0 = $$.getYScaleById(d.id)(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        x = $$.getShapeX(0, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var getTransitionName = function () {
  return getRandom();
};

/* harmony default export */ var shape_point = ({
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  initialOpacityForCircle: function initialOpacityForCircle(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
  },
  opacityForCircle: function opacityForCircle(d) {
    var config = this.config,
        opacity = config.point_show && !config.point_focus_only ? "1" : "0";
    return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
  },
  initCircle: function initCircle() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.point = $$.generatePoint(), config.point_show && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartCircles);
  },
  updateTargetForCircle: function updateTargetForCircle(t) {
    var $$ = this,
        config = $$.config,
        data = $$.data,
        $el = $$.$el;
    !$el.circle && config.point_show && $$.initCircle();
    var classCircles = $$.classCircles.bind($$),
        targets = (t || data.targets).filter(function (v) {
      return !$$.isBarType(v) && (!$$.isLineType(v) || $$.shouldDrawPointsForLine(v)) && $$.labelishData(v);
    }),
        mainCircle = $el.main.select("." + config_classes.chartCircles).style("pointer-events", "none").selectAll("." + config_classes.circles).data(targets).attr("class", classCircles),
        mainCircleEnter = mainCircle.enter();
    // Circles for each data point on lines
    // Update date for selected circles
    config.data_selection_enabled && mainCircleEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainCircleEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable.bind($$.api)(d) ? "pointer" : null;
    }), targets.forEach(function (t) {
      $el.main.selectAll("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll("" + config_classes.selectedCircle).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateCircle: function updateCircle() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        focusOnly = config.point_focus_only;

    if (config.point_show && !state.toggling) {
      var currIndex = focusOnly && $el.circle ? $el.circle.data()[0].index : 0,
          circles = $el.main.selectAll("." + config_classes.circles).selectAll("." + config_classes.circle).data(function (d) {
        return focusOnly ? [d.values[currIndex]] : d.values;
      });
      circles.exit().remove();
      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
      circles.enter().filter(function (d) {
        return d;
      }).append(fn).merge(circles).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$)), $el.circle = $el.main.selectAll("." + config_classes.circles + " ." + config_classes.circle);
    }
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        rendered = $$.state.rendered,
        _$$$$el = $$.$el,
        circle = _$$$$el.circle,
        main = _$$$$el.main,
        selectedCircles = main.selectAll("." + config_classes.selectedCircle);
    if (!$$.config.point_show) return [];
    var fn = $$.point("update", $$, cx, cy, $$.color, withTransition, flow, selectedCircles),
        posAttr = $$.isCirclePoint() ? "c" : "",
        t = getRandom(),
        opacityStyleFn = $$.opacityForCircle.bind($$),
        mainCircles = [];
    return circle.each(function (d) {
      var result = fn.bind(this)(d);
      result = (withTransition || !rendered ? result.transition(t) : result).style("opacity", opacityStyleFn), mainCircles.push(result);
    }), [mainCircles, selectedCircles.attr(posAttr + "x", cx).attr(posAttr + "y", cy)];
  },

  /**
   * Show focused data point circle
   * @param {object} d Selected data
   * @private
   */
  showCircleFocus: function showCircleFocus(d) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        hasRadar = _$$$state.hasRadar,
        resizing = _$$$state.resizing,
        toggling = _$$$state.toggling,
        transiting = _$$$state.transiting,
        $el = $$.$el,
        circle = $el.circle;

    if (transiting === !1 && config.point_focus_only && circle) {
      var cx = (hasRadar ? $$.radarCircleX : $$.circleX).bind($$),
          cy = (hasRadar ? $$.radarCircleY : $$.circleY).bind($$),
          withTransition = toggling || isUndefined(d),
          fn = $$.point("update", $$, cx, cy, $$.color, !resizing && withTransition);
      d && (circle = circle.filter(function (t) {
        var data = d.filter(function (v) {
          return v.id === t.id;
        });
        return !!data.length && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).datum(data[0]);
      })), circle.attr("class", this.updatePointClass.bind(this)).style("opacity", "1").each(function (d) {
        var id = d.id,
            index = d.index,
            value = d.value,
            visibility = "hidden";
        isValue(value) && (fn.bind(this)(d), $$.expandCircles(index, id), visibility = ""), this.style.visibility = visibility;
      });
    }
  },

  /**
   * Hide focused data point circle
   * @private
   */
  hideCircleFocus: function hideCircleFocus() {
    var $$ = this,
        config = $$.config,
        circle = $$.$el.circle;
    config.point_focus_only && circle && ($$.unexpandCircles(), circle.style("visibility", "hidden"));
  },
  circleX: function circleX(d) {
    return this.xx(d);
  },
  updateCircleY: function updateCircleY() {
    var $$ = this,
        getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), !1);

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? getPoints(d, i)[0][1] : $$.getYScaleById(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? $$.$el.main.selectAll("." + config_classes.circles + $$.getTargetSelectorSuffix(id)) : $$.$el.main).selectAll("." + config_classes.circle + suffix);
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(" + x + " " + y + ") scale(" + scale + ")");
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(" + r(circles) / $$.config.point_r + ")");
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR.bind($$.api)(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint(node) ? "c" : "",
        cx = +element.attr(prefix + "x"),
        cy = +element.attr(prefix + "y");

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _getBoundingRect = getBoundingRect(node),
          x = _getBoundingRect.x,
          y = _getBoundingRect.y;

      cx = x, cy = y;
    }

    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.$el.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.$el.defs.select("#" + id);
  },
  updatePointClass: function updatePointClass(d) {
    var $$ = this,
        circle = $$.$el.circle,
        pointClass = !1;
    return (isObject(d) || circle) && (pointClass = d === !0 ? circle.each(function (d) {
      var className = $$.classCircle.bind($$)(d);
      this.getAttribute("class").indexOf(config_classes.EXPANDED) > -1 && (className += " " + config_classes.EXPANDED), this.setAttribute("class", className);
    }) : $$.classCircle(d)), pointClass;
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = $$.getYScaleById.bind($$);
    return function (d, i) {
      var y0 = yScale.call($$, d.id)($$.getShapeYMin(d.id)),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ids.indexOf(id) < 0 && ids.push(id);
        var point = pattern[ids.indexOf(id) % pattern.length];
        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = datetimeId + "-point-" + id,
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  custom: {
    create: function create(element, id, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#" + id).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles && selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
        return yPosFn(d) - height / 2;
      }).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles && selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = getTransitionName();
        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles && selectedCircles.transition(getTransitionName());
      }

      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
        return yPosFn(d) - r;
      }).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
 * Get the position value
 * @param {boolean} isClockwise If the direction is clockwise
 * @param {string} type Coordinate type 'x' or 'y'
 * @param {number} edge Number of edge
 * @param {number} pos The indexed position
 * @param {number} range Range value
 * @param {number} ratio Ratio value
 * @returns {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = KEY.radarPoints;
/* harmony default export */ var ChartInternal_shape_radar = ({
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config,
        current = $$.state.current,
        $el = $$.$el;
    $$.hasType("radar") && ($el.radar = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartRadars), $el.radar.levels = $el.radar.append("g").attr("class", config_classes.levels), $el.radar.axes = $el.radar.append("g").attr("class", config_classes.axis), $el.radar.shapes = $el.radar.append("g").attr("class", config_classes.shapes), current.dataMax = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        arcWidth = _$$$state.arcWidth,
        arcHeight = _$$$state.arcHeight,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min(arcWidth, arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        width = _$$$getRadarSize[0],
        height = _$$$getRadarSize[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize2 = $$.getRadarSize(),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        points = $$.cache.get(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.cache.add(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(durationForExit) {
    var $$ = this,
        _$$$$el = $$.$el,
        radar = _$$$$el.radar,
        main = _$$$$el.main,
        translate = $$.getTranslate("radar");
    translate && (radar.attr("transform", translate), main.selectAll("." + config_classes.circles).attr("transform", translate), main.select("." + config_classes.chartTexts).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var points = this.cache.get(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radar = $$.$el.radar,
        _$$$getRadarSize3 = $$.getRadarSize(),
        width = _$$$getRadarSize3[0],
        height = _$$$getRadarSize3[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = radar.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = (config.radar_level_text_format || function () {}).bind($$.api),
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll("." + config_classes.level).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return config_classes.level + " " + config_classes.level + "-" + i;
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat(state.current.dataMax / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(" + (width - levelRatio[d]) + ", " + (height - levelRatio[d]) + ")";
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        radar = $$.$el.radar,
        _$$$getRadarSize4 = $$.getRadarSize(),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        categories = config.axis_x_categories,
        axis = radar.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return config_classes.axis + "-" + i;
    });

    // axis text
    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show) {
      var _config$radar_axis_te = config.radar_axis_text_position,
          _config$radar_axis_te2 = _config$radar_axis_te.x,
          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
          _config$radar_axis_te3 = _config$radar_axis_te.y,
          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
        selection.each(function (d) {
          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
        });
      }).datum(function (d, i) {
        return {
          index: i
        };
      }).attr("transform", function (d) {
        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(" + posX + " " + posY + ")";
      });
    }

    $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var $$ = this,
        config = $$.config,
        _$$$state2 = $$.state,
        inputType = _$$$state2.inputType,
        transiting = _$$$state2.transiting,
        _$$$$el2 = $$.$el,
        radar = _$$$$el2.radar,
        svg = _$$$$el2.svg,
        focusOnly = config.point_focus_only;

    if (config.interaction_enabled) {
      var isMouse = inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && ($$.hideTooltip(), focusOnly ? $$.hideCircleFocus() : $$.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      radar.axes.selectAll("text").on(isMouse ? "mouseover " : "touchstart", function () {
        if (!transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle(svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.cache.get(radar_cacheKey),
        areas = $$.$el.radar.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).style("fill", $$.color).style("stroke", $$.color).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {object} d Data object
   * @returns {number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/core.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */

 // eslint-disable-next-line no-use-before-define


var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {string} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "2.0.0-alpha",

  /**
   * Generate chart
   * @param {Options} config chart options
   * @memberof bb
   * @returns {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @returns {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {}
};
/**
 * @namespace bb
 * @version 2.0.0-alpha
 */
// CONCATENATED MODULE: ./src/index.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */


 // Axis

 // Shape









extend(ChartInternal_ChartInternal.prototype, [].concat(internal, [shape_arc, ChartInternal_shape_area, ChartInternal_shape_bar, shape_bubble, ChartInternal_shape_line, shape_point, ChartInternal_shape_radar])), extend(Chart_Chart.prototype, axis_api);

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi94bWwtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw0LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9odG1sLWVudGl0aWVzL2xpYi9odG1sNS1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9nbGV2ZWwvbGliL2xvZ2xldmVsLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvc2VuZE1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9yZWxvYWRBcHAuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9ob3QvZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL2NyZWF0ZVNvY2tldFVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXJsL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvZ2V0Q3VycmVudFNjcmlwdFNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdCBzeW5jIG5vbnJlY3Vyc2l2ZSBeXFwuXFwvbG9nJCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9sb2cuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYmlsbGJvYXJkLnNjc3M/MWI1ZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3Njc3MvYmlsbGJvYXJkLnNjc3MiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcyIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJjb21tb25qczJcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJhbWRcIjpcImQzLXRpbWUtZm9ybWF0XCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNlbGVjdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy1zZWxlY3Rpb25cIixcImFtZFwiOlwiZDMtc2VsZWN0aW9uXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWJydXNoXCIsXCJjb21tb25qczJcIjpcImQzLWJydXNoXCIsXCJhbWRcIjpcImQzLWJydXNoXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWRzdlwiLFwiY29tbW9uanMyXCI6XCJkMy1kc3ZcIixcImFtZFwiOlwiZDMtZHN2XCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWRyYWdcIixcImNvbW1vbmpzMlwiOlwiZDMtZHJhZ1wiLFwiYW1kXCI6XCJkMy1kcmFnXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNjYWxlXCIsXCJjb21tb25qczJcIjpcImQzLXNjYWxlXCIsXCJhbWRcIjpcImQzLXNjYWxlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXRyYW5zaXRpb25cIixcImNvbW1vbmpzMlwiOlwiZDMtdHJhbnNpdGlvblwiLFwiYW1kXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXNoYXBlXCIsXCJjb21tb25qczJcIjpcImQzLXNoYXBlXCIsXCJhbWRcIjpcImQzLXNoYXBlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLXpvb21cIixcImNvbW1vbmpzMlwiOlwiZDMtem9vbVwiLFwiYW1kXCI6XCJkMy16b29tXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWF4aXNcIixcImNvbW1vbmpzMlwiOlwiZDMtYXhpc1wiLFwiYW1kXCI6XCJkMy1heGlzXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWVhc2VcIixcImNvbW1vbmpzMlwiOlwiZDMtZWFzZVwiLFwiYW1kXCI6XCJkMy1lYXNlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWNvbG9yXCIsXCJjb21tb25qczJcIjpcImQzLWNvbG9yXCIsXCJhbWRcIjpcImQzLWNvbG9yXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wiY29tbW9uanNcIjpcImQzLWludGVycG9sYXRlXCIsXCJjb21tb25qczJcIjpcImQzLWludGVycG9sYXRlXCIsXCJhbWRcIjpcImQzLWludGVycG9sYXRlXCIsXCJyb290XCI6XCJkM1wifSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jbGFzc2VzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvU3RvcmUvRWxlbWVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL1N0b3JlL1N0YXRlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvU3RvcmUvU3RvcmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9tYWluLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9kYXRhL2RhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9jb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL2ludGVyYWN0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vbGVnZW5kLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vdGl0bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi90b29sdGlwLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9kYXRhL2F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2RhdGEvc2VsZWN0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9heGlzL3gudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2F4aXMveS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy95Mi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy9heGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3BvaW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vc3ViY2hhcnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi96b29tLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9hcmVhLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9iYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL2J1YmJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvbGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvc3BsaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9kb251dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvZ2F1Z2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL3BpZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvcmFkYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZS9icm93c2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvdXRpbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvT3B0aW9ucy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlL0NhY2hlLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvZ2VuZXJhdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvY29udmVydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9kYXRhL2RhdGEudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvZGF0YS9sb2FkLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2xhc3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NhdGVnb3J5LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9jb2xvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbnN0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9kb21haW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2Zvcm1hdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvbGVnZW5kLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9yZWRyYXcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3NjYWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL3NoYXBlLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zaXplLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy90ZXh0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy90aXRsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdG9vbHRpcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdHJhbnNmb3JtLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy90eXBlLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL0NoYXJ0SW50ZXJuYWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9jaGFydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2NvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2V4cG9ydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2ZvY3VzLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvbGVnZW5kLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvbG9hZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3Nob3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS90b29sdGlwLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9DaGFydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2Zsb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncmlkLngudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncmlkLnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncm91cC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3JlZ2lvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS94LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXNSZW5kZXJlckhlbHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXNSZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJhY3Rpb25zL2RyYWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJhY3Rpb25zL2Zsb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJhY3Rpb25zL2V2ZW50cmVjdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvc3ViY2hhcnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJhY3Rpb25zL3pvb20udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NsaXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2dyaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3JlZ2lvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvc2VsZWN0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zaXplLmF4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9yZXNvbHZlci9heGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL2FyYy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9hcmVhLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL2Jhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9idWJibGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvbGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9wb2ludC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9yYWRhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOlsiYXJjIiwiYXJjTGFiZWxMaW5lIiwiYXJjcyIsImFyZWEiLCJhcmVhcyIsImF4aXMiLCJheGlzWCIsImF4aXNYTGFiZWwiLCJheGlzWSIsImF4aXNZMiIsImF4aXNZMkxhYmVsIiwiYXhpc1lMYWJlbCIsImJhciIsImJhcnMiLCJicnVzaCIsImJ1dHRvbiIsImJ1dHRvblpvb21SZXNldCIsImNoYXJ0IiwiY2hhcnRBcmMiLCJjaGFydEFyY3MiLCJjaGFydEFyY3NCYWNrZ3JvdW5kIiwiY2hhcnRBcmNzR2F1Z2VNYXgiLCJjaGFydEFyY3NHYXVnZU1pbiIsImNoYXJ0QXJjc0dhdWdlVW5pdCIsImNoYXJ0QXJjc1RpdGxlIiwiY2hhcnRBcmNzR2F1Z2VUaXRsZSIsImNoYXJ0QmFyIiwiY2hhcnRCYXJzIiwiY2hhcnRDaXJjbGVzIiwiY2hhcnRMaW5lIiwiY2hhcnRMaW5lcyIsImNoYXJ0UmFkYXIiLCJjaGFydFJhZGFycyIsImNoYXJ0VGV4dCIsImNoYXJ0VGV4dHMiLCJjaXJjbGUiLCJjaXJjbGVzIiwiY29sb3JQYXR0ZXJuIiwiY29sb3JTY2FsZSIsImRlZm9jdXNlZCIsImRyYWdhcmVhIiwiZW1wdHkiLCJldmVudFJlY3QiLCJldmVudFJlY3RzIiwiZXZlbnRSZWN0c011bHRpcGxlIiwiZXZlbnRSZWN0c1NpbmdsZSIsImZvY3VzZWQiLCJnYXVnZVZhbHVlIiwiZ3JpZCIsImdyaWRMaW5lcyIsImxlZ2VuZCIsImxlZ2VuZEJhY2tncm91bmQiLCJsZWdlbmRJdGVtIiwibGVnZW5kSXRlbUV2ZW50IiwibGVnZW5kSXRlbUZvY3VzZWQiLCJsZWdlbmRJdGVtSGlkZGVuIiwibGVnZW5kSXRlbVBvaW50IiwibGVnZW5kSXRlbVRpbGUiLCJsZXZlbCIsImxldmVscyIsImxpbmUiLCJsaW5lcyIsIm1haW4iLCJyZWdpb24iLCJyZWdpb25zIiwic2VsZWN0ZWRDaXJjbGUiLCJzZWxlY3RlZENpcmNsZXMiLCJzaGFwZSIsInNoYXBlcyIsInN0YW5mb3JkRWxlbWVudHMiLCJzdGFuZm9yZExpbmUiLCJzdGFuZm9yZExpbmVzIiwic3RhbmZvcmRSZWdpb24iLCJzdGFuZm9yZFJlZ2lvbnMiLCJ0YXJnZXQiLCJ0ZXh0IiwidGV4dHMiLCJ0aXRsZSIsInRvb2x0aXAiLCJ0b29sdGlwQ29udGFpbmVyIiwidG9vbHRpcE5hbWUiLCJ4Z3JpZCIsInhncmlkRm9jdXMiLCJ4Z3JpZExpbmUiLCJ4Z3JpZExpbmVzIiwieGdyaWRzIiwieWdyaWQiLCJ5Z3JpZEZvY3VzIiwieWdyaWRMaW5lIiwieWdyaWRMaW5lcyIsInlncmlkcyIsInpvb21CcnVzaCIsInpvb21SZWN0IiwiRVhQQU5ERUQiLCJTRUxFQ1RFRCIsIklOQ0xVREVEIiwiVGV4dE92ZXJsYXBwaW5nIiwiRWxlbWVudCIsInN2ZyIsIngiLCJ5IiwieTIiLCJzdWJYIiwiZGVmcyIsInN1YmNoYXJ0IiwicmFkYXIiLCJsaXN0IiwiU3RhdGUiLCJ3aWR0aCIsIndpZHRoMiIsImhlaWdodCIsImhlaWdodDIiLCJtYXJnaW4iLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJtYXJnaW4yIiwibWFyZ2luMyIsImFyY1dpZHRoIiwiYXJjSGVpZ2h0IiwieEF4aXNIZWlnaHQiLCJoYXNBeGlzIiwiaGFzUmFkYXIiLCJjdXJyZW50IiwiZGF0YU1heCIsIm1heFRpY2tXaWR0aHMiLCJzaXplIiwidGlja3MiLCJjbGlwUGF0aCIsImRvbWFpbiIsInR5cGVzIiwiaXNMZWdlbmRSaWdodCIsImlzTGVnZW5kSW5zZXQiLCJpc0xlZ2VuZFRvcCIsImlzTGVnZW5kTGVmdCIsImxlZ2VuZFN0ZXAiLCJsZWdlbmRJdGVtV2lkdGgiLCJsZWdlbmRJdGVtSGVpZ2h0IiwibGVnZW5kSGFzUmVuZGVyZWQiLCJwYWRkaW5nIiwidGlja0NvdW50Iiwicm90YXRlZFBhZGRpbmciLCJ3aXRob3V0RmFkZUluIiwiaW5wdXRUeXBlIiwiZGF0ZXRpbWVJZCIsImNsaXAiLCJpZCIsImlkWEF4aXMiLCJpZFlBeGlzIiwiaWRYQXhpc1RpY2tUZXh0cyIsImlkR3JpZCIsImlkU3ViY2hhcnQiLCJwYXRoIiwicGF0aFhBeGlzIiwicGF0aFlBeGlzIiwicGF0aFhBeGlzVGlja1RleHRzIiwicGF0aEdyaWQiLCJkcmFnU3RhcnQiLCJkcmFnZ2luZyIsImZsb3dpbmciLCJjYW5jZWxDbGljayIsIm1vdXNlb3ZlciIsInJlbmRlcmVkIiwidHJhbnNpdGluZyIsInJlc2l6aW5nIiwidG9nZ2xpbmciLCJoYXNOZWdhdGl2ZVZhbHVlIiwiaGFzUG9zaXRpdmVWYWx1ZSIsIm9yZ0FyZWFPcGFjaXR5IiwiaGlkZGVuVGFyZ2V0SWRzIiwiaGlkZGVuTGVnZW5kSWRzIiwiZm9jdXNlZFRhcmdldElkcyIsImRlZm9jdXNlZFRhcmdldElkcyIsInJhZGl1cyIsImlubmVyUmFkaXVzIiwiaW5uZXJSYWRpdXNSYXRpbyIsImdhdWdlQXJjV2lkdGgiLCJyYWRpdXNFeHBhbmRlZCIsInhncmlkQXR0ciIsIngxIiwieDIiLCJ5MSIsImNsYXNzZXMiLCJlbGVtZW50Iiwic3RhdGUiLCJTdG9yZSIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwidiIsImdldFN0b3JlIiwibmFtZSIsImJpbmR0byIsImJhY2tncm91bmQiLCJzdmdfY2xhc3NuYW1lIiwidW5kZWZpbmVkIiwic2l6ZV93aWR0aCIsInNpemVfaGVpZ2h0IiwicGFkZGluZ19sZWZ0IiwicGFkZGluZ19yaWdodCIsInBhZGRpbmdfdG9wIiwicGFkZGluZ19ib3R0b20iLCJyZXNpemVfYXV0byIsIm9ub3ZlciIsIm9ub3V0Iiwib25yZXNpemUiLCJvbnJlc2l6ZWQiLCJvbmJlZm9yZWluaXQiLCJvbmluaXQiLCJvbmFmdGVyaW5pdCIsIm9ucmVuZGVyZWQiLCJ0cmFuc2l0aW9uX2R1cmF0aW9uIiwic2NhdHRlcl96ZXJvYmFzZWQiLCJwbHVnaW5zIiwicmVuZGVyIiwiZGF0YV9pZENvbnZlcnRlciIsImRhdGFfbmFtZXMiLCJkYXRhX2NsYXNzZXMiLCJkYXRhX3R5cGUiLCJkYXRhX3R5cGVzIiwiZGF0YV9vcmRlciIsImRhdGFfY29sb3IiLCJkYXRhX2NvbG9ycyIsImRhdGFfaGlkZSIsImRhdGFfZmlsdGVyIiwiZGF0YV9vbmNsaWNrIiwiZGF0YV9vbm92ZXIiLCJkYXRhX29ub3V0IiwiZGF0YV9vbm1pbiIsImRhdGFfb25tYXgiLCJkYXRhX3VybCIsImRhdGFfaGVhZGVycyIsImRhdGFfanNvbiIsImRhdGFfcm93cyIsImRhdGFfY29sdW1ucyIsImRhdGFfbWltZVR5cGUiLCJkYXRhX2tleXMiLCJkYXRhX2VtcHR5X2xhYmVsX3RleHQiLCJjb2xvcl9wYXR0ZXJuIiwiY29sb3JfdGlsZXMiLCJjb2xvcl90aHJlc2hvbGQiLCJjb2xvcl9vbm92ZXIiLCJpbnRlcmFjdGlvbl9lbmFibGVkIiwiaW50ZXJhY3Rpb25fYnJpZ2h0ZW4iLCJpbnRlcmFjdGlvbl9pbnB1dFR5cGVfbW91c2UiLCJpbnRlcmFjdGlvbl9pbnB1dFR5cGVfdG91Y2giLCJsZWdlbmRfc2hvdyIsImxlZ2VuZF9oaWRlIiwibGVnZW5kX2NvbnRlbnRzX2JpbmR0byIsImxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZSIsImxlZ2VuZF9wb3NpdGlvbiIsImxlZ2VuZF9pbnNldF9hbmNob3IiLCJsZWdlbmRfaW5zZXRfeCIsImxlZ2VuZF9pbnNldF95IiwibGVnZW5kX2luc2V0X3N0ZXAiLCJsZWdlbmRfaXRlbV9vbmNsaWNrIiwibGVnZW5kX2l0ZW1fb25vdmVyIiwibGVnZW5kX2l0ZW1fb25vdXQiLCJsZWdlbmRfZXF1YWxseSIsImxlZ2VuZF9wYWRkaW5nIiwibGVnZW5kX2l0ZW1fdGlsZV93aWR0aCIsImxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0IiwibGVnZW5kX3VzZVBvaW50IiwidGl0bGVfdGV4dCIsInRpdGxlX3BhZGRpbmciLCJ0aXRsZV9wb3NpdGlvbiIsInRvb2x0aXBfc2hvdyIsInRvb2x0aXBfZG9Ob3RIaWRlIiwidG9vbHRpcF9ncm91cGVkIiwidG9vbHRpcF9mb3JtYXRfdGl0bGUiLCJ0b29sdGlwX2Zvcm1hdF9uYW1lIiwidG9vbHRpcF9mb3JtYXRfdmFsdWUiLCJ0b29sdGlwX3Bvc2l0aW9uIiwidG9vbHRpcF9jb250ZW50cyIsInRvb2x0aXBfaW5pdF9zaG93IiwidG9vbHRpcF9pbml0X3giLCJ0b29sdGlwX2luaXRfcG9zaXRpb24iLCJ0b29sdGlwX2xpbmtlZCIsInRvb2x0aXBfbGlua2VkX25hbWUiLCJ0b29sdGlwX29uc2hvdyIsInRvb2x0aXBfb25oaWRlIiwidG9vbHRpcF9vbnNob3duIiwidG9vbHRpcF9vbmhpZGRlbiIsInRvb2x0aXBfb3JkZXIiLCJkYXRhX3giLCJkYXRhX3hzIiwiZGF0YV94Rm9ybWF0IiwiZGF0YV94TG9jYWx0aW1lIiwiZGF0YV94U29ydCIsImRhdGFfZ3JvdXBzIiwiZGF0YV9heGVzIiwiZGF0YV9sYWJlbHMiLCJkYXRhX2xhYmVsc19jb2xvcnMiLCJkYXRhX2xhYmVsc19wb3NpdGlvbiIsImRhdGFfcmVnaW9ucyIsImRhdGFfc3RhY2tfbm9ybWFsaXplIiwiZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCIsImRhdGFfc2VsZWN0aW9uX2dyb3VwZWQiLCJkYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUiLCJkYXRhX3NlbGVjdGlvbl9tdWx0aXBsZSIsImRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZSIsImRhdGFfb25zZWxlY3RlZCIsImRhdGFfb251bnNlbGVjdGVkIiwiYXhpc194X2NsaXBQYXRoIiwiYXhpc194X3Nob3ciLCJheGlzX3hfdHlwZSIsImF4aXNfeF9sb2NhbHRpbWUiLCJheGlzX3hfY2F0ZWdvcmllcyIsImF4aXNfeF90aWNrX2NlbnRlcmVkIiwiYXhpc194X3RpY2tfZm9ybWF0IiwiYXhpc194X3RpY2tfY3VsbGluZyIsImF4aXNfeF90aWNrX2N1bGxpbmdfbWF4IiwiYXhpc194X3RpY2tfY291bnQiLCJheGlzX3hfdGlja19zaG93IiwiYXhpc194X3RpY2tfdGV4dF9zaG93IiwiYXhpc194X3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeF90aWNrX2ZpdCIsImF4aXNfeF90aWNrX3ZhbHVlcyIsImF4aXNfeF90aWNrX2F1dG9yb3RhdGUiLCJheGlzX3hfdGlja19yb3RhdGUiLCJheGlzX3hfdGlja19vdXRlciIsImF4aXNfeF90aWNrX211bHRpbGluZSIsImF4aXNfeF90aWNrX3dpZHRoIiwiYXhpc194X3RpY2tfdG9vbHRpcCIsImF4aXNfeF9tYXgiLCJheGlzX3hfbWluIiwiYXhpc194X3BhZGRpbmciLCJheGlzX3hfaGVpZ2h0IiwiYXhpc194X2V4dGVudCIsImF4aXNfeF9sYWJlbCIsImF4aXNfeF9heGVzIiwiYXhpc195X2NsaXBQYXRoIiwiYXhpc195X3Nob3ciLCJheGlzX3lfdHlwZSIsImF4aXNfeV9tYXgiLCJheGlzX3lfbWluIiwiYXhpc195X2ludmVydGVkIiwiYXhpc195X2NlbnRlciIsImF4aXNfeV9pbm5lciIsImF4aXNfeV9sYWJlbCIsImF4aXNfeV90aWNrX2Zvcm1hdCIsImF4aXNfeV90aWNrX2N1bGxpbmciLCJheGlzX3lfdGlja19jdWxsaW5nX21heCIsImF4aXNfeV90aWNrX291dGVyIiwiYXhpc195X3RpY2tfdmFsdWVzIiwiYXhpc195X3RpY2tfcm90YXRlIiwiYXhpc195X3RpY2tfY291bnQiLCJheGlzX3lfdGlja19zaG93IiwiYXhpc195X3RpY2tfc3RlcFNpemUiLCJheGlzX3lfdGlja190ZXh0X3Nob3ciLCJheGlzX3lfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc195X3RpY2tfdGltZV92YWx1ZSIsImF4aXNfeV9wYWRkaW5nIiwiYXhpc195X2RlZmF1bHQiLCJheGlzX3lfYXhlcyIsImF4aXNfeTJfc2hvdyIsImF4aXNfeTJfbWF4IiwiYXhpc195Ml9taW4iLCJheGlzX3kyX2ludmVydGVkIiwiYXhpc195Ml9jZW50ZXIiLCJheGlzX3kyX2lubmVyIiwiYXhpc195Ml9sYWJlbCIsImF4aXNfeTJfdGlja19mb3JtYXQiLCJheGlzX3kyX3RpY2tfY3VsbGluZyIsImF4aXNfeTJfdGlja19jdWxsaW5nX21heCIsImF4aXNfeTJfdGlja19vdXRlciIsImF4aXNfeTJfdGlja192YWx1ZXMiLCJheGlzX3kyX3RpY2tfcm90YXRlIiwiYXhpc195Ml90aWNrX2NvdW50IiwiYXhpc195Ml90aWNrX3Nob3ciLCJheGlzX3kyX3RpY2tfc3RlcFNpemUiLCJheGlzX3kyX3RpY2tfdGV4dF9zaG93IiwiYXhpc195Ml90aWNrX3RleHRfcG9zaXRpb24iLCJheGlzX3kyX3BhZGRpbmciLCJheGlzX3kyX2RlZmF1bHQiLCJheGlzX3kyX2F4ZXMiLCJheGlzX3JvdGF0ZWQiLCJncmlkX3hfc2hvdyIsImdyaWRfeF90eXBlIiwiZ3JpZF94X2xpbmVzIiwiZ3JpZF95X3Nob3ciLCJncmlkX3lfbGluZXMiLCJncmlkX3lfdGlja3MiLCJncmlkX2ZvY3VzX2VkZ2UiLCJncmlkX2ZvY3VzX3Nob3ciLCJncmlkX2ZvY3VzX3kiLCJncmlkX2Zyb250IiwiZ3JpZF9saW5lc19mcm9udCIsInBvaW50X3Nob3ciLCJwb2ludF9yIiwicG9pbnRfc2Vuc2l0aXZpdHkiLCJwb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCIsInBvaW50X2ZvY3VzX2V4cGFuZF9yIiwicG9pbnRfZm9jdXNfb25seSIsInBvaW50X3BhdHRlcm4iLCJwb2ludF9zZWxlY3RfciIsInBvaW50X3R5cGUiLCJzdWJjaGFydF9zaG93Iiwic3ViY2hhcnRfc2l6ZV9oZWlnaHQiLCJzdWJjaGFydF9heGlzX3hfc2hvdyIsInN1YmNoYXJ0X2F4aXNfeF90aWNrX3Nob3ciLCJzdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3ciLCJzdWJjaGFydF9vbmJydXNoIiwiem9vbV9lbmFibGVkIiwiem9vbV9leHRlbnQiLCJ6b29tX3ByaXZpbGVnZWQiLCJ6b29tX3Jlc2NhbGUiLCJ6b29tX29uem9vbSIsInpvb21fb256b29tc3RhcnQiLCJ6b29tX29uem9vbWVuZCIsInpvb21fcmVzZXRCdXR0b24iLCJ6b29tX3hfbWluIiwiem9vbV94X21heCIsImFyZWFfemVyb2Jhc2VkIiwiYXJlYV9hYm92ZSIsImFyZWFfbGluZWFyR3JhZGllbnQiLCJiYXJfcGFkZGluZyIsImJhcl9yYWRpdXMiLCJiYXJfcmFkaXVzX3JhdGlvIiwiYmFyX3NlbnNpdGl2aXR5IiwiYmFyX3dpZHRoIiwiYmFyX3dpZHRoX3JhdGlvIiwiYmFyX3dpZHRoX21heCIsImJhcl96ZXJvYmFzZWQiLCJidWJibGVfbWF4UiIsImJ1YmJsZV96ZXJvYmFzZWQiLCJsaW5lX2Nvbm5lY3ROdWxsIiwibGluZV9zdGVwX3R5cGUiLCJsaW5lX3plcm9iYXNlZCIsImxpbmVfY2xhc3NlcyIsImxpbmVfcG9pbnQiLCJzcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlIiwiZG9udXRfbGFiZWxfc2hvdyIsImRvbnV0X2xhYmVsX2Zvcm1hdCIsImRvbnV0X2xhYmVsX3RocmVzaG9sZCIsImRvbnV0X2xhYmVsX3JhdGlvIiwiZG9udXRfd2lkdGgiLCJkb251dF90aXRsZSIsImRvbnV0X2V4cGFuZCIsImRvbnV0X2V4cGFuZF9yYXRlIiwiZG9udXRfZXhwYW5kX2R1cmF0aW9uIiwiZG9udXRfcGFkQW5nbGUiLCJkb251dF9zdGFydGluZ0FuZ2xlIiwiZ2F1Z2VfZnVsbENpcmNsZSIsImdhdWdlX2xhYmVsX3Nob3ciLCJnYXVnZV9sYWJlbF9mb3JtYXQiLCJnYXVnZV9sYWJlbF9leHRlbnRzIiwiZ2F1Z2VfbWluIiwiZ2F1Z2VfbWF4IiwiZ2F1Z2VfdHlwZSIsImdhdWdlX3N0YXJ0aW5nQW5nbGUiLCJNYXRoIiwiUEkiLCJnYXVnZV90aXRsZSIsImdhdWdlX3VuaXRzIiwiZ2F1Z2Vfd2lkdGgiLCJnYXVnZV9hcmNzX21pbldpZHRoIiwiZ2F1Z2VfZXhwYW5kIiwiZ2F1Z2VfZXhwYW5kX3JhdGUiLCJnYXVnZV9leHBhbmRfZHVyYXRpb24iLCJwaWVfbGFiZWxfc2hvdyIsInBpZV9sYWJlbF9mb3JtYXQiLCJwaWVfbGFiZWxfdGhyZXNob2xkIiwicGllX2xhYmVsX3JhdGlvIiwicGllX2V4cGFuZCIsInBpZV9leHBhbmRfcmF0ZSIsInBpZV9leHBhbmRfZHVyYXRpb24iLCJwaWVfaW5uZXJSYWRpdXMiLCJwaWVfcGFkQW5nbGUiLCJwaWVfcGFkZGluZyIsInBpZV9zdGFydGluZ0FuZ2xlIiwicmFkYXJfYXhpc19tYXgiLCJyYWRhcl9heGlzX2xpbmVfc2hvdyIsInJhZGFyX2F4aXNfdGV4dF9zaG93IiwicmFkYXJfYXhpc190ZXh0X3Bvc2l0aW9uIiwicmFkYXJfbGV2ZWxfZGVwdGgiLCJyYWRhcl9sZXZlbF9zaG93IiwicmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQiLCJ0b0ZpeGVkIiwicmFkYXJfbGV2ZWxfdGV4dF9zaG93IiwicmFkYXJfc2l6ZV9yYXRpbyIsInJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2UiLCJ3aW4iLCJkZWYiLCJvIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiIsImRvYyIsImRvY3VtZW50IiwiaXNWYWx1ZSIsImlzRnVuY3Rpb24iLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNVbmRlZmluZWQiLCJpc0RlZmluZWQiLCJpc2Jvb2xlYW4iLCJjZWlsMTAiLCJjZWlsIiwiYXNIYWxmUGl4ZWwiLCJuIiwiZGlmZkRvbWFpbiIsImQiLCJpc09iamVjdFR5cGUiLCJpc0VtcHR5IiwibGVuZ3RoIiwiRGF0ZSIsImlzTmFOIiwibm90RW1wdHkiLCJpc0FycmF5IiwiYXJyIiwiQXJyYXkiLCJpc09iamVjdCIsIm9iaiIsIm5vZGVUeXBlIiwiZ2V0T3B0aW9uIiwib3B0aW9ucyIsImtleSIsImRlZmF1bHRWYWx1ZSIsImhhc1ZhbHVlIiwiZGljdCIsInZhbHVlIiwiZm91bmQiLCJjYWxsRm4iLCJmbiIsImlzRm4iLCJhcmdzIiwiY2FsbCIsImVuZGFsbCIsInRyYW5zaXRpb24iLCJjYiIsImVhY2giLCJvbiIsImFwcGx5Iiwic2FuaXRpc2UiLCJzdHIiLCJyZXBsYWNlIiwic2V0VGV4dFZhbHVlIiwibm9kZSIsImR5IiwidG9NaWRkbGUiLCJpbmRleE9mIiwiZGlmZiIsIm1hcCIsIm11bHRpbGluZSIsInNwbGl0IiwibGVuIiwiaHRtbCIsImkiLCJhcHBlbmQiLCJhdHRyIiwiZ2V0UmVjdFNlZ0xpc3QiLCJnZXRCQm94IiwiZ2V0UGF0aEJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIml0ZW1zIiwibWluIiwiZ2V0QnJ1c2hTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCIkZWwiLCJldmVudCIsImQzRXZlbnQiLCJ0eXBlIiwic2VsZWN0IiwiQ0xBU1MiLCJkM0JydXNoU2VsZWN0aW9uIiwiZ2V0Qm91bmRpbmdSZWN0IiwicmVjdCIsImdldFJhbmRvbSIsImFzU3RyIiwicmFuZCIsInJhbmRvbSIsImJydXNoRW1wdHkiLCJjdHgiLCJleHRlbmQiLCJzb3VyY2UiLCJwIiwidGVzdCIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwidG9BcnJheSIsImdldENzc1J1bGVzIiwic3R5bGVTaGVldHMiLCJydWxlcyIsInNoZWV0IiwiY3NzUnVsZXMiLCJjb25jYXQiLCJlIiwiY29uc29sZSIsImVycm9yIiwiaHJlZiIsInRvU3RyaW5nIiwiZ2V0VHJhbnNsYXRpb24iLCJ0cmFuc2Zvcm0iLCJiYXNlVmFsIiwibnVtYmVyT2ZJdGVtcyIsImdldEl0ZW0iLCJtYXRyaXgiLCJhIiwiYiIsImMiLCJmIiwiZ2V0VW5pcXVlIiwiZGF0YSIsImlzRGF0ZSIsIk51bWJlciIsImZpbHRlciIsIm1lcmdlQXJyYXkiLCJyZWR1Y2UiLCJtZXJnZU9iaiIsIm9iamVjdE4iLCJzaGlmdCIsInNvcnRWYWx1ZSIsImlzQXNjIiwiZXZlcnkiLCJzb3J0IiwiZ2V0TWluTWF4IiwicmVzIiwiZ2V0UmFuZ2UiLCJzdGFydCIsImVuZCIsInN0ZXAiLCJtYXgiLCJwdXNoIiwiZW11bGF0ZUV2ZW50IiwibW91c2UiLCJnZXRQYXJhbXMiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJNb3VzZUV2ZW50IiwiZWwiLCJldmVudFR5cGUiLCJwYXJhbXMiLCJkaXNwYXRjaEV2ZW50IiwibW91c2VFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJ0b3VjaCIsInRvdWNoT2JqIiwiVG91Y2giLCJpZGVudGlmaWVyIiwibm93IiwicmFkaXVzWCIsInJhZGl1c1kiLCJyb3RhdGlvbkFuZ2xlIiwiZm9yY2UiLCJUb3VjaEV2ZW50Iiwic2hpZnRLZXkiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwidHBsUHJvY2VzcyIsInRwbCIsIlJlZ0V4cCIsInBhcnNlRGF0ZSIsImRhdGUiLCJwYXJzZWREYXRlIiwiY29uZmlnIiwiZm9ybWF0IiwiZGF0YVRpbWUiLCJpc1RhYlZpc2libGUiLCJoaWRkZW4iLCJjb252ZXJ0SW5wdXRUeXBlIiwiaXNNb2JpbGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJoYXNUb3VjaFBvaW50cyIsIm1heFRvdWNoUG9pbnRzIiwiaGFzVG91Y2giLCJEb2N1bWVudFRvdWNoIiwiaGFzTW91c2UiLCJPcHRpb25zIiwiY29sb3IiLCJpbnRlcmFjdGlvbiIsImRvbnV0IiwiZ2F1Z2UiLCJwaWUiLCJkYXRhQXhpcyIsImRhdGFTZWxlY3Rpb24iLCJwb2ludCIsInpvb20iLCJidWJibGUiLCJzcGxpbmUiLCJLRVkiLCJidWJibGVCYXNlTGVuZ3RoIiwiZGF0YU1pbk1heCIsImRhdGFUb3RhbFN1bSIsImRhdGFUb3RhbFBlckluZGV4IiwibGVnZW5kSXRlbVRleHRCb3giLCJyYWRhclBvaW50cyIsInNldE92ZXJPdXQiLCJjYWxsT3Zlck91dEZvclRvdWNoIiwidGV4dFJlY3QiLCJDYWNoZSIsImFkZCIsImlzRGF0YVR5cGUiLCJjYWNoZSIsImNsb25lVGFyZ2V0IiwicmVtb3ZlIiwiZ2V0IiwidGFyZ2V0cyIsInJlc2V0IiwiYWxsIiwiJCQiLCJpZF9vcmciLCJ2YWx1ZXMiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiZ2VuZXJhdGVSZXNpemUiLCJ0aW1lb3V0IiwiY2FsbFJlc2l6ZUZuIiwiY2xlYXIiLCJzcGxpY2UiLCJnZW5lcmF0ZVdhaXQiLCJ0cmFuc2l0aW9uc1RvV2FpdCIsInQiLCJjYWxsYmFjayIsImxvb3AiLCJkb25lIiwidGltZXIiLCJjb252ZXJ0RGF0YSIsInVybCIsImNvbnZlcnRVcmxUb0RhdGEiLCJtaW1lVHlwZSIsImhlYWRlcnMiLCJqc29uIiwiY29udmVydEpzb25Ub0RhdGEiLCJyb3dzIiwiY29udmVydFJvd3NUb0RhdGEiLCJjb2x1bW5zIiwiY29udmVydENvbHVtbnNUb0RhdGEiLCJFcnJvciIsInJlcSIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJyZWFkeVN0YXRlIiwic3RhdHVzIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJKU09OIiwicGFyc2UiLCJzZW5kIiwiY29udmVydENzdlRzdlRvRGF0YSIsInBhcnNlciIsInhzdiIsImNvbnZlcnRDc3ZUb0RhdGEiLCJkM0NzdlBhcnNlUm93cyIsImQzQ3N2UGFyc2UiLCJjb252ZXJ0VHN2VG9EYXRhIiwidHN2IiwiZDNUc3ZQYXJzZVJvd3MiLCJkM1RzdlBhcnNlIiwia2V5c1BhcmFtIiwidGFyZ2V0S2V5cyIsIm5ld1Jvd3MiLCJuZXdSb3ciLCJmaW5kVmFsdWVJbkpzb24iLCJ0bXAiLCJ1bnNoaWZ0Iiwib2JqZWN0IiwiY29udmVydGVkUGF0aCIsInBhdGhBcnJheSIsInNvbWUiLCJrIiwicm93IiwiaiIsImNvbCIsImNvbnZlcnREYXRhVG9UYXJnZXRzIiwiYXBwZW5kWHMiLCJpc0NhdGVnb3JpemVkIiwiaXNUaW1lU2VyaWVzIiwiaXNDdXN0b21YIiwieHNEYXRhIiwiZGF0YUtleXMiLCJpZHMiLCJpc05vdFgiLCJ4cyIsImlzWCIsInhLZXkiLCJnZXRYS2V5IiwicmF3WCIsImdlbmVyYXRlVGFyZ2V0WCIsImdldE90aGVyVGFyZ2V0WHMiLCJnZXRYVmFsdWVzT2ZYS2V5IiwiaW5kZXgiLCJjb252ZXJ0ZWRJZCIsImJpbmQiLCJhcGkiLCJpc0NhdGVnb3J5IiwiaGFzQ2F0ZWdvcnkiLCJ2MSIsInYyIiwiSW5maW5pdHkiLCJoYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzIiwiaGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyIsInNldFRhcmdldFR5cGUiLCJtYXBUb0lkcyIsImRhdGFLZXkiLCJleGlzdFZhbHVlIiwiaXNTdGFja05vcm1hbGl6ZWQiLCJpc0dyb3VwZWQiLCJ4VmFsdWVzIiwiZ2V0SW5kZXhCeVgiLCJiYXNlZFgiLCJmaWx0ZXJCeVgiLCJnZXRYVmFsdWUiLCJpZHNGb3JYIiwiZ2V0T3RoZXJUYXJnZXRYIiwiYWRkWHMiLCJpc011bHRpcGxlWCIsImhhc1R5cGUiLCJhZGROYW1lIiwiZ2V0QWxsVmFsdWVzT25JbmRleCIsImZpbHRlck51bGwiLCJmaWx0ZXJUYXJnZXRzVG9TaG93IiwiZ2V0VmFsdWVPbkluZGV4IiwidmFsdWVPbkluZGV4IiwidXBkYXRlVGFyZ2V0WCIsInVwZGF0ZVRhcmdldFhzIiwidXBkYXRlWHMiLCJnZXRQcmV2WCIsImdldE5leHRYIiwiZ2V0QmFzZVZhbHVlIiwiaXNBcmVhUmFuZ2VUeXBlIiwiZ2V0QXJlYVJhbmdlRGF0YSIsImlzQnViYmxlWlR5cGUiLCJnZXRCdWJibGVaRGF0YSIsImdldE1pbk1heFZhbHVlIiwiZ2V0TWluTWF4RGF0YSIsImNhY2hlS2V5IiwibWluTWF4RGF0YSIsIm1pbk1heCIsIm1pbkRhdGEiLCJnZXRGaWx0ZXJlZERhdGFCeVZhbHVlIiwibWF4RGF0YSIsImdldFRvdGFsUGVySW5kZXgiLCJzdW0iLCJnZXRUb3RhbERhdGFTdW0iLCJzdWJ0cmFjdEhpZGRlbiIsInRvdGFsIiwiZ2V0SGlkZGVuVG90YWxEYXRhU3VtIiwiZ2V0TWF4RGF0YUNvdW50IiwiZ2V0TWF4RGF0YUNvdW50VGFyZ2V0IiwibWFwVG9UYXJnZXRJZHMiLCJoYXNUYXJnZXQiLCJ2YWwiLCJpc1RhcmdldFRvU2hvdyIsInRhcmdldElkIiwiaXNMZWdlbmRUb1Nob3ciLCJtYXBUYXJnZXRzVG9VbmlxdWVYcyIsImFkZEhpZGRlblRhcmdldElkcyIsInRhcmdldElkcyIsInJlbW92ZUhpZGRlblRhcmdldElkcyIsImFkZEhpZGRlbkxlZ2VuZElkcyIsInJlbW92ZUhpZGRlbkxlZ2VuZElkcyIsImdldFZhbHVlc0FzSWRLZXllZCIsInlzIiwiY2hlY2tWYWx1ZUluVGFyZ2V0cyIsImNoZWNrZXIiLCJoYXNNdWx0aVRhcmdldHMiLCJfY2hlY2tPcmRlciIsIm9yZGVyIiwidG9Mb3dlckNhc2UiLCJpc09yZGVyRGVzYyIsImlzT3JkZXJBc2MiLCJvcmRlclRhcmdldHMiLCJ0YXJnZXRzVmFsdWUiLCJvcmRlckFzYyIsIm9yZGVyRGVzYyIsInQxIiwidDIiLCJyZWR1Y2VyIiwiYWJzIiwidDFTdW0iLCJ0MlN1bSIsImZpbHRlclJlbW92ZU51bGwiLCJmaWx0ZXJCeVhEb21haW4iLCJ4RG9tYWluIiwiaGFzRGF0YUxhYmVsIiwiZGF0YUxhYmVscyIsImdldERhdGFMYWJlbExlbmd0aCIsImxlbmd0aHMiLCJzZWxlY3RBbGwiLCJlbnRlciIsImRhdGFMYWJlbEZvcm1hdCIsImlzTm9uZUFyYyIsImlzQXJjIiwiZmluZFNhbWVYT2ZWYWx1ZXMiLCJ0YXJnZXRYIiwic2FtZXMiLCJmaW5kQ2xvc2VzdEZyb21UYXJnZXRzIiwicG9zIiwiY2FuZGlkYXRlcyIsImZpbmRDbG9zZXN0IiwiY2xvc2VzdCIsIm1pbkRpc3QiLCJpc0JhclR5cGUiLCJnZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCIsImlzV2l0aGluQmFyIiwiZGlzdCIsImlzUm90YXRlZCIsInNjYWxlIiwieEluZGV4IiwieUluZGV4IiwiY2lyY2xlWSIsInNxcnQiLCJwb3ciLCJjb252ZXJ0VmFsdWVzVG9TdGVwIiwic3RlcFR5cGUiLCJjb252ZXJ0ZWQiLCJjb252ZXJ0VmFsdWVzVG9SYW5nZSIsInJhbmdlcyIsInJhbmdlIiwidXBkYXRlRGF0YUF0dHJpYnV0ZXMiLCJhdHRycyIsInJlZHJhdyIsIndpdGhMZWdlbmQiLCJnZXRSYXRpbyIsImFzUGVyY2VudCIsInJhdGlvIiwic2hvd24iLCJwYWRBbmdsZSIsImVuZEFuZ2xlIiwic3RhcnRBbmdsZSIsImRhdGFWYWx1ZXMiLCJoaWRkZW5TdW0iLCJhY2MiLCJjdXJyIiwicGFyc2VGbG9hdCIsInVwZGF0ZURhdGFJbmRleEJ5WCIsInRpY2tWYWx1ZXMiLCJ0aWNrVmFsdWVNYXAiLCJvdXQiLCJ0aWNrIiwidmFsdWVJbmRleCIsImlzQnViYmxlVHlwZSIsImxvYWQiLCJyYXdUYXJnZXRzIiwidXBkYXRlVGFyZ2V0cyIsIndpdGhVcGRhdGVPcmdYRG9tYWluIiwid2l0aFVwZGF0ZVhEb21haW4iLCJ1cGRhdGVUeXBlc0VsZW1lbnRzIiwibG9hZEZyb21BcmdzIiwidW5sb2FkIiwicmF3VGFyZ2V0SWRzIiwiY3VzdG9tRG9uZUNiIiwic2VsZWN0b3JUYXJnZXQiLCJzdHlsZSIsImlzT3ZlciIsInNldE92ZXJDb2xvciIsImxhc3QiLCJpc1dpdGhpblNoYXBlIiwiZDNTZWxlY3QiLCJkYXR1bSIsInNob3dDaXJjbGVGb2N1cyIsImV4cGFuZENpcmNsZXNCYXJzIiwiZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uIiwiZHJhZyIsImQzRHJhZyIsImQzTW91c2UiLCJkcmFnc3RhcnQiLCJkcmFnZW5kIiwic2VsZWN0b3IiLCJheGVzIiwiZ2VuZXJhdGVDbGFzcyIsInByZWZpeCIsImNsYXNzVGV4dCIsImNsYXNzVGV4dHMiLCJjbGFzc1NoYXBlIiwiY2xhc3NTaGFwZXMiLCJnZW5lcmF0ZUV4dHJhTGluZUNsYXNzIiwiY2xhc3NMaW5lIiwiY2xhc3NMaW5lcyIsImNsYXNzQ2lyY2xlIiwiY2xhc3NDaXJjbGVzIiwiY2xhc3NCYXIiLCJjbGFzc0JhcnMiLCJjbGFzc0FyYyIsImNsYXNzQXJjcyIsImNsYXNzQXJlYSIsImNsYXNzQXJlYXMiLCJjbGFzc1JlZ2lvbiIsImNsYXNzIiwiY2xhc3NFdmVudCIsImNsYXNzVGFyZ2V0IiwiYWRkaXRpb25hbENsYXNzU3VmZml4IiwiYWRkaXRpb25hbENsYXNzIiwiY2xhc3NGb2N1cyIsImNsYXNzRm9jdXNlZCIsImNsYXNzRGVmb2N1c2VkIiwiY2xhc3NDaGFydFRleHQiLCJjbGFzc0NoYXJ0TGluZSIsImNsYXNzQ2hhcnRCYXIiLCJjbGFzc0NoYXJ0QXJjIiwiY2xhc3NDaGFydFJhZGFyIiwicGZ4Iiwic2VsZWN0b3JUYXJnZXRzIiwiaWRzVmFsdWUiLCJzZWxlY3RvckxlZ2VuZCIsInNlbGVjdG9yTGVnZW5kcyIsImNhdGVnb3J5TmFtZSIsImNhdGVnb3JpZXMiLCJjb2xvcml6ZVBhdHRlcm4iLCJwYXR0ZXJuIiwiY2xvbmVOb2RlIiwiaW5zZXJ0Iiwic2NoZW1lQ2F0ZWdvcnkxMCIsImdldENvbG9yRnJvbUNzcyIsImJvZHkiLCJzcGFuIiwiY3JlYXRlRWxlbWVudCIsImNsYXNzTmFtZSIsImRpc3BsYXkiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiYmFja2dyb3VuZEltYWdlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidHJpbSIsIkJvb2xlYW4iLCJnZW5lcmF0ZUNvbG9yIiwiY29sb3JzIiwiZDNTY2FsZU9yZGluYWwiLCJvcmlnaW5hbENvbG9yUGF0dGVybiIsInRpbGVzIiwiY29sb3JpemVkUGF0dGVybnMiLCJwYXR0ZXJucyIsImlzTGluZSIsImlzVHlwZU9mIiwiZ2VuZXJhdGVMZXZlbENvbG9yIiwidGhyZXNob2xkIiwiYXNWYWx1ZSIsInVuaXQiLCJsIiwiVFlQRSIsIkFSRUEiLCJBUkVBX0xJTkVfUkFOR0UiLCJBUkVBX1NQTElORSIsIkFSRUFfU1BMSU5FX1JBTkdFIiwiQVJFQV9TVEVQIiwiQkFSIiwiQlVCQkxFIiwiRE9OVVQiLCJHQVVHRSIsIkxJTkUiLCJQSUUiLCJSQURBUiIsIlNDQVRURVIiLCJTUExJTkUiLCJTVEVQIiwiVFlQRV9CWV9DQVRFR09SWSIsIkFyZWEiLCJBcmVhUmFuZ2UiLCJBcmMiLCJMaW5lIiwiU3RlcCIsIlNwbGluZSIsImdldFlEb21haW5NaW5NYXgiLCJpc01pbiIsImRhdGFHcm91cHMiLCJpZHNJbkdyb3VwIiwiYmFzZUlkIiwiYmFzZUF4aXNJZCIsImdldElkIiwiYXhpc0lkIiwibWVldENvbmRpdGlvbiIsImdldFlEb21haW5NaW4iLCJnZXRZRG9tYWluTWF4IiwiaXNIaWRkZW5UYXJnZXRXaXRoWURvbWFpbiIsImdldFlEb21haW4iLCJ0YXJnZXRzQnlBeGlzSWQiLCJ5VGFyZ2V0cyIsInlNaW4iLCJ5TWF4IiwieURvbWFpbk1pbiIsInlEb21haW5NYXgiLCJjZW50ZXIiLCJpc1plcm9CYXNlZCIsImlzSW52ZXJ0ZWQiLCJzaG93SG9yaXpvbnRhbERhdGFMYWJlbCIsInNob3dWZXJ0aWNhbERhdGFMYWJlbCIsImlzQWxsUG9zaXRpdmUiLCJpc0FsbE5lZ2F0aXZlIiwiZG9tYWluTGVuZ3RoIiwieURvbWFpbkFicyIsImNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nIiwiZ2V0UGFkZGluZyIsInJldmVyc2UiLCJnZXRYRG9tYWluTWluTWF4IiwiY29uZmlnVmFsdWUiLCJkYXRhVmFsdWUiLCJmaXQiLCJnZXRYRG9tYWluTWluIiwiZ2V0WERvbWFpbk1heCIsImdldFhEb21haW5QYWRkaW5nIiwibWF4RGF0YUNvdW50IiwieFBhZGRpbmciLCJnZXRYRG9tYWluIiwiZmlyc3RYIiwibGFzdFgiLCJnZXRUaW1lIiwidXBkYXRlWERvbWFpbiIsIndpdGhUcmltIiwib3JnIiwiem9vbUVuYWJsZWQiLCJ1cGRhdGVTY2FsZUV4dGVudCIsImRvbWFpblZhbHVlIiwiaW52ZXJ0IiwidHJpbVhEb21haW4iLCJvcmdEb21haW4iLCJ6b29tRG9tYWluIiwiZ2V0Wm9vbURvbWFpbiIsImdldEZvcm1hdCIsInR5cGVWYWx1ZSIsImRlZmF1bHRWYWx1ZUZvcm1hdCIsImdldFlGb3JtYXQiLCJmb3JBcmMiLCJ5Rm9ybWF0IiwieTJGb3JtYXQiLCJkZWZhdWx0QXJjVmFsdWVGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0IiwiaW5pdExlZ2VuZCIsImNsYXNzZWQiLCJnZXRUcmFuc2xhdGUiLCJ1cGRhdGVMZWdlbmQiLCJ0cmFuc2l0aW9ucyIsIm9wdGlvbnoiLCJ3aXRoVHJhbnNmb3JtIiwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0iLCJ3aXRoVHJhbnNpdGlvbiIsInVwZGF0ZUxlZ2VuZFRlbXBsYXRlIiwidXBkYXRlTGVnZW5kRWxlbWVudCIsInVwZGF0ZVNjYWxlcyIsInVwZGF0ZVN2Z1NpemUiLCJ0cmFuc2Zvcm1BbGwiLCJ3cmFwcGVyIiwidGVtcGxhdGUiLCJDT0xPUiIsIlRJVExFIiwiY2hpbGROb2RlcyIsInNldExlZ2VuZEl0ZW0iLCJ1cGRhdGVTaXplRm9yTGVnZW5kIiwiaW5zZXRMZWdlbmRQb3NpdGlvbiIsImdldEN1cnJlbnRQYWRkaW5nVG9wIiwiZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20iLCJnZXRDdXJyZW50UGFkZGluZ0xlZnQiLCJnZXRDdXJyZW50UGFkZGluZ1JpZ2h0IiwiTmFOIiwidHJhbnNmb3JtTGVnZW5kIiwidXBkYXRlTGVnZW5kU3RlcCIsInVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aCIsInVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCJ1cGRhdGVMZWdlbmRJdGVtQ29sb3IiLCJnZXRMZWdlbmRXaWR0aCIsImdldExlZ2VuZEhlaWdodCIsIm9wYWNpdHlGb3JMZWdlbmQiLCJvcGFjaXR5Rm9yVW5mb2N1c2VkTGVnZW5kIiwidG9nZ2xlRm9jdXNMZWdlbmQiLCJmb2N1cyIsInRhcmdldElkeiIsImR1cmF0aW9uIiwicmV2ZXJ0TGVnZW5kIiwic2hvd0xlZ2VuZCIsImhpZGVMZWdlbmQiLCJnZXRMZWdlbmRJdGVtVGV4dEJveCIsInRleHRFbGVtZW50IiwiZ2V0VGV4dFJlY3QiLCJpdGVtIiwiaXNUb3VjaCIsImhhc0dhdWdlIiwiaXRlbUNsYXNzIiwiYWx0S2V5IiwiaGlkZSIsInNob3ciLCJ0b2dnbGUiLCJyZXZlcnQiLCJoaWRlVG9vbHRpcCIsInVuZG9NYXJrT3ZlcmxhcHBlZCIsIm1hcmtPdmVybGFwcGVkIiwieEZvckxlZ2VuZCIsInlGb3JMZWdlbmQiLCJwb3NNaW4iLCJ0aWxlV2lkdGgiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsInRvdGFsTGVuZ3RoIiwib2Zmc2V0cyIsIndpZHRocyIsImhlaWdodHMiLCJtYXJnaW5zIiwic3RlcHMiLCJpc0xlZ2VuZFJpZ2h0T3JJbnNldCIsInVwZGF0ZVBvc2l0aW9ucyIsImlzTGFzdCIsImJveCIsIml0ZW1XaWR0aCIsIml0ZW1IZWlnaHQiLCJpdGVtTGVuZ3RoIiwiYXJlYUxlbmd0aCIsInVwZGF0ZVZhbHVlcyIsImlkMiIsIndpdGhvdXRTdGVwIiwibWF4TGVuZ3RoIiwieEZvckxlZ2VuZFRleHQiLCJ4Rm9yTGVnZW5kUmVjdCIsIngxRm9yTGVnZW5kVGlsZSIsIngyRm9yTGVnZW5kVGlsZSIsInlGb3JMZWdlbmRUZXh0IiwieUZvckxlZ2VuZFJlY3QiLCJ5Rm9yTGVnZW5kVGlsZSIsInVzZVBvaW50IiwiY3JlYXRlRWxlbWVudE5TIiwiZDNOYW1lc3BhY2VzIiwiaGFzVmFsaWRQb2ludFR5cGUiLCJpZHgiLCJub2RlTmFtZSIsInJlY3RzIiwicG9pbnRSIiwieE9mZnNldCIsInlPZmZzZXQiLCJsZXZlbENvbG9yIiwidHJhbnNpdGlvbnNWYWx1ZSIsInRhcmdldHNUb1Nob3ciLCJpbml0aWFsaXppbmciLCJmbG93Iiwid3RoIiwiZ2V0V2l0aE9wdGlvbiIsIlRyYW5zaXRpb24iLCJkdXJhdGlvbkZvckV4aXQiLCJUcmFuc2l0aW9uRm9yRXhpdCIsImR1cmF0aW9uRm9yQXhpcyIsIlRyYW5zaXRpb25Gb3JBeGlzIiwiZ2VuZXJhdGVUcmFuc2l0aW9ucyIsInVwZGF0ZVNpemVzIiwiTGVnZW5kIiwiRGltZW5zaW9uIiwidXBkYXRlRGltZW5zaW9uIiwidXBkYXRlVGV4dCIsImhhc0FyY1R5cGUiLCJ1cGRhdGVDaXJjbGVZIiwiaGFzUG9pbnRUeXBlIiwidXBkYXRlQ2lyY2xlIiwicmVkcmF3QXhpcyIsImhhc0dyaWQiLCJ1cGRhdGVHcmlkIiwidXBkYXRlUmVnaW9uIiwidXBkYXRlQmFyIiwiaGFzVHlwZU9mIiwidXBkYXRlTGluZSIsInVwZGF0ZUFyZWEiLCJFdmVudFJlY3QiLCJiaW5kWm9vbUV2ZW50IiwicmVkcmF3QXJjIiwiVHJhbnNmb3JtIiwicmVkcmF3UmFkYXIiLCJyZWRyYXdUaXRsZSIsImdlbmVyYXRlUmVkcmF3TGlzdCIsIlN1YmNoYXJ0IiwiY2FsbFBsdWdpbkhvb2siLCJ3aXRoU3ViY2hhcnQiLCJnZXREcmF3U2hhcGUiLCJyZWRyYXdTdWJjaGFydCIsImZsb3dGbiIsImdlbmVyYXRlRmxvdyIsInh2IiwiaXNUcmFuc2l0aW9uIiwicmVkcmF3TGlzdCIsImdldFJlZHJhd0xpc3QiLCJhZnRlclJlZHJhdyIsIndhaXRGb3JEcmF3IiwiZDNUcmFuc2l0aW9uIiwiY3giLCJjeSIsInhGb3JUZXh0IiwieUZvclRleHQiLCJyZWRyYXdHcmlkIiwicmVkcmF3UmVnaW9uIiwicmVkcmF3TGluZSIsInJlZHJhd0FyZWEiLCJyZWRyYXdCYXIiLCJ1cGRhdGVHcmlkRm9jdXMiLCJyZWRyYXdUZXh0IiwicmVkcmF3Q2lyY2xlIiwidXBkYXRlQW5kUmVkcmF3Iiwid2l0aFRyYW5zaXRpb25Gb3JFeGl0Iiwid2l0aFRyYW5zaXRpb25Gb3JBeGlzIiwicmVkcmF3V2l0aG91dFJlc2NhbGUiLCJ3aXRoWSIsIndpdGhFdmVudFJlY3QiLCJnZXRTY2FsZSIsImZvclRpbWVzZXJpZXMiLCJkM1NjYWxlVGltZSIsImQzU2NhbGVMaW5lYXIiLCJnZXRYU2NhbGUiLCJvZmZzZXQiLCJnZXRDdXN0b21pemVkU2NhbGUiLCJnZXRZU2NhbGUiLCJpc1RpbWVTZXJpZXNZIiwiZ2V0WVNjYWxlQnlJZCIsImlzU3ViIiwiaXNZMiIsInNjYWxlVmFsdWUiLCJvZmZzZXRWYWx1ZSIsInRpY2tPZmZzZXQiLCJyYXciLCJvcmdTY2FsZSIsImFyZ3VtZW50cyIsImlzSW5pdCIsInN1YlkiLCJ4U3ViRG9tYWluIiwieEF4aXNUaWNrIiwiZ2V0WEF4aXNUaWNrRm9ybWF0Iiwic2V0QXhpcyIsInN1YlkyIiwidXBkYXRlQXJjIiwieHgiLCJ5diIsInlTY2FsZSIsInN1Ynh4IiwiaW5kaWNlcyIsImdldFNoYXBlSW5kaWNlcyIsImlzTGluZVR5cGUiLCJnZW5lcmF0ZURyYXdMaW5lIiwiaXNBcmVhVHlwZSIsImdlbmVyYXRlRHJhd0FyZWEiLCJnZW5lcmF0ZURyYXdCYXIiLCJyYWRhckNpcmNsZVgiLCJjaXJjbGVYIiwicmFkYXJDaXJjbGVZIiwiZ2VuZXJhdGVYWUZvclRleHQiLCJ0eXBlRmlsdGVyIiwiaGFzWHMiLCJncm91cHMiLCJpbmQiLCJfX21heF9fIiwiZ2V0SW5kaWNlcyIsImdldEluZGljZXNNYXgiLCJnZXRTaGFwZVgiLCJjdXJyU2NhbGUiLCJiYXJQYWRkaW5nIiwiaGFsZldpZHRoIiwidGFyZ2V0c051bSIsInhQb3MiLCJnZXRTaGFwZVkiLCJnZXRTaGFwZVlNaW4iLCJnZXRTaGFwZU9mZnNldERhdGEiLCJzaGFwZU9mZnNldFRhcmdldHMiLCJyb3dWYWx1ZXMiLCJpc1N0ZXBUeXBlIiwicm93VmFsdWVNYXBCeVhWYWx1ZSIsImluZGV4TWFwQnlUYXJnZXRJZCIsImdldFNoYXBlT2Zmc2V0IiwieTAiLCJkYXRhWEFzTnVtYmVyIiwidGhhdCIsImlzV2l0aGluIiwiaXNXaXRoaW5TdGVwIiwiaXNXaXRoaW5DaXJjbGUiLCJwb2ludFNlbGVjdFIiLCJnZXRJbnRlcnBvbGF0ZSIsImludGVycG9sYXRpb24iLCJnZXRJbnRlcnBvbGF0ZVR5cGUiLCJkM0N1cnZlQmFzaXMiLCJkM0N1cnZlQmFzaXNDbG9zZWQiLCJkM0N1cnZlQmFzaXNPcGVuIiwiZDNDdXJ2ZUJ1bmRsZSIsImQzQ3VydmVDYXJkaW5hbCIsImQzQ3VydmVDYXJkaW5hbENsb3NlZCIsImQzQ3VydmVDYXJkaW5hbE9wZW4iLCJkM0N1cnZlQ2F0bXVsbFJvbSIsImQzQ3VydmVDYXRtdWxsUm9tQ2xvc2VkIiwiZDNDdXJ2ZUNhdG11bGxSb21PcGVuIiwiZDNDdXJ2ZU1vbm90b25lWCIsImQzQ3VydmVNb25vdG9uZVkiLCJkM0N1cnZlTmF0dXJhbCIsImQzQ3VydmVMaW5lYXJDbG9zZWQiLCJkM0N1cnZlTGluZWFyIiwiZDNDdXJ2ZVN0ZXAiLCJkM0N1cnZlU3RlcEFmdGVyIiwiZDNDdXJ2ZVN0ZXBCZWZvcmUiLCJpc0ludGVycG9sYXRpb25UeXBlIiwiaXNTcGxpbmVUeXBlIiwic2V0Q29udGFpbmVyU2l6ZSIsImdldEN1cnJlbnRXaWR0aCIsImdldEN1cnJlbnRIZWlnaHQiLCJnZXRQYXJlbnRXaWR0aCIsImgiLCJnZXRQYXJlbnRIZWlnaHQiLCJheGVzTGVuIiwiZ2V0VGl0bGVQYWRkaW5nIiwiZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQiLCJ3aXRob3V0UmVjb21wdXRlIiwiYXhpc1dpZHRoIiwiZ2V0QXhpc1dpZHRoQnlBeGlzSWQiLCJnZXRBeGlzTGFiZWxQb3NpdGlvbiIsImlzT3V0ZXIiLCJ3aXRob3V0VGlja1RleHRPdmVyZmxvdyIsImRlZmF1bHRQYWRkaW5nIiwibGVnZW5kV2lkdGhPblJpZ2h0IiwieEF4aXNUaWNrVGV4dE92ZXJmbG93IiwiZ2V0WEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3ciLCJnZXRQYXJlbnRSZWN0VmFsdWUiLCJvZmZzZXROYW1lIiwicGFyZW50IiwidGFnTmFtZSIsImJvZHlXaWR0aCIsIm9mZnNldFdpZHRoIiwicGFyc2VJbnQiLCJnZXRTdmdMZWZ0IiwiaGFzTGVmdEF4aXNSZWN0IiwibGVmdEF4aXNDbGFzcyIsImxlZnRBeGlzIiwic3ZnUmVjdCIsImNoYXJ0UmVjdCIsImhhc0FyYyIsInN2Z0xlZnQiLCJ3aXRob3V0QXhpcyIsImNyZWF0ZSIsImJydXNoU2l6ZSIsImdldFhBeGlzQ2xpcFgiLCJnZXRYQXhpc0NsaXBZIiwiZ2V0WEF4aXNDbGlwV2lkdGgiLCJnZXRYQXhpc0NsaXBIZWlnaHQiLCJnZXRZQXhpc0NsaXBYIiwiZ2V0WUF4aXNDbGlwWSIsImdldFlBeGlzQ2xpcFdpZHRoIiwiZ2V0WUF4aXNDbGlwSGVpZ2h0IiwiY3VyckxlZ2VuZCIsImxlZ2VuZEhlaWdodEZvckJvdHRvbSIsInN1YmNoYXJ0WEF4aXNIZWlnaHQiLCJzdWJjaGFydEhlaWdodCIsImdldEdhdWdlTGFiZWxIZWlnaHQiLCJ1cGRhdGVSYWRpdXMiLCJ1cGRhdGVYQXhpc1RpY2tDbGlwIiwib3BhY2l0eUZvclRleHQiLCJpbml0VGV4dCIsInVwZGF0ZVRhcmdldHNGb3JUZXh0IiwibWFpblRleHRVcGRhdGUiLCJtYWluVGV4dEVudGVyIiwiZGF0YUZuIiwibGFiZWxpc2hEYXRhIiwiaXNSYWRhclR5cGUiLCJleGl0IiwibWVyZ2UiLCJ1cGRhdGVUZXh0Q29sb3IiLCJsYWJlbENvbG9ycyIsImZvckZsb3ciLCJiYXNlIiwicXVlcnlTZWxlY3RvciIsInRleHRDb250ZW50IiwiZm9yWCIsInBvaW50cyIsImdldHRlciIsImdldFhGb3JUZXh0IiwiZ2V0WUZvclRleHQiLCJnZXRDZW50ZXJlZFRleHRQb3MiLCJjZW50ZXJlZCIsImlzUG9zaXRpdmUiLCJ3IiwiZ2V0VGV4dFBvcyIsInlQb3MiLCJyIiwiYmFzZVkiLCJpc1NjYXR0ZXJUeXBlIiwiYm94SGVpZ2h0IiwidGV4dE5vZGVzIiwiZmlsdGVyZWRUZXh0Tm9kZXMiLCJ0ZXh0Tm9kZSIsInRyYW5zbGF0ZSIsImNhbGNIeXBvIiwiY29vcmRpbmF0ZSIsImZpbHRlcmVkVGV4dE5vZGUiLCJub2RlRm9yV2lkdGgiLCJvdmVybGFwc1giLCJnZXRDb21wdXRlZFRleHRMZW5ndGgiLCJvdmVybGFwc1kiLCJkM1NlbGVjdEFsbCIsInByZXZpb3VzU2libGluZyIsInBvc2l0aW9uIiwiaXNOdW0iLCJpbml0VGl0bGUiLCJ5Rm9yVGl0bGUiLCJ4Rm9yVGl0bGUiLCJ0ZXh0UmVjdFdpZHRoIiwiaW5pdFRvb2x0aXAiLCJnZXRUb29sdGlwSFRNTCIsImJpbmRUb29sdGlwUmVzaXplUG9zIiwiZ2V0VG9vbHRpcENvbnRlbnQiLCJkZWZhdWx0VGl0bGVGb3JtYXQiLCJ0aXRsZUZvcm1hdCIsIm5hbWVGb3JtYXQiLCJ2YWx1ZUZvcm1hdCIsImdldFJvd1ZhbHVlIiwiZ2V0QmdDb2xvciIsImNvbnRlbnRzIiwidHBsU3RyIiwiaTIiLCJwYXJhbSIsImdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUiLCJDTEFTU19UT09MVElQIiwiaGlnaCIsImxvdyIsImNvbnRlbnRWYWx1ZSIsIkNMQVNTX1RPT0xUSVBfTkFNRSIsIk5BTUUiLCJWQUxVRSIsInRvb2x0aXBQb3NpdGlvbiIsImRhdGFUb1Nob3ciLCJ0V2lkdGgiLCJ0SGVpZ2h0IiwiY2hhcnRSaWdodCIsImNoYXJ0TGVmdCIsImRhdGFTY2FsZSIsInpvb21TY2FsZSIsInNob3dUb29sdGlwIiwic2VsZWN0ZWREYXRhIiwiZGF0YVN0ciIsInN0cmluZ2lmeSIsInByb3BlcnR5IiwiX2hhbmRsZUxpbmtlZENoYXJ0cyIsImZuUG9zIiwieFBvc0luUGVyY2VudCIsInJlc2l6ZUZ1bmN0aW9uIiwiY2hhcnRzIiwibGlua2VkTmFtZSIsImludGVybmFsIiwiaXNMaW5rZWQiLCJpc0luRG9tIiwiY29udGFpbnMiLCJpc05vdFNhbWVJbmRleCIsImdldEF4aXNTaXplIiwiZ2V0UmFkYXJTaXplIiwidHJhbnNmb3JtTWFpbiIsInhBeGlzIiwieUF4aXMiLCJ5MkF4aXMiLCJ0cmFuc2Zvcm1Db250ZXh0IiwiaGFzIiwic2V0Q2hhcnRFbGVtZW50cyIsImNoZWNrRnJvbURhdGEiLCJleGNsdWRlIiwiZGF0YVR5cGUiLCJoYXNNdWx0aUFyY0dhdWdlIiwiaXNQaWVUeXBlIiwiaXNHYXVnZVR5cGUiLCJpc0RvbnV0VHlwZSIsImlzQXJjVHlwZSIsImlzQ2lyY2xlUG9pbnQiLCJpc0NpcmNsZSIsImxpbmVEYXRhIiwiYXJjRGF0YSIsImJhckRhdGEiLCJiYXJMaW5lQnViYmxlRGF0YSIsIkNoYXJ0SW50ZXJuYWwiLCJ4U2NhbGUiLCJleHRyYUxpbmVDbGFzc2VzIiwiZGVmYXVsdEF4aXNUaW1lIiwiYXhpc1RpbWUiLCJzdG9yZSIsImJlZm9yZUluaXQiLCJhZnRlckluaXQiLCJpbml0IiwiaW5pdFBhcmFtcyIsImNsYXNzbmFtZSIsImluaXRUb1JlbmRlciIsImZvcmNlZCIsImlzSGlkZGVuIiwiaXNMYXp5IiwibGF6eSIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwibXV0YXRpb24iLCJvYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlRmlsdGVyIiwiY29udmVydGVkRGF0YSIsImluaXRXaXRoRGF0YSIsImdlbmVyYXRlUG9pbnQiLCJpbml0Q2xpcCIsImQzVGltZVBhcnNlIiwiZDNVdGNQYXJzZSIsImQzVGltZUZvcm1hdCIsImQzVXRjRm9ybWF0IiwiaXNEcmFnWm9vbSIsImlzWm9vbWVkIiwic3BlY2lmaWVyIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ2V0U2Vjb25kcyIsImdldE1pbnV0ZXMiLCJnZXRIb3VycyIsImdldERhdGUiLCJnZXRNb250aCIsInJvdGF0ZWRQYWRkaW5nUmlnaHQiLCJoYXNJbnRlcmFjdGlvbiIsImdldEF4aXNJbnN0YW5jZSIsImluaXRab29tIiwiaGFzQ29sb3JQYXR0ZXJucyIsImFwcGVuZENsaXAiLCJiaW5kUmVzaXplIiwiaW5pdFN1YmNoYXJ0IiwiaW5pdFJlZ2lvbiIsImluaXRFdmVudFJlY3QiLCJpbml0R3JpZCIsImluaXRDaGFydEVsZW1lbnRzIiwic2V0QmFja2dyb3VuZCIsIiQiLCJiZyIsImltZ1VybCIsInVwZGF0ZVRhcmdldEZvckNpcmNsZSIsInVwZGF0ZVRhcmdldHNGb3JCYXIiLCJ1cGRhdGVUYXJnZXRzRm9yTGluZSIsInVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCIsInVwZGF0ZVRhcmdldHNGb3JSYWRhciIsInVwZGF0ZVRhcmdldHNGb3JBcmMiLCJzaG93VGFyZ2V0cyIsIndpdGhPcHRpb25zIiwiWSIsIlRyaW1YRG9tYWluIiwiVXBkYXRlWERvbWFpbiIsIlVwZGF0ZU9yZ1hEb21haW4iLCJVcGRhdGVYQXhpcyIsImRlZlZhbCIsImluaXRpYWxPcGFjaXR5IiwiZmx1c2giLCJhZGRFdmVudExpc3RlbmVyIiwicGhhc2UiLCJwcm90b3R5cGUiLCJkYXRhQ29udmVydCIsImRhdGFMb2FkIiwiY2F0ZWdvcnkiLCJjbGFzc01vZHVsZSIsImxvYWRDb25maWciLCJyZWFkIiwidGhpc0NvbmZpZyIsImZpbmQiLCJyZXNpemUiLCJzb2Z0IiwidXBkYXRlUmVzaXplIiwic2V0T3JpZW50IiwiZGVzdHJveSIsImludGVycnVwdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJmbGF0IiwibmFtZXMiLCJiNjRFbmNvZGVVbmljb2RlIiwiYnRvYSIsImVuY29kZVVSSUNvbXBvbmVudCIsIm1hdGNoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibm9kZVRvU3ZnRGF0YVVybCIsInNlcmlhbGl6ZXIiLCJYTUxTZXJpYWxpemVyIiwiY2xvbmUiLCJjc3NUZXh0Iiwic2V0QXR0cmlidXRlIiwieGh0bWwiLCJub2RlWG1sIiwic2VyaWFsaXplVG9TdHJpbmciLCJjcmVhdGVUZXh0Tm9kZSIsImpvaW4iLCJzdHlsZVhtbCIsImV4cG9ydCIsInN2Z0RhdGFVcmwiLCJpbWciLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwib25sb2FkIiwiY2FudmFzIiwiZ2V0Q29udGV4dCIsImRyYXdJbWFnZSIsInRvRGF0YVVSTCIsInNyYyIsInRhcmdldElkc1ZhbHVlIiwiZGVmb2N1cyIsImV4cGFuZEFyYyIsInVuZXhwYW5kQXJjIiwiYXJnc1ZhbHVlIiwic2hvd0hpZGUiLCJvcGFjaXR5IiwiZXZlbnROYW1lIiwiaGlkZUdyaWRGb2N1cyIsInVuZXhwYW5kQ2lyY2xlcyIsInVuZXhwYW5kQmFycyIsIkNoYXJ0IiwiYmluZFRoaXMiLCJhcmdUaGlzIiwiaXNGdW5jIiwiaXNDaGlsZCIsImhhc0NoaWxkIiwiYXBpQ2hhcnQiLCJhcGlDb2xvciIsImFwaURhdGEiLCJhcGlFeHBvcnQiLCJhcGlGb2N1cyIsImFwaUxlZ2VuZCIsImFwaUxvYWQiLCJhcGlTaG93IiwiYXBpVG9vbHRpcCIsInNldE1pbk1heCIsImxhYmVscyIsInNldExhYmVsVGV4dCIsInVwZGF0ZUxhYmVscyIsInRvIiwidGFpbCIsIm5vdGZvdW5kSWRzIiwib3JnRGF0YUNvdW50IiwibWlzc2luZyIsImJhc2VUYXJnZXQiLCJiYXNlVmFsdWUiLCJ3aXRoVHJpbVhEb21haW4iLCJ3aXRoVXBkYXRlWEF4aXMiLCJncmlkcyIsInJlbW92ZUdyaWRMaW5lcyIsIm9wdGlvbnNWYWx1ZSIsInNlbGVjdGVkIiwiZGF0YVBvaW50IiwicmVzZXRPdGhlciIsImdldFRvZ2dsZSIsImlzVGFyZ2V0SWQiLCJpc1RhcmdldEluZGV4IiwiaXNTZWxlY3RlZCIsInVuc2VsZWN0Iiwid2l0aGluUmFuZ2UiLCJyZXN1bHREb21haW4iLCJnZXRTZWxlY3Rpb24iLCJtb3ZlIiwid2l0aERpbWVuc2lvbiIsInNldFpvb21SZXNldEJ1dHRvbiIsImVuYWJsZSIsImVuYWJsZWQiLCJlbmFibGVUeXBlIiwidW56b29tIiwidXBkYXRlVHJhbnNmb3JtU2NhbGUiLCJkM1pvb21JZGVudGl0eSIsInVwZGF0ZVpvb20iLCJyZXNldEJ0biIsImQzWm9vbVRyYW5zZm9ybSIsIkF4aXNSZW5kZXJlckhlbHBlciIsIm93bmVyIiwibm9UcmFuc2l0aW9uIiwid2l0aG91dFRyYW5zaXRpb24iLCJzY2FsZUV4dGVudCIsIm9yZ1hTY2FsZSIsImdldFNpemVGb3IxQ2hhciIsImdldFRpY2tUcmFuc2Zvcm1TZXR0ZXIiLCJzdG9wIiwiZ2VuZXJhdGVUaWNrcyIsImlzWUF4ZXMiLCJ0aWNrU3RlcFNpemUiLCJpbnRlcnZhbCIsInRpY2tBcmd1bWVudHMiLCJyb3VuZCIsImNvcHlTY2FsZSIsIm5ld1NjYWxlIiwiY29weSIsInRleHRGb3JtYXR0ZWQiLCJ0aWNrRm9ybWF0IiwiZm9ybWF0dGVkIiwidHJhbnNpdGlvbmlzZSIsIkF4aXNSZW5kZXJlciIsImlubmVyVGlja1NpemUiLCJvdXRlclRpY2tTaXplIiwib3V0ZXJUaWNrIiwib3JpZW50IiwidGlja0NlbnRlcmVkIiwidGlja0N1bGxpbmciLCJ0aWNrTGVuZ3RoIiwidGlja1BhZGRpbmciLCJoZWxwZXIiLCJIZWxwZXIiLCJnIiwic3BsaXRUaWNrVGV4dCIsImlzTGVmdFJpZ2h0IiwiaXNUb3BCb3R0b20iLCJ0aWNrVHJhbnNmb3JtIiwiYXhpc1B4Iiwic2lnbiIsInJvdGF0ZSIsInRpY2tUZXh0Um90YXRlIiwicmFuZ2VFeHRlbnQiLCIkZyIsInRpY2tUZXh0UG9zIiwiYXhpc1Nob3ciLCJ0aWNrU2hvdyIsInNjYWxlMCIsIl9fY2hhcnRfXyIsInNjYWxlMSIsIm91dGVyVGlja1NpemVkIiwidGlja0VudGVyIiwidGlja0V4aXQiLCJzaXplRm9yMUNoYXIiLCJjb3VudHMiLCJ0c3BhbiIsInRpY2tNdWx0aWxpbmUiLCJzcGxpdHRlZCIsImR4Iiwic2luIiwibGluZVVwZGF0ZSIsInRleHRVcGRhdGUiLCJzZXRUaWNrTGluZVRleHRQb3NpdGlvbiIsInRpY2tUaXRsZSIsImJhbmR3aWR0aCIsImdldFRpY2tYWSIsImdldFRpY2tTaXplIiwidGlja1Bvc2l0aW9uIiwidGlja1BvcyIsInRleHRBbmNob3JGb3JUZXh0IiwidGV4dFRyYW5zZm9ybSIsInIyIiwiY2hhcldpZHRoIiwic3VidGV4dCIsInNwYWNlSW5kZXgiLCJ0ZXh0V2lkdGgiLCJzdWJzdHIiLCJ0aWNrV2lkdGgiLCJ0aWNrVGV4dCIsImlzQ2VudGVyZWQiLCJ0aWNrSW50ZXJ2YWwiLCJnZXRUb3RhbExlbmd0aCIsImN1bGxpbmciLCJzZXRUcmFuc2l0aW9uIiwiQXhpcyIsImdldEF4aXNDbGFzc05hbWUiLCJpc0hvcml6b250YWwiLCJmb3JIb3Jpem9udGFsIiwiY2xhc3NBeGlzIiwiY2xhc3NMYWJlbCIsInRleHRBbmNob3JGb3JBeGlzTGFiZWwiLCJnZW5lcmF0ZUF4ZXMiLCJ5SW5uZXIiLCJ5MklubmVyIiwiZDNBeGlzIiwiYXhlc0NvbmZpZyIsImQzQXhpc0xlZnQiLCJkM0F4aXNCb3R0b20iLCJkM0F4aXNUb3AiLCJkM0F4aXNSaWdodCIsImNvdW50IiwidGlja1NpemVPdXRlciIsIm91dGVyIiwiYXhlc0xpc3QiLCJ1cGRhdGVBeGVzIiwiYXhpc1JhbmdlIiwiZ2V0VGlja1ZhbHVlcyIsImdldEF4aXMiLCJub1RpY2tUZXh0Um90YXRlIiwiZ2V0QXhpc1RpY2tSb3RhdGUiLCJheGlzUGFyYW1zIiwidXBkYXRlWEF4aXNUaWNrVmFsdWVzIiwiZ2VuZXJhdGVUaWNrVmFsdWVzIiwiY3VyckZvcm1hdCIsImdldExhYmVsT3B0aW9uQnlBeGlzSWQiLCJnZXRMYWJlbFRleHQiLCJvcHRpb24iLCJnZXRMYWJlbFBvc2l0aW9uIiwiZGVmYXVsdFBvc2l0aW9uIiwiaXNJbm5lciIsImlzTGVmdCIsImlzQ2VudGVyIiwiaXNSaWdodCIsImlzVG9wIiwiaXNNaWRkbGUiLCJpc0JvdHRvbSIsImdldExhYmVsUG9zaXRpb25CeUlkIiwieEZvckF4aXNMYWJlbCIsImR4Rm9yQXhpc0xhYmVsIiwiYW5jaG9yIiwiZHlGb3JBeGlzTGFiZWwiLCJ0aWNrUm90YXRlIiwibWF4VGlja1dpZHRoIiwiZ2V0TWF4VGlja1dpZHRoIiwieEhlaWdodCIsImN1cnJlbnRUaWNrTWF4IiwiaXNZQXhpcyIsImR1bW15IiwiY3VycmVudFRleHRXaWR0aCIsInhBeGlzVGlja1JvdGF0ZSIsIndpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCIsIm1heE92ZXJmbG93IiwiZ2V0WEF4aXNUaWNrTWF4T3ZlcmZsb3ciLCJ4QXhpc1RpY2tUZXh0WTJPdmVyZmxvdyIsInRpY2tUZXh0V2lkdGhzIiwicmVtYWluaW5nIiwidGlja0luZGV4Iiwicm90YXRlZFRpY2tUZXh0V2lkdGgiLCJjb3MiLCJ0aWNrc0JlZm9yZVRpY2tUZXh0IiwiZ2V0WEF4aXNQYWRkaW5nIiwidGltZURpZmYiLCJyZWxhdGl2ZVRpY2tXaWR0aCIsInBpeGVscyIsImZvclRpbWVTZXJpZXMiLCJ0YXJnZXRDb3VudCIsInRpY2tWYWx1ZSIsImF4IiwiYXhpc1N1YlgiLCIkYXhpcyIsInhEb21haW5Gb3Jab29tIiwiaGFzWm9vbSIsImF4aXNTY2FsZSIsInNldEN1bGxpbmciLCJ0b0N1bGwiLCJpbnRlcnZhbEZvckN1bGxpbmciLCJ0aWNrU2l6ZSIsImN1bGxpbmdNYXgiLCJhbHREb21haW4iLCJzeCIsInN5IiwibXgiLCJteSIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJpc0luY2x1ZGVkIiwidG9nZ2xlUG9pbnQiLCJ0b2dnbGVQYXRoIiwic2V0RHJhZ1N0YXR1cyIsImlzRHJhZ2dpbmciLCJmbG93TGVuZ3RoIiwidXBkYXRlWEdyaWQiLCJlbGVtZW50cyIsInNldEZsb3dMaXN0IiwiZmxvd0luZGV4IiwiZ2V0Rmxvd1RyYW5zZm9ybSIsIndhaXQiLCJndCIsImVhc2UiLCJkM0Vhc2VMaW5lYXIiLCJpc1JlZ2lvbk9uWCIsImNsZWFuVXBGbG93IiwicmVnaW9uWCIsInJlZ2lvbldpZHRoIiwieEZ1bmMiLCJ5RnVuYyIsInJlZHJhd0V2ZW50UmVjdCIsInRyYW5zbGF0ZVgiLCJmbG93U3RhcnQiLCJmbG93RW5kIiwic2NhbGVYIiwiZXZlbnRSZWN0VXBkYXRlIiwiZ2VuZXJhdGVFdmVudFJlY3RzRm9yTXVsdGlwbGVYcyIsInhBeGlzVGlja1ZhbHVlcyIsInVwZGF0ZVBvaW50Q2xhc3MiLCJnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYIiwidXBkYXRlRXZlbnRSZWN0IiwiYmluZFRvdWNoT25FdmVudFJlY3QiLCJzdGFydFB4IiwiZ2V0RXZlbnRSZWN0IiwiZWxlbWVudEZyb21Qb2ludCIsImdldEluZGV4Iiwic2VsZWN0UmVjdCIsImNvbnRleHQiLCJzZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyIsInVuc2VsZWN0UmVjdCIsInNlbGVjdFJlY3RGb3JTaW5nbGUiLCJwcmV2ZW50RGVmYXVsdCIsImlzUHJldmVudGVkIiwicHJldmVudFRocmVzaG9sZCIsInByZXZlbnRFdmVudCIsImN1cnJlbnRYWSIsInRvZ2dsZVNoYXBlIiwiZXZlbnRSZWN0RGF0YSIsInJlY3RXIiwicmVjdFgiLCJnZXRFdmVudFJlY3RXaWR0aCIsImdldFByZXZOZXh0WCIsInByZXYiLCJuZXh0IiwidGhpc1giLCJpc1NlbGVjdGlvbkVuYWJsZWQiLCJpc1NlbGVjdGlvbkdyb3VwZWQiLCJpc1Rvb2x0aXBHcm91cGVkIiwic2hvd0dyaWRGb2N1cyIsImV4cGFuZENpcmNsZXMiLCJleHBhbmRCYXJzIiwic2FtZVhEYXRhIiwiZXZlbnRSZWN0RW50ZXIiLCJjbGlja0hhbmRsZXJGb3JTaW5nbGVYIiwiZDIiLCJjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTIiwiaW5pdEJydXNoIiwiZDNCcnVzaFkiLCJkM0JydXNoWCIsImxhc3REb21haW4iLCJicnVzaEhhbmRsZXIiLCJyZWRyYXdGb3JCcnVzaCIsImdldEJydXNoU2l6ZSIsInVwZGF0ZSIsImV4dGVudCIsImdldEV4dGVudCIsInZpc2liaWxpdHkiLCJjbGlwSWQiLCJnZXRDbGlwUGF0aCIsImJhclVwZGF0ZSIsImJhckVudGVyIiwibGluZUVudGVyIiwidXBkYXRlQmFyRm9yU3ViY2hhcnQiLCJyZWRyYXdCYXJGb3JTdWJjaGFydCIsImRyYXdCYXJPblN1YiIsInVwZGF0ZUxpbmVGb3JTdWJjaGFydCIsInJlZHJhd0xpbmVGb3JTdWJjaGFydCIsImRyYXdMaW5lT25TdWIiLCJ1cGRhdGVBcmVhRm9yU3ViY2hhcnQiLCJyZWRyYXdBcmVhRm9yU3ViY2hhcnQiLCJkcmF3QXJlYU9uU3ViIiwiZHJhdyIsIm9uQnJ1c2giLCJzdWJYQXhpcyIsImdlbmVyYXRlWm9vbSIsImluaXRab29tQmVoYXZpb3VyIiwiYmluZFpvb21PbkV2ZW50UmVjdCIsImQzWm9vbSIsIm9uWm9vbVN0YXJ0Iiwib25ab29tIiwib25ab29tRW5kIiwib3JnU2NhbGVFeHRlbnQiLCJyZXNjYWxlIiwic291cmNlRXZlbnQiLCJzdGFydEV2ZW50IiwiaXNNb3VzZW1vdmUiLCJpc1pvb21PdXQiLCJ3aGVlbERlbHRhIiwiZGVsdGEiLCJpc2Z1bGx5U2hvd24iLCJiZWhhdmlvdXIiLCJ6b29tQmVoYXZpb3VyIiwicHJvcCIsImNsaWNrRGlzdGFuY2UiLCJyZXNldEJ1dHRvbiIsIm9uY2xpY2siLCJpc0lFOSIsImFwcFZlcnNpb24iLCJVUkwiLCJnZXRBeGlzQ2xpcFgiLCJnZXRBeGlzQ2xpcFkiLCJnZXRBeGlzQ2xpcFdpZHRoIiwiZ2V0QXhpc0NsaXBIZWlnaHQiLCJuZXdYQXhpc0hlaWdodCIsImNsaXBYQXhpc1RpY2tUZXh0cyIsInNldFhBeGlzVGlja0NsaXBXaWR0aCIsInNldFhBeGlzVGlja1RleHRDbGlwUGF0aFdpZHRoIiwic2luUm90YXRpb24iLCJnZXRHcmlkVGV4dEFuY2hvciIsImdldEdyaWRUZXh0RHgiLCJnZXRHcmlkVGV4dFgiLCJzbW9vdGhMaW5lcyIsImluaXRHcmlkTGluZXMiLCJpbml0Rm9jdXNHcmlkIiwid2l0aG91dFVwZGF0ZSIsInhncmlkRGF0YSIsImdlbmVyYXRlR3JpZERhdGEiLCJ1cGRhdGVZR3JpZCIsImdyaWRWYWx1ZXMiLCJ1cGRhdGVYR3JpZExpbmVzIiwidXBkYXRlWUdyaWRMaW5lcyIsInhMaW5lcyIsImlzRnJvbnQiLCJmb2N1c0VsIiwiaXNFZGdlIiwieHkiLCJoaWRlQ2lyY2xlRm9jdXMiLCJ0aWNrTnVtIiwiZ3JpZERhdGEiLCJmaXJzdFllYXIiLCJnZXRGdWxsWWVhciIsImxhc3RZZWFyIiwiZ2V0R3JpZEZpbHRlclRvUmVtb3ZlIiwidG9SZW1vdmUiLCJyZWdpb25ZIiwicmVnaW9uSGVpZ2h0IiwiZ2V0UmVnaW9uWFkiLCJnZXRSZWdpb25TaXplIiwiaXNXaWR0aCIsInNlbGVjdFBvaW50IiwidW5zZWxlY3RQb2ludCIsIm1ldGhvZCIsInNlbGVjdFBhdGgiLCJkM1JnYiIsImJyaWdodGVyIiwidW5zZWxlY3RQYXRoIiwidG9nZ2xlZFNoYXBlIiwiYWxsb3dlZFhBeGlzVHlwZXMiLCJuZWVkVG9Sb3RhdGVYQXhpc1RpY2tUZXh0cyIsInhBeGlzTGVuZ3RoIiwidGlja0NvdW50V2l0aFBhZGRpbmciLCJhcGlBeGlzIiwiYXBpQ2F0ZWdvcnkiLCJhcGlGbG93IiwiYXBpWEdyaWQiLCJhcGlZR3JpZCIsImFwaUdyb3VwIiwiYXBpUmVnaW9uIiwiYXBpU2VsZWN0aW9uIiwiYXBpWCIsImFwaVpvb20iLCJldmVudHJlY3QiLCJzaXplQXhpcyIsImluaXRQaWUiLCJzdGFydGluZ0FuZ2xlIiwiZDNQaWUiLCJzb3J0VmFsdWVzIiwiZ2V0SW5uZXJSYWRpdXMiLCJzdmdBcmMiLCJnZXRTdmdBcmMiLCJzdmdBcmNFeHBhbmRlZCIsImdldFN2Z0FyY0V4cGFuZGVkIiwidXBkYXRlQW5nbGUiLCJkVmFsdWUiLCJnU3RhcnQiLCJ0b3RhbFN1bSIsImdFbmQiLCJtYXhWYWx1ZSIsImdNaW4iLCJnTWF4IiwiZ1ZhbHVlIiwiaXIiLCJzaW5nbGVBcmNXaWR0aCIsImQzQXJjIiwib3V0ZXJSYWRpdXMiLCJuZXdBcmMiLCJ1cGRhdGVkIiwiY2VudHJvaWQiLCJyYXRlIiwibmV3UmF0ZSIsImV4cGFuZFdpZHRoIiwiZ2V0QXJjIiwidHJhbnNmb3JtRm9yQXJjTGFiZWwiLCJjb252ZXJ0VG9BcmNEYXRhIiwidGV4dEZvckFyY0xhYmVsIiwic2hvdWxkU2hvd0FyY0xhYmVsIiwiaXNVbmRlclRocmVzaG9sZCIsIm1lZXRzQXJjTGFiZWxUaHJlc2hvbGQiLCJnZXRBcmNMYWJlbEZvcm1hdCIsInRleHRGb3JHYXVnZU1pbk1heCIsImlzTWF4Iiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibmV3VGFyZ2V0SWRzIiwic2hvdWxkRXhwYW5kIiwiZXhwYW5kRHVyYXRpb24iLCJnZXRFeHBhbmRDb25maWciLCJzdmdBcmNFeHBhbmRlZFN1YiIsImdldEFyY1RpdGxlIiwibWFpblBpZVVwZGF0ZSIsIm1haW5QaWVFbnRlciIsImluaXRBcmMiLCJzZXRBcmNUaXRsZSIsIm1haW5BcmMiLCJfY3VycmVudCIsInJlZHJhd011bHRpQXJjR2F1Z2UiLCJhdHRyVHdlZW4iLCJpbnRlcnBvbGF0ZSIsImQzSW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWQiLCJiaW5kQXJjRXZlbnQiLCJyZWRyYXdBcmNUZXh0IiwiYXJjTGFiZWxMaW5lcyIsIm1haW5BcmNMYWJlbExpbmUiLCJsaW5lTGVuZ3RoIiwibGluZVRoaWNrbmVzcyIsImlubmVyTGluZUxlbmd0aCIsImxpbmVBbmdsZSIsImFyY0lubmVyUmFkaXVzIiwibGluZVBvc2l0aW9uaW5nQW5nbGUiLCJzZWxlY3RBcmMiLCJfdGhpcyIsInVuc2VsZWN0QXJjIiwiaXNNb3VzZSIsInJhZGFycyIsImdldEV2ZW50QXJjIiwiZXZlbnRBcmMiLCJoYW5kbGVyIiwiaXNGdWxsQ2lyY2xlIiwiYmFja2dyb3VuZEFyYyIsImQxIiwiaW5pdEdhdWdlIiwiYXBwZW5kVGV4dCIsImluaXRBcmVhIiwibWFpbkxpbmVFbnRlciIsInVwZGF0ZUFyZWFHcmFkaWVudCIsInN0b3BzIiwibGluZWFyR3JhZGllbnQiLCJzdG9wQ29sb3IiLCJ1cGRhdGVBcmVhQ29sb3IiLCJkcmF3QXJlYSIsImFyZWFJbmRpY2VzIiwibGluZUNvbm5lY3ROdWxsIiwiZ2V0UG9pbnRzIiwiZ2VuZXJhdGVHZXRBcmVhUG9pbnRzIiwieFZhbHVlIiwidmFsdWUwIiwidmFsdWUxIiwieDAiLCJkM0FyZWEiLCJkZWZpbmVkIiwiY3VydmUiLCJnZXRDdXJ2ZSIsImFyZWFPZmZzZXQiLCJwb3NYIiwicG9zWSIsImluaXRCYXIiLCJtYWluQmFyVXBkYXRlIiwibWFpbkJhckVudGVyIiwiZHJhd0JhciIsImdldEJhclciLCJiYXJUYXJnZXRzTnVtIiwicmVzdWx0IiwiZ2V0V2lkdGgiLCJnZXRCYXJzIiwic3VmZml4IiwiYmFySW5kaWNlcyIsImdlbmVyYXRlR2V0QmFyUG9pbnRzIiwiYmFyUmFkaXVzIiwiYmFyUmFkaXVzUmF0aW8iLCJnZXRSYWRpdXMiLCJpbmRleFgiLCJpbmRleFkiLCJpc05lZ2F0aXZlIiwicGF0aFJhZGl1cyIsImJhclciLCJiYXJYIiwiYmFyWSIsImJhck9mZnNldCIsInNlZzAiLCJzZWcxIiwiaW5pdEJ1YmJsZSIsImdldEJhc2VMZW5ndGgiLCJiYXNlTGVuZ3RoIiwiZ2V0QnViYmxlUiIsIm1heFIiLCJtaWQiLCJtYXhBcmVhIiwiaW5pdExpbmUiLCJtYWluTGluZVVwZGF0ZSIsImRyYXdMaW5lIiwiaXNSb3RhdGVkU3RlcFR5cGUiLCJvcmdQb2ludCIsInBvaW50Um90YXRlZCIsIl9wb2ludCIsIl95IiwiX3QiLCJfY29udGV4dCIsImxpbmVUbyIsIl94IiwibGluZUluZGljZXMiLCJnZW5lcmF0ZUdldExpbmVQb2ludHMiLCJ5VmFsdWUiLCJkM0xpbmUiLCJsaW5lV2l0aFJlZ2lvbnMiLCJfcmVnaW9ucyIsInhwIiwieXAiLCJkaWZmeDIiLCJkYXNoYXJyYXkiLCJpc1dpdGhpblJlZ2lvbnMiLCJ3aXRoaW5YIiwid2l0aGluUmVnaW9ucyIsInJlZyIsImdldFZhbHVlIiwiZHQiLCJnZW5lcmF0ZU0iLCJzV2l0aFJlZ2lvbiIsImQwIiwidGltZXNlcmllc0RpZmYiLCJ4RGlmZiIsInh2MCIsInh2MSIsIm90aGVyRGlmZiIsInByZXZEYXRhIiwiaGFzUHJldkRhdGEiLCJkZCIsInNob3VsZERyYXdQb2ludHNGb3JMaW5lIiwibGluZVBvaW50IiwiZ2V0VHJhbnNpdGlvbk5hbWUiLCJoYXNWYWxpZFBvaW50RHJhd01ldGhvZHMiLCJwb2ludFR5cGUiLCJpbml0aWFsT3BhY2l0eUZvckNpcmNsZSIsIm9wYWNpdHlGb3JDaXJjbGUiLCJpbml0Q2lyY2xlIiwibWFpbkNpcmNsZSIsIm1haW5DaXJjbGVFbnRlciIsImZvY3VzT25seSIsImN1cnJJbmRleCIsInBvc0F0dHIiLCJvcGFjaXR5U3R5bGVGbiIsIm1haW5DaXJjbGVzIiwiZ2V0Q2lyY2xlcyIsInBvaW50RXhwYW5kZWRSIiwic2VsZWN0UiIsImluc2VydFBvaW50SW5mb0RlZnMiLCJjb3B5QXR0ciIsImZyb20iLCJhdHRyaWJzIiwiZ2V0QXR0cmlidXRlIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiZG9jdW1lbnRFbGVtZW50IiwiZmlsbCIsInN0cm9rZSIsImlubmVySFRNTCIsInBvaW50RnJvbURlZnMiLCJwb2ludENsYXNzIiwiaXNTdWJWYWx1ZSIsImxpbmVPZmZzZXQiLCJwb2ludElkIiwiY3VzdG9tIiwic2l6ZUZuIiwiZmlsbFN0eWxlRm4iLCJ4UG9zRm4iLCJ5UG9zRm4iLCJ4UG9zRm4yIiwidHJhbnNpdGlvbk5hbWUiLCJyZWN0YW5nbGUiLCJyZWN0U2l6ZUZuIiwicmVjdFhQb3NGbiIsImdldFBvc2l0aW9uIiwiaXNDbG9ja3dpc2UiLCJlZGdlIiwiZnVuYyIsImluaXRSYWRhciIsImdlbmVyYXRlUmFkYXJQb2ludHMiLCJnZXRSYWRhclBvc2l0aW9uIiwiX3NpemUiLCJ1cGRhdGVSYWRhckxldmVsIiwidXBkYXRlUmFkYXJBeGVzIiwidXBkYXRlUmFkYXJTaGFwZSIsImdlbmVyYXRlR2V0UmFkYXJQb2ludHMiLCJkZXB0aCIsInNob3dUZXh0IiwicmFkYXJMZXZlbHMiLCJsZXZlbERhdGEiLCJsZXZlbFJhdGlvIiwibGV2ZWxUZXh0Rm9ybWF0IiwibGV2ZWxFbnRlciIsImF4aXNFbnRlciIsImZpcnN0Q2hpbGQiLCJiaW5kRXZlbnQiLCJub0luZGV4IiwiYXJlYXNFbnRlciIsImRlZmF1bHRzIiwiYmIiLCJ2ZXJzaW9uIiwiZ2VuZXJhdGUiLCJpbnN0IiwiaW5zdGFuY2UiLCJwbHVnaW4iLCJpbnRlcm5hbEF4aXMiLCJzaGFwZUFyYyIsInNoYXBlQXJlYSIsInNoYXBlQmFyIiwic2hhcGVCdWJibGUiLCJzaGFwZUxpbmUiLCJzaGFwZVBvaW50Iiwic2hhcGVSYWRhciJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87UUNWQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7O1FBR0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDBDQUEwQyxnQ0FBZ0M7UUFDMUU7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSx3REFBd0Qsa0JBQWtCO1FBQzFFO1FBQ0EsaURBQWlELGNBQWM7UUFDL0Q7O1FB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Q0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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OztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtEQUFrRCxXQUFXO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLDBRQUEwUTtBQUM3UTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsZ0ZBQWdGO0FBQ25GO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0dBQXdHO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxxRkFBcUY7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLCtJQUErSTtBQUNsSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxtRkFBbUY7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlGQUF5Rjs7QUFFekY7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLHFEQUFxRDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9GQUFvRjtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxREFBcUQ7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHlHQUF5RztBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFxRCxtQkFBbUIsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsa0lBQWtJO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsd0RBQXdEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMsRUFBRSxXQUFXO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLGNBQWM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLGtEQUFrRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsb0NBQW9DO0FBQ3ZDLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxFQUFFLFlBQVk7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLFdBQVc7QUFDZDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsMEJBQTBCO0FBQzdCOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksTUFBTTtBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUEsdUJBQXVCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFN1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLGlCQUFpQjtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsY0FBYztBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCLGFBQWE7QUFDYjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsQ0FBQyxFQUFFLFFBQVE7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLGtDQUFrQyxpREFBaUQ7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFvRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsOEJBQThCO0FBQ3ZFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDZCQUE2QjtBQUM3Rix1RUFBdUUsaUNBQWlDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnQkFBZ0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHdEQUF3RCwwRUFBMEUsT0FBTywwQkFBMEIsU0FBUztBQUM1SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxnRUFBZ0UsZ0JBQWdCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDJCQUEyQjtBQUM1RjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckMsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxrQkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2RkFBNkY7QUFDckgsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1HQUFtRztBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG1HQUFtRztBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pELEdBQUc7QUFDSCxzQ0FBc0M7QUFDdEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEseUJBQXlCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEVBQUUsdUNBQXVDLEVBQUUsR0FBRztBQUMvQyxDQUFDOzs7QUFHRDs7Ozs7Ozs7QUN6ckxhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsRzs7Ozs7OztBQzFCWTtBQUNiOztBQUVBLGVBQWUsbUJBQU8sQ0FBQyxFQUFXOztBQUVsQyxlQUFlLG1CQUFPLENBQUMsRUFBZTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0EsZ0RBQWdEOztBQUVoRDtBQUNBLEdBQUcsRUFBRTtBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7OztBQ3ZIWTs7QUFFWjs7QUFFQTtBQUNBLG1EQUFtRCxJQUFJLFNBQVMsTUFBTSxJQUFJOztBQUUxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsR0FBRztBQUNIO0FBQ0Esc0JBQXNCO0FBQ3RCLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVSwrQkFBK0I7QUFDaEY7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7OztBQy9LYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELHFCQUFxQixtQkFBTyxDQUFDLEVBQWdCO0FBQzdDO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsRUFBa0I7QUFDakQ7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxFQUFrQjtBQUNqRDtBQUNBOzs7Ozs7OztBQ1JhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFNBQVM7QUFDVCxXQUFXO0FBQ1gsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7Ozs7OztBQ2pIYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7Ozs7Ozs7O0FDN0dhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0RhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBOztBQUVBLHdDOzs7Ozs7QUNyQkE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUI7Ozs7OztBQ3RCQTs7QUFFQTs7QUFFQTtBQUNB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ZSI6ImJpbGxib2FyZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImQzLXRpbWUtZm9ybWF0XCIpLCByZXF1aXJlKFwiZDMtc2VsZWN0aW9uXCIpLCByZXF1aXJlKFwiZDMtYnJ1c2hcIiksIHJlcXVpcmUoXCJkMy1kc3ZcIiksIHJlcXVpcmUoXCJkMy1kcmFnXCIpLCByZXF1aXJlKFwiZDMtc2NhbGVcIiksIHJlcXVpcmUoXCJkMy10cmFuc2l0aW9uXCIpLCByZXF1aXJlKFwiZDMtc2hhcGVcIiksIHJlcXVpcmUoXCJkMy16b29tXCIpLCByZXF1aXJlKFwiZDMtYXhpc1wiKSwgcmVxdWlyZShcImQzLWVhc2VcIiksIHJlcXVpcmUoXCJkMy1jb2xvclwiKSwgcmVxdWlyZShcImQzLWludGVycG9sYXRlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImQzLXRpbWUtZm9ybWF0XCIsIFwiZDMtc2VsZWN0aW9uXCIsIFwiZDMtYnJ1c2hcIiwgXCJkMy1kc3ZcIiwgXCJkMy1kcmFnXCIsIFwiZDMtc2NhbGVcIiwgXCJkMy10cmFuc2l0aW9uXCIsIFwiZDMtc2hhcGVcIiwgXCJkMy16b29tXCIsIFwiZDMtYXhpc1wiLCBcImQzLWVhc2VcIiwgXCJkMy1jb2xvclwiLCBcImQzLWludGVycG9sYXRlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJkMy10aW1lLWZvcm1hdFwiKSwgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgcmVxdWlyZShcImQzLWJydXNoXCIpLCByZXF1aXJlKFwiZDMtZHN2XCIpLCByZXF1aXJlKFwiZDMtZHJhZ1wiKSwgcmVxdWlyZShcImQzLXNjYWxlXCIpLCByZXF1aXJlKFwiZDMtdHJhbnNpdGlvblwiKSwgcmVxdWlyZShcImQzLXNoYXBlXCIpLCByZXF1aXJlKFwiZDMtem9vbVwiKSwgcmVxdWlyZShcImQzLWF4aXNcIiksIHJlcXVpcmUoXCJkMy1lYXNlXCIpLCByZXF1aXJlKFwiZDMtY29sb3JcIiksIHJlcXVpcmUoXCJkMy1pbnRlcnBvbGF0ZVwiKSkgOiBmYWN0b3J5KHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zN19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Ml9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180M19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Nl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180N19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180OF9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpLFxuICAgIGxvZyA9IF9yZXF1aXJlLmxvZyxcbiAgICBzZXRMb2dMZXZlbCA9IF9yZXF1aXJlLnNldExvZ0xldmVsO1xuXG52YXIgc2VuZE1lc3NhZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3NlbmRNZXNzYWdlJyk7XG5cbnZhciByZWxvYWRBcHAgPSByZXF1aXJlKCcuL3V0aWxzL3JlbG9hZEFwcCcpO1xuXG52YXIgY3JlYXRlU29ja2V0VXJsID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTb2NrZXRVcmwnKTtcblxudmFyIHN0YXR1cyA9IHtcbiAgaXNVbmxvYWRpbmc6IGZhbHNlLFxuICBjdXJyZW50SGFzaDogJydcbn07XG52YXIgb3B0aW9ucyA9IHtcbiAgaG90OiBmYWxzZSxcbiAgaG90UmVsb2FkOiB0cnVlLFxuICBsaXZlUmVsb2FkOiBmYWxzZSxcbiAgaW5pdGlhbDogdHJ1ZSxcbiAgdXNlV2FybmluZ092ZXJsYXk6IGZhbHNlLFxuICB1c2VFcnJvck92ZXJsYXk6IGZhbHNlLFxuICB1c2VQcm9ncmVzczogZmFsc2Vcbn07XG52YXIgc29ja2V0VXJsID0gY3JlYXRlU29ja2V0VXJsKF9fcmVzb3VyY2VRdWVyeSk7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgc3RhdHVzLmlzVW5sb2FkaW5nID0gdHJ1ZTtcbn0pO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHFzID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICBvcHRpb25zLmhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cblxudmFyIG9uU29ja2V0TWVzc2FnZSA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC4nKTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7IC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnSW52YWxpZCcpO1xuICB9LFxuICBoYXNoOiBmdW5jdGlvbiBoYXNoKF9oYXNoKSB7XG4gICAgc3RhdHVzLmN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ1N0aWxsT2snKTtcbiAgfSxcbiAgJ2xvZy1sZXZlbCc6IGZ1bmN0aW9uIGxvZ0xldmVsKGxldmVsKSB7XG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XG5cbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG5cbiAgICBzZXRMb2dMZXZlbChsZXZlbCk7XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlLmVycm9ycztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhfcHJvZ3Jlc3MpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy51c2VQcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgICB9XG4gIH0sXG4gICdwcm9ncmVzcy11cGRhdGUnOiBmdW5jdGlvbiBwcm9ncmVzc1VwZGF0ZShkYXRhKSB7XG4gICAgaWYgKG9wdGlvbnMudXNlUHJvZ3Jlc3MpIHtcbiAgICAgIGxvZy5pbmZvKFwiW1dEU10gXCIuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnUHJvZ3Jlc3MnLCBkYXRhKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKCdPaycpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQ29udGVudCBiYXNlIGNoYW5nZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBEaXNjb25uZWN0ZWQhJyk7XG4gICAgc2VuZE1lc3NhZ2UoJ0Nsb3NlJyk7XG4gIH1cbn07XG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1lc3NhZ2UpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gKi9cblxuLyogZXNsaW50LWRpc2FibGVcbiAgY2FtZWxjYXNlXG4qL1xuLy8gdGhpcyBTb2NrSlNDbGllbnQgaXMgaGVyZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2ssIGluIGNhc2UgaW5saW5lIG1vZGVcbi8vIGlzIG9mZiBvciB0aGUgY2xpZW50IGlzIG5vdCBpbmplY3RlZC4gVGhpcyB3aWxsIGJlIHN3aXRjaGVkIHRvXG4vLyBXZWJzb2NrZXRDbGllbnQgd2hlbiBpdCBiZWNvbWVzIHRoZSBkZWZhdWx0XG4vLyBpbXBvcnRhbnQ6IHRoZSBwYXRoIHRvIFNvY2tKU0NsaWVudCBoZXJlIGlzIG1hZGUgdG8gd29yayBpbiB0aGUgJ2NsaWVudCdcbi8vIGRpcmVjdG9yeSwgYnV0IGlzIHVwZGF0ZWQgdmlhIHRoZSB3ZWJwYWNrIGNvbXBpbGF0aW9uIHdoZW4gY29tcGlsZWQgZnJvbVxuLy8gdGhlICdjbGllbnQtc3JjJyBkaXJlY3RvcnlcblxudmFyIENsaWVudCA9IHR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxucmVxdWlyZSgnLi9jbGllbnRzL1NvY2tKU0NsaWVudCcpO1xudmFyIHJldHJpZXMgPSAwO1xudmFyIGNsaWVudCA9IG51bGw7XG5cbnZhciBzb2NrZXQgPSBmdW5jdGlvbiBpbml0U29ja2V0KHVybCwgaGFuZGxlcnMpIHtcbiAgY2xpZW50ID0gbmV3IENsaWVudCh1cmwpO1xuICBjbGllbnQub25PcGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXRyaWVzID0gMDtcbiAgfSk7XG4gIGNsaWVudC5vbkNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9IC8vIFRyeSB0byByZWNvbm5lY3QuXG5cblxuICAgIGNsaWVudCA9IG51bGw7IC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cblxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycyk7XG4gICAgICB9LCByZXRyeUluTXMpO1xuICAgIH1cbiAgfSk7XG4gIGNsaWVudC5vbk1lc3NhZ2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbXNnID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgIGlmIChoYW5kbGVyc1ttc2cudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21zZy50eXBlXShtc2cuZGF0YSk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29ja2V0OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG52YXIgU29ja0pTID0gcmVxdWlyZSgnc29ja2pzLWNsaWVudC9kaXN0L3NvY2tqcycpO1xuXG52YXIgQmFzZUNsaWVudCA9IHJlcXVpcmUoJy4vQmFzZUNsaWVudCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VDbGllbnQpIHtcbiAgX2luaGVyaXRzKFNvY2tKU0NsaWVudCwgX0Jhc2VDbGllbnQpO1xuXG4gIGZ1bmN0aW9uIFNvY2tKU0NsaWVudCh1cmwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU29ja0pTQ2xpZW50KTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNvY2tKU0NsaWVudCkuY2FsbCh0aGlzKSk7XG4gICAgX3RoaXMuc29jayA9IG5ldyBTb2NrSlModXJsKTtcblxuICAgIF90aGlzLnNvY2sub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHsvLyBUT0RPOiB1c2UgbG9nZ2VyIHRvIGxvZyB0aGUgZXJyb3IgZXZlbnQgb25jZSBjbGllbnQgYW5kIGNsaWVudC1zcmNcbiAgICAgIC8vIGFyZSByZW9yZ2FuaXplZCB0byBoYXZlIHRoZSBzYW1lIGRpcmVjdG9yeSBzdHJ1Y3R1cmVcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNvY2tKU0NsaWVudCwgW3tcbiAgICBrZXk6IFwib25PcGVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uT3BlbihmKSB7XG4gICAgICB0aGlzLnNvY2sub25vcGVuID0gZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsb3NlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbmNsb3NlID0gZjtcbiAgICB9IC8vIGNhbGwgZiB3aXRoIHRoZSBtZXNzYWdlIHN0cmluZyBhcyB0aGUgZmlyc3QgYXJndW1lbnRcblxuICB9LCB7XG4gICAga2V5OiBcIm9uTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk1lc3NhZ2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGYoZS5kYXRhKTtcbiAgICAgIH07XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiByZXF1aXJlLnJlc29sdmUoJy4vU29ja0pTQ2xpZW50Jyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNvY2tKU0NsaWVudDtcbn0oQmFzZUNsaWVudCk7IiwiLyogc29ja2pzLWNsaWVudCB2MS40LjAgfCBodHRwOi8vc29ja2pzLm9yZyB8IE1JVCBsaWNlbnNlICovXG4oZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cIm9iamVjdFwiJiZ0eXBlb2YgbW9kdWxlIT09XCJ1bmRlZmluZWRcIil7bW9kdWxlLmV4cG9ydHM9ZigpfWVsc2UgaWYodHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCIpe2c9d2luZG93fWVsc2UgaWYodHlwZW9mIGdsb2JhbCE9PVwidW5kZWZpbmVkXCIpe2c9Z2xvYmFsfWVsc2UgaWYodHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zy5Tb2NrSlMgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHRyYW5zcG9ydExpc3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC1saXN0Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tYWluJykodHJhbnNwb3J0TGlzdCk7XG5cbi8vIFRPRE8gY2FuJ3QgZ2V0IHJpZCBvZiB0aGlzIHVudGlsIGFsbCBzZXJ2ZXJzIGRvXG5pZiAoJ19zb2NranNfb25sb2FkJyBpbiBnbG9iYWwpIHtcbiAgc2V0VGltZW91dChnbG9iYWwuX3NvY2tqc19vbmxvYWQsIDEpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL21haW5cIjoxNCxcIi4vdHJhbnNwb3J0LWxpc3RcIjoxNn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0eXBlID0gYXJndW1lbnRzWzBdO1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkobCAtIDEpO1xuICBmb3IgKHZhciBhaSA9IDE7IGFpIDwgbDsgYWkrKykge1xuICAgIGFyZ3NbYWkgLSAxXSA9IGFyZ3VtZW50c1thaV07XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSx7XCIuL2V2ZW50dGFyZ2V0XCI6NSxcImluaGVyaXRzXCI6NTd9XSw0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbn1cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB0aGlzLnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZXZlbnQgPSBhcmd1bWVudHNbMF07XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBbZXZlbnRdIDogQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgLy8gVE9ETzogVGhpcyBkb2Vzbid0IG1hdGNoIHRoZSByZWFsIGJlaGF2aW9yOyBwZXIgc3BlYywgb25mb28gZ2V0XG4gIC8vIHRoZWlyIHBsYWNlIGluIGxpbmUgZnJvbSB0aGUgL2ZpcnN0LyB0aW1lIHRoZXkncmUgc2V0IGZyb21cbiAgLy8gbm9uLW51bGwuIEFsdGhvdWdoIFdlYktpdCBidW1wcyBpdCB0byB0aGUgZW5kIGV2ZXJ5IHRpbWUgaXQnc1xuICAvLyBzZXQuXG4gIGlmICh0aGlzWydvbicgKyB0XSkge1xuICAgIHRoaXNbJ29uJyArIHRdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG4gIGlmICh0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgIC8vIEdyYWIgYSByZWZlcmVuY2UgdG8gdGhlIGxpc3RlbmVycyBsaXN0LiByZW1vdmVFdmVudExpc3RlbmVyIG1heSBhbHRlciB0aGUgbGlzdC5cbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3RdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5pbmhlcml0cyhUcmFuc3BvcnRNZXNzYWdlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgO1xuXG5mdW5jdGlvbiBGYWNhZGVKUyh0cmFuc3BvcnQpIHtcbiAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0cmFuc3BvcnQub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICB0cmFuc3BvcnQub24oJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG59XG5cbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ2MnLCBKU09OMy5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihmcmFtZSkge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgndCcsIGZyYW1lKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX3NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmFjYWRlSlM7XG5cbn0se1wiLi91dGlscy9pZnJhbWVcIjo0NyxcImpzb24zXCI6NTh9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vZmFjYWRlXCI6NyxcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vbG9jYXRpb25cIjoxMyxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi91dGlscy9vYmplY3RcIjo0OSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvaWZyYW1lJylcbiAgLCBJbmZvUmVjZWl2ZXJJZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8taWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIGdvID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlmciA9IHNlbGYuaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydChJbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSwgdXJsLCBiYXNlVXJsKTtcblxuICAgIGlmci5vbmNlKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgICBpZiAobXNnKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGQgPSBKU09OMy5wYXJzZShtc2cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgbXNnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5mbyA9IGRbMF0sIHJ0dCA9IGRbMV07XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgIH1cbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcblxuICAgIGlmci5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBUT0RPIHRoaXMgc2VlbXMgdGhlIHNhbWUgYXMgdGhlICduZWVkQm9keScgZnJvbSB0cmFuc3BvcnRzXG4gIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkpIHtcbiAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgfSBlbHNlIHtcbiAgICBnbygpO1xuICB9XG59XG5cbmluaGVyaXRzKEluZm9JZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9JZnJhbWUuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cbkluZm9JZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlmcikge1xuICAgIHRoaXMuaWZyLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5pZnIgPSBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvSWZyYW1lO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL3RyYW5zcG9ydC9pZnJhbWVcIjoyMixcIi4vdXRpbHMvZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2luZm8tYWpheFwiOjksXCIuL2luZm8taWZyYW1lXCI6MTEsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGRyXCI6MzQsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZVwiOjM2LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHA6J1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbXMnKTtcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi91dGlscy9yYW5kb20nKVxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXInKVxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnQnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudHRhcmdldCcpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gICwgQ2xvc2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvY2xvc2UnKVxuICAsIFRyYW5zcG9ydE1lc3NhZ2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvdHJhbnMtbWVzc2FnZScpXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50Om1haW4nKTtcbn1cblxudmFyIHRyYW5zcG9ydHM7XG5cbi8vIGZvbGxvdyBjb25zdHJ1Y3RvciBzdGVwcyBkZWZpbmVkIGF0IGh0dHA6Ly9kZXYudzMub3JnL2h0bWw1L3dlYnNvY2tldHMvI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG5mdW5jdGlvbiBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tKUykpIHtcbiAgICByZXR1cm4gbmV3IFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1NvY2tKUzogMSBhcmd1bWVudCByZXF1aXJlZCwgYnV0IG9ubHkgMCBwcmVzZW50XCIpO1xuICB9XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNPTk5FQ1RJTkc7XG4gIHRoaXMuZXh0ZW5zaW9ucyA9ICcnO1xuICB0aGlzLnByb3RvY29sID0gJyc7XG5cbiAgLy8gbm9uLXN0YW5kYXJkIGV4dGVuc2lvblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKG9wdGlvbnMucHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgIGxvZy53YXJuKFwiJ3Byb3RvY29sc193aGl0ZWxpc3QnIGlzIERFUFJFQ0FURUQuIFVzZSAndHJhbnNwb3J0cycgaW5zdGVhZC5cIik7XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCA9IG9wdGlvbnMudHJhbnNwb3J0cztcbiAgdGhpcy5fdHJhbnNwb3J0T3B0aW9ucyA9IG9wdGlvbnMudHJhbnNwb3J0T3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fCAwO1xuXG4gIHZhciBzZXNzaW9uSWQgPSBvcHRpb25zLnNlc3Npb25JZCB8fCA4O1xuICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5kb20uc3RyaW5nKHNlc3Npb25JZCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJZiBzZXNzaW9uSWQgaXMgdXNlZCBpbiB0aGUgb3B0aW9ucywgaXQgbmVlZHMgdG8gYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyIHx8IHJhbmRvbS5udW1iZXJTdHJpbmcoMTAwMCk7XG5cbiAgLy8gU3RlcCAxIG9mIFdTIHNwZWMgLSBwYXJzZSBhbmQgdmFsaWRhdGUgdGhlIHVybC4gSXNzdWUgIzhcbiAgdmFyIHBhcnNlZFVybCA9IG5ldyBVUkwodXJsKTtcbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCB8fCAhcGFyc2VkVXJsLnByb3RvY29sKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCAnXCIgKyB1cmwgKyBcIicgaXMgaW52YWxpZFwiKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwuaGFzaCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVGhlIFVSTCBtdXN0IG5vdCBjb250YWluIGEgZnJhZ21lbnQnKTtcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwOicgJiYgcGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cHM6Jykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwncyBzY2hlbWUgbXVzdCBiZSBlaXRoZXIgJ2h0dHA6JyBvciAnaHR0cHM6Jy4gJ1wiICsgcGFyc2VkVXJsLnByb3RvY29sICsgXCInIGlzIG5vdCBhbGxvd2VkLlwiKTtcbiAgfVxuXG4gIHZhciBzZWN1cmUgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAvLyBTdGVwIDIgLSBkb24ndCBhbGxvdyBzZWN1cmUgb3JpZ2luIHdpdGggYW4gaW5zZWN1cmUgcHJvdG9jb2xcbiAgaWYgKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiYgIXNlY3VyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2VjdXJpdHlFcnJvcjogQW4gaW5zZWN1cmUgU29ja0pTIGNvbm5lY3Rpb24gbWF5IG5vdCBiZSBpbml0aWF0ZWQgZnJvbSBhIHBhZ2UgbG9hZGVkIG92ZXIgSFRUUFMnKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMyAtIGNoZWNrIHBvcnQgYWNjZXNzIC0gbm8gbmVlZCBoZXJlXG4gIC8vIFN0ZXAgNCAtIHBhcnNlIHByb3RvY29scyBhcmd1bWVudFxuICBpZiAoIXByb3RvY29scykge1xuICAgIHByb3RvY29scyA9IFtdO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgfVxuXG4gIC8vIFN0ZXAgNSAtIGNoZWNrIHByb3RvY29scyBhcmd1bWVudFxuICB2YXIgc29ydGVkUHJvdG9jb2xzID0gcHJvdG9jb2xzLnNvcnQoKTtcbiAgc29ydGVkUHJvdG9jb2xzLmZvckVhY2goZnVuY3Rpb24ocHJvdG8sIGkpIHtcbiAgICBpZiAoIXByb3RvKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGludmFsaWQuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IChzb3J0ZWRQcm90b2NvbHMubGVuZ3RoIC0gMSkgJiYgcHJvdG8gPT09IHNvcnRlZFByb3RvY29sc1tpICsgMV0pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgZHVwbGljYXRlZC5cIik7XG4gICAgfVxuICB9KTtcblxuICAvLyBTdGVwIDYgLSBjb252ZXJ0IG9yaWdpblxuICB2YXIgbyA9IHVybFV0aWxzLmdldE9yaWdpbihsb2MuaHJlZik7XG4gIHRoaXMuX29yaWdpbiA9IG8gPyBvLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuXG4gIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgc2xhc2hcbiAgcGFyc2VkVXJsLnNldCgncGF0aG5hbWUnLCBwYXJzZWRVcmwucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xuXG4gIC8vIHN0b3JlIHRoZSBzYW5pdGl6ZWQgdXJsXG4gIHRoaXMudXJsID0gcGFyc2VkVXJsLmhyZWY7XG4gIGRlYnVnKCd1c2luZyB1cmwnLCB0aGlzLnVybCk7XG5cbiAgLy8gU3RlcCA3IC0gc3RhcnQgY29ubmVjdGlvbiBpbiBiYWNrZ3JvdW5kXG4gIC8vIG9idGFpbiBzZXJ2ZXIgaW5mb1xuICAvLyBodHRwOi8vc29ja2pzLmdpdGh1Yi5pby9zb2NranMtcHJvdG9jb2wvc29ja2pzLXByb3RvY29sLTAuMy4zLmh0bWwjc2VjdGlvbi0yNlxuICB0aGlzLl91cmxJbmZvID0ge1xuICAgIG51bGxPcmlnaW46ICFicm93c2VyLmhhc0RvbWFpbigpXG4gICwgc2FtZU9yaWdpbjogdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gICwgc2FtZVNjaGVtZTogdXJsVXRpbHMuaXNTY2hlbWVFcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gIH07XG5cbiAgdGhpcy5faXIgPSBuZXcgSW5mb1JlY2VpdmVyKHRoaXMudXJsLCB0aGlzLl91cmxJbmZvKTtcbiAgdGhpcy5faXIub25jZSgnZmluaXNoJywgdGhpcy5fcmVjZWl2ZUluZm8uYmluZCh0aGlzKSk7XG59XG5cbmluaGVyaXRzKFNvY2tKUywgRXZlbnRUYXJnZXQpO1xuXG5mdW5jdGlvbiB1c2VyU2V0Q29kZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMDAwIHx8IChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KTtcbn1cblxuU29ja0pTLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAvLyBTdGVwIDFcbiAgaWYgKGNvZGUgJiYgIXVzZXJTZXRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkQWNjZXNzRXJyb3I6IEludmFsaWQgY29kZScpO1xuICB9XG4gIC8vIFN0ZXAgMi40IHN0YXRlcyB0aGUgbWF4IGlzIDEyMyBieXRlcywgYnV0IHdlIGFyZSBqdXN0IGNoZWNraW5nIGxlbmd0aFxuICBpZiAocmVhc29uICYmIHJlYXNvbi5sZW5ndGggPiAxMjMpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ3JlYXNvbiBhcmd1bWVudCBoYXMgYW4gaW52YWxpZCBsZW5ndGgnKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMy4xXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TSU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE8gbG9vayBhdCBkb2NzIHRvIGRldGVybWluZSBob3cgdG8gc2V0IHRoaXNcbiAgdmFyIHdhc0NsZWFuID0gdHJ1ZTtcbiAgdGhpcy5fY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24gfHwgJ05vcm1hbCBjbG9zdXJlJywgd2FzQ2xlYW4pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyAjMTMgLSBjb252ZXJ0IGFueXRoaW5nIG5vbi1zdHJpbmcgdG8gc3RyaW5nXG4gIC8vIFRPRE8gdGhpcyBjdXJyZW50bHkgdHVybnMgb2JqZWN0cyBpbnRvIFtvYmplY3QgT2JqZWN0XVxuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFRoZSBjb25uZWN0aW9uIGhhcyBub3QgYmVlbiBlc3RhYmxpc2hlZCB5ZXQnKTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnQuc2VuZChlc2NhcGUucXVvdGUoZGF0YSkpO1xufTtcblxuU29ja0pTLnZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuU29ja0pTLkNPTk5FQ1RJTkcgPSAwO1xuU29ja0pTLk9QRU4gPSAxO1xuU29ja0pTLkNMT1NJTkcgPSAyO1xuU29ja0pTLkNMT1NFRCA9IDM7XG5cblNvY2tKUy5wcm90b3R5cGUuX3JlY2VpdmVJbmZvID0gZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gIGRlYnVnKCdfcmVjZWl2ZUluZm8nLCBydHQpO1xuICB0aGlzLl9pciA9IG51bGw7XG4gIGlmICghaW5mbykge1xuICAgIHRoaXMuX2Nsb3NlKDEwMDIsICdDYW5ub3QgY29ubmVjdCB0byBzZXJ2ZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBlc3RhYmxpc2ggYSByb3VuZC10cmlwIHRpbWVvdXQgKFJUTykgYmFzZWQgb24gdGhlXG4gIC8vIHJvdW5kLXRyaXAgdGltZSAoUlRUKVxuICB0aGlzLl9ydG8gPSB0aGlzLmNvdW50UlRPKHJ0dCk7XG4gIC8vIGFsbG93IHNlcnZlciB0byBvdmVycmlkZSB1cmwgdXNlZCBmb3IgdGhlIGFjdHVhbCB0cmFuc3BvcnRcbiAgdGhpcy5fdHJhbnNVcmwgPSBpbmZvLmJhc2VfdXJsID8gaW5mby5iYXNlX3VybCA6IHRoaXMudXJsO1xuICBpbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKGluZm8sIHRoaXMuX3VybEluZm8pO1xuICBkZWJ1ZygnaW5mbycsIGluZm8pO1xuICAvLyBkZXRlcm1pbmUgbGlzdCBvZiBkZXNpcmVkIGFuZCBzdXBwb3J0ZWQgdHJhbnNwb3J0c1xuICB2YXIgZW5hYmxlZFRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzLmZpbHRlclRvRW5hYmxlZCh0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKTtcbiAgdGhpcy5fdHJhbnNwb3J0cyA9IGVuYWJsZWRUcmFuc3BvcnRzLm1haW47XG4gIGRlYnVnKHRoaXMuX3RyYW5zcG9ydHMubGVuZ3RoICsgJyBlbmFibGVkIHRyYW5zcG9ydHMnKTtcblxuICB0aGlzLl9jb25uZWN0KCk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKTsgVHJhbnNwb3J0OyBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCkpIHtcbiAgICBkZWJ1ZygnYXR0ZW1wdCcsIFRyYW5zcG9ydC50cmFuc3BvcnROYW1lKTtcbiAgICBpZiAoVHJhbnNwb3J0Lm5lZWRCb2R5KSB7XG4gICAgICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5IHx8XG4gICAgICAgICAgKHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2ludGVyYWN0aXZlJykpIHtcbiAgICAgICAgZGVidWcoJ3dhaXRpbmcgZm9yIGJvZHknKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0cy51bnNoaWZ0KFRyYW5zcG9ydCk7XG4gICAgICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCB0aGlzLl9jb25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRpbWVvdXQgYmFzZWQgb24gUlRPIGFuZCByb3VuZCB0cmlwcy4gRGVmYXVsdCB0byA1c1xuICAgIHZhciB0aW1lb3V0TXMgPSBNYXRoLm1heCh0aGlzLl90aW1lb3V0LCAodGhpcy5fcnRvICogVHJhbnNwb3J0LnJvdW5kVHJpcHMpIHx8IDUwMDApO1xuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xuICAgIGRlYnVnKCd1c2luZyB0aW1lb3V0JywgdGltZW91dE1zKTtcblxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuX3RyYW5zcG9ydE9wdGlvbnNbVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdO1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsLCBvcHRpb25zKTtcbiAgICB0cmFuc3BvcnRPYmoub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0T2JqO1xuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRNZXNzYWdlJywgbXNnKTtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gbXNnLnNsaWNlKDAsIDEpXG4gICAgLCBjb250ZW50ID0gbXNnLnNsaWNlKDEpXG4gICAgLCBwYXlsb2FkXG4gICAgO1xuXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xuICAgICAgZGVidWcoJ2hlYXJ0YmVhdCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQgPSBKU09OMy5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVidWcoJ2VtcHR5IHBheWxvYWQnLCBjb250ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBzZWxmLnRyYW5zcG9ydCwgcCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCB0aGlzLnRyYW5zcG9ydCwgcGF5bG9hZCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXNlclNldENvZGUoY29kZSkgJiYgY29kZSAhPT0gMjAwMCAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfb3BlbicsIHRoaXMuX3RyYW5zcG9ydCAmJiB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKTtcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgLy8gY29ubmVjdGlvbi5cbiAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB2YXIgZm9yY2VGYWlsID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2lyKSB7XG4gICAgZm9yY2VGYWlsID0gdHJ1ZTtcbiAgICB0aGlzLl9pci5jbG9zZSgpO1xuICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgaWYgKGZvcmNlRmFpbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XG4gICAgZS5jb2RlID0gY29kZSB8fCAxMDAwO1xuICAgIGUucmVhc29uID0gcmVhc29uO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XG4gIH0uYmluZCh0aGlzKSwgMCk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XG4gIC8vIEluIGEgbG9jYWwgZW52aXJvbm1lbnQsIHdoZW4gdXNpbmcgSUU4LzkgYW5kIHRoZSBganNvbnAtcG9sbGluZ2BcbiAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcbiAgLy8gYXJvdW5kIDIwMG1zZWMgKHRoZSBsb3dlciBib3VuZCB1c2VkIGluIHRoZSBhcnRpY2xlIGFib3ZlKSBhbmQgdGhpc1xuICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXG4gIGlmIChydHQgPiAxMDApIHtcbiAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICB9XG4gIHJldHVybiAzMDAgKyBydHQ7IC8vIDMwMG1zZWMgPCBydG8gPD0gNDAwbXNlY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHRyYW5zcG9ydHMgPSB0cmFuc3BvcnQoYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJldHVybiBTb2NrSlM7XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MixcIi4vZXZlbnQvZXZlbnRcIjo0LFwiLi9ldmVudC9ldmVudHRhcmdldFwiOjUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjo2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6OCxcIi4vaW5mby1yZWNlaXZlclwiOjEyLFwiLi9sb2NhdGlvblwiOjEzLFwiLi9zaGltc1wiOjE1LFwiLi91dGlscy9icm93c2VyXCI6NDQsXCIuL3V0aWxzL2VzY2FwZVwiOjQ1LFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9sb2dcIjo0OCxcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi91dGlscy90cmFuc3BvcnRcIjo1MSxcIi4vdXRpbHMvdXJsXCI6NTIsXCIuL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OCxcInVybC1wYXJzZVwiOjYxfV0sMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGpzY3M6IGRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gcHVsbGVkIHNwZWNpZmljIHNoaW1zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbnZhciBkZWZpbmVQcm9wZXJ0eTtcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgOS40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICAgIHZhciBuID0gK251bTtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgIHJldHVybiB4ID4+PiAwO1xufVxuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG5mdW5jdGlvbiBFbXB0eSgpIHt9XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgdmFyIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG5cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ICAgICA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIFRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4vLyBbYnVnZml4LCBjaHJvbWVdXG4vLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4vLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4vLyBlbGVtZW50cy5cbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbn0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xufVxuXG4vLyBFQ01BLTI2MiwgM3JkIEIuMi4zXG4vLyBOb3QgYW4gRUNNQVNjcmlwdCBzdGFuZGFyZCwgYWx0aG91Z2ggRUNNQVNjcmlwdCAzcmQgRWRpdGlvbiBoYXMgYVxuLy8gbm9uLW5vcm1hdGl2ZSBzZWN0aW9uIHN1Z2dlc3RpbmcgdW5pZm9ybSBzZW1hbnRpY3MgYW5kIGl0IHNob3VsZCBiZVxuLy8gbm9ybWFsaXplZCBhY3Jvc3MgYWxsIGJyb3dzZXJzXG4vLyBbYnVnZml4LCBJRSBsdCA5XSBJRSA8IDkgc3Vic3RyKCkgd2l0aCBuZWdhdGl2ZSB2YWx1ZSBub3Qgd29ya2luZyBpbiBJRVxudmFyIHN0cmluZ19zdWJzdHIgPSBTdHJpbmdQcm90b3R5cGUuc3Vic3RyO1xudmFyIGhhc05lZ2F0aXZlU3Vic3RyQnVnID0gJycuc3Vic3RyICYmICcwYicuc3Vic3RyKC0xKSAhPT0gJ2InO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICBzdWJzdHI6IGZ1bmN0aW9uIHN1YnN0cihzdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3Vic3RyLmNhbGwoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgc3RhcnQgPCAwID8gKChzdGFydCA9IHRoaXMubGVuZ3RoICsgc3RhcnQpIDwgMCA/IDAgOiBzdGFydCkgOiBzdGFydCxcbiAgICAgICAgICAgIGxlbmd0aFxuICAgICAgICApO1xuICAgIH1cbn0sIGhhc05lZ2F0aXZlU3Vic3RyQnVnKTtcblxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8gc3RyZWFtaW5nIHRyYW5zcG9ydHNcbiAgcmVxdWlyZSgnLi90cmFuc3BvcnQvd2Vic29ja2V0JylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJykpXG5cbiAgLy8gcG9sbGluZyB0cmFuc3BvcnRzXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmcnKVxuXTtcblxufSx7XCIuL3RyYW5zcG9ydC9ldmVudHNvdXJjZVwiOjIwLFwiLi90cmFuc3BvcnQvaHRtbGZpbGVcIjoyMSxcIi4vdHJhbnNwb3J0L2pzb25wLXBvbGxpbmdcIjoyMyxcIi4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcFwiOjI2LFwiLi90cmFuc3BvcnQvd2Vic29ja2V0XCI6MzgsXCIuL3RyYW5zcG9ydC94ZHItcG9sbGluZ1wiOjM5LFwiLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZ1wiOjQwLFwiLi90cmFuc3BvcnQveGhyLXBvbGxpbmdcIjo0MSxcIi4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmdcIjo0Mn1dLDE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFhIUiA9IGdsb2JhbC5YTUxIdHRwUmVxdWVzdFxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnJvd3Nlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gQWJzdHJhY3RYSFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEFic3RyYWN0WEhST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgdGhpcy54aHIgPSBuZXcgWEhSKCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cblxuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgZGVidWcoJ25vIHhocicpO1xuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNldmVyYWwgYnJvd3NlcnMgY2FjaGUgUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgLy8gRXhwbG9yZXIgdGVuZHMgdG8ga2VlcCBjb25uZWN0aW9uIG9wZW4sIGV2ZW4gYWZ0ZXIgdGhlXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy50aW1lb3V0ICYmICd0aW1lb3V0JyBpbiB0aGlzLnhocikge1xuICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoIW9wdHMgfHwgIW9wdHMubm9DcmVkZW50aWFscykgJiYgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTKSB7XG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAvLyBcIlRoaXMgbmV2ZXIgYWZmZWN0cyBzYW1lLXNpdGUgcmVxdWVzdHMuXCJcblxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gIH1cbiAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgdGhpcy54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoc2VsZi54aHIpIHtcbiAgICAgIHZhciB4ID0gc2VsZi54aHI7XG4gICAgICB2YXIgdGV4dCwgc3RhdHVzO1xuICAgICAgZGVidWcoJ3JlYWR5U3RhdGUnLCB4LnJlYWR5U3RhdGUpO1xuICAgICAgc3dpdGNoICh4LnJlYWR5U3RhdGUpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgLy8gSUUgZG9lc24ndCBsaWtlIHBlZWtpbmcgaW50byByZXNwb25zZVRleHQgb3Igc3RhdHVzXG4gICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgICB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZygnY2h1bmsnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIHJldHVybnMgdGhpcyBmb3IgYSBiYWQgcG9ydFxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzgzNzcwKHY9dnMuODUpLmFzcHhcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnhoci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH1cbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIGlmICghdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xuICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gIH1cblxuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54aHIgPSBudWxsO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhWEhSO1xuLy8gb3ZlcnJpZGUgWE1MSHR0cFJlcXVlc3QgZm9yIElFNi83XG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmICghQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCAmJiAoYXhvIGluIGdsb2JhbCkpIHtcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcbiAgWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFuZXcgWEhSKCk7XG59XG5cbnZhciBjb3JzID0gZmFsc2U7XG50cnkge1xuICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xufSBjYXRjaCAoaWdub3JlZCkge1xuICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG59XG5cbkFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUyA9IGNvcnM7XG5cbm1vZHVsZS5leHBvcnRzID0gQWJzdHJhY3RYSFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkV2ZW50U291cmNlO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRHJpdmVyID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuaWYgKERyaXZlcikge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIFdlYlNvY2tldEJyb3dzZXJEcml2ZXIodXJsKSB7XG5cdFx0cmV0dXJuIG5ldyBEcml2ZXIodXJsKTtcblx0fTtcbn0gZWxzZSB7XG5cdG1vZHVsZS5leHBvcnRzID0gdW5kZWZpbmVkO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sMjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgRXZlbnRTb3VyY2VSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvZXZlbnRzb3VyY2UnKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFFdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIUV2ZW50U291cmNlRHJpdmVyO1xufTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdldmVudHNvdXJjZSc7XG5FdmVudFNvdXJjZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2V2ZW50c291cmNlXCI6MjksXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBIdG1sZmlsZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9odG1sZmlsZScpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICA7XG5cbmZ1bmN0aW9uIEh0bWxGaWxlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLCBYSFJMb2NhbE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEh0bWxGaWxlVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5IdG1sRmlsZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICByZXR1cm4gSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbjtcbn07XG5cbkh0bWxGaWxlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaHRtbGZpbGUnO1xuSHRtbEZpbGVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbEZpbGVUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9odG1sZmlsZVwiOjMwLFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gRmV3IGNvb2wgdHJhbnNwb3J0cyBkbyB3b3JrIG9ubHkgZm9yIHNhbWUtb3JpZ2luLiBJbiBvcmRlciB0byBtYWtlXG4vLyB0aGVtIHdvcmsgY3Jvc3MtZG9tYWluIHdlIHNoYWxsIHVzZSBpZnJhbWUsIHNlcnZlZCBmcm9tIHRoZVxuLy8gcmVtb3RlIGRvbWFpbi4gTmV3IGJyb3dzZXJzIGhhdmUgY2FwYWJpbGl0aWVzIHRvIGNvbW11bmljYXRlIHdpdGhcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHZlcnNpb24gPSByZXF1aXJlKCcuLi92ZXJzaW9uJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9pZnJhbWUnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnRyYW5zcG9ydDppZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSWZyYW1lVHJhbnNwb3J0KHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgaWYgKCFJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLm9yaWdpbiA9IHVybFV0aWxzLmdldE9yaWdpbihiYXNlVXJsKTtcbiAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgdGhpcy50cmFuc1VybCA9IHRyYW5zVXJsO1xuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdGhpcy53aW5kb3dJZCA9IHJhbmRvbS5zdHJpbmcoOCk7XG5cbiAgdmFyIGlmcmFtZVVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pZnJhbWUuaHRtbCcpICsgJyMnICsgdGhpcy53aW5kb3dJZDtcbiAgZGVidWcodHJhbnNwb3J0LCB0cmFuc1VybCwgaWZyYW1lVXJsKTtcblxuICB0aGlzLmlmcmFtZU9iaiA9IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVVcmwsIGZ1bmN0aW9uKHIpIHtcbiAgICBkZWJ1ZygnZXJyIGNhbGxiYWNrJyk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdVbmFibGUgdG8gbG9hZCBhbiBpZnJhbWUgKCcgKyByICsgJyknKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xuXG4gIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLl9tZXNzYWdlLmJpbmQodGhpcyk7XG4gIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbn1cblxuaW5oZXJpdHMoSWZyYW1lVHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICBldmVudFV0aWxzLmRldGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICB0aGlzLnBvc3RNZXNzYWdlKCdjJyk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICAgIHRoaXMub25tZXNzYWdlQ2FsbGJhY2sgPSB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuX21lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGUub3JpZ2luLCB0aGlzLm9yaWdpbikpIHtcbiAgICBkZWJ1Zygnbm90IHNhbWUgb3JpZ2luJywgZS5vcmlnaW4sIHRoaXMub3JpZ2luKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgdHJ5IHtcbiAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IHRoaXMud2luZG93SWQpIHtcbiAgICBkZWJ1ZygnbWlzbWF0Y2hlZCB3aW5kb3cgaWQnLCBpZnJhbWVNZXNzYWdlLndpbmRvd0lkLCB0aGlzLndpbmRvd0lkKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICBjYXNlICdzJzpcbiAgICB0aGlzLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAvLyB3aW5kb3cgZ2xvYmFsIGRlcGVuZGVuY3lcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdzJywgSlNPTjMuc3RyaW5naWZ5KFtcbiAgICAgIHZlcnNpb25cbiAgICAsIHRoaXMudHJhbnNwb3J0XG4gICAgLCB0aGlzLnRyYW5zVXJsXG4gICAgLCB0aGlzLmJhc2VVcmxcbiAgICBdKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3QnOlxuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2MnOlxuICAgIHZhciBjZGF0YTtcbiAgICB0cnkge1xuICAgICAgY2RhdGEgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjZGF0YVswXSwgY2RhdGFbMV0pO1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgICBicmVhaztcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgZGVidWcoJ3Bvc3RNZXNzYWdlJywgdHlwZSwgZGF0YSk7XG4gIHRoaXMuaWZyYW1lT2JqLnBvc3QoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICB3aW5kb3dJZDogdGhpcy53aW5kb3dJZFxuICAsIHR5cGU6IHR5cGVcbiAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gIH0pLCB0aGlzLm9yaWdpbik7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lJztcbklmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBJZnJhbWVUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi91dGlscy9yYW5kb21cIjo1MCxcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIHNpbXBsZXN0IGFuZCBtb3N0IHJvYnVzdCB0cmFuc3BvcnQsIHVzaW5nIHRoZSB3ZWxsLWtub3cgY3Jvc3Ncbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXG4vLyBtZXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4vLyBldmVyeXdoZXJlLlxuLy8gS25vd24gbGltaXRhdGlvbnM6XG4vLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4vLyAgIG8gZm9yIEtvbnF1ZXJvciBhIGR1bWIgdGltZXIgaXMgbmVlZGVkIHRvIGRldGVjdCBlcnJvcnNcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyLXJlY2VpdmVyJylcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXG4gICwganNvbnBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlci9qc29ucCcpXG4gIDtcblxuZnVuY3Rpb24gSnNvblBUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFKc29uUFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2pzb25wJywganNvbnBTZW5kZXIsIEpzb25wUmVjZWl2ZXIpO1xufVxuXG5pbmhlcml0cyhKc29uUFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5Kc29uUFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudDtcbn07XG5cbkpzb25QVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnanNvbnAtcG9sbGluZyc7XG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcbkpzb25QVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9saWIvc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCIuL3JlY2VpdmVyL2pzb25wXCI6MzEsXCIuL3NlbmRlci9qc29ucFwiOjMzLFwiaW5oZXJpdHNcIjo1N31dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3NlbmRlci1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDphamF4LWJhc2VkJyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGRlYnVnKCdjcmVhdGUgYWpheCBzZW5kZXInLCB1cmwsIHBheWxvYWQpO1xuICAgIHZhciBvcHQgPSB7fTtcbiAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBvcHQuaGVhZGVycyA9IHsnQ29udGVudC10eXBlJzogJ3RleHQvcGxhaW4nfTtcbiAgICB9XG4gICAgdmFyIGFqYXhVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHVybCwgJy94aHJfc2VuZCcpO1xuICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgYWpheFVybCwgcGF5bG9hZCwgb3B0KTtcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdHVzICE9PSAyMDAgJiYgc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignaHR0cCBzdGF0dXMgJyArIHN0YXR1cykpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgIHhvLmNsb3NlKCk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Fib3J0ZWQnKTtcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHVybFN1ZmZpeCwgY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpO1xufVxuXG5pbmhlcml0cyhBamF4QmFzZWRUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vc2VuZGVyLXJlY2VpdmVyXCI6MjgsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJ1ZmZlcmVkLXNlbmRlcicpO1xufVxuXG5mdW5jdGlvbiBCdWZmZXJlZFNlbmRlcih1cmwsIHNlbmRlcikge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZGVyID0gc2VuZGVyO1xuICB0aGlzLnVybCA9IHVybDtcbn1cblxuaW5oZXJpdHMoQnVmZmVyZWRTZW5kZXIsIEV2ZW50RW1pdHRlcik7XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnNlbmRCdWZmZXIucHVzaChtZXNzYWdlKTtcbiAgaWYgKCF0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU2NoZWR1bGUoKTtcbiAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZVdhaXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZVdhaXQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdHJlZjtcbiAgdGhpcy5zZW5kU3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdzZW5kU3RvcCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgfTtcbiAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBzZWxmLnNlbmRTY2hlZHVsZSgpO1xuICB9LCAyNSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGUnLCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5zZW5kQnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoaXMuc2VuZEJ1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgdGhpcy5zZW5kU3RvcCA9IHRoaXMuc2VuZGVyKHRoaXMudXJsLCBwYXlsb2FkLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUgfHwgMTAwNiwgJ1NlbmRpbmcgZXJyb3I6ICcgKyBlcnIpO1xuICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnNlbmRTY2hlZHVsZVdhaXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgIHRoaXMuc2VuZFN0b3AgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU2VuZGVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSWZyYW1lVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vaWZyYW1lJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL29iamVjdCcpXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblxuICBmdW5jdGlvbiBJZnJhbWVXcmFwVHJhbnNwb3J0KHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gICAgSWZyYW1lVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgfVxuXG4gIGluaGVyaXRzKElmcmFtZVdyYXBUcmFuc3BvcnQsIElmcmFtZVRyYW5zcG9ydCk7XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24odXJsLCBpbmZvKSB7XG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaWZyYW1lSW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZCh7fSwgaW5mbyk7XG4gICAgaWZyYW1lSW5mby5zYW1lT3JpZ2luID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJhbnNwb3J0LmVuYWJsZWQoaWZyYW1lSW5mbykgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbiAgfTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLScgKyB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQucm91bmRUcmlwcyA9IElmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzICsgdHJhbnNwb3J0LnJvdW5kVHJpcHMgLSAxOyAvLyBodG1sLCBqYXZhc2NyaXB0ICgyKSArIHRyYW5zcG9ydCAtIG5vIENPUlMgKDEpXG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5mYWNhZGVUcmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgcmV0dXJuIElmcmFtZVdyYXBUcmFuc3BvcnQ7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9vYmplY3RcIjo0OSxcIi4uL2lmcmFtZVwiOjIyLFwiaW5oZXJpdHNcIjo1N31dLDI3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnBvbGxpbmcnKTtcbn1cblxuZnVuY3Rpb24gUG9sbGluZyhSZWNlaXZlciwgcmVjZWl2ZVVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1ZyhyZWNlaXZlVXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgdGhpcy5yZWNlaXZlVXJsID0gcmVjZWl2ZVVybDtcbiAgdGhpcy5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgdGhpcy5fc2NoZWR1bGVSZWNlaXZlcigpO1xufVxuXG5pbmhlcml0cyhQb2xsaW5nLCBFdmVudEVtaXR0ZXIpO1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5fc2NoZWR1bGVSZWNlaXZlciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcG9sbCA9IHRoaXMucG9sbCA9IG5ldyB0aGlzLlJlY2VpdmVyKHRoaXMucmVjZWl2ZVVybCwgdGhpcy5BamF4T2JqZWN0KTtcblxuICBwb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuXG4gIHBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygnY2xvc2UnLCBjb2RlLCByZWFzb24sIHNlbGYucG9sbElzQ2xvc2luZyk7XG4gICAgc2VsZi5wb2xsID0gcG9sbCA9IG51bGw7XG5cbiAgICBpZiAoIXNlbGYucG9sbElzQ2xvc2luZykge1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ25ldHdvcmsnKSB7XG4gICAgICAgIHNlbGYuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlIHx8IDEwMDYsIHJlYXNvbik7XG4gICAgICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgQnVmZmVyZWRTZW5kZXIgPSByZXF1aXJlKCcuL2J1ZmZlcmVkLXNlbmRlcicpXG4gICwgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXItcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gU2VuZGVyUmVjZWl2ZXIodHJhbnNVcmwsIHVybFN1ZmZpeCwgc2VuZGVyRnVuYywgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgdmFyIHBvbGxVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCB1cmxTdWZmaXgpO1xuICBkZWJ1Zyhwb2xsVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBCdWZmZXJlZFNlbmRlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCBzZW5kZXJGdW5jKTtcblxuICB0aGlzLnBvbGwgPSBuZXcgUG9sbGluZyhSZWNlaXZlciwgcG9sbFVybCwgQWpheE9iamVjdCk7XG4gIHRoaXMucG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdwb2xsIG1lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuICB0aGlzLnBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygncG9sbCBjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5wb2xsID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLmNsb3NlKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhTZW5kZXJSZWNlaXZlciwgQnVmZmVyZWRTZW5kZXIpO1xuXG5TZW5kZXJSZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmNsb3NlLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgdGhpcy5wb2xsID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZW5kZXJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9idWZmZXJlZC1zZW5kZXJcIjoyNSxcIi4vcG9sbGluZ1wiOjI3LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpldmVudHNvdXJjZScpO1xufVxuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlcyA9IHRoaXMuZXMgPSBuZXcgRXZlbnRTb3VyY2VEcml2ZXIodXJsKTtcbiAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkZWNvZGVVUkkoZS5kYXRhKSk7XG4gIH07XG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yJywgZXMucmVhZHlTdGF0ZSwgZSk7XG4gICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXG4gICAgdmFyIHJlYXNvbiA9IChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZShyZWFzb24pO1xuICB9O1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgdmFyIGVzID0gdGhpcy5lcztcbiAgaWYgKGVzKSB7XG4gICAgZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgZXMuY2xvc2UoKTtcbiAgICB0aGlzLmVzID0gbnVsbDtcbiAgfVxufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gU2FmYXJpIGFuZCBjaHJvbWUgPCAxNSBjcmFzaCBpZiB3ZSBjbG9zZSB3aW5kb3cgYmVmb3JlXG4gIC8vIHdhaXRpbmcgZm9yIEVTIGNsZWFudXAuIFNlZTpcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg5MTU1XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSwgMjAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiZXZlbnRzb3VyY2VcIjoxOCxcImluaGVyaXRzXCI6NTd9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmh0bWxmaWxlJyk7XG59XG5cbmZ1bmN0aW9uIEh0bWxmaWxlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmcmFtZVV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZGVjb2RlVVJJQ29tcG9uZW50KGlmcmFtZVV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZGVidWcoJ3VzaW5nIGh0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQpO1xuICB2YXIgY29uc3RydWN0RnVuYyA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID9cbiAgICAgIGlmcmFtZVV0aWxzLmNyZWF0ZUh0bWxmaWxlIDogaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lO1xuXG4gIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHtcbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RhcnQnKTtcbiAgICAgIHNlbGYuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIH1cbiAgLCBtZXNzYWdlOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gICAgfVxuICAsIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0b3AnKTtcbiAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIHNlbGYuX2Nsb3NlKCduZXR3b3JrJyk7XG4gICAgfVxuICB9O1xuICB0aGlzLmlmcmFtZU9iaiA9IGNvbnN0cnVjdEZ1bmModXJsLCBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnY2FsbGJhY2snKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UoJ3Blcm1hbmVudCcpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSHRtbGZpbGVSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBpZiAodGhpcy5pZnJhbWVPYmopIHtcbiAgICB0aGlzLmlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ19jbG9zZScsIHJlYXNvbik7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSBmYWxzZTtcblxuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoYXhvIGluIGdsb2JhbCkge1xuICB0cnkge1xuICAgIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gISFuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gIH1cbn1cblxuSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgfHwgaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sZmlsZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvaWZyYW1lJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpqc29ucCcpO1xufVxuXG5mdW5jdGlvbiBKc29ucFJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICB0aGlzLmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg2KTtcbiAgdmFyIHVybFdpdGhJZCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGVuY29kZVVSSUNvbXBvbmVudCh1dGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSA9IHRoaXMuX2NhbGxiYWNrLmJpbmQodGhpcyk7XG4gIHRoaXMuX2NyZWF0ZVNjcmlwdCh1cmxXaXRoSWQpO1xuXG4gIC8vIEZhbGxiYWNrIG1vc3RseSBmb3IgS29ucXVlcm9yIC0gc3R1cGlkIHRpbWVyLCAzNSBzZWNvbmRzIHNoYWxsIGJlIHBsZW50eS5cbiAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpJykpO1xuICB9LCBKc29ucFJlY2VpdmVyLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhKc29ucFJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXSkge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0pTT05QIHVzZXIgYWJvcnRlZCByZWFkJyk7XG4gICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgIHRoaXMuX2Fib3J0KGVycik7XG4gIH1cbn07XG5cbkpzb25wUmVjZWl2ZXIudGltZW91dCA9IDM1MDAwO1xuSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQgPSAxMDAwO1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGRlYnVnKCdfY2FsbGJhY2snLCBkYXRhKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuXG4gIGlmICh0aGlzLmFib3J0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRhdGEpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGRhdGEpO1xuICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICB9XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAnbmV0d29yaycpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2Fib3J0ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGRlYnVnKCdfYWJvcnQnLCBlcnIpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuYWJvcnRpbmcgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgZXJyLmNvZGUsIGVyci5tZXNzYWdlKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICBpZiAodGhpcy5zY3JpcHQyKSB7XG4gICAgdGhpcy5zY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQyKTtcbiAgICB0aGlzLnNjcmlwdDIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB5b3UgY2FuJ3QgcmVhbGx5IGFib3J0IHNjcmlwdCBsb2FkaW5nIG9mXG4gICAgLy8gdGhlIHNjcmlwdC5cbiAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25lcnJvciA9XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG4gIGRlbGV0ZSBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF07XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fc2NyaXB0RXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY3JpcHRFcnJvcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLmVycm9yVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmVycm9yVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGlmICghc2VsZi5sb2FkZWRPa2F5KSB7XG4gICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvciknKSk7XG4gICAgfVxuICB9LCBKc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY3JlYXRlU2NyaXB0ID0gZnVuY3Rpb24odXJsKSB7XG4gIGRlYnVnKCdfY3JlYXRlU2NyaXB0JywgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cblxuICBzY3JpcHQuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBzY3JpcHQuc3JjID0gdXJsO1xuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gIHNjcmlwdC5vbmVycm9yID0gdGhpcy5fc2NyaXB0RXJyb3IuYmluZCh0aGlzKTtcbiAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKScpKTtcbiAgfTtcblxuICAvLyBJRTkgZmlyZXMgJ2Vycm9yJyBldmVudCBhZnRlciBvbnJlYWR5c3RhdGVjaGFuZ2Ugb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gIC8vIFVzZSBsb2FkZWRPa2F5IHRvIGRldGVybWluZSBpZiBhY3R1YWxseSBlcnJvcmVkXG4gIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgc2NyaXB0LnJlYWR5U3RhdGUpO1xuICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0Lmh0bWxGb3IgJiYgc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgc2VsZi5sb2FkZWRPa2F5ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXG4gICAgICBzY3JpcHQyID0gdGhpcy5zY3JpcHQyID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIgKyBzY3JpcHQuaWQgKyBcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGhlYWQgPSBnbG9iYWwuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICBpZiAoc2NyaXB0Mikge1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdDIsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbnBSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIFhoclJlY2VpdmVyKHVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xuXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYueG8gPSBudWxsO1xuICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2h1bmtIYW5kbGVyID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcbiAgaWYgKHN0YXR1cyAhPT0gMjAwIHx8ICF0ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaWR4ID0gLTE7IDsgdGhpcy5idWZmZXJQb3NpdGlvbiArPSBpZHggKyAxKSB7XG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XG4gICAgaWR4ID0gYnVmLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG1zZyA9IGJ1Zi5zbGljZSgwLCBpZHgpO1xuICAgIGlmIChtc2cpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmICh0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICAgIGRlYnVnKCdjbG9zZScpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAndXNlcicpO1xuICAgIHRoaXMueG8gPSBudWxsO1xuICB9XG4gIHRoaXMuX2NsZWFudXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOmpzb25wJyk7XG59XG5cbnZhciBmb3JtLCBhcmVhO1xuXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcbiAgZGVidWcoJ2NyZWF0ZUlmcmFtZScsIGlkKTtcbiAgdHJ5IHtcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicgKyBpZCArICdcIj4nKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLm5hbWUgPSBpZDtcbiAgICByZXR1cm4gaWZyYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XG4gIGRlYnVnKCdjcmVhdGVGb3JtJyk7XG4gIGZvcm0gPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIGZvcm0uYWNjZXB0Q2hhcnNldCA9ICdVVEYtOCc7XG5cbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICBhcmVhLm5hbWUgPSAnZCc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cbiAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICBkZWJ1Zyh1cmwsIHBheWxvYWQpO1xuICBpZiAoIWZvcm0pIHtcbiAgICBjcmVhdGVGb3JtKCk7XG4gIH1cbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgZm9ybS50YXJnZXQgPSBpZDtcbiAgZm9ybS5hY3Rpb24gPSB1cmxVdGlscy5hZGRRdWVyeSh1cmxVdGlscy5hZGRQYXRoKHVybCwgJy9qc29ucF9zZW5kJyksICdpPScgKyBpZCk7XG5cbiAgdmFyIGlmcmFtZSA9IGNyZWF0ZUlmcmFtZShpZCk7XG4gIGlmcmFtZS5pZCA9IGlkO1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIHRyeSB7XG4gICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXG4gIH1cbiAgZm9ybS5zdWJtaXQoKTtcblxuICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgZGVidWcoJ2NvbXBsZXRlZCcsIGlkLCBlcnIpO1xuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgLy8gT3BlcmEgbWluaSBkb2Vzbid0IGxpa2UgaWYgd2UgR0MgaWZyYW1lXG4gICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW5pbmcgdXAnLCBpZCk7XG4gICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICB9LCA1MDApO1xuICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXG4gICAgLy8gZmFpbGVkIHRvIHN1Ym1pdCBvdXIgZm9ybS5cbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgaWQsIGlmcmFtZS5yZWFkeVN0YXRlLCBlKTtcbiAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgaWQpO1xuICAgIGNvbXBsZXRlZChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NX1dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xufVxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG5cbmZ1bmN0aW9uIFhEUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhYRFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcoJ19zdGFydCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4ZHIgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gIC8vIElFIGNhY2hlcyBldmVuIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIHhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29udGltZW91dCcpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3Byb2dyZXNzJywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gIH07XG4gIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnbG9hZCcpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfTtcbiAgdGhpcy54ZHIgPSB4ZHI7XG4gIHRoaXMudW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICB0aGlzLnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLnhkci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdGhpcy5fZXJyb3IoKTtcbiAgfVxufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJywgYWJvcnQpO1xuICBpZiAoIXRoaXMueGRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGV2ZW50VXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhkciA9IG51bGw7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gSUUgOC85IGlmIHRoZSByZXF1ZXN0IHRhcmdldCB1c2VzIHRoZSBzYW1lIHNjaGVtZSAtICM3OVxuWERST2JqZWN0LmVuYWJsZWQgPSAhIShnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgYnJvd3Nlci5oYXNEb21haW4oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWERST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbn1cblxuaW5oZXJpdHMoWEhSQ29yc09iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSQ29yc09iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQgJiYgWGhyRHJpdmVyLnN1cHBvcnRzQ09SUztcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJDb3JzT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG5cbn0se1wiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJMb2NhbE9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCAvKiwgb3B0cyAqLykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhIUkxvY2FsT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSTG9jYWxPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwsIGlnbm9yZSwgb3B0aW9ucykge1xuICBpZiAoIVdlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY29uc3RydWN0b3InLCB0cmFuc1VybCk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgJy93ZWJzb2NrZXQnKTtcbiAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xuICAgIHVybCA9ICd3c3MnICsgdXJsLnNsaWNlKDUpO1xuICB9IGVsc2Uge1xuICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XG4gIH1cbiAgdGhpcy51cmwgPSB1cmw7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJzb2NrZXREcml2ZXIodGhpcy51cmwsIFtdLCBvcHRpb25zKTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gIH07XG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCcpO1xuICAgIHNlbGYud3MuY2xvc2UoKTtcbiAgfSk7XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW4nKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG59XG5cbmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbXNnID0gJ1snICsgZGF0YSArICddJztcbiAgZGVidWcoJ3NlbmQnLCBtc2cpO1xuICB0aGlzLndzLnNlbmQobXNnKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHdzKSB7XG4gICAgd3MuY2xvc2UoKTtcbiAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgaWYgKHdzKSB7XG4gICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IHdzLm9uZXJyb3IgPSBudWxsO1xuICB9XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy53cyA9IG51bGw7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnZW5hYmxlZCcpO1xuICByZXR1cm4gISFXZWJzb2NrZXREcml2ZXI7XG59O1xuV2ViU29ja2V0VHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnd2Vic29ja2V0JztcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy91cmxcIjo1MixcIi4vZHJpdmVyL3dlYnNvY2tldFwiOjE5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGRyU3RyZWFtaW5nVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi94ZHItc3RyZWFtaW5nJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbmZ1bmN0aW9uIFhkclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZDtcblhkclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItcG9sbGluZyc7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcIi4veGRyLXN0cmVhbWluZ1wiOjQwLFwiaW5oZXJpdHNcIjo1N31dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94ZHJcIjozNCxcImluaGVyaXRzXCI6NTd9XSw0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1wb2xsaW5nJztcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpXG4gIDtcblxuZnVuY3Rpb24gWGhyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IHN1cHBvcnQgeGhyLXN0cmVhbWluZyAjNjBcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXG4gIGlmIChicm93c2VyLmlzT3BlcmEoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItc3RyZWFtaW5nJztcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbi8vIFNhZmFyaSBnZXRzIGNvbmZ1c2VkIHdoZW4gYSBzdHJlYW1pbmcgYWpheCByZXF1ZXN0IGlzIHN0YXJ0ZWRcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cbi8vIE9ubHkgcmVxdWlyZSBib2R5IHdoZW4gdXNlZCBpbiBhIGJyb3dzZXJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5uZWVkQm9keSA9ICEhZ2xvYmFsLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbmlmIChnbG9iYWwuY3J5cHRvICYmIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhieXRlcyk7XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBieXRlc1tpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1Nik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAvb3BlcmEvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4sIGlzS29ucXVlcm9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xuLCBoYXNEb21haW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBub24tYnJvd3NlciBjbGllbnQgYWx3YXlzIGhhcyBhIGRvbWFpblxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50LmRvbWFpbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpO1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBleHRyYUVzY2FwYWJsZSA9IC9bXFx4MDAtXFx4MWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZlxcdTAzMDAtXFx1MDMzM1xcdTAzM2QtXFx1MDM0NlxcdTAzNGEtXFx1MDM0Y1xcdTAzNTAtXFx1MDM1MlxcdTAzNTctXFx1MDM1OFxcdTAzNWMtXFx1MDM2MlxcdTAzNzRcXHUwMzdlXFx1MDM4N1xcdTA1OTEtXFx1MDVhZlxcdTA1YzRcXHUwNjEwLVxcdTA2MTdcXHUwNjUzLVxcdTA2NTRcXHUwNjU3LVxcdTA2NWJcXHUwNjVkLVxcdTA2NWVcXHUwNmRmLVxcdTA2ZTJcXHUwNmViLVxcdTA2ZWNcXHUwNzMwXFx1MDczMi1cXHUwNzMzXFx1MDczNS1cXHUwNzM2XFx1MDczYVxcdTA3M2RcXHUwNzNmLVxcdTA3NDFcXHUwNzQzXFx1MDc0NVxcdTA3NDdcXHUwN2ViLVxcdTA3ZjFcXHUwOTUxXFx1MDk1OC1cXHUwOTVmXFx1MDlkYy1cXHUwOWRkXFx1MDlkZlxcdTBhMzNcXHUwYTM2XFx1MGE1OS1cXHUwYTViXFx1MGE1ZVxcdTBiNWMtXFx1MGI1ZFxcdTBlMzgtXFx1MGUzOVxcdTBmNDNcXHUwZjRkXFx1MGY1MlxcdTBmNTdcXHUwZjVjXFx1MGY2OVxcdTBmNzItXFx1MGY3NlxcdTBmNzhcXHUwZjgwLVxcdTBmODNcXHUwZjkzXFx1MGY5ZFxcdTBmYTJcXHUwZmE3XFx1MGZhY1xcdTBmYjlcXHUxOTM5LVxcdTE5M2FcXHUxYTE3XFx1MWI2YlxcdTFjZGEtXFx1MWNkYlxcdTFkYzAtXFx1MWRjZlxcdTFkZmNcXHUxZGZlXFx1MWY3MVxcdTFmNzNcXHUxZjc1XFx1MWY3N1xcdTFmNzlcXHUxZjdiXFx1MWY3ZFxcdTFmYmJcXHUxZmJlXFx1MWZjOVxcdTFmY2JcXHUxZmQzXFx1MWZkYlxcdTFmZTNcXHUxZmViXFx1MWZlZS1cXHUxZmVmXFx1MWZmOVxcdTFmZmJcXHUxZmZkXFx1MjAwMC1cXHUyMDAxXFx1MjBkMC1cXHUyMGQxXFx1MjBkNC1cXHUyMGQ3XFx1MjBlNy1cXHUyMGU5XFx1MjEyNlxcdTIxMmEtXFx1MjEyYlxcdTIzMjktXFx1MjMyYVxcdTJhZGNcXHUzMDJiLVxcdTMwMmNcXHVhYWIyLVxcdWFhYjNcXHVmOTAwLVxcdWZhMGRcXHVmYTEwXFx1ZmExMlxcdWZhMTUtXFx1ZmExZVxcdWZhMjBcXHVmYTIyXFx1ZmEyNS1cXHVmYTI2XFx1ZmEyYS1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIxZFxcdWZiMWZcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYjRlXFx1ZmZmMC1cXHVmZmZmXS9nXG4gICwgZXh0cmFMb29rdXA7XG5cbi8vIFRoaXMgbWF5IGJlIHF1aXRlIHNsb3csIHNvIGxldCdzIGRlbGF5IHVudGlsIHVzZXIgYWN0dWFsbHkgdXNlcyBiYWRcbi8vIGNoYXJhY3RlcnMuXG52YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XG4gIHZhciBpO1xuICB2YXIgdW5yb2xsZWQgPSB7fTtcbiAgdmFyIGMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IDY1NTM2OyBpKyspIHtcbiAgICBjLnB1c2goIFN0cmluZy5mcm9tQ2hhckNvZGUoaSkgKTtcbiAgfVxuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgYy5qb2luKCcnKS5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHVucm9sbGVkO1xufTtcblxuLy8gUXVvdGUgc3RyaW5nLCBhbHNvIHRha2luZyBjYXJlIG9mIHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGJyb3dzZXJzXG4vLyBvZnRlbiBicmVhay4gRXNwZWNpYWxseSwgdGFrZSBjYXJlIG9mIHVuaWNvZGUgc3Vycm9nYXRlczpcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHF1b3RlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcXVvdGVkID0gSlNPTjMuc3RyaW5naWZ5KHN0cmluZyk7XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzIHRoaXMgc2hvdWxkIGJlIHZlcnkgZmFzdCBhbmQgZ29vZCBlbm91Z2guXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoIWV4dHJhRXNjYXBhYmxlLnRlc3QocXVvdGVkKSkge1xuICAgICAgcmV0dXJuIHF1b3RlZDtcbiAgICB9XG5cbiAgICBpZiAoIWV4dHJhTG9va3VwKSB7XG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gZXh0cmFMb29rdXBbYV07XG4gICAgfSk7XG4gIH1cbn07XG5cbn0se1wianNvbjNcIjo1OH1dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tJyk7XG5cbnZhciBvblVubG9hZCA9IHt9XG4gICwgYWZ0ZXJVbmxvYWQgPSBmYWxzZVxuICAgIC8vIGRldGVjdCBnb29nbGUgY2hyb21lIHBhY2thZ2VkIGFwcHMgYmVjYXVzZSB0aGV5IGRvbid0IGFsbG93IHRoZSAndW5sb2FkJyBldmVudFxuICAsIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWVcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgIC8vIElFIHF1aXJrcy5cbiAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZ2V0cyBkZWxpdmVyZWQgb25seSB0byAnZG9jdW1lbnQnLCBub3QgJ3dpbmRvdycuXG4gICAgICBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxuICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIGRldGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmRldGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICBnbG9iYWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgdW5sb2FkQWRkOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVmID0gcmFuZG9tLnN0cmluZyg4KTtcbiAgICBvblVubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMudHJpZ2dlclVubG9hZENhbGxiYWNrcywgMCk7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG4gIH1cblxuLCB1bmxvYWREZWw6IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmIChyZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxuXG4sIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgb25VbmxvYWRbcmVmXSgpO1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG59O1xuXG52YXIgdW5sb2FkVHJpZ2dlcmVkID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhZnRlclVubG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhZnRlclVubG9hZCA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MoKTtcbn07XG5cbi8vICd1bmxvYWQnIGFsb25lIGlzIG5vdCByZWxpYWJsZSBpbiBvcGVyYSB3aXRoaW4gYW4gaWZyYW1lLCBidXQgd2Vcbi8vIGNhbid0IHVzZSBgYmVmb3JldW5sb2FkYCBhcyBJRSBmaXJlcyBpdCBvbiBqYXZhc2NyaXB0OiBsaW5rcy5cbmlmICghaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICBtb2R1bGUuZXhwb3J0cy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkVHJpZ2dlcmVkKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9yYW5kb21cIjo1MH1dLDQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6aWZyYW1lJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXUHJlZml4OiAnX2pwJ1xuLCBjdXJyZW50V2luZG93SWQ6IG51bGxcblxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShtb2R1bGUuZXhwb3J0cy5XUHJlZml4IGluIGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IHt9O1xuICAgIH1cbiAgfVxuXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgaWYgKGdsb2JhbC5wYXJlbnQgIT09IGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnBhcmVudC5wb3N0TWVzc2FnZShKU09OMy5zdHJpbmdpZnkoe1xuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXG4gICAgICAsIHR5cGU6IHR5cGVcbiAgICAgICwgZGF0YTogZGF0YSB8fCAnJ1xuICAgICAgfSksICcqJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdDYW5ub3QgcG9zdE1lc3NhZ2UsIG5vIHBhcmVudCB3aW5kb3cuJywgdHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygndW5hdHRhY2gnKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAvLyB3aXRoaW4gaWZyYW1lLiBXaXRob3V0IHRoZSB0aW1lb3V0IGl0IGdvZXMgc3RyYWlnaHQgdG9cbiAgICAgICAgLy8gb251bmxvYWQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCBlcnIpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIGRlYnVnKCdwb3N0JywgbXNnLCBvcmlnaW4pO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgIC8vIGV4ZWN1dGVkLiBHaXZlIGl0IGZldyBzZWNvbmRzIHRvIGFjdHVhbGx5IGxvYWQgc3R1ZmYuXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25lcnJvcignb25sb2FkIHRpbWVvdXQnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG5cbi8qIGVzbGludCBuby11bmRlZjogXCJvZmZcIiwgbmV3LWNhcDogXCJvZmZcIiAqL1xuLCBjcmVhdGVIdG1sZmlsZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgdmFyIGRvYyA9IG5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUgPSBkb2MgPSBudWxsO1xuICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgfVxuICAgIH07XG5cbiAgICBkb2Mub3BlbigpO1xuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xuICAgICAgICAgICAgICAnZG9jdW1lbnQuZG9tYWluPVwiJyArIGdsb2JhbC5kb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgIHZhciBjID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9IGZhbHNlO1xuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgbW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9ICh0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcbn1cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9icm93c2VyXCI6NDQsXCIuL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ09iamVjdCA9IHt9O1xuWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gIHZhciBsZXZlbEV4aXN0cztcblxuICB0cnkge1xuICAgIGxldmVsRXhpc3RzID0gZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseTtcbiAgfSBjYXRjaChlKSB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgbG9nT2JqZWN0W2xldmVsXSA9IGxldmVsRXhpc3RzID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHkoZ2xvYmFsLmNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH0gOiAobGV2ZWwgPT09ICdsb2cnID8gZnVuY3Rpb24gKCkge30gOiBsb2dPYmplY3QubG9nKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZ09iamVjdDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH1cblxuLCBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5pc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG5cbn0se1wiY3J5cHRvXCI6NDN9XSw1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnRyYW5zcG9ydCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcbiAgICAgIHZhciB0cmFuc3BvcnRzID0ge1xuICAgICAgICBtYWluOiBbXVxuICAgICAgLCBmYWNhZGU6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKCF0cmFuc3BvcnRzV2hpdGVsaXN0KSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbdHJhbnNwb3J0c1doaXRlbGlzdF07XG4gICAgICB9XG5cbiAgICAgIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbih0cmFucykge1xuICAgICAgICBpZiAoIXRyYW5zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLnRyYW5zcG9ydE5hbWUgPT09ICd3ZWJzb2NrZXQnICYmIGluZm8ud2Vic29ja2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCBmcm9tIHNlcnZlcicsICd3ZWJzb2NrZXQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QuaW5kZXhPZih0cmFucy50cmFuc3BvcnROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBkZWJ1Zygnbm90IGluIHdoaXRlbGlzdCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XG4gICAgICAgICAgZGVidWcoJ2VuYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICB0cmFuc3BvcnRzLm1haW4ucHVzaCh0cmFucyk7XG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0cy5mYWNhZGUucHVzaCh0cmFucy5mYWNhZGVUcmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NX1dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJ1cmwtcGFyc2VcIjo2MX1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gJzEuNC4wJztcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC0/XFxkP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuXG59LHt9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2NvbW1vblwiOjU2fV0sNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG4gIGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuICBjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcbiAgY3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcbiAgfSk7XG4gIC8qKlxuICAqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMgPSBbXTtcbiAgLyoqXG4gICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gICovXG5cbiAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgLyoqXG4gICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICAqXG4gICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcbiAgLyoqXG4gICogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcbiAgKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2VcbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuICBmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcbiAgICB2YXIgaGFzaCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuICAvKipcbiAgKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuICAgIHZhciBwcmV2VGltZTtcblxuICAgIGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2FibGVkP1xuICAgICAgaWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGYgPSBkZWJ1ZzsgLy8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblxuICAgICAgdmFyIGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG4gICAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgICAgc2VsZi5kaWZmID0gbXM7XG4gICAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgICBwcmV2VGltZSA9IGN1cnI7XG4gICAgICBhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG4gICAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcbiAgICAgIH0gLy8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblxuXG4gICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIGZ1bmN0aW9uIChtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7IC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblxuICAgICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICBpbmRleC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfSk7IC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cbiAgICAgIGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcbiAgICAgIHZhciBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcbiAgICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cblxuICAgIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcbiAgICBkZWJ1Zy5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuICAgIGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuICAgIGRlYnVnLmNvbG9yID0gc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcbiAgICBkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7IC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuICAgIC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcbiAgICAvLyBlbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcbiAgICB9XG5cbiAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG4gICAgcmV0dXJuIGRlYnVnO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB2YXIgaW5kZXggPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICAgIGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG4gICAgY3JlYXRlRGVidWcubmFtZXMgPSBbXTtcbiAgICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gICAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCFzcGxpdFtpXSkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cbiAgICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgICAgY3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZURlYnVnLmluc3RhbmNlc1tpXTtcbiAgICAgIGluc3RhbmNlLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICAqXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgY3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcbiAgfVxuICAvKipcbiAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICAgIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgKiBDb2VyY2UgYHZhbGAuXG4gICpcbiAgKiBAcGFyYW0ge01peGVkfSB2YWxcbiAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgKiBAYXBpIHByaXZhdGVcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuICByZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG5cblxufSx7XCJtc1wiOjU0fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogRGVjb2RlIGEgVVJJIGVuY29kZWQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgVVJJIGVuY29kZWQgc3RyaW5nLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgcXVlcnkgc3RyaW5nIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHN0cmluZyB0aGF0IG5lZWRzIHRvIGJlIHBhcnNlZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZyhxdWVyeSkge1xuICB2YXIgcGFyc2VyID0gLyhbXj0/Jl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICBpZiAoa2V5IGluIHJlc3VsdCkgY29udGludWU7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGEgcXVlcnkgc3RyaW5nIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIE9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFuc2Zvcm1lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggT3B0aW9uYWwgcHJlZml4LlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5naWZ5KG9iaiwgcHJlZml4KSB7XG4gIHByZWZpeCA9IHByZWZpeCB8fCAnJztcblxuICB2YXIgcGFpcnMgPSBbXTtcblxuICAvL1xuICAvLyBPcHRpb25hbGx5IHByZWZpeCB3aXRoIGEgJz8nIGlmIG5lZWRlZFxuICAvL1xuICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcmVmaXgpIHByZWZpeCA9ICc/JztcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArJz0nKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFpcnMubGVuZ3RoID8gcHJlZml4ICsgcGFpcnMuam9pbignJicpIDogJyc7XG59XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5leHBvcnRzLnN0cmluZ2lmeSA9IHF1ZXJ5c3RyaW5naWZ5O1xuZXhwb3J0cy5wYXJzZSA9IHF1ZXJ5c3RyaW5nO1xuXG59LHt9XSw2MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcblxufSx7fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcU1xcc10qKS9pXG4gICwgc2xhc2hlcyA9IC9eW0EtWmEtel1bQS1aYS16MC05Ky0uXSo6XFwvXFwvLztcblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIHJ1bGVzIGZvciB0aGUgVVJMIHBhcnNlciwgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgcnVsZXMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgZnVuY3Rpb24gc2FuaXRpemUoYWRkcmVzcykgeyAgICAgICAgICAvLyBTYW5pdGl6ZSB3aGF0IGlzIGxlZnQgb2YgdGhlIGFkZHJlc3NcbiAgICByZXR1cm4gYWRkcmVzcy5yZXBsYWNlKCdcXFxcJywgJy8nKTtcbiAgfSxcbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbLzooXFxkKykkLywgJ3BvcnQnLCB1bmRlZmluZWQsIDFdLCAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyBhIGJsb2IgVVJMIGRvZXMgbm90IGluY2x1ZGUgYSBoYXNoLCBvbmx5IHRoZVxuICogb3JpZ2luLlxuICpcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgaWdub3JlID0geyBoYXNoOiAxLCBxdWVyeTogMSB9O1xuXG4vKipcbiAqIFRoZSBsb2NhdGlvbiBvYmplY3QgZGlmZmVycyB3aGVuIHlvdXIgY29kZSBpcyBsb2FkZWQgdGhyb3VnaCBhIG5vcm1hbCBwYWdlLFxuICogV29ya2VyIG9yIHRocm91Z2ggYSB3b3JrZXIgdXNpbmcgYSBibG9iLiBBbmQgd2l0aCB0aGUgYmxvYmJsZSBiZWdpbnMgdGhlXG4gKiB0cm91YmxlIGFzIHRoZSBsb2NhdGlvbiBvYmplY3Qgd2lsbCBjb250YWluIHRoZSBVUkwgb2YgdGhlIGJsb2IsIG5vdCB0aGVcbiAqIGxvY2F0aW9uIG9mIHRoZSBwYWdlIHdoZXJlIG91ciBjb2RlIGlzIGxvYWRlZCBpbi4gVGhlIGFjdHVhbCBvcmlnaW4gaXNcbiAqIGVuY29kZWQgaW4gdGhlIGBwYXRobmFtZWAgc28gd2UgY2FuIHRoYW5rZnVsbHkgZ2VuZXJhdGUgYSBnb29kIFwiZGVmYXVsdFwiXG4gKiBsb2NhdGlvbiBmcm9tIGl0IHNvIHdlIGNhbiBnZW5lcmF0ZSBwcm9wZXIgcmVsYXRpdmUgVVJMJ3MgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbCAmJiBnbG9iYWwubG9jYXRpb24gfHwge307XG4gIGxvYyA9IGxvYyB8fCBsb2NhdGlvbjtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVybChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIHtcbiAgICBmb3IgKGtleSBpbiBsb2MpIHtcbiAgICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICAgIH1cblxuICAgIGlmIChmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID0gc2xhc2hlcy50ZXN0KGxvYy5ocmVmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmluYWxkZXN0aW5hdGlvbjtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEByZXR1cm4ge1Byb3RvY29sRXh0cmFjdH0gRXh0cmFjdGVkIGluZm9ybWF0aW9uLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MpIHtcbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpO1xuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnLFxuICAgIHNsYXNoZXM6ICEhbWF0Y2hbMl0sXG4gICAgcmVzdDogbWF0Y2hbM11cbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVsYXRpdmUgVVJMIHBhdGhuYW1lIGFnYWluc3QgYSBiYXNlIFVSTCBwYXRobmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVsYXRpdmUgUGF0aG5hbWUgb2YgdGhlIHJlbGF0aXZlIFVSTC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFBhdGhuYW1lIG9mIHRoZSBiYXNlIFVSTC5cbiAqIEByZXR1cm4ge1N0cmluZ30gUmVzb2x2ZWQgcGF0aG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZXNvbHZlKHJlbGF0aXZlLCBiYXNlKSB7XG4gIHZhciBwYXRoID0gKGJhc2UgfHwgJy8nKS5zcGxpdCgnLycpLnNsaWNlKDAsIC0xKS5jb25jYXQocmVsYXRpdmUuc3BsaXQoJy8nKSlcbiAgICAsIGkgPSBwYXRoLmxlbmd0aFxuICAgICwgbGFzdCA9IHBhdGhbaSAtIDFdXG4gICAgLCB1bnNoaWZ0ID0gZmFsc2VcbiAgICAsIHVwID0gMDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKHBhdGhbaV0gPT09ICcuJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChwYXRoW2ldID09PSAnLi4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgaWYgKGkgPT09IDApIHVuc2hpZnQgPSB0cnVlO1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIGlmICh1bnNoaWZ0KSBwYXRoLnVuc2hpZnQoJycpO1xuICBpZiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHBhdGgucHVzaCgnJyk7XG5cbiAgcmV0dXJuIHBhdGguam9pbignLycpO1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBPQ0QuXG4gKlxuICogSXQgaXMgd29ydGggbm90aW5nIHRoYXQgd2Ugc2hvdWxkIG5vdCB1c2UgYFVSTGAgYXMgY2xhc3MgbmFtZSB0byBwcmV2ZW50XG4gKiBjbGFzaGVzIHdpdGggdGhlIGdsb2JhbCBVUkwgaW5zdGFuY2UgdGhhdCBnb3QgaW50cm9kdWNlZCBpbiBicm93c2Vycy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IHBhcnNlciBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgLy9cbiAgLy8gVGhlIGhyZWYgaXMganVzdCB0aGUgY29tcGlsZWQgcmVzdWx0LlxuICAvL1xuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIFRoaXMgaXMgY29udmVuaWVuY2UgbWV0aG9kIGZvciBjaGFuZ2luZyBwcm9wZXJ0aWVzIGluIHRoZSBVUkwgaW5zdGFuY2UgdG9cbiAqIGluc3VyZSB0aGF0IHRoZXkgYWxsIHByb3BhZ2F0ZSBjb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhcnQgICAgICAgICAgUHJvcGVydHkgd2UgbmVlZCB0byBhZGp1c3QuXG4gKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAgICAgICAgICBUaGUgbmV3bHkgYXNzaWduZWQgdmFsdWUuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IGZuICBXaGVuIHNldHRpbmcgdGhlIHF1ZXJ5LCBpdCB3aWxsIGJlIHRoZSBmdW5jdGlvblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlZCB0byBwYXJzZSB0aGUgcXVlcnkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBXaGVuIHNldHRpbmcgdGhlIHByb3RvY29sLCBkb3VibGUgc2xhc2ggd2lsbCBiZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCBmcm9tIHRoZSBmaW5hbCB1cmwgaWYgaXQgaXMgdHJ1ZS5cbiAqIEByZXR1cm5zIHtVUkx9IFVSTCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgc3dpdGNoIChwYXJ0KSB7XG4gICAgY2FzZSAncXVlcnknOlxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdmFsdWUgJiYgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwb3J0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgICB1cmxbcGFydF0gPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdG5hbWUnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICAgIHVybC5ob3N0ID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3QnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICgvOlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFydCA9PT0gJ3BhdGhuYW1lJyA/ICcvJyA6ICcjJztcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWUuY2hhckF0KDApICE9PSBjaGFyID8gY2hhciArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5vcmlnaW4gPSB1cmwucHJvdG9jb2wgJiYgdXJsLmhvc3QgJiYgdXJsLnByb3RvY29sICE9PSAnZmlsZTonXG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcHJvdG9jb2wgPSB1cmwucHJvdG9jb2w7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLmNoYXJBdChwcm90b2NvbC5sZW5ndGggLSAxKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgdmFyIHJlc3VsdCA9IHByb3RvY29sICsgKHVybC5zbGFzaGVzID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdCArIHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cblVybC5wcm90b3R5cGUgPSB7IHNldDogc2V0LCB0b1N0cmluZzogdG9TdHJpbmcgfTtcblxuLy9cbi8vIEV4cG9zZSB0aGUgVVJMIHBhcnNlciBhbmQgc29tZSBhZGRpdGlvbmFsIHByb3BlcnRpZXMgdGhhdCBtaWdodCBiZSB1c2VmdWwgZm9yXG4vLyBvdGhlcnMgb3IgdGVzdGluZy5cbi8vXG5VcmwuZXh0cmFjdFByb3RvY29sID0gZXh0cmFjdFByb3RvY29sO1xuVXJsLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xuVXJsLnFzID0gcXM7XG5cbm1vZHVsZS5leHBvcnRzID0gVXJsO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCJxdWVyeXN0cmluZ2lmeVwiOjU5LFwicmVxdWlyZXMtcG9ydFwiOjYwfV19LHt9LFsxXSkoMSlcbn0pO1xuXG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvY2tqcy5qcy5tYXBcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZUNsaWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNsaWVudCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUNsaWVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0Q2xpZW50UGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDbGllbnRQYXRoKG9wdGlvbnMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2xpZW50IG5lZWRzIGltcGxlbWVudGF0aW9uJyk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDbGllbnQ7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyBUaGUgZXJyb3Igb3ZlcmxheSBpcyBpbnNwaXJlZCAoYW5kIG1vc3RseSBjb3BpZWQpIGZyb20gQ3JlYXRlIFJlYWN0IEFwcCAoaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHApXG4vLyBUaGV5LCBpbiB0dXJuLCBnb3QgaW5zcGlyZWQgYnkgd2VicGFjay1ob3QtbWlkZGxld2FyZSAoaHR0cHM6Ly9naXRodWIuY29tL2dsZW5qYW1pbi93ZWJwYWNrLWhvdC1taWRkbGV3YXJlKS5cblxudmFyIGFuc2lIVE1MID0gcmVxdWlyZSgnYW5zaS1odG1sJyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2h0bWwtZW50aXRpZXMnKSxcbiAgICBBbGxIdG1sRW50aXRpZXMgPSBfcmVxdWlyZS5BbGxIdG1sRW50aXRpZXM7XG5cbnZhciBlbnRpdGllcyA9IG5ldyBBbGxIdG1sRW50aXRpZXMoKTtcbnZhciBjb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ3RyYW5zcGFyZW50JywgJ3RyYW5zcGFyZW50J10sXG4gIGJsYWNrOiAnMTgxODE4JyxcbiAgcmVkOiAnRTM2MDQ5JyxcbiAgZ3JlZW46ICdCM0NCNzQnLFxuICB5ZWxsb3c6ICdGRkQwODAnLFxuICBibHVlOiAnN0NBRkMyJyxcbiAgbWFnZW50YTogJzdGQUNDQScsXG4gIGN5YW46ICdDM0MyRUYnLFxuICBsaWdodGdyZXk6ICdFQkU3RTMnLFxuICBkYXJrZ3JleTogJzZENzg5MSdcbn07XG52YXIgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG52YXIgb3ZlcmxheURpdiA9IG51bGw7XG52YXIgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbmFuc2lIVE1MLnNldENvbG9ycyhjb2xvcnMpO1xuXG5mdW5jdGlvbiBjcmVhdGVPdmVybGF5SWZyYW1lKG9uSWZyYW1lTG9hZCkge1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gIGlmcmFtZS5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXknO1xuICBpZnJhbWUuc3JjID0gJ2Fib3V0OmJsYW5rJztcbiAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgaWZyYW1lLnN0eWxlLmxlZnQgPSAwO1xuICBpZnJhbWUuc3R5bGUudG9wID0gMDtcbiAgaWZyYW1lLnN0eWxlLnJpZ2h0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLmJvdHRvbSA9IDA7XG4gIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBpZnJhbWUuc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICBpZnJhbWUuc3R5bGUuekluZGV4ID0gOTk5OTk5OTk5OTtcbiAgaWZyYW1lLm9ubG9hZCA9IG9uSWZyYW1lTG9hZDtcbiAgcmV0dXJuIGlmcmFtZTtcbn1cblxuZnVuY3Rpb24gYWRkT3ZlcmxheURpdlRvKGlmcmFtZSkge1xuICB2YXIgZGl2ID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheS1kaXYnO1xuICBkaXYuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICBkaXYuc3R5bGUubGVmdCA9IDA7XG4gIGRpdi5zdHlsZS50b3AgPSAwO1xuICBkaXYuc3R5bGUucmlnaHQgPSAwO1xuICBkaXYuc3R5bGUuYm90dG9tID0gMDtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgZGl2LnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjg1KSc7XG4gIGRpdi5zdHlsZS5jb2xvciA9ICcjRThFOEU4JztcbiAgZGl2LnN0eWxlLmZvbnRGYW1pbHkgPSAnTWVubG8sIENvbnNvbGFzLCBtb25vc3BhY2UnO1xuICBkaXYuc3R5bGUuZm9udFNpemUgPSAnbGFyZ2UnO1xuICBkaXYuc3R5bGUucGFkZGluZyA9ICcycmVtJztcbiAgZGl2LnN0eWxlLmxpbmVIZWlnaHQgPSAnMS4yJztcbiAgZGl2LnN0eWxlLndoaXRlU3BhY2UgPSAncHJlLXdyYXAnO1xuICBkaXYuc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gIGlmcmFtZS5jb250ZW50RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICByZXR1cm4gZGl2O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKG9uT3ZlcmxheURpdlJlYWR5KSB7XG4gIGlmIChvdmVybGF5RGl2KSB7XG4gICAgLy8gRXZlcnl0aGluZyBpcyByZWFkeSwgY2FsbCB0aGUgY2FsbGJhY2sgcmlnaHQgYXdheS5cbiAgICBvbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgICByZXR1cm47XG4gIH0gLy8gQ3JlYXRpbmcgYW4gaWZyYW1lIG1heSBiZSBhc3luY2hyb25vdXMgc28gd2UnbGwgc2NoZWR1bGUgdGhlIGNhbGxiYWNrLlxuICAvLyBJbiBjYXNlIG9mIG11bHRpcGxlIGNhbGxzLCBsYXN0IGNhbGxiYWNrIHdpbnMuXG5cblxuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBvbk92ZXJsYXlEaXZSZWFkeTtcblxuICBpZiAob3ZlcmxheUlmcmFtZSkge1xuICAgIC8vIFdlJ3ZlIGFscmVhZHkgY3JlYXRlZCBpdC5cbiAgICByZXR1cm47XG4gIH0gLy8gQ3JlYXRlIGlmcmFtZSBhbmQsIHdoZW4gaXQgaXMgcmVhZHksIGEgZGl2IGluc2lkZSBpdC5cblxuXG4gIG92ZXJsYXlJZnJhbWUgPSBjcmVhdGVPdmVybGF5SWZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICBvdmVybGF5RGl2ID0gYWRkT3ZlcmxheURpdlRvKG92ZXJsYXlJZnJhbWUpOyAvLyBOb3cgd2UgY2FuIHRhbGshXG5cbiAgICBsYXN0T25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gIH0pOyAvLyBaYWxnbyBhbGVydDogb25JZnJhbWVMb2FkKCkgd2lsbCBiZSBjYWxsZWQgZWl0aGVyIHN5bmNocm9ub3VzbHlcbiAgLy8gb3IgYXN5bmNocm9ub3VzbHkgZGVwZW5kaW5nIG9uIHRoZSBicm93c2VyLlxuICAvLyBXZSBkZWxheSBhZGRpbmcgaXQgc28gYG92ZXJsYXlJZnJhbWVgIGlzIHNldCB3aGVuIGBvbklmcmFtZUxvYWRgIGZpcmVzLlxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG59IC8vIFN1Y2Nlc3NmdWwgY29tcGlsYXRpb24uXG5cblxuZnVuY3Rpb24gY2xlYXIoKSB7XG4gIGlmICghb3ZlcmxheURpdikge1xuICAgIC8vIEl0IGlzIG5vdCB0aGVyZSBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gICAgcmV0dXJuO1xuICB9IC8vIENsZWFuIHVwIGFuZCByZXNldCBpbnRlcm5hbCBzdGF0ZS5cblxuXG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQob3ZlcmxheUlmcmFtZSk7XG4gIG92ZXJsYXlEaXYgPSBudWxsO1xuICBvdmVybGF5SWZyYW1lID0gbnVsbDtcbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gbnVsbDtcbn0gLy8gQ29tcGlsYXRpb24gd2l0aCBlcnJvcnMgKGUuZy4gc3ludGF4IGVycm9yIG9yIG1pc3NpbmcgbW9kdWxlcykuXG5cblxuZnVuY3Rpb24gc2hvd01lc3NhZ2UobWVzc2FnZXMpIHtcbiAgZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhmdW5jdGlvbiAoZGl2KSB7XG4gICAgLy8gTWFrZSBpdCBsb29rIHNpbWlsYXIgdG8gb3VyIHRlcm1pbmFsLlxuICAgIGRpdi5pbm5lckhUTUwgPSBcIjxzcGFuIHN0eWxlPVxcXCJjb2xvcjogI1wiLmNvbmNhdChjb2xvcnMucmVkLCBcIlxcXCI+RmFpbGVkIHRvIGNvbXBpbGUuPC9zcGFuPjxicj48YnI+XCIpLmNvbmNhdChhbnNpSFRNTChlbnRpdGllcy5lbmNvZGUobWVzc2FnZXNbMF0pKSk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY2xlYXI6IGNsZWFyLFxuICBzaG93TWVzc2FnZTogc2hvd01lc3NhZ2Vcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gYW5zaUhUTUxcblxuLy8gUmVmZXJlbmNlIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvYW5zaS1yZWdleFxudmFyIF9yZWdBTlNJID0gLyg/Oig/OlxcdTAwMWJcXFspfFxcdTAwOWIpKD86KD86WzAtOV17MSwzfSk/KD86KD86O1swLTldezAsM30pKik/W0EtTXxmLW1dKXxcXHUwMDFiW0EtTV0vXG5cbnZhciBfZGVmQ29sb3JzID0ge1xuICByZXNldDogWydmZmYnLCAnMDAwJ10sIC8vIFtGT1JFR1JPVURfQ09MT1IsIEJBQ0tHUk9VTkRfQ09MT1JdXG4gIGJsYWNrOiAnMDAwJyxcbiAgcmVkOiAnZmYwMDAwJyxcbiAgZ3JlZW46ICcyMDk4MDUnLFxuICB5ZWxsb3c6ICdlOGJmMDMnLFxuICBibHVlOiAnMDAwMGZmJyxcbiAgbWFnZW50YTogJ2ZmMDBmZicsXG4gIGN5YW46ICcwMGZmZWUnLFxuICBsaWdodGdyZXk6ICdmMGYwZjAnLFxuICBkYXJrZ3JleTogJzg4OCdcbn1cbnZhciBfc3R5bGVzID0ge1xuICAzMDogJ2JsYWNrJyxcbiAgMzE6ICdyZWQnLFxuICAzMjogJ2dyZWVuJyxcbiAgMzM6ICd5ZWxsb3cnLFxuICAzNDogJ2JsdWUnLFxuICAzNTogJ21hZ2VudGEnLFxuICAzNjogJ2N5YW4nLFxuICAzNzogJ2xpZ2h0Z3JleSdcbn1cbnZhciBfb3BlblRhZ3MgPSB7XG4gICcxJzogJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAvLyBib2xkXG4gICcyJzogJ29wYWNpdHk6MC41JywgLy8gZGltXG4gICczJzogJzxpPicsIC8vIGl0YWxpY1xuICAnNCc6ICc8dT4nLCAvLyB1bmRlcnNjb3JlXG4gICc4JzogJ2Rpc3BsYXk6bm9uZScsIC8vIGhpZGRlblxuICAnOSc6ICc8ZGVsPicgLy8gZGVsZXRlXG59XG52YXIgX2Nsb3NlVGFncyA9IHtcbiAgJzIzJzogJzwvaT4nLCAvLyByZXNldCBpdGFsaWNcbiAgJzI0JzogJzwvdT4nLCAvLyByZXNldCB1bmRlcnNjb3JlXG4gICcyOSc6ICc8L2RlbD4nIC8vIHJlc2V0IGRlbGV0ZVxufVxuXG47WzAsIDIxLCAyMiwgMjcsIDI4LCAzOSwgNDldLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgX2Nsb3NlVGFnc1tuXSA9ICc8L3NwYW4+J1xufSlcblxuLyoqXG4gKiBDb252ZXJ0cyB0ZXh0IHdpdGggQU5TSSBjb2xvciBjb2RlcyB0byBIVE1MIG1hcmt1cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYW5zaUhUTUwgKHRleHQpIHtcbiAgLy8gUmV0dXJucyB0aGUgdGV4dCBpZiB0aGUgc3RyaW5nIGhhcyBubyBBTlNJIGVzY2FwZSBjb2RlLlxuICBpZiAoIV9yZWdBTlNJLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLy8gQ2FjaGUgb3BlbmVkIHNlcXVlbmNlLlxuICB2YXIgYW5zaUNvZGVzID0gW11cbiAgLy8gUmVwbGFjZSB3aXRoIG1hcmt1cC5cbiAgdmFyIHJldCA9IHRleHQucmVwbGFjZSgvXFwwMzNcXFsoXFxkKykqbS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNlcSkge1xuICAgIHZhciBvdCA9IF9vcGVuVGFnc1tzZXFdXG4gICAgaWYgKG90KSB7XG4gICAgICAvLyBJZiBjdXJyZW50IHNlcXVlbmNlIGhhcyBiZWVuIG9wZW5lZCwgY2xvc2UgaXQuXG4gICAgICBpZiAoISF+YW5zaUNvZGVzLmluZGV4T2Yoc2VxKSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWV4dHJhLWJvb2xlYW4tY2FzdFxuICAgICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgICAgcmV0dXJuICc8L3NwYW4+J1xuICAgICAgfVxuICAgICAgLy8gT3BlbiB0YWcuXG4gICAgICBhbnNpQ29kZXMucHVzaChzZXEpXG4gICAgICByZXR1cm4gb3RbMF0gPT09ICc8JyA/IG90IDogJzxzcGFuIHN0eWxlPVwiJyArIG90ICsgJztcIj4nXG4gICAgfVxuXG4gICAgdmFyIGN0ID0gX2Nsb3NlVGFnc1tzZXFdXG4gICAgaWYgKGN0KSB7XG4gICAgICAvLyBQb3Agc2VxdWVuY2VcbiAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIGN0XG4gICAgfVxuICAgIHJldHVybiAnJ1xuICB9KVxuXG4gIC8vIE1ha2Ugc3VyZSB0YWdzIGFyZSBjbG9zZWQuXG4gIHZhciBsID0gYW5zaUNvZGVzLmxlbmd0aFxuICA7KGwgPiAwKSAmJiAocmV0ICs9IEFycmF5KGwgKyAxKS5qb2luKCc8L3NwYW4+JykpXG5cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIEN1c3RvbWl6ZSBjb2xvcnMuXG4gKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIHJlZmVyZW5jZSB0byBfZGVmQ29sb3JzXG4gKi9cbmFuc2lIVE1MLnNldENvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcbiAgaWYgKHR5cGVvZiBjb2xvcnMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgY29sb3JzYCBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBPYmplY3QuJylcbiAgfVxuXG4gIHZhciBfZmluYWxDb2xvcnMgPSB7fVxuICBmb3IgKHZhciBrZXkgaW4gX2RlZkNvbG9ycykge1xuICAgIHZhciBoZXggPSBjb2xvcnMuaGFzT3duUHJvcGVydHkoa2V5KSA/IGNvbG9yc1trZXldIDogbnVsbFxuICAgIGlmICghaGV4KSB7XG4gICAgICBfZmluYWxDb2xvcnNba2V5XSA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCdyZXNldCcgPT09IGtleSkge1xuICAgICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGhleCA9IFtoZXhdXG4gICAgICB9XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaGV4KSB8fCBoZXgubGVuZ3RoID09PSAwIHx8IGhleC5zb21lKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaCAhPT0gJ3N0cmluZydcbiAgICAgIH0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhbiBBcnJheSBhbmQgZWFjaCBpdGVtIGNvdWxkIG9ubHkgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgICAgfVxuICAgICAgdmFyIGRlZkhleENvbG9yID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBpZiAoIWhleFswXSkge1xuICAgICAgICBoZXhbMF0gPSBkZWZIZXhDb2xvclswXVxuICAgICAgfVxuICAgICAgaWYgKGhleC5sZW5ndGggPT09IDEgfHwgIWhleFsxXSkge1xuICAgICAgICBoZXggPSBbaGV4WzBdXVxuICAgICAgICBoZXgucHVzaChkZWZIZXhDb2xvclsxXSlcbiAgICAgIH1cblxuICAgICAgaGV4ID0gaGV4LnNsaWNlKDAsIDIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICB9XG4gICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBoZXhcbiAgfVxuICBfc2V0VGFncyhfZmluYWxDb2xvcnMpXG59XG5cbi8qKlxuICogUmVzZXQgY29sb3JzLlxuICovXG5hbnNpSFRNTC5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgX3NldFRhZ3MoX2RlZkNvbG9ycylcbn1cblxuLyoqXG4gKiBFeHBvc2UgdGFncywgaW5jbHVkaW5nIG9wZW4gYW5kIGNsb3NlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuYW5zaUhUTUwudGFncyA9IHt9XG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdvcGVuJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX29wZW5UYWdzIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFuc2lIVE1MLnRhZ3MsICdjbG9zZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9jbG9zZVRhZ3MgfVxuICB9KVxufSBlbHNlIHtcbiAgYW5zaUhUTUwudGFncy5vcGVuID0gX29wZW5UYWdzXG4gIGFuc2lIVE1MLnRhZ3MuY2xvc2UgPSBfY2xvc2VUYWdzXG59XG5cbmZ1bmN0aW9uIF9zZXRUYWdzIChjb2xvcnMpIHtcbiAgLy8gcmVzZXQgYWxsXG4gIF9vcGVuVGFnc1snMCddID0gJ2ZvbnQtd2VpZ2h0Om5vcm1hbDtvcGFjaXR5OjE7Y29sb3I6IycgKyBjb2xvcnMucmVzZXRbMF0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMV1cbiAgLy8gaW52ZXJzZVxuICBfb3BlblRhZ3NbJzcnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5yZXNldFsxXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFswXVxuICAvLyBkYXJrIGdyZXlcbiAgX29wZW5UYWdzWyc5MCddID0gJ2NvbG9yOiMnICsgY29sb3JzLmRhcmtncmV5XG5cbiAgZm9yICh2YXIgY29kZSBpbiBfc3R5bGVzKSB7XG4gICAgdmFyIGNvbG9yID0gX3N0eWxlc1tjb2RlXVxuICAgIHZhciBvcmlDb2xvciA9IGNvbG9yc1tjb2xvcl0gfHwgJzAwMCdcbiAgICBfb3BlblRhZ3NbY29kZV0gPSAnY29sb3I6IycgKyBvcmlDb2xvclxuICAgIGNvZGUgPSBwYXJzZUludChjb2RlKVxuICAgIF9vcGVuVGFnc1soY29kZSArIDEwKS50b1N0cmluZygpXSA9ICdiYWNrZ3JvdW5kOiMnICsgb3JpQ29sb3JcbiAgfVxufVxuXG5hbnNpSFRNTC5yZXNldCgpXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB4bWxfZW50aXRpZXNfMSA9IHJlcXVpcmUoXCIuL3htbC1lbnRpdGllc1wiKTtcbmV4cG9ydHMuWG1sRW50aXRpZXMgPSB4bWxfZW50aXRpZXNfMS5YbWxFbnRpdGllcztcbnZhciBodG1sNF9lbnRpdGllc18xID0gcmVxdWlyZShcIi4vaHRtbDQtZW50aXRpZXNcIik7XG5leHBvcnRzLkh0bWw0RW50aXRpZXMgPSBodG1sNF9lbnRpdGllc18xLkh0bWw0RW50aXRpZXM7XG52YXIgaHRtbDVfZW50aXRpZXNfMSA9IHJlcXVpcmUoXCIuL2h0bWw1LWVudGl0aWVzXCIpO1xuZXhwb3J0cy5IdG1sNUVudGl0aWVzID0gaHRtbDVfZW50aXRpZXNfMS5IdG1sNUVudGl0aWVzO1xuZXhwb3J0cy5BbGxIdG1sRW50aXRpZXMgPSBodG1sNV9lbnRpdGllc18xLkh0bWw1RW50aXRpZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBTFBIQV9JTkRFWCA9IHtcbiAgICAnJmx0JzogJzwnLFxuICAgICcmZ3QnOiAnPicsXG4gICAgJyZxdW90JzogJ1wiJyxcbiAgICAnJmFwb3MnOiAnXFwnJyxcbiAgICAnJmFtcCc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJmFwb3M7JzogJ1xcJycsXG4gICAgJyZhbXA7JzogJyYnXG59O1xudmFyIENIQVJfSU5ERVggPSB7XG4gICAgNjA6ICdsdCcsXG4gICAgNjI6ICdndCcsXG4gICAgMzQ6ICdxdW90JyxcbiAgICAzOTogJ2Fwb3MnLFxuICAgIDM4OiAnYW1wJ1xufTtcbnZhciBDSEFSX1NfSU5ERVggPSB7XG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgJ1xcJyc6ICcmYXBvczsnLFxuICAgICcmJzogJyZhbXA7J1xufTtcbnZhciBYbWxFbnRpdGllcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYbWxFbnRpdGllcygpIHtcbiAgICB9XG4gICAgWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1s8PlwiJyZdL2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICByZXR1cm4gQ0hBUl9TX0lOREVYW3NdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFhtbEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZShzdHIpO1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjP1swLTlhLXpBLVpdKzs/L2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICBpZiAocy5jaGFyQXQoMSkgPT09ICcjJykge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcy5jaGFyQXQoMikudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMyksIDE2KSA6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlSW50KHMuc3Vic3RyKDIpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBBTFBIQV9JTkRFWFtzXSB8fCBzO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFhtbEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmRlY29kZShzdHIpO1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGFscGhhID0gQ0hBUl9JTkRFWFtjXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFhtbEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuICAgIH07XG4gICAgWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5naHQgPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5naHQpIHtcbiAgICAgICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFhtbEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiAgICB9O1xuICAgIHJldHVybiBYbWxFbnRpdGllcztcbn0oKSk7XG5leHBvcnRzLlhtbEVudGl0aWVzID0gWG1sRW50aXRpZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBIVE1MX0FMUEhBID0gWydhcG9zJywgJ25ic3AnLCAnaWV4Y2wnLCAnY2VudCcsICdwb3VuZCcsICdjdXJyZW4nLCAneWVuJywgJ2JydmJhcicsICdzZWN0JywgJ3VtbCcsICdjb3B5JywgJ29yZGYnLCAnbGFxdW8nLCAnbm90JywgJ3NoeScsICdyZWcnLCAnbWFjcicsICdkZWcnLCAncGx1c21uJywgJ3N1cDInLCAnc3VwMycsICdhY3V0ZScsICdtaWNybycsICdwYXJhJywgJ21pZGRvdCcsICdjZWRpbCcsICdzdXAxJywgJ29yZG0nLCAncmFxdW8nLCAnZnJhYzE0JywgJ2ZyYWMxMicsICdmcmFjMzQnLCAnaXF1ZXN0JywgJ0FncmF2ZScsICdBYWN1dGUnLCAnQWNpcmMnLCAnQXRpbGRlJywgJ0F1bWwnLCAnQXJpbmcnLCAnQWVsaWcnLCAnQ2NlZGlsJywgJ0VncmF2ZScsICdFYWN1dGUnLCAnRWNpcmMnLCAnRXVtbCcsICdJZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjJywgJ0l1bWwnLCAnRVRIJywgJ050aWxkZScsICdPZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjJywgJ090aWxkZScsICdPdW1sJywgJ3RpbWVzJywgJ09zbGFzaCcsICdVZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjJywgJ1V1bWwnLCAnWWFjdXRlJywgJ1RIT1JOJywgJ3N6bGlnJywgJ2FncmF2ZScsICdhYWN1dGUnLCAnYWNpcmMnLCAnYXRpbGRlJywgJ2F1bWwnLCAnYXJpbmcnLCAnYWVsaWcnLCAnY2NlZGlsJywgJ2VncmF2ZScsICdlYWN1dGUnLCAnZWNpcmMnLCAnZXVtbCcsICdpZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjJywgJ2l1bWwnLCAnZXRoJywgJ250aWxkZScsICdvZ3JhdmUnLCAnb2FjdXRlJywgJ29jaXJjJywgJ290aWxkZScsICdvdW1sJywgJ2RpdmlkZScsICdvc2xhc2gnLCAndWdyYXZlJywgJ3VhY3V0ZScsICd1Y2lyYycsICd1dW1sJywgJ3lhY3V0ZScsICd0aG9ybicsICd5dW1sJywgJ3F1b3QnLCAnYW1wJywgJ2x0JywgJ2d0JywgJ09FbGlnJywgJ29lbGlnJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWXVtbCcsICdjaXJjJywgJ3RpbGRlJywgJ2Vuc3AnLCAnZW1zcCcsICd0aGluc3AnLCAnenduaicsICd6d2onLCAnbHJtJywgJ3JsbScsICduZGFzaCcsICdtZGFzaCcsICdsc3F1bycsICdyc3F1bycsICdzYnF1bycsICdsZHF1bycsICdyZHF1bycsICdiZHF1bycsICdkYWdnZXInLCAnRGFnZ2VyJywgJ3Blcm1pbCcsICdsc2FxdW8nLCAncnNhcXVvJywgJ2V1cm8nLCAnZm5vZicsICdBbHBoYScsICdCZXRhJywgJ0dhbW1hJywgJ0RlbHRhJywgJ0Vwc2lsb24nLCAnWmV0YScsICdFdGEnLCAnVGhldGEnLCAnSW90YScsICdLYXBwYScsICdMYW1iZGEnLCAnTXUnLCAnTnUnLCAnWGknLCAnT21pY3JvbicsICdQaScsICdSaG8nLCAnU2lnbWEnLCAnVGF1JywgJ1Vwc2lsb24nLCAnUGhpJywgJ0NoaScsICdQc2knLCAnT21lZ2EnLCAnYWxwaGEnLCAnYmV0YScsICdnYW1tYScsICdkZWx0YScsICdlcHNpbG9uJywgJ3pldGEnLCAnZXRhJywgJ3RoZXRhJywgJ2lvdGEnLCAna2FwcGEnLCAnbGFtYmRhJywgJ211JywgJ251JywgJ3hpJywgJ29taWNyb24nLCAncGknLCAncmhvJywgJ3NpZ21hZicsICdzaWdtYScsICd0YXUnLCAndXBzaWxvbicsICdwaGknLCAnY2hpJywgJ3BzaScsICdvbWVnYScsICd0aGV0YXN5bScsICd1cHNpaCcsICdwaXYnLCAnYnVsbCcsICdoZWxsaXAnLCAncHJpbWUnLCAnUHJpbWUnLCAnb2xpbmUnLCAnZnJhc2wnLCAnd2VpZXJwJywgJ2ltYWdlJywgJ3JlYWwnLCAndHJhZGUnLCAnYWxlZnN5bScsICdsYXJyJywgJ3VhcnInLCAncmFycicsICdkYXJyJywgJ2hhcnInLCAnY3JhcnInLCAnbEFycicsICd1QXJyJywgJ3JBcnInLCAnZEFycicsICdoQXJyJywgJ2ZvcmFsbCcsICdwYXJ0JywgJ2V4aXN0JywgJ2VtcHR5JywgJ25hYmxhJywgJ2lzaW4nLCAnbm90aW4nLCAnbmknLCAncHJvZCcsICdzdW0nLCAnbWludXMnLCAnbG93YXN0JywgJ3JhZGljJywgJ3Byb3AnLCAnaW5maW4nLCAnYW5nJywgJ2FuZCcsICdvcicsICdjYXAnLCAnY3VwJywgJ2ludCcsICd0aGVyZTQnLCAnc2ltJywgJ2NvbmcnLCAnYXN5bXAnLCAnbmUnLCAnZXF1aXYnLCAnbGUnLCAnZ2UnLCAnc3ViJywgJ3N1cCcsICduc3ViJywgJ3N1YmUnLCAnc3VwZScsICdvcGx1cycsICdvdGltZXMnLCAncGVycCcsICdzZG90JywgJ2xjZWlsJywgJ3JjZWlsJywgJ2xmbG9vcicsICdyZmxvb3InLCAnbGFuZycsICdyYW5nJywgJ2xveicsICdzcGFkZXMnLCAnY2x1YnMnLCAnaGVhcnRzJywgJ2RpYW1zJ107XG52YXIgSFRNTF9DT0RFUyA9IFszOSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSwgMTcyLCAxNzMsIDE3NCwgMTc1LCAxNzYsIDE3NywgMTc4LCAxNzksIDE4MCwgMTgxLCAxODIsIDE4MywgMTg0LCAxODUsIDE4NiwgMTg3LCAxODgsIDE4OSwgMTkwLCAxOTEsIDE5MiwgMTkzLCAxOTQsIDE5NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCwgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxMCwgMjExLCAyMTIsIDIxMywgMjE0LCAyMTUsIDIxNiwgMjE3LCAyMTgsIDIxOSwgMjIwLCAyMjEsIDIyMiwgMjIzLCAyMjQsIDIyNSwgMjI2LCAyMjcsIDIyOCwgMjI5LCAyMzAsIDIzMSwgMjMyLCAyMzMsIDIzNCwgMjM1LCAyMzYsIDIzNywgMjM4LCAyMzksIDI0MCwgMjQxLCAyNDIsIDI0MywgMjQ0LCAyNDUsIDI0NiwgMjQ3LCAyNDgsIDI0OSwgMjUwLCAyNTEsIDI1MiwgMjUzLCAyNTQsIDI1NSwgMzQsIDM4LCA2MCwgNjIsIDMzOCwgMzM5LCAzNTIsIDM1MywgMzc2LCA3MTAsIDczMiwgODE5NCwgODE5NSwgODIwMSwgODIwNCwgODIwNSwgODIwNiwgODIwNywgODIxMSwgODIxMiwgODIxNiwgODIxNywgODIxOCwgODIyMCwgODIyMSwgODIyMiwgODIyNCwgODIyNSwgODI0MCwgODI0OSwgODI1MCwgODM2NCwgNDAyLCA5MTMsIDkxNCwgOTE1LCA5MTYsIDkxNywgOTE4LCA5MTksIDkyMCwgOTIxLCA5MjIsIDkyMywgOTI0LCA5MjUsIDkyNiwgOTI3LCA5MjgsIDkyOSwgOTMxLCA5MzIsIDkzMywgOTM0LCA5MzUsIDkzNiwgOTM3LCA5NDUsIDk0NiwgOTQ3LCA5NDgsIDk0OSwgOTUwLCA5NTEsIDk1MiwgOTUzLCA5NTQsIDk1NSwgOTU2LCA5NTcsIDk1OCwgOTU5LCA5NjAsIDk2MSwgOTYyLCA5NjMsIDk2NCwgOTY1LCA5NjYsIDk2NywgOTY4LCA5NjksIDk3NywgOTc4LCA5ODIsIDgyMjYsIDgyMzAsIDgyNDIsIDgyNDMsIDgyNTQsIDgyNjAsIDg0NzIsIDg0NjUsIDg0NzYsIDg0ODIsIDg1MDEsIDg1OTIsIDg1OTMsIDg1OTQsIDg1OTUsIDg1OTYsIDg2MjksIDg2NTYsIDg2NTcsIDg2NTgsIDg2NTksIDg2NjAsIDg3MDQsIDg3MDYsIDg3MDcsIDg3MDksIDg3MTEsIDg3MTIsIDg3MTMsIDg3MTUsIDg3MTksIDg3MjEsIDg3MjIsIDg3MjcsIDg3MzAsIDg3MzMsIDg3MzQsIDg3MzYsIDg3NDMsIDg3NDQsIDg3NDUsIDg3NDYsIDg3NDcsIDg3NTYsIDg3NjQsIDg3NzMsIDg3NzYsIDg4MDAsIDg4MDEsIDg4MDQsIDg4MDUsIDg4MzQsIDg4MzUsIDg4MzYsIDg4MzgsIDg4MzksIDg4NTMsIDg4NTUsIDg4NjksIDg5MDEsIDg5NjgsIDg5NjksIDg5NzAsIDg5NzEsIDkwMDEsIDkwMDIsIDk2NzQsIDk4MjQsIDk4MjcsIDk4MjksIDk4MzBdO1xudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBudW1JbmRleCA9IHt9O1xuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IEhUTUxfQUxQSEEubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhID0gSFRNTF9BTFBIQVtpXTtcbiAgICAgICAgdmFyIGMgPSBIVE1MX0NPREVTW2ldO1xuICAgICAgICBhbHBoYUluZGV4W2FdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICAgICAgbnVtSW5kZXhbY10gPSBhO1xuICAgICAgICBpKys7XG4gICAgfVxufSkoKTtcbnZhciBIdG1sNEVudGl0aWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw0RW50aXRpZXMoKSB7XG4gICAgfVxuICAgIEh0bWw0RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24gKHMsIGVudGl0eSkge1xuICAgICAgICAgICAgdmFyIGNocjtcbiAgICAgICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLCAxNikgOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmRlY29kZShzdHIpO1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBhbHBoYSA/IFwiJlwiICsgYWxwaGEgKyBcIjtcIiA6IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiAgICB9O1xuICAgIEh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY2MgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W2NjXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjYyA8IDMyIHx8IGNjID4gMTI2KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJiNcIiArIGNjICsgXCI7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSAnJztcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgSHRtbDRFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiAgICB9O1xuICAgIHJldHVybiBIdG1sNEVudGl0aWVzO1xufSgpKTtcbmV4cG9ydHMuSHRtbDRFbnRpdGllcyA9IEh0bWw0RW50aXRpZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBFTlRJVElFUyA9IFtbJ0FhY3V0ZScsIFsxOTNdXSwgWydhYWN1dGUnLCBbMjI1XV0sIFsnQWJyZXZlJywgWzI1OF1dLCBbJ2FicmV2ZScsIFsyNTldXSwgWydhYycsIFs4NzY2XV0sIFsnYWNkJywgWzg3NjddXSwgWydhY0UnLCBbODc2NiwgODE5XV0sIFsnQWNpcmMnLCBbMTk0XV0sIFsnYWNpcmMnLCBbMjI2XV0sIFsnYWN1dGUnLCBbMTgwXV0sIFsnQWN5JywgWzEwNDBdXSwgWydhY3knLCBbMTA3Ml1dLCBbJ0FFbGlnJywgWzE5OF1dLCBbJ2FlbGlnJywgWzIzMF1dLCBbJ2FmJywgWzgyODldXSwgWydBZnInLCBbMTIwMDY4XV0sIFsnYWZyJywgWzEyMDA5NF1dLCBbJ0FncmF2ZScsIFsxOTJdXSwgWydhZ3JhdmUnLCBbMjI0XV0sIFsnYWxlZnN5bScsIFs4NTAxXV0sIFsnYWxlcGgnLCBbODUwMV1dLCBbJ0FscGhhJywgWzkxM11dLCBbJ2FscGhhJywgWzk0NV1dLCBbJ0FtYWNyJywgWzI1Nl1dLCBbJ2FtYWNyJywgWzI1N11dLCBbJ2FtYWxnJywgWzEwODE1XV0sIFsnYW1wJywgWzM4XV0sIFsnQU1QJywgWzM4XV0sIFsnYW5kYW5kJywgWzEwODM3XV0sIFsnQW5kJywgWzEwODM1XV0sIFsnYW5kJywgWzg3NDNdXSwgWydhbmRkJywgWzEwODQ0XV0sIFsnYW5kc2xvcGUnLCBbMTA4NDBdXSwgWydhbmR2JywgWzEwODQyXV0sIFsnYW5nJywgWzg3MzZdXSwgWydhbmdlJywgWzEwNjYwXV0sIFsnYW5nbGUnLCBbODczNl1dLCBbJ2FuZ21zZGFhJywgWzEwNjY0XV0sIFsnYW5nbXNkYWInLCBbMTA2NjVdXSwgWydhbmdtc2RhYycsIFsxMDY2Nl1dLCBbJ2FuZ21zZGFkJywgWzEwNjY3XV0sIFsnYW5nbXNkYWUnLCBbMTA2NjhdXSwgWydhbmdtc2RhZicsIFsxMDY2OV1dLCBbJ2FuZ21zZGFnJywgWzEwNjcwXV0sIFsnYW5nbXNkYWgnLCBbMTA2NzFdXSwgWydhbmdtc2QnLCBbODczN11dLCBbJ2FuZ3J0JywgWzg3MzVdXSwgWydhbmdydHZiJywgWzg4OTRdXSwgWydhbmdydHZiZCcsIFsxMDY1M11dLCBbJ2FuZ3NwaCcsIFs4NzM4XV0sIFsnYW5nc3QnLCBbMTk3XV0sIFsnYW5nemFycicsIFs5MDg0XV0sIFsnQW9nb24nLCBbMjYwXV0sIFsnYW9nb24nLCBbMjYxXV0sIFsnQW9wZicsIFsxMjAxMjBdXSwgWydhb3BmJywgWzEyMDE0Nl1dLCBbJ2FwYWNpcicsIFsxMDg2M11dLCBbJ2FwJywgWzg3NzZdXSwgWydhcEUnLCBbMTA4NjRdXSwgWydhcGUnLCBbODc3OF1dLCBbJ2FwaWQnLCBbODc3OV1dLCBbJ2Fwb3MnLCBbMzldXSwgWydBcHBseUZ1bmN0aW9uJywgWzgyODldXSwgWydhcHByb3gnLCBbODc3Nl1dLCBbJ2FwcHJveGVxJywgWzg3NzhdXSwgWydBcmluZycsIFsxOTddXSwgWydhcmluZycsIFsyMjldXSwgWydBc2NyJywgWzExOTk2NF1dLCBbJ2FzY3InLCBbMTE5OTkwXV0sIFsnQXNzaWduJywgWzg3ODhdXSwgWydhc3QnLCBbNDJdXSwgWydhc3ltcCcsIFs4Nzc2XV0sIFsnYXN5bXBlcScsIFs4NzgxXV0sIFsnQXRpbGRlJywgWzE5NV1dLCBbJ2F0aWxkZScsIFsyMjddXSwgWydBdW1sJywgWzE5Nl1dLCBbJ2F1bWwnLCBbMjI4XV0sIFsnYXdjb25pbnQnLCBbODc1NV1dLCBbJ2F3aW50JywgWzEwNzY5XV0sIFsnYmFja2NvbmcnLCBbODc4MF1dLCBbJ2JhY2tlcHNpbG9uJywgWzEwMTRdXSwgWydiYWNrcHJpbWUnLCBbODI0NV1dLCBbJ2JhY2tzaW0nLCBbODc2NV1dLCBbJ2JhY2tzaW1lcScsIFs4OTA5XV0sIFsnQmFja3NsYXNoJywgWzg3MjZdXSwgWydCYXJ2JywgWzEwOTgzXV0sIFsnYmFydmVlJywgWzg4OTNdXSwgWydiYXJ3ZWQnLCBbODk2NV1dLCBbJ0JhcndlZCcsIFs4OTY2XV0sIFsnYmFyd2VkZ2UnLCBbODk2NV1dLCBbJ2JicmsnLCBbOTE0MV1dLCBbJ2Jicmt0YnJrJywgWzkxNDJdXSwgWydiY29uZycsIFs4NzgwXV0sIFsnQmN5JywgWzEwNDFdXSwgWydiY3knLCBbMTA3M11dLCBbJ2JkcXVvJywgWzgyMjJdXSwgWydiZWNhdXMnLCBbODc1N11dLCBbJ2JlY2F1c2UnLCBbODc1N11dLCBbJ0JlY2F1c2UnLCBbODc1N11dLCBbJ2JlbXB0eXYnLCBbMTA2NzJdXSwgWydiZXBzaScsIFsxMDE0XV0sIFsnYmVybm91JywgWzg0OTJdXSwgWydCZXJub3VsbGlzJywgWzg0OTJdXSwgWydCZXRhJywgWzkxNF1dLCBbJ2JldGEnLCBbOTQ2XV0sIFsnYmV0aCcsIFs4NTAyXV0sIFsnYmV0d2VlbicsIFs4ODEyXV0sIFsnQmZyJywgWzEyMDA2OV1dLCBbJ2JmcicsIFsxMjAwOTVdXSwgWydiaWdjYXAnLCBbODg5OF1dLCBbJ2JpZ2NpcmMnLCBbOTcxMV1dLCBbJ2JpZ2N1cCcsIFs4ODk5XV0sIFsnYmlnb2RvdCcsIFsxMDc1Ml1dLCBbJ2JpZ29wbHVzJywgWzEwNzUzXV0sIFsnYmlnb3RpbWVzJywgWzEwNzU0XV0sIFsnYmlnc3FjdXAnLCBbMTA3NThdXSwgWydiaWdzdGFyJywgWzk3MzNdXSwgWydiaWd0cmlhbmdsZWRvd24nLCBbOTY2MV1dLCBbJ2JpZ3RyaWFuZ2xldXAnLCBbOTY1MV1dLCBbJ2JpZ3VwbHVzJywgWzEwNzU2XV0sIFsnYmlndmVlJywgWzg4OTddXSwgWydiaWd3ZWRnZScsIFs4ODk2XV0sIFsnYmthcm93JywgWzEwNTA5XV0sIFsnYmxhY2tsb3plbmdlJywgWzEwNzMxXV0sIFsnYmxhY2tzcXVhcmUnLCBbOTY0Ml1dLCBbJ2JsYWNrdHJpYW5nbGUnLCBbOTY1Ml1dLCBbJ2JsYWNrdHJpYW5nbGVkb3duJywgWzk2NjJdXSwgWydibGFja3RyaWFuZ2xlbGVmdCcsIFs5NjY2XV0sIFsnYmxhY2t0cmlhbmdsZXJpZ2h0JywgWzk2NTZdXSwgWydibGFuaycsIFs5MjUxXV0sIFsnYmxrMTInLCBbOTYxOF1dLCBbJ2JsazE0JywgWzk2MTddXSwgWydibGszNCcsIFs5NjE5XV0sIFsnYmxvY2snLCBbOTYwOF1dLCBbJ2JuZScsIFs2MSwgODQyMV1dLCBbJ2JuZXF1aXYnLCBbODgwMSwgODQyMV1dLCBbJ2JOb3QnLCBbMTA5ODldXSwgWydibm90JywgWzg5NzZdXSwgWydCb3BmJywgWzEyMDEyMV1dLCBbJ2JvcGYnLCBbMTIwMTQ3XV0sIFsnYm90JywgWzg4NjldXSwgWydib3R0b20nLCBbODg2OV1dLCBbJ2Jvd3RpZScsIFs4OTA0XV0sIFsnYm94Ym94JywgWzEwNjk3XV0sIFsnYm94ZGwnLCBbOTQ4OF1dLCBbJ2JveGRMJywgWzk1NTddXSwgWydib3hEbCcsIFs5NTU4XV0sIFsnYm94REwnLCBbOTU1OV1dLCBbJ2JveGRyJywgWzk0ODRdXSwgWydib3hkUicsIFs5NTU0XV0sIFsnYm94RHInLCBbOTU1NV1dLCBbJ2JveERSJywgWzk1NTZdXSwgWydib3hoJywgWzk0NzJdXSwgWydib3hIJywgWzk1NTJdXSwgWydib3hoZCcsIFs5NTE2XV0sIFsnYm94SGQnLCBbOTU3Ml1dLCBbJ2JveGhEJywgWzk1NzNdXSwgWydib3hIRCcsIFs5NTc0XV0sIFsnYm94aHUnLCBbOTUyNF1dLCBbJ2JveEh1JywgWzk1NzVdXSwgWydib3hoVScsIFs5NTc2XV0sIFsnYm94SFUnLCBbOTU3N11dLCBbJ2JveG1pbnVzJywgWzg4NjNdXSwgWydib3hwbHVzJywgWzg4NjJdXSwgWydib3h0aW1lcycsIFs4ODY0XV0sIFsnYm94dWwnLCBbOTQ5Nl1dLCBbJ2JveHVMJywgWzk1NjNdXSwgWydib3hVbCcsIFs5NTY0XV0sIFsnYm94VUwnLCBbOTU2NV1dLCBbJ2JveHVyJywgWzk0OTJdXSwgWydib3h1UicsIFs5NTYwXV0sIFsnYm94VXInLCBbOTU2MV1dLCBbJ2JveFVSJywgWzk1NjJdXSwgWydib3h2JywgWzk0NzRdXSwgWydib3hWJywgWzk1NTNdXSwgWydib3h2aCcsIFs5NTMyXV0sIFsnYm94dkgnLCBbOTU3OF1dLCBbJ2JveFZoJywgWzk1NzldXSwgWydib3hWSCcsIFs5NTgwXV0sIFsnYm94dmwnLCBbOTUwOF1dLCBbJ2JveHZMJywgWzk1NjldXSwgWydib3hWbCcsIFs5NTcwXV0sIFsnYm94VkwnLCBbOTU3MV1dLCBbJ2JveHZyJywgWzk1MDBdXSwgWydib3h2UicsIFs5NTY2XV0sIFsnYm94VnInLCBbOTU2N11dLCBbJ2JveFZSJywgWzk1NjhdXSwgWydicHJpbWUnLCBbODI0NV1dLCBbJ2JyZXZlJywgWzcyOF1dLCBbJ0JyZXZlJywgWzcyOF1dLCBbJ2JydmJhcicsIFsxNjZdXSwgWydic2NyJywgWzExOTk5MV1dLCBbJ0JzY3InLCBbODQ5Ml1dLCBbJ2JzZW1pJywgWzgyNzFdXSwgWydic2ltJywgWzg3NjVdXSwgWydic2ltZScsIFs4OTA5XV0sIFsnYnNvbGInLCBbMTA2OTNdXSwgWydic29sJywgWzkyXV0sIFsnYnNvbGhzdWInLCBbMTAxODRdXSwgWydidWxsJywgWzgyMjZdXSwgWydidWxsZXQnLCBbODIyNl1dLCBbJ2J1bXAnLCBbODc4Ml1dLCBbJ2J1bXBFJywgWzEwOTI2XV0sIFsnYnVtcGUnLCBbODc4M11dLCBbJ0J1bXBlcScsIFs4NzgyXV0sIFsnYnVtcGVxJywgWzg3ODNdXSwgWydDYWN1dGUnLCBbMjYyXV0sIFsnY2FjdXRlJywgWzI2M11dLCBbJ2NhcGFuZCcsIFsxMDgyMF1dLCBbJ2NhcGJyY3VwJywgWzEwODI1XV0sIFsnY2FwY2FwJywgWzEwODI3XV0sIFsnY2FwJywgWzg3NDVdXSwgWydDYXAnLCBbODkxNF1dLCBbJ2NhcGN1cCcsIFsxMDgyM11dLCBbJ2NhcGRvdCcsIFsxMDgxNl1dLCBbJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJywgWzg1MTddXSwgWydjYXBzJywgWzg3NDUsIDY1MDI0XV0sIFsnY2FyZXQnLCBbODI1N11dLCBbJ2Nhcm9uJywgWzcxMV1dLCBbJ0NheWxleXMnLCBbODQ5M11dLCBbJ2NjYXBzJywgWzEwODI5XV0sIFsnQ2Nhcm9uJywgWzI2OF1dLCBbJ2NjYXJvbicsIFsyNjldXSwgWydDY2VkaWwnLCBbMTk5XV0sIFsnY2NlZGlsJywgWzIzMV1dLCBbJ0NjaXJjJywgWzI2NF1dLCBbJ2NjaXJjJywgWzI2NV1dLCBbJ0Njb25pbnQnLCBbODc1Ml1dLCBbJ2NjdXBzJywgWzEwODI4XV0sIFsnY2N1cHNzbScsIFsxMDgzMl1dLCBbJ0Nkb3QnLCBbMjY2XV0sIFsnY2RvdCcsIFsyNjddXSwgWydjZWRpbCcsIFsxODRdXSwgWydDZWRpbGxhJywgWzE4NF1dLCBbJ2NlbXB0eXYnLCBbMTA2NzRdXSwgWydjZW50JywgWzE2Ml1dLCBbJ2NlbnRlcmRvdCcsIFsxODNdXSwgWydDZW50ZXJEb3QnLCBbMTgzXV0sIFsnY2ZyJywgWzEyMDA5Nl1dLCBbJ0NmcicsIFs4NDkzXV0sIFsnQ0hjeScsIFsxMDYzXV0sIFsnY2hjeScsIFsxMDk1XV0sIFsnY2hlY2snLCBbMTAwMDNdXSwgWydjaGVja21hcmsnLCBbMTAwMDNdXSwgWydDaGknLCBbOTM1XV0sIFsnY2hpJywgWzk2N11dLCBbJ2NpcmMnLCBbNzEwXV0sIFsnY2lyY2VxJywgWzg3OTFdXSwgWydjaXJjbGVhcnJvd2xlZnQnLCBbODYzNF1dLCBbJ2NpcmNsZWFycm93cmlnaHQnLCBbODYzNV1dLCBbJ2NpcmNsZWRhc3QnLCBbODg1OV1dLCBbJ2NpcmNsZWRjaXJjJywgWzg4NThdXSwgWydjaXJjbGVkZGFzaCcsIFs4ODYxXV0sIFsnQ2lyY2xlRG90JywgWzg4NTddXSwgWydjaXJjbGVkUicsIFsxNzRdXSwgWydjaXJjbGVkUycsIFs5NDE2XV0sIFsnQ2lyY2xlTWludXMnLCBbODg1NF1dLCBbJ0NpcmNsZVBsdXMnLCBbODg1M11dLCBbJ0NpcmNsZVRpbWVzJywgWzg4NTVdXSwgWydjaXInLCBbOTY3NV1dLCBbJ2NpckUnLCBbMTA2OTFdXSwgWydjaXJlJywgWzg3OTFdXSwgWydjaXJmbmludCcsIFsxMDc2OF1dLCBbJ2Npcm1pZCcsIFsxMDk5MV1dLCBbJ2NpcnNjaXInLCBbMTA2OTBdXSwgWydDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NF1dLCBbJ2NsdWJzJywgWzk4MjddXSwgWydjbHVic3VpdCcsIFs5ODI3XV0sIFsnY29sb24nLCBbNThdXSwgWydDb2xvbicsIFs4NzU5XV0sIFsnQ29sb25lJywgWzEwODY4XV0sIFsnY29sb25lJywgWzg3ODhdXSwgWydjb2xvbmVxJywgWzg3ODhdXSwgWydjb21tYScsIFs0NF1dLCBbJ2NvbW1hdCcsIFs2NF1dLCBbJ2NvbXAnLCBbODcwNV1dLCBbJ2NvbXBmbicsIFs4NzI4XV0sIFsnY29tcGxlbWVudCcsIFs4NzA1XV0sIFsnY29tcGxleGVzJywgWzg0NTBdXSwgWydjb25nJywgWzg3NzNdXSwgWydjb25nZG90JywgWzEwODYxXV0sIFsnQ29uZ3J1ZW50JywgWzg4MDFdXSwgWydjb25pbnQnLCBbODc1MF1dLCBbJ0NvbmludCcsIFs4NzUxXV0sIFsnQ29udG91ckludGVncmFsJywgWzg3NTBdXSwgWydjb3BmJywgWzEyMDE0OF1dLCBbJ0NvcGYnLCBbODQ1MF1dLCBbJ2NvcHJvZCcsIFs4NzIwXV0sIFsnQ29wcm9kdWN0JywgWzg3MjBdXSwgWydjb3B5JywgWzE2OV1dLCBbJ0NPUFknLCBbMTY5XV0sIFsnY29weXNyJywgWzg0NzFdXSwgWydDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTVdXSwgWydjcmFycicsIFs4NjI5XV0sIFsnY3Jvc3MnLCBbMTAwMDddXSwgWydDcm9zcycsIFsxMDc5OV1dLCBbJ0NzY3InLCBbMTE5OTY2XV0sIFsnY3NjcicsIFsxMTk5OTJdXSwgWydjc3ViJywgWzEwOTU5XV0sIFsnY3N1YmUnLCBbMTA5NjFdXSwgWydjc3VwJywgWzEwOTYwXV0sIFsnY3N1cGUnLCBbMTA5NjJdXSwgWydjdGRvdCcsIFs4OTQzXV0sIFsnY3VkYXJybCcsIFsxMDU1Ml1dLCBbJ2N1ZGFycnInLCBbMTA1NDldXSwgWydjdWVwcicsIFs4OTI2XV0sIFsnY3Vlc2MnLCBbODkyN11dLCBbJ2N1bGFycicsIFs4NjMwXV0sIFsnY3VsYXJycCcsIFsxMDU1N11dLCBbJ2N1cGJyY2FwJywgWzEwODI0XV0sIFsnY3VwY2FwJywgWzEwODIyXV0sIFsnQ3VwQ2FwJywgWzg3ODFdXSwgWydjdXAnLCBbODc0Nl1dLCBbJ0N1cCcsIFs4OTE1XV0sIFsnY3VwY3VwJywgWzEwODI2XV0sIFsnY3VwZG90JywgWzg4NDVdXSwgWydjdXBvcicsIFsxMDgyMV1dLCBbJ2N1cHMnLCBbODc0NiwgNjUwMjRdXSwgWydjdXJhcnInLCBbODYzMV1dLCBbJ2N1cmFycm0nLCBbMTA1NTZdXSwgWydjdXJseWVxcHJlYycsIFs4OTI2XV0sIFsnY3VybHllcXN1Y2MnLCBbODkyN11dLCBbJ2N1cmx5dmVlJywgWzg5MTBdXSwgWydjdXJseXdlZGdlJywgWzg5MTFdXSwgWydjdXJyZW4nLCBbMTY0XV0sIFsnY3VydmVhcnJvd2xlZnQnLCBbODYzMF1dLCBbJ2N1cnZlYXJyb3dyaWdodCcsIFs4NjMxXV0sIFsnY3V2ZWUnLCBbODkxMF1dLCBbJ2N1d2VkJywgWzg5MTFdXSwgWydjd2NvbmludCcsIFs4NzU0XV0sIFsnY3dpbnQnLCBbODc1M11dLCBbJ2N5bGN0eScsIFs5MDA1XV0sIFsnZGFnZ2VyJywgWzgyMjRdXSwgWydEYWdnZXInLCBbODIyNV1dLCBbJ2RhbGV0aCcsIFs4NTA0XV0sIFsnZGFycicsIFs4NTk1XV0sIFsnRGFycicsIFs4NjA5XV0sIFsnZEFycicsIFs4NjU5XV0sIFsnZGFzaCcsIFs4MjA4XV0sIFsnRGFzaHYnLCBbMTA5ODBdXSwgWydkYXNodicsIFs4ODY3XV0sIFsnZGJrYXJvdycsIFsxMDUxMV1dLCBbJ2RibGFjJywgWzczM11dLCBbJ0RjYXJvbicsIFsyNzBdXSwgWydkY2Fyb24nLCBbMjcxXV0sIFsnRGN5JywgWzEwNDRdXSwgWydkY3knLCBbMTA3Nl1dLCBbJ2RkYWdnZXInLCBbODIyNV1dLCBbJ2RkYXJyJywgWzg2NTBdXSwgWydERCcsIFs4NTE3XV0sIFsnZGQnLCBbODUxOF1dLCBbJ0REb3RyYWhkJywgWzEwNTEzXV0sIFsnZGRvdHNlcScsIFsxMDg3MV1dLCBbJ2RlZycsIFsxNzZdXSwgWydEZWwnLCBbODcxMV1dLCBbJ0RlbHRhJywgWzkxNl1dLCBbJ2RlbHRhJywgWzk0OF1dLCBbJ2RlbXB0eXYnLCBbMTA2NzNdXSwgWydkZmlzaHQnLCBbMTA2MjNdXSwgWydEZnInLCBbMTIwMDcxXV0sIFsnZGZyJywgWzEyMDA5N11dLCBbJ2RIYXInLCBbMTA1OTddXSwgWydkaGFybCcsIFs4NjQzXV0sIFsnZGhhcnInLCBbODY0Ml1dLCBbJ0RpYWNyaXRpY2FsQWN1dGUnLCBbMTgwXV0sIFsnRGlhY3JpdGljYWxEb3QnLCBbNzI5XV0sIFsnRGlhY3JpdGljYWxEb3VibGVBY3V0ZScsIFs3MzNdXSwgWydEaWFjcml0aWNhbEdyYXZlJywgWzk2XV0sIFsnRGlhY3JpdGljYWxUaWxkZScsIFs3MzJdXSwgWydkaWFtJywgWzg5MDBdXSwgWydkaWFtb25kJywgWzg5MDBdXSwgWydEaWFtb25kJywgWzg5MDBdXSwgWydkaWFtb25kc3VpdCcsIFs5ODMwXV0sIFsnZGlhbXMnLCBbOTgzMF1dLCBbJ2RpZScsIFsxNjhdXSwgWydEaWZmZXJlbnRpYWxEJywgWzg1MThdXSwgWydkaWdhbW1hJywgWzk4OV1dLCBbJ2Rpc2luJywgWzg5NDZdXSwgWydkaXYnLCBbMjQ3XV0sIFsnZGl2aWRlJywgWzI0N11dLCBbJ2RpdmlkZW9udGltZXMnLCBbODkwM11dLCBbJ2Rpdm9ueCcsIFs4OTAzXV0sIFsnREpjeScsIFsxMDI2XV0sIFsnZGpjeScsIFsxMTA2XV0sIFsnZGxjb3JuJywgWzg5OTBdXSwgWydkbGNyb3AnLCBbODk3M11dLCBbJ2RvbGxhcicsIFszNl1dLCBbJ0RvcGYnLCBbMTIwMTIzXV0sIFsnZG9wZicsIFsxMjAxNDldXSwgWydEb3QnLCBbMTY4XV0sIFsnZG90JywgWzcyOV1dLCBbJ0RvdERvdCcsIFs4NDEyXV0sIFsnZG90ZXEnLCBbODc4NF1dLCBbJ2RvdGVxZG90JywgWzg3ODVdXSwgWydEb3RFcXVhbCcsIFs4Nzg0XV0sIFsnZG90bWludXMnLCBbODc2MF1dLCBbJ2RvdHBsdXMnLCBbODcyNF1dLCBbJ2RvdHNxdWFyZScsIFs4ODY1XV0sIFsnZG91YmxlYmFyd2VkZ2UnLCBbODk2Nl1dLCBbJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzUxXV0sIFsnRG91YmxlRG90JywgWzE2OF1dLCBbJ0RvdWJsZURvd25BcnJvdycsIFs4NjU5XV0sIFsnRG91YmxlTGVmdEFycm93JywgWzg2NTZdXSwgWydEb3VibGVMZWZ0UmlnaHRBcnJvdycsIFs4NjYwXV0sIFsnRG91YmxlTGVmdFRlZScsIFsxMDk4MF1dLCBbJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnLCBbMTAyMzJdXSwgWydEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzRdXSwgWydEb3VibGVMb25nUmlnaHRBcnJvdycsIFsxMDIzM11dLCBbJ0RvdWJsZVJpZ2h0QXJyb3cnLCBbODY1OF1dLCBbJ0RvdWJsZVJpZ2h0VGVlJywgWzg4NzJdXSwgWydEb3VibGVVcEFycm93JywgWzg2NTddXSwgWydEb3VibGVVcERvd25BcnJvdycsIFs4NjYxXV0sIFsnRG91YmxlVmVydGljYWxCYXInLCBbODc0MV1dLCBbJ0Rvd25BcnJvd0JhcicsIFsxMDUxNV1dLCBbJ2Rvd25hcnJvdycsIFs4NTk1XV0sIFsnRG93bkFycm93JywgWzg1OTVdXSwgWydEb3duYXJyb3cnLCBbODY1OV1dLCBbJ0Rvd25BcnJvd1VwQXJyb3cnLCBbODY5M11dLCBbJ0Rvd25CcmV2ZScsIFs3ODVdXSwgWydkb3duZG93bmFycm93cycsIFs4NjUwXV0sIFsnZG93bmhhcnBvb25sZWZ0JywgWzg2NDNdXSwgWydkb3duaGFycG9vbnJpZ2h0JywgWzg2NDJdXSwgWydEb3duTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc2XV0sIFsnRG93bkxlZnRUZWVWZWN0b3InLCBbMTA1OTBdXSwgWydEb3duTGVmdFZlY3RvckJhcicsIFsxMDU4Ml1dLCBbJ0Rvd25MZWZ0VmVjdG9yJywgWzg2MzddXSwgWydEb3duUmlnaHRUZWVWZWN0b3InLCBbMTA1OTFdXSwgWydEb3duUmlnaHRWZWN0b3JCYXInLCBbMTA1ODNdXSwgWydEb3duUmlnaHRWZWN0b3InLCBbODY0MV1dLCBbJ0Rvd25UZWVBcnJvdycsIFs4NjE1XV0sIFsnRG93blRlZScsIFs4ODY4XV0sIFsnZHJia2Fyb3cnLCBbMTA1MTJdXSwgWydkcmNvcm4nLCBbODk5MV1dLCBbJ2RyY3JvcCcsIFs4OTcyXV0sIFsnRHNjcicsIFsxMTk5NjddXSwgWydkc2NyJywgWzExOTk5M11dLCBbJ0RTY3knLCBbMTAyOV1dLCBbJ2RzY3knLCBbMTEwOV1dLCBbJ2Rzb2wnLCBbMTA3NDJdXSwgWydEc3Ryb2snLCBbMjcyXV0sIFsnZHN0cm9rJywgWzI3M11dLCBbJ2R0ZG90JywgWzg5NDVdXSwgWydkdHJpJywgWzk2NjNdXSwgWydkdHJpZicsIFs5NjYyXV0sIFsnZHVhcnInLCBbODY5M11dLCBbJ2R1aGFyJywgWzEwNjA3XV0sIFsnZHdhbmdsZScsIFsxMDY2Ml1dLCBbJ0RaY3knLCBbMTAzOV1dLCBbJ2R6Y3knLCBbMTExOV1dLCBbJ2R6aWdyYXJyJywgWzEwMjM5XV0sIFsnRWFjdXRlJywgWzIwMV1dLCBbJ2VhY3V0ZScsIFsyMzNdXSwgWydlYXN0ZXInLCBbMTA4NjJdXSwgWydFY2Fyb24nLCBbMjgyXV0sIFsnZWNhcm9uJywgWzI4M11dLCBbJ0VjaXJjJywgWzIwMl1dLCBbJ2VjaXJjJywgWzIzNF1dLCBbJ2VjaXInLCBbODc5MF1dLCBbJ2Vjb2xvbicsIFs4Nzg5XV0sIFsnRWN5JywgWzEwNjldXSwgWydlY3knLCBbMTEwMV1dLCBbJ2VERG90JywgWzEwODcxXV0sIFsnRWRvdCcsIFsyNzhdXSwgWydlZG90JywgWzI3OV1dLCBbJ2VEb3QnLCBbODc4NV1dLCBbJ2VlJywgWzg1MTldXSwgWydlZkRvdCcsIFs4Nzg2XV0sIFsnRWZyJywgWzEyMDA3Ml1dLCBbJ2VmcicsIFsxMjAwOThdXSwgWydlZycsIFsxMDkwNl1dLCBbJ0VncmF2ZScsIFsyMDBdXSwgWydlZ3JhdmUnLCBbMjMyXV0sIFsnZWdzJywgWzEwOTAyXV0sIFsnZWdzZG90JywgWzEwOTA0XV0sIFsnZWwnLCBbMTA5MDVdXSwgWydFbGVtZW50JywgWzg3MTJdXSwgWydlbGludGVycycsIFs5MTkxXV0sIFsnZWxsJywgWzg0NjddXSwgWydlbHMnLCBbMTA5MDFdXSwgWydlbHNkb3QnLCBbMTA5MDNdXSwgWydFbWFjcicsIFsyNzRdXSwgWydlbWFjcicsIFsyNzVdXSwgWydlbXB0eScsIFs4NzA5XV0sIFsnZW1wdHlzZXQnLCBbODcwOV1dLCBbJ0VtcHR5U21hbGxTcXVhcmUnLCBbOTcyM11dLCBbJ2VtcHR5dicsIFs4NzA5XV0sIFsnRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCBbOTY0M11dLCBbJ2Vtc3AxMycsIFs4MTk2XV0sIFsnZW1zcDE0JywgWzgxOTddXSwgWydlbXNwJywgWzgxOTVdXSwgWydFTkcnLCBbMzMwXV0sIFsnZW5nJywgWzMzMV1dLCBbJ2Vuc3AnLCBbODE5NF1dLCBbJ0VvZ29uJywgWzI4MF1dLCBbJ2VvZ29uJywgWzI4MV1dLCBbJ0VvcGYnLCBbMTIwMTI0XV0sIFsnZW9wZicsIFsxMjAxNTBdXSwgWydlcGFyJywgWzg5MTddXSwgWydlcGFyc2wnLCBbMTA3MjNdXSwgWydlcGx1cycsIFsxMDg2NV1dLCBbJ2Vwc2knLCBbOTQ5XV0sIFsnRXBzaWxvbicsIFs5MTddXSwgWydlcHNpbG9uJywgWzk0OV1dLCBbJ2Vwc2l2JywgWzEwMTNdXSwgWydlcWNpcmMnLCBbODc5MF1dLCBbJ2VxY29sb24nLCBbODc4OV1dLCBbJ2Vxc2ltJywgWzg3NzBdXSwgWydlcXNsYW50Z3RyJywgWzEwOTAyXV0sIFsnZXFzbGFudGxlc3MnLCBbMTA5MDFdXSwgWydFcXVhbCcsIFsxMDg2OV1dLCBbJ2VxdWFscycsIFs2MV1dLCBbJ0VxdWFsVGlsZGUnLCBbODc3MF1dLCBbJ2VxdWVzdCcsIFs4Nzk5XV0sIFsnRXF1aWxpYnJpdW0nLCBbODY1Ml1dLCBbJ2VxdWl2JywgWzg4MDFdXSwgWydlcXVpdkREJywgWzEwODcyXV0sIFsnZXF2cGFyc2wnLCBbMTA3MjVdXSwgWydlcmFycicsIFsxMDYwOV1dLCBbJ2VyRG90JywgWzg3ODddXSwgWydlc2NyJywgWzg0OTVdXSwgWydFc2NyJywgWzg0OTZdXSwgWydlc2RvdCcsIFs4Nzg0XV0sIFsnRXNpbScsIFsxMDg2N11dLCBbJ2VzaW0nLCBbODc3MF1dLCBbJ0V0YScsIFs5MTldXSwgWydldGEnLCBbOTUxXV0sIFsnRVRIJywgWzIwOF1dLCBbJ2V0aCcsIFsyNDBdXSwgWydFdW1sJywgWzIwM11dLCBbJ2V1bWwnLCBbMjM1XV0sIFsnZXVybycsIFs4MzY0XV0sIFsnZXhjbCcsIFszM11dLCBbJ2V4aXN0JywgWzg3MDddXSwgWydFeGlzdHMnLCBbODcwN11dLCBbJ2V4cGVjdGF0aW9uJywgWzg0OTZdXSwgWydleHBvbmVudGlhbGUnLCBbODUxOV1dLCBbJ0V4cG9uZW50aWFsRScsIFs4NTE5XV0sIFsnZmFsbGluZ2RvdHNlcScsIFs4Nzg2XV0sIFsnRmN5JywgWzEwNjBdXSwgWydmY3knLCBbMTA5Ml1dLCBbJ2ZlbWFsZScsIFs5NzkyXV0sIFsnZmZpbGlnJywgWzY0MjU5XV0sIFsnZmZsaWcnLCBbNjQyNTZdXSwgWydmZmxsaWcnLCBbNjQyNjBdXSwgWydGZnInLCBbMTIwMDczXV0sIFsnZmZyJywgWzEyMDA5OV1dLCBbJ2ZpbGlnJywgWzY0MjU3XV0sIFsnRmlsbGVkU21hbGxTcXVhcmUnLCBbOTcyNF1dLCBbJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZScsIFs5NjQyXV0sIFsnZmpsaWcnLCBbMTAyLCAxMDZdXSwgWydmbGF0JywgWzk4MzddXSwgWydmbGxpZycsIFs2NDI1OF1dLCBbJ2ZsdG5zJywgWzk2NDldXSwgWydmbm9mJywgWzQwMl1dLCBbJ0ZvcGYnLCBbMTIwMTI1XV0sIFsnZm9wZicsIFsxMjAxNTFdXSwgWydmb3JhbGwnLCBbODcwNF1dLCBbJ0ZvckFsbCcsIFs4NzA0XV0sIFsnZm9yaycsIFs4OTE2XV0sIFsnZm9ya3YnLCBbMTA5NjldXSwgWydGb3VyaWVydHJmJywgWzg0OTddXSwgWydmcGFydGludCcsIFsxMDc2NV1dLCBbJ2ZyYWMxMicsIFsxODldXSwgWydmcmFjMTMnLCBbODUzMV1dLCBbJ2ZyYWMxNCcsIFsxODhdXSwgWydmcmFjMTUnLCBbODUzM11dLCBbJ2ZyYWMxNicsIFs4NTM3XV0sIFsnZnJhYzE4JywgWzg1MzldXSwgWydmcmFjMjMnLCBbODUzMl1dLCBbJ2ZyYWMyNScsIFs4NTM0XV0sIFsnZnJhYzM0JywgWzE5MF1dLCBbJ2ZyYWMzNScsIFs4NTM1XV0sIFsnZnJhYzM4JywgWzg1NDBdXSwgWydmcmFjNDUnLCBbODUzNl1dLCBbJ2ZyYWM1NicsIFs4NTM4XV0sIFsnZnJhYzU4JywgWzg1NDFdXSwgWydmcmFjNzgnLCBbODU0Ml1dLCBbJ2ZyYXNsJywgWzgyNjBdXSwgWydmcm93bicsIFs4OTk0XV0sIFsnZnNjcicsIFsxMTk5OTVdXSwgWydGc2NyJywgWzg0OTddXSwgWydnYWN1dGUnLCBbNTAxXV0sIFsnR2FtbWEnLCBbOTE1XV0sIFsnZ2FtbWEnLCBbOTQ3XV0sIFsnR2FtbWFkJywgWzk4OF1dLCBbJ2dhbW1hZCcsIFs5ODldXSwgWydnYXAnLCBbMTA4ODZdXSwgWydHYnJldmUnLCBbMjg2XV0sIFsnZ2JyZXZlJywgWzI4N11dLCBbJ0djZWRpbCcsIFsyOTBdXSwgWydHY2lyYycsIFsyODRdXSwgWydnY2lyYycsIFsyODVdXSwgWydHY3knLCBbMTA0M11dLCBbJ2djeScsIFsxMDc1XV0sIFsnR2RvdCcsIFsyODhdXSwgWydnZG90JywgWzI4OV1dLCBbJ2dlJywgWzg4MDVdXSwgWydnRScsIFs4ODA3XV0sIFsnZ0VsJywgWzEwODkyXV0sIFsnZ2VsJywgWzg5MjNdXSwgWydnZXEnLCBbODgwNV1dLCBbJ2dlcXEnLCBbODgwN11dLCBbJ2dlcXNsYW50JywgWzEwODc4XV0sIFsnZ2VzY2MnLCBbMTA5MjFdXSwgWydnZXMnLCBbMTA4NzhdXSwgWydnZXNkb3QnLCBbMTA4ODBdXSwgWydnZXNkb3RvJywgWzEwODgyXV0sIFsnZ2VzZG90b2wnLCBbMTA4ODRdXSwgWydnZXNsJywgWzg5MjMsIDY1MDI0XV0sIFsnZ2VzbGVzJywgWzEwOTAwXV0sIFsnR2ZyJywgWzEyMDA3NF1dLCBbJ2dmcicsIFsxMjAxMDBdXSwgWydnZycsIFs4ODExXV0sIFsnR2cnLCBbODkyMV1dLCBbJ2dnZycsIFs4OTIxXV0sIFsnZ2ltZWwnLCBbODUwM11dLCBbJ0dKY3knLCBbMTAyN11dLCBbJ2dqY3knLCBbMTEwN11dLCBbJ2dsYScsIFsxMDkxN11dLCBbJ2dsJywgWzg4MjNdXSwgWydnbEUnLCBbMTA4OThdXSwgWydnbGonLCBbMTA5MTZdXSwgWydnbmFwJywgWzEwODkwXV0sIFsnZ25hcHByb3gnLCBbMTA4OTBdXSwgWydnbmUnLCBbMTA4ODhdXSwgWydnbkUnLCBbODgwOV1dLCBbJ2duZXEnLCBbMTA4ODhdXSwgWydnbmVxcScsIFs4ODA5XV0sIFsnZ25zaW0nLCBbODkzNV1dLCBbJ0dvcGYnLCBbMTIwMTI2XV0sIFsnZ29wZicsIFsxMjAxNTJdXSwgWydncmF2ZScsIFs5Nl1dLCBbJ0dyZWF0ZXJFcXVhbCcsIFs4ODA1XV0sIFsnR3JlYXRlckVxdWFsTGVzcycsIFs4OTIzXV0sIFsnR3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3XV0sIFsnR3JlYXRlckdyZWF0ZXInLCBbMTA5MTRdXSwgWydHcmVhdGVyTGVzcycsIFs4ODIzXV0sIFsnR3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzhdXSwgWydHcmVhdGVyVGlsZGUnLCBbODgxOV1dLCBbJ0dzY3InLCBbMTE5OTcwXV0sIFsnZ3NjcicsIFs4NDU4XV0sIFsnZ3NpbScsIFs4ODE5XV0sIFsnZ3NpbWUnLCBbMTA4OTRdXSwgWydnc2ltbCcsIFsxMDg5Nl1dLCBbJ2d0Y2MnLCBbMTA5MTldXSwgWydndGNpcicsIFsxMDg3NF1dLCBbJ2d0JywgWzYyXV0sIFsnR1QnLCBbNjJdXSwgWydHdCcsIFs4ODExXV0sIFsnZ3Rkb3QnLCBbODkxOV1dLCBbJ2d0bFBhcicsIFsxMDY0NV1dLCBbJ2d0cXVlc3QnLCBbMTA4NzZdXSwgWydndHJhcHByb3gnLCBbMTA4ODZdXSwgWydndHJhcnInLCBbMTA2MTZdXSwgWydndHJkb3QnLCBbODkxOV1dLCBbJ2d0cmVxbGVzcycsIFs4OTIzXV0sIFsnZ3RyZXFxbGVzcycsIFsxMDg5Ml1dLCBbJ2d0cmxlc3MnLCBbODgyM11dLCBbJ2d0cnNpbScsIFs4ODE5XV0sIFsnZ3ZlcnRuZXFxJywgWzg4MDksIDY1MDI0XV0sIFsnZ3ZuRScsIFs4ODA5LCA2NTAyNF1dLCBbJ0hhY2VrJywgWzcxMV1dLCBbJ2hhaXJzcCcsIFs4MjAyXV0sIFsnaGFsZicsIFsxODldXSwgWydoYW1pbHQnLCBbODQ1OV1dLCBbJ0hBUkRjeScsIFsxMDY2XV0sIFsnaGFyZGN5JywgWzEwOThdXSwgWydoYXJyY2lyJywgWzEwNTY4XV0sIFsnaGFycicsIFs4NTk2XV0sIFsnaEFycicsIFs4NjYwXV0sIFsnaGFycncnLCBbODYyMV1dLCBbJ0hhdCcsIFs5NF1dLCBbJ2hiYXInLCBbODQ2M11dLCBbJ0hjaXJjJywgWzI5Ml1dLCBbJ2hjaXJjJywgWzI5M11dLCBbJ2hlYXJ0cycsIFs5ODI5XV0sIFsnaGVhcnRzdWl0JywgWzk4MjldXSwgWydoZWxsaXAnLCBbODIzMF1dLCBbJ2hlcmNvbicsIFs4ODg5XV0sIFsnaGZyJywgWzEyMDEwMV1dLCBbJ0hmcicsIFs4NDYwXV0sIFsnSGlsYmVydFNwYWNlJywgWzg0NTldXSwgWydoa3NlYXJvdycsIFsxMDUzM11dLCBbJ2hrc3dhcm93JywgWzEwNTM0XV0sIFsnaG9hcnInLCBbODcwM11dLCBbJ2hvbXRodCcsIFs4NzYzXV0sIFsnaG9va2xlZnRhcnJvdycsIFs4NjE3XV0sIFsnaG9va3JpZ2h0YXJyb3cnLCBbODYxOF1dLCBbJ2hvcGYnLCBbMTIwMTUzXV0sIFsnSG9wZicsIFs4NDYxXV0sIFsnaG9yYmFyJywgWzgyMTNdXSwgWydIb3Jpem9udGFsTGluZScsIFs5NDcyXV0sIFsnaHNjcicsIFsxMTk5OTddXSwgWydIc2NyJywgWzg0NTldXSwgWydoc2xhc2gnLCBbODQ2M11dLCBbJ0hzdHJvaycsIFsyOTRdXSwgWydoc3Ryb2snLCBbMjk1XV0sIFsnSHVtcERvd25IdW1wJywgWzg3ODJdXSwgWydIdW1wRXF1YWwnLCBbODc4M11dLCBbJ2h5YnVsbCcsIFs4MjU5XV0sIFsnaHlwaGVuJywgWzgyMDhdXSwgWydJYWN1dGUnLCBbMjA1XV0sIFsnaWFjdXRlJywgWzIzN11dLCBbJ2ljJywgWzgyOTFdXSwgWydJY2lyYycsIFsyMDZdXSwgWydpY2lyYycsIFsyMzhdXSwgWydJY3knLCBbMTA0OF1dLCBbJ2ljeScsIFsxMDgwXV0sIFsnSWRvdCcsIFszMDRdXSwgWydJRWN5JywgWzEwNDVdXSwgWydpZWN5JywgWzEwNzddXSwgWydpZXhjbCcsIFsxNjFdXSwgWydpZmYnLCBbODY2MF1dLCBbJ2lmcicsIFsxMjAxMDJdXSwgWydJZnInLCBbODQ2NV1dLCBbJ0lncmF2ZScsIFsyMDRdXSwgWydpZ3JhdmUnLCBbMjM2XV0sIFsnaWknLCBbODUyMF1dLCBbJ2lpaWludCcsIFsxMDc2NF1dLCBbJ2lpaW50JywgWzg3NDldXSwgWydpaW5maW4nLCBbMTA3MTZdXSwgWydpaW90YScsIFs4NDg5XV0sIFsnSUpsaWcnLCBbMzA2XV0sIFsnaWpsaWcnLCBbMzA3XV0sIFsnSW1hY3InLCBbMjk4XV0sIFsnaW1hY3InLCBbMjk5XV0sIFsnaW1hZ2UnLCBbODQ2NV1dLCBbJ0ltYWdpbmFyeUknLCBbODUyMF1dLCBbJ2ltYWdsaW5lJywgWzg0NjRdXSwgWydpbWFncGFydCcsIFs4NDY1XV0sIFsnaW1hdGgnLCBbMzA1XV0sIFsnSW0nLCBbODQ2NV1dLCBbJ2ltb2YnLCBbODg4N11dLCBbJ2ltcGVkJywgWzQzN11dLCBbJ0ltcGxpZXMnLCBbODY1OF1dLCBbJ2luY2FyZScsIFs4NDUzXV0sIFsnaW4nLCBbODcxMl1dLCBbJ2luZmluJywgWzg3MzRdXSwgWydpbmZpbnRpZScsIFsxMDcxN11dLCBbJ2lub2RvdCcsIFszMDVdXSwgWydpbnRjYWwnLCBbODg5MF1dLCBbJ2ludCcsIFs4NzQ3XV0sIFsnSW50JywgWzg3NDhdXSwgWydpbnRlZ2VycycsIFs4NDg0XV0sIFsnSW50ZWdyYWwnLCBbODc0N11dLCBbJ2ludGVyY2FsJywgWzg4OTBdXSwgWydJbnRlcnNlY3Rpb24nLCBbODg5OF1dLCBbJ2ludGxhcmhrJywgWzEwNzc1XV0sIFsnaW50cHJvZCcsIFsxMDgxMl1dLCBbJ0ludmlzaWJsZUNvbW1hJywgWzgyOTFdXSwgWydJbnZpc2libGVUaW1lcycsIFs4MjkwXV0sIFsnSU9jeScsIFsxMDI1XV0sIFsnaW9jeScsIFsxMTA1XV0sIFsnSW9nb24nLCBbMzAyXV0sIFsnaW9nb24nLCBbMzAzXV0sIFsnSW9wZicsIFsxMjAxMjhdXSwgWydpb3BmJywgWzEyMDE1NF1dLCBbJ0lvdGEnLCBbOTIxXV0sIFsnaW90YScsIFs5NTNdXSwgWydpcHJvZCcsIFsxMDgxMl1dLCBbJ2lxdWVzdCcsIFsxOTFdXSwgWydpc2NyJywgWzExOTk5OF1dLCBbJ0lzY3InLCBbODQ2NF1dLCBbJ2lzaW4nLCBbODcxMl1dLCBbJ2lzaW5kb3QnLCBbODk0OV1dLCBbJ2lzaW5FJywgWzg5NTNdXSwgWydpc2lucycsIFs4OTQ4XV0sIFsnaXNpbnN2JywgWzg5NDddXSwgWydpc2ludicsIFs4NzEyXV0sIFsnaXQnLCBbODI5MF1dLCBbJ0l0aWxkZScsIFsyOTZdXSwgWydpdGlsZGUnLCBbMjk3XV0sIFsnSXVrY3knLCBbMTAzMF1dLCBbJ2l1a2N5JywgWzExMTBdXSwgWydJdW1sJywgWzIwN11dLCBbJ2l1bWwnLCBbMjM5XV0sIFsnSmNpcmMnLCBbMzA4XV0sIFsnamNpcmMnLCBbMzA5XV0sIFsnSmN5JywgWzEwNDldXSwgWydqY3knLCBbMTA4MV1dLCBbJ0pmcicsIFsxMjAwNzddXSwgWydqZnInLCBbMTIwMTAzXV0sIFsnam1hdGgnLCBbNTY3XV0sIFsnSm9wZicsIFsxMjAxMjldXSwgWydqb3BmJywgWzEyMDE1NV1dLCBbJ0pzY3InLCBbMTE5OTczXV0sIFsnanNjcicsIFsxMTk5OTldXSwgWydKc2VyY3knLCBbMTAzMl1dLCBbJ2pzZXJjeScsIFsxMTEyXV0sIFsnSnVrY3knLCBbMTAyOF1dLCBbJ2p1a2N5JywgWzExMDhdXSwgWydLYXBwYScsIFs5MjJdXSwgWydrYXBwYScsIFs5NTRdXSwgWydrYXBwYXYnLCBbMTAwOF1dLCBbJ0tjZWRpbCcsIFszMTBdXSwgWydrY2VkaWwnLCBbMzExXV0sIFsnS2N5JywgWzEwNTBdXSwgWydrY3knLCBbMTA4Ml1dLCBbJ0tmcicsIFsxMjAwNzhdXSwgWydrZnInLCBbMTIwMTA0XV0sIFsna2dyZWVuJywgWzMxMl1dLCBbJ0tIY3knLCBbMTA2MV1dLCBbJ2toY3knLCBbMTA5M11dLCBbJ0tKY3knLCBbMTAzNl1dLCBbJ2tqY3knLCBbMTExNl1dLCBbJ0tvcGYnLCBbMTIwMTMwXV0sIFsna29wZicsIFsxMjAxNTZdXSwgWydLc2NyJywgWzExOTk3NF1dLCBbJ2tzY3InLCBbMTIwMDAwXV0sIFsnbEFhcnInLCBbODY2Nl1dLCBbJ0xhY3V0ZScsIFszMTNdXSwgWydsYWN1dGUnLCBbMzE0XV0sIFsnbGFlbXB0eXYnLCBbMTA2NzZdXSwgWydsYWdyYW4nLCBbODQ2Nl1dLCBbJ0xhbWJkYScsIFs5MjNdXSwgWydsYW1iZGEnLCBbOTU1XV0sIFsnbGFuZycsIFsxMDIxNl1dLCBbJ0xhbmcnLCBbMTAyMThdXSwgWydsYW5nZCcsIFsxMDY0MV1dLCBbJ2xhbmdsZScsIFsxMDIxNl1dLCBbJ2xhcCcsIFsxMDg4NV1dLCBbJ0xhcGxhY2V0cmYnLCBbODQ2Nl1dLCBbJ2xhcXVvJywgWzE3MV1dLCBbJ2xhcnJiJywgWzg2NzZdXSwgWydsYXJyYmZzJywgWzEwNTI3XV0sIFsnbGFycicsIFs4NTkyXV0sIFsnTGFycicsIFs4NjA2XV0sIFsnbEFycicsIFs4NjU2XV0sIFsnbGFycmZzJywgWzEwNTI1XV0sIFsnbGFycmhrJywgWzg2MTddXSwgWydsYXJybHAnLCBbODYxOV1dLCBbJ2xhcnJwbCcsIFsxMDU1M11dLCBbJ2xhcnJzaW0nLCBbMTA2MTFdXSwgWydsYXJydGwnLCBbODYxMF1dLCBbJ2xhdGFpbCcsIFsxMDUyMV1dLCBbJ2xBdGFpbCcsIFsxMDUyM11dLCBbJ2xhdCcsIFsxMDkyM11dLCBbJ2xhdGUnLCBbMTA5MjVdXSwgWydsYXRlcycsIFsxMDkyNSwgNjUwMjRdXSwgWydsYmFycicsIFsxMDUwOF1dLCBbJ2xCYXJyJywgWzEwNTEwXV0sIFsnbGJicmsnLCBbMTAwOThdXSwgWydsYnJhY2UnLCBbMTIzXV0sIFsnbGJyYWNrJywgWzkxXV0sIFsnbGJya2UnLCBbMTA2MzVdXSwgWydsYnJrc2xkJywgWzEwNjM5XV0sIFsnbGJya3NsdScsIFsxMDYzN11dLCBbJ0xjYXJvbicsIFszMTddXSwgWydsY2Fyb24nLCBbMzE4XV0sIFsnTGNlZGlsJywgWzMxNV1dLCBbJ2xjZWRpbCcsIFszMTZdXSwgWydsY2VpbCcsIFs4OTY4XV0sIFsnbGN1YicsIFsxMjNdXSwgWydMY3knLCBbMTA1MV1dLCBbJ2xjeScsIFsxMDgzXV0sIFsnbGRjYScsIFsxMDU1MF1dLCBbJ2xkcXVvJywgWzgyMjBdXSwgWydsZHF1b3InLCBbODIyMl1dLCBbJ2xkcmRoYXInLCBbMTA1OTldXSwgWydsZHJ1c2hhcicsIFsxMDU3MV1dLCBbJ2xkc2gnLCBbODYyNl1dLCBbJ2xlJywgWzg4MDRdXSwgWydsRScsIFs4ODA2XV0sIFsnTGVmdEFuZ2xlQnJhY2tldCcsIFsxMDIxNl1dLCBbJ0xlZnRBcnJvd0JhcicsIFs4Njc2XV0sIFsnbGVmdGFycm93JywgWzg1OTJdXSwgWydMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRhcnJvdycsIFs4NjU2XV0sIFsnTGVmdEFycm93UmlnaHRBcnJvdycsIFs4NjQ2XV0sIFsnbGVmdGFycm93dGFpbCcsIFs4NjEwXV0sIFsnTGVmdENlaWxpbmcnLCBbODk2OF1dLCBbJ0xlZnREb3VibGVCcmFja2V0JywgWzEwMjE0XV0sIFsnTGVmdERvd25UZWVWZWN0b3InLCBbMTA1OTNdXSwgWydMZWZ0RG93blZlY3RvckJhcicsIFsxMDU4NV1dLCBbJ0xlZnREb3duVmVjdG9yJywgWzg2NDNdXSwgWydMZWZ0Rmxvb3InLCBbODk3MF1dLCBbJ2xlZnRoYXJwb29uZG93bicsIFs4NjM3XV0sIFsnbGVmdGhhcnBvb251cCcsIFs4NjM2XV0sIFsnbGVmdGxlZnRhcnJvd3MnLCBbODY0N11dLCBbJ2xlZnRyaWdodGFycm93JywgWzg1OTZdXSwgWydMZWZ0UmlnaHRBcnJvdycsIFs4NTk2XV0sIFsnTGVmdHJpZ2h0YXJyb3cnLCBbODY2MF1dLCBbJ2xlZnRyaWdodGFycm93cycsIFs4NjQ2XV0sIFsnbGVmdHJpZ2h0aGFycG9vbnMnLCBbODY1MV1dLCBbJ2xlZnRyaWdodHNxdWlnYXJyb3cnLCBbODYyMV1dLCBbJ0xlZnRSaWdodFZlY3RvcicsIFsxMDU3NF1dLCBbJ0xlZnRUZWVBcnJvdycsIFs4NjEyXV0sIFsnTGVmdFRlZScsIFs4ODY3XV0sIFsnTGVmdFRlZVZlY3RvcicsIFsxMDU4Nl1dLCBbJ2xlZnR0aHJlZXRpbWVzJywgWzg5MDddXSwgWydMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDNdXSwgWydMZWZ0VHJpYW5nbGUnLCBbODg4Ml1dLCBbJ0xlZnRUcmlhbmdsZUVxdWFsJywgWzg4ODRdXSwgWydMZWZ0VXBEb3duVmVjdG9yJywgWzEwNTc3XV0sIFsnTGVmdFVwVGVlVmVjdG9yJywgWzEwNTkyXV0sIFsnTGVmdFVwVmVjdG9yQmFyJywgWzEwNTg0XV0sIFsnTGVmdFVwVmVjdG9yJywgWzg2MzldXSwgWydMZWZ0VmVjdG9yQmFyJywgWzEwNTc4XV0sIFsnTGVmdFZlY3RvcicsIFs4NjM2XV0sIFsnbEVnJywgWzEwODkxXV0sIFsnbGVnJywgWzg5MjJdXSwgWydsZXEnLCBbODgwNF1dLCBbJ2xlcXEnLCBbODgwNl1dLCBbJ2xlcXNsYW50JywgWzEwODc3XV0sIFsnbGVzY2MnLCBbMTA5MjBdXSwgWydsZXMnLCBbMTA4NzddXSwgWydsZXNkb3QnLCBbMTA4NzldXSwgWydsZXNkb3RvJywgWzEwODgxXV0sIFsnbGVzZG90b3InLCBbMTA4ODNdXSwgWydsZXNnJywgWzg5MjIsIDY1MDI0XV0sIFsnbGVzZ2VzJywgWzEwODk5XV0sIFsnbGVzc2FwcHJveCcsIFsxMDg4NV1dLCBbJ2xlc3Nkb3QnLCBbODkxOF1dLCBbJ2xlc3NlcWd0cicsIFs4OTIyXV0sIFsnbGVzc2VxcWd0cicsIFsxMDg5MV1dLCBbJ0xlc3NFcXVhbEdyZWF0ZXInLCBbODkyMl1dLCBbJ0xlc3NGdWxsRXF1YWwnLCBbODgwNl1dLCBbJ0xlc3NHcmVhdGVyJywgWzg4MjJdXSwgWydsZXNzZ3RyJywgWzg4MjJdXSwgWydMZXNzTGVzcycsIFsxMDkxM11dLCBbJ2xlc3NzaW0nLCBbODgxOF1dLCBbJ0xlc3NTbGFudEVxdWFsJywgWzEwODc3XV0sIFsnTGVzc1RpbGRlJywgWzg4MThdXSwgWydsZmlzaHQnLCBbMTA2MjBdXSwgWydsZmxvb3InLCBbODk3MF1dLCBbJ0xmcicsIFsxMjAwNzldXSwgWydsZnInLCBbMTIwMTA1XV0sIFsnbGcnLCBbODgyMl1dLCBbJ2xnRScsIFsxMDg5N11dLCBbJ2xIYXInLCBbMTA1OTRdXSwgWydsaGFyZCcsIFs4NjM3XV0sIFsnbGhhcnUnLCBbODYzNl1dLCBbJ2xoYXJ1bCcsIFsxMDYwMl1dLCBbJ2xoYmxrJywgWzk2MDRdXSwgWydMSmN5JywgWzEwMzNdXSwgWydsamN5JywgWzExMTNdXSwgWydsbGFycicsIFs4NjQ3XV0sIFsnbGwnLCBbODgxMF1dLCBbJ0xsJywgWzg5MjBdXSwgWydsbGNvcm5lcicsIFs4OTkwXV0sIFsnTGxlZnRhcnJvdycsIFs4NjY2XV0sIFsnbGxoYXJkJywgWzEwNjAzXV0sIFsnbGx0cmknLCBbOTcyMl1dLCBbJ0xtaWRvdCcsIFszMTldXSwgWydsbWlkb3QnLCBbMzIwXV0sIFsnbG1vdXN0YWNoZScsIFs5MTM2XV0sIFsnbG1vdXN0JywgWzkxMzZdXSwgWydsbmFwJywgWzEwODg5XV0sIFsnbG5hcHByb3gnLCBbMTA4ODldXSwgWydsbmUnLCBbMTA4ODddXSwgWydsbkUnLCBbODgwOF1dLCBbJ2xuZXEnLCBbMTA4ODddXSwgWydsbmVxcScsIFs4ODA4XV0sIFsnbG5zaW0nLCBbODkzNF1dLCBbJ2xvYW5nJywgWzEwMjIwXV0sIFsnbG9hcnInLCBbODcwMV1dLCBbJ2xvYnJrJywgWzEwMjE0XV0sIFsnbG9uZ2xlZnRhcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdMZWZ0QXJyb3cnLCBbMTAyMjldXSwgWydMb25nbGVmdGFycm93JywgWzEwMjMyXV0sIFsnbG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjMxXV0sIFsnTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjMxXV0sIFsnTG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjM0XV0sIFsnbG9uZ21hcHN0bycsIFsxMDIzNl1dLCBbJ2xvbmdyaWdodGFycm93JywgWzEwMjMwXV0sIFsnTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzBdXSwgWydMb25ncmlnaHRhcnJvdycsIFsxMDIzM11dLCBbJ2xvb3BhcnJvd2xlZnQnLCBbODYxOV1dLCBbJ2xvb3BhcnJvd3JpZ2h0JywgWzg2MjBdXSwgWydsb3BhcicsIFsxMDYyOV1dLCBbJ0xvcGYnLCBbMTIwMTMxXV0sIFsnbG9wZicsIFsxMjAxNTddXSwgWydsb3BsdXMnLCBbMTA3OTddXSwgWydsb3RpbWVzJywgWzEwODA0XV0sIFsnbG93YXN0JywgWzg3MjddXSwgWydsb3diYXInLCBbOTVdXSwgWydMb3dlckxlZnRBcnJvdycsIFs4NjAxXV0sIFsnTG93ZXJSaWdodEFycm93JywgWzg2MDBdXSwgWydsb3onLCBbOTY3NF1dLCBbJ2xvemVuZ2UnLCBbOTY3NF1dLCBbJ2xvemYnLCBbMTA3MzFdXSwgWydscGFyJywgWzQwXV0sIFsnbHBhcmx0JywgWzEwNjQzXV0sIFsnbHJhcnInLCBbODY0Nl1dLCBbJ2xyY29ybmVyJywgWzg5OTFdXSwgWydscmhhcicsIFs4NjUxXV0sIFsnbHJoYXJkJywgWzEwNjA1XV0sIFsnbHJtJywgWzgyMDZdXSwgWydscnRyaScsIFs4ODk1XV0sIFsnbHNhcXVvJywgWzgyNDldXSwgWydsc2NyJywgWzEyMDAwMV1dLCBbJ0xzY3InLCBbODQ2Nl1dLCBbJ2xzaCcsIFs4NjI0XV0sIFsnTHNoJywgWzg2MjRdXSwgWydsc2ltJywgWzg4MThdXSwgWydsc2ltZScsIFsxMDg5M11dLCBbJ2xzaW1nJywgWzEwODk1XV0sIFsnbHNxYicsIFs5MV1dLCBbJ2xzcXVvJywgWzgyMTZdXSwgWydsc3F1b3InLCBbODIxOF1dLCBbJ0xzdHJvaycsIFszMjFdXSwgWydsc3Ryb2snLCBbMzIyXV0sIFsnbHRjYycsIFsxMDkxOF1dLCBbJ2x0Y2lyJywgWzEwODczXV0sIFsnbHQnLCBbNjBdXSwgWydMVCcsIFs2MF1dLCBbJ0x0JywgWzg4MTBdXSwgWydsdGRvdCcsIFs4OTE4XV0sIFsnbHRocmVlJywgWzg5MDddXSwgWydsdGltZXMnLCBbODkwNV1dLCBbJ2x0bGFycicsIFsxMDYxNF1dLCBbJ2x0cXVlc3QnLCBbMTA4NzVdXSwgWydsdHJpJywgWzk2NjddXSwgWydsdHJpZScsIFs4ODg0XV0sIFsnbHRyaWYnLCBbOTY2Nl1dLCBbJ2x0clBhcicsIFsxMDY0Nl1dLCBbJ2x1cmRzaGFyJywgWzEwNTcwXV0sIFsnbHVydWhhcicsIFsxMDU5OF1dLCBbJ2x2ZXJ0bmVxcScsIFs4ODA4LCA2NTAyNF1dLCBbJ2x2bkUnLCBbODgwOCwgNjUwMjRdXSwgWydtYWNyJywgWzE3NV1dLCBbJ21hbGUnLCBbOTc5NF1dLCBbJ21hbHQnLCBbMTAwMTZdXSwgWydtYWx0ZXNlJywgWzEwMDE2XV0sIFsnTWFwJywgWzEwNTAxXV0sIFsnbWFwJywgWzg2MTRdXSwgWydtYXBzdG8nLCBbODYxNF1dLCBbJ21hcHN0b2Rvd24nLCBbODYxNV1dLCBbJ21hcHN0b2xlZnQnLCBbODYxMl1dLCBbJ21hcHN0b3VwJywgWzg2MTNdXSwgWydtYXJrZXInLCBbOTY0Nl1dLCBbJ21jb21tYScsIFsxMDc5M11dLCBbJ01jeScsIFsxMDUyXV0sIFsnbWN5JywgWzEwODRdXSwgWydtZGFzaCcsIFs4MjEyXV0sIFsnbUREb3QnLCBbODc2Ml1dLCBbJ21lYXN1cmVkYW5nbGUnLCBbODczN11dLCBbJ01lZGl1bVNwYWNlJywgWzgyODddXSwgWydNZWxsaW50cmYnLCBbODQ5OV1dLCBbJ01mcicsIFsxMjAwODBdXSwgWydtZnInLCBbMTIwMTA2XV0sIFsnbWhvJywgWzg0ODddXSwgWydtaWNybycsIFsxODFdXSwgWydtaWRhc3QnLCBbNDJdXSwgWydtaWRjaXInLCBbMTA5OTJdXSwgWydtaWQnLCBbODczOV1dLCBbJ21pZGRvdCcsIFsxODNdXSwgWydtaW51c2InLCBbODg2M11dLCBbJ21pbnVzJywgWzg3MjJdXSwgWydtaW51c2QnLCBbODc2MF1dLCBbJ21pbnVzZHUnLCBbMTA3OTRdXSwgWydNaW51c1BsdXMnLCBbODcyM11dLCBbJ21sY3AnLCBbMTA5NzFdXSwgWydtbGRyJywgWzgyMzBdXSwgWydtbnBsdXMnLCBbODcyM11dLCBbJ21vZGVscycsIFs4ODcxXV0sIFsnTW9wZicsIFsxMjAxMzJdXSwgWydtb3BmJywgWzEyMDE1OF1dLCBbJ21wJywgWzg3MjNdXSwgWydtc2NyJywgWzEyMDAwMl1dLCBbJ01zY3InLCBbODQ5OV1dLCBbJ21zdHBvcycsIFs4NzY2XV0sIFsnTXUnLCBbOTI0XV0sIFsnbXUnLCBbOTU2XV0sIFsnbXVsdGltYXAnLCBbODg4OF1dLCBbJ211bWFwJywgWzg4ODhdXSwgWyduYWJsYScsIFs4NzExXV0sIFsnTmFjdXRlJywgWzMyM11dLCBbJ25hY3V0ZScsIFszMjRdXSwgWyduYW5nJywgWzg3MzYsIDg0MDJdXSwgWyduYXAnLCBbODc3N11dLCBbJ25hcEUnLCBbMTA4NjQsIDgyNF1dLCBbJ25hcGlkJywgWzg3NzksIDgyNF1dLCBbJ25hcG9zJywgWzMyOV1dLCBbJ25hcHByb3gnLCBbODc3N11dLCBbJ25hdHVyYWwnLCBbOTgzOF1dLCBbJ25hdHVyYWxzJywgWzg0NjldXSwgWyduYXR1cicsIFs5ODM4XV0sIFsnbmJzcCcsIFsxNjBdXSwgWyduYnVtcCcsIFs4NzgyLCA4MjRdXSwgWyduYnVtcGUnLCBbODc4MywgODI0XV0sIFsnbmNhcCcsIFsxMDgxOV1dLCBbJ05jYXJvbicsIFszMjddXSwgWyduY2Fyb24nLCBbMzI4XV0sIFsnTmNlZGlsJywgWzMyNV1dLCBbJ25jZWRpbCcsIFszMjZdXSwgWyduY29uZycsIFs4Nzc1XV0sIFsnbmNvbmdkb3QnLCBbMTA4NjEsIDgyNF1dLCBbJ25jdXAnLCBbMTA4MThdXSwgWydOY3knLCBbMTA1M11dLCBbJ25jeScsIFsxMDg1XV0sIFsnbmRhc2gnLCBbODIxMV1dLCBbJ25lYXJoaycsIFsxMDUzMl1dLCBbJ25lYXJyJywgWzg1OTldXSwgWyduZUFycicsIFs4NjYzXV0sIFsnbmVhcnJvdycsIFs4NTk5XV0sIFsnbmUnLCBbODgwMF1dLCBbJ25lZG90JywgWzg3ODQsIDgyNF1dLCBbJ05lZ2F0aXZlTWVkaXVtU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpY2tTcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGluU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnbmVxdWl2JywgWzg4MDJdXSwgWyduZXNlYXInLCBbMTA1MzZdXSwgWyduZXNpbScsIFs4NzcwLCA4MjRdXSwgWydOZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFs4ODExXV0sIFsnTmVzdGVkTGVzc0xlc3MnLCBbODgxMF1dLCBbJ25leGlzdCcsIFs4NzA4XV0sIFsnbmV4aXN0cycsIFs4NzA4XV0sIFsnTmZyJywgWzEyMDA4MV1dLCBbJ25mcicsIFsxMjAxMDddXSwgWyduZ0UnLCBbODgwNywgODI0XV0sIFsnbmdlJywgWzg4MTddXSwgWyduZ2VxJywgWzg4MTddXSwgWyduZ2VxcScsIFs4ODA3LCA4MjRdXSwgWyduZ2Vxc2xhbnQnLCBbMTA4NzgsIDgyNF1dLCBbJ25nZXMnLCBbMTA4NzgsIDgyNF1dLCBbJ25HZycsIFs4OTIxLCA4MjRdXSwgWyduZ3NpbScsIFs4ODIxXV0sIFsnbkd0JywgWzg4MTEsIDg0MDJdXSwgWyduZ3QnLCBbODgxNV1dLCBbJ25ndHInLCBbODgxNV1dLCBbJ25HdHYnLCBbODgxMSwgODI0XV0sIFsnbmhhcnInLCBbODYyMl1dLCBbJ25oQXJyJywgWzg2NTRdXSwgWyduaHBhcicsIFsxMDk5NF1dLCBbJ25pJywgWzg3MTVdXSwgWyduaXMnLCBbODk1Nl1dLCBbJ25pc2QnLCBbODk1NF1dLCBbJ25pdicsIFs4NzE1XV0sIFsnTkpjeScsIFsxMDM0XV0sIFsnbmpjeScsIFsxMTE0XV0sIFsnbmxhcnInLCBbODYwMl1dLCBbJ25sQXJyJywgWzg2NTNdXSwgWydubGRyJywgWzgyMjldXSwgWydubEUnLCBbODgwNiwgODI0XV0sIFsnbmxlJywgWzg4MTZdXSwgWydubGVmdGFycm93JywgWzg2MDJdXSwgWyduTGVmdGFycm93JywgWzg2NTNdXSwgWydubGVmdHJpZ2h0YXJyb3cnLCBbODYyMl1dLCBbJ25MZWZ0cmlnaHRhcnJvdycsIFs4NjU0XV0sIFsnbmxlcScsIFs4ODE2XV0sIFsnbmxlcXEnLCBbODgwNiwgODI0XV0sIFsnbmxlcXNsYW50JywgWzEwODc3LCA4MjRdXSwgWydubGVzJywgWzEwODc3LCA4MjRdXSwgWydubGVzcycsIFs4ODE0XV0sIFsnbkxsJywgWzg5MjAsIDgyNF1dLCBbJ25sc2ltJywgWzg4MjBdXSwgWyduTHQnLCBbODgxMCwgODQwMl1dLCBbJ25sdCcsIFs4ODE0XV0sIFsnbmx0cmknLCBbODkzOF1dLCBbJ25sdHJpZScsIFs4OTQwXV0sIFsnbkx0dicsIFs4ODEwLCA4MjRdXSwgWydubWlkJywgWzg3NDBdXSwgWydOb0JyZWFrJywgWzgyODhdXSwgWydOb25CcmVha2luZ1NwYWNlJywgWzE2MF1dLCBbJ25vcGYnLCBbMTIwMTU5XV0sIFsnTm9wZicsIFs4NDY5XV0sIFsnTm90JywgWzEwOTg4XV0sIFsnbm90JywgWzE3Ml1dLCBbJ05vdENvbmdydWVudCcsIFs4ODAyXV0sIFsnTm90Q3VwQ2FwJywgWzg4MTNdXSwgWydOb3REb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQyXV0sIFsnTm90RWxlbWVudCcsIFs4NzEzXV0sIFsnTm90RXF1YWwnLCBbODgwMF1dLCBbJ05vdEVxdWFsVGlsZGUnLCBbODc3MCwgODI0XV0sIFsnTm90RXhpc3RzJywgWzg3MDhdXSwgWydOb3RHcmVhdGVyJywgWzg4MTVdXSwgWydOb3RHcmVhdGVyRXF1YWwnLCBbODgxN11dLCBbJ05vdEdyZWF0ZXJGdWxsRXF1YWwnLCBbODgwNywgODI0XV0sIFsnTm90R3JlYXRlckdyZWF0ZXInLCBbODgxMSwgODI0XV0sIFsnTm90R3JlYXRlckxlc3MnLCBbODgyNV1dLCBbJ05vdEdyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4LCA4MjRdXSwgWydOb3RHcmVhdGVyVGlsZGUnLCBbODgyMV1dLCBbJ05vdEh1bXBEb3duSHVtcCcsIFs4NzgyLCA4MjRdXSwgWydOb3RIdW1wRXF1YWwnLCBbODc4MywgODI0XV0sIFsnbm90aW4nLCBbODcxM11dLCBbJ25vdGluZG90JywgWzg5NDksIDgyNF1dLCBbJ25vdGluRScsIFs4OTUzLCA4MjRdXSwgWydub3RpbnZhJywgWzg3MTNdXSwgWydub3RpbnZiJywgWzg5NTFdXSwgWydub3RpbnZjJywgWzg5NTBdXSwgWydOb3RMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDMsIDgyNF1dLCBbJ05vdExlZnRUcmlhbmdsZScsIFs4OTM4XV0sIFsnTm90TGVmdFRyaWFuZ2xlRXF1YWwnLCBbODk0MF1dLCBbJ05vdExlc3MnLCBbODgxNF1dLCBbJ05vdExlc3NFcXVhbCcsIFs4ODE2XV0sIFsnTm90TGVzc0dyZWF0ZXInLCBbODgyNF1dLCBbJ05vdExlc3NMZXNzJywgWzg4MTAsIDgyNF1dLCBbJ05vdExlc3NTbGFudEVxdWFsJywgWzEwODc3LCA4MjRdXSwgWydOb3RMZXNzVGlsZGUnLCBbODgyMF1dLCBbJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzEwOTE0LCA4MjRdXSwgWydOb3ROZXN0ZWRMZXNzTGVzcycsIFsxMDkxMywgODI0XV0sIFsnbm90bmknLCBbODcxNl1dLCBbJ25vdG5pdmEnLCBbODcxNl1dLCBbJ25vdG5pdmInLCBbODk1OF1dLCBbJ25vdG5pdmMnLCBbODk1N11dLCBbJ05vdFByZWNlZGVzJywgWzg4MzJdXSwgWydOb3RQcmVjZWRlc0VxdWFsJywgWzEwOTI3LCA4MjRdXSwgWydOb3RQcmVjZWRlc1NsYW50RXF1YWwnLCBbODkyOF1dLCBbJ05vdFJldmVyc2VFbGVtZW50JywgWzg3MTZdXSwgWydOb3RSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0LCA4MjRdXSwgWydOb3RSaWdodFRyaWFuZ2xlJywgWzg5MzldXSwgWydOb3RSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODk0MV1dLCBbJ05vdFNxdWFyZVN1YnNldCcsIFs4ODQ3LCA4MjRdXSwgWydOb3RTcXVhcmVTdWJzZXRFcXVhbCcsIFs4OTMwXV0sIFsnTm90U3F1YXJlU3VwZXJzZXQnLCBbODg0OCwgODI0XV0sIFsnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4OTMxXV0sIFsnTm90U3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWydOb3RTdWJzZXRFcXVhbCcsIFs4ODQwXV0sIFsnTm90U3VjY2VlZHMnLCBbODgzM11dLCBbJ05vdFN1Y2NlZWRzRXF1YWwnLCBbMTA5MjgsIDgyNF1dLCBbJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4OTI5XV0sIFsnTm90U3VjY2VlZHNUaWxkZScsIFs4ODMxLCA4MjRdXSwgWydOb3RTdXBlcnNldCcsIFs4ODM1LCA4NDAyXV0sIFsnTm90U3VwZXJzZXRFcXVhbCcsIFs4ODQxXV0sIFsnTm90VGlsZGUnLCBbODc2OV1dLCBbJ05vdFRpbGRlRXF1YWwnLCBbODc3Ml1dLCBbJ05vdFRpbGRlRnVsbEVxdWFsJywgWzg3NzVdXSwgWydOb3RUaWxkZVRpbGRlJywgWzg3NzddXSwgWydOb3RWZXJ0aWNhbEJhcicsIFs4NzQwXV0sIFsnbnBhcmFsbGVsJywgWzg3NDJdXSwgWyducGFyJywgWzg3NDJdXSwgWyducGFyc2wnLCBbMTEwMDUsIDg0MjFdXSwgWyducGFydCcsIFs4NzA2LCA4MjRdXSwgWyducG9saW50JywgWzEwNzcyXV0sIFsnbnByJywgWzg4MzJdXSwgWyducHJjdWUnLCBbODkyOF1dLCBbJ25wcmVjJywgWzg4MzJdXSwgWyducHJlY2VxJywgWzEwOTI3LCA4MjRdXSwgWyducHJlJywgWzEwOTI3LCA4MjRdXSwgWyducmFycmMnLCBbMTA1NDcsIDgyNF1dLCBbJ25yYXJyJywgWzg2MDNdXSwgWyduckFycicsIFs4NjU1XV0sIFsnbnJhcnJ3JywgWzg2MDUsIDgyNF1dLCBbJ25yaWdodGFycm93JywgWzg2MDNdXSwgWyduUmlnaHRhcnJvdycsIFs4NjU1XV0sIFsnbnJ0cmknLCBbODkzOV1dLCBbJ25ydHJpZScsIFs4OTQxXV0sIFsnbnNjJywgWzg4MzNdXSwgWyduc2NjdWUnLCBbODkyOV1dLCBbJ25zY2UnLCBbMTA5MjgsIDgyNF1dLCBbJ05zY3InLCBbMTE5OTc3XV0sIFsnbnNjcicsIFsxMjAwMDNdXSwgWyduc2hvcnRtaWQnLCBbODc0MF1dLCBbJ25zaG9ydHBhcmFsbGVsJywgWzg3NDJdXSwgWyduc2ltJywgWzg3NjldXSwgWyduc2ltZScsIFs4NzcyXV0sIFsnbnNpbWVxJywgWzg3NzJdXSwgWyduc21pZCcsIFs4NzQwXV0sIFsnbnNwYXInLCBbODc0Ml1dLCBbJ25zcXN1YmUnLCBbODkzMF1dLCBbJ25zcXN1cGUnLCBbODkzMV1dLCBbJ25zdWInLCBbODgzNl1dLCBbJ25zdWJFJywgWzEwOTQ5LCA4MjRdXSwgWyduc3ViZScsIFs4ODQwXV0sIFsnbnN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnbnN1YnNldGVxJywgWzg4NDBdXSwgWyduc3Vic2V0ZXFxJywgWzEwOTQ5LCA4MjRdXSwgWyduc3VjYycsIFs4ODMzXV0sIFsnbnN1Y2NlcScsIFsxMDkyOCwgODI0XV0sIFsnbnN1cCcsIFs4ODM3XV0sIFsnbnN1cEUnLCBbMTA5NTAsIDgyNF1dLCBbJ25zdXBlJywgWzg4NDFdXSwgWyduc3Vwc2V0JywgWzg4MzUsIDg0MDJdXSwgWyduc3Vwc2V0ZXEnLCBbODg0MV1dLCBbJ25zdXBzZXRlcXEnLCBbMTA5NTAsIDgyNF1dLCBbJ250Z2wnLCBbODgyNV1dLCBbJ050aWxkZScsIFsyMDldXSwgWydudGlsZGUnLCBbMjQxXV0sIFsnbnRsZycsIFs4ODI0XV0sIFsnbnRyaWFuZ2xlbGVmdCcsIFs4OTM4XV0sIFsnbnRyaWFuZ2xlbGVmdGVxJywgWzg5NDBdXSwgWydudHJpYW5nbGVyaWdodCcsIFs4OTM5XV0sIFsnbnRyaWFuZ2xlcmlnaHRlcScsIFs4OTQxXV0sIFsnTnUnLCBbOTI1XV0sIFsnbnUnLCBbOTU3XV0sIFsnbnVtJywgWzM1XV0sIFsnbnVtZXJvJywgWzg0NzBdXSwgWydudW1zcCcsIFs4MTk5XV0sIFsnbnZhcCcsIFs4NzgxLCA4NDAyXV0sIFsnbnZkYXNoJywgWzg4NzZdXSwgWydudkRhc2gnLCBbODg3N11dLCBbJ25WZGFzaCcsIFs4ODc4XV0sIFsnblZEYXNoJywgWzg4NzldXSwgWydudmdlJywgWzg4MDUsIDg0MDJdXSwgWydudmd0JywgWzYyLCA4NDAyXV0sIFsnbnZIYXJyJywgWzEwNTAwXV0sIFsnbnZpbmZpbicsIFsxMDcxOF1dLCBbJ252bEFycicsIFsxMDQ5OF1dLCBbJ252bGUnLCBbODgwNCwgODQwMl1dLCBbJ252bHQnLCBbNjAsIDg0MDJdXSwgWydudmx0cmllJywgWzg4ODQsIDg0MDJdXSwgWydudnJBcnInLCBbMTA0OTldXSwgWydudnJ0cmllJywgWzg4ODUsIDg0MDJdXSwgWydudnNpbScsIFs4NzY0LCA4NDAyXV0sIFsnbndhcmhrJywgWzEwNTMxXV0sIFsnbndhcnInLCBbODU5OF1dLCBbJ253QXJyJywgWzg2NjJdXSwgWydud2Fycm93JywgWzg1OThdXSwgWydud25lYXInLCBbMTA1MzVdXSwgWydPYWN1dGUnLCBbMjExXV0sIFsnb2FjdXRlJywgWzI0M11dLCBbJ29hc3QnLCBbODg1OV1dLCBbJ09jaXJjJywgWzIxMl1dLCBbJ29jaXJjJywgWzI0NF1dLCBbJ29jaXInLCBbODg1OF1dLCBbJ09jeScsIFsxMDU0XV0sIFsnb2N5JywgWzEwODZdXSwgWydvZGFzaCcsIFs4ODYxXV0sIFsnT2RibGFjJywgWzMzNl1dLCBbJ29kYmxhYycsIFszMzddXSwgWydvZGl2JywgWzEwODA4XV0sIFsnb2RvdCcsIFs4ODU3XV0sIFsnb2Rzb2xkJywgWzEwNjg0XV0sIFsnT0VsaWcnLCBbMzM4XV0sIFsnb2VsaWcnLCBbMzM5XV0sIFsnb2ZjaXInLCBbMTA2ODddXSwgWydPZnInLCBbMTIwMDgyXV0sIFsnb2ZyJywgWzEyMDEwOF1dLCBbJ29nb24nLCBbNzMxXV0sIFsnT2dyYXZlJywgWzIxMF1dLCBbJ29ncmF2ZScsIFsyNDJdXSwgWydvZ3QnLCBbMTA2ODldXSwgWydvaGJhcicsIFsxMDY3N11dLCBbJ29obScsIFs5MzddXSwgWydvaW50JywgWzg3NTBdXSwgWydvbGFycicsIFs4NjM0XV0sIFsnb2xjaXInLCBbMTA2ODZdXSwgWydvbGNyb3NzJywgWzEwNjgzXV0sIFsnb2xpbmUnLCBbODI1NF1dLCBbJ29sdCcsIFsxMDY4OF1dLCBbJ09tYWNyJywgWzMzMl1dLCBbJ29tYWNyJywgWzMzM11dLCBbJ09tZWdhJywgWzkzN11dLCBbJ29tZWdhJywgWzk2OV1dLCBbJ09taWNyb24nLCBbOTI3XV0sIFsnb21pY3JvbicsIFs5NTldXSwgWydvbWlkJywgWzEwNjc4XV0sIFsnb21pbnVzJywgWzg4NTRdXSwgWydPb3BmJywgWzEyMDEzNF1dLCBbJ29vcGYnLCBbMTIwMTYwXV0sIFsnb3BhcicsIFsxMDY3OV1dLCBbJ09wZW5DdXJseURvdWJsZVF1b3RlJywgWzgyMjBdXSwgWydPcGVuQ3VybHlRdW90ZScsIFs4MjE2XV0sIFsnb3BlcnAnLCBbMTA2ODFdXSwgWydvcGx1cycsIFs4ODUzXV0sIFsnb3JhcnInLCBbODYzNV1dLCBbJ09yJywgWzEwODM2XV0sIFsnb3InLCBbODc0NF1dLCBbJ29yZCcsIFsxMDg0NV1dLCBbJ29yZGVyJywgWzg1MDBdXSwgWydvcmRlcm9mJywgWzg1MDBdXSwgWydvcmRmJywgWzE3MF1dLCBbJ29yZG0nLCBbMTg2XV0sIFsnb3JpZ29mJywgWzg4ODZdXSwgWydvcm9yJywgWzEwODM4XV0sIFsnb3JzbG9wZScsIFsxMDgzOV1dLCBbJ29ydicsIFsxMDg0M11dLCBbJ29TJywgWzk0MTZdXSwgWydPc2NyJywgWzExOTk3OF1dLCBbJ29zY3InLCBbODUwMF1dLCBbJ09zbGFzaCcsIFsyMTZdXSwgWydvc2xhc2gnLCBbMjQ4XV0sIFsnb3NvbCcsIFs4ODU2XV0sIFsnT3RpbGRlJywgWzIxM11dLCBbJ290aWxkZScsIFsyNDVdXSwgWydvdGltZXNhcycsIFsxMDgwNl1dLCBbJ090aW1lcycsIFsxMDgwN11dLCBbJ290aW1lcycsIFs4ODU1XV0sIFsnT3VtbCcsIFsyMTRdXSwgWydvdW1sJywgWzI0Nl1dLCBbJ292YmFyJywgWzkwMjFdXSwgWydPdmVyQmFyJywgWzgyNTRdXSwgWydPdmVyQnJhY2UnLCBbOTE4Ml1dLCBbJ092ZXJCcmFja2V0JywgWzkxNDBdXSwgWydPdmVyUGFyZW50aGVzaXMnLCBbOTE4MF1dLCBbJ3BhcmEnLCBbMTgyXV0sIFsncGFyYWxsZWwnLCBbODc0MV1dLCBbJ3BhcicsIFs4NzQxXV0sIFsncGFyc2ltJywgWzEwOTk1XV0sIFsncGFyc2wnLCBbMTEwMDVdXSwgWydwYXJ0JywgWzg3MDZdXSwgWydQYXJ0aWFsRCcsIFs4NzA2XV0sIFsnUGN5JywgWzEwNTVdXSwgWydwY3knLCBbMTA4N11dLCBbJ3BlcmNudCcsIFszN11dLCBbJ3BlcmlvZCcsIFs0Nl1dLCBbJ3Blcm1pbCcsIFs4MjQwXV0sIFsncGVycCcsIFs4ODY5XV0sIFsncGVydGVuaycsIFs4MjQxXV0sIFsnUGZyJywgWzEyMDA4M11dLCBbJ3BmcicsIFsxMjAxMDldXSwgWydQaGknLCBbOTM0XV0sIFsncGhpJywgWzk2Nl1dLCBbJ3BoaXYnLCBbOTgxXV0sIFsncGhtbWF0JywgWzg0OTldXSwgWydwaG9uZScsIFs5NzQyXV0sIFsnUGknLCBbOTI4XV0sIFsncGknLCBbOTYwXV0sIFsncGl0Y2hmb3JrJywgWzg5MTZdXSwgWydwaXYnLCBbOTgyXV0sIFsncGxhbmNrJywgWzg0NjNdXSwgWydwbGFuY2toJywgWzg0NjJdXSwgWydwbGFua3YnLCBbODQ2M11dLCBbJ3BsdXNhY2lyJywgWzEwNzg3XV0sIFsncGx1c2InLCBbODg2Ml1dLCBbJ3BsdXNjaXInLCBbMTA3ODZdXSwgWydwbHVzJywgWzQzXV0sIFsncGx1c2RvJywgWzg3MjRdXSwgWydwbHVzZHUnLCBbMTA3ODldXSwgWydwbHVzZScsIFsxMDg2Nl1dLCBbJ1BsdXNNaW51cycsIFsxNzddXSwgWydwbHVzbW4nLCBbMTc3XV0sIFsncGx1c3NpbScsIFsxMDc5MF1dLCBbJ3BsdXN0d28nLCBbMTA3OTFdXSwgWydwbScsIFsxNzddXSwgWydQb2luY2FyZXBsYW5lJywgWzg0NjBdXSwgWydwb2ludGludCcsIFsxMDc3M11dLCBbJ3BvcGYnLCBbMTIwMTYxXV0sIFsnUG9wZicsIFs4NDczXV0sIFsncG91bmQnLCBbMTYzXV0sIFsncHJhcCcsIFsxMDkzNV1dLCBbJ1ByJywgWzEwOTM5XV0sIFsncHInLCBbODgyNl1dLCBbJ3ByY3VlJywgWzg4MjhdXSwgWydwcmVjYXBwcm94JywgWzEwOTM1XV0sIFsncHJlYycsIFs4ODI2XV0sIFsncHJlY2N1cmx5ZXEnLCBbODgyOF1dLCBbJ1ByZWNlZGVzJywgWzg4MjZdXSwgWydQcmVjZWRlc0VxdWFsJywgWzEwOTI3XV0sIFsnUHJlY2VkZXNTbGFudEVxdWFsJywgWzg4MjhdXSwgWydQcmVjZWRlc1RpbGRlJywgWzg4MzBdXSwgWydwcmVjZXEnLCBbMTA5MjddXSwgWydwcmVjbmFwcHJveCcsIFsxMDkzN11dLCBbJ3ByZWNuZXFxJywgWzEwOTMzXV0sIFsncHJlY25zaW0nLCBbODkzNl1dLCBbJ3ByZScsIFsxMDkyN11dLCBbJ3ByRScsIFsxMDkzMV1dLCBbJ3ByZWNzaW0nLCBbODgzMF1dLCBbJ3ByaW1lJywgWzgyNDJdXSwgWydQcmltZScsIFs4MjQzXV0sIFsncHJpbWVzJywgWzg0NzNdXSwgWydwcm5hcCcsIFsxMDkzN11dLCBbJ3BybkUnLCBbMTA5MzNdXSwgWydwcm5zaW0nLCBbODkzNl1dLCBbJ3Byb2QnLCBbODcxOV1dLCBbJ1Byb2R1Y3QnLCBbODcxOV1dLCBbJ3Byb2ZhbGFyJywgWzkwMDZdXSwgWydwcm9mbGluZScsIFs4OTc4XV0sIFsncHJvZnN1cmYnLCBbODk3OV1dLCBbJ3Byb3AnLCBbODczM11dLCBbJ1Byb3BvcnRpb25hbCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbicsIFs4NzU5XV0sIFsncHJvcHRvJywgWzg3MzNdXSwgWydwcnNpbScsIFs4ODMwXV0sIFsncHJ1cmVsJywgWzg4ODBdXSwgWydQc2NyJywgWzExOTk3OV1dLCBbJ3BzY3InLCBbMTIwMDA1XV0sIFsnUHNpJywgWzkzNl1dLCBbJ3BzaScsIFs5NjhdXSwgWydwdW5jc3AnLCBbODIwMF1dLCBbJ1FmcicsIFsxMjAwODRdXSwgWydxZnInLCBbMTIwMTEwXV0sIFsncWludCcsIFsxMDc2NF1dLCBbJ3FvcGYnLCBbMTIwMTYyXV0sIFsnUW9wZicsIFs4NDc0XV0sIFsncXByaW1lJywgWzgyNzldXSwgWydRc2NyJywgWzExOTk4MF1dLCBbJ3FzY3InLCBbMTIwMDA2XV0sIFsncXVhdGVybmlvbnMnLCBbODQ2MV1dLCBbJ3F1YXRpbnQnLCBbMTA3NzRdXSwgWydxdWVzdCcsIFs2M11dLCBbJ3F1ZXN0ZXEnLCBbODc5OV1dLCBbJ3F1b3QnLCBbMzRdXSwgWydRVU9UJywgWzM0XV0sIFsnckFhcnInLCBbODY2N11dLCBbJ3JhY2UnLCBbODc2NSwgODE3XV0sIFsnUmFjdXRlJywgWzM0MF1dLCBbJ3JhY3V0ZScsIFszNDFdXSwgWydyYWRpYycsIFs4NzMwXV0sIFsncmFlbXB0eXYnLCBbMTA2NzVdXSwgWydyYW5nJywgWzEwMjE3XV0sIFsnUmFuZycsIFsxMDIxOV1dLCBbJ3JhbmdkJywgWzEwNjQyXV0sIFsncmFuZ2UnLCBbMTA2NjFdXSwgWydyYW5nbGUnLCBbMTAyMTddXSwgWydyYXF1bycsIFsxODddXSwgWydyYXJyYXAnLCBbMTA2MTNdXSwgWydyYXJyYicsIFs4Njc3XV0sIFsncmFycmJmcycsIFsxMDUyOF1dLCBbJ3JhcnJjJywgWzEwNTQ3XV0sIFsncmFycicsIFs4NTk0XV0sIFsnUmFycicsIFs4NjA4XV0sIFsnckFycicsIFs4NjU4XV0sIFsncmFycmZzJywgWzEwNTI2XV0sIFsncmFycmhrJywgWzg2MThdXSwgWydyYXJybHAnLCBbODYyMF1dLCBbJ3JhcnJwbCcsIFsxMDU2NV1dLCBbJ3JhcnJzaW0nLCBbMTA2MTJdXSwgWydSYXJydGwnLCBbMTA1MThdXSwgWydyYXJydGwnLCBbODYxMV1dLCBbJ3JhcnJ3JywgWzg2MDVdXSwgWydyYXRhaWwnLCBbMTA1MjJdXSwgWydyQXRhaWwnLCBbMTA1MjRdXSwgWydyYXRpbycsIFs4NzU4XV0sIFsncmF0aW9uYWxzJywgWzg0NzRdXSwgWydyYmFycicsIFsxMDUwOV1dLCBbJ3JCYXJyJywgWzEwNTExXV0sIFsnUkJhcnInLCBbMTA1MTJdXSwgWydyYmJyaycsIFsxMDA5OV1dLCBbJ3JicmFjZScsIFsxMjVdXSwgWydyYnJhY2snLCBbOTNdXSwgWydyYnJrZScsIFsxMDYzNl1dLCBbJ3JicmtzbGQnLCBbMTA2MzhdXSwgWydyYnJrc2x1JywgWzEwNjQwXV0sIFsnUmNhcm9uJywgWzM0NF1dLCBbJ3JjYXJvbicsIFszNDVdXSwgWydSY2VkaWwnLCBbMzQyXV0sIFsncmNlZGlsJywgWzM0M11dLCBbJ3JjZWlsJywgWzg5NjldXSwgWydyY3ViJywgWzEyNV1dLCBbJ1JjeScsIFsxMDU2XV0sIFsncmN5JywgWzEwODhdXSwgWydyZGNhJywgWzEwNTUxXV0sIFsncmRsZGhhcicsIFsxMDYwMV1dLCBbJ3JkcXVvJywgWzgyMjFdXSwgWydyZHF1b3InLCBbODIyMV1dLCBbJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZScsIFs4MjIxXV0sIFsncmRzaCcsIFs4NjI3XV0sIFsncmVhbCcsIFs4NDc2XV0sIFsncmVhbGluZScsIFs4NDc1XV0sIFsncmVhbHBhcnQnLCBbODQ3Nl1dLCBbJ3JlYWxzJywgWzg0NzddXSwgWydSZScsIFs4NDc2XV0sIFsncmVjdCcsIFs5NjQ1XV0sIFsncmVnJywgWzE3NF1dLCBbJ1JFRycsIFsxNzRdXSwgWydSZXZlcnNlRWxlbWVudCcsIFs4NzE1XV0sIFsnUmV2ZXJzZUVxdWlsaWJyaXVtJywgWzg2NTFdXSwgWydSZXZlcnNlVXBFcXVpbGlicml1bScsIFsxMDYwN11dLCBbJ3JmaXNodCcsIFsxMDYyMV1dLCBbJ3JmbG9vcicsIFs4OTcxXV0sIFsncmZyJywgWzEyMDExMV1dLCBbJ1JmcicsIFs4NDc2XV0sIFsnckhhcicsIFsxMDU5Nl1dLCBbJ3JoYXJkJywgWzg2NDFdXSwgWydyaGFydScsIFs4NjQwXV0sIFsncmhhcnVsJywgWzEwNjA0XV0sIFsnUmhvJywgWzkyOV1dLCBbJ3JobycsIFs5NjFdXSwgWydyaG92JywgWzEwMDldXSwgWydSaWdodEFuZ2xlQnJhY2tldCcsIFsxMDIxN11dLCBbJ1JpZ2h0QXJyb3dCYXInLCBbODY3N11dLCBbJ3JpZ2h0YXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0YXJyb3cnLCBbODY1OF1dLCBbJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnLCBbODY0NF1dLCBbJ3JpZ2h0YXJyb3d0YWlsJywgWzg2MTFdXSwgWydSaWdodENlaWxpbmcnLCBbODk2OV1dLCBbJ1JpZ2h0RG91YmxlQnJhY2tldCcsIFsxMDIxNV1dLCBbJ1JpZ2h0RG93blRlZVZlY3RvcicsIFsxMDU4OV1dLCBbJ1JpZ2h0RG93blZlY3RvckJhcicsIFsxMDU4MV1dLCBbJ1JpZ2h0RG93blZlY3RvcicsIFs4NjQyXV0sIFsnUmlnaHRGbG9vcicsIFs4OTcxXV0sIFsncmlnaHRoYXJwb29uZG93bicsIFs4NjQxXV0sIFsncmlnaHRoYXJwb29udXAnLCBbODY0MF1dLCBbJ3JpZ2h0bGVmdGFycm93cycsIFs4NjQ0XV0sIFsncmlnaHRsZWZ0aGFycG9vbnMnLCBbODY1Ml1dLCBbJ3JpZ2h0cmlnaHRhcnJvd3MnLCBbODY0OV1dLCBbJ3JpZ2h0c3F1aWdhcnJvdycsIFs4NjA1XV0sIFsnUmlnaHRUZWVBcnJvdycsIFs4NjE0XV0sIFsnUmlnaHRUZWUnLCBbODg2Nl1dLCBbJ1JpZ2h0VGVlVmVjdG9yJywgWzEwNTg3XV0sIFsncmlnaHR0aHJlZXRpbWVzJywgWzg5MDhdXSwgWydSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0XV0sIFsnUmlnaHRUcmlhbmdsZScsIFs4ODgzXV0sIFsnUmlnaHRUcmlhbmdsZUVxdWFsJywgWzg4ODVdXSwgWydSaWdodFVwRG93blZlY3RvcicsIFsxMDU3NV1dLCBbJ1JpZ2h0VXBUZWVWZWN0b3InLCBbMTA1ODhdXSwgWydSaWdodFVwVmVjdG9yQmFyJywgWzEwNTgwXV0sIFsnUmlnaHRVcFZlY3RvcicsIFs4NjM4XV0sIFsnUmlnaHRWZWN0b3JCYXInLCBbMTA1NzldXSwgWydSaWdodFZlY3RvcicsIFs4NjQwXV0sIFsncmluZycsIFs3MzBdXSwgWydyaXNpbmdkb3RzZXEnLCBbODc4N11dLCBbJ3JsYXJyJywgWzg2NDRdXSwgWydybGhhcicsIFs4NjUyXV0sIFsncmxtJywgWzgyMDddXSwgWydybW91c3RhY2hlJywgWzkxMzddXSwgWydybW91c3QnLCBbOTEzN11dLCBbJ3JubWlkJywgWzEwOTkwXV0sIFsncm9hbmcnLCBbMTAyMjFdXSwgWydyb2FycicsIFs4NzAyXV0sIFsncm9icmsnLCBbMTAyMTVdXSwgWydyb3BhcicsIFsxMDYzMF1dLCBbJ3JvcGYnLCBbMTIwMTYzXV0sIFsnUm9wZicsIFs4NDc3XV0sIFsncm9wbHVzJywgWzEwNzk4XV0sIFsncm90aW1lcycsIFsxMDgwNV1dLCBbJ1JvdW5kSW1wbGllcycsIFsxMDYwOF1dLCBbJ3JwYXInLCBbNDFdXSwgWydycGFyZ3QnLCBbMTA2NDRdXSwgWydycHBvbGludCcsIFsxMDc3MF1dLCBbJ3JyYXJyJywgWzg2NDldXSwgWydScmlnaHRhcnJvdycsIFs4NjY3XV0sIFsncnNhcXVvJywgWzgyNTBdXSwgWydyc2NyJywgWzEyMDAwN11dLCBbJ1JzY3InLCBbODQ3NV1dLCBbJ3JzaCcsIFs4NjI1XV0sIFsnUnNoJywgWzg2MjVdXSwgWydyc3FiJywgWzkzXV0sIFsncnNxdW8nLCBbODIxN11dLCBbJ3JzcXVvcicsIFs4MjE3XV0sIFsnQ2xvc2VDdXJseVF1b3RlJywgWzgyMTddXSwgWydydGhyZWUnLCBbODkwOF1dLCBbJ3J0aW1lcycsIFs4OTA2XV0sIFsncnRyaScsIFs5NjU3XV0sIFsncnRyaWUnLCBbODg4NV1dLCBbJ3J0cmlmJywgWzk2NTZdXSwgWydydHJpbHRyaScsIFsxMDcwMl1dLCBbJ1J1bGVEZWxheWVkJywgWzEwNzQwXV0sIFsncnVsdWhhcicsIFsxMDYwMF1dLCBbJ3J4JywgWzg0NzhdXSwgWydTYWN1dGUnLCBbMzQ2XV0sIFsnc2FjdXRlJywgWzM0N11dLCBbJ3NicXVvJywgWzgyMThdXSwgWydzY2FwJywgWzEwOTM2XV0sIFsnU2Nhcm9uJywgWzM1Ml1dLCBbJ3NjYXJvbicsIFszNTNdXSwgWydTYycsIFsxMDk0MF1dLCBbJ3NjJywgWzg4MjddXSwgWydzY2N1ZScsIFs4ODI5XV0sIFsnc2NlJywgWzEwOTI4XV0sIFsnc2NFJywgWzEwOTMyXV0sIFsnU2NlZGlsJywgWzM1MF1dLCBbJ3NjZWRpbCcsIFszNTFdXSwgWydTY2lyYycsIFszNDhdXSwgWydzY2lyYycsIFszNDldXSwgWydzY25hcCcsIFsxMDkzOF1dLCBbJ3NjbkUnLCBbMTA5MzRdXSwgWydzY25zaW0nLCBbODkzN11dLCBbJ3NjcG9saW50JywgWzEwNzcxXV0sIFsnc2NzaW0nLCBbODgzMV1dLCBbJ1NjeScsIFsxMDU3XV0sIFsnc2N5JywgWzEwODldXSwgWydzZG90YicsIFs4ODY1XV0sIFsnc2RvdCcsIFs4OTAxXV0sIFsnc2RvdGUnLCBbMTA4NTRdXSwgWydzZWFyaGsnLCBbMTA1MzNdXSwgWydzZWFycicsIFs4NjAwXV0sIFsnc2VBcnInLCBbODY2NF1dLCBbJ3NlYXJyb3cnLCBbODYwMF1dLCBbJ3NlY3QnLCBbMTY3XV0sIFsnc2VtaScsIFs1OV1dLCBbJ3Nlc3dhcicsIFsxMDUzN11dLCBbJ3NldG1pbnVzJywgWzg3MjZdXSwgWydzZXRtbicsIFs4NzI2XV0sIFsnc2V4dCcsIFsxMDAzOF1dLCBbJ1NmcicsIFsxMjAwODZdXSwgWydzZnInLCBbMTIwMTEyXV0sIFsnc2Zyb3duJywgWzg5OTRdXSwgWydzaGFycCcsIFs5ODM5XV0sIFsnU0hDSGN5JywgWzEwNjVdXSwgWydzaGNoY3knLCBbMTA5N11dLCBbJ1NIY3knLCBbMTA2NF1dLCBbJ3NoY3knLCBbMTA5Nl1dLCBbJ1Nob3J0RG93bkFycm93JywgWzg1OTVdXSwgWydTaG9ydExlZnRBcnJvdycsIFs4NTkyXV0sIFsnc2hvcnRtaWQnLCBbODczOV1dLCBbJ3Nob3J0cGFyYWxsZWwnLCBbODc0MV1dLCBbJ1Nob3J0UmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnU2hvcnRVcEFycm93JywgWzg1OTNdXSwgWydzaHknLCBbMTczXV0sIFsnU2lnbWEnLCBbOTMxXV0sIFsnc2lnbWEnLCBbOTYzXV0sIFsnc2lnbWFmJywgWzk2Ml1dLCBbJ3NpZ21hdicsIFs5NjJdXSwgWydzaW0nLCBbODc2NF1dLCBbJ3NpbWRvdCcsIFsxMDg1OF1dLCBbJ3NpbWUnLCBbODc3MV1dLCBbJ3NpbWVxJywgWzg3NzFdXSwgWydzaW1nJywgWzEwOTEwXV0sIFsnc2ltZ0UnLCBbMTA5MTJdXSwgWydzaW1sJywgWzEwOTA5XV0sIFsnc2ltbEUnLCBbMTA5MTFdXSwgWydzaW1uZScsIFs4Nzc0XV0sIFsnc2ltcGx1cycsIFsxMDc4OF1dLCBbJ3NpbXJhcnInLCBbMTA2MTBdXSwgWydzbGFycicsIFs4NTkyXV0sIFsnU21hbGxDaXJjbGUnLCBbODcyOF1dLCBbJ3NtYWxsc2V0bWludXMnLCBbODcyNl1dLCBbJ3NtYXNocCcsIFsxMDgwM11dLCBbJ3NtZXBhcnNsJywgWzEwNzI0XV0sIFsnc21pZCcsIFs4NzM5XV0sIFsnc21pbGUnLCBbODk5NV1dLCBbJ3NtdCcsIFsxMDkyMl1dLCBbJ3NtdGUnLCBbMTA5MjRdXSwgWydzbXRlcycsIFsxMDkyNCwgNjUwMjRdXSwgWydTT0ZUY3knLCBbMTA2OF1dLCBbJ3NvZnRjeScsIFsxMTAwXV0sIFsnc29sYmFyJywgWzkwMjNdXSwgWydzb2xiJywgWzEwNjkyXV0sIFsnc29sJywgWzQ3XV0sIFsnU29wZicsIFsxMjAxMzhdXSwgWydzb3BmJywgWzEyMDE2NF1dLCBbJ3NwYWRlcycsIFs5ODI0XV0sIFsnc3BhZGVzdWl0JywgWzk4MjRdXSwgWydzcGFyJywgWzg3NDFdXSwgWydzcWNhcCcsIFs4ODUxXV0sIFsnc3FjYXBzJywgWzg4NTEsIDY1MDI0XV0sIFsnc3FjdXAnLCBbODg1Ml1dLCBbJ3NxY3VwcycsIFs4ODUyLCA2NTAyNF1dLCBbJ1NxcnQnLCBbODczMF1dLCBbJ3Nxc3ViJywgWzg4NDddXSwgWydzcXN1YmUnLCBbODg0OV1dLCBbJ3Nxc3Vic2V0JywgWzg4NDddXSwgWydzcXN1YnNldGVxJywgWzg4NDldXSwgWydzcXN1cCcsIFs4ODQ4XV0sIFsnc3FzdXBlJywgWzg4NTBdXSwgWydzcXN1cHNldCcsIFs4ODQ4XV0sIFsnc3FzdXBzZXRlcScsIFs4ODUwXV0sIFsnc3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZUludGVyc2VjdGlvbicsIFs4ODUxXV0sIFsnU3F1YXJlU3Vic2V0JywgWzg4NDddXSwgWydTcXVhcmVTdWJzZXRFcXVhbCcsIFs4ODQ5XV0sIFsnU3F1YXJlU3VwZXJzZXQnLCBbODg0OF1dLCBbJ1NxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODg1MF1dLCBbJ1NxdWFyZVVuaW9uJywgWzg4NTJdXSwgWydzcXVhcmYnLCBbOTY0Ml1dLCBbJ3NxdScsIFs5NjMzXV0sIFsnc3F1ZicsIFs5NjQyXV0sIFsnc3JhcnInLCBbODU5NF1dLCBbJ1NzY3InLCBbMTE5OTgyXV0sIFsnc3NjcicsIFsxMjAwMDhdXSwgWydzc2V0bW4nLCBbODcyNl1dLCBbJ3NzbWlsZScsIFs4OTk1XV0sIFsnc3N0YXJmJywgWzg5MDJdXSwgWydTdGFyJywgWzg5MDJdXSwgWydzdGFyJywgWzk3MzRdXSwgWydzdGFyZicsIFs5NzMzXV0sIFsnc3RyYWlnaHRlcHNpbG9uJywgWzEwMTNdXSwgWydzdHJhaWdodHBoaScsIFs5ODFdXSwgWydzdHJucycsIFsxNzVdXSwgWydzdWInLCBbODgzNF1dLCBbJ1N1YicsIFs4OTEyXV0sIFsnc3ViZG90JywgWzEwOTQxXV0sIFsnc3ViRScsIFsxMDk0OV1dLCBbJ3N1YmUnLCBbODgzOF1dLCBbJ3N1YmVkb3QnLCBbMTA5NDddXSwgWydzdWJtdWx0JywgWzEwOTQ1XV0sIFsnc3VibkUnLCBbMTA5NTVdXSwgWydzdWJuZScsIFs4ODQyXV0sIFsnc3VicGx1cycsIFsxMDk0M11dLCBbJ3N1YnJhcnInLCBbMTA2MTddXSwgWydzdWJzZXQnLCBbODgzNF1dLCBbJ1N1YnNldCcsIFs4OTEyXV0sIFsnc3Vic2V0ZXEnLCBbODgzOF1dLCBbJ3N1YnNldGVxcScsIFsxMDk0OV1dLCBbJ1N1YnNldEVxdWFsJywgWzg4MzhdXSwgWydzdWJzZXRuZXEnLCBbODg0Ml1dLCBbJ3N1YnNldG5lcXEnLCBbMTA5NTVdXSwgWydzdWJzaW0nLCBbMTA5NTFdXSwgWydzdWJzdWInLCBbMTA5NjVdXSwgWydzdWJzdXAnLCBbMTA5NjNdXSwgWydzdWNjYXBwcm94JywgWzEwOTM2XV0sIFsnc3VjYycsIFs4ODI3XV0sIFsnc3VjY2N1cmx5ZXEnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzJywgWzg4MjddXSwgWydTdWNjZWVkc0VxdWFsJywgWzEwOTI4XV0sIFsnU3VjY2VlZHNTbGFudEVxdWFsJywgWzg4MjldXSwgWydTdWNjZWVkc1RpbGRlJywgWzg4MzFdXSwgWydzdWNjZXEnLCBbMTA5MjhdXSwgWydzdWNjbmFwcHJveCcsIFsxMDkzOF1dLCBbJ3N1Y2NuZXFxJywgWzEwOTM0XV0sIFsnc3VjY25zaW0nLCBbODkzN11dLCBbJ3N1Y2NzaW0nLCBbODgzMV1dLCBbJ1N1Y2hUaGF0JywgWzg3MTVdXSwgWydzdW0nLCBbODcyMV1dLCBbJ1N1bScsIFs4NzIxXV0sIFsnc3VuZycsIFs5ODM0XV0sIFsnc3VwMScsIFsxODVdXSwgWydzdXAyJywgWzE3OF1dLCBbJ3N1cDMnLCBbMTc5XV0sIFsnc3VwJywgWzg4MzVdXSwgWydTdXAnLCBbODkxM11dLCBbJ3N1cGRvdCcsIFsxMDk0Ml1dLCBbJ3N1cGRzdWInLCBbMTA5NjhdXSwgWydzdXBFJywgWzEwOTUwXV0sIFsnc3VwZScsIFs4ODM5XV0sIFsnc3VwZWRvdCcsIFsxMDk0OF1dLCBbJ1N1cGVyc2V0JywgWzg4MzVdXSwgWydTdXBlcnNldEVxdWFsJywgWzg4MzldXSwgWydzdXBoc29sJywgWzEwMTg1XV0sIFsnc3VwaHN1YicsIFsxMDk2N11dLCBbJ3N1cGxhcnInLCBbMTA2MTldXSwgWydzdXBtdWx0JywgWzEwOTQ2XV0sIFsnc3VwbkUnLCBbMTA5NTZdXSwgWydzdXBuZScsIFs4ODQzXV0sIFsnc3VwcGx1cycsIFsxMDk0NF1dLCBbJ3N1cHNldCcsIFs4ODM1XV0sIFsnU3Vwc2V0JywgWzg5MTNdXSwgWydzdXBzZXRlcScsIFs4ODM5XV0sIFsnc3Vwc2V0ZXFxJywgWzEwOTUwXV0sIFsnc3Vwc2V0bmVxJywgWzg4NDNdXSwgWydzdXBzZXRuZXFxJywgWzEwOTU2XV0sIFsnc3Vwc2ltJywgWzEwOTUyXV0sIFsnc3Vwc3ViJywgWzEwOTY0XV0sIFsnc3Vwc3VwJywgWzEwOTY2XV0sIFsnc3dhcmhrJywgWzEwNTM0XV0sIFsnc3dhcnInLCBbODYwMV1dLCBbJ3N3QXJyJywgWzg2NjVdXSwgWydzd2Fycm93JywgWzg2MDFdXSwgWydzd253YXInLCBbMTA1MzhdXSwgWydzemxpZycsIFsyMjNdXSwgWydUYWInLCBbOV1dLCBbJ3RhcmdldCcsIFs4OTgyXV0sIFsnVGF1JywgWzkzMl1dLCBbJ3RhdScsIFs5NjRdXSwgWyd0YnJrJywgWzkxNDBdXSwgWydUY2Fyb24nLCBbMzU2XV0sIFsndGNhcm9uJywgWzM1N11dLCBbJ1RjZWRpbCcsIFszNTRdXSwgWyd0Y2VkaWwnLCBbMzU1XV0sIFsnVGN5JywgWzEwNThdXSwgWyd0Y3knLCBbMTA5MF1dLCBbJ3Rkb3QnLCBbODQxMV1dLCBbJ3RlbHJlYycsIFs4OTgxXV0sIFsnVGZyJywgWzEyMDA4N11dLCBbJ3RmcicsIFsxMjAxMTNdXSwgWyd0aGVyZTQnLCBbODc1Nl1dLCBbJ3RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGV0YScsIFs5MjBdXSwgWyd0aGV0YScsIFs5NTJdXSwgWyd0aGV0YXN5bScsIFs5NzddXSwgWyd0aGV0YXYnLCBbOTc3XV0sIFsndGhpY2thcHByb3gnLCBbODc3Nl1dLCBbJ3RoaWNrc2ltJywgWzg3NjRdXSwgWydUaGlja1NwYWNlJywgWzgyODcsIDgyMDJdXSwgWydUaGluU3BhY2UnLCBbODIwMV1dLCBbJ3RoaW5zcCcsIFs4MjAxXV0sIFsndGhrYXAnLCBbODc3Nl1dLCBbJ3Roa3NpbScsIFs4NzY0XV0sIFsnVEhPUk4nLCBbMjIyXV0sIFsndGhvcm4nLCBbMjU0XV0sIFsndGlsZGUnLCBbNzMyXV0sIFsnVGlsZGUnLCBbODc2NF1dLCBbJ1RpbGRlRXF1YWwnLCBbODc3MV1dLCBbJ1RpbGRlRnVsbEVxdWFsJywgWzg3NzNdXSwgWydUaWxkZVRpbGRlJywgWzg3NzZdXSwgWyd0aW1lc2JhcicsIFsxMDgwMV1dLCBbJ3RpbWVzYicsIFs4ODY0XV0sIFsndGltZXMnLCBbMjE1XV0sIFsndGltZXNkJywgWzEwODAwXV0sIFsndGludCcsIFs4NzQ5XV0sIFsndG9lYScsIFsxMDUzNl1dLCBbJ3RvcGJvdCcsIFs5MDE0XV0sIFsndG9wY2lyJywgWzEwOTkzXV0sIFsndG9wJywgWzg4NjhdXSwgWydUb3BmJywgWzEyMDEzOV1dLCBbJ3RvcGYnLCBbMTIwMTY1XV0sIFsndG9wZm9yaycsIFsxMDk3MF1dLCBbJ3Rvc2EnLCBbMTA1MzddXSwgWyd0cHJpbWUnLCBbODI0NF1dLCBbJ3RyYWRlJywgWzg0ODJdXSwgWydUUkFERScsIFs4NDgyXV0sIFsndHJpYW5nbGUnLCBbOTY1M11dLCBbJ3RyaWFuZ2xlZG93bicsIFs5NjYzXV0sIFsndHJpYW5nbGVsZWZ0JywgWzk2NjddXSwgWyd0cmlhbmdsZWxlZnRlcScsIFs4ODg0XV0sIFsndHJpYW5nbGVxJywgWzg3OTZdXSwgWyd0cmlhbmdsZXJpZ2h0JywgWzk2NTddXSwgWyd0cmlhbmdsZXJpZ2h0ZXEnLCBbODg4NV1dLCBbJ3RyaWRvdCcsIFs5NzA4XV0sIFsndHJpZScsIFs4Nzk2XV0sIFsndHJpbWludXMnLCBbMTA4MTBdXSwgWydUcmlwbGVEb3QnLCBbODQxMV1dLCBbJ3RyaXBsdXMnLCBbMTA4MDldXSwgWyd0cmlzYicsIFsxMDcwMV1dLCBbJ3RyaXRpbWUnLCBbMTA4MTFdXSwgWyd0cnBleml1bScsIFs5MTg2XV0sIFsnVHNjcicsIFsxMTk5ODNdXSwgWyd0c2NyJywgWzEyMDAwOV1dLCBbJ1RTY3knLCBbMTA2Ml1dLCBbJ3RzY3knLCBbMTA5NF1dLCBbJ1RTSGN5JywgWzEwMzVdXSwgWyd0c2hjeScsIFsxMTE1XV0sIFsnVHN0cm9rJywgWzM1OF1dLCBbJ3RzdHJvaycsIFszNTldXSwgWyd0d2l4dCcsIFs4ODEyXV0sIFsndHdvaGVhZGxlZnRhcnJvdycsIFs4NjA2XV0sIFsndHdvaGVhZHJpZ2h0YXJyb3cnLCBbODYwOF1dLCBbJ1VhY3V0ZScsIFsyMThdXSwgWyd1YWN1dGUnLCBbMjUwXV0sIFsndWFycicsIFs4NTkzXV0sIFsnVWFycicsIFs4NjA3XV0sIFsndUFycicsIFs4NjU3XV0sIFsnVWFycm9jaXInLCBbMTA1NjldXSwgWydVYnJjeScsIFsxMDM4XV0sIFsndWJyY3knLCBbMTExOF1dLCBbJ1VicmV2ZScsIFszNjRdXSwgWyd1YnJldmUnLCBbMzY1XV0sIFsnVWNpcmMnLCBbMjE5XV0sIFsndWNpcmMnLCBbMjUxXV0sIFsnVWN5JywgWzEwNTldXSwgWyd1Y3knLCBbMTA5MV1dLCBbJ3VkYXJyJywgWzg2NDVdXSwgWydVZGJsYWMnLCBbMzY4XV0sIFsndWRibGFjJywgWzM2OV1dLCBbJ3VkaGFyJywgWzEwNjA2XV0sIFsndWZpc2h0JywgWzEwNjIyXV0sIFsnVWZyJywgWzEyMDA4OF1dLCBbJ3VmcicsIFsxMjAxMTRdXSwgWydVZ3JhdmUnLCBbMjE3XV0sIFsndWdyYXZlJywgWzI0OV1dLCBbJ3VIYXInLCBbMTA1OTVdXSwgWyd1aGFybCcsIFs4NjM5XV0sIFsndWhhcnInLCBbODYzOF1dLCBbJ3VoYmxrJywgWzk2MDBdXSwgWyd1bGNvcm4nLCBbODk4OF1dLCBbJ3VsY29ybmVyJywgWzg5ODhdXSwgWyd1bGNyb3AnLCBbODk3NV1dLCBbJ3VsdHJpJywgWzk3MjBdXSwgWydVbWFjcicsIFszNjJdXSwgWyd1bWFjcicsIFszNjNdXSwgWyd1bWwnLCBbMTY4XV0sIFsnVW5kZXJCYXInLCBbOTVdXSwgWydVbmRlckJyYWNlJywgWzkxODNdXSwgWydVbmRlckJyYWNrZXQnLCBbOTE0MV1dLCBbJ1VuZGVyUGFyZW50aGVzaXMnLCBbOTE4MV1dLCBbJ1VuaW9uJywgWzg4OTldXSwgWydVbmlvblBsdXMnLCBbODg0Nl1dLCBbJ1VvZ29uJywgWzM3MF1dLCBbJ3VvZ29uJywgWzM3MV1dLCBbJ1VvcGYnLCBbMTIwMTQwXV0sIFsndW9wZicsIFsxMjAxNjZdXSwgWydVcEFycm93QmFyJywgWzEwNTE0XV0sIFsndXBhcnJvdycsIFs4NTkzXV0sIFsnVXBBcnJvdycsIFs4NTkzXV0sIFsnVXBhcnJvdycsIFs4NjU3XV0sIFsnVXBBcnJvd0Rvd25BcnJvdycsIFs4NjQ1XV0sIFsndXBkb3duYXJyb3cnLCBbODU5N11dLCBbJ1VwRG93bkFycm93JywgWzg1OTddXSwgWydVcGRvd25hcnJvdycsIFs4NjYxXV0sIFsnVXBFcXVpbGlicml1bScsIFsxMDYwNl1dLCBbJ3VwaGFycG9vbmxlZnQnLCBbODYzOV1dLCBbJ3VwaGFycG9vbnJpZ2h0JywgWzg2MzhdXSwgWyd1cGx1cycsIFs4ODQ2XV0sIFsnVXBwZXJMZWZ0QXJyb3cnLCBbODU5OF1dLCBbJ1VwcGVyUmlnaHRBcnJvdycsIFs4NTk5XV0sIFsndXBzaScsIFs5NjVdXSwgWydVcHNpJywgWzk3OF1dLCBbJ3Vwc2loJywgWzk3OF1dLCBbJ1Vwc2lsb24nLCBbOTMzXV0sIFsndXBzaWxvbicsIFs5NjVdXSwgWydVcFRlZUFycm93JywgWzg2MTNdXSwgWydVcFRlZScsIFs4ODY5XV0sIFsndXB1cGFycm93cycsIFs4NjQ4XV0sIFsndXJjb3JuJywgWzg5ODldXSwgWyd1cmNvcm5lcicsIFs4OTg5XV0sIFsndXJjcm9wJywgWzg5NzRdXSwgWydVcmluZycsIFszNjZdXSwgWyd1cmluZycsIFszNjddXSwgWyd1cnRyaScsIFs5NzIxXV0sIFsnVXNjcicsIFsxMTk5ODRdXSwgWyd1c2NyJywgWzEyMDAxMF1dLCBbJ3V0ZG90JywgWzg5NDRdXSwgWydVdGlsZGUnLCBbMzYwXV0sIFsndXRpbGRlJywgWzM2MV1dLCBbJ3V0cmknLCBbOTY1M11dLCBbJ3V0cmlmJywgWzk2NTJdXSwgWyd1dWFycicsIFs4NjQ4XV0sIFsnVXVtbCcsIFsyMjBdXSwgWyd1dW1sJywgWzI1Ml1dLCBbJ3V3YW5nbGUnLCBbMTA2NjNdXSwgWyd2YW5ncnQnLCBbMTA2NTJdXSwgWyd2YXJlcHNpbG9uJywgWzEwMTNdXSwgWyd2YXJrYXBwYScsIFsxMDA4XV0sIFsndmFybm90aGluZycsIFs4NzA5XV0sIFsndmFycGhpJywgWzk4MV1dLCBbJ3ZhcnBpJywgWzk4Ml1dLCBbJ3ZhcnByb3B0bycsIFs4NzMzXV0sIFsndmFycicsIFs4NTk3XV0sIFsndkFycicsIFs4NjYxXV0sIFsndmFycmhvJywgWzEwMDldXSwgWyd2YXJzaWdtYScsIFs5NjJdXSwgWyd2YXJzdWJzZXRuZXEnLCBbODg0MiwgNjUwMjRdXSwgWyd2YXJzdWJzZXRuZXFxJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcScsIFs4ODQzLCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcXEnLCBbMTA5NTYsIDY1MDI0XV0sIFsndmFydGhldGEnLCBbOTc3XV0sIFsndmFydHJpYW5nbGVsZWZ0JywgWzg4ODJdXSwgWyd2YXJ0cmlhbmdsZXJpZ2h0JywgWzg4ODNdXSwgWyd2QmFyJywgWzEwOTg0XV0sIFsnVmJhcicsIFsxMDk4N11dLCBbJ3ZCYXJ2JywgWzEwOTg1XV0sIFsnVmN5JywgWzEwNDJdXSwgWyd2Y3knLCBbMTA3NF1dLCBbJ3ZkYXNoJywgWzg4NjZdXSwgWyd2RGFzaCcsIFs4ODcyXV0sIFsnVmRhc2gnLCBbODg3M11dLCBbJ1ZEYXNoJywgWzg4NzVdXSwgWydWZGFzaGwnLCBbMTA5ODJdXSwgWyd2ZWViYXInLCBbODg5MV1dLCBbJ3ZlZScsIFs4NzQ0XV0sIFsnVmVlJywgWzg4OTddXSwgWyd2ZWVlcScsIFs4Nzk0XV0sIFsndmVsbGlwJywgWzg5NDJdXSwgWyd2ZXJiYXInLCBbMTI0XV0sIFsnVmVyYmFyJywgWzgyMTRdXSwgWyd2ZXJ0JywgWzEyNF1dLCBbJ1ZlcnQnLCBbODIxNF1dLCBbJ1ZlcnRpY2FsQmFyJywgWzg3MzldXSwgWydWZXJ0aWNhbExpbmUnLCBbMTI0XV0sIFsnVmVydGljYWxTZXBhcmF0b3InLCBbMTAwNzJdXSwgWydWZXJ0aWNhbFRpbGRlJywgWzg3NjhdXSwgWydWZXJ5VGhpblNwYWNlJywgWzgyMDJdXSwgWydWZnInLCBbMTIwMDg5XV0sIFsndmZyJywgWzEyMDExNV1dLCBbJ3ZsdHJpJywgWzg4ODJdXSwgWyd2bnN1YicsIFs4ODM0LCA4NDAyXV0sIFsndm5zdXAnLCBbODgzNSwgODQwMl1dLCBbJ1ZvcGYnLCBbMTIwMTQxXV0sIFsndm9wZicsIFsxMjAxNjddXSwgWyd2cHJvcCcsIFs4NzMzXV0sIFsndnJ0cmknLCBbODg4M11dLCBbJ1ZzY3InLCBbMTE5OTg1XV0sIFsndnNjcicsIFsxMjAwMTFdXSwgWyd2c3VibkUnLCBbMTA5NTUsIDY1MDI0XV0sIFsndnN1Ym5lJywgWzg4NDIsIDY1MDI0XV0sIFsndnN1cG5FJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZzdXBuZScsIFs4ODQzLCA2NTAyNF1dLCBbJ1Z2ZGFzaCcsIFs4ODc0XV0sIFsndnppZ3phZycsIFsxMDY1MF1dLCBbJ1djaXJjJywgWzM3Ml1dLCBbJ3djaXJjJywgWzM3M11dLCBbJ3dlZGJhcicsIFsxMDg0N11dLCBbJ3dlZGdlJywgWzg3NDNdXSwgWydXZWRnZScsIFs4ODk2XV0sIFsnd2VkZ2VxJywgWzg3OTNdXSwgWyd3ZWllcnAnLCBbODQ3Ml1dLCBbJ1dmcicsIFsxMjAwOTBdXSwgWyd3ZnInLCBbMTIwMTE2XV0sIFsnV29wZicsIFsxMjAxNDJdXSwgWyd3b3BmJywgWzEyMDE2OF1dLCBbJ3dwJywgWzg0NzJdXSwgWyd3cicsIFs4NzY4XV0sIFsnd3JlYXRoJywgWzg3NjhdXSwgWydXc2NyJywgWzExOTk4Nl1dLCBbJ3dzY3InLCBbMTIwMDEyXV0sIFsneGNhcCcsIFs4ODk4XV0sIFsneGNpcmMnLCBbOTcxMV1dLCBbJ3hjdXAnLCBbODg5OV1dLCBbJ3hkdHJpJywgWzk2NjFdXSwgWydYZnInLCBbMTIwMDkxXV0sIFsneGZyJywgWzEyMDExN11dLCBbJ3hoYXJyJywgWzEwMjMxXV0sIFsneGhBcnInLCBbMTAyMzRdXSwgWydYaScsIFs5MjZdXSwgWyd4aScsIFs5NThdXSwgWyd4bGFycicsIFsxMDIyOV1dLCBbJ3hsQXJyJywgWzEwMjMyXV0sIFsneG1hcCcsIFsxMDIzNl1dLCBbJ3huaXMnLCBbODk1NV1dLCBbJ3hvZG90JywgWzEwNzUyXV0sIFsnWG9wZicsIFsxMjAxNDNdXSwgWyd4b3BmJywgWzEyMDE2OV1dLCBbJ3hvcGx1cycsIFsxMDc1M11dLCBbJ3hvdGltZScsIFsxMDc1NF1dLCBbJ3hyYXJyJywgWzEwMjMwXV0sIFsneHJBcnInLCBbMTAyMzNdXSwgWydYc2NyJywgWzExOTk4N11dLCBbJ3hzY3InLCBbMTIwMDEzXV0sIFsneHNxY3VwJywgWzEwNzU4XV0sIFsneHVwbHVzJywgWzEwNzU2XV0sIFsneHV0cmknLCBbOTY1MV1dLCBbJ3h2ZWUnLCBbODg5N11dLCBbJ3h3ZWRnZScsIFs4ODk2XV0sIFsnWWFjdXRlJywgWzIyMV1dLCBbJ3lhY3V0ZScsIFsyNTNdXSwgWydZQWN5JywgWzEwNzFdXSwgWyd5YWN5JywgWzExMDNdXSwgWydZY2lyYycsIFszNzRdXSwgWyd5Y2lyYycsIFszNzVdXSwgWydZY3knLCBbMTA2N11dLCBbJ3ljeScsIFsxMDk5XV0sIFsneWVuJywgWzE2NV1dLCBbJ1lmcicsIFsxMjAwOTJdXSwgWyd5ZnInLCBbMTIwMTE4XV0sIFsnWUljeScsIFsxMDMxXV0sIFsneWljeScsIFsxMTExXV0sIFsnWW9wZicsIFsxMjAxNDRdXSwgWyd5b3BmJywgWzEyMDE3MF1dLCBbJ1lzY3InLCBbMTE5OTg4XV0sIFsneXNjcicsIFsxMjAwMTRdXSwgWydZVWN5JywgWzEwNzBdXSwgWyd5dWN5JywgWzExMDJdXSwgWyd5dW1sJywgWzI1NV1dLCBbJ1l1bWwnLCBbMzc2XV0sIFsnWmFjdXRlJywgWzM3N11dLCBbJ3phY3V0ZScsIFszNzhdXSwgWydaY2Fyb24nLCBbMzgxXV0sIFsnemNhcm9uJywgWzM4Ml1dLCBbJ1pjeScsIFsxMDQ3XV0sIFsnemN5JywgWzEwNzldXSwgWydaZG90JywgWzM3OV1dLCBbJ3pkb3QnLCBbMzgwXV0sIFsnemVldHJmJywgWzg0ODhdXSwgWydaZXJvV2lkdGhTcGFjZScsIFs4MjAzXV0sIFsnWmV0YScsIFs5MThdXSwgWyd6ZXRhJywgWzk1MF1dLCBbJ3pmcicsIFsxMjAxMTldXSwgWydaZnInLCBbODQ4OF1dLCBbJ1pIY3knLCBbMTA0Nl1dLCBbJ3poY3knLCBbMTA3OF1dLCBbJ3ppZ3JhcnInLCBbODY2OV1dLCBbJ3pvcGYnLCBbMTIwMTcxXV0sIFsnWm9wZicsIFs4NDg0XV0sIFsnWnNjcicsIFsxMTk5ODldXSwgWyd6c2NyJywgWzEyMDAxNV1dLCBbJ3p3aicsIFs4MjA1XV0sIFsnenduaicsIFs4MjA0XV1dO1xudmFyIGFscGhhSW5kZXggPSB7fTtcbnZhciBjaGFySW5kZXggPSB7fTtcbmNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KTtcbnZhciBIdG1sNUVudGl0aWVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEh0bWw1RW50aXRpZXMoKSB7XG4gICAgfVxuICAgIEh0bWw1RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24gKHMsIGVudGl0eSkge1xuICAgICAgICAgICAgdmFyIGNocjtcbiAgICAgICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpLCAxNikgOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xuICAgIH07XG4gICAgSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxwaGEgPSBjaGFySW5mb1tzdHIuY2hhckNvZGVBdChpICsgMSldO1xuICAgICAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbHBoYSA9IGNoYXJJbmZvWycnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiAgICB9O1xuICAgIEh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W2NdO1xuICAgICAgICAgICAgaWYgKGNoYXJJbmZvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjIDwgMzIgfHwgYyA+IDEyNikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIdG1sNUVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gICAgfTtcbiAgICBIdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBIdG1sNUVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xuICAgIH07XG4gICAgcmV0dXJuIEh0bWw1RW50aXRpZXM7XG59KCkpO1xuZXhwb3J0cy5IdG1sNUVudGl0aWVzID0gSHRtbDVFbnRpdGllcztcbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIGkgPSBFTlRJVElFUy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZSA9IEVOVElUSUVTW2ldO1xuICAgICAgICB2YXIgYWxwaGEgPSBlWzBdO1xuICAgICAgICB2YXIgY2hhcnMgPSBlWzFdO1xuICAgICAgICB2YXIgY2hyID0gY2hhcnNbMF07XG4gICAgICAgIHZhciBhZGRDaGFyID0gKGNociA8IDMyIHx8IGNociA+IDEyNikgfHwgY2hyID09PSA2MiB8fCBjaHIgPT09IDYwIHx8IGNociA9PT0gMzggfHwgY2hyID09PSAzNCB8fCBjaHIgPT09IDM5O1xuICAgICAgICB2YXIgY2hhckluZm8gPSB2b2lkIDA7XG4gICAgICAgIGlmIChhZGRDaGFyKSB7XG4gICAgICAgICAgICBjaGFySW5mbyA9IGNoYXJJbmRleFtjaHJdID0gY2hhckluZGV4W2Nocl0gfHwge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJzWzFdKSB7XG4gICAgICAgICAgICB2YXIgY2hyMiA9IGNoYXJzWzFdO1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICAgICAgYWRkQ2hhciAmJiAoY2hhckluZm9bY2hyMl0gPSBhbHBoYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgIGFkZENoYXIgJiYgKGNoYXJJbmZvWycnXSA9IGFscGhhKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykuZ2V0TG9nZ2VyKCd3ZWJwYWNrLWRldi1zZXJ2ZXInKTtcblxudmFyIElORk8gPSAnaW5mbyc7XG52YXIgV0FSTiA9ICd3YXJuJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgREVCVUcgPSAnZGVidWcnO1xudmFyIFRSQUNFID0gJ3RyYWNlJztcbnZhciBTSUxFTlQgPSAnc2lsZW50JzsgLy8gZGVwcmVjYXRlZFxuLy8gVE9ETzogcmVtb3ZlIHRoZXNlIGF0IG1ham9yIHJlbGVhc2VkXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8xODI1XG5cbnZhciBXQVJOSU5HID0gJ3dhcm5pbmcnO1xudmFyIE5PTkUgPSAnbm9uZSc7IC8vIFNldCB0aGUgZGVmYXVsdCBsb2cgbGV2ZWxcblxubG9nLnNldERlZmF1bHRMZXZlbChJTkZPKTtcblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgSU5GTzpcbiAgICBjYXNlIFdBUk46XG4gICAgY2FzZSBFUlJPUjpcbiAgICBjYXNlIERFQlVHOlxuICAgIGNhc2UgVFJBQ0U6XG4gICAgICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gZGVwcmVjYXRlZFxuXG4gICAgY2FzZSBXQVJOSU5HOlxuICAgICAgLy8gbG9nbGV2ZWwncyB3YXJuaW5nIG5hbWUgaXMgZGlmZmVyZW50IGZyb20gd2VicGFjaydzXG4gICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgTk9ORTpcbiAgICBjYXNlIFNJTEVOVDpcbiAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBsb2cuZXJyb3IoXCJbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsICdcIi5jb25jYXQobGV2ZWwsIFwiJ1wiKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZzogbG9nLFxuICBzZXRMb2dMZXZlbDogc2V0TG9nTGV2ZWxcbn07IiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmICh0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cbi8vIFNlbmQgbWVzc2FnZXMgdG8gdGhlIG91dHNpZGUsIHNvIHBsdWdpbnMgY2FuIGNvbnN1bWUgaXQuXG5cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnIHx8ICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwid2VicGFja1wiLmNvbmNhdCh0eXBlKSxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9LCAnKicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VuZE1zZzsiLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2xvZycpLFxuICAgIGxvZyA9IF9yZXF1aXJlLmxvZztcblxuZnVuY3Rpb24gcmVsb2FkQXBwKF9yZWYsIF9yZWYyKSB7XG4gIHZhciBob3RSZWxvYWQgPSBfcmVmLmhvdFJlbG9hZCxcbiAgICAgIGhvdCA9IF9yZWYuaG90LFxuICAgICAgbGl2ZVJlbG9hZCA9IF9yZWYubGl2ZVJlbG9hZDtcbiAgdmFyIGlzVW5sb2FkaW5nID0gX3JlZjIuaXNVbmxvYWRpbmcsXG4gICAgICBjdXJyZW50SGFzaCA9IF9yZWYyLmN1cnJlbnRIYXNoO1xuXG4gIGlmIChpc1VubG9hZGluZyB8fCAhaG90UmVsb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGhvdCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgaG90IHVwZGF0ZS4uLicpO1xuXG4gICAgdmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKCd3ZWJwYWNrL2hvdC9lbWl0dGVyJyk7XG5cbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XG5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93KSB7XG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZShcIndlYnBhY2tIb3RVcGRhdGVcIi5jb25jYXQoY3VycmVudEhhc2gpLCAnKicpO1xuICAgIH1cbiAgfSAvLyBhbGxvdyByZWZyZXNoaW5nIHRoZSBwYWdlIG9ubHkgaWYgbGl2ZVJlbG9hZCBpc24ndCBkaXNhYmxlZFxuICBlbHNlIGlmIChsaXZlUmVsb2FkKSB7XG4gICAgICB2YXIgcm9vdFdpbmRvdyA9IHNlbGY7IC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuXG4gICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocm9vdFdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2Fib3V0OicpIHtcbiAgICAgICAgICAvLyByZWxvYWQgaW1tZWRpYXRlbHkgaWYgcHJvdG9jb2wgaXMgdmFsaWRcbiAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290V2luZG93ID0gcm9vdFdpbmRvdy5wYXJlbnQ7XG5cbiAgICAgICAgICBpZiAocm9vdFdpbmRvdy5wYXJlbnQgPT09IHJvb3RXaW5kb3cpIHtcbiAgICAgICAgICAgIC8vIGlmIHBhcmVudCBlcXVhbHMgY3VycmVudCB3aW5kb3cgd2UndmUgcmVhY2hlZCB0aGUgcm9vdCB3aGljaCB3b3VsZCBjb250aW51ZSBmb3JldmVyLCBzbyB0cmlnZ2VyIGEgcmVsb2FkIGFueXdheXNcbiAgICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbG9hZEFwcDsiLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgc2VsZiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBnZXRDdXJyZW50U2NyaXB0U291cmNlID0gcmVxdWlyZSgnLi9nZXRDdXJyZW50U2NyaXB0U291cmNlJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNvY2tldFVybChyZXNvdXJjZVF1ZXJ5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIHVybFBhcnRzO1xuXG4gIGlmICh0eXBlb2YgcmVzb3VyY2VRdWVyeSA9PT0gJ3N0cmluZycgJiYgcmVzb3VyY2VRdWVyeSAhPT0gJycpIHtcbiAgICAvLyBJZiB0aGlzIGJ1bmRsZSBpcyBpbmxpbmVkLCB1c2UgdGhlIHJlc291cmNlIHF1ZXJ5IHRvIGdldCB0aGUgY29ycmVjdCB1cmwuXG4gICAgLy8gZm9ybWF0IGlzIGxpa2UgYD9odHRwOi8vMC4wLjAuMDo4MDk2JnNvY2tQb3J0PTgwOTcmc29ja0hvc3Q9bG9jYWxob3N0YFxuICAgIHVybFBhcnRzID0gdXJsLnBhcnNlKHJlc291cmNlUXVlcnkgLy8gc3RyaXAgbGVhZGluZyBgP2AgZnJvbSBxdWVyeSBzdHJpbmcgdG8gZ2V0IGEgdmFsaWQgVVJMXG4gICAgLnN1YnN0cigxKSAvLyByZXBsYWNlIGZpcnN0IGAmYCB3aXRoIGA/YCB0byBoYXZlIGEgdmFsaWQgcXVlcnkgc3RyaW5nXG4gICAgLnJlcGxhY2UoJyYnLCAnPycpLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFbHNlLCBnZXQgdGhlIHVybCBmcm9tIHRoZSA8c2NyaXB0PiB0aGlzIGZpbGUgd2FzIGNhbGxlZCB3aXRoLlxuICAgIHZhciBzY3JpcHRIb3N0ID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpO1xuICAgIHVybFBhcnRzID0gdXJsLnBhcnNlKHNjcmlwdEhvc3QgfHwgJy8nLCB0cnVlLCB0cnVlKTtcbiAgfSAvLyBVc2UgcGFyYW1ldGVyIHRvIGFsbG93IHBhc3NpbmcgbG9jYXRpb24gaW4gdW5pdCB0ZXN0c1xuXG5cbiAgaWYgKHR5cGVvZiBjdXJyZW50TG9jYXRpb24gPT09ICdzdHJpbmcnICYmIGN1cnJlbnRMb2NhdGlvbiAhPT0gJycpIHtcbiAgICBjdXJyZW50TG9jYXRpb24gPSB1cmwucGFyc2UoY3VycmVudExvY2F0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50TG9jYXRpb24gPSBzZWxmLmxvY2F0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGdldFNvY2tldFVybCh1cmxQYXJ0cywgY3VycmVudExvY2F0aW9uKTtcbn1cbi8qXG4gKiBHZXRzIHNvY2tldCBVUkwgYmFzZWQgb24gU2NyaXB0IFNvdXJjZS9Mb2NhdGlvblxuICogKHNjcmlwdFNyYzogVVJMLCBsb2NhdGlvbjogVVJMKSAtPiBVUkxcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNvY2tldFVybCh1cmxQYXJ0cywgbG9jKSB7XG4gIHZhciBhdXRoID0gdXJsUGFydHMuYXV0aCxcbiAgICAgIHF1ZXJ5ID0gdXJsUGFydHMucXVlcnk7XG4gIHZhciBob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lLFxuICAgICAgcHJvdG9jb2wgPSB1cmxQYXJ0cy5wcm90b2NvbCxcbiAgICAgIHBvcnQgPSB1cmxQYXJ0cy5wb3J0O1xuXG4gIGlmICghcG9ydCB8fCBwb3J0ID09PSAnMCcpIHtcbiAgICBwb3J0ID0gbG9jLnBvcnQ7XG4gIH0gLy8gY2hlY2sgaXB2NCBhbmQgaXB2NiBgYWxsIGhvc3RuYW1lYFxuICAvLyB3aHkgZG8gd2UgbmVlZCB0aGlzIGNoZWNrP1xuICAvLyBob3N0bmFtZSBuL2EgZm9yIGZpbGUgcHJvdG9jb2wgKGV4YW1wbGUsIHdoZW4gdXNpbmcgZWxlY3Ryb24sIGlvbmljKVxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9wdWxsLzM4NFxuXG5cbiAgaWYgKChob3N0bmFtZSA9PT0gJzAuMC4wLjAnIHx8IGhvc3RuYW1lID09PSAnOjonKSAmJiBsb2MuaG9zdG5hbWUgJiYgbG9jLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gMCkge1xuICAgIGhvc3RuYW1lID0gbG9jLmhvc3RuYW1lO1xuICB9IC8vIGBob3N0bmFtZWAgY2FuIGJlIGVtcHR5IHdoZW4gdGhlIHNjcmlwdCBwYXRoIGlzIHJlbGF0aXZlLiBJbiB0aGF0IGNhc2UsIHNwZWNpZnlpbmdcbiAgLy8gYSBwcm90b2NvbCB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZCBVUkwuXG4gIC8vIFdoZW4gaHR0cHMgaXMgdXNlZCBpbiB0aGUgYXBwLCBzZWN1cmUgd2Vic29ja2V0cyBhcmUgYWx3YXlzIG5lY2Vzc2FyeVxuICAvLyBiZWNhdXNlIHRoZSBicm93c2VyIGRvZXNuJ3QgYWNjZXB0IG5vbi1zZWN1cmUgd2Vic29ja2V0cy5cblxuXG4gIGlmIChob3N0bmFtZSAmJiBob3N0bmFtZSAhPT0gJzEyNy4wLjAuMScgJiYgKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgdXJsUGFydHMuaG9zdG5hbWUgPT09ICcwLjAuMC4wJykpIHtcbiAgICBwcm90b2NvbCA9IGxvYy5wcm90b2NvbDtcbiAgfSAvLyBhbGwgb2YgdGhlc2Ugc29jayB1cmwgcGFyYW1zIGFyZSBvcHRpb25hbGx5IHBhc3NlZCBpbiB0aHJvdWdoXG4gIC8vIHJlc291cmNlUXVlcnksIHNvIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IGlmXG4gIC8vIHRoZXkgYXJlIG5vdCBwcm92aWRlZFxuXG5cbiAgdmFyIHNvY2tIb3N0ID0gcXVlcnkuc29ja0hvc3QgfHwgaG9zdG5hbWU7XG4gIHZhciBzb2NrUGF0aCA9IHF1ZXJ5LnNvY2tQYXRoIHx8ICcvc29ja2pzLW5vZGUnO1xuICB2YXIgc29ja1BvcnQgPSBxdWVyeS5zb2NrUG9ydCB8fCBwb3J0O1xuXG4gIGlmIChzb2NrUG9ydCA9PT0gJ2xvY2F0aW9uJykge1xuICAgIHNvY2tQb3J0ID0gbG9jLnBvcnQ7XG4gIH1cblxuICByZXR1cm4gdXJsLmZvcm1hdCh7XG4gICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgIGF1dGg6IGF1dGgsXG4gICAgaG9zdG5hbWU6IHNvY2tIb3N0LFxuICAgIHBvcnQ6IHNvY2tQb3J0LFxuICAgIC8vIElmIHNvY2tQYXRoIGlzIHByb3ZpZGVkIGl0J2xsIGJlIHBhc3NlZCBpbiB2aWEgdGhlIHJlc291cmNlUXVlcnkgYXMgYVxuICAgIC8vIHF1ZXJ5IHBhcmFtIHNvIGl0IGhhcyB0byBiZSBwYXJzZWQgb3V0IG9mIHRoZSBxdWVyeXN0cmluZyBpbiBvcmRlciBmb3IgdGhlXG4gICAgLy8gY2xpZW50IHRvIG9wZW4gdGhlIHNvY2tldCB0byB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAgICBwYXRobmFtZTogc29ja1BhdGhcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU29ja2V0VXJsOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKSB7XG4gIC8vIGBkb2N1bWVudC5jdXJyZW50U2NyaXB0YCBpcyB0aGUgbW9zdCBhY2N1cmF0ZSB3YXkgdG8gZmluZCB0aGUgY3VycmVudCBzY3JpcHQsXG4gIC8vIGJ1dCBpcyBub3Qgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vycy5cbiAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICB9IC8vIEZhbGwgYmFjayB0byBnZXR0aW5nIGFsbCBzY3JpcHRzIGluIHRoZSBkb2N1bWVudC5cblxuXG4gIHZhciBzY3JpcHRFbGVtZW50cyA9IGRvY3VtZW50LnNjcmlwdHMgfHwgW107XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gc2NyaXB0RWxlbWVudHNbc2NyaXB0RWxlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgaWYgKGN1cnJlbnRTY3JpcHQpIHtcbiAgICByZXR1cm4gY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICB9IC8vIEZhaWwgYXMgdGhlcmUgd2FzIG5vIHNjcmlwdCB0byB1c2UuXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1tXRFNdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2U7IiwidmFyIG1hcCA9IHtcblx0XCIuL2xvZ1wiOiAzMVxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDMwOyIsInZhciBsb2dMZXZlbCA9IFwiaW5mb1wiO1xuXG5mdW5jdGlvbiBkdW1teSgpIHt9XG5cbmZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbCkge1xuXHR2YXIgc2hvdWxkTG9nID1cblx0XHQobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcblx0cmV0dXJuIHNob3VsZExvZztcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0bG9nRm4obXNnKTtcblx0XHR9XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdGlmIChsZXZlbCA9PT0gXCJpbmZvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcblx0XHRcdGNvbnNvbGUud2Fybihtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xuXHRcdH1cblx0fVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG52YXIgZ3JvdXAgPSBjb25zb2xlLmdyb3VwIHx8IGR1bW15O1xudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7XG5cdGxvZ0xldmVsID0gbGV2ZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHR2YXIgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuXHR2YXIgc3RhY2sgPSBlcnIuc3RhY2s7XG5cdGlmICghc3RhY2spIHtcblx0XHRyZXR1cm4gbWVzc2FnZTtcblx0fSBlbHNlIGlmIChzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDwgMCkge1xuXHRcdHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzdGFjaztcblx0fVxufTtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYmlsbGJvYXJkLnNjc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKi0tIENoYXJ0IC0tKi9cXG4uYmIgc3ZnIHtcXG4gIGZvbnQ6IDEwcHggc2Fucy1zZXJpZjtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTsgfVxcblxcbi5iYiBwYXRoLCAuYmIgbGluZSB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjMDAwOyB9XFxuXFxuLmJiIHRleHQsIC5iYiAuYmItYnV0dG9uIHtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4uYmItbGVnZW5kLWl0ZW0tdGlsZSxcXG4uYmIteGdyaWQtZm9jdXMsXFxuLmJiLXlncmlkLWZvY3VzLFxcbi5iYi15Z3JpZCxcXG4uYmItZXZlbnQtcmVjdCxcXG4uYmItYmFycyBwYXRoIHtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlczsgfVxcblxcbi5iYi1jaGFydC1hcmMgLmJiLWdhdWdlLXZhbHVlIHtcXG4gIGZpbGw6ICMwMDA7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHBhdGgge1xcbiAgc3Ryb2tlOiAjZmZmOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyByZWN0IHtcXG4gIHN0cm9rZTogI2ZmZjtcXG4gIHN0cm9rZS13aWR0aDogMTsgfVxcblxcbi5iYi1jaGFydC1hcmMgdGV4dCB7XFxuICBmaWxsOiAjZmZmO1xcbiAgZm9udC1zaXplOiAxM3B4OyB9XFxuXFxuLyotLSBBeGlzIC0tKi9cXG4uYmItYXhpcyB7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7IH1cXG5cXG4vKi0tIEdyaWQgLS0qL1xcbi5iYi1ncmlkIGxpbmUge1xcbiAgc3Ryb2tlOiAjYWFhOyB9XFxuXFxuLmJiLWdyaWQgdGV4dCB7XFxuICBmaWxsOiAjYWFhOyB9XFxuXFxuLmJiLXhncmlkLCAuYmIteWdyaWQge1xcbiAgc3Ryb2tlLWRhc2hhcnJheTogMyAzOyB9XFxuXFxuLyotLSBUZXh0IG9uIENoYXJ0IC0tKi9cXG4uYmItdGV4dC5iYi1lbXB0eSB7XFxuICBmaWxsOiAjODA4MDgwO1xcbiAgZm9udC1zaXplOiAyZW07IH1cXG5cXG4vKi0tIExpbmUgLS0qL1xcbi5iYi1saW5lIHtcXG4gIHN0cm9rZS13aWR0aDogMXB4OyB9XFxuXFxuLyotLSBQb2ludCAtLSovXFxuLmJiLWNpcmNsZS5fZXhwYW5kZWRfIHtcXG4gIHN0cm9rZS13aWR0aDogMXB4O1xcbiAgc3Ryb2tlOiB3aGl0ZTsgfVxcblxcbi5iYi1zZWxlY3RlZC1jaXJjbGUge1xcbiAgZmlsbDogd2hpdGU7XFxuICBzdHJva2Utd2lkdGg6IDJweDsgfVxcblxcbi8qLS0gQmFyIC0tKi9cXG4uYmItYmFyIHtcXG4gIHN0cm9rZS13aWR0aDogMDsgfVxcbiAgLmJiLWJhci5fZXhwYW5kZWRfIHtcXG4gICAgZmlsbC1vcGFjaXR5OiAwLjc1OyB9XFxuXFxuLyotLSBGb2N1cyAtLSovXFxuLmJiLXRhcmdldC5iYi1mb2N1c2VkLCAuYmItY2lyY2xlcy5iYi1mb2N1c2VkIHtcXG4gIG9wYWNpdHk6IDE7IH1cXG5cXG4uYmItdGFyZ2V0LmJiLWZvY3VzZWQgcGF0aC5iYi1saW5lLCAuYmItdGFyZ2V0LmJiLWZvY3VzZWQgcGF0aC5iYi1zdGVwLCAuYmItY2lyY2xlcy5iYi1mb2N1c2VkIHBhdGguYmItbGluZSwgLmJiLWNpcmNsZXMuYmItZm9jdXNlZCBwYXRoLmJiLXN0ZXAge1xcbiAgc3Ryb2tlLXdpZHRoOiAycHg7IH1cXG5cXG4uYmItdGFyZ2V0LmJiLWRlZm9jdXNlZCwgLmJiLWNpcmNsZXMuYmItZGVmb2N1c2VkIHtcXG4gIG9wYWNpdHk6IDAuMyAhaW1wb3J0YW50OyB9XFxuICAuYmItdGFyZ2V0LmJiLWRlZm9jdXNlZCAudGV4dC1vdmVybGFwcGluZywgLmJiLWNpcmNsZXMuYmItZGVmb2N1c2VkIC50ZXh0LW92ZXJsYXBwaW5nIHtcXG4gICAgb3BhY2l0eTogLjA1ICFpbXBvcnRhbnQ7IH1cXG5cXG4vKi0tIFJlZ2lvbiAtLSovXFxuLmJiLXJlZ2lvbiB7XFxuICBmaWxsOiBzdGVlbGJsdWU7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBab29tIHJlZ2lvbiAtLSovXFxuLmJiLXpvb20tYnJ1c2gge1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gQnJ1c2ggLS0qL1xcbi5iYi1icnVzaCAuZXh0ZW50IHtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIFNlbGVjdCAtIERyYWcgLS0qL1xcbi8qLS0gTGVnZW5kIC0tKi9cXG4uYmItbGVnZW5kLWl0ZW0ge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4uYmItbGVnZW5kLWl0ZW0taGlkZGVuIHtcXG4gIG9wYWNpdHk6IDAuMTU7IH1cXG5cXG4uYmItbGVnZW5kLWJhY2tncm91bmQge1xcbiAgb3BhY2l0eTogMC43NTtcXG4gIGZpbGw6IHdoaXRlO1xcbiAgc3Ryb2tlOiBsaWdodGdyYXk7XFxuICBzdHJva2Utd2lkdGg6IDE7IH1cXG5cXG4vKi0tIFRpdGxlIC0tKi9cXG4uYmItdGl0bGUge1xcbiAgZm9udDogMTRweCBzYW5zLXNlcmlmOyB9XFxuXFxuLyotLSBUb29sdGlwIC0tKi9cXG4uYmItdG9vbHRpcC1jb250YWluZXIge1xcbiAgei1pbmRleDogMTA7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi10b29sdGlwIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICBib3JkZXItc3BhY2luZzogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBlbXB0eS1jZWxsczogc2hvdztcXG4gIG9wYWNpdHk6IDAuOTtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NztcXG4gIC1tb3otYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NztcXG4gIGJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7IH1cXG4gIC5iYi10b29sdGlwIHRyIHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI0NDQzsgfVxcbiAgLmJiLXRvb2x0aXAgdGgge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWFhO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIHBhZGRpbmc6IDJweCA1cHg7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIGNvbG9yOiAjRkZGOyB9XFxuICAuYmItdG9vbHRpcCB0ZCB7XFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXG4gICAgcGFkZGluZzogM3B4IDZweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkb3R0ZWQgIzk5OTsgfVxcbiAgICAuYmItdG9vbHRpcCB0ZCA+IHNwYW4sIC5iYi10b29sdGlwIHRkID4gc3ZnIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgaGVpZ2h0OiAxMHB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogNnB4OyB9XFxuICAuYmItdG9vbHRpcC52YWx1ZSB7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0OyB9XFxuXFxuLyotLSBBcmVhIC0tKi9cXG4uYmItYXJlYSB7XFxuICBzdHJva2Utd2lkdGg6IDA7XFxuICBvcGFjaXR5OiAwLjI7IH1cXG5cXG4vKi0tIEFyYyAtLSovXFxuLmJiLWNoYXJ0LWFyY3MtdGl0bGUge1xcbiAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcXG4gIGZvbnQtc2l6ZTogMS4zZW07IH1cXG5cXG4uYmItY2hhcnQtYXJjcy1nYXVnZS10aXRsZSB7XFxuICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xcbiAgZm9udC1zaXplOiAyLjdlbTsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWJhY2tncm91bmQge1xcbiAgZmlsbDogI2UwZTBlMDtcXG4gIHN0cm9rZTogI2ZmZjsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLXVuaXQge1xcbiAgZmlsbDogIzAwMDtcXG4gIGZvbnQtc2l6ZTogMTZweDsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLW1heCB7XFxuICBmaWxsOiAjNzc3OyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWluIHtcXG4gIGZpbGw6ICM3Nzc7IH1cXG5cXG4vKi0tIFJhZGFyIC0tKi9cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1sZXZlbHMgcG9seWdvbiB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjODQ4MjgyO1xcbiAgc3Ryb2tlLXdpZHRoOiAuNXB4OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItbGV2ZWxzIHRleHQge1xcbiAgZmlsbDogIzg0ODI4MjsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWF4aXMgbGluZSB7XFxuICBzdHJva2U6ICM4NDgyODI7XFxuICBzdHJva2Utd2lkdGg6IC41cHg7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1heGlzIHRleHQge1xcbiAgZm9udC1zaXplOiAxLjE1ZW07XFxuICBjdXJzb3I6IGRlZmF1bHQ7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1zaGFwZXMgcG9seWdvbiB7XFxuICBmaWxsLW9wYWNpdHk6IC4yO1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7IH1cXG5cXG4vKi0tIEJ1dHRvbiAtLSovXFxuLmJiLWJ1dHRvbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDEwcHg7XFxuICByaWdodDogMTBweDsgfVxcbiAgLmJiLWJ1dHRvbiAuYmItem9vbS1yZXNldCB7XFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXG4gICAgYm9yZGVyOiBzb2xpZCAxcHggI2NjYztcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM2X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zN19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzhfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM5X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDFfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQyX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180M19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDRfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ1X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Nl9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDdfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ4X187IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQ1NTIGNsYXNzIG5hbWVzIGRlZmluaXRpb25cclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRhcmM6IFwiYmItYXJjXCIsXHJcblx0YXJjTGFiZWxMaW5lOiBcImJiLWFyYy1sYWJlbC1saW5lXCIsXHJcblx0YXJjczogXCJiYi1hcmNzXCIsXHJcblx0YXJlYTogXCJiYi1hcmVhXCIsXHJcblx0YXJlYXM6IFwiYmItYXJlYXNcIixcclxuXHRheGlzOiBcImJiLWF4aXNcIixcclxuXHRheGlzWDogXCJiYi1heGlzLXhcIixcclxuXHRheGlzWExhYmVsOiBcImJiLWF4aXMteC1sYWJlbFwiLFxyXG5cdGF4aXNZOiBcImJiLWF4aXMteVwiLFxyXG5cdGF4aXNZMjogXCJiYi1heGlzLXkyXCIsXHJcblx0YXhpc1kyTGFiZWw6IFwiYmItYXhpcy15Mi1sYWJlbFwiLFxyXG5cdGF4aXNZTGFiZWw6IFwiYmItYXhpcy15LWxhYmVsXCIsXHJcblx0YmFyOiBcImJiLWJhclwiLFxyXG5cdGJhcnM6IFwiYmItYmFyc1wiLFxyXG5cdGJydXNoOiBcImJiLWJydXNoXCIsXHJcblx0YnV0dG9uOiBcImJiLWJ1dHRvblwiLFxyXG5cdGJ1dHRvblpvb21SZXNldDogXCJiYi16b29tLXJlc2V0XCIsXHJcblx0Y2hhcnQ6IFwiYmItY2hhcnRcIixcclxuXHRjaGFydEFyYzogXCJiYi1jaGFydC1hcmNcIixcclxuXHRjaGFydEFyY3M6IFwiYmItY2hhcnQtYXJjc1wiLFxyXG5cdGNoYXJ0QXJjc0JhY2tncm91bmQ6IFwiYmItY2hhcnQtYXJjcy1iYWNrZ3JvdW5kXCIsXHJcblx0Y2hhcnRBcmNzR2F1Z2VNYXg6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS1tYXhcIixcclxuXHRjaGFydEFyY3NHYXVnZU1pbjogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1pblwiLFxyXG5cdGNoYXJ0QXJjc0dhdWdlVW5pdDogXCJiYi1jaGFydC1hcmNzLWdhdWdlLXVuaXRcIixcclxuXHRjaGFydEFyY3NUaXRsZTogXCJiYi1jaGFydC1hcmNzLXRpdGxlXCIsXHJcblx0Y2hhcnRBcmNzR2F1Z2VUaXRsZTogXCJiYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlXCIsXHJcblx0Y2hhcnRCYXI6IFwiYmItY2hhcnQtYmFyXCIsXHJcblx0Y2hhcnRCYXJzOiBcImJiLWNoYXJ0LWJhcnNcIixcclxuXHRjaGFydENpcmNsZXM6IFwiYmItY2hhcnQtY2lyY2xlc1wiLFxyXG5cdGNoYXJ0TGluZTogXCJiYi1jaGFydC1saW5lXCIsXHJcblx0Y2hhcnRMaW5lczogXCJiYi1jaGFydC1saW5lc1wiLFxyXG5cdGNoYXJ0UmFkYXI6IFwiYmItY2hhcnQtcmFkYXJcIixcclxuXHRjaGFydFJhZGFyczogXCJiYi1jaGFydC1yYWRhcnNcIixcclxuXHRjaGFydFRleHQ6IFwiYmItY2hhcnQtdGV4dFwiLFxyXG5cdGNoYXJ0VGV4dHM6IFwiYmItY2hhcnQtdGV4dHNcIixcclxuXHRjaXJjbGU6IFwiYmItY2lyY2xlXCIsXHJcblx0Y2lyY2xlczogXCJiYi1jaXJjbGVzXCIsXHJcblx0Y29sb3JQYXR0ZXJuOiBcImJiLWNvbG9yLXBhdHRlcm5cIixcclxuXHRjb2xvclNjYWxlOiBcImJiLWNvbG9yc2NhbGVcIixcclxuXHRkZWZvY3VzZWQ6IFwiYmItZGVmb2N1c2VkXCIsXHJcblx0ZHJhZ2FyZWE6IFwiYmItZHJhZ2FyZWFcIixcclxuXHRlbXB0eTogXCJiYi1lbXB0eVwiLFxyXG5cdGV2ZW50UmVjdDogXCJiYi1ldmVudC1yZWN0XCIsXHJcblx0ZXZlbnRSZWN0czogXCJiYi1ldmVudC1yZWN0c1wiLFxyXG5cdGV2ZW50UmVjdHNNdWx0aXBsZTogXCJiYi1ldmVudC1yZWN0cy1tdWx0aXBsZVwiLFxyXG5cdGV2ZW50UmVjdHNTaW5nbGU6IFwiYmItZXZlbnQtcmVjdHMtc2luZ2xlXCIsXHJcblx0Zm9jdXNlZDogXCJiYi1mb2N1c2VkXCIsXHJcblx0Z2F1Z2VWYWx1ZTogXCJiYi1nYXVnZS12YWx1ZVwiLFxyXG5cdGdyaWQ6IFwiYmItZ3JpZFwiLFxyXG5cdGdyaWRMaW5lczogXCJiYi1ncmlkLWxpbmVzXCIsXHJcblx0bGVnZW5kOiBcImJiLWxlZ2VuZFwiLFxyXG5cdGxlZ2VuZEJhY2tncm91bmQ6IFwiYmItbGVnZW5kLWJhY2tncm91bmRcIixcclxuXHRsZWdlbmRJdGVtOiBcImJiLWxlZ2VuZC1pdGVtXCIsXHJcblx0bGVnZW5kSXRlbUV2ZW50OiBcImJiLWxlZ2VuZC1pdGVtLWV2ZW50XCIsXHJcblx0bGVnZW5kSXRlbUZvY3VzZWQ6IFwiYmItbGVnZW5kLWl0ZW0tZm9jdXNlZFwiLFxyXG5cdGxlZ2VuZEl0ZW1IaWRkZW46IFwiYmItbGVnZW5kLWl0ZW0taGlkZGVuXCIsXHJcblx0bGVnZW5kSXRlbVBvaW50OiBcImJiLWxlZ2VuZC1pdGVtLXBvaW50XCIsXHJcblx0bGVnZW5kSXRlbVRpbGU6IFwiYmItbGVnZW5kLWl0ZW0tdGlsZVwiLFxyXG5cdGxldmVsOiBcImJiLWxldmVsXCIsXHJcblx0bGV2ZWxzOiBcImJiLWxldmVsc1wiLFxyXG5cdGxpbmU6IFwiYmItbGluZVwiLFxyXG5cdGxpbmVzOiBcImJiLWxpbmVzXCIsXHJcblx0bWFpbjogXCJiYi1tYWluXCIsXHJcblx0cmVnaW9uOiBcImJiLXJlZ2lvblwiLFxyXG5cdHJlZ2lvbnM6IFwiYmItcmVnaW9uc1wiLFxyXG5cdHNlbGVjdGVkQ2lyY2xlOiBcImJiLXNlbGVjdGVkLWNpcmNsZVwiLFxyXG5cdHNlbGVjdGVkQ2lyY2xlczogXCJiYi1zZWxlY3RlZC1jaXJjbGVzXCIsXHJcblx0c2hhcGU6IFwiYmItc2hhcGVcIixcclxuXHRzaGFwZXM6IFwiYmItc2hhcGVzXCIsXHJcblx0c3RhbmZvcmRFbGVtZW50czogXCJiYi1zdGFuZm9yZC1lbGVtZW50c1wiLFxyXG5cdHN0YW5mb3JkTGluZTogXCJiYi1zdGFuZm9yZC1saW5lXCIsXHJcblx0c3RhbmZvcmRMaW5lczogXCJiYi1zdGFuZm9yZC1saW5lc1wiLFxyXG5cdHN0YW5mb3JkUmVnaW9uOiBcImJiLXN0YW5mb3JkLXJlZ2lvblwiLFxyXG5cdHN0YW5mb3JkUmVnaW9uczogXCJiYi1zdGFuZm9yZC1yZWdpb25zXCIsXHJcblx0dGFyZ2V0OiBcImJiLXRhcmdldFwiLFxyXG5cdHRleHQ6IFwiYmItdGV4dFwiLFxyXG5cdHRleHRzOiBcImJiLXRleHRzXCIsXHJcblx0dGl0bGU6IFwiYmItdGl0bGVcIixcclxuXHR0b29sdGlwOiBcImJiLXRvb2x0aXBcIixcclxuXHR0b29sdGlwQ29udGFpbmVyOiBcImJiLXRvb2x0aXAtY29udGFpbmVyXCIsXHJcblx0dG9vbHRpcE5hbWU6IFwiYmItdG9vbHRpcC1uYW1lXCIsXHJcblx0eGdyaWQ6IFwiYmIteGdyaWRcIixcclxuXHR4Z3JpZEZvY3VzOiBcImJiLXhncmlkLWZvY3VzXCIsXHJcblx0eGdyaWRMaW5lOiBcImJiLXhncmlkLWxpbmVcIixcclxuXHR4Z3JpZExpbmVzOiBcImJiLXhncmlkLWxpbmVzXCIsXHJcblx0eGdyaWRzOiBcImJiLXhncmlkc1wiLFxyXG5cdHlncmlkOiBcImJiLXlncmlkXCIsXHJcblx0eWdyaWRGb2N1czogXCJiYi15Z3JpZC1mb2N1c1wiLFxyXG5cdHlncmlkTGluZTogXCJiYi15Z3JpZC1saW5lXCIsXHJcblx0eWdyaWRMaW5lczogXCJiYi15Z3JpZC1saW5lc1wiLFxyXG5cdHlncmlkczogXCJiYi15Z3JpZHNcIixcclxuXHR6b29tQnJ1c2g6IFwiYmItem9vbS1icnVzaFwiLFxyXG5cdHpvb21SZWN0OiBcImJiLXpvb20tcmVjdFwiLFxyXG5cdEVYUEFOREVEOiBcIl9leHBhbmRlZF9cIixcclxuXHRTRUxFQ1RFRDogXCJfc2VsZWN0ZWRfXCIsXHJcblx0SU5DTFVERUQ6IFwiX2luY2x1ZGVkX1wiLFxyXG5cdFRleHRPdmVybGFwcGluZzogXCJ0ZXh0LW92ZXJsYXBwaW5nXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbnR5cGUgVCA9IGQzU2VsZWN0aW9uIHwgbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBFbGVtZW50cyBjbGFzcy5cclxuICogQGNsYXNzIEVsZW1lbnRzXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVsZW1lbnQge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0Y29uc3QgZWxlbWVudDoge1xyXG5cdFx0XHRba2V5OiBzdHJpbmddOiBUIHwge1trZXk6IHN0cmluZ106IFR9XHJcblx0XHR9ID0ge1xyXG5cdFx0XHRjaGFydDogbnVsbCxcclxuXHRcdFx0bWFpbjogbnVsbCxcclxuXHRcdFx0c3ZnOiBudWxsLFxyXG5cdFx0XHRheGlzOiB7IC8vIGF4ZXNcclxuXHRcdFx0XHR4OiBudWxsLFxyXG5cdFx0XHRcdHk6IG51bGwsXHJcblx0XHRcdFx0eTI6IG51bGwsXHJcblx0XHRcdFx0c3ViWDogbnVsbFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRkZWZzOiBudWxsLFxyXG5cdFx0XHR0b29sdGlwOiBudWxsLFxyXG5cdFx0XHRsZWdlbmQ6IG51bGwsXHJcblx0XHRcdHRpdGxlOiBudWxsLFxyXG5cdFx0XHRzdWJjaGFydDoge1xyXG5cdFx0XHRcdG1haW46IG51bGwsIC8vICQkLmNvbnRleHRcclxuXHRcdFx0XHRiYXI6IG51bGwsIC8vICQkLmNvbnRleHRCYXJcclxuXHRcdFx0XHRsaW5lOiBudWxsLCAvLyAkJC5jb250ZXh0TGluZVxyXG5cdFx0XHRcdGFyZWE6IG51bGwgLy8gJCQuY29udGV4dEFyZWFcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGFyY3M6IG51bGwsXHJcblx0XHRcdGJhcjogbnVsbCwgLy8gbWFpbkJhcixcclxuXHRcdFx0bGluZTogbnVsbCwgLy8gbWFpbkxpbmUsXHJcblx0XHRcdGFyZWE6IG51bGwsIC8vIG1haW5BcmVhLFxyXG5cdFx0XHRjaXJjbGU6IG51bGwsIC8vIG1haW5DaXJjbGUsXHJcblx0XHRcdHJhZGFyOiBudWxsLFxyXG5cdFx0XHR0ZXh0OiBudWxsLCAvLyBtYWluVGV4dCxcclxuXHRcdFx0Z3JpZDoge1xyXG5cdFx0XHRcdG1haW46IG51bGwsIC8vIGdyaWQgKGFsc28gZm9jdXMpXHJcblx0XHRcdFx0eDogbnVsbCwgLy8geGdyaWQsXHJcblx0XHRcdFx0eTogbnVsbCwgLy8geWdyaWQsXHJcblx0XHRcdH0sXHJcblx0XHRcdGdyaWRMaW5lczoge1xyXG5cdFx0XHRcdG1haW46IG51bGwsIC8vIGdyaWRMaW5lc1xyXG5cdFx0XHRcdHg6IG51bGwsIC8vIHhncmlkTGluZXMsXHJcblx0XHRcdFx0eTogbnVsbCwgLy8geWdyaWRMaW5lc1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZWdpb246IHtcclxuXHRcdFx0XHRtYWluOiBudWxsLCAvLyByZWdpb25cclxuXHRcdFx0XHRsaXN0OiBudWxsIC8vIG1haW5SZWdpb25cclxuXHRcdFx0fSxcclxuXHRcdFx0ZXZlbnRSZWN0OiBudWxsXHJcblx0XHR9O1xyXG5cclxuXHRcdHJldHVybiBlbGVtZW50O1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBTdGF0ZSBjbGFzcy5cclxuICogQGNsYXNzIFN0YXRlXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0YXRlIHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHdpZHRoOiAwLFxyXG5cdFx0XHR3aWR0aDI6IDAsXHJcblx0XHRcdGhlaWdodDogMCxcclxuXHRcdFx0aGVpZ2h0MjogMCxcclxuXHRcdFx0bWFyZ2luOiB7XHJcblx0XHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwXHJcblx0XHRcdH0sXHJcblx0XHRcdG1hcmdpbjI6IHtcclxuXHRcdFx0XHR0b3A6IDAsXHJcblx0XHRcdFx0Ym90dG9tOiAwLFxyXG5cdFx0XHRcdGxlZnQ6IDAsXHJcblx0XHRcdFx0cmlnaHQ6IDBcclxuXHRcdFx0fSxcclxuXHRcdFx0bWFyZ2luMzoge1xyXG5cdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRib3R0b206IDAsXHJcblx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRyaWdodDogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRhcmNXaWR0aDogMCxcclxuXHRcdFx0YXJjSGVpZ2h0OiAwLFxyXG5cdFx0XHR4QXhpc0hlaWdodDogMCxcclxuXHJcblx0XHRcdGhhc0F4aXM6IGZhbHNlLFxyXG5cdFx0XHRoYXNSYWRhcjogZmFsc2UsXHJcblxyXG5cdFx0XHRjdXJyZW50OiB7XHJcblx0XHRcdFx0d2lkdGg6IDAsXHJcblx0XHRcdFx0aGVpZ2h0OiAwLFxyXG5cdFx0XHRcdGRhdGFNYXg6IDAsXHJcblxyXG5cdFx0XHRcdG1heFRpY2tXaWR0aHM6IHtcclxuXHRcdFx0XHRcdHg6IHtzaXplOiAwLCB0aWNrczogPG51bWJlcltdPiBbXSwgY2xpcFBhdGg6IDAsIGRvbWFpbjogXCJcIn0sXHJcblx0XHRcdFx0XHR5OiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifSxcclxuXHRcdFx0XHRcdHkyOiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifVxyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdC8vIGN1cnJlbnQgdXNlZCBjaGFydCB0eXBlIGxpc3RcclxuXHRcdFx0XHR0eXBlczogPHN0cmluZ1tdPiBbXSxcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdC8vIGxlZ2VuZFxyXG5cdFx0XHRpc0xlZ2VuZFJpZ2h0OiBmYWxzZSxcclxuXHRcdFx0aXNMZWdlbmRJbnNldDogZmFsc2UsXHJcblx0XHRcdGlzTGVnZW5kVG9wOiBmYWxzZSxcclxuXHRcdFx0aXNMZWdlbmRMZWZ0OiBmYWxzZSxcclxuXHRcdFx0bGVnZW5kU3RlcDogMCxcclxuXHRcdFx0bGVnZW5kSXRlbVdpZHRoOiAwLFxyXG5cdFx0XHRsZWdlbmRJdGVtSGVpZ2h0OiAwLFxyXG5cdFx0XHRsZWdlbmRIYXNSZW5kZXJlZDogZmFsc2UsXHJcblxyXG5cdFx0XHRheGlzOiB7XHJcblx0XHRcdFx0eDoge1xyXG5cdFx0XHRcdFx0cGFkZGluZzoge2xlZnQ6IDAsIHJpZ2h0OiAwfSxcclxuXHRcdFx0XHRcdHRpY2tDb3VudDogMFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHJvdGF0ZWRQYWRkaW5nOiB7XHJcblx0XHRcdFx0bGVmdDogMzAsXHJcblx0XHRcdFx0cmlnaHQ6IDAsXHJcblx0XHRcdFx0dG9wOiA1XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR3aXRob3V0RmFkZUluOiB7fSxcclxuXHRcdFx0aW5wdXRUeXBlOiBcIlwiLFxyXG5cclxuXHRcdFx0ZGF0ZXRpbWVJZDogXCJcIixcclxuXHJcblx0XHRcdC8vIGNsaXAgaWQgc3RyaW5nXHJcblx0XHRcdGNsaXA6IHtcclxuXHRcdFx0XHRpZDogXCJcIixcclxuXHRcdFx0XHRpZFhBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdGlkWUF4aXM6IFwiXCIsXHJcblx0XHRcdFx0aWRYQXhpc1RpY2tUZXh0czogXCJcIixcclxuXHRcdFx0XHRpZEdyaWQ6IFwiXCIsXHJcblx0XHRcdFx0aWRTdWJjaGFydDogXCJcIiwgLy8gY2xpcElkRm9yU3ViY2hhcnRcclxuXHRcdFx0XHRwYXRoOiBcIlwiLFxyXG5cdFx0XHRcdHBhdGhYQXhpczogXCJcIixcclxuXHRcdFx0XHRwYXRoWUF4aXM6IFwiXCIsXHJcblx0XHRcdFx0cGF0aFhBeGlzVGlja1RleHRzOiBcIlwiLFxyXG5cdFx0XHRcdHBhdGhHcmlkOiBcIlwiXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBzdGF0dXNcclxuXHRcdFx0ZHJhZ1N0YXJ0OiBudWxsLFxyXG5cdFx0XHRkcmFnZ2luZzogZmFsc2UsXHJcblx0XHRcdGZsb3dpbmc6IGZhbHNlLFxyXG5cdFx0XHRjYW5jZWxDbGljazogZmFsc2UsXHJcblx0XHRcdG1vdXNlb3ZlcjogZmFsc2UsXHJcblx0XHRcdHJlbmRlcmVkOiBmYWxzZSxcclxuXHRcdFx0dHJhbnNpdGluZzogZmFsc2UsXHJcblx0XHRcdHJlc2l6aW5nOiBmYWxzZSwgLy8gcmVzaXplIGV2ZW50IGNhbGxlZFxyXG5cdFx0XHR0b2dnbGluZzogZmFsc2UsIC8vIGxlZ2VuZCB0b2dnbGVcclxuXHRcdFx0aGFzTmVnYXRpdmVWYWx1ZTogZmFsc2UsXHJcblx0XHRcdGhhc1Bvc2l0aXZlVmFsdWU6IHRydWUsXHJcblxyXG5cdFx0XHRvcmdBcmVhT3BhY2l0eTogXCIwLjJcIixcclxuXHJcblx0XHRcdC8vIElEIHN0cmluZ3NcclxuXHRcdFx0aGlkZGVuVGFyZ2V0SWRzOiA8c3RyaW5nW10+IFtdLFxyXG5cdFx0XHRoaWRkZW5MZWdlbmRJZHM6IDxzdHJpbmdbXT4gW10sXHJcblx0XHRcdGZvY3VzZWRUYXJnZXRJZHM6IDxzdHJpbmdbXT4gW10sXHJcblx0XHRcdGRlZm9jdXNlZFRhcmdldElkczogPHN0cmluZ1tdPiBbXSxcclxuXHJcblx0XHRcdC8vIHZhbHVlIGZvciBBcmNcclxuXHRcdFx0cmFkaXVzOiAwLFxyXG5cdFx0XHRpbm5lclJhZGl1czogMCxcclxuXHRcdFx0aW5uZXJSYWRpdXNSYXRpbzogMCxcclxuXHRcdFx0Z2F1Z2VBcmNXaWR0aDogMCxcclxuXHRcdFx0cmFkaXVzRXhwYW5kZWQ6IDAsXHJcblxyXG5cdFx0XHQvLyB4Z3JpZCBhdHRyaWJ1dGVcclxuXHRcdFx0eGdyaWRBdHRyOiB7XHJcblx0XHRcdFx0eDE6IDxudW1iZXIgfCBudWxsPiBudWxsLFxyXG5cdFx0XHRcdHgyOiA8bnVtYmVyIHwgbnVsbD4gbnVsbCxcclxuXHRcdFx0XHR5MTogPG51bWJlciB8IG51bGw+IG51bGwsXHJcblx0XHRcdFx0eTI6IDxudW1iZXIgfCBudWxsPiBudWxsXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IEVsZW1lbnQgZnJvbSBcIi4vRWxlbWVudFwiO1xyXG5pbXBvcnQgU3RhdGUgZnJvbSBcIi4vU3RhdGVcIjtcclxuXHJcbi8vIG1hcHBpbmdcclxuY29uc3QgY2xhc3NlcyA9IHtcclxuXHRlbGVtZW50OiBFbGVtZW50LFxyXG5cdHN0YXRlOiBTdGF0ZVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIHN0b3JlIGNsYXNzLlxyXG4gKiBAY2xhc3MgU3RvcmVcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RvcmUge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0T2JqZWN0LmtleXMoY2xhc3NlcykuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0dGhpc1t2XSA9IG5ldyBjbGFzc2VzW3ZdKCk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGdldFN0b3JlKG5hbWU6IHN0cmluZyk6IEVsZW1lbnQgfCBTdGF0ZSB7XHJcblx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogbWFpbiBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNwZWNpZnkgdGhlIENTUyBzZWxlY3RvciBvciB0aGUgZWxlbWVudCB3aGljaCB0aGUgY2hhcnQgd2lsbCBiZSBzZXQgdG8uIEQzIHNlbGVjdGlvbiBvYmplY3QgY2FuIGJlIHNwZWNpZmllZCBhbHNvLjxicj5cclxuXHQgKiBJZiBvdGhlciBjaGFydCBpcyBzZXQgYWxyZWFkeSwgaXQgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBuZXcgb25lIChvbmx5IG9uZSBjaGFydCBjYW4gYmUgc2V0IGluIG9uZSBlbGVtZW50KS5cclxuXHQgKiAtICoqTk9URToqKiBJbiBjYXNlIG9mIGVsZW1lbnQgZG9lc24ndCBleGlzdCBvciBub3Qgc3BlY2lmaWVkLCB3aWxsIGFkZCBhIGA8ZGl2PmAgZWxlbWVudCB0byB0aGUgYm9keS5cclxuXHQgKiBAbmFtZSBiaW5kdG9cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fGQzLnNlbGVjdGlvbnxvYmplY3R9IFtiaW5kdG89XCIjY2hhcnRcIl0gU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfEhUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gYmluZHRvLmVsZW1lbnQ9XCIjY2hhcnRcIiBTcGVjaWZ5IHRoZSBlbGVtZW50IHdoZXJlIGNoYXJ0IHdpbGwgYmUgZHJhd24uXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtiaW5kdG8uY2xhc3NuYW1lPWJiXSBTcGVjaWZ5IHRoZSBjbGFzcyBuYW1lIG9mIGJpbmQgZWxlbWVudC48YnI+XHJcblx0ICogICAgICoqTk9URToqKiBXaGVuIGNsYXNzIG5hbWUgaXNuJ3QgYGJiYCwgdGhlbiB5b3UgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgZGVmYXVsdCBDU1MgdG8gYmUgcmVuZGVyZWQgY29ycmVjdGx5LlxyXG5cdCAqIEBkZWZhdWx0ICNjaGFydFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYmluZHRvOiBcIiNteUNvbnRhaW5lclwiXHJcblx0ICpcclxuXHQgKiAvLyBvciBIVE1MRWxlbWVudFxyXG5cdCAqIGJpbmR0bzogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUNvbnRhaW5lclwiKVxyXG5cdCAqXHJcblx0ICogLy8gb3IgRDMgc2VsZWN0aW9uIG9iamVjdFxyXG5cdCAqIGJpbmR0bzogZDMuc2VsZWN0KFwiI215Q29udGFpbmVyXCIpXHJcblx0ICpcclxuXHQgKiAvLyBvciB0byBjaGFuZ2UgZGVmYXVsdCBjbGFzc25hbWVcclxuXHQgKiBiaW5kdG86IHtcclxuXHQgKiAgICBlbGVtZW50OiBcIiNjaGFydFwiLFxyXG5cdCAqICAgIGNsYXNzbmFtZTogXCJiaWxsLWJvYXJkXCIgIC8vIGV4KSA8ZGl2IGlkPSdjaGFydCcgY2xhc3M9J2JpbGwtYm9hcmQnPlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRiaW5kdG86IDxzdHJpbmd8e2VsZW1lbnQ6IHN0cmluZzsgY2xhc3NuYW1lPzogc3RyaW5nfT4gXCIjY2hhcnRcIixcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNoYXJ0IGJhY2tncm91bmQuXHJcblx0ICogQG5hbWUgYmFja2dyb3VuZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IGJhY2tncm91bmQgYmFja2dyb3VuZCBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gYmFja2dyb3VuZC5jbGFzcyBTcGVjaWZ5IHRoZSBjbGFzcyBuYW1lIGZvciBiYWNrZ3JvdW5kIGVsZW1lbnQuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmQuY29sb3IgU3BlY2lmeSB0aGUgZmlsbCBjb2xvciBmb3IgYmFja2dyb3VuZCBlbGVtZW50Ljxicj4qKk5PVEU6KiogV2lsbCBiZSBpZ25vcmVkIGlmIGBpbWdVcmxgIG9wdGlvbiBpcyBzZXQuXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGJhY2tncm91bmQuaW1nVXJsIFNwZWNpZnkgdGhlIGltYWdlIHVybCBzdHJpbmcgZm9yIGJhY2tncm91bmQuXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5CYWNrZ3JvdW5kKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYmFja2dyb3VuZDoge1xyXG5cdCAqICAgIGNsYXNzOiBcIm15Q2xhc3NcIixcclxuXHQgKiAgICBjb2xvcjogXCJyZWRcIixcclxuXHQgKlxyXG5cdCAqICAgIC8vIFNldCBpbWFnZSB1cmwgZm9yIGJhY2tncm91bmQuXHJcblx0ICogICAgLy8gSWYgc3BlY2lmaWVkLCAnY29sb3InIG9wdGlvbiB3aWxsIGJlIGlnbm9yZWQuXHJcblx0ICogICAgaW1nVXJsOiBcImh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9pbWcvbG9nby9iaWxsYm9hcmQuanMuc3ZnXCIsXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGJhY2tncm91bmQ6IDx7Y2xhc3M/OiBzdHJpbmc7IGNvbG9yPzogc3RyaW5nOyBpbWdVcmw/OiBzdHJpbmc7fT4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGUgZm9yIGNoYXJ0IGVsZW1lbnRcclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICA+IFdoZW4gaXMgZmFsc2UsIGNoYXJ0IG5vZGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkIGFmdGVyIHRoZSBheGlzIG5vZGUgaW4gRE9NIHRyZWUgaGllcmFyY2h5LlxyXG5cdCAqICA+IElzIHRvIG1ha2UgY2hhcnQgZWxlbWVudCBwb3NpdGlvbmVkIG92ZXIgYXhpcyBlbGVtZW50LlxyXG5cdCAqIEBuYW1lIGNsaXBQYXRoXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5jbGlwUGF0aClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuXHQgKiBjbGlwUGF0aDogZmFsc2VcclxuXHQgKi9cclxuXHRjbGlwUGF0aDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHN2ZyBlbGVtZW50J3MgY2xhc3MgbmFtZVxyXG5cdCAqIEBuYW1lIHN2Z1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gW3N2Z10gc3ZnIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc3ZnLmNsYXNzbmFtZV0gY2xhc3MgbmFtZSBmb3Igc3ZnIGVsZW1lbnRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIHN2Zzoge1xyXG5cdCAqICAgY2xhc3NuYW1lOiBcInRlc3RfY2xhc3NcIlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRzdmdfY2xhc3NuYW1lOiA8c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgZGVzaXJlZCBzaXplIG9mIHRoZSBjaGFydCBlbGVtZW50LlxyXG5cdCAqIElmIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSB3aWR0aCBvZiB0aGUgY2hhcnQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBwYXJlbnQgZWxlbWVudCBpdCdzIGFwcGVuZGVkIHRvLlxyXG5cdCAqIEBuYW1lIHNpemVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtzaXplXSBzaXplIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc2l6ZS53aWR0aF0gd2lkdGggb2YgdGhlIGNoYXJ0IGVsZW1lbnRcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3NpemUuaGVpZ2h0XSBoZWlnaHQgb2YgdGhlIGNoYXJ0IGVsZW1lbnRcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkNoYXJ0U2l6ZSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIHNpemU6IHtcclxuXHQgKiAgIHdpZHRoOiA2NDAsXHJcblx0ICogICBoZWlnaHQ6IDQ4MFxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRzaXplX3dpZHRoOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHNpemVfaGVpZ2h0OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgcGFkZGluZyBvZiB0aGUgY2hhcnQgZWxlbWVudC5cclxuXHQgKiBAbmFtZSBwYWRkaW5nXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbcGFkZGluZ10gcGFkZGluZyBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BhZGRpbmcudG9wXSBwYWRkaW5nIG9uIHRoZSB0b3Agb2YgY2hhcnRcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BhZGRpbmcucmlnaHRdIHBhZGRpbmcgb24gdGhlIHJpZ2h0IG9mIGNoYXJ0XHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwYWRkaW5nLmJvdHRvbV0gcGFkZGluZyBvbiB0aGUgYm90dG9tIG9mIGNoYXJ0XHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwYWRkaW5nLmxlZnRdIHBhZGRpbmcgb24gdGhlIGxlZnQgb2YgY2hhcnRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIHBhZGRpbmc6IHtcclxuXHQgKiAgIHRvcDogMjAsXHJcblx0ICogICByaWdodDogMjAsXHJcblx0ICogICBib3R0b206IDIwLFxyXG5cdCAqICAgbGVmdDogMjBcclxuXHQgKiB9XHJcblx0ICovXHJcblx0cGFkZGluZ19sZWZ0OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHBhZGRpbmdfcmlnaHQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0cGFkZGluZ190b3A6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0cGFkZGluZ19ib3R0b206IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjaGFydCByZXNpemUgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIHJlc2l6ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gW3Jlc2l6ZV0gcmVzaXplIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Jlc2l6ZS5hdXRvPXRydWVdIFNldCBjaGFydCByZXNpemUgYXV0b21hdGljYWxseSBvbiB2aWV3cG9ydCBjaGFuZ2VzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHJlc2l6ZToge1xyXG5cdCAqICAgICAgYXV0bzogZmFsc2VcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHJlc2l6ZV9hdXRvOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggZW50ZXJzIHRoZSBjaGFydC5cclxuXHQgKiBAbmFtZSBvbm92ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdCAqIG9ub3ZlcjogZnVuY3Rpb24oY3R4KSB7XHJcblx0ICogICAuLi5cclxuXHQgKiB9XHJcblx0ICovXHJcblx0b25vdmVyOiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggbGVhdmVzIHRoZSBjaGFydC5cclxuXHQgKiBAbmFtZSBvbm91dFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0ICogb25vdXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdCAqICAgLi4uXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdG9ub3V0OiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdXNlciByZXNpemVzIHRoZSBzY3JlZW4uXHJcblx0ICogQG5hbWUgb25yZXNpemVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdCAqIG9ucmVzaXplOiBmdW5jdGlvbihjdHgpIHtcclxuXHQgKiAgIC4uLlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRvbnJlc2l6ZTogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHNjcmVlbiByZXNpemUgZmluaXNoZWQuXHJcblx0ICogQG5hbWUgb25yZXNpemVkXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHQgKiBvbnJlc2l6ZWQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdCAqICAgLi4uXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdG9ucmVzaXplZDogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXHJcblx0ICogQG5hbWUgb25iZWZvcmVpbml0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHQgKiBvbmJlZm9yZWluaXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdCAqICAgLi4uXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdG9uYmVmb3JlaW5pdDogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZC5cclxuXHQgKiBAbmFtZSBvbmluaXRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdCAqIG9uaW5pdDogZnVuY3Rpb24oY3R4KSB7XHJcblx0ICogICAuLi5cclxuXHQgKiB9XHJcblx0ICovXHJcblx0b25pbml0OiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZFxyXG5cdCAqIEBuYW1lIG9uYWZ0ZXJpbml0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHQgKiBvbmFmdGVyaW5pdDogZnVuY3Rpb24oY3R4KSB7XHJcblx0ICogICAuLi5cclxuXHQgKiB9XHJcblx0ICovXHJcblx0b25hZnRlcmluaXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGNhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHJlbmRlcmVkLiBCYXNpY2FsbHksIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaW4gZWFjaCB0aW1lIHdoZW4gdGhlIGNoYXJ0IGlzIHJlZHJhd2VkLlxyXG5cdCAqIEBuYW1lIG9ucmVuZGVyZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdCAqIG9ucmVuZGVyZWQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdCAqICAgLi4uXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdG9ucmVuZGVyZWQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uIChpbiBtaWxsaXNlY29uZHMpIGZvciBjaGFydCBhbmltYXRpb24uPGJyPjxicj5cclxuXHQgKiAtICoqTk9URToqKiBJZiBgMCBgb3IgYG51bGxgIHNldCwgdHJhbnNpdGlvbiB3aWxsIGJlIHNraXBwZWQuIFNvLCB0aGlzIG1ha2VzIGluaXRpYWwgcmVuZGVyaW5nIGZhc3RlciBlc3BlY2lhbGx5IGluIGNhc2UgeW91IGhhdmUgYSBsb3Qgb2YgZGF0YS5cclxuXHQgKiBAbmFtZSB0cmFuc2l0aW9uXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbdHJhbnNpdGlvbl0gdHJhbnNpdGlvbiBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3RyYW5zaXRpb24uZHVyYXRpb249MzUwXSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIHRyYW5zaXRpb246IHtcclxuXHQgKiAgICBkdXJhdGlvbjogNTAwXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdHRyYW5zaXRpb25fZHVyYXRpb246IDM1MCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHNjYXR0ZXIgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIHNjYXR0ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtzY2F0dGVyXSBzY2F0dGVyIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NjYXR0ZXIuemVyb2Jhc2VkPWZhbHNlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gc2NhdHRlciBjaGFydC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBzY2F0dGVyOiB7XHJcblx0ICogICAgICBjb25uZWN0TnVsbDogdHJ1ZSxcclxuXHQgKiAgICAgIHN0ZXA6IHtcclxuXHQgKiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcclxuXHQgKiAgICAgIHBvaW50OiBmYWxzZSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcclxuXHQgKiAgICAgIHBvaW50OiBbXHJcblx0ICogICAgICAgICAgXCJkYXRhMVwiLCBcImRhdGEzXCJcclxuXHQgKiAgICAgIF0sXHJcblx0ICpcclxuXHQgKiAgICAgIHplcm9iYXNlZDogZmFsc2VcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHNjYXR0ZXJfemVyb2Jhc2VkOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHBsdWdpbnNcclxuXHQgKiBAbmFtZSBwbHVnaW5zXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgcGx1Z2luczogW1xyXG5cdCAqICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXHJcblx0ICogICAgbmV3IFBsdWdpbkEoKSxcclxuXHQgKiAgICAuLi5cclxuXHQgKiBdXHJcblx0ICovXHJcblx0cGx1Z2luczogW10sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnRyb2wgdGhlIHJlbmRlciB0aW1pbmdcclxuXHQgKiBAbmFtZSByZW5kZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtyZW5kZXJdIHJlbmRlciBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZW5kZXIubGF6eT10cnVlXSBNYWtlIHRvIG5vdCByZW5kZXIgYXQgaW5pdGlhbGl6YXRpb24gKGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIGJpbmQgZWxlbWVudCdzIHZpc2liaWxpdHkgaXMgaGlkZGVuKS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZW5kZXIub2JzZXJ2ZT10cnVlXSBPYnNlcnZlIGJpbmQgZWxlbWVudCdzIHZpc2liaWxpdHkoYGRpc3BsYXlgIG9yIGB2aXNpYmxpdHlgIGlubGluZSBjc3MgcHJvcGVydHkgb3IgY2xhc3MgdmFsdWUpICYgcmVuZGVyIHdoZW4gaXMgdmlzaWJsZSBhdXRvbWF0aWNhbGx5IChmb3IgSUVzLCBvbmx5IHdvcmtzIElFMTErKS4gV2hlbiBzZXQgdG8gKipmYWxzZSoqLCBjYWxsIFtgLmZsdXNoKClgXSguL0NoYXJ0Lmh0bWwjZmx1c2gpIHRvIHJlbmRlci5cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkxhenlSZW5kZXIpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgcmVuZGVyOiB7XHJcblx0ICogICAgbGF6eTogdHJ1ZSxcclxuXHQgKiAgICBvYnNlcnZlOiB0cnVlXHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKlx0Ly8gPCEtLSByZW5kZXIubGF6eSB3aWxsIGRldGVjdCB2aXNpYmlsaXR5IGRlZmluZWQgLS0+XHJcblx0ICogIC8vIChhKSA8ZGl2IGlkPSdjaGFydCcgY2xhc3M9J2hpZGUnPjwvZGl2PlxyXG5cdCAqICAvLyAoYikgPGRpdiBpZD0nY2hhcnQnIHN0eWxlPSdkaXNwbGF5Om5vbmUnPjwvZGl2PlxyXG5cdCAqXHJcblx0ICogIC8vIHJlbmRlci5sYXp5IGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIGVsZW1lbnQgaXMgaGlkZGVuXHJcblx0ICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIGNoYXJ0IHdpbGwgYmUgcmVuZGVyZWQgYXV0b21hdGljYWxseSB3aGVuIGVsZW1lbnQncyB2aXNpYmlsaXR5IGNoYW5nZXNcclxuXHQgKiAgLy8gTm90ZTogd29ya3Mgb25seSBmb3IgaW5saW5lZCBjc3MgcHJvcGVydHkgb3IgY2xhc3MgYXR0cmlidXRlIGNoYW5nZXNcclxuXHQgKiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0JykuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpICAvLyAoYSlcclxuXHQgKiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7ICAvLyAoYilcclxuXHQgKlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICpcdC8vIGNoYXJ0IHdvbid0IGJlIHJlbmRlcmVkIGFuZCBub3Qgb2JzZXJ2aW5nIGJpbmQgZWxlbWVudCdzIHZpc2libGl0eSBjaGFuZ2VzXHJcblx0ICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuXHQgKiAgICAgcmVuZGVyOiB7XHJcblx0ICogICAgICAgICAgbGF6eTogdHJ1ZSxcclxuXHQgKiAgICAgICAgICBvYnNlcnZlOiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIGNhbGwgYXQgYW55IHBvaW50IHdoZW4geW91IHdhbnQgdG8gcmVuZGVyXHJcblx0ICogIGNoYXJ0LmZsdXNoKCk7XHJcblx0ICovXHJcblx0cmVuZGVyOiA8e2xhenk/OiBib29sZWFuOyBvYnNlcnZlPzogYm9vbGVhbjt9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyByZWN0YW5nbGVzIGluc2lkZSB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgYXhpcywgc3RhcnQsIGVuZCBhbmQgY2xhc3MuXHJcblx0ICogVGhlIGtleXMgc3RhcnQsIGVuZCBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLlxyXG5cdCAqIGF4aXMgbXVzdCBiZSB4LCB5IG9yIHkyLiBzdGFydCBhbmQgZW5kIHNob3VsZCBiZSB0aGUgdmFsdWUgd2hlcmUgcmVnaW9ucyBzdGFydCBhbmQgZW5kLlxyXG5cdCAqIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBlZGdlIHZhbHVlcyB3aWxsIGJlIHVzZWQuXHJcblx0ICogSWYgdGltZXNlcmllcyB4IGF4aXMsIGRhdGUgc3RyaW5nLCBEYXRlIG9iamVjdCBhbmQgdW5peHRpbWUgaW50ZWdlciBjYW4gYmUgdXNlZC5cclxuXHQgKiBJZiBjbGFzcyBpcyBzZXQsIHRoZSByZWdpb24gZWxlbWVudCB3aWxsIGhhdmUgaXQgYXMgY2xhc3MuXHJcblx0ICogQG5hbWUgcmVnaW9uc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IFtdXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgcmVnaW9uczogW1xyXG5cdCAqICAgIHtcclxuXHQgKiAgICAgIGF4aXM6IFwieFwiLFxyXG5cdCAqICAgICAgc3RhcnQ6IDEsXHJcblx0ICogICAgICBlbmQ6IDQsXHJcblx0ICogICAgICBjbGFzczogXCJyZWdpb24tMS00XCJcclxuXHQgKiAgICB9XHJcblx0ICogIF1cclxuXHQgKi9cclxuXHRyZWdpb25zOiA8e2F4aXM/OiBzdHJpbmc7IHN0YXJ0PzogbnVtYmVyOyBlbmQ/OiBudW1iZXI7IGNsYXNzPzogc3RyaW5nO31bXT4gW11cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge0NoYXJ0VHlwZXN9IGZyb20gXCIuLi8uLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIGRhdGEgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBDb252ZXJ0cyBkYXRhIGlkIHZhbHVlXHJcblx0ICogQG5hbWUgZGF0YeKApGlkQ29udmVydGVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkOyB9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgaWRDb252ZXJ0ZXI6IGZ1bmN0aW9uKGlkKSB7XHJcblx0ICogICAgICAgLy8gd2hlbiBpZCBpcyAnZGF0YTEnLCBjb252ZXJ0cyB0byBiZSAnZGF0YTInXHJcblx0ICogICAgICAgLy8gJ2RhdGEyJyBzaG91bGQgYmUgZ2l2ZW4gYXMgdGhlIGluaXRpYWwgZGF0YSB2YWx1ZVxyXG5cdCAqICAgICAgIGlmIChpZCA9PT0gXCJkYXRhMVwiKSB7XHJcblx0ICogICAgICAgICAgcmV0dXJuIFwiZGF0YTJcIjtcclxuXHQgKiAgICAgICB9IGVsc2Uge1xyXG5cdCAqICAgICAgICAgIHJldHVybiBpZDtcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2lkQ29udmVydGVyOiBpZCA9PiBpZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGN1c3RvbSBkYXRhIG5hbWUuXHJcblx0ICogQG5hbWUgZGF0YeKApG5hbWVzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU5hbWUpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBuYW1lczoge1xyXG5cdCAqICAgICBkYXRhMTogXCJEYXRhIE5hbWUgMVwiLFxyXG5cdCAqICAgICBkYXRhMjogXCJEYXRhIE5hbWUgMlwiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfbmFtZXM6IDx7W2tleTogc3RyaW5nXTogc3RyaW5nfT4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjdXN0b20gZGF0YSBjbGFzcy48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlIGVsZW1lbnQgZyBmb3IgdGhlIGRhdGEgaGFzIGFuIGFkZGl0aW9uYWwgY2xhc3MgdGhhdCBoYXMgdGhlIHByZWZpeCAnYmItdGFyZ2V0LScgKGVnLiBiYi10YXJnZXQtYWRkaXRpb25hbC1kYXRhMS1jbGFzcykuXHJcblx0ICogQG5hbWUgZGF0YeKApGNsYXNzZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNsYXNzZXM6IHtcclxuXHQgKiAgICAgZGF0YTE6IFwiYWRkaXRpb25hbC1kYXRhMS1jbGFzc1wiLFxyXG5cdCAqICAgICBkYXRhMjogXCJhZGRpdGlvbmFsLWRhdGEyLWNsYXNzXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9jbGFzc2VzOiA8e1trZXk6IHN0cmluZ106IHN0cmluZ30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2hhcnQgdHlwZSBhdCBvbmNlLjxicj48YnI+XHJcblx0ICogSWYgdGhpcyBvcHRpb24gaXMgc3BlY2lmaWVkLCB0aGUgdHlwZSB3aWxsIGJlIGFwcGxpZWQgdG8gZXZlcnkgZGF0YS4gVGhpcyBzZXR0aW5nIGNhbiBiZSBvdmVyd3JpdHRlbiBieSBkYXRhLnR5cGVzLjxicj48YnI+XHJcblx0ICogKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogLSBhcmVhXHJcblx0ICogLSBhcmVhLWxpbmUtcmFuZ2VcclxuXHQgKiAtIGFyZWEtc3BsaW5lXHJcblx0ICogLSBhcmVhLXNwbGluZS1yYW5nZVxyXG5cdCAqIC0gYXJlYS1zdGVwXHJcblx0ICogLSBiYXJcclxuXHQgKiAtIGJ1YmJsZVxyXG5cdCAqIC0gZG9udXRcclxuXHQgKiAtIGdhdWdlXHJcblx0ICogLSBsaW5lXHJcblx0ICogLSBwaWVcclxuXHQgKiAtIHJhZGFyXHJcblx0ICogLSBzY2F0dGVyXHJcblx0ICogLSBzcGxpbmVcclxuXHQgKiAtIHN0ZXBcclxuXHQgKiBAbmFtZSBkYXRh4oCkdHlwZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCBsaW5lXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgdHlwZTogXCJiYXJcIlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3R5cGU6IDxDaGFydFR5cGVzfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2hhcnQgdHlwZSBmb3IgZWFjaCBkYXRhLjxicj5cclxuXHQgKiBUaGlzIHNldHRpbmcgb3ZlcndyaXRlcyBkYXRhLnR5cGUgc2V0dGluZy5cclxuXHQgKiAtICoqTk9URToqKiBgcmFkYXJgIHR5cGUgY2FuJ3QgYmUgY29tYmluZWQgd2l0aCBvdGhlciB0eXBlcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkdHlwZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHR5cGVzOiB7XHJcblx0ICogICAgIGRhdGExOiBcImJhclwiLFxyXG5cdCAqICAgICBkYXRhMjogXCJzcGxpbmVcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3R5cGVzOiA8e1trZXk6IHN0cmluZ106IENoYXJ0VHlwZXN9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogIFRoaXMgb3B0aW9uIGNoYW5nZXMgdGhlIG9yZGVyIG9mIHN0YWNraW5nIGRhdGEgYW5kIHBpZWNlcyBvZiBwaWUvZG9udXQuXHJcblx0ICogIC0gSWYgYG51bGxgIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB0aGUgb3JkZXIgdGhlIGRhdGEgbG9hZGVkLlxyXG5cdCAqICAtIElmIGZ1bmN0aW9uIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB1c2VkIGFzIFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKTxicj48YnI+XHJcblx0ICpcclxuXHQgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIG9yZGVyXHJcblx0ICogIC0gYGFzY2A6IEluIGFzY2VuZGluZyBvcmRlclxyXG5cdCAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgbG9hZCBvcmRlclxyXG5cdCAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvblxyXG5cdCAqIEBuYW1lIGRhdGHigKRvcmRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ3xGdW5jdGlvbnxudWxsfVxyXG5cdCAqIEBkZWZhdWx0IGRlc2NcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhT3JkZXIpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAvLyBpbiBkZXNjZW5kaW5nIG9yZGVyIChkZWZhdWx0KVxyXG5cdCAqICAgb3JkZXI6IFwiZGVzY1wiXHJcblx0ICpcclxuXHQgKiAgIC8vIGluIGFzY2VuZGluZyBvcmRlclxyXG5cdCAqICAgb3JkZXI6IFwiYXNjXCJcclxuXHQgKlxyXG5cdCAqICAgLy8ga2VlcHMgZGF0YSBpbnB1dCBvcmRlclxyXG5cdCAqICAgb3JkZXI6IG51bGxcclxuXHQgKlxyXG5cdCAqICAgLy8gc3BlY2lmeWluZyBzb3J0IGZ1bmN0aW9uXHJcblx0ICogICBvcmRlcjogZnVuY3Rpb24oYSwgYikge1xyXG5cdCAqICAgICAgIC8vIHBhcmFtIGRhdGEgcGFzc2VkIGZvcm1hdFxyXG5cdCAqICAgICAgIHtcclxuXHQgKiAgICAgICAgICBpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBbXHJcblx0ICogICAgICAgICAgICAgIHt4OiA1LCB2YWx1ZTogMjUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNSwgbmFtZTogXCJkYXRhMVwifSxcclxuXHQgKiAgICAgICAgICAgICAgLi4uXHJcblx0ICogICAgICAgICAgXVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9vcmRlcjogPFwiZGVzY1wifFwiYXNjXCJ8RnVuY3Rpb258bnVsbD4gXCJkZXNjXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjb2xvciBjb252ZXJ0ZXIgZnVuY3Rpb24uPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBzaG91bGQgYSBmdW5jdGlvbiBhbmQgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBjb2xvciAoZS5nLiAnI2ZmMDAwMCcpIGFuZCBkIHRoYXQgaGFzIGRhdGEgcGFyYW1ldGVycyBsaWtlIGlkLCB2YWx1ZSwgaW5kZXgsIGV0Yy4gQW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBjb2xvciAoZS5nLiAnIzAwZmYwMCcpLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRjb2xvclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFDb2xvcilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNvbG9yOiBmdW5jdGlvbihjb2xvciwgZCkgeyAuLi4gfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2NvbG9yOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjb2xvciBmb3IgZWFjaCBkYXRhLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRjb2xvcnNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNvbG9yczoge1xyXG5cdCAqICAgICBkYXRhMTogXCIjZmYwMDAwXCIsXHJcblx0ICogICAgIGRhdGEyOiBmdW5jdGlvbihkKSB7XHJcblx0ICogICAgICAgIHJldHVybiBcIiMwMDBcIjtcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgICAuLi5cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9jb2xvcnM6IDx7W2tleTogc3RyaW5nXTogc3RyaW5nfCgoKSA9PiBzdHJpbmcpO30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGVhY2ggZGF0YSB3aGVuIHRoZSBjaGFydCBhcHBlYXJzLjxicj48YnI+XHJcblx0ICogSWYgdHJ1ZSBzcGVjaWZpZWQsIGFsbCBvZiBkYXRhIHdpbGwgYmUgaGlkZGVuLiBJZiBtdWx0aXBsZSBpZHMgc3BlY2lmaWVkIGFzIGFuIGFycmF5LCB0aG9zZSB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiBAbmFtZSBkYXRh4oCkaGlkZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW58QXJyYXl9XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIC8vIGFsbCBvZiBkYXRhIHdpbGwgYmUgaGlkZGVuXHJcblx0ICogICBoaWRlOiB0cnVlXHJcblx0ICpcclxuXHQgKiAgIC8vIHNwZWNpZmllZCBkYXRhIHdpbGwgYmUgaGlkZGVuXHJcblx0ICogICBoaWRlOiBbXCJkYXRhMVwiLCAuLi5dXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfaGlkZTogPHN0cmluZ1tdfGJvb2xlYW4+IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBGaWx0ZXIgdmFsdWVzIHRvIGJlIHNob3duXHJcblx0ICogVGhlIGRhdGEgdmFsdWUgaXMgdGhlIHNhbWUgYXMgdGhlIHJldHVybmVkIGJ5IGAuZGF0YSgpYC5cclxuXHQgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlclxyXG5cdCAqIEBuYW1lIGRhdGHigKRmaWx0ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIC8vIGZpbHRlciBmb3IgaWQgdmFsdWVcclxuXHQgKiAgIGZpbHRlcjogZnVuY3Rpb24odikge1xyXG5cdCAqICAgICAgLy8gdjogW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBbXHJcblx0ICogICAgICAvLyAgICAgIHt4OiAwLCB2YWx1ZTogMTMwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogMH0sIC4uLl1cclxuXHQgKiAgICAgIC8vICAgIH0sIC4uLl1cclxuXHQgKiAgICAgIHJldHVybiB2LmlkICE9PSBcImRhdGExXCI7XHJcblx0ICogICB9XHJcblx0ICovXHJcblx0ZGF0YV9maWx0ZXI6IDwoKCkgPT4gYm9vbGVhbil8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGNhbGxiYWNrIGZvciBjbGljayBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuXHQgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gZWFjaCBkYXRhIHBvaW50IGNsaWNrZWQgYW5kIHdpbGwgcmVjZWl2ZSBgZGAgYW5kIGVsZW1lbnQgYXMgdGhlIGFyZ3VtZW50cy5cclxuXHQgKiAtIGBkYCBpcyB0aGUgZGF0YSBjbGlja2VkIGFuZCBlbGVtZW50IGlzIHRoZSBlbGVtZW50IGNsaWNrZWQuXHJcblx0ICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcblx0ICogLSBJbiB0aGlzIGNhbGxiYWNrLCBgdGhpc2Agd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbmNsaWNrXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgICBvbmNsaWNrOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XHJcblx0ICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX29uY2xpY2s6ICgpID0+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbW91c2UvdG91Y2ggb3ZlciBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuXHQgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvbnRvIGVhY2ggZGF0YSBwb2ludCBhbmQgd2lsbCByZWNlaXZlIGBkYCBhbmQgYGVsZW1lbnRgIGFzIHRoZSBhcmd1bWVudC5cclxuXHQgKiAtIGBkYCBpcyB0aGUgZGF0YSB3aGVyZSBtb3VzZSBjdXJzb3IgbW92ZXMgb250by5cclxuXHQgKiAtIGBlbGVtZW50YCBpcyB0aGUgY3VycmVudCBpbnRlcmFjdGluZyBzdmcgZWxlbWVudC5cclxuXHQgKiAtIEluIHRoaXMgY2FsbGJhY2ssIGB0aGlzYCB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXHJcblx0ICogQG5hbWUgZGF0YeKApG9ub3ZlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb25vdmVyOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0fVxyXG5cdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9vbm92ZXI6ICgpID0+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbW91c2UvdG91Y2ggb3V0IGV2ZW50IG9uIGVhY2ggZGF0YSBwb2ludC48YnI+PGJyPlxyXG5cdCAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBtb3VzZSBjdXJzb3Igb3IgdmlhIHRvdWNoIG1vdmVzIG91dCBlYWNoIGRhdGEgcG9pbnQgYW5kIHdpbGwgcmVjZWl2ZSBgZGAgYXMgdGhlIGFyZ3VtZW50LlxyXG5cdCAqIC0gYGRgIGlzIHRoZSBkYXRhIHdoZXJlIG1vdXNlIGN1cnNvciBtb3ZlcyBvdXQuXHJcblx0ICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcblx0ICogLSBJbiB0aGlzIGNhbGxiYWNrLCBgdGhpc2Agd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbm91dFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb25vdXQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuXHQgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDR9XHJcblx0ICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX29ub3V0OiAoKSA9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIG1pbmltdW0gZGF0YVxyXG5cdCAqIC0gKipOT1RFOioqIEZvciAnYXJlYS1saW5lLXJhbmdlJyBhbmQgJ2FyZWEtc3BsaW5lLXJhbmdlJywgYG1pZGAgZGF0YSB3aWxsIGJlIHRha2VuIGZvciB0aGUgY29tcGFyaXNvblxyXG5cdCAqIEBuYW1lIGRhdGHigKRvbm1pblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgb25taW46IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHQgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxyXG5cdCAqICAgIC4uLlxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0ZGF0YV9vbm1pbjogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3IgbWF4aW11bSBkYXRhXHJcblx0ICogLSAqKk5PVEU6KiogRm9yICdhcmVhLWxpbmUtcmFuZ2UnIGFuZCAnYXJlYS1zcGxpbmUtcmFuZ2UnLCBgbWlkYCBkYXRhIHdpbGwgYmUgdGFrZW4gZm9yIHRoZSBjb21wYXJpc29uXHJcblx0ICogQG5hbWUgZGF0YeKApG9ubWF4XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuT25NaW5NYXhDYWxsYmFjaylcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBvbm1heDogZnVuY3Rpb24oZGF0YSkge1xyXG5cdCAqICAgIC8vIGRhdGEgLSBleCkgW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLiBdXHJcblx0ICogICAgLi4uXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRkYXRhX29ubWF4OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIExvYWQgYSBDU1Ygb3IgSlNPTiBmaWxlIGZyb20gYSBVUkwuIE5PVEUgdGhhdCB0aGlzIHdpbGwgbm90IHdvcmsgaWYgbG9hZGluZyB2aWEgdGhlIFwiZmlsZTovL1wiIHByb3RvY29sIGFzIHRoZSBtb3N0IGJyb3dzZXJzIHdpbGwgYmxvY2sgWE1MSFRUUFJlcXVlc3RzLlxyXG5cdCAqIEBuYW1lIGRhdGHigKR1cmxcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuTG9hZERhdGEpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIHVybDogXCIvZGF0YS90ZXN0LmNzdlwiXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfdXJsOiA8c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBYSFIgaGVhZGVyIHZhbHVlXHJcblx0ICogLSAqKk5PVEU6KiogU2hvdWxkIGJlIHVzZWQgd2l0aCBgZGF0YS51cmxgIG9wdGlvblxyXG5cdCAqIEBuYW1lIGRhdGHigKRoZWFkZXJzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1hNTEh0dHBSZXF1ZXN0L3NldFJlcXVlc3RIZWFkZXJcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgdXJsOiBcIi9kYXRhL3Rlc3QuY3N2XCIsXHJcblx0ICogICAgIGhlYWRlcnM6IHtcclxuXHQgKiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3htbFwiLFxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2hlYWRlcnM6IDxvYmplY3R8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFBhcnNlIGEgSlNPTiBvYmplY3QgZm9yIGRhdGEuIFNlZSBhbHNvIGRhdGEua2V5cy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkanNvblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW2RhdGHigKRrZXlzXSgjLmRhdGElMjVFMiUyNTgwJTI1QTRrZXlzKVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkpTT05EYXRhKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgICBqc29uOiBbXHJcblx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUxLmNvbVwiLCB1cGxvYWQ6IDIwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDQwMH0sXHJcblx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUyLmNvbVwiLCB1cGxvYWQ6IDEwMCwgZG93bmxvYWQ6IDMwMCwgdG90YWw6IDQwMH0sXHJcblx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGUzLmNvbVwiLCB1cGxvYWQ6IDMwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDUwMH0sXHJcblx0ICogICAgICAge25hbWU6IFwid3d3LnNpdGU0LmNvbVwiLCB1cGxvYWQ6IDQwMCwgZG93bmxvYWQ6IDEwMCwgdG90YWw6IDUwMH1cclxuXHQgKiAgICAgXSxcclxuXHQgKiAgICAga2V5czoge1xyXG5cdCAqICAgICAgIC8vIHg6IFwibmFtZVwiLCAvLyBpdCdzIHBvc3NpYmxlIHRvIHNwZWNpZnkgJ3gnIHdoZW4gY2F0ZWdvcnkgYXhpc1xyXG5cdCAqICAgICAgIHZhbHVlOiBbXCJ1cGxvYWRcIiwgXCJkb3dubG9hZFwiXVxyXG5cdCAqICAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfanNvbjogPG9iamVjdFtdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBMb2FkIGRhdGEgZnJvbSBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXksIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgY29udGFpbmluZyB0aGUgZGF0YSBuYW1lcywgdGhlIGZvbGxvd2luZyBjb250YWluaW5nIHJlbGF0ZWQgZGF0YSBpbiB0aGF0IG9yZGVyLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRyb3dzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuUm93T3JpZW50ZWREYXRhKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgcm93czogW1xyXG5cdCAqICAgICBbXCJBXCIsIFwiQlwiLCBcIkNcIl0sXHJcblx0ICogICAgIFs5MCwgMTIwLCAzMDBdLFxyXG5cdCAqICAgICBbNDAsIDE2MCwgMjQwXSxcclxuXHQgKiAgICAgWzUwLCAyMDAsIDI5MF0sXHJcblx0ICogICAgIFsxMjAsIDE2MCwgMjMwXSxcclxuXHQgKiAgICAgWzgwLCAxMzAsIDMwMF0sXHJcblx0ICogICAgIFs5MCwgMjIwLCAzMjBdXHJcblx0ICogICBdXHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogLy8gZm9yICdyYW5nZScgdHlwZXMoJ2FyZWEtbGluZS1yYW5nZScgb3IgJ2FyZWEtc3BsaW5lLXJhbmdlJyksIGRhdGEgc2hvdWxkIGNvbnRhaW46XHJcblx0ICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxyXG5cdCAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ2hpZ2gnLCAnbWlkJyBhbmQgJ2xvdycga2V5IHZhbHVlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgcm93czogW1xyXG5cdCAqICAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuXHQgKiAgICAgIFtcclxuXHQgKiAgICAgICAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9LCAxMjBcclxuXHQgKiAgICAgICAgWzE1MCwgMTQwLCAxMTBdLCAxMjBcclxuXHQgKiAgICAgIF0sXHJcblx0ICogICAgICBbWzE1NSwgMTMwLCAxMTVdLCA1NV0sXHJcblx0ICogICAgICBbWzE2MCwgMTM1LCAxMjBdLCA2MF1cclxuXHQgKiAgIF0sXHJcblx0ICogICB0eXBlczoge1xyXG5cdCAqICAgICAgIGRhdGExOiBcImFyZWEtbGluZS1yYW5nZVwiLFxyXG5cdCAqICAgICAgIGRhdGEyOiBcImxpbmVcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKlxyXG5cdCAqIC8vIGZvciAnYnViYmxlJyB0eXBlLCBkYXRhIGNhbiBjb250YWluIGRpbWVuc2lvbiB2YWx1ZTpcclxuXHQgKiAvLyAtIGFuIGFycmF5IG9mIFt5LCB6XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuXHQgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICd5JyBhbmQgJ3onIGtleSB2YWx1ZVxyXG5cdCAqIC8vICd5JyBpcyBmb3IgeSBheGlzIGNvb3JkaW5hdGlvbiBhbmQgJ3onIGlzIHRoZSBidWJibGUgcmFkaXVzIHZhbHVlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgcm93czogW1xyXG5cdCAqICAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuXHQgKiAgICAgIFtcclxuXHQgKiAgICAgICAgLy8gb3Ige3k6MTAsIHo6IDE0MH0sIDEyMFxyXG5cdCAqICAgICAgICBbMTAsIDE0MF0sIDEyMFxyXG5cdCAqICAgICAgXSxcclxuXHQgKiAgICAgIFtbMTAwLCAzMF0sIDU1XSxcclxuXHQgKiAgICAgIFtbNTAsIDEwMF0sIDYwXVxyXG5cdCAqICAgXSxcclxuXHQgKiAgIHR5cGVzOiB7XHJcblx0ICogICAgICAgZGF0YTE6IFwiYnViYmxlXCIsXHJcblx0ICogICAgICAgZGF0YTI6IFwibGluZVwiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfcm93czogPChzdHJpbmd8bnVtYmVyKVtdW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIExvYWQgZGF0YSBmcm9tIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSwgd2l0aCBlYWNoIGVsZW1lbnQgY29udGFpbmluZyBhbiBhcnJheSBjb25zaXN0aW5nIG9mIGEgZGF0dW0gbmFtZSBhbmQgYXNzb2NpYXRlZCBkYXRhIHZhbHVlcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkY29sdW1uc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkNvbHVtbk9yaWVudGVkRGF0YSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgIFtcImRhdGExXCIsIDMwLCAyMCwgNTAsIDQwLCA2MCwgNTBdLFxyXG5cdCAqICAgICAgW1wiZGF0YTJcIiwgMjAwLCAxMzAsIDkwLCAyNDAsIDEzMCwgMjIwXSxcclxuXHQgKiAgICAgIFtcImRhdGEzXCIsIDMwMCwgMjAwLCAxNjAsIDQwMCwgMjUwLCAyNTBdXHJcblx0ICogICBdXHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogLy8gZm9yICdyYW5nZScgdHlwZXMoJ2FyZWEtbGluZS1yYW5nZScgb3IgJ2FyZWEtc3BsaW5lLXJhbmdlJyksIGRhdGEgc2hvdWxkIGNvbnRhaW46XHJcblx0ICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxyXG5cdCAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ2hpZ2gnLCAnbWlkJyBhbmQgJ2xvdycga2V5IHZhbHVlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgW1wiZGF0YTFcIixcclxuXHQgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sICAvLyBvciB7aGlnaDoxNTAsIG1pZDogMTQwLCBsb3c6IDExMH1cclxuXHQgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sXHJcblx0ICogICAgICAgICAgWzE1MCwgMTQwLCAxMTBdXHJcblx0ICogICAgICBdXHJcblx0ICogICBdLFxyXG5cdCAqICAgdHlwZTogXCJhcmVhLWxpbmUtcmFuZ2VcIlxyXG5cdCAqIH1cclxuXHQgKlxyXG5cdCAqIC8vIGZvciAnYnViYmxlJyB0eXBlLCBkYXRhIGNhbiBjb250YWluIGRpbWVuc2lvbiB2YWx1ZTpcclxuXHQgKiAvLyAtIGFuIGFycmF5IG9mIFt5LCB6XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuXHQgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICd5JyBhbmQgJ3onIGtleSB2YWx1ZVxyXG5cdCAqIC8vICd5JyBpcyBmb3IgeSBheGlzIGNvb3JkaW5hdGlvbiBhbmQgJ3onIGlzIHRoZSBidWJibGUgcmFkaXVzIHZhbHVlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgW1wiZGF0YTFcIixcclxuXHQgKiAgICAgICAgICBbMTAsIDE0MF0sICAvLyBvciB7eToxMCwgejogMTQwfVxyXG5cdCAqICAgICAgICAgIFsxMDAsIDMwXSxcclxuXHQgKiAgICAgICAgICBbNTAsIDEwMF1cclxuXHQgKiAgICAgIF1cclxuXHQgKiAgIF0sXHJcblx0ICogICB0eXBlOiBcImJ1YmJsZVwiXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfY29sdW1uczogPChzdHJpbmd8bnVtYmVyKVtdW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVzZWQgaWYgbG9hZGluZyBKU09OIHZpYSBkYXRhLnVybC5cclxuXHQgKiAtICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqICAgLSBqc29uXHJcblx0ICogICAtIGNzdlxyXG5cdCAqICAgLSB0c3ZcclxuXHQgKiBAbmFtZSBkYXRh4oCkbWltZVR5cGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgY3N2XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIlxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX21pbWVUeXBlOiA8XCJjc3ZcInxcImpzb25cInxcInRzdlwiPiBcImNzdlwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBDaG9vc2Ugd2hpY2ggSlNPTiBvYmplY3Qga2V5cyBjb3JyZXNwb25kIHRvIGRlc2lyZWQgZGF0YS5cclxuXHQgKiAtICoqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS5cclxuXHQgKiBAbmFtZSBkYXRh4oCka2V5c1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAganNvbjogW1xyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMS5jb21cIiwgdXBsb2FkOiAyMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA0MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxyXG5cdCAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlNC5jb21cIiwgdXBsb2FkOiA0MDAsIGRvd25sb2FkOiAxMDAsIHRvdGFsOiA1MDB9XHJcblx0ICogICAgIF0sXHJcblx0ICogICAgIGtleXM6IHtcclxuXHQgKiAgICAgICAvLyB4OiBcIm5hbWVcIiwgLy8gaXQncyBwb3NzaWJsZSB0byBzcGVjaWZ5ICd4JyB3aGVuIGNhdGVnb3J5IGF4aXNcclxuXHQgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cclxuXHQgKiAgICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2tleXM6IDx7eD86IHN0cmluZzsgdmFsdWU/OiBzdHJpbmdbXX18dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0ZXh0IGxhYmVsIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZXJlJ3Mgbm8gZGF0YSB0byBzaG93LlxyXG5cdCAqIC0gZXguIFRvZ2dsaW5nIGFsbCB2aXNpYmxlIGRhdGEgdG8gbm90IGJlIHNob3duLCB1bmxvYWRpbmcgYWxsIGN1cnJlbnQgZGF0YSwgZXRjLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRlbXB0eeKApGxhYmVs4oCkdGV4dFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCBcIlwiXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBlbXB0eToge1xyXG5cdCAqICAgICBsYWJlbDoge1xyXG5cdCAqICAgICAgIHRleHQ6IFwiTm8gRGF0YVwiXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9lbXB0eV9sYWJlbF90ZXh0OiBcIlwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGNvbG9yIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGNvbG9yIG9mIHRoZSBkYXRhIHZhbHVlc1xyXG5cdCAqIEBuYW1lIGNvbG9yXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb2xvciBjb2xvciBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xvYmplY3R8RnVuY3Rpb259IFtjb2xvci5vbm92ZXJdIFNldCB0aGUgY29sb3IgdmFsdWUgZm9yIGVhY2ggZGF0YSBwb2ludCB3aGVuIG1vdXNlL3RvdWNoIG9ub3ZlciBldmVudCBvY2N1cnMuXHJcblx0ICogQHByb3BlcnR5IHtBcnJheXxudWxsfSBbY29sb3IucGF0dGVybj1bXV0gU2V0IGN1c3RvbSBjb2xvciBwYXR0ZXJuLiBQYXNzaW5nIGBudWxsYCB3aWxsIG5vdCBzZXQgYSBjb2xvciBmb3IgdGhlc2UgZWxlbWVudHMsIHdoaWNoIHJlcXVpcmVzIHRoZSB1c2FnZSBvZiBjdXN0b20gQ1NTLWJhc2VkIHRoZW1pbmcgdG8gd29yay5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbY29sb3IudGlsZXNdIGlmIGRlZmluZWQsIGFsbG93cyB1c2Ugc3ZnJ3MgcGF0dGVybnMgdG8gZmlsbCBkYXRhIGFyZWEuIEl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgW1NWR1BhdHRlcm5FbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU1ZHUGF0dGVybkVsZW1lbnQpLlxyXG5cdCAqICAtICoqTk9URToqKiBUaGUgcGF0dGVybiBlbGVtZW50J3MgaWQgd2lsbCBiZSBkZWZpbmVkIGFzIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLSRDT0xPUi1WQUxVRWAuPGJyPlxyXG5cdCAqICAgIGV4LiBXaGVuIGNvbG9yIHBhdHRlcm4gdmFsdWUgaXMgYFsncmVkJywgJyNmZmYnXWAgYW5kIGRlZmluZWQgMiBwYXR0ZXJucyx0aGVuIGlkcyBmb3IgcGF0dGVybiBlbGVtZW50cyBhcmU6PGJyPlxyXG5cdCAqICAgIC0gYGJiLWNvbG9yaXplLXBhdHRlcm4tcmVkYFxyXG5cdCAqICAgIC0gYGJiLWNvbG9yaXplLXBhdHRlcm4tZmZmYFxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbY29sb3IudGhyZXNob2xkXSBjb2xvciB0aHJlc2hvbGQgZm9yIGdhdWdlIGFuZCB0b29sdGlwIGNvbG9yXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtjb2xvci50aHJlc2hvbGQudW5pdF0gSWYgc2V0IHRvIGB2YWx1ZWAsIHRoZSB0aHJlc2hvbGQgd2lsbCBiZSBiYXNlZCBvbiB0aGUgZGF0YSB2YWx1ZS4gT3RoZXJ3aXNlIGl0J2xsIGJlIGJhc2VkIG9uIGVxdWF0aW9uIG9mIHRoZSBgdGhyZXNob2xkLm1heGAgb3B0aW9uIHZhbHVlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtjb2xvci50aHJlc2hvbGQudmFsdWVzXSBUaHJlc2hvbGQgdmFsdWVzIGZvciBlYWNoIHN0ZXBzXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtjb2xvci50aHJlc2hvbGQubWF4PTEwMF0gVGhlIGJhc2UgdmFsdWUgdG8gZGV0ZXJtaW5lIHRocmVzaG9sZCBzdGVwIHZhbHVlIGNvbmRpdGlvbi4gV2hlbiB0aGUgZ2l2ZW4gdmFsdWUgaXMgMTUgYW5kIG1heCAxMCwgdGhlbiB0aGUgdmFsdWUgZm9yIHRocmVzaG9sZCBpcyBgMTUqMTAwLzEwYC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjb2xvcjoge1xyXG5cdCAqICAgICAgcGF0dGVybjogW1wiIzFmNzdiNFwiLCBcIiNhZWM3ZThcIiwgLi4uXSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gU2V0IGNvbG9ycycgcGF0dGVybnNcclxuXHQgKiAgICAgIC8vIGl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgU1ZHUGF0dGVybkVsZW1lbnRcclxuXHQgKiAgICAgIHRpbGVzOiBmdW5jdGlvbigpIHtcclxuXHQgKiAgICAgICAgIHZhciBwYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXR0ZXJuXCIpO1xyXG5cdCAqICAgICAgICAgdmFyIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XHJcblx0ICogICAgICAgICB2YXIgY2lyY2xlMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpO1xyXG5cdCAqXHJcblx0ICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xyXG5cdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBcIjMyXCIpO1xyXG5cdCAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIzMlwiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgZy5zdHlsZS5maWxsID0gXCIjMDAwXCI7XHJcblx0ICogICAgICAgICBnLnN0eWxlLm9wYWNpdHkgPSBcIjAuMlwiO1xyXG5cdCAqXHJcblx0ICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcImN4XCIsIFwiM1wiKTtcclxuXHQgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiY3lcIiwgXCIzXCIpO1xyXG5cdCAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJyXCIsIFwiM1wiKTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgZy5hcHBlbmRDaGlsZChjaXJjbGUxKTtcclxuXHQgKiAgICAgICAgIHBhdHRlcm4uYXBwZW5kQ2hpbGQoZyk7XHJcblx0ICpcclxuXHQgKiAgICAgICAgIHJldHVybiBbcGF0dGVybl07XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBmb3IgdGhyZXNob2xkIHVzYWdlLCBwYXR0ZXJuIHZhbHVlcyBzaG91bGQgYmUgc2V0IGZvciBlYWNoIHN0ZXBzXHJcblx0ICogICAgICBwYXR0ZXJuOiBbXCJncmV5XCIsIFwiZ3JlZW5cIiwgXCJ5ZWxsb3dcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl0sXHJcblx0ICogICAgICB0aHJlc2hvbGQ6IHtcclxuXHQgKiAgICAgICAgICB1bml0OiBcInZhbHVlXCIsXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyB3aGVuIHZhbHVlIGlzIDIwID0+ICdncmVlbicsIHZhbHVlIGlzIDQwID0+ICdvcmFuZ2UnIHdpbGwgYmUgc2V0LlxyXG5cdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzAsIDQwLCA1MF0sXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyB0aGUgZXF1YXRpb24gZm9yIG1heDpcclxuXHQgKiAgICAgICAgICAvLyAtIHVuaXQgPT0gJ3ZhbHVlJzogbWF4ID0+IDMwXHJcblx0ICogICAgICAgICAgLy8gLSB1bml0ICE9ICd2YWx1ZSc6IG1heCA9PiB2YWx1ZSoxMDAvMzBcclxuXHQgKiAgICAgICAgICBtYXg6IDMwXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBzZXQgYWxsIGRhdGEgdG8gJ3JlZCdcclxuXHQgKiAgICAgIG9ub3ZlcjogXCJyZWRcIixcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2V0IGRpZmZlcmVudCBjb2xvciBmb3IgZGF0YVxyXG5cdCAqICAgICAgb25vdmVyOiB7XHJcblx0ICogICAgICAgICAgZGF0YTE6IFwicmVkXCIsXHJcblx0ICogICAgICAgICAgZGF0YTI6IFwieWVsbG93XCJcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHdpbGwgcGFzcyBkYXRhIG9iamVjdCB0byB0aGUgY2FsbGJhY2tcclxuXHQgKiAgICAgIG9ub3ZlcjogZnVuY3Rpb24oZCkge1xyXG5cdCAqICAgICAgICAgIHJldHVybiBkLmlkID09PSBcImRhdGExXCIgPyBcInJlZFwiIDogXCJncmVlblwiO1xyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0Y29sb3JfcGF0dGVybjogPChzdHJpbmd8bnVsbClbXT4gW10sXHJcblx0Y29sb3JfdGlsZXM6IDwoKCkgPT4gW10pfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGNvbG9yX3RocmVzaG9sZDogPHt1bml0Pzogc3RyaW5nOyB2YWx1ZXM/OiBudW1iZXJbXTsgbWF4OiBudW1iZXI7fT4ge30sXHJcblx0Y29sb3Jfb25vdmVyOiA8c3RyaW5nfG9iamVjdHx1bmRlZmluZWQ+IHVuZGVmaW5lZFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBpbnRlcmFjdGlvbiBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEludGVyYWN0aW9uIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBpbnRlcmFjdGlvblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gaW50ZXJhY3Rpb24gSW50ZXJzZWN0aW9uIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVyYWN0aW9uLmVuYWJsZWQ9dHJ1ZV0gSW5kaWNhdGUgaWYgdGhlIGNoYXJ0IHNob3VsZCBoYXZlIGludGVyYWN0aW9ucy48YnI+XHJcblx0ICogICAgIElmIGBmYWxzZWAgaXMgc2V0LCBhbGwgb2YgaW50ZXJhY3Rpb25zIChzaG93aW5nL2hpZGluZyB0b29sdGlwLCBzZWxlY3Rpb24sIG1vdXNlIGV2ZW50cywgZXRjKSB3aWxsIGJlIGRpc2FibGVkLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ludGVyYWN0aW9uLmJyaWdodGVuPXRydWVdIE1ha2UgYnJpZ2h0ZXIgZm9yIHRoZSBzZWxlY3RlZCBhcmVhIChleC4gJ3BpZScgdHlwZSBkYXRhIHNlbGVjdGVkIGFyZWEpXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLm1vdXNlPXRydWVdIGVuYWJsZSBvciBkaXNhYmxlIG1vdXNlIGludGVyYWN0aW9uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoPXRydWVdIGVuYWJsZSBvciBkaXNhYmxlICB0b3VjaCBpbnRlcmFjdGlvblxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxudW1iZXJ9IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2gucHJldmVudERlZmF1bHQ9ZmFsc2VdIGVuYWJsZSBvciBkaXNhYmxlIHRvIGNhbGwgZXZlbnQucHJldmVudERlZmF1bHQgb24gdG91Y2hzdGFydCAmIHRvdWNobW92ZSBldmVudC4gSXQncyB1c3VhbGx5IHVzZWQgdG8gcHJldmVudCBkb2N1bWVudCBzY3JvbGxpbmcuXHJcblx0ICogQHNlZSBbRGVtbzogdG91Y2gucHJldmVudERlZmF1bHRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5QcmV2ZW50U2Nyb2xsT25Ub3VjaClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGludGVyYWN0aW9uOiB7XHJcblx0ICogICAgZW5hYmxlZDogZmFsc2UsXHJcblx0ICogICAgYnJpZ2h0ZW46IGZhbHNlLFxyXG5cdCAqICAgIGlucHV0VHlwZToge1xyXG5cdCAqICAgICAgICBtb3VzZTogdHJ1ZSxcclxuXHQgKiAgICAgICAgdG91Y2g6IGZhbHNlXHJcblx0ICpcclxuXHQgKiAgICAgICAgLy8gb3IgZGVjbGFyZSBwcmV2ZW50RGVmYXVsdCBleHBsaWNpdGx5LlxyXG5cdCAqICAgICAgICAvLyBJbiB0aGlzIGNhc2UgdG91Y2ggaW5wdXRUeXBlIGlzIGVuYWJsZWQgYnkgZGVmYXVsdFxyXG5cdCAqICAgICAgICB0b3VjaDoge1xyXG5cdCAqICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IHRydWVcclxuXHQgKlxyXG5cdCAqICAgICAgICAgICAgLy8gb3IgdGhyZXNob2xkIHBpeGVsIHZhbHVlIChwaXhlbCBtb3ZlZCBmcm9tIHRvdWNoc3RhcnQgdG8gdG91Y2htb3ZlKVxyXG5cdCAqICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6IDVcclxuXHQgKiAgICAgICAgfVxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0aW50ZXJhY3Rpb25fZW5hYmxlZDogdHJ1ZSxcclxuXHRpbnRlcmFjdGlvbl9icmlnaHRlbjogdHJ1ZSxcclxuXHRpbnRlcmFjdGlvbl9pbnB1dFR5cGVfbW91c2U6IHRydWUsXHJcblx0aW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoOiA8Ym9vbGVhbnx7cHJldmVudERlZmF1bHQ/OiBib29sZWFufG51bWJlcn0+IHt9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGxlZ2VuZCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIExlZ2VuZCBvcHRpb25zXHJcblx0ICogQG5hbWUgbGVnZW5kXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBsZWdlbmQgTGVnZW5kIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xlZ2VuZC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZWdlbmQuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbGVnZW5kLmhpZGU9ZmFsc2VdIEhpZGUgbGVnZW5kXHJcblx0ICogIElmIHRydWUgZ2l2ZW4sIGFsbCBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uIElmIHN0cmluZyBvciBhcnJheSBnaXZlbiwgb25seSB0aGUgbGVnZW5kIHRoYXQgaGFzIHRoZSBpZCB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW2xlZ2VuZC5jb250ZW50cy5iaW5kdG89dW5kZWZpbmVkXSBTZXQgQ1NTIHNlbGVjdG9yIG9yIGVsZW1lbnQgcmVmZXJlbmNlIHRvIGJpbmQgbGVnZW5kIGl0ZW1zLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfEZ1bmN0aW9ufSBbbGVnZW5kLmNvbnRlbnRzLnRlbXBsYXRlPXVuZGVmaW5lZF0gU2V0IGl0ZW0ncyB0ZW1wbGF0ZS48YnI+XHJcblx0ICogIC0gSWYgc2V0IGBzdHJpbmdgIHZhbHVlLCB3aXRoaW4gdGVtcGxhdGUgdGhlICdjb2xvcicgYW5kICd0aXRsZScgY2FuIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcclxuXHQgKiAgICAtIHs9Q09MT1J9OiBkYXRhIGNvbG9yIHZhbHVlXHJcblx0ICogICAgLSB7PVRJVExFfTogZGF0YSB0aXRsZSB2YWx1ZVxyXG5cdCAqICAtIElmIHNldCBgZnVuY3Rpb25gIHZhbHVlLCB3aWxsIHBhc3MgZm9sbG93aW5nIGFyZ3VtZW50cyB0byB0aGUgZ2l2ZW4gZnVuY3Rpb246XHJcblx0ICogICAtIHRpdGxlIHtzdHJpbmd9OiBkYXRhJ3MgaWQgdmFsdWVcclxuXHQgKiAgIC0gY29sb3Ige3N0cmluZ306IGNvbG9yIHN0cmluZ1xyXG5cdCAqICAgLSBkYXRhIHtBcnJheX06IGRhdGEgYXJyYXlcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW2xlZ2VuZC5wb3NpdGlvbj1ib3R0b21dIENoYW5nZSB0aGUgcG9zaXRpb24gb2YgbGVnZW5kLjxicj5cclxuXHQgKiAgQXZhaWxhYmxlIHZhbHVlcyBhcmU6IGBib3R0b21gLCBgcmlnaHRgIGFuZCBgaW5zZXRgIGFyZSBzdXBwb3J0ZWQuXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtsZWdlbmQuaW5zZXQ9e2FuY2hvcjogJ3RvcC1sZWZ0Jyx4OiAxMCx5OiAwLHN0ZXA6IHVuZGVmaW5lZH1dIENoYW5nZSBpbnNldCBsZWdlbmQgYXR0cmlidXRlcy48YnI+XHJcblx0ICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgb2JqZWN0IHRoYXQgaGFzIHRoZSBrZXlzIGBhbmNob3JgLCBgeGAsIGB5YCBhbmQgYHN0ZXBgLlxyXG5cdCAqICAtICoqYW5jaG9yKiogZGVjaWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZDpcclxuXHQgKiAgIC0gdG9wLWxlZnRcclxuXHQgKiAgIC0gdG9wLXJpZ2h0XHJcblx0ICogICAtIGJvdHRvbS1sZWZ0XHJcblx0ICogICAtIGJvdHRvbS1yaWdodFxyXG5cdCAqICAtICoqeCoqIGFuZCAqKnkqKjpcclxuXHQgKiAgIC0gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGJhc2VkIG9uIHRoZSBhbmNob3IuXHJcblx0ICogIC0gKipzdGVwKio6XHJcblx0ICogICAtIGRlZmluZXMgdGhlIG1heCBzdGVwIHRoZSBsZWdlbmQgaGFzIChlLmcuIElmIDIgc2V0IGFuZCBsZWdlbmQgaGFzIDMgbGVnZW5kIGl0ZW0sIHRoZSBsZWdlbmQgMiBjb2x1bW5zKS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsZWdlbmQuZXF1YWxseT1mYWxzZV0gU2V0IHRvIGFsbCBpdGVtcyBoYXZlIHNhbWUgd2lkdGggc2l6ZS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsZWdlbmQucGFkZGluZz0wXSBTZXQgcGFkZGluZyB2YWx1ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbmNsaWNrPXVuZGVmaW5lZF0gU2V0IGNsaWNrIGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbm92ZXI9dW5kZWZpbmVkXSBTZXQgbW91c2UvdG91Y2ggb3ZlciBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25vdXQ9dW5kZWZpbmVkXSBTZXQgbW91c2UvdG91Y2ggb3V0IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGVnZW5kLml0ZW0udGlsZS53aWR0aD0xMF0gU2V0IHdpZHRoIG9mIGl0ZW0gdGlsZSBlbGVtZW50XHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtsZWdlbmQuaXRlbS50aWxlLmhlaWdodD0xMF0gU2V0IGhlaWdodCBvZiBpdGVtIHRpbGUgZWxlbWVudFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xlZ2VuZC51c2VQb2ludD1mYWxzZV0gV2hldGhlciB0byB1c2UgY3VzdG9tIHBvaW50cyBpbiBsZWdlbmQuXHJcblx0ICogQHNlZSBbRGVtbzogcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQuTGVnZW5kUG9zaXRpb24pXHJcblx0ICogQHNlZSBbRGVtbzogY29udGVudHMudGVtcGxhdGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQuTGVnZW5kVGVtcGxhdGUxKVxyXG5cdCAqIEBzZWUgW0RlbW86IHVzZVBvaW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLnVzZVBvaW50KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGxlZ2VuZDoge1xyXG5cdCAqICAgICAgc2hvdzogdHJ1ZSxcclxuXHQgKiAgICAgIGhpZGU6IHRydWUsXHJcblx0ICogICAgICAvL29yIGhpZGU6IFwiZGF0YTFcIlxyXG5cdCAqICAgICAgLy9vciBoaWRlOiBbXCJkYXRhMVwiLCBcImRhdGEyXCJdXHJcblx0ICogICAgICBjb250ZW50czoge1xyXG5cdCAqICAgICAgICAgIGJpbmR0bzogXCIjbGVnZW5kXCIsICAgLy8gPHVsIGlkPSdsZWdlbmQnPjwvdWw+XHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyB3aWxsIGJlIGFzOiA8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6IzFmNzdiNCc+ZGF0YTE8L2xpPlxyXG5cdCAqICAgICAgICAgIHRlbXBsYXRlOiBcIjxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjp7PUNPTE9SfSc+ez1USVRMRX08L2xpPlwiXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyBvciB1c2luZyBmdW5jdGlvblxyXG5cdCAqICAgICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbihpZCwgY29sb3IsIGRhdGEpIHtcclxuXHQgKiAgICAgICAgICAgICAgIC8vIGlmIHlvdSB3YW50IG9taXQgc29tZSBsZWdlbmQsIHJldHVybiBmYWxzeSB2YWx1ZVxyXG5cdCAqICAgICAgICAgICAgICAgaWYgKGlkICE9PSBcImRhdGExXCIpIHtcclxuXHQgKiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOlwiKyBjb2xvciArXCI+XCIrIGlkICtcIjwvbGk+XCI7XHJcblx0ICogICAgICAgICAgICAgICB9XHJcblx0ICogICAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLCAgLy8gYm90dG9tLCByaWdodCwgaW5zZXRcclxuXHQgKiAgICAgIGluc2V0OiB7XHJcblx0ICogICAgICAgICAgYW5jaG9yOiBcInRvcC1yaWdodFwiICAvLyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0XHJcblx0ICogICAgICAgICAgeDogMjAsXHJcblx0ICogICAgICAgICAgeTogMTAsXHJcblx0ICogICAgICAgICAgc3RlcDogMlxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIGVxdWFsbHk6IGZhbHNlLFxyXG5cdCAqICAgICAgcGFkZGluZzogMTAsXHJcblx0ICogICAgICBpdGVtOiB7XHJcblx0ICogICAgICAgICAgb25jbGljazogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXHJcblx0ICogICAgICAgICAgb25vdmVyOiBmdW5jdGlvbihpZCkgeyAuLi4gfSxcclxuXHQgKiAgICAgICAgICBvbm91dDogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXHJcblx0ICpcclxuXHQgKiAgICAgICAgICAvLyBzZXQgdGlsZSdzIHNpemVcclxuXHQgKiAgICAgICAgICB0aWxlOiB7XHJcblx0ICogICAgICAgICAgICAgIHdpZHRoOiAyMCxcclxuXHQgKiAgICAgICAgICAgICAgaGVpZ2h0OiAxNVxyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICB1c2VQb2ludDogdHJ1ZVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0bGVnZW5kX3Nob3c6IHRydWUsXHJcblx0bGVnZW5kX2hpZGU6IGZhbHNlLFxyXG5cdGxlZ2VuZF9jb250ZW50c19iaW5kdG86IDxzdHJpbmd8SFRNTEVsZW1lbnR8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGVnZW5kX2NvbnRlbnRzX3RlbXBsYXRlOiA8c3RyaW5nfCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD51bmRlZmluZWQsXHJcblx0bGVnZW5kX3Bvc2l0aW9uOiA8XCJib3R0b21cInxcInJpZ2h0XCJ8XCJpbnNldFwiPiBcImJvdHRvbVwiLFxyXG5cdGxlZ2VuZF9pbnNldF9hbmNob3I6IDxcInRvcC1sZWZ0XCJ8XCJ0b3AtcmlnaHRcInxcImJvdHRvbS1sZWZ0XCJ8XCJib3R0b20tcmlnaHRcIj4gXCJ0b3AtbGVmdFwiLFxyXG5cdGxlZ2VuZF9pbnNldF94OiAxMCxcclxuXHRsZWdlbmRfaW5zZXRfeTogMCxcclxuXHRsZWdlbmRfaW5zZXRfc3RlcDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRsZWdlbmRfaXRlbV9vbmNsaWNrOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGVnZW5kX2l0ZW1fb25vdmVyOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0bGVnZW5kX2l0ZW1fb25vdXQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRsZWdlbmRfZXF1YWxseTogZmFsc2UsXHJcblx0bGVnZW5kX3BhZGRpbmc6IDAsXHJcblx0bGVnZW5kX2l0ZW1fdGlsZV93aWR0aDogMTAsXHJcblx0bGVnZW5kX2l0ZW1fdGlsZV9oZWlnaHQ6IDEwLFxyXG5cdGxlZ2VuZF91c2VQb2ludDogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogdGl0bGUgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgdGl0bGUgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIHRpdGxlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aXRsZSBUaXRsZSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlLnRleHRdIFRpdGxlIHRleHQuIElmIGNvbnRhaW5zIGBcXG5gLCBpdCdzIHVzZWQgYXMgbGluZSBicmVhayBhbGxvd2luZyBtdWx0aWxpbmUgdGl0bGUuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt0aXRsZS5wYWRkaW5nLnRvcD0wXSBUb3AgcGFkZGluZyB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3RpdGxlLnBhZGRpbmcucmlnaHQ9MF0gUmlnaHQgcGFkZGluZyB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3RpdGxlLnBhZGRpbmcuYm90dG9tPTBdIEJvdHRvbSBwYWRkaW5nIHZhbHVlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGl0bGUucGFkZGluZy5sZWZ0PTBdIExlZnQgcGFkZGluZyB2YWx1ZS5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlLnBvc2l0aW9uPWNlbnRlcl0gQXZhaWxhYmxlIHZhbHVlcyBhcmU6ICdjZW50ZXInLCAncmlnaHQnIGFuZCAnbGVmdCcuXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1RpdGxlLk11bHRpbGluZWRUaXRsZSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICB0aXRsZToge1xyXG5cdCAqICAgICAgdGV4dDogXCJUaXRsZSBUZXh0XCIsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIG9yIE11bHRpbGluZSB0aXRsZSB0ZXh0XHJcblx0ICogICAgICB0ZXh0OiBcIk1haW4gdGl0bGUgdGV4dFxcblN1YiB0aXRsZSB0ZXh0XCIsXHJcblx0ICpcclxuXHQgKiAgICAgIHBhZGRpbmc6IHtcclxuXHQgKiAgICAgICAgICB0b3A6IDEwLFxyXG5cdCAqICAgICAgICAgIHJpZ2h0OiAxMCxcclxuXHQgKiAgICAgICAgICBib3R0b206IDEwLFxyXG5cdCAqICAgICAgICAgIGxlZnQ6IDEwXHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgcG9zaXRpb246IFwiY2VudGVyXCJcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHRpdGxlX3RleHQ6IDxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0dGl0bGVfcGFkZGluZzoge1xyXG5cdFx0dG9wOiAwLFxyXG5cdFx0cmlnaHQ6IDAsXHJcblx0XHRib3R0b206IDAsXHJcblx0XHRsZWZ0OiAwXHJcblx0fSxcclxuXHR0aXRsZV9wb3NpdGlvbjogPFwiY2VudGVyXCJ8XCJyaWdodFwifFwibGVmdFwiPiBcImNlbnRlclwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHRvb2x0aXAgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBUb29sdGlwIG9wdGlvbnNcclxuXHQgKiBAbmFtZSB0b29sdGlwXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0b29sdGlwIFRvb2x0aXAgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbdG9vbHRpcC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB0b29sdGlwLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXAuZG9Ob3RIaWRlPWZhbHNlXSBNYWtlIHRvb2x0aXAga2VlcCBzaG93aW5nIG5vdCBoaWRpbmcgb24gaW50ZXJhY3Rpb24uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbdG9vbHRpcC5ncm91cGVkPXRydWVdIFNldCBpZiB0b29sdGlwIGlzIGdyb3VwZWQgb3Igbm90IGZvciB0aGUgZGF0YSBwb2ludHMuXHJcblx0ICogICAtICoqTk9URToqKiBUaGUgb3ZlcmxhcHBlZCBkYXRhIHBvaW50cyB3aWxsIGJlIGRpc3BsYXllZCBhcyBncm91cGVkIGV2ZW4gaWYgc2V0IGZhbHNlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXAubGlua2VkPWZhbHNlXSBTZXQgaWYgdG9vbHRpcHMgb24gYWxsIHZpc2libGUgY2hhcnRzIHdpdGggbGlrZSB4IHBvaW50cyBhcmUgc2hvd24gdG9nZXRoZXIgd2hlbiBvbmUgaXMgc2hvd24uXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFt0b29sdGlwLmxpbmtlZC5uYW1lPVwiXCJdIEdyb3BpbmcgbmFtZSBmb3IgbGlua2VkIHRvb2x0aXAuPGJyPklmIHNwZWNpZmllZCwgbGlua2VkIHRvb2x0aXAgd2lsbCBiZSBncm9wZWQgaW50ZXJhY3RpbmcgdG8gYmUgd29ya2VkIG9ubHkgd2l0aCB0aGUgc2FtZSBuYW1lLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC50aXRsZV0gU2V0IGZvcm1hdCBmb3IgdGhlIHRpdGxlIG9mIHRvb2x0aXAuPGJyPlxyXG5cdCAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgeCBvZiB0aGUgZGF0YSBwb2ludCB0byBzaG93LlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC5uYW1lXSBTZXQgZm9ybWF0IGZvciB0aGUgbmFtZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XHJcblx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBuYW1lLCByYXRpbywgaWQgYW5kIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHRvIHNob3cuIHJhdGlvIHdpbGwgYmUgdW5kZWZpbmVkIGlmIHRoZSBjaGFydCBpcyBub3QgZG9udXQvcGllL2dhdWdlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC52YWx1ZV0gU2V0IGZvcm1hdCBmb3IgdGhlIHZhbHVlIG9mIGVhY2ggZGF0YSBpbiB0b29sdGlwLjxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXHJcblx0ICogIElmIHVuZGVmaW5lZCByZXR1cm5lZCwgdGhlIHJvdyBvZiB0aGF0IHZhbHVlIHdpbGwgYmUgc2tpcHBlZC5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5wb3NpdGlvbl0gU2V0IGN1c3RvbSBwb3NpdGlvbiBmdW5jdGlvbiBmb3IgdGhlIHRvb2x0aXAuPGJyPlxyXG5cdCAqICBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgcG9zaXRpb24gYnkgcmV0dXJuaW5nIG9iamVjdCB0aGF0IGhhcyB0b3AgYW5kIGxlZnQuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbnxvYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzXSBTZXQgY3VzdG9tIEhUTUwgZm9yIHRoZSB0b29sdGlwLjxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIGRhdGEsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0IGFuZCBjb2xvciBvZiB0aGUgZGF0YSBwb2ludCB0byBzaG93LiBJZiB0b29sdGlwLmdyb3VwZWQgaXMgdHJ1ZSwgZGF0YSBpbmNsdWRlcyBtdWx0aXBsZSBkYXRhIHBvaW50cy5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xIVE1MRWxlbWVudH0gW3Rvb2x0aXAuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIHRvb2x0aXAuXHJcblx0ICogIC0gKipOT1RFOioqIFdoZW4gaXMgc3BlY2lmaWVkLCB3aWxsIG5vdCBiZSB1cGRhdGluZyB0b29sdGlwJ3MgcG9zaXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFt0b29sdGlwLmNvbnRlbnRzLnRlbXBsYXRlPXVuZGVmaW5lZF0gU2V0IHRvb2x0aXAncyB0ZW1wbGF0ZS48YnI+PGJyPlxyXG5cdCAqICBXaXRoaW4gdGVtcGxhdGUsIGJlbG93IHN5bnRheCB3aWxsIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcclxuXHQgKiAgICAtICoqe3sgLi4uIH19Kio6IHRoZSBkb3VibHkgY3VybHkgYnJhY2tldHMgaW5kaWNhdGUgbG9vcCBibG9jayBmb3IgZGF0YSByb3dzLlxyXG5cdCAqICAgIC0gKip7PUNMQVNTX1RPT0xUSVB9Kio6IGRlZmF1bHQgdG9vbHRpcCBjbGFzcyBuYW1lIGBiYi10b29sdGlwYC5cclxuXHQgKiAgICAtICoqez1DTEFTU19UT09MVElQX05BTUV9Kio6IGRlZmF1bHQgdG9vbHRpcCBkYXRhIGNsYXNzIG5hbWUgKGV4LiBgYmItdG9vbHRpcC1uYW1lLWRhdGExYClcclxuXHQgKiAgICAtICoqez1USVRMRX0qKjogdGl0bGUgdmFsdWUuXHJcblx0ICogICAgLSAqKns9Q09MT1J9Kio6IGRhdGEgY29sb3IuXHJcblx0ICogICAgLSAqKns9VkFMVUV9Kio6IGRhdGEgdmFsdWUuXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFt0b29sdGlwLmNvbnRlbnRzLnRleHQ9dW5kZWZpbmVkXSBTZXQgYWRkaXRpb25hbCB0ZXh0IGNvbnRlbnQgd2l0aGluIGRhdGEgbG9vcCwgdXNpbmcgdGVtcGxhdGUgc3ludGF4LlxyXG5cdCAqICAtICoqTk9URToqKiBJdCBzaG91bGQgY29udGFpbiBgeyBrZXk6IEFycmF5LCAuLi4gfWAgdmFsdWVcclxuXHQgKiAgICAtICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXHJcblx0ICogICAgLSBUaGUgdmFsdWUgYXJyYXkgbGVuZ3RoIHNob3VsZCBtYXRjaCB3aXRoIHRoZSBkYXRhIGxlbmd0aFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3Rvb2x0aXAuaW5pdC5zaG93PWZhbHNlXSBTaG93IHRvb2x0aXAgYXQgdGhlIGluaXRpYWxpemF0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdG9vbHRpcC5pbml0Lng9MF0gU2V0IHggQXhpcyBpbmRleCB0byBiZSBzaG93biBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFt0b29sdGlwLmluaXQucG9zaXRpb249e3RvcDogXCIwcHhcIixsZWZ0OiBcIjUwcHhcIn1dIFNldCB0aGUgcG9zaXRpb24gb2YgdG9vbHRpcCBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25zaG93XSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgc2hvd24uXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRlXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd25dIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSB0b29sdGlwIGlzIHNob3duXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRkZW5dIFNldCBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBpbnZva2VkIGFmdGVyIHRoZSB0b29sdGlwIGlzIGhpZGRlbi5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ3xGdW5jdGlvbnxudWxsfSBbdG9vbHRpcC5vcmRlcj1udWxsXSBTZXQgdG9vbHRpcCBkYXRhIGRpc3BsYXkgb3JkZXIuPGJyPjxicj5cclxuXHQgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcclxuXHQgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcclxuXHQgKiAgLSBgbnVsbGA6IEl0IGtlZXBzIHRoZSBkYXRhIGRpc3BsYXkgb3JkZXI8YnI+XHJcblx0ICogICAgICoqTk9URToqKiBXaGVuIGBkYXRhLmdyb3Vwc2AgaXMgc2V0LCB0aGUgb3JkZXIgd2lsbCBmb2xsb3cgYXMgdGhlIHN0YWNrZWQgZ3JhcGggb3JkZXIuPGJyPlxyXG5cdCAqICAgICAgSWYgd2FudCB0byBvcmRlciBhcyBkYXRhIGJvdW5kLCBzZXQgYW55IHZhbHVlIHJhdGhlciB0aGFuIGFzYywgZGVzYyBvciBudWxsLiAoZXguIGVtcHR5IHN0cmluZyBcIlwiKVxyXG5cdCAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBbQXJyYXkuc29ydCBjb21wYXJlRnVuY3Rpb25dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnQjUGFyYW1ldGVycylcclxuXHQgKiBAc2VlIFtEZW1vOiBIaWRlIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkhpZGVUb29sdGlwKVxyXG5cdCAqIEBzZWUgW0RlbW86IFRvb2x0aXAgR3JvdXBpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBHcm91cGluZylcclxuXHQgKiBAc2VlIFtEZW1vOiBUb29sdGlwIEZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcEZvcm1hdClcclxuXHQgKiBAc2VlIFtEZW1vOiBMaW5rZWQgVG9vbHRpcF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuTGlua2VkVG9vbHRpcHMpXHJcblx0ICogQHNlZSBbRGVtbzogVG9vbHRpcCBUZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcFRlbXBsYXRlKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHRvb2x0aXA6IHtcclxuXHQgKiAgICAgIHNob3c6IHRydWUsXHJcblx0ICogICAgICBkb05vdEhpZGU6IHRydWUsXHJcblx0ICogICAgICBncm91cGVkOiBmYWxzZSxcclxuXHQgKiAgICAgIGZvcm1hdDoge1xyXG5cdCAqICAgICAgICAgIHRpdGxlOiBmdW5jdGlvbih4KSB7IHJldHVybiBcIkRhdGEgXCIgKyB4OyB9LFxyXG5cdCAqICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uKG5hbWUsIHJhdGlvLCBpZCwgaW5kZXgpIHsgcmV0dXJuIG5hbWU7IH0sXHJcblx0ICogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiByYXRpbzsgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbihkYXRhLCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IDB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICBjb250ZW50czogZnVuY3Rpb24oZCwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQsIGNvbG9yKSB7XHJcblx0ICogICAgICAgICAgcmV0dXJuIC4uLiAvLyBmb3JtYXR0ZWQgaHRtbCBhcyB5b3Ugd2FudFxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIHNwZWNpZnkgdG9vbHRpcCBjb250ZW50cyB1c2luZyB0ZW1wbGF0ZVxyXG5cdCAqICAgICAgIC8vIC0gZXhhbXBsZSBvZiBIVE1MIHJldHVybmVkOlxyXG5cdCAqICAgICAgIC8vIDx1bCBjbGFzcz1cImJiLXRvb2x0aXBcIj5cclxuXHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMVwiPjxzcGFuPjI1MDwvc3Bhbj48YnI+PHNwYW4gc3R5bGU9XCJjb2xvcjojMDBjNzNjXCI+ZGF0YTE8L3NwYW4+PC9saT5cclxuXHQgKiAgICAgICAvLyAgIDxsaSBjbGFzcz1cImJiLXRvb2x0aXAtbmFtZS1kYXRhMlwiPjxzcGFuPjUwPC9zcGFuPjxicj48c3BhbiBzdHlsZT1cImNvbG9yOiNmYTcxNzFcIj5kYXRhMjwvc3Bhbj48L2xpPlxyXG5cdCAqICAgICAgIC8vIDwvdWw+XHJcblx0ICogICAgICAgY29udGVudHM6IHtcclxuXHQgKiAgICAgIFx0YmluZHRvOiBcIiN0b29sdGlwXCIsXHJcblx0ICogICAgICBcdHRlbXBsYXRlOiAnPHVsIGNsYXNzPXs9Q0xBU1NfVE9PTFRJUH0+e3snICtcclxuXHQgKiAgICAgIFx0XHRcdCc8bGkgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj48c3Bhbj57PVZBTFVFfTwvc3Bhbj48YnI+JyArXHJcblx0ICogICAgICBcdFx0XHQnPHNwYW4gc3R5bGU9Y29sb3I6ez1DT0xPUn0+ez1OQU1FfTwvc3Bhbj48L2xpPicgK1xyXG5cdCAqICAgICAgXHRcdCd9fTwvdWw+J1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogICAgICAgLy8gd2l0aCBhZGRpdGlvbmFsIHRleHQgdmFsdWVcclxuXHQgKiAgICAgICAvLyAtIGV4YW1wbGUgb2YgSFRNTCByZXR1cm5lZDpcclxuXHQgKiAgICAgICAvLyA8dWwgY2xhc3M9XCJiYi10b29sdGlwXCI+XHJcblx0ICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTFcIj48c3Bhbj4yNTA8L3NwYW4+PGJyPmNvbW1lbnQxPHNwYW4gc3R5bGU9XCJjb2xvcjojMDBjNzNjXCI+ZGF0YTE8L3NwYW4+dGV4dDE8L2xpPlxyXG5cdCAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGEyXCI+PHNwYW4+NTA8L3NwYW4+PGJyPmNvbW1lbnQyPHNwYW4gc3R5bGU9XCJjb2xvcjojZmE3MTcxXCI+ZGF0YTI8L3NwYW4+dGV4dDI8L2xpPlxyXG5cdCAqICAgICAgIC8vIDwvdWw+XHJcblx0ICogICAgICAgY29udGVudHM6IHtcclxuXHQgKiAgICAgIFx0YmluZHRvOiBcIiN0b29sdGlwXCIsXHJcblx0ICogICAgICBcdHRleHQ6IHtcclxuXHQgKiAgICAgIFx0XHQvLyBhKSAna2V5JyBuYW1lIGlzIHVzZWQgYXMgc3Vic3RpdHV0aW9uIHdpdGhpbiB0ZW1wbGF0ZSBhcyAnez1LRVl9J1xyXG5cdCAqICAgICAgXHRcdC8vIGIpIHRoZSBsZW5ndGggc2hvdWxkIG1hdGNoIHdpdGggdGhlIGRhdGEgbGVuZ3RoXHJcblx0ICogICAgICBcdFx0VkFSMTogW1widGV4dDFcIiwgXCJ0ZXh0MlwiXSxcclxuXHQgKiAgICAgIFx0XHRWQVIyOiBbXCJjb21tZW50MVwiLCBcImNvbW1lbnQyXCJdLFxyXG5cdCAqICAgICAgXHR9LFxyXG5cdCAqICAgICAgXHR0ZW1wbGF0ZTogJzx1bCBjbGFzcz17PUNMQVNTX1RPT0xUSVB9Pnt7JyArXHJcblx0ICogICAgICBcdFx0XHQnPGxpIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+PHNwYW4+ez1WQUxVRX08L3NwYW4+ez1WQVIyfTxicj4nICtcclxuXHQgKiAgICAgIFx0XHRcdCc8c3BhbiBzdHlsZT1jb2xvcjp7PUNPTE9SfT57PU5BTUV9PC9zcGFuPns9VkFSMX08L2xpPicgK1xyXG5cdCAqICAgICAgXHRcdCd9fTwvdWw+J1xyXG5cdCAqICAgICAgfVxyXG5cdCAqXHJcblx0ICogICAgICAvLyBzb3J0IHRvb2x0aXAgZGF0YSB2YWx1ZSBkaXNwbGF5IGluIGFzY2VuZGluZyBvcmRlclxyXG5cdCAqICAgICAgb3JkZXI6IFwiYXNjXCIsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHNwZWNpZnlpbmcgc29ydCBmdW5jdGlvblxyXG5cdCAqICAgICAgb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcclxuXHQgKiAgICAgICAgIC8vIHBhcmFtIGRhdGEgcGFzc2VkIGZvcm1hdFxyXG5cdCAqICAgICAgICAge3g6IDUsIHZhbHVlOiAyNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA1LCBuYW1lOiBcImRhdGExXCJ9XHJcblx0ICogICAgICAgICAgIC4uLlxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2hvdyBhdCB0aGUgaW5pdGlhbGl6YXRpb25cclxuXHQgKiAgICAgIGluaXQ6IHtcclxuXHQgKiAgICAgICAgICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICAgICAgIHg6IDIsXHJcblx0ICogICAgICAgICAgcG9zaXRpb246IHtcclxuXHQgKiAgICAgICAgICAgICAgdG9wOiBcIjE1MHB4XCIsXHJcblx0ICogICAgICAgICAgICAgIGxlZnQ6IFwiMjUwcHhcIlxyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgc2hvd25cclxuXHQgKiAgICAgIG9uc2hvdzogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuXHQgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXHJcblx0ICpcclxuXHQgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcblx0ICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXHJcblx0ICogICAgICBcdHNlbGVjdGVkRGF0YTtcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGZpcmVzIHByaW9yIHRvb2x0aXAgaXMgaGlkZGVuXHJcblx0ICogICAgICBvbmhpZGU6IGZ1bmN0aW9uKGN0eCwgc2VsZWN0ZWREYXRhKSB7XHJcblx0ICogICAgICBcdGN0eDsgLy8gY3VycmVudCBjaGFydCBpbnN0YW5jZVxyXG5cdCAqXHJcblx0ICogICAgICBcdC8vIGN1cnJlbnQgZGF0YXNldCBzZWxlY3RlZFxyXG5cdCAqICAgICAgXHQvLyA9PT4gW3t4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMlwifSwgLi4uXVxyXG5cdCAqICAgICAgXHRzZWxlY3RlZERhdGE7XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBmaXJlcyBhZnRlciB0b29sdGlwIGlzIHNob3duXHJcblx0ICogICAgICBvbnNob3duOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xyXG5cdCAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuXHQgKlxyXG5cdCAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcclxuXHQgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuXHQgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gZmlyZXMgYWZ0ZXIgdG9vbHRpcCBpcyBoaWRkZW5cclxuXHQgKiAgICAgIG9uaGlkZGVuOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xyXG5cdCAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuXHQgKlxyXG5cdCAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcclxuXHQgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuXHQgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gTGluayBhbnkgdG9vbHRpcHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgYXJlIG9uIHRoZSBzY3JlZW4gd2hlcmUgc2FtZSB4IGNvb3JkaW5hdGVzIGFyZSBhdmFpbGFibGVcclxuXHQgKiAgICAgIC8vIFVzZWZ1bCBmb3IgdGltZXNlcmllcyBjb3JyZWxhdGlvblxyXG5cdCAqICAgICAgbGlua2VkOiB0cnVlLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBTcGVjaWZ5IG5hbWUgdG8gaW50ZXJhY3QgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIG9ubHkuXHJcblx0ICogICAgICBsaW5rZWQ6IHtcclxuXHQgKiAgICAgICAgICBuYW1lOiBcInNvbWUtZ3JvdXBcIlxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0dG9vbHRpcF9zaG93OiB0cnVlLFxyXG5cdHRvb2x0aXBfZG9Ob3RIaWRlOiBmYWxzZSxcclxuXHR0b29sdGlwX2dyb3VwZWQ6IHRydWUsXHJcblx0dG9vbHRpcF9mb3JtYXRfdGl0bGU6IDwoKCkgPT4gc3RyaW5nKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR0b29sdGlwX2Zvcm1hdF9uYW1lOiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0dG9vbHRpcF9mb3JtYXRfdmFsdWU6IDwoKCkgPT4gbnVtYmVyKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR0b29sdGlwX3Bvc2l0aW9uOiA8KCgpID0+IHt0b3A6IG51bWJlcjsgbGVmdDogbnVtYmVyO30pfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHRvb2x0aXBfY29udGVudHM6IDxcclxuXHRcdFx0KCgpID0+IHN0cmluZyl8e2JpbmR0bzogc3RyaW5nOyB0ZW1wbGF0ZTogc3RyaW5nOyB0ZXh0Pzoge1trZXk6IHN0cmluZ106IHN0cmluZ1tdfX1cclxuXHRcdD4ge30sXHJcblx0dG9vbHRpcF9pbml0X3Nob3c6IGZhbHNlLFxyXG5cdHRvb2x0aXBfaW5pdF94OiAwLFxyXG5cdHRvb2x0aXBfaW5pdF9wb3NpdGlvbjoge1xyXG5cdFx0dG9wOiBcIjBweFwiLFxyXG5cdFx0bGVmdDogXCI1MHB4XCJcclxuXHR9LFxyXG5cdHRvb2x0aXBfbGlua2VkOiBmYWxzZSxcclxuXHR0b29sdGlwX2xpbmtlZF9uYW1lOiBcIlwiLFxyXG5cdHRvb2x0aXBfb25zaG93OiAoKSA9PiB7fSxcclxuXHR0b29sdGlwX29uaGlkZTogKCkgPT4ge30sXHJcblx0dG9vbHRpcF9vbnNob3duOiAoKSA9PiB7fSxcclxuXHR0b29sdGlwX29uaGlkZGVuOiAoKSA9PiB7fSxcclxuXHR0b29sdGlwX29yZGVyOiA8c3RyaW5nfEZ1bmN0aW9ufG51bGw+IG51bGxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQXhpcyBiYXNlZCBjaGFydCBkYXRhIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU3BlY2lmeSB0aGUga2V5IG9mIHggdmFsdWVzIGluIHRoZSBkYXRhLjxicj48YnI+XHJcblx0ICogV2UgY2FuIHNob3cgdGhlIGRhdGEgd2l0aCBub24taW5kZXggeCB2YWx1ZXMgYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gdGhlIHR5cGUgb2YgeCBheGlzIGlzIHRpbWVzZXJpZXMuIElmIHRoaXMgb3B0aW9uIGlzIHNldCBvbiBjYXRlZ29yeSBheGlzLCB0aGUgdmFsdWVzIG9mIHRoZSBkYXRhIG9uIHRoZSBrZXkgd2lsbCBiZSB1c2VkIGZvciBjYXRlZ29yeSBuYW1lcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkeFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ31cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHg6IFwiZGF0ZVwiXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfeDogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU3BlY2lmeSB0aGUga2V5cyBvZiB0aGUgeCB2YWx1ZXMgZm9yIGVhY2ggZGF0YS48YnI+PGJyPlxyXG5cdCAqIFRoaXMgb3B0aW9uIGNhbiBiZSB1c2VkIGlmIHdlIHdhbnQgdG8gc2hvdyB0aGUgZGF0YSB0aGF0IGhhcyBkaWZmZXJlbnQgeCB2YWx1ZXMuXHJcblx0ICogQG5hbWUgZGF0YeKApHhzXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICB4czoge1xyXG5cdCAqICAgICAgZGF0YTE6IFwieDFcIixcclxuXHQgKiAgICAgIGRhdGEyOiBcIngyXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV94czoge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGZvcm1hdCBzcGVjaWZpZXIgdG8gcGFyc2Ugc3RyaW5nIHNwZWNpZmVkIGFzIHguXHJcblx0ICogQG5hbWUgZGF0YeKApHhGb3JtYXRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgJVktJW0tJWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICB4OiBcInhcIixcclxuXHQgKiAgICBjb2x1bW5zOiBbXHJcblx0ICogICAgICAgIFtcInhcIiwgXCIwMTAxMjAxOVwiLCBcIjAyMDEyMDE5XCIsIFwiMDMwMTIwMTlcIl0sXHJcblx0ICogICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1cclxuXHQgKiAgICBdLFxyXG5cdCAqICAgIC8vIEZvcm1hdCBzcGVjaWZpZXIgdG8gcGFyc2UgYXMgZGF0ZXRpbWUgZm9yIGdpdmVuICd4JyBzdHJpbmcgdmFsdWVcclxuXHQgKiAgICB4Rm9ybWF0OiBcIiVtJWQlWVwiXHJcblx0ICogfSxcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICAgeDoge1xyXG5cdCAqICAgICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICogQHNlZSBbRDMncyB0aW1lIHNwZWNpZmllcl0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUtZm9ybWF0I2xvY2FsZV9mb3JtYXQpXHJcblx0ICovXHJcblx0ZGF0YV94Rm9ybWF0OiBcIiVZLSVtLSVkXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBsb2NhbHRpbWUgZm9ybWF0IHRvIHBhcnNlIHggYXhpcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkeExvY2FsdGltZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgeExvY2FsdGltZTogZmFsc2VcclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV94TG9jYWx0aW1lOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTb3J0IG9uIHggYXhpcy5cclxuXHQgKiBAbmFtZSBkYXRh4oCkeFNvcnRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIHhTb3J0OiBmYWxzZVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3hTb3J0OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZ3JvdXBzIGZvciB0aGUgZGF0YSBmb3Igc3RhY2tpbmcuXHJcblx0ICogQG5hbWUgZGF0YeKApGdyb3Vwc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBkZWZhdWx0IFtdXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICBncm91cHM6IFtcclxuXHQgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuXHQgKiAgICAgW1wiZGF0YTNcIl1cclxuXHQgKiAgIF1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9ncm91cHM6IDxzdHJpbmdbXVtdPiBbXSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHkgYXhpcyB0aGUgZGF0YSByZWxhdGVkIHRvLiB5IGFuZCB5MiBjYW4gYmUgdXNlZC5cclxuXHQgKiAtICoqTk9URToqKiBJZiBhbGwgZGF0YSBpcyByZWxhdGVkIHRvIG9uZSBvZiB0aGUgYXhlcywgdGhlIGRvbWFpbiBvZiBheGlzIHdpdGhvdXQgcmVsYXRlZCBkYXRhIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGRvbWFpbiBmcm9tIHRoZSBheGlzIHdpdGggcmVsYXRlZCBkYXRhXHJcblx0ICogQG5hbWUgZGF0YeKApGF4ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgIGF4ZXM6IHtcclxuXHQgKiAgICAgZGF0YTE6IFwieVwiLFxyXG5cdCAqICAgICBkYXRhMjogXCJ5MlwiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfYXhlczogPHtba2V5OiBzdHJpbmddOiBzdHJpbmd9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxhYmVscyBvcHRpb25zXHJcblx0ICogQG5hbWUgZGF0YeKApGxhYmVsc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gZGF0YSBEYXRhIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RhdGEubGFiZWxzPWZhbHNlXSBTaG93IG9yIGhpZGUgbGFiZWxzIG9uIGVhY2ggZGF0YSBwb2ludHNcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkYXRhLmxhYmVscy5jZW50ZXJlZD1mYWxzZV0gQ2VudGVyaXplIGxhYmVscyBvbiBgYmFyYCBzaGFwZS4gKCoqTk9URToqKiB3b3JrcyBvbmx5IGZvciAnYmFyJyB0eXBlKVxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkYXRhLmxhYmVscy5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZnVuY3Rpb24gZm9yIGRhdGEgbGFiZWxzLjxicj5cclxuXHQgKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9uIHJlY2VpdmVzIDQgYXJndW1lbnRzIHN1Y2ggYXMgdiwgaWQsIGksIGogYW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBhcyB0aGUgbGFiZWwuIFRoZSBhcmd1bWVudHMgYXJlOjxicj5cclxuXHQgKiAgLSBgdmAgaXMgdGhlIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50IHdoZXJlIHRoZSBsYWJlbCBpcyBzaG93bi5cclxuXHQgKiAgLSBgaWRgIGlzIHRoZSBpZCBvZiB0aGUgZGF0YSB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcblx0ICogIC0gYGlgIGlzIHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcblx0ICogIC0gYGpgIGlzIHRoZSBzdWIgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLjxicj48YnI+XHJcblx0ICogRm9ybWF0dGVyIGZ1bmN0aW9uIGNhbiBiZSBkZWZpbmVkIGZvciBlYWNoIGRhdGEgYnkgc3BlY2lmeWluZyBhcyBhbiBvYmplY3QgYW5kIEQzIGZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgc2V0IChleC4gZDMuZm9ybWF0KCckJykpXHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd8b2JqZWN0fSBbZGF0YS5sYWJlbHMuY29sb3JzXSBTZXQgbGFiZWwgdGV4dCBjb2xvcnMuXHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IFtkYXRhLmxhYmVscy5wb3NpdGlvbl0gU2V0IGVhY2ggZGF0YXNldCBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGF0YS5sYWJlbHMucG9zaXRpb24ueD0wXSB4IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLnk9MF0geSBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsKVxyXG5cdCAqIEBzZWUgW0RlbW86IGxhYmVsIGNvbG9yc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsQ29sb3JzKVxyXG5cdCAqIEBzZWUgW0RlbW86IGxhYmVsIGZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsRm9ybWF0KVxyXG5cdCAqIEBzZWUgW0RlbW86IGxhYmVsIG92ZXJsYXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbE92ZXJsYXApXHJcblx0ICogQHNlZSBbRGVtbzogbGFiZWwgcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbFBvc2l0aW9uKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgbGFiZWxzOiB0cnVlLFxyXG5cdCAqXHJcblx0ICogICAvLyBvciBzZXQgc3BlY2lmaWMgb3B0aW9uc1xyXG5cdCAqICAgbGFiZWxzOiB7XHJcblx0ICogICAgIGZvcm1hdDogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXHJcblx0ICpcclxuXHQgKiAgICAgLy8gaXQncyBwb3NzaWJsZSB0byBzZXQgZm9yIGVhY2ggZGF0YVxyXG5cdCAqICAgICBmb3JtYXQ6IHtcclxuXHQgKiAgICAgICAgIGRhdGExOiBmdW5jdGlvbih2LCBpZCwgaSwgaikgeyAuLi4gfSxcclxuXHQgKiAgICAgICAgIC4uLlxyXG5cdCAqICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgIC8vIGFsaWduIHRleHQgdG8gY2VudGVyIG9mIHRoZSAnYmFyJyBzaGFwZSAod29ya3Mgb25seSBmb3IgJ2JhcicgdHlwZSlcclxuXHQgKiAgICAgY2VudGVyZWQ6IHRydWUsXHJcblx0ICpcclxuXHQgKiAgICAgLy8gYXBwbHkgZm9yIGFsbCBsYWJlbCB0ZXh0c1xyXG5cdCAqICAgICBjb2xvcnM6IFwicmVkXCIsXHJcblx0ICpcclxuXHQgKiAgICAgLy8gb3Igc2V0IGRpZmZlcmVudCBjb2xvcnMgcGVyIGRhdGFzZXRcclxuXHQgKiAgICAgLy8gZm9yIG5vdCBzcGVjaWZpZWQgZGF0YXNldCwgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IGNvbG9yIHZhbHVlXHJcblx0ICogICAgIGNvbG9yczoge1xyXG5cdCAqICAgICAgICBkYXRhMTogXCJ5ZWxsb3dcIixcclxuXHQgKiAgICAgICAgZGF0YTM6IFwiZ3JlZW5cIlxyXG5cdCAqICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgIC8vIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb25cclxuXHQgKiAgICAgcG9zaXRpb246IHtcclxuXHQgKiAgICAgICAgeDogLTEwLFxyXG5cdCAqICAgICAgICB5OiAxMFxyXG5cdCAqICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgIC8vIG9yIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb24gYnkgZWFjaCBkYXRhc2V0XHJcblx0ICogICAgIHBvc2l0aW9uOiB7XHJcblx0ICogICAgICAgIGRhdGExOiB7eDogNSwgeTogNX0sXHJcblx0ICogICAgICAgIGRhdGEyOiB7eDogMTAsIHk6IC0yMH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX2xhYmVsczpcclxuXHRcdDxib29sZWFuIHwge1xyXG5cdFx0XHRjZW50ZXJlZD86IGJvb2xlYW47XHJcblx0XHRcdGZvcm1hdD86IEZ1bmN0aW9uO1xyXG5cdFx0XHRjb2xvcnM/OiBzdHJpbmd8e1trZXk6IHN0cmluZ106IHN0cmluZ307XHJcblx0XHRcdHBvc2l0aW9uPzoge1trZXk6IHN0cmluZ106IG51bWJlcn18e1trZXk6IHN0cmluZ106IHt4PzogbnVtYmVyOyB5PzogbnVtYmVyO319XHJcblx0XHR9PiB7fSxcclxuXHRkYXRhX2xhYmVsc19jb2xvcnM6IDxzdHJpbmd8b2JqZWN0fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGRhdGFfbGFiZWxzX3Bvc2l0aW9uOiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogRGVmaW5lIHJlZ2lvbnMgZm9yIGVhY2ggZGF0YS48YnI+XHJcblx0ICogVGhlIHZhbHVlcyBtdXN0IGJlIGFuIGFycmF5IGZvciBlYWNoIGRhdGEgYW5kIGl0IHNob3VsZCBpbmNsdWRlIGFuIG9iamVjdCB0aGF0IGhhcyBgc3RhcnRgLCBgZW5kYCBhbmQgYHN0eWxlYC5cclxuXHQgKiAtIFRoZSBvYmplY3QgdHlwZSBzaG91bGQgYmUgYXM6XHJcblx0ICogICAtIHN0YXJ0IHtudW1iZXJ9OiBTdGFydCBkYXRhIHBvaW50IG51bWJlci4gSWYgbm90IHNldCwgdGhlIHN0YXJ0IHdpbGwgYmUgdGhlIGZpcnN0IGRhdGEgcG9pbnQuXHJcblx0ICogICAtIFtlbmRdIHtudW1iZXJ9OiBFbmQgZGF0YSBwb2ludCBudW1iZXIuIElmIG5vdCBzZXQsIHRoZSBlbmQgd2lsbCBiZSB0aGUgbGFzdCBkYXRhIHBvaW50LlxyXG5cdCAqICAgLSBbc3R5bGUuZGFzaGFycmF5PVwiMiAyXCJdIHtvYmplY3R9OiBUaGUgZmlyc3QgbnVtYmVyIHNwZWNpZmllcyBhIGRpc3RhbmNlIGZvciB0aGUgZmlsbGVkIGFyZWEsIGFuZCB0aGUgc2Vjb25kIGEgZGlzdGFuY2UgZm9yIHRoZSB1bmZpbGxlZCBhcmVhLlxyXG5cdCAqIC0gKipOT1RFOioqIEN1cnJlbnRseSB0aGlzIG9wdGlvbiBzdXBwb3J0cyBvbmx5IGxpbmUgY2hhcnQgYW5kIGRhc2hlZCBzdHlsZS4gSWYgdGhpcyBvcHRpb24gc3BlY2lmaWVkLCB0aGUgbGluZSB3aWxsIGJlIGRhc2hlZCBvbmx5IGluIHRoZSByZWdpb25zLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRyZWdpb25zXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICByZWdpb25zOiB7XHJcblx0ICogICAgIGRhdGExOiBbe1xyXG5cdCAqICAgICAgICAgc3RhcnQ6IDEsXHJcblx0ICogICAgICAgICBlbmQ6IDIsXHJcblx0ICogICAgICAgICBzdHlsZToge1xyXG5cdCAqICAgICAgICAgICAgIGRhc2hhcnJheTogXCI1IDJcIlxyXG5cdCAqICAgICAgICAgfVxyXG5cdCAqICAgICB9LCB7XHJcblx0ICogICAgICAgICBzdGFydDogM1xyXG5cdCAqICAgICB9XSxcclxuXHQgKiAgICAgLi4uXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfcmVnaW9uczogPHtzdGFydD86IG51bWJlcjsgZW5kPzogbnVtYmVyOyBzdHlsZT86IHtkYXNoYXJyYXk6IHN0cmluZzt9fVtdPiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSBzdGFja2luZyB0byBiZSBub3JtYWxpemVkXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gRm9yIHN0YWNraW5nLCAnW2RhdGEuZ3JvdXBzXSgjLmRhdGElMjVFMiUyNTgwJTI1QTRncm91cHMpJyBvcHRpb24gc2hvdWxkIGJlIHNldFxyXG5cdCAqICAgLSB5IEF4aXMgd2lsbCBiZSBzZXQgaW4gcGVyY2VudGFnZSB2YWx1ZSAoMCB+IDEwMCUpXHJcblx0ICogICAtIE11c3QgaGF2ZSBwb3N0aXZlIHZhbHVlc1xyXG5cdCAqIEBuYW1lIGRhdGHigKRzdGFja+KApG5vcm1hbGl6ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhU3RhY2tOb3JtYWxpemVkKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgc3RhY2s6IHtcclxuXHQgKiAgICAgIG5vcm1hbGl6ZTogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3N0YWNrX25vcm1hbGl6ZTogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZGF0YS5zZWxlY3Rpb24gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgZGF0YSBzZWxlY3Rpb24gZW5hYmxlZDxicj48YnI+XHJcblx0ICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRydWUsIHdlIGNhbiBzZWxlY3QgdGhlIGRhdGEgcG9pbnRzIGFuZCBnZXQvc2V0IGl0cyBzdGF0ZSBvZiBzZWxlY3Rpb24gYnkgQVBJIChlLmcuIHNlbGVjdCwgdW5zZWxlY3QsIHNlbGVjdGVkKS5cclxuXHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZW5hYmxlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhU2VsZWN0aW9uKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgIHNlbGVjdGlvbjoge1xyXG5cdCAqICAgICAgIGVuYWJsZWQ6IHRydWVcclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfc2VsZWN0aW9uX2VuYWJsZWQ6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZ3JvdXBlZCBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIHNldCB0cnVlLCBtdWx0aXBsZSBkYXRhIHBvaW50cyB0aGF0IGhhdmUgc2FtZSB4IHZhbHVlIHdpbGwgYmUgc2VsZWN0ZWQgYnkgb25lIHNlbGVjdGlvbi5cclxuXHQgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkZ3JvdXBlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICBzZWxlY3Rpb246IHtcclxuXHQgKiAgICAgICBncm91cGVkOiB0cnVlXHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX3NlbGVjdGlvbl9ncm91cGVkOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGEgY2FsbGJhY2sgZm9yIGVhY2ggZGF0YSBwb2ludCB0byBkZXRlcm1pbmUgaWYgaXQncyBzZWxlY3RhYmxlIG9yIG5vdC48YnI+PGJyPlxyXG5cdCAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgZCBhcyBhbiBhcmd1bWVudCBhbmQgaXQgaGFzIHNvbWUgcGFyYW1ldGVycyBsaWtlIGlkLCB2YWx1ZSwgaW5kZXguIFRoaXMgY2FsbGJhY2sgc2hvdWxkIHJldHVybiBib29sZWFuLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRpc3NlbGVjdGFibGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICBzZWxlY3Rpb246IHtcclxuXHQgKiAgICAgICBpc3NlbGVjdGFibGU6IGZ1bmN0aW9uKGQpIHsgLi4uIH1cclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZTogKCkgPT4gdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG11bHRpcGxlIGRhdGEgcG9pbnRzIHNlbGVjdGlvbiBlbmFibGVkLjxicj48YnI+XHJcblx0ICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpbGUgZGF0YSBwb2ludHMgY2FuIGhhdmUgdGhlIHNlbGVjdGVkIHN0YXRlIGF0IHRoZSBzYW1lIHRpbWUuIElmIGZhbHNlIHNldCwgb25seSBvbmUgZGF0YSBwb2ludCBjYW4gaGF2ZSB0aGUgc2VsZWN0ZWQgc3RhdGUgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSB1bnNlbGVjdGVkIHdoZW4gdGhlIG5ldyBkYXRhIHBvaW50IGlzIHNlbGVjdGVkLlxyXG5cdCAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRtdWx0aXBsZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZGF0YToge1xyXG5cdCAqICAgIHNlbGVjdGlvbjoge1xyXG5cdCAqICAgICAgIG11bHRpcGxlOiBmYWxzZVxyXG5cdCAqICAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0ZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGU6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEVuYWJsZSB0byBzZWxlY3QgZGF0YSBwb2ludHMgYnkgZHJhZ2dpbmcuXHJcblx0ICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIGRhdGEgcG9pbnRzIGNhbiBiZSBzZWxlY3RlZCBieSBkcmFnZ2luZy5cclxuXHQgKiAtICoqTk9URToqKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgc2Nyb2xsaW5nIG9uIHRoZSBjaGFydCB3aWxsIGJlIGRpc2FibGVkIGJlY2F1c2UgZHJhZ2dpbmcgZXZlbnQgd2lsbCBoYW5kbGUgdGhlIGV2ZW50LlxyXG5cdCAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRkcmFnZ2FibGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgc2VsZWN0aW9uOiB7XHJcblx0ICogICAgICAgZHJhZ2dhYmxlOiB0cnVlXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZTogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhIGNhbGxiYWNrIGZvciBvbiBkYXRhIHNlbGVjdGlvbi5cclxuXHQgKiBAbmFtZSBkYXRh4oCkb25zZWxlY3RlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb25zZWxlY3RlZDogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG5cdCAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMVwifVxyXG5cdCAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRkYXRhX29uc2VsZWN0ZWQ6ICgpID0+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYSBjYWxsYmFjayBmb3Igb24gZGF0YSB1bi1zZWxlY3Rpb24uXHJcblx0ICogQG5hbWUgZGF0YeKApG9udW5zZWxlY3RlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGRhdGE6IHtcclxuXHQgKiAgICAgb251bnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcblx0ICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XHJcblx0ICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGRhdGFfb251bnNlbGVjdGVkOiAoKSA9PiB7fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgY2xpcC1wYXRoIGF0dHJpYnV0ZSBmb3IgeCBheGlzIGVsZW1lbnRcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApGNsaXBQYXRoXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gZG9uJ3Qgc2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZVxyXG5cdCAqIGNsaXBQYXRoOiBmYWxzZVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9jbGlwUGF0aDogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHggYXhpcy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHNob3dcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0eXBlIG9mIHggYXhpcy48YnI+PGJyPlxyXG5cdCAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG5cdCAqIC0gdGltZXNlcmllc1xyXG5cdCAqIC0gY2F0ZWdvcnlcclxuXHQgKiAtIGluZGV4ZWRcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHR5cGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICogQGRlZmF1bHQgaW5kZXhlZFxyXG5cdCAqIEBzZWUgW0RlbW86IGluZGV4ZWRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5BcmVhQ2hhcnQpXHJcblx0ICogQHNlZSBbRGVtbzogdGltZXNlcmllc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlRpbWVzZXJpZXNDaGFydClcclxuXHQgKiBAc2VlIFtEZW1vOiBjYXRlZ29yeV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ2F0ZWdvcnlEYXRhKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdHlwZTogPFwiaW5kZXhlZFwifFwidGltZXNlcmllc1wifFwiY2F0ZWdvcnlcIj4gXCJpbmRleGVkXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBob3cgdG8gdHJlYXQgdGhlIHRpbWV6b25lIG9mIHggdmFsdWVzLjxicj5cclxuXHQgKiBJZiB0cnVlLCB0cmVhdCB4IHZhbHVlIGFzIGxvY2FsdGltZS4gSWYgZmFsc2UsIGNvbnZlcnQgdG8gVVRDIGludGVybmFsbHkuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRsb2NhbHRpbWVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgbG9jYWx0aW1lOiBmYWxzZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfbG9jYWx0aW1lOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2F0ZWdvcnkgbmFtZXMgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBUaGlzIG11c3QgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBjYXRlZ29yeSBuYW1lcyBpbiBzdHJpbmcuIElmIGNhdGVnb3J5IG5hbWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBieSBkYXRhLnggb3B0aW9uLCB0aGlzIGlzIG5vdCByZXF1aXJlZC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApGNhdGVnb3JpZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAZGVmYXVsdCBbXVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICBjYXRlZ29yaWVzOiBbXCJDYXRlZ29yeSAxXCIsIFwiQ2F0ZWdvcnkgMlwiLCAuLi5dXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9jYXRlZ29yaWVzOiA8c3RyaW5nW10+IFtdLFxyXG5cclxuXHQvKipcclxuXHQgKiBjZW50ZXJpemUgdGlja3Mgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjZW50ZXJlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGNlbnRlcmVkOiB0cnVlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfY2VudGVyZWQ6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBBIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aWNrIHZhbHVlLiBGb3JtYXQgc3RyaW5nIGlzIGFsc28gYXZhaWxhYmxlIGZvciB0aW1lc2VyaWVzIGRhdGEuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkZm9ybWF0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb258c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgIC8vIGZvciB0aW1lc2VyaWVzLCBhICdkYXRldGltZScgb2JqZWN0IGlzIGdpdmVuIGFzIHBhcmFtZXRlclxyXG5cdCAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG5cdCAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xyXG5cdCAqICAgICAgIH1cclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIGZvciBjYXRlZ29yeSwgaW5kZXgoTnVtYmVyKSBhbmQgY2F0ZWdvcnlOYW1lKFN0cmluZykgYXJlIGdpdmVuIGFzIHBhcmFtZXRlclxyXG5cdCAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oaW5kZXgsIGNhdGVnb3J5TmFtZSkge1xyXG5cdCAqICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnlOYW1lLnN1YnN0cigwLCAxMCk7XHJcblx0ICogICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgICAvLyBmb3IgdGltZXNlcmllcyBmb3JtYXQgc3BlY2lmaWVyXHJcblx0ICogICAgICAgIGZvcm1hdDogXCIlWS0lbS0lZCAlSDolTTolU1wiXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfZm9ybWF0OiA8RnVuY3Rpb258c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XHJcblx0ICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XHJcblx0ICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueC50aWNrLmN1bGxpbmcubWF4LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmdcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0XHJcblx0ICogLSB0cnVlIGZvciBpbmRleGVkIGF4aXMgYW5kIHRpbWVzZXJpZXMgYXhpc1xyXG5cdCAqIC0gZmFsc2UgZm9yIGNhdGVnb3J5IGF4aXNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfY3VsbGluZzoge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmfigKRtYXhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMTBcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IHtcclxuXHQgKiAgICAgICAgICAgbWF4OiA1XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX2N1bGxpbmdfbWF4OiAxMCxcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIG51bWJlciBvZiB4IGF4aXMgdGlja3MgdG8gc2hvdy48YnI+PGJyPlxyXG5cdCAqIFRoaXMgb3B0aW9uIGhpZGVzIHRpY2sgbGluZXMgdG9nZXRoZXIgd2l0aCB0aWNrIHRleHQuIElmIHRoaXMgb3B0aW9uIGlzIHVzZWQgb24gdGltZXNlcmllcyBheGlzLCB0aGUgdGlja3MgcG9zaXRpb24gd2lsbCBiZSBkZXRlcm1pbmVkIHByZWNpc2VseSBhbmQgbm90IG5pY2VseSBwb3NpdGlvbmVkIChlLmcuIGl0IHdpbGwgaGF2ZSByb3VnaCBzZWNvbmQgdmFsdWUpLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGNvdW50XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgY291bnQ6IDVcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja19jb3VudDogPG51bWJlcnx1bmRlZmluZWQ+dW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgbGluZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHNob3c6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfc2hvdzogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIHRleHQuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdGV4dOKApHNob3dcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgeCBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICAgICBwb3NpdGlvbjoge1xyXG5cdCAqICAgICAgICAgICB4OiAxMCxcclxuXHQgKiAgICAgICAgICAgeTogMTBcclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuXHQvKipcclxuXHQgKiBGaXQgeCBheGlzIHRpY2tzLlxyXG5cdCAqIC0gKip0cnVlKio6IHRpY2tzIHdpbGwgYmUgcG9zaXRpb25lZCBuaWNlbHkgdG8gaGF2ZSBzYW1lIGludGVydmFscy5cclxuXHQgKiAtICoqZmFsc2UqKjogdGlja3Mgd2lsbCBiZSBwb3NpdGlvbmVkIGFjY29yZGluZyB0byB4IHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRmaXRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tGaXR0aW5nKVxyXG5cdCAqIEBzZWUgW0RlbW86IGZvciB0aW1lc2VyaWVzIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja1RpbWVzZXJpZXMpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBmaXQ6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfZml0OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIHggdmFsdWVzIG9mIHRpY2tzIG1hbnVhbGx5Ljxicj48YnI+XHJcblx0ICogSWYgdGhpcyBvcHRpb24gaXMgcHJvdmlkZWQsIHRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja3Mgd2lsbCBiZSBkZXRlcm1pbmVkIGJhc2VkIG9uIHRob3NlIHZhbHVlcy48YnI+XHJcblx0ICogVGhpcyBvcHRpb24gd29ya3Mgd2l0aCBgdGltZXNlcmllc2AgZGF0YSBhbmQgdGhlIHggdmFsdWVzIHdpbGwgYmUgcGFyc2VkIGFjY29kaW5nIHRvIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBhbmQgZGF0YS54Rm9ybWF0IG9wdGlvbi5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR2YWx1ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cclxuXHQgKiBAZGVmYXVsdCBudWxsXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB2YWx1ZXM6IFsxLCAyLCA0LCA4LCAxNiwgMzIsIC4uLl0sXHJcblx0ICpcclxuXHQgKiAgICAgICAvLyBhbiBBcnJheSB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWRcclxuXHQgKiAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG5cdCAqICAgICAgIFx0cmV0dXJuIFsgLi4uIF07XHJcblx0ICogICAgICAgfVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3ZhbHVlczogPChzdHJpbmd8RGF0ZXxudW1iZXIpW118KCgpPT4gbnVtYmVyW10pfG51bGw+IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJvdGF0ZSB4IGF4aXMgdGljayB0ZXh0IGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgZm9yICdjYXRlZ29yeScgYW5kICd0aW1lc2VyaWVzJyB0eXBlIGF4aXMuXHJcblx0ICogLSAqKk5PVEU6KiogVGhlIGNvbmRpdGlvbnMgd2hlcmUgYGF1dG9yb3RhdGVgIGlzIGVuYWJsZWQgYXJlOlxyXG5cdCAqICAgLSBheGlzLngudHlwZT0nY2F0ZWdvcnknIG9yICd0aW1lc2VyaWVzXHJcblx0ICogICAtIGF4aXMueC50aWNrLm11bHRpbGluZT1mYWxzZVxyXG5cdCAqICAgLSBheGlzLngudGljay5jdWxsaW5nPWZhbHNlXHJcblx0ICogICAtIGF4aXMueC50aWNrLmZpdD10cnVlXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkYXV0b3JvdGF0ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tBdXRvcm90YXRlKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgcm90YXRlOiAxNSxcclxuXHQgKiAgICAgICBhdXRvcm90YXRlOiB0cnVlLFxyXG5cdCAqICAgICAgIG11bHRpbGluZTogZmFsc2UsXHJcblx0ICogICAgICAgY3VsbGluZzogZmFsc2UsXHJcblx0ICogICAgICAgZml0OiB0cnVlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfYXV0b3JvdGF0ZTogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJvdGF0ZSB4IGF4aXMgdGljayB0ZXh0LlxyXG5cdCAqIC0gSWYgeW91IHNldCBuZWdhdGl2ZSB2YWx1ZSwgaXQgd2lsbCByb3RhdGUgdG8gb3Bwb3NpdGUgZGlyZWN0aW9uLlxyXG5cdCAqIC0gQXBwbGllZCB3aGVuIFtgYXhpcy5yb3RhdGVkYF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0cm90YXRlZCkgb3B0aW9uIGlzIGBmYWxzZWAuXHJcblx0ICogLSBBcyBsb25nIGFzIGBheGlzX3hfdGlja19maXRgIGlzIHNldCB0byBgdHJ1ZWAgaXQgd2lsbCBjYWxjdWxhdGUgYW4gb3ZlcmZsb3cgZm9yIHRoZSB5MiBheGlzIGFuZCBhZGQgdGhpcyB2YWx1ZSB0byB0aGUgcmlnaHQgcGFkZGluZy5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRyb3RhdGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlJvdGF0ZVhBeGlzVGlja1RleHQpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICByb3RhdGU6IDYwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3RpY2tfcm90YXRlOiAwLFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IHggYXhpcyBvdXRlciB0aWNrLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG91dGVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBvdXRlcjogZmFsc2VcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfdGlja19vdXRlcjogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRpY2sgdGV4dCB0byBiZSBtdWx0aWxpbmVcclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrIGFuZCAnYXhpcy54LnRpY2sud2lkdGgnIG9wdGlvbiBpcyBpZ25vcmVkLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApG11bHRpbGluZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja011bHRpbGluZSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIG11bHRpbGluZTogZmFsc2VcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGV4YW1wbGUgb2YgbGluZSBicmVhayB3aXRoICdcXG4nXHJcblx0ICogLy8gSW4gdGhpcyBjYXNlLCAnYXhpcy54LnRpY2sud2lkdGgnIGlzIGlnbm9yZWRcclxuXHQgKiBkYXRhOiB7XHJcblx0ICogICAgeDogXCJ4XCIsXHJcblx0ICogICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgICBbXCJ4XCIsIFwibG9uZ1xcbnRleHRcIiwgXCJBbm90aGVyXFxuTG9uZ1xcblRleHRcIl0sXHJcblx0ICogICAgICAgIC4uLlxyXG5cdCAqICAgIF0sXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX211bHRpbGluZTogdHJ1ZSxcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aWNrIHdpZHRoXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgPiBXaGVuIHggdGljayB0ZXh0IGNvbnRhaW5zIGBcXG5gLCB0aGlzIG9wdGlvbiBpcyBpZ25vcmVkLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHdpZHRoXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IG51bGxcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHdpZHRoOiA1MFxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3dpZHRoOiA8bnVtYmVyfG51bGw+IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0byBkaXNwbGF5IHN5c3RlbSB0b29sdGlwKHZpYSAndGl0bGUnIGF0dHJpYnV0ZSkgZm9yIHRpY2sgdGV4dFxyXG5cdCAqIC0gKipOT1RFOioqIE9ubHkgYXZhaWxhYmxlIGZvciBjYXRlZ29yeSBheGlzIHR5cGUgKGBheGlzLngudHlwZT0nY2F0ZWdvcnknYClcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR0b29sdGlwXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdG9vbHRpcDogdHJ1ZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF90aWNrX3Rvb2x0aXA6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWF4IHZhbHVlIG9mIHggYXhpcyByYW5nZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApG1heFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IG1heCBTZXQgdGhlIG1heCB2YWx1ZVxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW21heC5maXQ9ZmFsc2VdIFdoZW4gc3BlY2lmaWVkIGBtYXgudmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYm91bmQgZGF0YSB2YWx1ZSwgc2V0dGluZyBgdHJ1ZWAgd2lsbCBtYWtlIHggYXhpcyBtYXggdG8gYmUgZml0dGVkIHRvIHRoZSBib3VuZCBkYXRhIG1heCB2YWx1ZS5cclxuXHQgKiAtICoqTk9URToqKiBJZiB0aGUgYm91bmQgZGF0YSBtYXggdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBgbWF4LnZhbHVlYCwgdGhlIHggYXhpcyBtYXggd2lsbCBiZSBsaW1pdGVkIGFzIHRoZSBnaXZlbiBgbWF4LnZhbHVlYC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW21heC52YWx1ZV0gU2V0IHRoZSBtYXggdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgbWF4OiAxMDAsXHJcblx0ICpcclxuXHQgKiAgICAgbWF4OiB7XHJcblx0ICogICAgICAgLy8gJ2ZpdD10cnVlJyB3aWxsIG1ha2UgeCBheGlzIG1heCB0byBiZSBsaW1pdGVkIGFzIHRoZSBib3VuZCBkYXRhIHZhbHVlIG1heCB3aGVuICdtYXgudmFsdWUnIGlzIGdyZWF0ZXIuXHJcblx0ICogICAgICAgLy8gLSB3aGVuIGJvdW5kIGRhdGEgbWF4IGlzICcxMCcgYW5kIG1heC52YWx1ZTogJzEwMCcgPT0+ICB4IGF4aXMgbWF4IHdpbGwgYmUgJzEwJ1xyXG5cdCAqICAgICAgIC8vIC0gd2hlbiBib3VuZCBkYXRhIG1heCBpcyAnMTAwMCcgYW5kIG1heC52YWx1ZTogJzEwMCcgPT0+IHggYXhpcyBtYXggd2lsbCBiZSAnMTAwJ1xyXG5cdCAqICAgICAgIGZpdDogdHJ1ZSxcclxuXHQgKiAgICAgICB2YWx1ZTogMTAwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X21heDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1pbiB2YWx1ZSBvZiB4IGF4aXMgcmFuZ2UuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRtaW5cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW4gU2V0IHRoZSBtaW4gdmFsdWVcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFttaW4uZml0PWZhbHNlXSBXaGVuIHNwZWNpZmllZCBgbWluLnZhbHVlYCBpcyBsb3dlciB0aGFuIHRoZSBib3VuZCBkYXRhIHZhbHVlLCBzZXR0aW5nIGB0cnVlYCB3aWxsIG1ha2UgeCBheGlzIG1pbiB0byBiZSBmaXR0ZWQgdG8gdGhlIGJvdW5kIGRhdGEgbWluIHZhbHVlLlxyXG5cdCAqIC0gKipOT1RFOioqIElmIHRoZSBib3VuZCBkYXRhIG1pbiB2YWx1ZSBpcyBsb3dlciB0aGFuIHRoZSBgbWluLnZhbHVlYCwgdGhlIHggYXhpcyBtaW4gd2lsbCBiZSBsaW1pdGVkIGFzIHRoZSBnaXZlbiBgbWluLnZhbHVlYC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW21pbi52YWx1ZV0gU2V0IHRoZSBtaW4gdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgbWluOiAtMTAwLFxyXG5cdCAqXHJcblx0ICogICAgIG1pbjoge1xyXG5cdCAqICAgICAgIC8vICdmaXQ9dHJ1ZScgd2lsbCBtYWtlIHggYXhpcyBtaW4gdG8gYmUgbGltaXRlZCBhcyB0aGUgYm91bmQgZGF0YSB2YWx1ZSBtaW4gd2hlbiAnbWluLnZhbHVlJyBpcyBsb3dlci5cclxuXHQgKiAgICAgICAvLyAtIHdoZW4gYm91bmQgZGF0YSBtaW4gaXMgJy0xMCcgYW5kIG1pbi52YWx1ZTogJy0xMDAnID09PiAgeCBheGlzIG1pbiB3aWxsIGJlICctMTAnXHJcblx0ICogICAgICAgLy8gLSB3aGVuIGJvdW5kIGRhdGEgbWluIGlzICctMTAwMCcgYW5kIG1pbi52YWx1ZTogJy0xMDAnID09PiB4IGF4aXMgbWluIHdpbGwgYmUgJy0xMDAnXHJcblx0ICogICAgICAgZml0OiB0cnVlLFxyXG5cdCAqICAgICAgIHZhbHVlOiAtMTAwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X21pbjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHBhZGRpbmcgZm9yIHggYXhpcy48YnI+PGJyPlxyXG5cdCAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIHJhbmdlIG9mIHggYXhpcyB3aWxsIGluY3JlYXNlL2RlY3JlYXNlIGFjY29yZGluZyB0byB0aGUgdmFsdWVzLlxyXG5cdCAqIElmIG5vIHBhZGRpbmcgaXMgbmVlZGVkIGluIHRoZSByYWdlIG9mIHggYXhpcywgMCBzaG91bGQgYmUgc2V0LlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICBUaGUgcGFkZGluZyB2YWx1ZXMgYXJlbid0IGJhc2VkIG9uIHBpeGVscy4gSXQgZGlmZmVycyBhY2NvcmRpbmcgYXhpcyB0eXBlczxicj5cclxuXHQgKiAgIC0gKipjYXRlZ29yeToqKiBUaGUgdW5pdCBvZiB0aWNrIHZhbHVlXHJcblx0ICogICAgIGV4LiB0aGUgZ2l2ZW4gdmFsdWUgYDFgLCBpcyBzYW1lIGFzIHRoZSB3aWR0aCBvZiAxIHRpY2sgd2lkdGhcclxuXHQgKiAgIC0gKip0aW1lc2VyaWVzOioqIE51bWVyaWMgdGltZSB2YWx1ZVxyXG5cdCAqICAgICBleC4gdGhlIGdpdmVuIHZhbHVlIGAxMDAwKjYwKjYwKjI0YCwgd2hpY2ggaXMgbnVtZXJpYyB0aW1lIGVxdWl2YWxlbnQgb2YgYSBkYXksIGlzIHNhbWUgYXMgdGhlIHdpZHRoIG9mIDEgdGljayB3aWR0aFxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkcGFkZGluZ1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdHxudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHg6IHtcclxuXHQgKiAgICAgcGFkZGluZzoge1xyXG5cdCAqICAgICAgIC8vIHdoZW4gYXhpcyB0eXBlIGlzICdjYXRlZ29yeSdcclxuXHQgKiAgICAgICBsZWZ0OiAxLCAgLy8gc2V0IGxlZnQgcGFkZGluZyB3aWR0aCBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgdGljaydzIHdpZHRoXHJcblx0ICogICAgICAgcmlnaHQ6IDAuNSAgLy8gc2V0IHJpZ2h0IHBhZGRpbmcgd2lkdGggYXMgaGFsZiBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIHRpY2sncyB3aWR0aFxyXG5cdCAqXHJcblx0ICogICAgICAgLy8gd2hlbiBheGlzIHR5cGUgaXMgJ3RpbWVzZXJpZXMnXHJcblx0ICogICAgICAgbGVmdDogMTAwMCo2MCo2MCoyNCwgIC8vIHNldCBsZWZ0IHBhZGRpbmcgd2lkdGggb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcclxuXHQgKiAgICAgICByaWdodDogMTAwMCo2MCo2MCoxMiAgIC8vIHNldCByaWdodCBwYWRkaW5nIHdpZHRoIGFzIGhhbGYgb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcclxuXHQgKiAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cclxuXHQgKiAgICAgcGFkZGluZzogMTBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X3BhZGRpbmc6IDxudW1iZXJ8e2xlZnQ/OiBudW1iZXI7IHJpZ2h0PzogbnVtYmVyO30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgaGVpZ2h0IG9mIHggYXhpcy48YnI+PGJyPlxyXG5cdCAqIFRoZSBoZWlnaHQgb2YgeCBheGlzIGNhbiBiZSBzZXQgbWFudWFsbHkgYnkgdGhpcyBvcHRpb24uIElmIHlvdSBuZWVkIG1vcmUgc3BhY2UgZm9yIHggYXhpcywgcGxlYXNlIHVzZSB0aGlzIG9wdGlvbiBmb3IgdGhhdC4gVGhlIHVuaXQgaXMgcGl4ZWwuXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRoZWlnaHRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIGhlaWdodDogMjBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc194X2hlaWdodDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRlZmF1bHQgZXh0ZW50IGZvciBzdWJjaGFydCBhbmQgem9vbS4gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR44oCkZXh0ZW50XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIC8vIGV4dGVudCByYW5nZSBhcyBhIHBpeGVsIHZhbHVlXHJcblx0ICogICAgIGV4dGVudDogWzAsIDIwMF0sXHJcblx0ICpcclxuXHQgKiAgICAgLy8gd2hlbiBheGlzIGlzICd0aW1lc2VyaWVzJywgcGFyc2FibGUgZGF0ZXRpbWUgc3RyaW5nXHJcblx0ICogICAgIGV4dGVudDogW1wiMjAxOS0wMy0wMVwiLCBcIjIwMTktMDMtMDVcIl0sXHJcblx0ICpcclxuXHQgKiAgICAgLy8gcmV0dXJuIGV4dGVudCB2YWx1ZVxyXG5cdCAqICAgICBleHRlbnQ6IGZ1bmN0aW9uKGRvbWFpbiwgc2NhbGUpIHtcclxuXHQgKiAgICBcdCB2YXIgZXh0ZW50ID0gZG9tYWluLm1hcChmdW5jdGlvbih2KSB7XHJcblx0ICogICAgIFx0ICAgIHJldHVybiBzY2FsZSh2KTtcclxuXHQgKiAgICAgXHQgfSk7XHJcblx0ICpcclxuXHQgKiAgIFx0IC8vIGl0IHNob3VsZCByZXR1cm4gYSBmb3JtYXQgb2YgYXJyYXlcclxuXHQgKiAgIFx0IC8vIGV4KSBbMCwgNTg0XVxyXG5cdCAqICAgICBcdCByZXR1cm4gZXh0ZW50O1xyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeF9leHRlbnQ6IDwobnVtYmVyfHN0cmluZylbXXxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxhYmVsIG9uIHggYXhpcy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc2V0IHggYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi5cclxuXHQgKiBgc3RyaW5nYCBhbmQgYG9iamVjdGAgY2FuIGJlIHBhc3NlZCBhbmQgd2UgY2FuIGNoYW5nZSB0aGUgcG9pc2l0b24gYnkgcGFzc2luZyBvYmplY3QgdGhhdCBoYXMgcG9zaXRpb24ga2V5Ljxicj5cclxuXHQgKiBBdmFpbGFibGUgcG9zaXRpb24gZGlmZmVycyBhY2NvcmRpbmcgdG8gdGhlIGF4aXMgZGlyZWN0aW9uICh2ZXJ0aWNhbCBvciBob3Jpem9udGFsKS5cclxuXHQgKiBJZiBzdHJpbmcgc2V0LCB0aGUgcG9zaXRpb24gd2lsbCBiZSB0aGUgZGVmYXVsdC5cclxuXHQgKlxyXG5cdCAqICAtICoqSWYgaXQncyBob3Jpem9udGFsIGF4aXM6KipcclxuXHQgKiAgICAtIGlubmVyLXJpZ2h0IFtkZWZhdWx0XVxyXG5cdCAqICAgIC0gaW5uZXItY2VudGVyXHJcblx0ICogICAgLSBpbm5lci1sZWZ0XHJcblx0ICogICAgLSBvdXRlci1yaWdodFxyXG5cdCAqICAgIC0gb3V0ZXItY2VudGVyXHJcblx0ICogICAgLSBvdXRlci1sZWZ0XHJcblx0ICogIC0gKipJZiBpdCdzIHZlcnRpY2FsIGF4aXM6KipcclxuXHQgKiAgICAtIGlubmVyLXRvcCBbZGVmYXVsdF1cclxuXHQgKiAgICAtIGlubmVyLW1pZGRsZVxyXG5cdCAqICAgIC0gaW5uZXItYm90dG9tXHJcblx0ICogICAgLSBvdXRlci10b3BcclxuXHQgKiAgICAtIG91dGVyLW1pZGRsZVxyXG5cdCAqICAgIC0gb3V0ZXItYm90dG9tXHJcblx0ICogQG5hbWUgYXhpc+KApHjigKRsYWJlbFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ3xvYmplY3R9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIGxhYmVsOiBcIllvdXIgWCBBeGlzXCJcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICpcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB4OiB7XHJcblx0ICogICAgIGxhYmVsOiB7XHJcblx0ICogICAgICAgIHRleHQ6IFwiWW91ciBYIEF4aXNcIixcclxuXHQgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItY2VudGVyXCJcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfbGFiZWw6IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB4IEF4aXMuXHJcblx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geCBBeGlzIHZhbHVlIGlmIGRvbWFpbiBvcHRpb24gaXNuJ3Qgc2V0LlxyXG5cdCAqXHJcblx0ICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxyXG5cdCAqXHJcblx0ICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqIHwgZG9tYWluIHwgQXJyYXkgfCAtIHwgU2V0IHRoZSBkb21haW4gdmFsdWUgfFxyXG5cdCAqIHwgdGljay5vdXRlciB8IGJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcclxuXHQgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcclxuXHQgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcclxuXHQgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcclxuXHQgKiBAbmFtZSBheGlz4oCkeOKApGF4ZXNcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXHJcblx0ICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiB4OiB7XHJcblx0ICogICAgYXhlczogW1xyXG5cdCAqICAgICAge1xyXG5cdCAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB4IEF4aXMgZG9tYWluIHZhbHVlXHJcblx0ICogICAgICAgIGRvbWFpbjogWzAsIDEwMDBdLFxyXG5cdCAqICAgICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxyXG5cdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG5cdCAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICBjb3VudDogMixcclxuXHQgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxyXG5cdCAqICAgICAgICB9XHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgLi4uXHJcblx0ICogICAgXVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3hfYXhlczogPG9iamVjdFtdPltdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHkgQXhpcyAgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgY2xpcC1wYXRoIGF0dHJpYnV0ZSBmb3IgeSBheGlzIGVsZW1lbnRcclxuXHQgKiAtICoqTk9URSoqOiBgY2xpcC1wYXRoYCBhdHRyaWJ1dGUgZm9yIHkgQXhpcyBpcyBzZXQgb25seSB3aGVuIGBheGlzLnkuaW5uZXJgIG9wdGlvbiBpcyB0cnVlLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkY2xpcFBhdGhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuXHQgKiBjbGlwUGF0aDogZmFsc2VcclxuXHQgKi9cclxuXHRheGlzX3lfY2xpcFBhdGg6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB5IGF4aXMuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHNob3c6IGZhbHNlXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9zaG93OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdHlwZSBvZiB5IGF4aXMuPGJyPjxicj5cclxuXHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuXHQgKiAgIC0gdGltZXNlcmllc1xyXG5cdCAqICAgLSBpbmRleGVkXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0eXBlXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqIEBkZWZhdWx0IFwiaW5kZXhlZFwiXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHR5cGU6IFwidGltZXNlcmllc1wiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90eXBlOiA8XCJpbmRleGVkXCJ8XCJjYXRlZ29yeVwifFwiaW5kZXhlZFwifHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWF4IHZhbHVlIG9mIHkgYXhpcy5cclxuXHQgKiAtICoqTk9URToqKiBQYWRkaW5nIHdpbGwgYmUgYWRkZWQgYmFzZWQgb24gdGhpcyB2YWx1ZSwgc28gaWYgeW91IGRvbid0IG5lZWQgdGhlIHBhZGRpbmcsIHBsZWFzZSBzZXQgYXhpcy55LnBhZGRpbmcgdG8gZGlzYWJsZSBpdCAoZS5nLiBheGlzLnkucGFkZGluZyA9IDApLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkbWF4XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBtYXg6IDEwMDBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X21heDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1pbiB2YWx1ZSBvZiB5IGF4aXMuXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIFBhZGRpbmcgd2lsbCBiZSBhZGRlZCBiYXNlZCBvbiB0aGlzIHZhbHVlLCBzbyBpZiB5b3UgZG9uJ3QgbmVlZCB0aGUgcGFkZGluZywgcGxlYXNlIHNldCBheGlzLnkucGFkZGluZyB0byBkaXNhYmxlIGl0IChlLmcuIGF4aXMueS5wYWRkaW5nID0gMCkuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKRtaW5cclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIG1pbjogMTAwMFxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfbWluOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGFuZ2UgdGhlIGRpcmVjdGlvbiBvZiB5IGF4aXMuPGJyPjxicj5cclxuXHQgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkaW52ZXJ0ZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIGludmVydGVkOiB0cnVlXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9pbnZlcnRlZDogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBjZW50ZXIgdmFsdWUgb2YgeSBheGlzLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkY2VudGVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBjZW50ZXI6IDBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X2NlbnRlcjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyB5IGF4aXMgaW5zaWRlIG9mIHRoZSBjaGFydC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGlubmVyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBpbm5lcjogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfaW5uZXI6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbGFiZWwgb24geSBheGlzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzZXQgeSBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGxhYmVsXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7c3RyaW5nfG9iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7fVxyXG5cdCAqIEBzZWUgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKSBmb3IgcG9zaXRpb24gc3RyaW5nIHZhbHVlLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBsYWJlbDogXCJZb3VyIFkgQXhpc1wiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICBsYWJlbDoge1xyXG5cdCAqICAgICAgICB0ZXh0OiBcIllvdXIgWSBBeGlzXCIsXHJcblx0ICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLW1pZGRsZVwiXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X2xhYmVsOiA8c3RyaW5nfG9iamVjdD4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBmb3JtYXR0ZXIgZm9yIHkgYXhpcyB0aWNrIHRleHQuPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGQzLmZvcm1hdCBvYmplY3QgYXMgd2VsbCBhcyBhIGZ1bmN0aW9uIHlvdSBkZWZpbmUuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkZm9ybWF0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuXHQgKiAgICAgICAgICAgcmV0dXJuIHguZ2V0RnVsbFllYXIoKTtcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfZm9ybWF0OiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cclxuXHQgKiBJZiB0cnVlIGlzIHNldCwgdGhlIHRpY2tzIHdpbGwgYmUgY3VsbGVkLCB0aGVuIG9ubHkgbGltaXR0ZWQgdGljayB0ZXh0IHdpbGwgYmUgc2hvd24uIFRoaXMgb3B0aW9uIGRvZXMgbm90IGhpZGUgdGhlIHRpY2sgbGluZXMuIElmIGZhbHNlIGlzIHNldCwgYWxsIG9mIHRpY2tzIHdpbGwgYmUgc2hvd24uPGJyPjxicj5cclxuXHQgKiBXZSBjYW4gY2hhbmdlIHRoZSBudW1iZXIgb2YgdGlja3MgdG8gYmUgc2hvd24gYnkgYXhpcy55LnRpY2suY3VsbGluZy5tYXguXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY3VsbGluZ1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfY3VsbGluZzogZmFsc2UsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGN1bGxpbmfigKRtYXhcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgNVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgY3VsbGluZzoge1xyXG5cdCAqICAgICAgICAgICBtYXg6IDVcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfY3VsbGluZ19tYXg6IDUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgeSBheGlzIG91dGVyIHRpY2suXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkb3V0ZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIG91dGVyOiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX291dGVyOiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgeSBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHZhbHVlc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fEZ1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IG51bGxcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHZhbHVlczogWzEwMCwgMTAwMCwgMTAwMDBdLFxyXG5cdCAqXHJcblx0ICogICAgICAgLy8gYW4gQXJyYXkgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXHJcblx0ICogICAgICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcclxuXHQgKiAgICAgICBcdHJldHVybiBbIC4uLiBdO1xyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfdGlja192YWx1ZXM6IDxudW1iZXJbXXwoKCk9PiBudW1iZXJbXSl8bnVsbD4gbnVsbCxcclxuXHJcblx0LyoqXHJcblx0ICogUm90YXRlIHkgYXhpcyB0aWNrIHRleHQuXHJcblx0ICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcblx0ICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYHRydWVgLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHJvdGF0ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCAwXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICByb3RhdGU6IDYwXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfcm90YXRlOiAwLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cclxuXHQgKiAtICoqTk9URToqKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgY2FsY3VsYXRlZCBwcmVjaXNlbHksIHNvIHRoZSB2YWx1ZXMgb24gdGhlIHRpY2tzIHdpbGwgbm90IGJlIHJvdW5kZWQgbmljZWx5LiBJbiB0aGUgY2FzZSwgYXhpcy55LnRpY2suZm9ybWF0IG9yIGF4aXMueS50aWNrLnZhbHVlcyB3aWxsIGJlIGhlbHBmdWwuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY291bnRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjb3VudDogNVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV90aWNrX2NvdW50OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IG9yIGhpZGUgeSBheGlzIHRpY2sgbGluZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHNob3c6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfc2hvdzogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGF4aXMgdGljayBzdGVwKGludGVydmFsKSBzaXplLlxyXG5cdCAqIC0gKipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgYXhpcy55LnRpY2suY291bnRgIG9yIGBheGlzLnkudGljay52YWx1ZXNgIG9wdGlvbnMgYXJlIHNldC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRzdGVwU2l6ZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5TdGVwU2l6ZUZvcllBeGlzKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxyXG5cdCAqICAgICAgIC8vIGV4KSAnc3RlcFNpemU9MTUnID09PiBbMCwgMTUsIDMwLCA0NSwgNjBdXHJcblx0ICogICAgICAgc3RlcFNpemU6IDE1XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfc3RlcFNpemU6IDxudW1iZXJ8bnVsbD4gbnVsbCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHkgYXhpcyB0aWNrIHRleHQuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHNob3dcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3lfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgeSBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5OiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICAgICBwb3NpdGlvbjoge1xyXG5cdCAqICAgICAgICAgICB4OiAxMCxcclxuXHQgKiAgICAgICAgICAgeTogMTBcclxuXHQgKiAgICAgICAgIH1cclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cclxuXHQgKiAtICoqTk9URToqKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgY2FsY3VsYXRlZCBwcmVjaXNlbHksIHNvIHRoZSB2YWx1ZXMgb24gdGhlIHRpY2tzIHdpbGwgbm90IGJlIHJvdW5kZWQgbmljZWx5LiBJbiB0aGUgY2FzZSwgYXhpcy55LnRpY2suZm9ybWF0IG9yIGF4aXMueS50aWNrLnZhbHVlcyB3aWxsIGJlIGhlbHBmdWwuXHJcblx0ICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGltZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aW1lIHRpbWUgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3RpbWUudmFsdWVdIEQzJ3MgdGltZSBpbnRlcnZhbCBmdW5jdGlvbiAoaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUjaW50ZXJ2YWxzKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeToge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgdGltZToge1xyXG5cdCAqICAgICAgICAgIC8vIHRpY2tzIGF0IDE1LW1pbnV0ZSBpbnRlcnZhbHNcclxuXHQgKiAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtc2NhbGUvYmxvYi9tYXN0ZXIvUkVBRE1FLm1kI3RpbWVfdGlja3NcclxuXHQgKiAgICAgICAgICB2YWx1ZTogZDMudGltZU1pbnV0ZS5ldmVyeSgxNSlcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0Ly8gQFRPRE86IG5vdCBmdWxseSBpbXBsZW1lbnRlZCB5ZXRcclxuXHRheGlzX3lfdGlja190aW1lX3ZhbHVlOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBwYWRkaW5nIGZvciB5IGF4aXMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNldCBwYWRkaW5nIGZvciB5IGF4aXMgdG8gY3JlYXRlIG1vcmUgc3BhY2Ugb24gdGhlIGVkZ2Ugb2YgdGhlIGF4aXMuXHJcblx0ICogVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgYW5kIGl0IGNhbiBpbmNsdWRlIHRvcCBhbmQgYm90dG9tLiB0b3AsIGJvdHRvbSB3aWxsIGJlIHRyZWF0ZWQgYXMgcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gR2l2ZW4gdmFsdWVzIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB5IEF4aXMgZG9tYWluIHZhbHVlIGZvciBwYWRkaW5nXHJcblx0ICogICAtIEZvciBhcmVhIGFuZCBiYXIgdHlwZSBjaGFydHMsIFthcmVhLnplcm9iYXNlZF0oIy5hcmVhKSBvciBbYmFyLnplcm9iYXNlZF0oIy5iYXIpIG9wdGlvbnMgc2hvdWxkIGJlIHNldCB0byAnZmFsc2VgIHRvIGdldCBwYWRkZWQgYm90dG9tLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkcGFkZGluZ1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdHxudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgcGFkZGluZzoge1xyXG5cdCAqICAgICAgIHRvcDogMCxcclxuXHQgKiAgICAgICBib3R0b206IDBcclxuXHQgKiAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cclxuXHQgKiAgICAgcGFkZGluZzogMTBcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195X3BhZGRpbmc6IDxudW1iZXJ8e3RvcD86IG51bWJlcjsgYm90dG9tPzogbnVtYmVyO30+IHt9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZGVmYXVsdCByYW5nZSBvZiB5IGF4aXMuPGJyPjxicj5cclxuXHQgKiBUaGlzIG9wdGlvbiBzZXQgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHkgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeeKApGRlZmF1bHRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtBcnJheX1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9kZWZhdWx0OiA8bnVtYmVyW118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhZGRpdGlvbmFsIGF4ZXMgZm9yIHkgQXhpcy5cclxuXHQgKiAtICoqTk9URToqKiBBeGlzJyBzY2FsZSBpcyBiYXNlZCBvbiB5IEF4aXMgdmFsdWUgaWYgZG9tYWluIG9wdGlvbiBpc24ndCBzZXQuXHJcblx0ICpcclxuXHQgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XHJcblx0ICpcclxuXHQgKiB8IE5hbWUgfCBUeXBlIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogfCBkb21haW4gfCBBcnJheSB8IC0gfCBTZXQgdGhlIGRvbWFpbiB2YWx1ZSB8XHJcblx0ICogfCB0aWNrLm91dGVyIHwgYm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxyXG5cdCAqIHwgdGljay5mb3JtYXQgfCBGdW5jdGlvbiB8IC0gfCBTZXQgZm9ybWF0dGVyIGZvciB0aWNrIHRleHQgfFxyXG5cdCAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxyXG5cdCAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxyXG5cdCAqIEBuYW1lIGF4aXPigKR54oCkYXhlc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlcylcclxuXHQgKiBAc2VlIFtEZW1vOiBEb21haW5dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlc0RvbWFpbilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIHk6IHtcclxuXHQgKiAgICBheGVzOiBbXHJcblx0ICogICAgICB7XHJcblx0ICogICAgICAgIC8vIGlmIHNldCwgd2lsbCBub3QgYmUgY29ycmVsYXRlZCB3aXRoIHRoZSBtYWluIHkgQXhpcyBkb21haW4gdmFsdWVcclxuXHQgKiAgICAgICAgZG9tYWluOiBbMCwgMTAwMF0sXHJcblx0ICogICAgICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXHJcblx0ICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcblx0ICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIGNvdW50OiAyLFxyXG5cdCAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXHJcblx0ICogICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICAuLi5cclxuXHQgKiAgICBdXHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeV9heGVzOiA8b2JqZWN0W10+IFtdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHkyIEF4aXMgIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMuXHJcblx0ICogLSAqKk5PVEUqKjpcclxuXHQgKiAgIC0gV2hlbiBzZXQgdG8gYGZhbHNlYCB3aWxsIG5vdCBnZW5lcmF0ZSB5MiBheGlzIG5vZGUuIEluIHRoaXMgY2FzZSwgYWxsICd5MicgYXhpcyByZWxhdGVkIGZ1bmN0aW9uYWxpdHkgd29uJ3Qgd29yayBwcm9wZXJseS5cclxuXHQgKiAgIC0gSWYgbmVlZCB0byB1c2UgJ3kyJyByZWxhdGVkIG9wdGlvbnMgd2hpbGUgeTIgaXNuJ3QgdmlzaWJsZSwgc2V0IHRoZSB2YWx1ZSBgdHJ1ZWAgYW5kIGNvbnRyb2wgdmlzaWJpbGl0eSBieSBjc3MgZGlzcGxheSBwcm9wZXJ0eS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgc2hvdzogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3Nob3c6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWF4IHZhbHVlIG9mIHkyIGF4aXMuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkbWF4XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgbWF4OiAxMDAwXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfbWF4OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWluIHZhbHVlIG9mIHkyIGF4aXMuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkbWluXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgbWluOiAtMTAwMFxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX21pbjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hhbmdlIHRoZSBkaXJlY3Rpb24gb2YgeTIgYXhpcy48YnI+PGJyPlxyXG5cdCAqIElmIHRydWUgc2V0LCB0aGUgZGlyZWN0aW9uIHdpbGwgYmUgZnJvbSB0aGUgdG9wIHRvIHRoZSBib3R0b20uXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkaW52ZXJ0ZWRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICBpbnZlcnRlZDogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX2ludmVydGVkOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNlbnRlciB2YWx1ZSBvZiB5MiBheGlzLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApGNlbnRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIGNlbnRlcjogMFxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX2NlbnRlcjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyB5MiBheGlzIGluc2lkZSBvZiB0aGUgY2hhcnQuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkaW5uZXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IGZhbHNlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICBpbm5lcjogdHJ1ZVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX2lubmVyOiBmYWxzZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxhYmVsIG9uIHkyIGF4aXMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNldCB5MiBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRsYWJlbFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge3N0cmluZ3xvYmplY3R9XHJcblx0ICogQGRlZmF1bHQge31cclxuXHQgKiBAc2VlIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkgZm9yIHBvc2l0aW9uIHN0cmluZyB2YWx1ZS5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIGxhYmVsOiBcIllvdXIgWTIgQXhpc1wiXHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgbGFiZWw6IHtcclxuXHQgKiAgICAgICAgdGV4dDogXCJZb3VyIFkyIEF4aXNcIixcclxuXHQgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX2xhYmVsOiA8c3RyaW5nfG9iamVjdD4ge30sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBmb3JtYXR0ZXIgZm9yIHkyIGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XHJcblx0ICogVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS5mb3JtYXQuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGZvcm1hdFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGZvcm1hdDogZDMuZm9ybWF0KFwiJCxcIilcclxuXHQgKiAgICAgICAvL29yIGZvcm1hdDogZnVuY3Rpb24oZCkgeyByZXR1cm4gXCIkXCIgKyBkOyB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX2Zvcm1hdDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XHJcblx0ICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XHJcblx0ICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueS50aWNrLmN1bGxpbmcubWF4LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjdWxsaW5nXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCBmYWxzZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIGN1bGxpbmc6IGZhbHNlXHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX2N1bGxpbmc6IGZhbHNlLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY3VsbGluZ+KApG1heFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCA1XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgY3VsbGluZzoge1xyXG5cdCAqICAgICAgICAgICBtYXg6IDVcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX2N1bGxpbmdfbWF4OiA1LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IG9yIGhpZGUgeTIgYXhpcyBvdXRlciB0aWNrLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRvdXRlclxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIG91dGVyOiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19vdXRlcjogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHkyIGF4aXMgdGljayB2YWx1ZXMgbWFudWFsbHkuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHZhbHVlc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fEZ1bmN0aW9ufVxyXG5cdCAqIEBkZWZhdWx0IG51bGxcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICB2YWx1ZXM6IFsxMDAsIDEwMDAsIDEwMDAwXSxcclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIGFuIEFycmF5IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZFxyXG5cdCAqICAgICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XHJcblx0ICogICAgICAgXHRyZXR1cm4gWyAuLi4gXTtcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX3ZhbHVlczogPG51bWJlcltdfCgoKT0+IG51bWJlcltdKXxudWxsPiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBSb3RhdGUgeTIgYXhpcyB0aWNrIHRleHQuXHJcblx0ICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcblx0ICogLSBBcHBsaWVkIHdoZW4gW2BheGlzLnJvdGF0ZWRgXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTRyb3RhdGVkKSBvcHRpb24gaXMgYHRydWVgLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRyb3RhdGVcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtudW1iZXJ9XHJcblx0ICogQGRlZmF1bHQgMFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHJvdGF0ZTogNjBcclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3RpY2tfcm90YXRlOiAwLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIG51bWJlciBvZiB5MiBheGlzIHRpY2tzLlxyXG5cdCAqIC0gKipOT1RFOioqIFRoaXMgd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS50aWNrLmNvdW50LlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRjb3VudFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge251bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBjb3VudDogNVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19jb3VudDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyBvciBoaWRlIHkyIGF4aXMgdGljayBsaW5lLlxyXG5cdCAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRzaG93XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cclxuXHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHkyOiB7XHJcblx0ICogICAgIHRpY2s6IHtcclxuXHQgKiAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICB9XHJcblx0ICogICB9XHJcblx0ICogfVxyXG5cdCAqL1xyXG5cdGF4aXNfeTJfdGlja19zaG93OiB0cnVlLFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYXhpcyB0aWNrIHN0ZXAoaW50ZXJ2YWwpIHNpemUuXHJcblx0ICogLSAqKk5PVEU6KiogV2lsbCBiZSBpZ25vcmVkIGlmIGBheGlzLnkyLnRpY2suY291bnRgIG9yIGBheGlzLnkyLnRpY2sudmFsdWVzYCBvcHRpb25zIGFyZSBzZXQuXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHN0ZXBTaXplXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7bnVtYmVyfVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlN0ZXBTaXplRm9yWUF4aXMpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICB0aWNrOiB7XHJcblx0ICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxyXG5cdCAqICAgICAgIC8vIGV4KSAnc3RlcFNpemU9MTUnID09PiBbMCwgMTUsIDMwLCA0NSwgNjBdXHJcblx0ICogICAgICAgc3RlcFNpemU6IDE1XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX3N0ZXBTaXplOiA8bnVtYmVyfG51bGw+IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgdGV4dC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkdGV4dOKApHNob3dcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdCAqIEBkZWZhdWx0IHRydWVcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgICAgICB9XHJcblx0ICogICAgIH1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml90aWNrX3RleHRfc2hvdzogdHJ1ZSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHRoZSB5MiBBeGlzIHRpY2sgdGV4dCdzIHBvc2l0aW9uIHJlbGF0aXZlbHkgaXRzIG9yaWdpbmFsIHBvc2l0aW9uXHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgdGljazoge1xyXG5cdCAqICAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgICAgIHBvc2l0aW9uOiB7XHJcblx0ICogICAgICAgICAgIHg6IDEwLFxyXG5cdCAqICAgICAgICAgICB5OiAxMFxyXG5cdCAqICAgICAgICAgfVxyXG5cdCAqICAgICAgIH1cclxuXHQgKiAgICAgfVxyXG5cdCAqICAgfVxyXG5cdCAqIH1cclxuXHQgKi9cclxuXHRheGlzX3kyX3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgcGFkZGluZyBmb3IgeTIgYXhpcy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc2V0IHBhZGRpbmcgZm9yIHkyIGF4aXMgdG8gY3JlYXRlIG1vcmUgc3BhY2Ugb24gdGhlIGVkZ2Ugb2YgdGhlIGF4aXMuXHJcblx0ICogVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgYW5kIGl0IGNhbiBpbmNsdWRlIHRvcCBhbmQgYm90dG9tLiB0b3AsIGJvdHRvbSB3aWxsIGJlIHRyZWF0ZWQgYXMgcGl4ZWxzLlxyXG5cdCAqXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gR2l2ZW4gdmFsdWVzIGFyZSB0cmFuc2xhdGVkIHJlbGF0aXZlIHRvIHRoZSB5MiBBeGlzIGRvbWFpbiB2YWx1ZSBmb3IgcGFkZGluZ1xyXG5cdCAqICAgLSBGb3IgYXJlYSBhbmQgYmFyIHR5cGUgY2hhcnRzLCBbYXJlYS56ZXJvYmFzZWRdKCMuYXJlYSkgb3IgW2Jhci56ZXJvYmFzZWRdKCMuYmFyKSBvcHRpb25zIHNob3VsZCBiZSBzZXQgdG8gJ2ZhbHNlYCB0byBnZXQgcGFkZGVkIGJvdHRvbS5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRwYWRkaW5nXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fG51bWJlcn1cclxuXHQgKiBAZGVmYXVsdCB7fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogYXhpczoge1xyXG5cdCAqICAgeTI6IHtcclxuXHQgKiAgICAgcGFkZGluZzoge1xyXG5cdCAqICAgICAgIHRvcDogMTAwLFxyXG5cdCAqICAgICAgIGJvdHRvbTogMTAwXHJcblx0ICogICAgIH1cclxuXHQgKlxyXG5cdCAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cclxuXHQgKiAgICAgcGFkZGluZzogMTBcclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9wYWRkaW5nOiA8bnVtYmVyfHt0b3A/OiBudW1iZXI7IGJvdHRvbT86IG51bWJlcjt9PiB7fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRlZmF1bHQgcmFuZ2Ugb2YgeTIgYXhpcy48YnI+PGJyPlxyXG5cdCAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeTIgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cclxuXHQgKiBAbmFtZSBheGlz4oCkeTLigKRkZWZhdWx0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBheGlzOiB7XHJcblx0ICogICB5Mjoge1xyXG5cdCAqICAgICBkZWZhdWx0OiBbMCwgMTAwMF1cclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9kZWZhdWx0OiB1bmRlZmluZWQsXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBhZGRpdGlvbmFsIGF4ZXMgZm9yIHkyIEF4aXMuXHJcblx0ICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geTIgQXhpcyB2YWx1ZSBpZiBkb21haW4gb3B0aW9uIGlzbid0IHNldC5cclxuXHQgKlxyXG5cdCAqIEVhY2ggYXhpcyBvYmplY3Qgc2hvdWxkIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgb3B0aW9uczpcclxuXHQgKlxyXG5cdCAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiB8IGRvbWFpbiB8IEFycmF5IHwgLSB8IFNldCB0aGUgZG9tYWluIHZhbHVlIHxcclxuXHQgKiB8IHRpY2sub3V0ZXIgfCBib29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XHJcblx0ICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XHJcblx0ICogfCB0aWNrLmNvdW50IHwgTnVtYmVyIHwgLSB8IFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcyB8XHJcblx0ICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XHJcblx0ICogQG5hbWUgYXhpc+KApHky4oCkYXhlc1xyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge0FycmF5fVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlcylcclxuXHQgKiBAc2VlIFtEZW1vOiBEb21haW5dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlc0RvbWFpbilcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIHkyOiB7XHJcblx0ICogICAgYXhlczogW1xyXG5cdCAqICAgICAge1xyXG5cdCAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB5MiBBeGlzIGRvbWFpbiB2YWx1ZVxyXG5cdCAqICAgICAgICBkb21haW46IFswLCAxMDAwXSxcclxuXHQgKiAgICAgICAgdGljazoge1xyXG5cdCAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcclxuXHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuXHQgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgY291bnQ6IDIsXHJcblx0ICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cclxuXHQgKiAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIC4uLlxyXG5cdCAqICAgIF1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc195Ml9heGVzOiBbXVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB4IGZyb20gXCIuL3hcIjtcclxuaW1wb3J0IHkgZnJvbSBcIi4veVwiO1xyXG5pbXBvcnQgeTIgZnJvbSBcIi4veTJcIjtcclxuXHJcbi8qKlxyXG4gKiB5IEF4aXMgIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU3dpdGNoIHggYW5kIHkgYXhpcyBwb3NpdGlvbi5cclxuXHQgKiBAbmFtZSBheGlz4oCkcm90YXRlZFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0ICogQGRlZmF1bHQgZmFsc2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGF4aXM6IHtcclxuXHQgKiAgIHJvdGF0ZWQ6IHRydWVcclxuXHQgKiB9XHJcblx0ICovXHJcblx0YXhpc19yb3RhdGVkOiBmYWxzZSxcclxuXHQuLi54LFxyXG5cdC4uLnksXHJcblx0Li4ueTJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZ3JpZCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxudHlwZSBMaW5lcyA9IHt2YWx1ZT86IG51bWJlcjsgdGV4dD86IHN0cmluZzsgY2xhc3M/OiBzdHJpbmc7IHBvc2l0aW9uPzogc3RyaW5nfVtdO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCByZWxhdGVkIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBncmlkXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Zyb250PWZhbHNlXSBTZXQgJ2dyaWQgJiBmb2N1cyBsaW5lcycgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGdyaWQgbGluZXMgYW5kIGNoYXJ0IGVsZW1lbnRzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB4IEdyaWQgeCBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFt4LnNob3c9ZmFsc2VdIFNob3cgZ3JpZHMgYWxvbmcgeCBheGlzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt4LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB4IGF4aXMuPGJyPlxyXG5cdCAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgdmFsdWUsIHRleHQsIHBvc2l0aW9uIGFuZCBjbGFzcy4gdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzIGFyZSBvcHRpb25hbC4gRm9yIHBvc2l0aW9uLCBzdGFydCwgbWlkZGxlIGFuZCBlbmQgKGRlZmF1bHQpIGFyZSBhdmFpbGFibGUuXHJcblx0ICogIElmIHggYXhpcyBpcyBjYXRlZ29yeSBheGlzLCB2YWx1ZSBjYW4gYmUgY2F0ZWdvcnkgbmFtZS4gSWYgeCBheGlzIGlzIHRpbWVzZXJpZXMgYXhpcywgdmFsdWUgY2FuIGJlIGRhdGUgc3RyaW5nLCBEYXRlIG9iamVjdCBhbmQgdW5peHRpbWUgaW50ZWdlci5cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0geSBHcmlkIHkgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbeS5zaG93PWZhbHNlXSBTaG93IGdyaWRzIGFsb25nIHggYXhpcy5cclxuXHQgKiBAcHJvcGVydHkge0FycmF5fSBbeS5saW5lcz1bXV0gU2hvdyBhZGRpdGlvbmFsIGdyaWQgbGluZXMgYWxvbmcgeSBheGlzLjxicj5cclxuXHQgKiAgVGhpcyBvcHRpb24gYWNjZXB0cyBhcnJheSBpbmNsdWRpbmcgb2JqZWN0IHRoYXQgaGFzIHZhbHVlLCB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFt5LnRpY2tzPTEwXSBOdW1iZXIgb2YgeSBncmlkcyB0byBiZSBzaG93bi5cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gZm9jdXMgR3JpZCBmb2N1cyBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb2N1cy5lZGdlPWZhbHNlXSBTaG93IGVkZ2VkIGZvY3VzIGdyaWQgbGluZS48YnI+KipOT1RFOioqIEF2YWlsYWJsZSB3aGVuIFtgdG9vbHRpcC5ncm91cGVkPWZhbHNlYF0oIy50b29sdGlwKSBvcHRpb24gaXMgc2V0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2ZvY3VzLnNob3c9dHJ1ZV0gU2hvdyBncmlkIGxpbmUgd2hlbiBmb2N1cy5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtmb2N1cy55PWZhbHNlXSBTaG93IHkgY29vcmRpbmF0ZSBmb2N1cyBncmlkIGxpbmUuPGJyPioqTk9URToqKiBBdmFpbGFibGUgd2hlbiBbYHRvb2x0aXAuZ3JvdXBlZD1mYWxzZWBdKCMudG9vbHRpcCkgb3B0aW9uIGlzIHNldC5cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gbGluZXMgR3JpZCBsaW5lcyBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaW5lcy5mcm9udD10cnVlXSBTZXQgZ3JpZCBsaW5lcyB0byBiZSBwb3NpdGlvbmVkIG92ZXIgY2hhcnQgZWxlbWVudHMuXHJcblx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuR3JpZExpbmVzKVxyXG5cdCAqIEBzZWUgW0RlbW86IFggR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxYR3JpZExpbmVzKVxyXG5cdCAqIEBzZWUgW0RlbW86IFkgR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxZR3JpZExpbmVzKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogZ3JpZDoge1xyXG5cdCAqICAgeDoge1xyXG5cdCAqICAgICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICBsaW5lczogW1xyXG5cdCAqICAgICAgIHt2YWx1ZTogMiwgdGV4dDogXCJMYWJlbCBvbiAyXCJ9LFxyXG5cdCAqICAgICAgIHt2YWx1ZTogNSwgdGV4dDogXCJMYWJlbCBvbiA1XCIsIGNsYXNzOiBcImxhYmVsLTVcIn0sXHJcblx0ICogICAgICAge3ZhbHVlOiA2LCB0ZXh0OiBcIkxhYmVsIG9uIDZcIiwgcG9zaXRpb246IFwic3RhcnRcIn1cclxuXHQgKiAgICAgXVxyXG5cdCAqICAgfSxcclxuXHQgKiAgIHk6IHtcclxuXHQgKiAgICAgc2hvdzogdHJ1ZSxcclxuXHQgKiAgICAgbGluZXM6IFtcclxuXHQgKiAgICAgICB7dmFsdWU6IDEwMCwgdGV4dDogXCJMYWJlbCBvbiAxMDBcIn0sXHJcblx0ICogICAgICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgb24gMjAwXCIsIGNsYXNzOiBcImxhYmVsLTIwMFwifSxcclxuXHQgKiAgICAgICB7dmFsdWU6IDMwMCwgdGV4dDogXCJMYWJlbCBvbiAzMDBcIiwgcG9zaXRpb246ICdtaWRkbGUnfVxyXG5cdCAqICAgICBdLFxyXG5cdCAqICAgICB0aWNrczogNVxyXG5cdCAqICAgfSxcclxuXHQgKiAgIGZyb250OiB0cnVlLFxyXG5cdCAqICAgZm9jdXM6IHtcclxuXHQgKiAgICAgIHNob3c6IGZhbHNlLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBCZWxvdyBvcHRpb25zIGFyZSBhdmFpbGFibGUgd2hlbiAndG9vbHRpcC5ncm91cGVkPWZhbHNlJyBvcHRpb24gaXMgc2V0XHJcblx0ICogICAgICBlZGdlOiB0cnVlLFxyXG5cdCAqICAgICAgeTogdHJ1ZVxyXG5cdCAqICAgfSxcclxuXHQgKiAgIGxpbmVzOiB7XHJcblx0ICogICAgICBmcm9udDogZmFsc2VcclxuXHQgKiAgIH1cclxuXHQgKiB9XHJcblx0ICovXHJcblx0Z3JpZF94X3Nob3c6IGZhbHNlLFxyXG5cdGdyaWRfeF90eXBlOiBcInRpY2tcIixcclxuXHRncmlkX3hfbGluZXM6IDxMaW5lcz4gW10sXHJcblx0Z3JpZF95X3Nob3c6IGZhbHNlLFxyXG5cdGdyaWRfeV9saW5lczogPExpbmVzPiBbXSxcclxuXHRncmlkX3lfdGlja3M6IDEwLFxyXG5cdGdyaWRfZm9jdXNfZWRnZTogZmFsc2UsXHJcblx0Z3JpZF9mb2N1c19zaG93OiB0cnVlLFxyXG5cdGdyaWRfZm9jdXNfeTogZmFsc2UsXHJcblx0Z3JpZF9mcm9udDogZmFsc2UsXHJcblx0Z3JpZF9saW5lc19mcm9udDogdHJ1ZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBwb2ludCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBwb2ludCBvcHRpb25zXHJcblx0ICogQG5hbWUgcG9pbnRcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHBvaW50IFBvaW50IG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BvaW50LnNob3c9dHJ1ZV0gV2hldGhlciB0byBzaG93IGVhY2ggcG9pbnQgaW4gbGluZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcnxGdW5jdGlvbn0gW3BvaW50LnI9Mi41XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludC5cclxuXHQgKiAgLSAqKk5PVEU6KiogRGlzYWJsZWQgZm9yICdidWJibGUnIHR5cGVcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwb2ludC5mb2N1cy5leHBhbmQuZW5hYmxlZD10cnVlXSBXaGV0aGVyIHRvIGV4cGFuZCBlYWNoIHBvaW50IG9uIGZvY3VzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcG9pbnQuZm9jdXMuZXhwYW5kLnI9cG9pbnQucioxLjc1XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBmb2N1cy5cclxuXHQgKiAgLSAqKk5PVEU6KiogRm9yICdidWJibGUnIHR5cGUsIHRoZSBkZWZhdWx0IGlzIGBidWJibGVTaXplKjEuMTVgXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcG9pbnQuZm9jdXMub25seT1mYWxzZV0gU2hvdyBwb2ludCBvbmx5IHdoZW4gaXMgZm9jdXNlZC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BvaW50LnNlbnNpdGl2aXR5PTEwXSBUaGUgc2Vuc3Rpdml0eSB2YWx1ZSBmb3IgaW50ZXJhY3Rpb24gYm91bmRhcnkuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwb2ludC5zZWxlY3Qucj1wb2ludC5yKjRdIFRoZSByYWRpdXMgc2l6ZSBvZiBlYWNoIHBvaW50IG9uIHNlbGVjdGVkLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcG9pbnQudHlwZT1cImNpcmNsZVwiXSBUaGUgdHlwZSBvZiBwb2ludCB0byBiZSBkcmF3blxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cclxuXHQgKiAgIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXHJcblx0ICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuXHQgKiAgIC0gY2lyY2xlXHJcblx0ICogICAtIHJlY3RhbmdsZVxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtwb2ludC5wYXR0ZXJuPVtdXSBUaGUgdHlwZSBvZiBwb2ludCBvciBzdmcgc2hhcGUgYXMgc3RyaW5nLCB0byBiZSBkcmF3biBmb3IgZWFjaCBsaW5lXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gVGhpcyBpcyBhbiBgZXhwZXJpbWVudGFsYCBmZWF0dXJlIGFuZCBjYW4gaGF2ZSBzb21lIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxyXG5cdCAqICAgLSBJZiBjaGFydCBoYXMgJ2J1YmJsZScgdHlwZSwgb25seSBjaXJjbGUgY2FuIGJlIHVzZWQuXHJcblx0ICogICAtIEZvciBJRSwgbm9uIGNpcmNsZSBwb2ludCBleHBhbnNpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGR1ZSB0byBsYWNrIG9mIHRyYW5zZm9ybSBzdXBwb3J0LlxyXG5cdCAqIC0gKipBdmFpbGFibGUgVmFsdWVzOioqXHJcblx0ICogICAtIGNpcmNsZVxyXG5cdCAqICAgLSByZWN0YW5nbGVcclxuXHQgKiAgIC0gc3ZnIHNoYXBlIHRhZyBpbnRlcnByZXRlZCBhcyBzdHJpbmc8YnI+XHJcblx0ICogICAgIChleC4gYDxwb2x5Z29uIHBvaW50cz0nMi41IDAgMCA1IDUgNSc+PC9wb2x5Z29uPmApXHJcblx0ICogQHNlZSBbRGVtbzogcG9pbnQgdHlwZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1BvaW50LlJlY3RhbmdsZVBvaW50cylcclxuXHQgKiBAc2VlIFtEZW1vOiBwb2ludCBmb2N1cyBvbmx5XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUG9pbnQuRm9jdXNPbmx5KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHBvaW50OiB7XHJcblx0ICogICAgICBzaG93OiBmYWxzZSxcclxuXHQgKiAgICAgIHI6IDUsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIG9yIGN1c3RvbWl6ZSB0aGUgcmFkaXVzXHJcblx0ICogICAgICByOiBmdW5jdGlvbihkKSB7XHJcblx0ICogICAgICAgICAgLi4uXHJcblx0ICogICAgICAgICAgcmV0dXJuIHI7XHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICBmb2N1czoge1xyXG5cdCAqICAgICAgICAgIGV4cGFuZDoge1xyXG5cdCAqICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG5cdCAqICAgICAgICAgICAgICByOiAxXHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICBvbmx5OiB0cnVlXHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgc2VsZWN0OiB7XHJcblx0ICogICAgICAgICAgcjogM1xyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gaGF2aW5nIGxvd2VyIHZhbHVlLCBtZWFucyBob3cgY2xvc2VyIHRvIGJlIGZvciBpbnRlcmFjdGlvblxyXG5cdCAqICAgICAgc2Vuc2l0aXZpdHk6IDMsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHZhbGlkIHZhbHVlcyBhcmUgXCJjaXJjbGVcIiBvciBcInJlY3RhbmdsZVwiXHJcblx0ICogICAgICB0eXBlOiBcInJlY3RhbmdsZVwiLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBvciBpbmRpY2F0ZSBhcyBwYXR0ZXJuXHJcblx0ICogICAgICBwYXR0ZXJuOiBbXHJcblx0ICogICAgICAgIFwiY2lyY2xlXCIsXHJcblx0ICogICAgICAgIFwicmVjdGFuZ2xlXCIsXHJcblx0ICogICAgICAgIFwiPHBvbHlnb24gcG9pbnRzPScwIDYgNCAwIC00IDAnPjwvcG9seWdvbj5cIlxyXG5cdCAqICAgICBdLFxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0cG9pbnRfc2hvdzogdHJ1ZSxcclxuXHRwb2ludF9yOiAyLjUsXHJcblx0cG9pbnRfc2Vuc2l0aXZpdHk6IDEwLFxyXG5cdHBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkOiB0cnVlLFxyXG5cdHBvaW50X2ZvY3VzX2V4cGFuZF9yOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHBvaW50X2ZvY3VzX29ubHk6IGZhbHNlLFxyXG5cdHBvaW50X3BhdHRlcm46IDxzdHJpbmdbXT4gW10sXHJcblx0cG9pbnRfc2VsZWN0X3I6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0cG9pbnRfdHlwZTogXCJjaXJjbGVcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgc3ViY2hhcnQgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIHN1YmNoYXJ0XHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBzdWJjaGFydCBTdWJjaGFydCBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzdWJjaGFydC5zaG93PWZhbHNlXSBTaG93IHN1YiBjaGFydCBvbiB0aGUgYm90dG9tIG9mIHRoZSBjaGFydC5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzdWJjaGFydC5heGlzLnguc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC50aWNrLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIGxpbmUuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnRpY2sudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayB0ZXh0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3ViY2hhcnQuc2l6ZS5oZWlnaHRdIENoYW5nZSB0aGUgaGVpZ2h0IG9mIHRoZSBzdWJjaGFydC5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbc3ViY2hhcnQub25icnVzaF0gU2V0IGNhbGxiYWNrIGZvciBicnVzaCBldmVudC48YnI+XHJcblx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgY3VycmVudCB6b29tZWQgeCBkb21haW4uXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlN1YkNoYXJ0KVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHN1YmNoYXJ0OiB7XHJcblx0ICogICAgICBheGlzOiB7XHJcblx0ICogICAgICBcdHg6IHtcclxuXHQgKiAgICAgIFx0ICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICAgXHQgICAgdGljazoge1xyXG5cdCAqICAgICAgXHQgICAgICBzaG93OiB0cnVlLFxyXG5cdCAqICAgICAgXHQgICAgICB0ZXh0OiB7XHJcblx0ICogICAgICBcdCAgICAgICAgc2hvdzogZmFsc2VcclxuXHQgKiAgICAgIFx0ICAgICAgfVxyXG5cdCAqICAgICAgXHQgICAgfVxyXG5cdCAqICAgICAgXHR9XHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgc2hvdzogdHJ1ZSxcclxuXHQgKiAgICAgIHNpemU6IHtcclxuXHQgKiAgICAgICAgICBoZWlnaHQ6IDIwXHJcblx0ICogICAgICB9LFxyXG5cdCAqICAgICAgb25icnVzaDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9XHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRzdWJjaGFydF9zaG93OiBmYWxzZSxcclxuXHRzdWJjaGFydF9zaXplX2hlaWdodDogNjAsXHJcblx0c3ViY2hhcnRfYXhpc194X3Nob3c6IHRydWUsXHJcblx0c3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdzogdHJ1ZSxcclxuXHRzdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblx0c3ViY2hhcnRfb25icnVzaDogKCkgPT4ge31cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogem9vbSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCB6b29tIG9wdGlvbnNcclxuXHQgKiBAbmFtZSB6b29tXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB6b29tIFpvb20gb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbem9vbS5lbmFibGVkPWZhbHNlXSBFbmFibGUgem9vbWluZy5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb20uZW5hYmxlZC50eXBlPSd3aGVlbCddIFNldCB6b29tIGludGVyYWN0aW9uIHR5cGUuXHJcblx0ICogIC0gKipBdmFpbGFibGUgdHlwZXM6KipcclxuXHQgKiAgICAtIHdoZWVsXHJcblx0ICogICAgLSBkcmFnXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbem9vbS5yZXNjYWxlPWZhbHNlXSBFbmFibGUgdG8gcmVzY2FsZSBhZnRlciB6b29taW5nLjxicj5cclxuXHQgKiAgSWYgdHJ1ZSBzZXQsIHkgZG9tYWluIHdpbGwgYmUgdXBkYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHpvb21lZCByZWdpb24uXHJcblx0ICogQHByb3BlcnR5IHtBcnJheX0gW3pvb20uZXh0ZW50PVsxLCAxMF1dIENoYW5nZSB6b29tIGV4dGVudC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcnxEYXRlfSBbem9vbS54Lm1pbl0gU2V0IHggQXhpcyBtaW5pbXVtIHpvb20gcmFuZ2VcclxuXHQgKiBAcHJvcGVydHkge251bWJlcnxEYXRlfSBbem9vbS54Lm1heF0gU2V0IHggQXhpcyBtYXhpbXVtIHpvb20gcmFuZ2VcclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbem9vbS5vbnpvb21zdGFydD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgc3RhcnRzLjxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tIGV2ZW50LlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbT11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjaGFydCBpcyB6b29taW5nLjxicj5cclxuXHQgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tZWQgZG9tYWluLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbWVuZD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgZW5kcy48YnI+XHJcblx0ICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbWVkIGRvbWFpbi5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW58b2JqZWN0fSBbem9vbS5yZXNldEJ1dHRvbj10cnVlXSBTZXQgdG8gZGlzcGxheSB6b29tIHJlc2V0IGJ1dHRvbiBmb3IgJ2RyYWcnIHR5cGUgem9vbVxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLnJlc2V0QnV0dG9uLm9uY2xpY2tdIFNldCBjYWxsYmFjayB3aGVuIGNsaWNrcyB0aGUgcmVzZXQgYnV0dG9uLiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHJlc2V0IGJ1dHRvbiBlbGVtZW50IHJlZmVyZW5jZSBhcyBhcmd1bWVudC5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW3pvb20ucmVzZXRCdXR0b24udGV4dD0nUmVzZXQgWm9vbSddIFRleHQgdmFsdWUgZm9yIHpvb20gcmVzZXQgYnV0dG9uLlxyXG5cdCAqIEBzZWUgW0RlbW86em9vbV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlpvb20pXHJcblx0ICogQHNlZSBbRGVtbzpkcmFnIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5EcmFnWm9vbSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICB6b29tOiB7XHJcblx0ICogICAgICBlbmFibGVkOiB7XHJcblx0ICogICAgICAgICAgdHlwZTogXCJkcmFnXCJcclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICByZXNjYWxlOiB0cnVlLFxyXG5cdCAqICAgICAgZXh0ZW50OiBbMSwgMTAwXSAgLy8gZW5hYmxlIG1vcmUgem9vbWluZ1xyXG5cdCAqICAgICAgeDoge1xyXG5cdCAqICAgICAgICAgIG1pbjogLTEsICAvLyBzZXQgbWluIHJhbmdlXHJcblx0ICogICAgICAgICAgbWF4OiAxMCAgLy8gc2V0IG1heCByYW5nZVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIG9uem9vbXN0YXJ0OiBmdW5jdGlvbihldmVudCkgeyAuLi4gfSxcclxuXHQgKiAgICAgIG9uem9vbTogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9LFxyXG5cdCAqICAgICAgb256b29tZW5kOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHNob3cgcmVzZXQgYnV0dG9uIHdoZW4gaXMgem9vbWVkLWluXHJcblx0ICogICAgICByZXNldEJ1dHRvbjogdHJ1ZSxcclxuXHQgKlxyXG5cdCAqICAgICAgcmVzZXRCdXR0b246IHtcclxuXHQgKiAgICAgICAgICAvLyBvbmNsaWNrIGNhbGxiYWNrIHdoZW4gcmVzZXQgYnV0dG9uIGlzIGNsaWNrZWRcclxuXHQgKiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbihidXR0b24pIHtcclxuXHQgKiAgICAgICAgICAgIGJ1dHRvbjsgLy8gUmVzZXQgYnV0dG9uIGVsZW1lbnQgcmVmZXJlbmNlXHJcblx0ICogICAgICAgICAgICAuLi5cclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAgICAgLy8gY3VzdG9taXplZCB0ZXh0IHZhbHVlIGZvciByZXNldCB6b29tIGJ1dHRvblxyXG5cdCAqICAgICAgICAgIHRleHQ6IFwiVW56b29tXCJcclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdHpvb21fZW5hYmxlZDogPHt0eXBlOiBcIndoZWVsXCIgfCBcImRyYWdcIn18Ym9vbGVhbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR6b29tX2V4dGVudDogPG51bWJlcltdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHpvb21fcHJpdmlsZWdlZDogZmFsc2UsXHJcblx0em9vbV9yZXNjYWxlOiBmYWxzZSxcclxuXHR6b29tX29uem9vbTogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHpvb21fb256b29tc3RhcnQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHR6b29tX29uem9vbWVuZDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHpvb21fcmVzZXRCdXR0b246IDx7dGV4dDogc3RyaW5nO318Ym9vbGVhbj4gdHJ1ZSxcclxuXHR6b29tX3hfbWluOiA8TnVtYmVyfERhdGV8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0em9vbV94X21heDogPE51bWJlcnxEYXRlfHVuZGVmaW5lZD4gdW5kZWZpbmVkXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGFyZWEgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgYXJlYSBvcHRpb25zXHJcblx0ICogQG5hbWUgYXJlYVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gYXJlYSBBcmVhIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FyZWEuemVyb2Jhc2VkPXRydWVdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBhcmVhIGNoYXJ0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FyZWEuYWJvdmU9ZmFsc2VdIFNldCBiYWNrZ3JvdW5kIGFyZWEgYWJvdmUgdGhlIGRhdGEgY2hhcnQgbGluZS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW58b2JqZWN0fSBbYXJlYS5saW5lYXJHcmFkaWVudD1mYWxzZV0gU2V0IHRoZSBsaW5lYXIgZ3JhZGllbnQgb24gYXJlYS48YnI+PGJyPlxyXG5cdCAqIE9yIGN1c3RvbWl6ZSBieSBnaXZpbmcgYmVsb3cgb2JqZWN0IHZhbHVlOlxyXG5cdCAqICAtIHgge0FycmF5fTogYHgxYCwgYHgyYCB2YWx1ZVxyXG5cdCAqICAtIHkge0FycmF5fTogYHkxYCwgYHkyYCB2YWx1ZVxyXG5cdCAqICAtIHN0b3BzIHtBcnJheX06IEVhY2ggaXRlbSBzaG91bGQgYmUgaGF2aW5nIGBbb2Zmc2V0LCBzdG9wLWNvbG9yLCBzdG9wLW9wYWNpdHldYCB2YWx1ZXMuXHJcblx0ICogQHNlZSBbTUROJ3MgJmx0O2xpbmVhckdyYWRpZW50Pl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0VsZW1lbnQvbGluZWFyR3JhZGllbnQpLCBbJmx0O3N0b3A+XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC9zdG9wKVxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5BcmVhQ2hhcnQpXHJcblx0ICogQHNlZSBbRGVtbzogYWJvdmVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBcmVhQ2hhcnRPcHRpb25zLkFib3ZlKVxyXG5cdCAqIEBzZWUgW0RlbW86IGxpbmVhckdyYWRpZW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXJlYUNoYXJ0T3B0aW9ucy5MaW5lYXJHcmFkaWVudClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBhcmVhOiB7XHJcblx0ICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlLFxyXG5cdCAqICAgICAgYWJvdmU6IHRydWUsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIHdpbGwgZ2VuZXJhdGUgZm9sbHdpbmcgbGluZWFyR3JhZGllbnQ6XHJcblx0ICogICAgICAvLyA8bGluZWFyR3JhZGllbnQgeDE9XCIwXCIgeDI9XCIwXCIgeTE9XCIwXCIgeTI9XCIxXCI+XHJcblx0ICogICAgICAvLyAgICA8c3RvcCBvZmZzZXQ9XCIwXCIgc3RvcC1jb2xvcj1cIiREQVRBX0NPTE9SXCIgc3RvcC1vcGFjaXR5PVwiMVwiPjwvc3RvcD5cclxuXHQgKiAgICAgIC8vICAgIDxzdG9wIG9mZnNldD1cIjFcIiBzdG9wLWNvbG9yPVwiJERBVEFfQ09MT1JcIiBzdG9wLW9wYWNpdHk9XCIwXCI+PC9zdG9wPlxyXG5cdCAqICAgICAgLy8gPC9saW5lYXJHcmFkaWVudD5cclxuXHQgKiAgICAgIGxpbmVhckdyYWRpZW50OiB0cnVlLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBPciBjdXN0b21pemVkIGdyYWRpZW50XHJcblx0ICogICAgICBsaW5lYXJHcmFkaWVudDoge1xyXG5cdCAqICAgICAgXHR4OiBbMCwgMF0sICAvLyB4MSwgeDIgYXR0cmlidXRlc1xyXG5cdCAqICAgICAgXHR5OiBbMCwgMF0sICAvLyB5MSwgeTIgYXR0cmlidXRlc1xyXG5cdCAqICAgICAgXHRzdG9wczogW1xyXG5cdCAqICAgICAgXHQgIC8vIG9mZnNldCwgc3RvcC1jb2xvciwgc3RvcC1vcGFjaXR5XHJcblx0ICogICAgICBcdCAgWzAsIFwiIzdjYjVlY1wiLCAxXSxcclxuXHQgKlxyXG5cdCAqICAgICAgXHQgIC8vIHNldHRpbmcgJ251bGwnIGZvciBzdG9wLWNvbG9yLCB3aWxsIHNldCBpdHMgb3JpZ2luYWwgZGF0YSBjb2xvclxyXG5cdCAqICAgICAgXHQgIFswLjUsIG51bGwsIDBdLFxyXG5cdCAqXHJcblx0ICogICAgICBcdCAgLy8gc2V0dGluZyAnZnVuY3Rpb24nIGZvciBzdG9wLWNvbG9yLCB3aWxsIHBhc3MgZGF0YSBpZCBhcyBhcmd1bWVudC5cclxuXHQgKiAgICAgIFx0ICAvLyBJdCBzaG91bGQgcmV0dXJuIGNvbG9yIHN0cmluZyBvciBudWxsIHZhbHVlXHJcblx0ICogICAgICBcdCAgWzEsIGZ1bmN0aW9uKGlkKSB7IHJldHVybiBpZCA9PT0gXCJkYXRhMVwiID8gXCJyZWRcIiA6IFwiYmx1ZVwiOyB9LCAwXSxcclxuXHQgKiAgICAgIFx0XVxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0YXJlYV96ZXJvYmFzZWQ6IHRydWUsXHJcblx0YXJlYV9hYm92ZTogZmFsc2UsXHJcblx0YXJlYV9saW5lYXJHcmFkaWVudDogPFxyXG5cdFx0XHRib29sZWFufHt4PzogbnVtYmVyW107IHk/OiBudW1iZXJbXTsgc3RvcHM/OiBbbnVtYmVyLCBzdHJpbmd8RnVuY3Rpb258bnVsbCwgbnVtYmVyXX1cclxuXHRcdD4gZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogYmFyIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGJhciBvcHRpb25zXHJcblx0ICogQG5hbWUgYmFyXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBiYXIgQmFyIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLnBhZGRpbmc9MF0gVGhlIHBhZGRpbmcgcGl4ZWwgdmFsdWUgYmV0d2VlbiBlYWNoIGJhci5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci5yYWRpdXNdIFNldCB0aGUgcmFkaXVzIG9mIGJhciBlZGdlIGluIHBpeGVsLlxyXG5cdCAqIC0gKipOT1RFOioqIFdvcmtzIG9ubHkgZm9yIG5vbi1zdGFja2VkIGJhclxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLnJhZGl1cy5yYXRpb10gU2V0IHRoZSByYWRpdXMgcmF0aW8gb2YgYmFyIGVkZ2UgaW4gcmVsYXRpdmUgdGhlIGJhcidzIHdpZHRoLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLnNlbnNpdGl2aXR5PTJdIFRoZSBzZW5zdGl2aXR5IG9mZnNldCB2YWx1ZSBmb3IgaW50ZXJhY3Rpb24gYm91bmRhcnkuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIud2lkdGhdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLndpZHRoLnJhdGlvPTAuNl0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQgYnkgcmF0aW8uXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIud2lkdGgubWF4XSBUaGUgbWF4aW11bSB3aWR0aCB2YWx1ZSBmb3IgcmF0aW8uXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWVdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGZvciBpbmRpY2F0ZWQgZGF0YXNldCBvbmx5LlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIFdvcmtzIG9ubHkgZm9yIG5vbi1zdGFja2VkIGJhclxyXG5cdCAqICAgLSBCYXJzIGFyZSBjZW50ZXJlZCBhY2NvZGluZyBpdHMgdG90YWwgd2lkdGggdmFsdWVcclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZS5yYXRpbz0wLjZdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0IGJ5IHJhdGlvLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lLm1heF0gVGhlIG1heGltdW0gd2lkdGggdmFsdWUgZm9yIHJhdGlvLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Jhci56ZXJvYmFzZWQ9dHJ1ZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGJhciBjaGFydC5cclxuXHQgKiBAc2VlIFtEZW1vOiBiYXIgcGFkZGluZ10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJQYWRkaW5nKVxyXG5cdCAqIEBzZWUgW0RlbW86IGJhciByYWRpdXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNCYXJDaGFydE9wdGlvbnMuQmFyUmFkaXVzKVxyXG5cdCAqIEBzZWUgW0RlbW86IGJhciB3aWR0aF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJXaWR0aClcclxuXHQgKiBAc2VlIFtEZW1vOiBiYXIgd2lkdGggdmFyaWFudF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJXaWR0aFZhcmlhbnQpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgYmFyOiB7XHJcblx0ICogICAgICBwYWRkaW5nOiAxLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyB0aGUgJ3JhZGl1cycgb3B0aW9uIGNhbiBiZSB1c2VkIG9ubHkgZm9yIG5vbi1zdGFja2luZyBiYXJzXHJcblx0ICogICAgICByYWRpdXM6IDEwLFxyXG5cdCAqICAgICAgLy8gb3JcclxuXHQgKiAgICAgIHJhZGl1czoge1xyXG5cdCAqICAgICAgICAgIHJhdGlvOiAwLjVcclxuXHQgKiAgICAgIH1cclxuXHQgKlxyXG5cdCAqICAgICAgLy8gd2lsbCBub3QgaGF2ZSBvZmZzZXQgYmV0d2VlbiBlYWNoIGJhciBlbGVtZW50cyBmb3IgaW50ZXJhY3Rpb25cclxuXHQgKiAgICAgIHNlbnNpdGl2aXR5OiAwLFxyXG5cdCAqXHJcblx0ICogICAgICB3aWR0aDogMTAsXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIG9yXHJcblx0ICogICAgICB3aWR0aDoge1xyXG5cdCAqICAgICAgICAgIHJhdGlvOiAwLjIsXHJcblx0ICogICAgICAgICAgbWF4OiAyMFxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gb3Igc3BlY2lmeSB3aWR0aCBwZXIgZGF0YXNldFxyXG5cdCAqICAgICAgd2lkdGg6IHtcclxuXHQgKiAgICAgICAgICBkYXRhMTogMjAsXHJcblx0ICogICAgICAgICAgZGF0YTI6IHtcclxuXHQgKiAgICAgICAgICAgICAgcmF0aW86IDAuMixcclxuXHQgKiAgICAgICAgICAgICAgbWF4OiAyMFxyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIHplcm9iYXNlZDogZmFsc2VcclxuXHQgKiAgfVxyXG5cdCAqL1xyXG5cdGJhcl9wYWRkaW5nOiAwLFxyXG5cdGJhcl9yYWRpdXM6IDxudW1iZXJ8e3JhdGlvOiBudW1iZXJ9fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGJhcl9yYWRpdXNfcmF0aW86IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0YmFyX3NlbnNpdGl2aXR5OiAyLFxyXG5cdGJhcl93aWR0aDogPG51bWJlcnx7cmF0aW8/OiBudW1iZXI7IG1heD86IG51bWJlcjt9fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGJhcl93aWR0aF9yYXRpbzogMC42LFxyXG5cdGJhcl93aWR0aF9tYXg6IHVuZGVmaW5lZCxcclxuXHRiYXJfemVyb2Jhc2VkOiB0cnVlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGJ1YmJsZSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBidWJibGUgb3B0aW9uc1xyXG5cdCAqIEBuYW1lIGJ1YmJsZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gYnViYmxlIGJ1YmJsZSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge251bWJlcnxGdW5jdGlvbn0gW2J1YmJsZS5tYXhSPTM1XSBTZXQgdGhlIG1heCBidWJibGUgcmFkaXVzIHZhbHVlXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbYnViYmxlLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGJ1YmJsZSBjaGFydC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBidWJibGU6IHtcclxuXHQgKiAgICAgIC8vIGV4KSBJZiAxMDAgaXMgdGhlIGhpZ2hlc3QgdmFsdWUgYW1vbmcgZGF0YSBib3VuZCwgdGhlIHJlcHJlc2VudGF0aW9uIGJ1YmJsZSBvZiAxMDAgd2lsbCBoYXZlIHJhZGl1cyBvZiA1MC5cclxuXHQgKiAgICAgIC8vIEFuZCB0aGUgbGVzc2VyIHdpbGwgaGF2ZSByYWRpdXMgcmVsYXRpdmVseSBmcm9tIHRoYSBtYXggdmFsdWUuXHJcblx0ICogICAgICBtYXhSOiA1MCxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gb3Igc2V0IHJhZGl1cyBjYWxsYmFja1xyXG5cdCAqICAgICAgbWF4UjogZnVuY3Rpb24oZCkge1xyXG5cdCAqICAgICAgICAgIC8vIGV4LiBvZiBkIHBhcmFtIC0ge3g6IEZyaSBPY3QgMDYgMjAxNyAwMDowMDowMCBHTVQrMDkwMCwgdmFsdWU6IDgwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNX1cclxuXHQgKiAgICAgICAgICAuLi5cclxuXHQgKiAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KGQudmFsdWUgKiAyKTtcclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRidWJibGVfbWF4UjogPG51bWJlcnwoKCkgPT4gbnVtYmVyKT4gMzUsXHJcblx0YnViYmxlX3plcm9iYXNlZDogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogbGluZSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNldCBsaW5lIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBsaW5lXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBsaW5lIExpbmUgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbbGluZS5jb25uZWN0TnVsbD1mYWxzZV0gU2V0IGlmIG51bGwgZGF0YSBwb2ludCB3aWxsIGJlIGNvbm5lY3RlZCBvciBub3QuPGJyPlxyXG5cdCAqICBJZiB0cnVlIHNldCwgdGhlIHJlZ2lvbiBvZiBudWxsIGRhdGEgd2lsbCBiZSBjb25uZWN0ZWQgd2l0aG91dCBhbnkgZGF0YSBwb2ludC4gSWYgZmFsc2Ugc2V0LCB0aGUgcmVnaW9uIG9mIG51bGwgZGF0YSB3aWxsIG5vdCBiZSBjb25uZWN0ZWQgYW5kIGdldCBlbXB0eS5cclxuXHQgKiBAcHJvcGVydHkge0FycmF5fSAgIFtsaW5lLmNsYXNzZXM9dW5kZWZpbmVkXSBJZiBzZXQsIHVzZWQgdG8gc2V0IGEgY3NzIGNsYXNzIG9uIGVhY2ggbGluZS5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsaW5lLnN0ZXAudHlwZT1zdGVwXSBDaGFuZ2Ugc3RlcCB0eXBlIGZvciBzdGVwIGNoYXJ0Ljxicj5cclxuXHQgKiAqKkF2YWlsYWJsZSB2YWx1ZXM6KipcclxuXHQgKiAtIHN0ZXBcclxuXHQgKiAtIHN0ZXAtYmVmb3JlXHJcblx0ICogLSBzdGVwLWFmdGVyXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufEFycmF5fSBbbGluZS5wb2ludD10cnVlXSBTZXQgdG8gZmFsc2UgdG8gbm90IGRyYXcgcG9pbnRzIG9uIGxpbmVjaGFydHMuIE9yIHBhc3MgYW4gYXJyYXkgb2YgbGluZSBpZHMgdG8gZHJhdyBwb2ludHMgZm9yLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2xpbmUuemVyb2Jhc2VkPWZhbHNlXSBTZXQgaWYgbWluIG9yIG1heCB2YWx1ZSB3aWxsIGJlIDAgb24gbGluZSBjaGFydC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBsaW5lOiB7XHJcblx0ICogICAgICBjb25uZWN0TnVsbDogdHJ1ZSxcclxuXHQgKiAgICAgIGNsYXNzZXM6IFtcclxuXHQgKiAgICAgICAgICBcImxpbmUtY2xhc3MxXCIsXHJcblx0ICogICAgICAgICAgXCJsaW5lLWNsYXNzMlwiXHJcblx0ICogICAgICBdLFxyXG5cdCAqICAgICAgc3RlcDoge1xyXG5cdCAqICAgICAgICAgIHR5cGU6IFwic3RlcC1hZnRlclwiXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBoaWRlIGFsbCBkYXRhIHBvaW50cyAoJ3BvaW50LnNob3c9ZmFsc2UnIGFsc28gaGFzIHNpbWlsYXIgZWZmZWN0KVxyXG5cdCAqICAgICAgcG9pbnQ6IGZhbHNlLFxyXG5cdCAqXHJcblx0ICogICAgICAvLyBzaG93IGRhdGEgcG9pbnRzIGZvciBvbmx5IGluZGljYXRlZCBkYXRhc1xyXG5cdCAqICAgICAgcG9pbnQ6IFtcclxuXHQgKiAgICAgICAgICBcImRhdGExXCIsIFwiZGF0YTNcIlxyXG5cdCAqICAgICAgXSxcclxuXHQgKlxyXG5cdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0bGluZV9jb25uZWN0TnVsbDogZmFsc2UsXHJcblx0bGluZV9zdGVwX3R5cGU6IDxcInN0ZXBcInxcInN0ZXAtYmVmb3JlXCJ8XCJzdGVwLWFmdGVyXCI+IFwic3RlcFwiLFxyXG5cdGxpbmVfemVyb2Jhc2VkOiBmYWxzZSxcclxuXHRsaW5lX2NsYXNzZXM6IDxzdHJpbmdbXXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRsaW5lX3BvaW50OiA8c3RyaW5nW118Ym9vbGVhbj4gdHJ1ZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgc3BsaW5lIG9wdGlvbnNcclxuXHQgKiAtICoqQXZhaWxhYmxlIGludGVycG9sYXRpb24gdHlwZSB2YWx1ZXM6KipcclxuXHQgKiAgLSBiYXNpcyAoZDMuY3VydmVCYXNpcylcclxuXHQgKiAgLSBiYXNpcy1jbG9zZWQgKGQzLmN1cnZlQmFzaXNDbG9zZWQpXHJcblx0ICogIC0gYmFzaXMtb3BlbiAoZDMuY3VydmVCYXNpc09wZW4pXHJcblx0ICogIC0gYnVuZGxlIChkMy5jdXJ2ZUJ1bmRsZSlcclxuXHQgKiAgLSBjYXJkaW5hbCAoZDMuY3VydmVDYXJkaW5hbClcclxuXHQgKiAgLSBjYXJkaW5hbC1jbG9zZWQgKGQzLmN1cnZlQ2FyZGluYWxDbG9zZWQpXHJcblx0ICogIC0gY2FyZGluYWwtb3BlbiAoZDMuY3VydmVDYXJkaW5hbE9wZW4pXHJcblx0ICogIC0gY2F0bXVsbC1yb20gKGQzLmN1cnZlQ2F0bXVsbFJvbSlcclxuXHQgKiAgLSBjYXRtdWxsLXJvbS1jbG9zZWQgKGQzLmN1cnZlQ2F0bXVsbFJvbUNsb3NlZClcclxuXHQgKiAgLSBjYXRtdWxsLXJvbS1vcGVuIChkMy5jdXJ2ZUNhdG11bGxSb21PcGVuKVxyXG5cdCAqICAtIG1vbm90b25lLXggKGQzLmN1cnZlTW9ub3RvbmVYKVxyXG5cdCAqICAtIG1vbm90b25lLXkgKGQzLmN1cnZlTW9ub3RvbmVZKVxyXG5cdCAqICAtIG5hdHVyYWwgKGQzLmN1cnZlTmF0dXJhbClcclxuXHQgKiAgLSBsaW5lYXItY2xvc2VkIChkMy5jdXJ2ZUxpbmVhckNsb3NlZClcclxuXHQgKiAgLSBsaW5lYXIgKGQzLmN1cnZlTGluZWFyKVxyXG5cdCAqICAtIHN0ZXAgKGQzLmN1cnZlU3RlcClcclxuXHQgKiAgLSBzdGVwLWFmdGVyIChkMy5jdXJ2ZVN0ZXBBZnRlcilcclxuXHQgKiAgLSBzdGVwLWJlZm9yZSAoZDMuY3VydmVTdGVwQmVmb3JlKVxyXG5cdCAqIEBuYW1lIHNwbGluZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gc3BsaW5lIFNwbGluZSBvYmplY3RcclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gc3BsaW5lLmludGVycG9sYXRpb24gU3BsaW5lIGludGVycG9sYXRpb24gb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IFtzcGxpbmUuaW50ZXJwb2xhdGlvbi50eXBlPVwiY2FyZGluYWxcIl0gSW50ZXJwb2xhdGlvbiB0eXBlXHJcblx0ICogQHNlZSBbSW50ZXJwb2xhdGlvbiAoZDMgdjQpXShodHRwOi8vYmwub2Nrcy5vcmcvZW1tYXNhdW5kZXJzL2MyNWExNDc5NzBkZWYyYjAyZDhjN2MyNzE5ZGM3NTAyKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHNwbGluZToge1xyXG5cdCAqICAgICAgaW50ZXJwb2xhdGlvbjoge1xyXG5cdCAqICAgICAgICAgIHR5cGU6IFwiY2FyZGluYWxcIlxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0c3BsaW5lX2ludGVycG9sYXRpb25fdHlwZTogXCJjYXJkaW5hbFwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGRvbnV0IGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGRvbnV0IG9wdGlvbnNcclxuXHQgKiBAbmFtZSBkb251dFxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gZG9udXQgRG9udXQgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZG9udXQubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZWFjaCBkb251dCBwaWVjZS5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZG9udXQubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZWFjaCBkb251dCBwaWVjZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2RvbnV0LmxhYmVsLnRocmVzaG9sZD0wLjA1XSBTZXQgdGhyZXNob2xkIHRvIHNob3cvaGlkZSBsYWJlbHMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ8RnVuY3Rpb259IFtkb251dC5sYWJlbC5yYXRpbz11bmRlZmluZWRdIFNldCByYXRpbyBvZiBsYWJlbHMgcG9zaXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZG9udXQuZXhwYW5kPXRydWVdIEVuYWJsZSBvciBkaXNhYmxlIGV4cGFuZGluZyBkb251dCBwaWVjZXMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtkb251dC5leHBhbmQucmF0ZT0wLjk4XSBTZXQgZXhwYW5kIHJhdGUuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtkb251dC5leHBhbmQuZHVyYXRpb249NTBdIFNldCBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1zLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZG9udXQud2lkdGhdIFNldCB3aWR0aCBvZiBkb251dCBjaGFydC5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW2RvbnV0LnRpdGxlPVwiXCJdIFNldCB0aXRsZSBvZiBkb251dCBjaGFydC4gVXNlIGBcXG5gIGNoYXJhY3RlciB0byBlbnRlciBsaW5lIGJyZWFrLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZG9udXQucGFkQW5nbGU9MF0gU2V0IHBhZGRpbmcgYmV0d2VlbiBkYXRhLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZG9udXQuc3RhcnRpbmdBbmdsZT0wXSBTZXQgc3RhcnRpbmcgYW5nbGUgd2hlcmUgZGF0YSBkcmF3cy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBkb251dDoge1xyXG5cdCAqICAgICAgbGFiZWw6IHtcclxuXHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcclxuXHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQpIHtcclxuXHQgKiAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdChcIiRcIikodmFsdWUpO1xyXG5cdCAqXHJcblx0ICogICAgICAgICAgICAgIC8vIHRvIG11bHRpbGluZSwgcmV0dXJuIHdpdGggJ1xcbicgY2hhcmFjdGVyXHJcblx0ICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIHRocmVzaG9sZDogMC4xLFxyXG5cdCAqXHJcblx0ICogICAgICAgICAgLy8gc2V0IHJhdGlvIGNhbGxiYWNrLiBTaG91bGQgcmV0dXJuIHJhdGlvIHZhbHVlXHJcblx0ICogICAgICAgICAgcmF0aW86IGZ1bmN0aW9uKGQsIHJhZGl1cywgaCkge1xyXG5cdCAqICAgICAgICAgIFx0Li4uXHJcblx0ICogICAgICAgICAgXHRyZXR1cm4gcmF0aW87XHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICAvLyBvciBzZXQgcmF0aW8gbnVtYmVyXHJcblx0ICogICAgICAgICAgcmF0aW86IDAuNVxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gZGlzYWJsZSBleHBhbmQgdHJhbnNpdGlvbiBmb3IgaW50ZXJhY3Rpb25cclxuXHQgKiAgICAgIGV4cGFuZDogZmFsc2UsXHJcblx0ICpcclxuXHQgKiAgICAgIGV4cGFuZDoge1xyXG5cdCAqICAgICAgXHQvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXHJcblx0ICogICAgICAgICAgZHVyYXRpb246IDUwMCxcclxuXHQgKlxyXG5cdCAqICAgICAgXHQvLyBzZXQgZXhwYW5kIGFyZWEgcmF0ZVxyXG5cdCAqICAgICAgICAgIHJhdGU6IDFcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIHdpZHRoOiAxMCxcclxuXHQgKiAgICAgIHBhZEFuZ2xlOiAwLjIsXHJcblx0ICogICAgICBzdGFydGluZ0FuZ2xlOiAxLFxyXG5cdCAqICAgICAgdGl0bGU6IFwiRG9udXQgVGl0bGVcIlxyXG5cdCAqXHJcblx0ICogICAgICAvLyB0aXRsZSB3aXRoIGxpbmUgYnJlYWtcclxuXHQgKiAgICAgIHRpdGxlOiBcIlRpdGxlMVxcblRpdGxlMlwiXHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRkb251dF9sYWJlbF9zaG93OiB0cnVlLFxyXG5cdGRvbnV0X2xhYmVsX2Zvcm1hdDogPCgoKSA9PiBudW1iZXJ8c3RyaW5nKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRkb251dF9sYWJlbF90aHJlc2hvbGQ6IDAuMDUsXHJcblx0ZG9udXRfbGFiZWxfcmF0aW86IDxudW1iZXJ8KCgpID0+IG51bWJlcil8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0ZG9udXRfd2lkdGg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0ZG9udXRfdGl0bGU6IFwiXCIsXHJcblx0ZG9udXRfZXhwYW5kOiA8Ym9vbGVhbnx7cmF0ZT86IG51bWJlcjsgZHVyYXRpb24/OiBudW1iZXI7fT4ge30sXHJcblx0ZG9udXRfZXhwYW5kX3JhdGU6IDAuOTgsXHJcblx0ZG9udXRfZXhwYW5kX2R1cmF0aW9uOiA1MCxcclxuXHRkb251dF9wYWRBbmdsZTogMCxcclxuXHRkb251dF9zdGFydGluZ0FuZ2xlOiAwXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGdhdWdlIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IGdhdWdlIG9wdGlvbnNcclxuXHQgKiBAbmFtZSBnYXVnZVxyXG5cdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0ICogQHR5cGUge29iamVjdH1cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gZ2F1Z2UgR2F1Z2Ugb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZ2F1Z2UuZnVsbENpcmNsZT1mYWxzZV0gU2hvdyBmdWxsIGNpcmNsZSBhcyBkb251dC4gV2hlbiBzZXQgdG8gJ3RydWUnLCB0aGUgbWF4IGxhYmVsIHdpbGwgbm90IGJlIHNob3dlZCBkdWUgdG8gc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIHNhbWUgbG9jYXRpb24uXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZ2F1Z2UubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZ2F1Z2UuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2dhdWdlLmxhYmVsLmZvcm1hdF0gU2V0IGZvcm1hdHRlciBmb3IgdGhlIGxhYmVsIG9uIGdhdWdlLiBMYWJlbCB0ZXh0IGNhbiBiZSBtdWx0aWxpbmVkIHdpdGggYFxcbmAgY2hhcmFjdGVyLlxyXG5cdCAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtnYXVnZS5sYWJlbC5leHRlbnRzXSBTZXQgY3VzdG9taXplZCBtaW4vbWF4IGxhYmVsIHRleHQuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbZ2F1Z2UuZXhwYW5kPXRydWVdIEVuYWJsZSBvciBkaXNhYmxlIGV4cGFuZGluZyBnYXVnZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2dhdWdlLmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2dhdWdlLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IHRoZSBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1pbGxpc2Vjb25kcy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2dhdWdlLm1pbj0wXSBTZXQgbWluIHZhbHVlIG9mIHRoZSBnYXVnZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW2dhdWdlLm1heD0xMDBdIFNldCBtYXggdmFsdWUgb2YgdGhlIGdhdWdlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZ2F1Z2Uuc3RhcnRpbmdBbmdsZT0tMSAqIE1hdGguUEkgLyAyXSBTZXQgc3RhcnRpbmcgYW5nbGUgd2hlcmUgZGF0YSBkcmF3cy5cclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW2dhdWdlLnRpdGxlPVwiXCJdIFNldCB0aXRsZSBvZiBnYXVnZSBjaGFydC4gVXNlIGBcXG5gIGNoYXJhY3RlciB0byBlbnRlciBsaW5lIGJyZWFrLlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2F1Z2UudW5pdHNdIFNldCB1bml0cyBvZiB0aGUgZ2F1Z2UuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtnYXVnZS53aWR0aF0gU2V0IHdpZHRoIG9mIGdhdWdlIGNoYXJ0LlxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2F1Z2UudHlwZT1cInNpbmdsZVwiXSBTZXQgdHlwZSBvZiBnYXVnZSB0byBiZSBkaXNwbGF5ZWQuPGJyPjxicj5cclxuXHQgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuXHQgKiAtIHNpbmdsZVxyXG5cdCAqIC0gbXVsdGlcclxuXHQgKiBAcHJvcGVydHkge3N0cmluZ30gW2dhdWdlLmFyY3MubWluV2lkdGg9NV0gU2V0IG1pbmltYWwgd2lkdGggb2YgZ2F1Z2UgYXJjcyB1bnRpbCB0aGUgaW5uZXJSYWRpdXMgZGlzYXBwZWFycy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBnYXVnZToge1xyXG5cdCAqICAgICAgZnVsbENpcmNsZTogZmFsc2UsXHJcblx0ICogICAgICBsYWJlbDoge1xyXG5cdCAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG5cdCAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvKSB7XHJcblx0ICogICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHQgKlxyXG5cdCAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxyXG5cdCAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XHJcblx0ICogICAgICAgICAgfSxcclxuXHQgKiAgICAgICAgICBleHRlbnRzOiBmdW5jdGlvbih2YWx1ZSwgaXNNYXgpIHtcclxuXHQgKiAgICAgICAgICAgICAgcmV0dXJuIChpc01heCA/IFwiTWF4OlwiIDogXCJNaW46XCIpICsgdmFsdWU7XHJcblx0ICogICAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gZGlzYWJsZSBleHBhbmQgdHJhbnNpdGlvbiBmb3IgaW50ZXJhY3Rpb25cclxuXHQgKiAgICAgIGV4cGFuZDogZmFsc2UsXHJcblx0ICpcclxuXHQgKiAgICAgIGV4cGFuZDoge1xyXG5cdCAqICAgICAgXHQvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXHJcblx0ICogICAgICAgICAgZHVyYXRpb246IDUwMCxcclxuXHQgKlxyXG5cdCAqICAgICAgXHQvLyBzZXQgZXhwYW5kIGFyZWEgcmF0ZVxyXG5cdCAqICAgICAgICAgIHJhdGU6IDFcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIG1pbjogLTEwMCxcclxuXHQgKiAgICAgIG1heDogMjAwLFxyXG5cdCAqICAgICAgdHlwZTogXCJzaW5nbGVcIiAgLy8gb3IgJ211bHRpJ1xyXG5cdCAqICAgICAgdGl0bGU6IFwiVGl0bGUgVGV4dFwiLFxyXG5cdCAqICAgICAgdW5pdHM6IFwiJVwiLFxyXG5cdCAqICAgICAgd2lkdGg6IDEwLFxyXG5cdCAqICAgICAgYXJjczoge1xyXG5cdCAqICAgICAgICAgIG1pbldpZHRoOiA1XHJcblx0ICogICAgICB9XHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRnYXVnZV9mdWxsQ2lyY2xlOiBmYWxzZSxcclxuXHRnYXVnZV9sYWJlbF9zaG93OiB0cnVlLFxyXG5cdGdhdWdlX2xhYmVsX2Zvcm1hdDogPCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGdhdWdlX2xhYmVsX2V4dGVudHM6IDwoKCkgPT4gc3RyaW5nKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRnYXVnZV9taW46IDAsXHJcblx0Z2F1Z2VfbWF4OiAxMDAsXHJcblx0Z2F1Z2VfdHlwZTogXCJzaW5nbGVcIixcclxuXHRnYXVnZV9zdGFydGluZ0FuZ2xlOiAtMSAqIE1hdGguUEkgLyAyLFxyXG5cdGdhdWdlX3RpdGxlOiBcIlwiLFxyXG5cdGdhdWdlX3VuaXRzOiA8c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGdhdWdlX3dpZHRoOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdGdhdWdlX2FyY3NfbWluV2lkdGg6IDUsXHJcblx0Z2F1Z2VfZXhwYW5kOiA8Ym9vbGVhbnx7ZHVyYXRpb246IG51bWJlcn0+IHt9LFxyXG5cdGdhdWdlX2V4cGFuZF9yYXRlOiAwLjk4LFxyXG5cdGdhdWdlX2V4cGFuZF9kdXJhdGlvbjogNTBcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogeCBBeGlzIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHBpZSBvcHRpb25zXHJcblx0ICogQG5hbWUgcGllXHJcblx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHQgKiBAdHlwZSB7b2JqZWN0fVxyXG5cdCAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBwaWUgUGllIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BpZS5sYWJlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cclxuXHQgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbcGllLmxhYmVsLmZvcm1hdF0gU2V0IGZvcm1hdHRlciBmb3IgdGhlIGxhYmVsIG9uIGVhY2ggcGllIHBpZWNlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGllLmxhYmVsLnRocmVzaG9sZD0wLjA1XSBTZXQgdGhyZXNob2xkIHRvIHNob3cvaGlkZSBsYWJlbHMuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ8RnVuY3Rpb259IFtwaWUubGFiZWwucmF0aW89dW5kZWZpbmVkXSBTZXQgcmF0aW8gb2YgbGFiZWxzIHBvc2l0aW9uLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbnxvYmplY3R9IFtwaWUuZXhwYW5kPXRydWVdIEVuYWJsZSBvciBkaXNhYmxlIGV4cGFuZGluZyBwaWUgcGllY2VzLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcGllLmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BpZS5leHBhbmQuZHVyYXRpb249NTBdIFNldCBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1zLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfG9iamVjdH0gW3BpZS5pbm5lclJhZGl1cz0wXSBTZXRzIHRoZSBpbm5lciByYWRpdXMgb2YgcGllIGFyYy5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3BpZS5wYWRBbmdsZT0wXSBTZXQgcGFkZGluZyBiZXR3ZWVuIGRhdGEuXHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtwaWUucGFkZGluZz0wXSBTZXRzIHRoZSBnYXAgYmV0d2VlbiBwaWUgYXJjcy5cclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gZG9udXQgRG9udXQgb2JqZWN0XHJcblx0ICogQHByb3BlcnR5IHtudW1iZXJ9IFtkb251dC5zdGFydGluZ0FuZ2xlPTBdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHBpZToge1xyXG5cdCAqICAgICAgbGFiZWw6IHtcclxuXHQgKiAgICAgICAgICBzaG93OiBmYWxzZSxcclxuXHQgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQpIHtcclxuXHQgKiAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdChcIiRcIikodmFsdWUpO1xyXG5cdCAqXHJcblx0ICogICAgICAgICAgICAgIC8vIHRvIG11bHRpbGluZSwgcmV0dXJuIHdpdGggJ1xcbicgY2hhcmFjdGVyXHJcblx0ICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcclxuXHQgKiAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgIHRocmVzaG9sZDogMC4xLFxyXG5cdCAqXHJcblx0ICogICAgICAgICAgLy8gc2V0IHJhdGlvIGNhbGxiYWNrLiBTaG91bGQgcmV0dXJuIHJhdGlvIHZhbHVlXHJcblx0ICogICAgICAgICAgcmF0aW86IGZ1bmN0aW9uKGQsIHJhZGl1cywgaCkge1xyXG5cdCAqICAgICAgICAgICAgICAuLi5cclxuXHQgKiAgICAgICAgICAgICAgcmV0dXJuIHJhdGlvO1xyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgLy8gb3Igc2V0IHJhdGlvIG51bWJlclxyXG5cdCAqICAgICAgICAgIHJhdGlvOiAwLjVcclxuXHQgKiAgICAgIH0sXHJcblx0ICpcclxuXHQgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXHJcblx0ICogICAgICBleHBhbmQ6IGZhbHNlLFxyXG5cdCAqXHJcblx0ICogICAgICBleHBhbmQ6IHtcclxuXHQgKiAgICAgIFx0Ly8gc2V0IGR1cmF0aW9uIG9mIGV4cGFuZCB0cmFuc2l0aW9uIHRvIDUwMG1zLlxyXG5cdCAqICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcblx0ICpcclxuXHQgKiAgICAgIFx0Ly8gc2V0IGV4cGFuZCBhcmVhIHJhdGVcclxuXHQgKiAgICAgICAgICByYXRlOiAxXHJcblx0ICogICAgICB9LFxyXG5cdCAqXHJcblx0ICogICAgICBpbm5lclJhZGl1czogMCxcclxuXHQgKlxyXG5cdCAqICAgICAgLy8gc2V0IGRpZmZlcmVudCBpbm5lclJhZGl1cyBmb3IgZWFjaCBkYXRhXHJcblx0ICogICAgICBpbm5lclJhZGl1czoge1xyXG5cdCAqICAgICAgXHRkYXRhMTogMTAsXHJcblx0ICogICAgICBcdGRhdGEyOiAwXHJcblx0ICogICAgICB9XHJcblx0ICpcclxuXHQgKiAgICAgIHBhZEFuZ2xlOiAwLjEsXHJcblx0ICogICAgICBwYWRkaW5nOiAwLFxyXG5cdCAqICAgICAgc3RhcnRpbmdBbmdsZTogMVxyXG5cdCAqICB9XHJcblx0ICovXHJcblx0cGllX2xhYmVsX3Nob3c6IHRydWUsXHJcblx0cGllX2xhYmVsX2Zvcm1hdDogPCgoKSA9PiBudW1iZXJ8c3RyaW5nKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRwaWVfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxyXG5cdHBpZV9sYWJlbF9yYXRpbzogPCgoKSA9PiBudW1iZXIpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdHBpZV9leHBhbmQ6IDxib29sZWFufHtyYXRlPzogbnVtYmVyOyBkdXJhdGlvbj86IG51bWJlcjt9PiB7fSxcclxuXHRwaWVfZXhwYW5kX3JhdGU6IDAuOTgsXHJcblx0cGllX2V4cGFuZF9kdXJhdGlvbjogNTAsXHJcblx0cGllX2lubmVyUmFkaXVzOiA8bnVtYmVyfHtba2V5OiBzdHJpbmddOiBudW1iZXJ9PiAwLFxyXG5cdHBpZV9wYWRBbmdsZTogMCxcclxuXHRwaWVfcGFkZGluZzogMCxcclxuXHRwaWVfc3RhcnRpbmdBbmdsZTogMFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgcmFkYXIgb3B0aW9uc1xyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgaXQncyB1c2VkIGFzIGxpbmUgYnJlYWsuXHJcblx0ICogQG5hbWUgcmFkYXJcclxuXHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICogQHByb3BlcnR5IHtvYmplY3R9IHJhZGFyIFJhZGFyIG9iamVjdFxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkYXIuYXhpcy5tYXg9dW5kZWZpbmVkXSBUaGUgbWF4IHZhbHVlIG9mIGF4aXMuIElmIG5vdCBnaXZlbiwgaXQnbGwgdGFrZSB0aGUgbWF4IHZhbHVlIGZyb20gdGhlIGdpdmVuIGRhdGEuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcmFkYXIuYXhpcy5saW5lLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGF4aXMgbGluZS5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGFyLmF4aXMudGV4dC5wb3NpdGlvbi54PTBdIHggY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxyXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbcmFkYXIuYXhpcy50ZXh0LnBvc2l0aW9uLnk9MF0geSBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcmFkYXIuYXhpcy50ZXh0LnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGF4aXMgdGV4dC5cclxuXHQgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyYWRhci5kaXJlY3Rpb24uY2xvY2t3aXNlPWZhbHNlXSBTZXQgdGhlIGRpcmVjdGlvbiB0byBiZSBkcmF3bi5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGFyLmxldmVsLmRlcHRoPTNdIFNldCB0aGUgbGV2ZWwgZGVwdGguXHJcblx0ICogQHByb3BlcnR5IHtib29sZWFufSBbcmFkYXIubGV2ZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGV2ZWwuXHJcblx0ICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3JhZGFyLmxldmVsLnRleHQuZm9ybWF0PSh4KSA9PiAoeCAlIDEgPT09IDAgPyB4IDogeC50b0ZpeGVkKDIpKV0gU2V0IGZvcm1hdCBmdW5jdGlvbiBmb3IgdGhlIGxldmVsIHZhbHVlLlxyXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JhZGFyLmxldmVsLnRleHQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGV2ZWwgdGV4dC5cclxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gW3JhZGFyLnNpemUucmF0aW89MC44N10gU2V0IHNpemUgcmF0aW8uXHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlJhZGFyQ2hhcnQpXHJcblx0ICogQHNlZSBbRGVtbzogcmFkYXIgYXhpc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyQXhpcylcclxuXHQgKiBAc2VlIFtEZW1vOiByYWRhciBsZXZlbF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyTGV2ZWwpXHJcblx0ICogQHNlZSBbRGVtbzogcmFkYXIgc2l6ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyU2l6ZSlcclxuXHQgKiBAc2VlIFtEZW1vOiByYWRhciBheGlzIG11bHRpbGluZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyQXhpc011bHRpbGluZSlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICByYWRhcjoge1xyXG5cdCAqICAgICAgYXhpczoge1xyXG5cdCAqICAgICAgICAgIG1heDogNTAsXHJcblx0ICogICAgICAgICAgbGluZToge1xyXG5cdCAqICAgICAgICAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICAgICAgIH0sXHJcblx0ICogICAgICAgICAgdGV4dDoge1xyXG5cdCAqICAgICAgICAgICAgICBwb3NpdGlvbjoge1xyXG5cdCAqICAgICAgICAgICAgICBcdHg6IDAsXHJcblx0ICogICAgICAgICAgICAgIFx0eTogMFxyXG5cdCAqICAgICAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgICAgICBzaG93OiBmYWxzZVxyXG5cdCAqICAgICAgICAgIH1cclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBkaXJlY3Rpb246IHtcclxuXHQgKiAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcclxuXHQgKiAgICAgIH0sXHJcblx0ICogICAgICBsZXZlbDoge1xyXG5cdCAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG5cdCAqICAgICAgICAgIHRleHQ6IHtcclxuXHQgKiAgICAgICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcblx0ICogICAgICAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG5cdCAqICAgICAgICAgICAgICB9LFxyXG5cdCAqICAgICAgICAgICAgICBzaG93OiB0cnVlXHJcblx0ICogICAgICAgICAgfVxyXG5cdCAqICAgICAgfSxcclxuXHQgKiAgICAgIHNpemU6IHtcclxuXHQgKiAgICAgICAgICByYXRpbzogMC43XHJcblx0ICogICAgICB9XHJcblx0ICogIH1cclxuXHQgKi9cclxuXHRyYWRhcl9heGlzX21heDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHRyYWRhcl9heGlzX2xpbmVfc2hvdzogdHJ1ZSxcclxuXHRyYWRhcl9heGlzX3RleHRfc2hvdzogdHJ1ZSxcclxuXHRyYWRhcl9heGlzX3RleHRfcG9zaXRpb246IDx7eD86IG51bWJlcjsgeT86IG51bWJlcjt9PiB7fSxcclxuXHRyYWRhcl9sZXZlbF9kZXB0aDogMyxcclxuXHRyYWRhcl9sZXZlbF9zaG93OiB0cnVlLFxyXG5cdHJhZGFyX2xldmVsX3RleHRfZm9ybWF0OiAoeDogbnVtYmVyKSA9PiAoeCAlIDEgPT09IDAgPyB4IDogeC50b0ZpeGVkKDIpKSxcclxuXHRyYWRhcl9sZXZlbF90ZXh0X3Nob3c6IHRydWUsXHJcblx0cmFkYXJfc2l6ZV9yYXRpbzogMC44NyxcclxuXHRyYWRhcl9kaXJlY3Rpb25fY2xvY2t3aXNlOiBmYWxzZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBXaW5kb3cgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cclxuZXhwb3J0IHt3aW4gYXMgd2luZG93LCBkb2MgYXMgZG9jdW1lbnR9O1xyXG5cclxuY29uc3Qgd2luID0gKCgpID0+IHtcclxuXHRjb25zdCBkZWYgPSBvID0+IHR5cGVvZiBvICE9PSBcInVuZGVmaW5lZFwiICYmIG87XHJcblxyXG5cdHJldHVybiBkZWYoc2VsZikgfHwgZGVmKHdpbmRvdykgfHwgZGVmKGdsb2JhbCkgfHwgZGVmKGdsb2JhbFRoaXMpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcclxufSkoKTtcclxuLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cclxuXHJcbmNvbnN0IGRvYyA9IHdpbiAmJiB3aW4uZG9jdW1lbnQ7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge2V2ZW50IGFzIGQzRXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHticnVzaFNlbGVjdGlvbiBhcyBkM0JydXNoU2VsZWN0aW9ufSBmcm9tIFwiZDMtYnJ1c2hcIjtcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnQsIHdpbmRvd30gZnJvbSBcIi4vYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQge1xyXG5cdGFzSGFsZlBpeGVsLFxyXG5cdGJydXNoRW1wdHksXHJcblx0Y2FsbEZuLFxyXG5cdGNhcGl0YWxpemUsXHJcblx0Y2VpbDEwLFxyXG5cdGNvbnZlcnRJbnB1dFR5cGUsXHJcblx0ZGlmZkRvbWFpbixcclxuXHRlbmRhbGwsXHJcblx0ZW11bGF0ZUV2ZW50LFxyXG5cdGV4dGVuZCxcclxuXHRnZXRCcnVzaFNlbGVjdGlvbixcclxuXHRnZXRCb3VuZGluZ1JlY3QsXHJcblx0Z2V0Q3NzUnVsZXMsXHJcblx0Z2V0TWluTWF4LFxyXG5cdGdldE9wdGlvbixcclxuXHRnZXRQYXRoQm94LFxyXG5cdGdldFJhbmRvbSxcclxuXHRnZXRSYW5nZSxcclxuXHRnZXRSZWN0U2VnTGlzdCxcclxuXHRnZXRUcmFuc2xhdGlvbixcclxuXHRnZXRVbmlxdWUsXHJcblx0aGFzVmFsdWUsXHJcblx0aXNBcnJheSxcclxuXHRpc2Jvb2xlYW4sXHJcblx0aXNEZWZpbmVkLFxyXG5cdGlzRW1wdHksXHJcblx0aXNGdW5jdGlvbixcclxuXHRpc051bWJlcixcclxuXHRpc09iamVjdCxcclxuXHRpc09iamVjdFR5cGUsXHJcblx0aXNTdHJpbmcsXHJcblx0aXNUYWJWaXNpYmxlLFxyXG5cdGlzVW5kZWZpbmVkLFxyXG5cdGlzVmFsdWUsXHJcblx0bWVyZ2VBcnJheSxcclxuXHRtZXJnZU9iaixcclxuXHRub3RFbXB0eSxcclxuXHRwYXJzZURhdGUsXHJcblx0c2FuaXRpc2UsXHJcblx0c2V0VGV4dFZhbHVlLFxyXG5cdHNvcnRWYWx1ZSxcclxuXHR0b0FycmF5LFxyXG5cdHRwbFByb2Nlc3NcclxufTtcclxuXHJcbmNvbnN0IGlzVmFsdWUgPSAodjogYW55KTogYm9vbGVhbiA9PiB2IHx8IHYgPT09IDA7XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xyXG5jb25zdCBpc1N0cmluZyA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiO1xyXG5jb25zdCBpc051bWJlciA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xyXG5jb25zdCBpc1VuZGVmaW5lZCA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiO1xyXG5jb25zdCBpc0RlZmluZWQgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiAhPT0gXCJ1bmRlZmluZWRcIjtcclxuY29uc3QgaXNib29sZWFuID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiO1xyXG5jb25zdCBjZWlsMTAgPSAodjogYW55KTogbnVtYmVyID0+IE1hdGguY2VpbCh2IC8gMTApICogMTA7XHJcbmNvbnN0IGFzSGFsZlBpeGVsID0gKG46IGFueSk6IG51bWJlciA9PiBNYXRoLmNlaWwobikgKyAwLjU7XHJcbmNvbnN0IGRpZmZEb21haW4gPSAoZDogbnVtYmVyW10pOiBudW1iZXIgPT4gZFsxXSAtIGRbMF07XHJcbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcIm9iamVjdFwiO1xyXG5jb25zdCBpc0VtcHR5ID0gKG86IGFueSk6IGJvb2xlYW4gPT4gKFxyXG5cdGlzVW5kZWZpbmVkKG8pIHx8IG8gPT09IG51bGwgfHxcclxuXHQoaXNTdHJpbmcobykgJiYgby5sZW5ndGggPT09IDApIHx8XHJcblx0KGlzT2JqZWN0VHlwZShvKSAmJiAhKG8gaW5zdGFuY2VvZiBEYXRlKSAmJiBPYmplY3Qua2V5cyhvKS5sZW5ndGggPT09IDApIHx8XHJcblx0KGlzTnVtYmVyKG8pICYmIGlzTmFOKG8pKVxyXG4pO1xyXG5jb25zdCBub3RFbXB0eSA9IChvOiBhbnkpOiBib29sZWFuID0+ICFpc0VtcHR5KG8pO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGlzIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBEYXRhIHRvIGJlIGNoZWNrZWRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBpc0FycmF5ID0gKGFycjogYW55KTogYm9vbGVhbiA9PiBBcnJheS5pc0FycmF5KGFycik7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgaXMgb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogRGF0YSB0byBiZSBjaGVja2VkXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgaXNPYmplY3QgPSAob2JqOiBhbnkpOiBib29sZWFuID0+IG9iaiAmJiAhb2JqLm5vZGVUeXBlICYmIGlzT2JqZWN0VHlwZShvYmopICYmICFpc0FycmF5KG9iaik7XHJcblxyXG4vKipcclxuICogR2V0IHNwZWNpZmllZCBrZXkgdmFsdWUgZnJvbSBvYmplY3RcclxuICogSWYgZGVmYXVsdCB2YWx1ZSBpcyBnaXZlbiwgd2lsbCByZXR1cm4gaWYgZ2l2ZW4ga2V5IHZhbHVlIG5vdCBmb3VuZFxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBTb3VyY2Ugb2JqZWN0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgS2V5IHZhbHVlXHJcbiAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIERlZmF1bHQgdmFsdWVcclxuICogQHJldHVybnMgeyp9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRPcHRpb24ob3B0aW9uczogb2JqZWN0LCBrZXk6IHN0cmluZywgZGVmYXVsdFZhbHVlKTogYW55IHtcclxuXHRyZXR1cm4gaXNEZWZpbmVkKG9wdGlvbnNba2V5XSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0VmFsdWU7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB2YWx1ZSBleGlzdCBpbiB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaWN0IFRhcmdldCBvYmplY3QgdG8gYmUgY2hlY2tlZFxyXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGJlIGNoZWNrZWRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNWYWx1ZShkaWN0OiBvYmplY3QsIHZhbHVlOiBhbnkpOiBib29sZWFuIHtcclxuXHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0T2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChrZXkgPT4gKGRpY3Rba2V5XSA9PT0gdmFsdWUpICYmIChmb3VuZCA9IHRydWUpKTtcclxuXHJcblx0cmV0dXJuIGZvdW5kO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsbCBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50c1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICogQHBhcmFtIHsqfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZTogZm4gaXMgZnVuY3Rpb24sIGZhbHNlOiBmbiBpcyBub3QgZnVuY3Rpb25cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNhbGxGbihmbiwgLi4uYXJncyk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IGlzRm4gPSBpc0Z1bmN0aW9uKGZuKTtcclxuXHJcblx0aXNGbiAmJiBmbi5jYWxsKC4uLmFyZ3MpO1xyXG5cdHJldHVybiBpc0ZuO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsbCBmdW5jdGlvbiBhZnRlciBhbGwgdHJhbnNpdGlvbnMgZW5kc1xyXG4gKiBAcGFyYW0ge2QzLnRyYW5zaXRpb259IHRyYW5zaXRpb24gVHJhbnNpdGlvblxyXG4gKiBAcGFyYW0ge0Z1Y250aW9ufSBjYiBDYWxsYmFjayBmdW5jdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZW5kYWxsKHRyYW5zaXRpb24sIGNiOiBGdW5jdGlvbik6IHZvaWQge1xyXG5cdGxldCBuID0gMDtcclxuXHJcblx0dHJhbnNpdGlvblxyXG5cdFx0LmVhY2goKCkgPT4gKytuKVxyXG5cdFx0Lm9uKFwiZW5kXCIsIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcclxuXHRcdFx0IS0tbiAmJiBjYi5hcHBseSh0aGlzLCAuLi5hcmdzKTtcclxuXHRcdH0pO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwbGFjZSB0YWcgc2lnbiB0byBodG1sIGVudGl0eVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRhcmdldCBzdHJpbmcgdmFsdWVcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNhbml0aXNlKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gaXNTdHJpbmcoc3RyKSA/XHJcblx0XHRzdHIucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikgOiBzdHI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGV4dCB2YWx1ZS4gSWYgdGhlcmUncyBtdWx0aWxpbmUgYWRkIG5vZGVzLlxyXG4gKiBAcGFyYW0ge2QzU2VsZWN0aW9ufSBub2RlIFRleHQgbm9kZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUZXh0IHZhbHVlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge0FycmF5fSBkeSBkeSB2YWx1ZSBmb3IgbXVsdGlsaW5lZCB0ZXh0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9NaWRkbGUgVG8gYmUgYWxpbmduZWQgdmVydGljYWxseSBtaWRkbGVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldFRleHRWYWx1ZShcclxuXHRub2RlOiBkM1NlbGVjdGlvbixcclxuXHR0ZXh0OiBzdHJpbmcsXHJcblx0ZHk6IG51bWJlcltdID0gWy0xLCAxXSxcclxuXHR0b01pZGRsZTogYm9vbGVhbiA9IGZhbHNlXHJcbikge1xyXG5cdGlmICghbm9kZSB8fCAhaXNTdHJpbmcodGV4dCkpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGlmICh0ZXh0LmluZGV4T2YoXCJcXG5cIikgPT09IC0xKSB7XHJcblx0XHRub2RlLnRleHQodGV4dCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGNvbnN0IGRpZmYgPSBbbm9kZS50ZXh0KCksIHRleHRdLm1hcCh2ID0+IHYucmVwbGFjZSgvW1xcc1xcbl0vZywgXCJcIikpO1xyXG5cclxuXHRcdGlmIChkaWZmWzBdICE9PSBkaWZmWzFdKSB7XHJcblx0XHRcdGNvbnN0IG11bHRpbGluZSA9IHRleHQuc3BsaXQoXCJcXG5cIik7XHJcblx0XHRcdGNvbnN0IGxlbiA9IHRvTWlkZGxlID8gbXVsdGlsaW5lLmxlbmd0aCAtIDEgOiAxO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgcG9zc2libGUgdGV4dFxyXG5cdFx0XHRub2RlLmh0bWwoXCJcIik7XHJcblxyXG5cdFx0XHRtdWx0aWxpbmUuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdG5vZGUuYXBwZW5kKFwidHNwYW5cIilcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBgJHtpID09PSAwID8gZHlbMF0gKiBsZW4gOiBkeVsxXX1lbWApXHJcblx0XHRcdFx0XHQudGV4dCh2KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogU3Vic3RpdHV0aW9uIG9mIFNWR1BhdGhTZWcgQVBJIHBvbHlmaWxsXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSBwYXRoIFRhcmdldCBzdmcgZWxlbWVudFxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSZWN0U2VnTGlzdChwYXRoOiBTVkdHcmFwaGljc0VsZW1lbnQpOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9W10ge1xyXG5cdC8qXHJcblx0ICogc2VnMSAtLS0tLS0tLS0tIHNlZzJcclxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XHJcblx0ICogICB8ICAgICAgICAgICAgICAgfFxyXG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcclxuXHQgKiBzZWcwIC0tLS0tLS0tLS0gc2VnM1xyXG5cdCAqICovXHJcblx0Y29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gcGF0aC5nZXRCQm94KCk7XHJcblxyXG5cdHJldHVybiBbXHJcblx0XHR7eCwgeTogeSArIGhlaWdodH0sIC8vIHNlZzBcclxuXHRcdHt4LCB5fSwgLy8gc2VnMVxyXG5cdFx0e3g6IHggKyB3aWR0aCwgeX0sIC8vIHNlZzJcclxuXHRcdHt4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHR9IC8vIHNlZzNcclxuXHRdO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHN2ZyBib3VuZGluZyBwYXRoIGJveCBkaW1lbnNpb25cclxuICogQHBhcmFtIHtTVkdHcmFwaGljc0VsZW1lbnR9IHBhdGggVGFyZ2V0IHN2ZyBlbGVtZW50XHJcbiAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYXRoQm94KFxyXG5cdHBhdGg6IFNWR0dyYXBoaWNzRWxlbWVudFxyXG4pOiB7eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfSB7XHJcblx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRjb25zdCBpdGVtcyA9IGdldFJlY3RTZWdMaXN0KHBhdGgpO1xyXG5cdGNvbnN0IHggPSBpdGVtc1swXS54O1xyXG5cdGNvbnN0IHkgPSBNYXRoLm1pbihpdGVtc1swXS55LCBpdGVtc1sxXS55KTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHgsIHksIHdpZHRoLCBoZWlnaHRcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIGJydXNoIHNlbGVjdGlvbiBhcnJheVxyXG4gKiBAcGFyYW0ge29iamVjdH0gJGVsIFNlbGVjdGlvbiBvYmplY3RcclxuICogQHJldHVybnMge2QzLmJydXNoU2VsZWN0aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QnJ1c2hTZWxlY3Rpb24oeyRlbH0pIHtcclxuXHRjb25zdCBldmVudCA9IGQzRXZlbnQ7XHJcblx0Y29uc3QgbWFpbiA9ICRlbC5zdWJjaGFydC5tYWluIHx8ICRlbC5tYWluO1xyXG5cdGxldCBzZWxlY3Rpb247XHJcblxyXG5cdC8vIGNoZWNrIGZyb20gZXZlbnRcclxuXHRpZiAoZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJicnVzaFwiKSB7XHJcblx0XHRzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb247XHJcblx0Ly8gY2hlY2sgZnJvbSBicnVzaCBhcmVhIHNlbGVjdGlvblxyXG5cdH0gZWxzZSBpZiAobWFpbiAmJiAoc2VsZWN0aW9uID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApLm5vZGUoKSkpIHtcclxuXHRcdHNlbGVjdGlvbiA9IGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBzZWxlY3Rpb247XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgYm91bmRpbmdDbGllbnRSZWN0LlxyXG4gKiBDYWNoZSB0aGUgZXZhbHVhdGVkIHZhbHVlIG9uY2UgaXQgd2FzIGNhbGxlZC5cclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZSBUYXJnZXQgZWxlbWVudFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgZ2V0Qm91bmRpbmdSZWN0ID0gKG5vZGUpOiB7XHJcblx0bGVmdDogbnVtYmVyLCB0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsXHJcblx0eDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyXHJcbn0gPT4gbm9kZS5yZWN0IHx8IChub2RlLnJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxuXHJcbi8qKlxyXG4gKiBSZXRydW4gcmFuZG9tIG51bWJlclxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFzU3RyIENvbnZlcnQgcmV0dXJuZWQgdmFsdWUgYXMgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ8c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmFuZG9tKGFzU3RyOiBib29sZWFuID0gdHJ1ZSk6IG51bWJlciB8IHN0cmluZyB7XHJcblx0Y29uc3QgcmFuZCA9IE1hdGgucmFuZG9tKCk7XHJcblxyXG5cdHJldHVybiBhc1N0ciA/IFN0cmluZyhyYW5kKSA6IHJhbmQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBicnVzaCBpcyBlbXB0eVxyXG4gKiBAcGFyYW0ge29iamVjdH0gY3R4IEJ1cnNoIGNvbnRleHRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBicnVzaEVtcHR5KGN0eCk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IHNlbGVjdGlvbiA9IGdldEJydXNoU2VsZWN0aW9uKGN0eCk7XHJcblxyXG5cdGlmIChzZWxlY3Rpb24pIHtcclxuXHRcdC8vIGJydXNoIHNlbGVjdGVkIGFyZWFcclxuXHRcdC8vIHR3by1kaW1lbnNpb25hbDogW1t4MCwgeTBdLCBbeDEsIHkxXV1cclxuXHRcdC8vIG9uZS1kaW1lbnNpb25hbDogW3gwLCB4MV0gb3IgW3kwLCB5MV1cclxuXHRcdHJldHVybiBzZWxlY3Rpb25bMF0gPT09IHNlbGVjdGlvblsxXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0cnVlO1xyXG59XHJcblxyXG4vKipcclxuICogRXh0ZW5kIHRhcmdldCBmcm9tIHNvdXJjZSBvYmplY3RcclxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdFxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCA9IHt9LCBzb3VyY2UpOiBvYmplY3Qge1xyXG5cdGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuXHRcdHNvdXJjZS5mb3JFYWNoKHYgPT4gZXh0ZW5kKHRhcmdldCwgdikpO1xyXG5cdH1cclxuXHJcblx0Ly8gZXhjbHVkZSBuYW1lIHdpdGggb25seSBudW1iZXJzXHJcblx0Zm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xyXG5cdFx0aWYgKC9eXFxkKyQvLnRlc3QocCkgfHwgcCBpbiB0YXJnZXQpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGFyZ2V0W3BdID0gc291cmNlW3BdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBmaXJzdCBsZXR0ZXIgY2FwaXRhbGl6ZWRcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUYXJnZXQgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IGNhcGl0YWxpemVkIHN0cmluZ1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FwaXRhbGl6ZSA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcblxyXG4vKipcclxuICogQ29udmVydCB0byBhcnJheVxyXG4gKiBAcGFyYW0ge29iamVjdH0gdiBUYXJnZXQgdG8gYmUgY29udmVydGVkXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvQXJyYXkgPSAodjogQ1NTU3R5bGVEZWNsYXJhdGlvbiB8IGFueSk6IGFueSA9PiBbXS5zbGljZS5jYWxsKHYpO1xyXG5cclxuLyoqXHJcbiAqIEdldCBjc3MgcnVsZXMgZm9yIHNwZWNpZmllZCBzdHlsZXNoZWV0c1xyXG4gKiBAcGFyYW0ge0FycmF5fSBzdHlsZVNoZWV0cyBUaGUgc3R5bGVzaGVldHMgdG8gZ2V0IHRoZSBydWxlcyBmcm9tXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldENzc1J1bGVzKHN0eWxlU2hlZXRzOiBhbnlbXSkge1xyXG5cdGxldCBydWxlcyA9IFtdO1xyXG5cclxuXHRzdHlsZVNoZWV0cy5mb3JFYWNoKHNoZWV0ID0+IHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGlmIChzaGVldC5jc3NSdWxlcyAmJiBzaGVldC5jc3NSdWxlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRydWxlcyA9IHJ1bGVzLmNvbmNhdCh0b0FycmF5KHNoZWV0LmNzc1J1bGVzKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgcmVhZGluZyBydWxlcyBmcm9tICR7c2hlZXQuaHJlZn06ICR7ZS50b1N0cmluZygpfWApO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gcnVsZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBTVkdNYXRyaXggb2YgYW4gU1ZHR0VsZW1lbnRcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBub2RlIE5vZGUgZWxlbWVudFxyXG4gKiBAcmV0dXJucyB7U1ZHTWF0cml4fSBtYXRyaXhcclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGdldFRyYW5zbGF0aW9uID0gbm9kZSA9PiB7XHJcblx0Y29uc3QgdHJhbnNmb3JtID0gbm9kZSA/IG5vZGUudHJhbnNmb3JtIDogbnVsbDtcclxuXHRjb25zdCBiYXNlVmFsID0gdHJhbnNmb3JtICYmIHRyYW5zZm9ybS5iYXNlVmFsO1xyXG5cclxuXHRyZXR1cm4gYmFzZVZhbCAmJiBiYXNlVmFsLm51bWJlck9mSXRlbXMgP1xyXG5cdFx0YmFzZVZhbC5nZXRJdGVtKDApLm1hdHJpeCA6XHJcblx0XHR7YTogMCwgYjogMCwgYzogMCwgZDogMCwgZTogMCwgZjogMH07XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0IHVuaXF1ZSB2YWx1ZSBmcm9tIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgU291cmNlIGRhdGFcclxuICogQHJldHVybnMge0FycmF5fSBVbmlxdWUgYXJyYXkgdmFsdWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFVuaXF1ZShkYXRhOiBhbnlbXSk6IGFueVtdIHtcclxuXHRjb25zdCBpc0RhdGUgPSBkYXRhWzBdIGluc3RhbmNlb2YgRGF0ZTtcclxuXHRjb25zdCBkID0gKGlzRGF0ZSA/IGRhdGEubWFwKE51bWJlcikgOiBkYXRhKVxyXG5cdFx0LmZpbHRlcigodiwgaSwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHYpID09PSBpKTtcclxuXHJcblx0cmV0dXJuIGlzRGF0ZSA/IGQubWFwKHYgPT4gbmV3IERhdGUodikpIDogZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyciBTb3VyY2UgYXJyYXlcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VBcnJheShhcnI6IGFueVtdKTogYW55W10ge1xyXG5cdHJldHVybiBhcnIgJiYgYXJyLmxlbmd0aCA/IGFyci5yZWR1Y2UoKHAsIGMpID0+IHAuY29uY2F0KGMpKSA6IFtdO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2Ugb2JqZWN0IHJldHVybmluZyBuZXcgb2JqZWN0XHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdFxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0TiBTb3VyY2Ugb2JqZWN0XHJcbiAqIEByZXR1cm5zIHtvYmplY3R9IG1lcmdlZCB0YXJnZXQgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU9iaih0YXJnZXQ6IG9iamVjdCwgLi4ub2JqZWN0Tik6IGFueSB7XHJcblx0aWYgKCFvYmplY3ROLmxlbmd0aCB8fCAob2JqZWN0Ti5sZW5ndGggPT09IDEgJiYgIW9iamVjdE5bMF0pKSB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH1cclxuXHJcblx0Y29uc3Qgc291cmNlID0gb2JqZWN0Ti5zaGlmdCgpO1xyXG5cclxuXHRpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XHJcblx0XHRPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcclxuXHJcblx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuXHRcdFx0XHQhdGFyZ2V0W2tleV0gJiYgKHRhcmdldFtrZXldID0ge30pO1xyXG5cdFx0XHRcdHRhcmdldFtrZXldID0gbWVyZ2VPYmoodGFyZ2V0W2tleV0sIHZhbHVlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGlzQXJyYXkodmFsdWUpID9cclxuXHRcdFx0XHRcdHZhbHVlLmNvbmNhdCgpIDogdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1lcmdlT2JqKHRhcmdldCwgLi4ub2JqZWN0Tik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb3J0IHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgdmFsdWUgdG8gYmUgc29ydGVkXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNBc2MgdHJ1ZTogYXNjLCBmYWxzZTogZGVzY1xyXG4gKiBAcmV0dXJucyB7bnVtYmVyfHN0cmluZ3xEYXRlfSBzb3J0ZWQgZGF0ZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc29ydFZhbHVlKGRhdGE6IGFueVtdLCBpc0FzYyA9IHRydWUpOiBhbnlbXSB7XHJcblx0bGV0IGZuO1xyXG5cclxuXHRpZiAoZGF0YVswXSBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdGZuID0gaXNBc2MgPyAoYSwgYikgPT4gYSAtIGIgOiAoYSwgYikgPT4gYiAtIGE7XHJcblx0fSBlbHNlIHtcclxuXHRcdGlmIChpc0FzYyAmJiAhZGF0YS5ldmVyeShpc05hTikpIHtcclxuXHRcdFx0Zm4gPSAoYSwgYikgPT4gYSAtIGI7XHJcblx0XHR9IGVsc2UgaWYgKCFpc0FzYykge1xyXG5cdFx0XHRmbiA9IChhLCBiKSA9PiAoYSA+IGIgJiYgLTEpIHx8IChhIDwgYiAmJiAxKSB8fCAoYSA9PT0gYiAmJiAwKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBkYXRhLmNvbmNhdCgpLnNvcnQoZm4pO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IG1pbi9tYXggdmFsdWVcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgJ21pbicgb3IgJ21heCdcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBcnJheSBkYXRhIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ8RGF0ZXx1bmRlZmluZWR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNaW5NYXgodHlwZTogXCJtaW5cIiB8IFwibWF4XCIsIGRhdGE6IG51bWJlcltdIHwgRGF0ZVtdIHwgYW55KTogbnVtYmVyIHwgRGF0ZSB8IHVuZGVmaW5lZCB8IGFueSB7XHJcblx0bGV0IHJlcyA9IGRhdGEuZmlsdGVyKHYgPT4gbm90RW1wdHkodikpO1xyXG5cclxuXHRpZiAocmVzLmxlbmd0aCkge1xyXG5cdFx0aWYgKGlzTnVtYmVyKHJlc1swXSkpIHtcclxuXHRcdFx0cmVzID0gTWF0aFt0eXBlXSguLi5yZXMpO1xyXG5cdFx0fSBlbHNlIGlmIChyZXNbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdHJlcyA9IHNvcnRWYWx1ZShyZXMsIHR5cGUgPT09IFwibWluXCIpWzBdO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXMgPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHJhbmdlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBTdGFydCBudW1iZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBFbmQgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFN0ZXAgbnVtYmVyXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGdldFJhbmdlID0gKHN0YXJ0OiBudW1iZXIsIGVuZDogbnVtYmVyLCBzdGVwID0gMSk6IG51bWJlcltdID0+IHtcclxuXHRjb25zdCByZXM6IG51bWJlcltdID0gW107XHJcblx0Y29uc3QgbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCkpIHwgMDtcclxuXHJcblx0Zm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbjsgaSsrKSB7XHJcblx0XHRyZXMucHVzaChzdGFydCArIGkgKiBzdGVwKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXM7XHJcbn07XHJcblxyXG4vLyBlbXVsYXRlIGV2ZW50XHJcbmNvbnN0IGVtdWxhdGVFdmVudCA9IHtcclxuXHRtb3VzZTogKCgpID0+IHtcclxuXHRcdGNvbnN0IGdldFBhcmFtcyA9ICgpID0+ICh7XHJcblx0XHRcdGJ1YmJsZXM6IGZhbHNlLCBjYW5jZWxhYmxlOiBmYWxzZSwgc2NyZWVuWDogMCwgc2NyZWVuWTogMCwgY2xpZW50WDogMCwgY2xpZW50WTogMFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xyXG5cdFx0XHRuZXcgTW91c2VFdmVudChcInRcIik7XHJcblxyXG5cdFx0XHRyZXR1cm4gKGVsOiBTVkdFbGVtZW50IHwgSFRNTEVsZW1lbnQsIGV2ZW50VHlwZTogc3RyaW5nLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xyXG5cdFx0XHRcdGVsLmRpc3BhdGNoRXZlbnQobmV3IE1vdXNlRXZlbnQoZXZlbnRUeXBlLCBwYXJhbXMpKTtcclxuXHRcdFx0fTtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Ly8gUG9seWZpbGxzIERPTTQgTW91c2VFdmVudFxyXG5cdFx0XHRyZXR1cm4gKGVsOiBTVkdFbGVtZW50IHwgSFRNTEVsZW1lbnQsIGV2ZW50VHlwZTogc3RyaW5nLCBwYXJhbXMgPSBnZXRQYXJhbXMoKSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IG1vdXNlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XHJcblxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L2luaXRNb3VzZUV2ZW50XHJcblx0XHRcdFx0bW91c2VFdmVudC5pbml0TW91c2VFdmVudChcclxuXHRcdFx0XHRcdGV2ZW50VHlwZSxcclxuXHRcdFx0XHRcdHBhcmFtcy5idWJibGVzLFxyXG5cdFx0XHRcdFx0cGFyYW1zLmNhbmNlbGFibGUsXHJcblx0XHRcdFx0XHR3aW5kb3csXHJcblx0XHRcdFx0XHQwLCAvLyB0aGUgZXZlbnQncyBtb3VzZSBjbGljayBjb3VudFxyXG5cdFx0XHRcdFx0cGFyYW1zLnNjcmVlblgsIHBhcmFtcy5zY3JlZW5ZLFxyXG5cdFx0XHRcdFx0cGFyYW1zLmNsaWVudFgsIHBhcmFtcy5jbGllbnRZLFxyXG5cdFx0XHRcdFx0ZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGxcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG1vdXNlRXZlbnQpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH0pKCksXHJcblx0dG91Y2g6IChlbDogU1ZHRWxlbWVudCB8IEhUTUxFbGVtZW50LCBldmVudFR5cGU6IHN0cmluZywgcGFyYW1zOiBhbnkpID0+IHtcclxuXHRcdGNvbnN0IHRvdWNoT2JqID0gbmV3IFRvdWNoKG1lcmdlT2JqKHtcclxuXHRcdFx0aWRlbnRpZmllcjogRGF0ZS5ub3coKSxcclxuXHRcdFx0dGFyZ2V0OiBlbCxcclxuXHRcdFx0cmFkaXVzWDogMi41LFxyXG5cdFx0XHRyYWRpdXNZOiAyLjUsXHJcblx0XHRcdHJvdGF0aW9uQW5nbGU6IDEwLFxyXG5cdFx0XHRmb3JjZTogMC41XHJcblx0XHR9LCBwYXJhbXMpKTtcclxuXHJcblx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBUb3VjaEV2ZW50KGV2ZW50VHlwZSwge1xyXG5cdFx0XHRjYW5jZWxhYmxlOiB0cnVlLFxyXG5cdFx0XHRidWJibGVzOiB0cnVlLFxyXG5cdFx0XHRzaGlmdEtleTogdHJ1ZSxcclxuXHRcdFx0dG91Y2hlczogW3RvdWNoT2JqXSxcclxuXHRcdFx0dGFyZ2V0VG91Y2hlczogW10sXHJcblx0XHRcdGNoYW5nZWRUb3VjaGVzOiBbdG91Y2hPYmpdXHJcblx0XHR9KSk7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb2Nlc3MgdGhlIHRlbXBsYXRlICAmIHJldHVybiBib3VuZCBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IHRwbCBUZW1wbGF0ZSBzdHJpbmdcclxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSB2YWx1ZSB0byBiZSByZXBsYWNlZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdHBsUHJvY2Vzcyh0cGw6IHN0cmluZywgZGF0YTogb2JqZWN0KTogc3RyaW5nIHtcclxuXHRsZXQgcmVzID0gdHBsO1xyXG5cclxuXHRmb3IgKGNvbnN0IHggaW4gZGF0YSkge1xyXG5cdFx0cmVzID0gcmVzLnJlcGxhY2UobmV3IFJlZ0V4cChgez0ke3h9fWAsIFwiZ1wiKSwgZGF0YVt4XSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHBhcnNlZCBkYXRlIHZhbHVlXHJcbiAqIChJdCBtdXN0IGJlIGNhbGxlZCBpbiAnQ2hhcnRJbnRlcm5hbCcgY29udGV4dClcclxuICogQHBhcmFtIHtEYXRlfHN0cmluZ3xudW1iZXJ9IGRhdGUgVmFsdWUgb2YgZGF0ZSB0byBiZSBwYXJzZWRcclxuICogQHJldHVybnMge0RhdGV9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURhdGUoZGF0ZTogRGF0ZSB8IHN0cmluZyB8IG51bWJlciB8IGFueSk6IERhdGUge1xyXG5cdGxldCBwYXJzZWREYXRlO1xyXG5cclxuXHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdHBhcnNlZERhdGUgPSBkYXRlO1xyXG5cdH0gZWxzZSBpZiAoaXNTdHJpbmcoZGF0ZSkpIHtcclxuXHRcdGNvbnN0IHtjb25maWcsIGZvcm1hdH0gPSB0aGlzO1xyXG5cclxuXHRcdHBhcnNlZERhdGUgPSBmb3JtYXQuZGF0YVRpbWUoY29uZmlnLmRhdGFfeEZvcm1hdCkoZGF0ZSk7XHJcblx0fSBlbHNlIGlmIChpc051bWJlcihkYXRlKSAmJiAhaXNOYU4oZGF0ZSkpIHtcclxuXHRcdHBhcnNlZERhdGUgPSBuZXcgRGF0ZSgrZGF0ZSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIXBhcnNlZERhdGUgfHwgaXNOYU4oK3BhcnNlZERhdGUpKSB7XHJcblx0XHRjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IgJiZcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBhcnNlIHggJyR7ZGF0ZX0nIHRvIERhdGUgb2JqZWN0YCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcGFyc2VkRGF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBpZiB0aGUgY3VycmVudCBkb2MgaXMgdmlzaWJsZSBvciBub3RcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1RhYlZpc2libGUoKTogYm9vbGVhbiB7XHJcblx0cmV0dXJuICFkb2N1bWVudC5oaWRkZW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgaW5wdXQgdHlwZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1vdXNlIENvbmZpZyB2YWx1ZTogaW50ZXJhY3Rpb24uaW5wdXRUeXBlLm1vdXNlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdG91Y2ggQ29uZmlnIHZhbHVlOiBpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2hcclxuICogQHJldHVybnMge3N0cmluZ30gXCJtb3VzZVwiIHwgXCJ0b3VjaFwiIHwgbnVsbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY29udmVydElucHV0VHlwZShtb3VzZTogYm9vbGVhbiwgdG91Y2g6IGJvb2xlYW4pOiBcIm1vdXNlXCIgfCBcInRvdWNoXCIgfCBudWxsIHtcclxuXHRsZXQgaXNNb2JpbGUgPSBmYWxzZTtcclxuXHJcblx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Ccm93c2VyX2RldGVjdGlvbl91c2luZ190aGVfdXNlcl9hZ2VudCNNb2JpbGVfVGFibGV0X29yX0Rlc2t0b3BcclxuXHRpZiAoL01vYmkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpICYmIHRvdWNoKSB7XHJcblx0XHQvLyBTb21lIEVkZ2UgZGVza3RvcCByZXR1cm4gdHJ1ZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMjA0MTcwNzQvXHJcblx0XHRjb25zdCBoYXNUb3VjaFBvaW50cyA9IHdpbmRvdy5uYXZpZ2F0b3IgJiYgXCJtYXhUb3VjaFBvaW50c1wiIGluIHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XHJcblxyXG5cdFx0Ly8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvdG91Y2hldmVudHMuanNcclxuXHRcdC8vIE9uIElFMTEgd2l0aCBJRTkgZW11bGF0aW9uIG1vZGUsICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIGlzIHJldHVybmluZyB0cnVlXHJcblx0XHRjb25zdCBoYXNUb3VjaCA9IChcIm9udG91Y2htb3ZlXCIgaW4gd2luZG93IHx8ICh3aW5kb3cuRG9jdW1lbnRUb3VjaCAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIHdpbmRvdy5Eb2N1bWVudFRvdWNoKSk7XHJcblxyXG5cdFx0aXNNb2JpbGUgPSBoYXNUb3VjaFBvaW50cyB8fCBoYXNUb3VjaDtcclxuXHR9XHJcblxyXG5cdGNvbnN0IGhhc01vdXNlID0gbW91c2UgJiYgIWlzTW9iaWxlID8gKFwib25tb3VzZW92ZXJcIiBpbiB3aW5kb3cpIDogZmFsc2U7XHJcblxyXG5cdHJldHVybiAoaGFzTW91c2UgJiYgXCJtb3VzZVwiKSB8fCAoaXNNb2JpbGUgJiYgXCJ0b3VjaFwiKSB8fCBudWxsO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLy8gY29tbW9uXHJcbmltcG9ydCBtYWluIGZyb20gXCIuL2NvbW1vbi9tYWluXCI7XHJcbmltcG9ydCBkYXRhIGZyb20gXCIuL2RhdGEvZGF0YVwiO1xyXG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29tbW9uL2NvbG9yXCI7XHJcbmltcG9ydCBpbnRlcmFjdGlvbiBmcm9tIFwiLi9jb21tb24vaW50ZXJhY3Rpb25cIjtcclxuaW1wb3J0IGxlZ2VuZCBmcm9tIFwiLi9jb21tb24vbGVnZW5kXCI7XHJcbmltcG9ydCB0aXRsZSBmcm9tIFwiLi9jb21tb24vdGl0bGVcIjtcclxuaW1wb3J0IHRvb2x0aXAgZnJvbSBcIi4vY29tbW9uL3Rvb2x0aXBcIjtcclxuXHJcbi8vIEF4aXMgYmFzZWRcclxuaW1wb3J0IGRhdGFBeGlzIGZyb20gXCIuL2RhdGEvYXhpc1wiO1xyXG5pbXBvcnQgZGF0YVNlbGVjdGlvbiBmcm9tIFwiLi9kYXRhL3NlbGVjdGlvblwiO1xyXG5pbXBvcnQgYXhpcyBmcm9tIFwiLi9heGlzL2F4aXNcIjtcclxuaW1wb3J0IGdyaWQgZnJvbSBcIi4vY29tbW9uL2dyaWRcIjtcclxuaW1wb3J0IHBvaW50IGZyb20gXCIuL2NvbW1vbi9wb2ludFwiO1xyXG5pbXBvcnQgc3ViY2hhcnQgZnJvbSBcIi4vY29tbW9uL3N1YmNoYXJ0XCI7XHJcbmltcG9ydCB6b29tIGZyb20gXCIuL2NvbW1vbi96b29tXCI7XHJcblxyXG5pbXBvcnQgYXJlYSBmcm9tIFwiLi9zaGFwZS9hcmVhXCI7XHJcbmltcG9ydCBiYXIgZnJvbSBcIi4vc2hhcGUvYmFyXCI7XHJcbmltcG9ydCBidWJibGUgZnJvbSBcIi4vc2hhcGUvYnViYmxlXCI7XHJcbmltcG9ydCBsaW5lIGZyb20gXCIuL3NoYXBlL2xpbmVcIjtcclxuaW1wb3J0IHNwbGluZSBmcm9tIFwiLi9zaGFwZS9zcGxpbmVcIjtcclxuXHJcbi8vIE5vbi1BeGlzIGJhc2VkXHJcbmltcG9ydCBkb251dCBmcm9tIFwiLi9zaGFwZS9kb251dFwiO1xyXG5pbXBvcnQgZ2F1Z2UgZnJvbSBcIi4vc2hhcGUvZ2F1Z2VcIjtcclxuaW1wb3J0IHBpZSBmcm9tIFwiLi9zaGFwZS9waWVcIjtcclxuaW1wb3J0IHJhZGFyIGZyb20gXCIuL3NoYXBlL3JhZGFyXCI7XHJcblxyXG5pbXBvcnQge21lcmdlT2JqfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0byBzZXQgb3B0aW9ucyBvbiBnZW5lcmF0aW5nIGNoYXJ0LlxyXG4gKiAtIEl0J3MgaW5zdGFudGlhdGVkIGludGVybmFsbHksIG5vdCBleHBvc2VkIGZvciBwdWJsaWMuXHJcbiAqIEBjbGFzcyBPcHRpb25zXHJcbiAqIEBzZWUge0BsaW5rIGJiLmdlbmVyYXRlfSB0byB1c2UgdGhlc2Ugb3B0aW9ucyBvbiBnZW5lcmF0aW5nIHRoZSBjaGFydFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9ucyB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRjb25zdCBhcmNTaGFwZUNvbmZpZyA9IFtkb251dCwgZ2F1Z2UsIHBpZSwgcmFkYXJdO1xyXG5cclxuXHRcdGNvbnN0IGF4aXNDb25maWcgPSBbZGF0YUF4aXMsIGRhdGFTZWxlY3Rpb24sIGF4aXMsIGdyaWQsIHBvaW50LCBzdWJjaGFydCwgem9vbV07XHJcblx0XHRjb25zdCBheGlzU2hhcGVDb25maWcgPSBbYXJlYSwgYmFyLCBidWJibGUsIGxpbmUsIHNwbGluZV07XHJcblxyXG5cdFx0Y29uc3QgY29uZmlnID0gW1xyXG5cdFx0XHRkYXRhLFxyXG5cdFx0XHRjb2xvcixcclxuXHRcdFx0aW50ZXJhY3Rpb24sXHJcblx0XHRcdGxlZ2VuZCxcclxuXHRcdFx0dGl0bGUsXHJcblx0XHRcdHRvb2x0aXAsXHJcblx0XHRcdC4uLmFyY1NoYXBlQ29uZmlnLFxyXG5cdFx0XHQuLi5heGlzQ29uZmlnLFxyXG5cdFx0XHQuLi5heGlzU2hhcGVDb25maWdcclxuXHRcdF07XHJcblxyXG5cdFx0cmV0dXJuIG1lcmdlT2JqKHsuLi5tYWlufSwgLi4uY29uZmlnKTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIHRvQXJyYXl9IGZyb20gXCIuL3V0aWxcIjtcclxuaW1wb3J0IHtEYXRhUm93fSBmcm9tIFwiLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBDb25zdGFudCBmb3IgY2FjaGUga2V5XHJcbiAqIC0gTk9URTogUHJlZml4ZWQgd2l0aCAnJCcsIHdpbGwgYmUgcmVzZXR0ZWQgd2hlbiAubG9hZCgpIGlzIGNhbGxlZFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEtFWSA9IHtcclxuXHRidWJibGVCYXNlTGVuZ3RoOiBcIiRiYXNlTGVuZ3RoXCIsXHJcblx0Y29sb3JQYXR0ZXJuOiBcIl9fY29sb3JQYXR0ZXJuX19cIixcclxuXHRkYXRhTWluTWF4OiBcIiRkYXRhTWluTWF4XCIsXHJcblx0ZGF0YVRvdGFsU3VtOiBcIiRkYXRhVG90YWxTdW1cIixcclxuXHRkYXRhVG90YWxQZXJJbmRleDogXCIkdG90YWxQZXJJbmRleFwiLFxyXG5cdGxlZ2VuZEl0ZW1UZXh0Qm94OiBcImxlZ2VuZEl0ZW1UZXh0Qm94XCIsXHJcblx0cmFkYXJQb2ludHM6IFwiJHJhZGFyUG9pbnRzXCIsXHJcblx0c2V0T3Zlck91dDogXCJzZXRPdmVyT3V0XCIsXHJcblx0Y2FsbE92ZXJPdXRGb3JUb3VjaDogXCJjYWxsT3Zlck91dEZvclRvdWNoXCIsXHJcblx0dGV4dFJlY3Q6IFwidGV4dFJlY3RcIlxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FjaGUge1xyXG5cdHByaXZhdGUgY2FjaGUgPSB7fTtcclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGNhY2hlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGtleSBDYWNoZSBrZXlcclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGJlIHN0b3JlZFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEYXRhVHlwZSBXZWF0aGVyIHRoZSBjYWNoZSBpcyBkYXRhIHR5cGVkICd7aWQ6J2RhdGEnLCBpZF9vcmc6ICdkYXRhJywgdmFsdWVzOiBbe3g6MCwgaW5kZXg6MCwuLi59LCAuLi5dfSdcclxuXHQgKiBAcmV0dXJucyB7Kn0gQWRkZWQgZGF0YSB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0YWRkKGtleTogc3RyaW5nLCB2YWx1ZSwgaXNEYXRhVHlwZSA9IGZhbHNlKSB7XHJcblx0XHR0aGlzLmNhY2hlW2tleV0gPSBpc0RhdGFUeXBlID8gdGhpcy5jbG9uZVRhcmdldCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlW2tleV07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgY2FjaGVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0ga2V5IENhY2hlIGtleVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVtb3ZlKGtleTogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdHRvQXJyYXkoa2V5KS5mb3JFYWNoKHYgPT4gZGVsZXRlIHRoaXMuY2FjaGVbdl0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGNhaGNlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IGtleSBDYWNoZSBrZXlcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGF0YVR5cGUgV2VhdGhlciB0aGUgY2FjaGUgaXMgZGF0YSB0eXBlZCAne2lkOidkYXRhJywgaWRfb3JnOiAnZGF0YScsIHZhbHVlczogW3t4OjAsIGluZGV4OjAsLi4ufSwgLi4uXX0nXHJcblx0ICogQHJldHVybnMgeyp9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXQoa2V5OiBzdHJpbmcsIGlzRGF0YVR5cGUgPSBmYWxzZSk6IGFueSB8IG51bGwge1xyXG5cdFx0aWYgKGlzRGF0YVR5cGUpIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0czogYW55W10gPSBbXTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCBpZDsgKGlkID0ga2V5W2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKGlkIGluIHRoaXMuY2FjaGUpIHtcclxuXHRcdFx0XHRcdHRhcmdldHMucHVzaCh0aGlzLmNsb25lVGFyZ2V0KHRoaXMuY2FjaGVbaWRdKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IHZhbHVlID0gdGhpcy5jYWNoZVtrZXldO1xyXG5cclxuXHRcdFx0cmV0dXJuIGlzVmFsdWUodmFsdWUpID8gdmFsdWUgOiBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVzZXQgY2FjaGVkIGRhdGFcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFsbCB0cnVlOiByZXNldCBhbGwgZGF0YSwgZmFsc2U6IHJlc2V0IG9ubHkgJyQnIHByZWZpeGVkIGtleSBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZXNldChhbGw/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Zm9yIChjb25zdCB4IGluICQkLmNhY2hlKSB7XHJcblx0XHRcdC8vIHJlc2V0IHRoZSBwcmVmaXhlZCAnJCcga2V5KHdoaWNoIGlzIGludGVybmFsIHVzZSBkYXRhKSBvbmx5LlxyXG5cdFx0XHRpZiAoYWxsIHx8IC9eXFwkLy50ZXN0KHgpKSB7XHJcblx0XHRcdFx0JCQuY2FjaGVbeF0gPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDbG9uZSBkYXRhIHRhcmdldCBvYmplY3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0IERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcclxuXHRjbG9uZVRhcmdldCh0YXJnZXQ6IERhdGFSb3cpOiBEYXRhUm93IHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGlkOiB0YXJnZXQuaWQsXHJcblx0XHRcdGlkX29yZzogdGFyZ2V0LmlkX29yZyxcclxuXHRcdFx0dmFsdWVzOiB0YXJnZXQudmFsdWVzLm1hcChkID0+ICh7eDogZC54LCB2YWx1ZTogZC52YWx1ZSwgaWQ6IGQuaWR9KSlcclxuXHRcdH07XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuL2Jyb3dzZXJcIjtcclxuaW1wb3J0IHtpc0FycmF5fSBmcm9tIFwiLi91dGlsXCI7XHJcblxyXG5jb25zdCB7c2V0VGltZW91dCwgY2xlYXJUaW1lb3V0fSA9IHdpbmRvdztcclxuXHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSByZXNpemUgcXVldWUgZnVuY3Rpb25cclxuICogQHJldHVybnMge0Z1Y250aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmVzaXplKCkge1xyXG5cdGNvbnN0IGZuOiBhbnlbXSA9IFtdO1xyXG5cdGxldCB0aW1lb3V0O1xyXG5cclxuXHRjb25zdCBjYWxsUmVzaXplRm4gPSBmdW5jdGlvbigpIHtcclxuXHRcdC8vIERlbGF5IGFsbCByZXNpemUgZnVuY3Rpb25zIGNhbGwsIHRvIHByZXZlbnQgdW5pbnRlbmRlZCBleGNlc3NpdmUgY2FsbCBmcm9tIHJlc2l6ZSBldmVudFxyXG5cdFx0Y2FsbFJlc2l6ZUZuLmNsZWFyKCk7XHJcblxyXG5cdFx0dGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRmbi5mb3JFYWNoKChmOiBGdW5jdGlvbikgPT4gZigpKTtcclxuXHRcdH0sIDIwMCk7XHJcblx0fTtcclxuXHJcblx0Y2FsbFJlc2l6ZUZuLmNsZWFyID0gKCkgPT4ge1xyXG5cdFx0aWYgKHRpbWVvdXQpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cdFx0XHR0aW1lb3V0ID0gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRjYWxsUmVzaXplRm4uYWRkID0gZiA9PiBmbi5wdXNoKGYpO1xyXG5cdGNhbGxSZXNpemVGbi5yZW1vdmUgPSBmID0+IGZuLnNwbGljZShmbi5pbmRleE9mKGYpLCAxKTtcclxuXHJcblx0cmV0dXJuIGNhbGxSZXNpemVGbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlIHRyYW5zaXRpb24gcXVldWUgZnVuY3Rpb25cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlV2FpdCgpIHtcclxuXHRsZXQgdHJhbnNpdGlvbnNUb1dhaXQ6IGFueSA9IFtdO1xyXG5cdGNvbnN0IGYgPSBmdW5jdGlvbih0LCBjYWxsYmFjaykge1xyXG5cdFx0bGV0IHRpbWVyO1xyXG5cclxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG5cdFx0ZnVuY3Rpb24gbG9vcCgpIHtcclxuXHRcdFx0bGV0IGRvbmUgPSAwO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIHQ7ICh0ID0gdHJhbnNpdGlvbnNUb1dhaXRbaV0pOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodCA9PT0gdHJ1ZSB8fCAodC5lbXB0eSAmJiB0LmVtcHR5KCkpKSB7XHJcblx0XHRcdFx0XHRkb25lKys7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR0LnRyYW5zaXRpb24oKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRkb25lKys7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xyXG5cclxuXHRcdFx0aWYgKGRvbmUgPT09IHRyYW5zaXRpb25zVG9XYWl0Lmxlbmd0aCkge1xyXG5cdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGltZXIgPSBzZXRUaW1lb3V0KGxvb3AsIDUwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxvb3AoKTtcclxuXHR9O1xyXG5cclxuXHRmLmFkZCA9IGZ1bmN0aW9uKHQpIHtcclxuXHRcdGlzQXJyYXkodCkgP1xyXG5cdFx0XHQodHJhbnNpdGlvbnNUb1dhaXQgPSB0cmFuc2l0aW9uc1RvV2FpdC5jb25jYXQodCkpIDpcclxuXHRcdFx0dHJhbnNpdGlvbnNUb1dhaXQucHVzaCh0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gZjtcclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0Y3N2UGFyc2UgYXMgZDNDc3ZQYXJzZSxcclxuXHR0c3ZQYXJzZSBhcyBkM1RzdlBhcnNlLFxyXG5cdGNzdlBhcnNlUm93cyBhcyBkM0NzdlBhcnNlUm93cyxcclxuXHR0c3ZQYXJzZVJvd3MgYXMgZDNUc3ZQYXJzZVJvd3MsXHJcbn0gZnJvbSBcImQzLWRzdlwiO1xyXG5pbXBvcnQge2lzVW5kZWZpbmVkLCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1ZhbHVlLCBub3RFbXB0eSwgaXNBcnJheSwgY2FwaXRhbGl6ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogRGF0YSBjb252ZXJ0XHJcbiAqIEBtZW1iZXJvZiBDaGFydEludGVybmFsXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ29udmVydCBkYXRhIGFjY29yZGluZyBpdHMgdHlwZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIGRhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmb3IgdXJsKFhIUikgdHlwZSBsb2FkaW5nXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnREYXRhKGFyZ3MsIGNhbGxiYWNrOiBGdW5jdGlvbik6IG9iamVjdCB7XHJcblx0XHRsZXQgZGF0YTtcclxuXHJcblx0XHRpZiAoYXJncy5iaW5kdG8pIHtcclxuXHRcdFx0ZGF0YSA9IHt9O1xyXG5cclxuXHRcdFx0W1widXJsXCIsIFwibWltZVR5cGVcIiwgXCJoZWFkZXJzXCIsIFwia2V5c1wiLCBcImpzb25cIiwgXCJrZXlzXCIsIFwicm93c1wiLCBcImNvbHVtbnNcIl1cclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGtleSA9IGBkYXRhXyR7dn1gO1xyXG5cclxuXHRcdFx0XHRcdGlmIChrZXkgaW4gYXJncykge1xyXG5cdFx0XHRcdFx0XHRkYXRhW3ZdID0gYXJnc1trZXldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGF0YSA9IGFyZ3M7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGRhdGEudXJsICYmIGNhbGxiYWNrKSB7XHJcblx0XHRcdHRoaXMuY29udmVydFVybFRvRGF0YShkYXRhLnVybCwgZGF0YS5taW1lVHlwZSwgZGF0YS5oZWFkZXJzLCBkYXRhLmtleXMsIGNhbGxiYWNrKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5qc29uKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRKc29uVG9EYXRhKGRhdGEuanNvbiwgZGF0YS5rZXlzKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5yb3dzKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRSb3dzVG9EYXRhKGRhdGEucm93cyk7XHJcblx0XHR9IGVsc2UgaWYgKGRhdGEuY29sdW1ucykge1xyXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Q29sdW1uc1RvRGF0YShkYXRhLmNvbHVtbnMpO1xyXG5cdFx0fSBlbHNlIGlmIChhcmdzLmJpbmR0bykge1xyXG5cdFx0XHR0aHJvdyBFcnJvcihcInVybCBvciBqc29uIG9yIHJvd3Mgb3IgY29sdW1ucyBpcyByZXF1aXJlZC5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzQXJyYXkoZGF0YSkgJiYgZGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IFVSTCBkYXRhXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCBSZW1vdGUgVVJMXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1pbWVUeXBlIE1JTUUgdHlwZSBzdHJpbmc6IGpzb24gfCBjc3YgfCB0c3ZcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gaGVhZGVycyBIZWFkZXIgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGtleXMgS2V5IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRvbmUgQ2FsbGJhY2sgZnVuY3Rpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnRVcmxUb0RhdGEodXJsOiBzdHJpbmcsIG1pbWVUeXBlID0gXCJjc3ZcIiwgaGVhZGVyczogb2JqZWN0LCBrZXlzOiBvYmplY3QsIGRvbmU6IEZ1bmN0aW9uKTogdm9pZCB7XHJcblx0XHRjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0XHRyZXEub3BlbihcIkdFVFwiLCB1cmwpO1xyXG5cclxuXHRcdGlmIChoZWFkZXJzKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRyZXEuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcblx0XHRcdGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG5cdFx0XHRcdGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcclxuXHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcclxuXHJcblx0XHRcdFx0XHRyZXNwb25zZSAmJiBkb25lLmNhbGwodGhpcyxcclxuXHRcdFx0XHRcdFx0dGhpc1tgY29udmVydCR7Y2FwaXRhbGl6ZShtaW1lVHlwZSl9VG9EYXRhYF0oXHJcblx0XHRcdFx0XHRcdFx0bWltZVR5cGUgPT09IFwianNvblwiID8gSlNPTi5wYXJzZShyZXNwb25zZSkgOiByZXNwb25zZSxcclxuXHRcdFx0XHRcdFx0XHRrZXlzXHJcblx0XHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7dXJsfTogU29tZXRoaW5nIHdlbnQgd3JvbmcgbG9hZGluZyFgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0cmVxLnNlbmQoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IENTVi9UU1YgZGF0YVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZXIgUGFyc2VyIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB4c3YgRGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKi9cclxuXHRjb252ZXJ0Q3N2VHN2VG9EYXRhKHBhcnNlciwgeHN2KSB7XHJcblx0XHRjb25zdCByb3dzID0gcGFyc2VyLnJvd3MoeHN2KTtcclxuXHRcdGxldCBkO1xyXG5cclxuXHRcdGlmIChyb3dzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRkID0gW3t9XTtcclxuXHJcblx0XHRcdHJvd3NbMF0uZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdFx0ZFswXVtpZF0gPSBudWxsO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGQgPSBwYXJzZXIucGFyc2UoeHN2KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0Q3N2VG9EYXRhKHhzdikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydENzdlRzdlRvRGF0YSh7XHJcblx0XHRcdHJvd3M6IGQzQ3N2UGFyc2VSb3dzLFxyXG5cdFx0XHRwYXJzZTogZDNDc3ZQYXJzZVxyXG5cdFx0fSwgeHN2KTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VHN2VG9EYXRhKHRzdikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydENzdlRzdlRvRGF0YSh7XHJcblx0XHRcdHJvd3M6IGQzVHN2UGFyc2VSb3dzLFxyXG5cdFx0XHRwYXJzZTogZDNUc3ZQYXJzZVxyXG5cdFx0fSwgdHN2KTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0SnNvblRvRGF0YShqc29uLCBrZXlzUGFyYW0pIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IHN0cmluZ1tdW10gPSBbXTtcclxuXHRcdGxldCB0YXJnZXRLZXlzOiBzdHJpbmdbXTtcclxuXHRcdGxldCBkYXRhO1xyXG5cclxuXHRcdGlmIChpc0FycmF5KGpzb24pKSB7XHJcblx0XHRcdGNvbnN0IGtleXMgPSBrZXlzUGFyYW0gfHwgY29uZmlnLmRhdGFfa2V5cztcclxuXHJcblx0XHRcdGlmIChrZXlzLngpIHtcclxuXHRcdFx0XHR0YXJnZXRLZXlzID0ga2V5cy52YWx1ZS5jb25jYXQoa2V5cy54KTtcclxuXHRcdFx0XHRjb25maWcuZGF0YV94ID0ga2V5cy54O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRhcmdldEtleXMgPSBrZXlzLnZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuZXdSb3dzLnB1c2godGFyZ2V0S2V5cyk7XHJcblxyXG5cdFx0XHRqc29uLmZvckVhY2gobyA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbmV3Um93ID0gdGFyZ2V0S2V5cy5tYXAoa2V5ID0+IHtcclxuXHRcdFx0XHRcdC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgYmVjYXVzZSB1bmRlZmluZWQgZGF0YSB3aWxsIGJlIHJlbW92ZWQgaW4gY29udmVydERhdGFUb1RhcmdldHMoKVxyXG5cdFx0XHRcdFx0bGV0IHYgPSB0aGlzLmZpbmRWYWx1ZUluSnNvbihvLCBrZXkpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh2KSkge1xyXG5cdFx0XHRcdFx0XHR2ID0gbnVsbDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gdjtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydFJvd3NUb0RhdGEobmV3Um93cyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhqc29uKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdG1wID0ganNvbltrZXldLmNvbmNhdCgpO1xyXG5cclxuXHRcdFx0XHR0bXAudW5zaGlmdChrZXkpO1xyXG5cdFx0XHRcdG5ld1Jvd3MucHVzaCh0bXApO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRDb2x1bW5zVG9EYXRhKG5ld1Jvd3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRWYWx1ZUluSnNvbihvYmplY3QsIHBhdGgpIHtcclxuXHRcdGlmIChvYmplY3RbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gb2JqZWN0W3BhdGhdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNvbnZlcnRlZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcWyhcXHcrKVxcXS9nLCBcIi4kMVwiKTsgLy8gY29udmVydCBpbmRleGVzIHRvIHByb3BlcnRpZXMgKHJlcGxhY2UgW10gd2l0aCAuKVxyXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gY29udmVydGVkUGF0aC5yZXBsYWNlKC9eXFwuLywgXCJcIikuc3BsaXQoXCIuXCIpOyAvLyBzdHJpcCBhIGxlYWRpbmcgZG90XHJcblx0XHRsZXQgdGFyZ2V0ID0gb2JqZWN0O1xyXG5cclxuXHRcdHBhdGhBcnJheS5zb21lKGsgPT4gIShcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0ICYmIGsgaW4gdGFyZ2V0ID9cclxuXHRcdFx0XHR0YXJnZXRba10gOiB1bmRlZmluZWRcclxuXHRcdCkpO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0Y29udmVydFJvd3NUb0RhdGEocm93cykge1xyXG5cdFx0Y29uc3Qga2V5cyA9IHJvd3NbMF07XHJcblx0XHRjb25zdCBuZXdSb3dzOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdHJvd3MuZm9yRWFjaCgocm93LCBpKSA9PiB7XHJcblx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IG5ld1JvdyA9IHt9O1xyXG5cclxuXHRcdFx0XHRyb3cuZm9yRWFjaCgodiwgaikgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHYpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgU291cmNlIGRhdGEgaXMgbWlzc2luZyBhIGNvbXBvbmVudCBhdCAoJHtpfSwgJHtqfSkhYCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bmV3Um93W2tleXNbal1dID0gdjtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBuZXdSb3dzO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRDb2x1bW5zVG9EYXRhKGNvbHVtbnMpIHtcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IGFueVtdID0gW107XHJcblxyXG5cdFx0Y29sdW1ucy5mb3JFYWNoKChjb2wsIGkpID0+IHtcclxuXHRcdFx0Y29uc3Qga2V5ID0gY29sWzBdO1xyXG5cclxuXHRcdFx0Y29sLmZvckVhY2goKHYsIGopID0+IHtcclxuXHRcdFx0XHRpZiAoaiA+IDApIHtcclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZChuZXdSb3dzW2ogLSAxXSkpIHtcclxuXHRcdFx0XHRcdFx0bmV3Um93c1tqIC0gMV0gPSB7fTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodikpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0ICgke2l9LCAke2p9KSFgKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRuZXdSb3dzW2ogLSAxXVtrZXldID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XHJcblx0fSxcclxuXHJcblx0Y29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgYXBwZW5kWHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtheGlzLCBjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0bGV0IGlzQ2F0ZWdvcml6ZWQgPSBmYWxzZTtcclxuXHRcdGxldCBpc1RpbWVTZXJpZXMgPSBmYWxzZTtcclxuXHRcdGxldCBpc0N1c3RvbVggPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoYXhpcykge1xyXG5cdFx0XHRpc0NhdGVnb3JpemVkID0gYXhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRcdGlzVGltZVNlcmllcyA9IGF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRcdGlzQ3VzdG9tWCA9IGF4aXMuaXNDdXN0b21YKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdIHx8IHt9KTtcclxuXHRcdGNvbnN0IGlkcyA9IGRhdGFLZXlzLmxlbmd0aCA/IGRhdGFLZXlzLmZpbHRlcigkJC5pc05vdFgsICQkKSA6IFtdO1xyXG5cdFx0Y29uc3QgeHMgPSBkYXRhS2V5cy5sZW5ndGggPyBkYXRhS2V5cy5maWx0ZXIoJCQuaXNYLCAkJCkgOiBbXTtcclxuXHJcblx0XHRsZXQgeHNEYXRhO1xyXG5cclxuXHRcdC8vIHNhdmUgeCBmb3IgdXBkYXRlIGRhdGEgYnkgbG9hZCB3aGVuIGN1c3RvbSB4IGFuZCBiYi54IEFQSVxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCB4S2V5ID0gdGhpcy5nZXRYS2V5KGlkKTtcclxuXHJcblx0XHRcdGlmIChpc0N1c3RvbVggfHwgaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0Ly8gaWYgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YVxyXG5cdFx0XHRcdGlmICh4cy5pbmRleE9mKHhLZXkpID49IDApIHtcclxuXHRcdFx0XHRcdHhzRGF0YSA9ICgoYXBwZW5kWHMgJiYgJCQuZGF0YS54c1tpZF0pIHx8IFtdKVxyXG5cdFx0XHRcdFx0XHQuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEubWFwKGQgPT4gZFt4S2V5XSlcclxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoaXNWYWx1ZSlcclxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKHJhd1gsIGkpID0+ICQkLmdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaSkpXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjb25maWcuZGF0YV94KSB7XHJcblx0XHRcdFx0XHQvLyBpZiBub3QgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YSwgZmluZCBmcm9tIHByZWxvYWRlZCBkYXRhIG9mIG90aGVyIGlkJ3MgeFxyXG5cdFx0XHRcdFx0eHNEYXRhID0gdGhpcy5nZXRPdGhlclRhcmdldFhzKCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChub3RFbXB0eShjb25maWcuZGF0YV94cykpIHtcclxuXHRcdFx0XHRcdC8vIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhLCBmaW5kIGZyb20gcHJlbG9hZGVkIGRhdGFcclxuXHRcdFx0XHRcdHhzRGF0YSA9ICQkLmdldFhWYWx1ZXNPZlhLZXkoeEtleSwgJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gTUVNTzogaWYgbm8geCBpbmNsdWRlZCwgdXNlIHNhbWUgeCBvZiBjdXJyZW50IHdpbGwgYmUgdXNlZFxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHhzRGF0YSA9IGRhdGEubWFwKChkLCBpKSA9PiBpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eHNEYXRhICYmICh0aGlzLmRhdGEueHNbaWRdID0geHNEYXRhKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGNoZWNrIHggaXMgZGVmaW5lZFxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRpZiAoIXRoaXMuZGF0YS54c1tpZF0pIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHggaXMgbm90IGRlZmluZWQgZm9yIGlkID0gXCIke2lkfVwiLmApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBjb252ZXJ0IHRvIHRhcmdldFxyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IGlkcy5tYXAoKGlkLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRjb25zdCBjb252ZXJ0ZWRJZCA9IGNvbmZpZy5kYXRhX2lkQ29udmVydGVyLmJpbmQoJCQuYXBpKShpZCk7XHJcblx0XHRcdGNvbnN0IHhLZXkgPSAkJC5nZXRYS2V5KGlkKTtcclxuXHRcdFx0Y29uc3QgaXNDYXRlZ29yeSA9IGlzQ3VzdG9tWCAmJiBpc0NhdGVnb3JpemVkO1xyXG5cdFx0XHRjb25zdCBoYXNDYXRlZ29yeSA9IGlzQ2F0ZWdvcnkgJiYgZGF0YS5tYXAodiA9PiB2LngpXHJcblx0XHRcdFx0LmV2ZXJ5KHYgPT4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodikgPiAtMSk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGlkOiBjb252ZXJ0ZWRJZCxcclxuXHRcdFx0XHRpZF9vcmc6IGlkLFxyXG5cdFx0XHRcdHZhbHVlczogZGF0YS5tYXAoKGQsIGkpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHJhd1ggPSBkW3hLZXldO1xyXG5cdFx0XHRcdFx0bGV0IHZhbHVlID0gZFtpZF07XHJcblx0XHRcdFx0XHRsZXQgeDtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgIWlzT2JqZWN0KHZhbHVlKSA/XHJcblx0XHRcdFx0XHRcdCt2YWx1ZSA6IChpc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IG51bGwpO1xyXG5cclxuXHRcdFx0XHRcdC8vIHVzZSB4IGFzIGNhdGVnb3JpZXMgaWYgY3VzdG9tIHggYW5kIGNhdGVnb3JpemVkXHJcblx0XHRcdFx0XHRpZiAoKGlzQ2F0ZWdvcnkgfHwgc3RhdGUuaGFzUmFkYXIpICYmIGluZGV4ID09PSAwICYmICFpc1VuZGVmaW5lZChyYXdYKSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIWhhc0NhdGVnb3J5ICYmIGluZGV4ID09PSAwICYmIGkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMgPSBbXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0eCA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHJhd1gpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHggPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0eCA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XHJcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLnB1c2gocmF3WCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHggPSAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIG1hcmsgYXMgeCA9IHVuZGVmaW5lZCBpZiB2YWx1ZSBpcyB1bmRlZmluZWQgYW5kIGZpbHRlciB0byByZW1vdmUgYWZ0ZXIgbWFwcGVkXHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodmFsdWUpIHx8ICQkLmRhdGEueHNbaWRdLmxlbmd0aCA8PSBpKSB7XHJcblx0XHRcdFx0XHRcdHggPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHt4LCB2YWx1ZSwgaWQ6IGNvbnZlcnRlZElkfTtcclxuXHRcdFx0XHR9KS5maWx0ZXIodiA9PiBpc0RlZmluZWQodi54KSlcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGZpbmlzaCB0YXJnZXRzXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdC8vIHNvcnQgdmFsdWVzIGJ5IGl0cyB4XHJcblx0XHRcdGlmIChjb25maWcuZGF0YV94U29ydCkge1xyXG5cdFx0XHRcdHQudmFsdWVzID0gdC52YWx1ZXMuc29ydCgodjEsIHYyKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB4MSA9IHYxLnggfHwgdjEueCA9PT0gMCA/IHYxLnggOiBJbmZpbml0eTtcclxuXHRcdFx0XHRcdGNvbnN0IHgyID0gdjIueCB8fCB2Mi54ID09PSAwID8gdjIueCA6IEluZmluaXR5O1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB4MSAtIHgyO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBpbmRleGluZyBlYWNoIHZhbHVlXHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHYsIGkpID0+ICh2LmluZGV4ID0gaSkpO1xyXG5cclxuXHRcdFx0Ly8gdGhpcyBuZWVkcyB0byBiZSBzb3J0ZWQgYmVjYXVzZSBpdHMgaW5kZXggYW5kIHZhbHVlLmluZGV4IGlzIGlkZW50aWNhbFxyXG5cdFx0XHQkJC5kYXRhLnhzW3QuaWRdLnNvcnQoKHYxLCB2MikgPT4gdjEgLSB2Mik7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBjYWNoZSBpbmZvcm1hdGlvbiBhYm91dCB2YWx1ZXNcclxuXHRcdHN0YXRlLmhhc05lZ2F0aXZlVmFsdWUgPSAkJC5oYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xyXG5cdFx0c3RhdGUuaGFzUG9zaXRpdmVWYWx1ZSA9ICQkLmhhc1Bvc2l0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gc2V0IHRhcmdldCB0eXBlc1xyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX3R5cGUpIHtcclxuXHRcdFx0JCQuc2V0VGFyZ2V0VHlwZSgkJC5tYXBUb0lkcyh0YXJnZXRzKVxyXG5cdFx0XHRcdC5maWx0ZXIoaWQgPT4gIShpZCBpbiBjb25maWcuZGF0YV90eXBlcykpLCBjb25maWcuZGF0YV90eXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBjYWNoZSBhcyBvcmlnaW5hbCBpZCBrZXllZFxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4gJCQuY2FjaGUuYWRkKGQuaWRfb3JnLCBkLCB0cnVlKSk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtLRVl9IGZyb20gXCIuLi8uLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IHtcclxuXHRnZXRVbmlxdWUsXHJcblx0aGFzVmFsdWUsXHJcblx0aXNBcnJheSxcclxuXHRpc2Jvb2xlYW4sXHJcblx0aXNEZWZpbmVkLFxyXG5cdGlzRnVuY3Rpb24sXHJcblx0aXNOdW1iZXIsXHJcblx0aXNPYmplY3QsXHJcblx0aXNPYmplY3RUeXBlLFxyXG5cdGlzU3RyaW5nLFxyXG5cdGlzVW5kZWZpbmVkLFxyXG5cdGlzVmFsdWUsXHJcblx0bWVyZ2VBcnJheSxcclxuXHRub3RFbXB0eSxcclxuXHRwYXJzZURhdGUsXHJcblx0c29ydFZhbHVlXHJcbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aXNYKGtleSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFLZXkgPSBjb25maWcuZGF0YV94ICYmIGtleSA9PT0gY29uZmlnLmRhdGFfeDtcclxuXHRcdGNvbnN0IGV4aXN0VmFsdWUgPSBub3RFbXB0eShjb25maWcuZGF0YV94cykgJiYgaGFzVmFsdWUoY29uZmlnLmRhdGFfeHMsIGtleSk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGFLZXkgfHwgZXhpc3RWYWx1ZTtcclxuXHR9LFxyXG5cclxuXHRpc05vdFgoa2V5KTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gIXRoaXMuaXNYKGtleSk7XHJcblx0fSxcclxuXHJcblx0aXNTdGFja05vcm1hbGl6ZWQoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICEhKGNvbmZpZy5kYXRhX3N0YWNrX25vcm1hbGl6ZSAmJiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoKTtcclxuXHR9LFxyXG5cclxuXHRpc0dyb3VwZWQoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5kYXRhX2dyb3Vwc1xyXG5cdFx0XHQubWFwKHYgPT4gdi5pbmRleE9mKGlkKSA+PSAwKVswXTtcclxuXHR9LFxyXG5cclxuXHRnZXRYS2V5KGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuZGF0YV94ID9cclxuXHRcdFx0Y29uZmlnLmRhdGFfeCA6IChub3RFbXB0eShjb25maWcuZGF0YV94cykgPyBjb25maWcuZGF0YV94c1tpZF0gOiBudWxsKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYVmFsdWVzT2ZYS2V5KGtleSwgdGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaWRzID0gdGFyZ2V0cyAmJiBub3RFbXB0eSh0YXJnZXRzKSA/ICQkLm1hcFRvSWRzKHRhcmdldHMpIDogW107XHJcblx0XHRsZXQgeFZhbHVlcztcclxuXHJcblx0XHRpZHMuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGlmICgkJC5nZXRYS2V5KGlkKSA9PT0ga2V5KSB7XHJcblx0XHRcdFx0eFZhbHVlcyA9ICQkLmRhdGEueHNbaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4geFZhbHVlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgaW5kZXggbnVtYmVyIGJhc2VkIG9uIGdpdmVuIHggQXhpcyB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7RGF0ZXxudW1iZXJ8c3RyaW5nfSB4IHggQXhpcyB0byBiZSBjb21wYXJlZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGJhc2VkWCB4IEF4aXMgbGlzdCB0byBiZSBiYXNlZCBvblxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IGluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kZXhCeVgoeCwgYmFzZWRYOiAoc3RyaW5nfERhdGUpW10pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBiYXNlZFggP1xyXG5cdFx0XHRiYXNlZFguaW5kZXhPZihpc1N0cmluZyh4KSA/IHggOiAreCkgOlxyXG5cdFx0XHQoJCQuZmlsdGVyQnlYKCQkLmRhdGEudGFyZ2V0cywgeClbMF0gfHwge2luZGV4OiBudWxsfSkuaW5kZXg7XHJcblx0fSxcclxuXHJcblx0Z2V0WFZhbHVlKGlkOiBzdHJpbmcsIGk6IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGlkIGluICQkLmRhdGEueHMgJiZcclxuXHRcdFx0JCQuZGF0YS54c1tpZF0gJiZcclxuXHRcdFx0aXNWYWx1ZSgkJC5kYXRhLnhzW2lkXVtpXSkgPyAkJC5kYXRhLnhzW2lkXVtpXSA6IGk7XHJcblx0fSxcclxuXHJcblx0Z2V0T3RoZXJUYXJnZXRYcygpOiBzdHJpbmcgfCBudWxsIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlkc0ZvclggPSBPYmplY3Qua2V5cygkJC5kYXRhLnhzKTtcclxuXHJcblx0XHRyZXR1cm4gaWRzRm9yWC5sZW5ndGggPyAkJC5kYXRhLnhzW2lkc0ZvclhbMF1dIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHRnZXRPdGhlclRhcmdldFgoaW5kZXg6IG51bWJlcik6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0Y29uc3QgeHMgPSB0aGlzLmdldE90aGVyVGFyZ2V0WHMoKTtcclxuXHJcblx0XHRyZXR1cm4geHMgJiYgaW5kZXggPCB4cy5sZW5ndGggPyB4c1tpbmRleF0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGFkZFhzKHhzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHhzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfeHNbaWRdID0geHNbaWRdO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0aXNNdWx0aXBsZVgoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgfHxcclxuXHRcdFx0IXRoaXMuY29uZmlnLmRhdGFfeFNvcnQgfHxcclxuXHRcdFx0dGhpcy5oYXNUeXBlKFwiYnViYmxlXCIpIHx8XHJcblx0XHRcdHRoaXMuaGFzVHlwZShcInNjYXR0ZXJcIik7XHJcblx0fSxcclxuXHJcblx0YWRkTmFtZShkYXRhKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IG5hbWU7XHJcblxyXG5cdFx0aWYgKGRhdGEpIHtcclxuXHRcdFx0bmFtZSA9IGNvbmZpZy5kYXRhX25hbWVzW2RhdGEuaWRdO1xyXG5cdFx0XHRkYXRhLm5hbWUgPSBuYW1lICE9PSB1bmRlZmluZWQgPyBuYW1lIDogZGF0YS5pZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYWxsIHZhbHVlcyBvbiBnaXZlbiBpbmRleFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZmlsdGVyTnVsbCBGaWx0ZXIgbnVsbGlzaCB2YWx1ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXg6IG51bWJlciwgZmlsdGVyTnVsbCA9IGZhbHNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0bGV0IHZhbHVlID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpXHJcblx0XHRcdC5tYXAodCA9PiAkJC5hZGROYW1lKCQkLmdldFZhbHVlT25JbmRleCh0LnZhbHVlcywgaW5kZXgpKSk7XHJcblxyXG5cdFx0aWYgKGZpbHRlck51bGwpIHtcclxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5maWx0ZXIodiA9PiBpc1ZhbHVlKHYudmFsdWUpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVPbkluZGV4KHZhbHVlcywgaW5kZXg6IG51bWJlcikge1xyXG5cdFx0Y29uc3QgdmFsdWVPbkluZGV4ID0gdmFsdWVzLmZpbHRlcih2ID0+IHYuaW5kZXggPT09IGluZGV4KTtcclxuXHJcblx0XHRyZXR1cm4gdmFsdWVPbkluZGV4Lmxlbmd0aCA/IHZhbHVlT25JbmRleFswXSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0WCh0YXJnZXRzLCB4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0di54ID0gJCQuZ2VuZXJhdGVUYXJnZXRYKHhbaV0sIHQuaWQsIGkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmRhdGEueHNbdC5pZF0gPSB4O1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0WHModGFyZ2V0cywgeHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHhzW3QuaWRdICYmICQkLnVwZGF0ZVRhcmdldFgoW3RdLCB4c1t0LmlkXSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQ6IHN0cmluZywgaW5kZXg6IG51bWJlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXN9ID0gJCQ7XHJcblx0XHRsZXQgeCA9IGF4aXMgJiYgYXhpcy5pc0NhdGVnb3JpemVkKCkgPyBpbmRleCA6IChyYXdYIHx8IGluZGV4KTtcclxuXHJcblx0XHRpZiAoYXhpcyAmJiBheGlzLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0eCA9IHJhd1ggPyBmbihyYXdYKSA6IGZuKCQkLmdldFhWYWx1ZShpZCwgaW5kZXgpKTtcclxuXHRcdH0gZWxzZSBpZiAoYXhpcyAmJiBheGlzLmlzQ3VzdG9tWCgpICYmICFheGlzLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHR4ID0gaXNWYWx1ZShyYXdYKSA/ICtyYXdYIDogJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWHModmFsdWVzKTogdm9pZCB7XHJcblx0XHRpZiAodmFsdWVzLmxlbmd0aCkge1xyXG5cdFx0XHR0aGlzLmF4aXMueHMgPSB2YWx1ZXMubWFwKHYgPT4gdi54KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRQcmV2WChpOiBudW1iZXIpOiBudW1iZXJbXSB8IG51bGwge1xyXG5cdFx0Y29uc3QgeCA9IHRoaXMuYXhpcy54c1tpIC0gMV07XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldE5leHRYKGk6IG51bWJlcik6IG51bWJlcltdIHwgbnVsbCB7XHJcblx0XHRjb25zdCB4ID0gdGhpcy5heGlzLnhzW2kgKyAxXTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHgpID8geCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGJhc2UgdmFsdWUgaXNBcmVhUmFuZ2VUeXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZVZhbHVlKGRhdGEpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXN9ID0gJCQuc3RhdGU7XHJcblx0XHRsZXQge3ZhbHVlfSA9IGRhdGE7XHJcblxyXG5cdFx0Ly8gSW4gY2FzZSBvZiBhcmVhLXJhbmdlLCBkYXRhIGlzIGdpdmVuIGFzOiBbbG93LCBtaWQsIGhpZ2hdIG9yIHtsb3csIG1pZCwgaGlnaH1cclxuXHRcdC8vIHdpbGwgdGFrZSB0aGUgJ21pZCcgYXMgdGhlIGJhc2UgdmFsdWVcclxuXHRcdGlmICh2YWx1ZSAmJiBoYXNBeGlzKSB7XHJcblx0XHRcdGlmICgkJC5pc0FyZWFSYW5nZVR5cGUoZGF0YSkpIHtcclxuXHRcdFx0XHR2YWx1ZSA9ICQkLmdldEFyZWFSYW5nZURhdGEoZGF0YSwgXCJtaWRcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVaVHlwZShkYXRhKSkge1xyXG5cdFx0XHRcdHZhbHVlID0gJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBtaW4vbWF4IHZhbHVlIGZyb20gdGhlIGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgYXJyYXkgZGF0YSB0byBiZSBldmFsdWF0ZWRcclxuXHQgKiBAcmV0dXJucyB7e21pbjoge251bWJlcn0sIG1heDoge251bWJlcn19fVxyXG5cdCAqL1xyXG5cdGdldE1pbk1heFZhbHVlKGRhdGEpOiB7bWluOiBudW1iZXIsIG1heDogbnVtYmVyfSB7XHJcblx0XHRjb25zdCBnZXRCYXNlVmFsdWUgPSB0aGlzLmdldEJhc2VWYWx1ZS5iaW5kKHRoaXMpO1xyXG5cdFx0bGV0IG1pbjtcclxuXHRcdGxldCBtYXg7XHJcblxyXG5cdFx0KGRhdGEgfHwgdGhpcy5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKVxyXG5cdFx0XHQuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdi5tYXAoZ2V0QmFzZVZhbHVlKS5maWx0ZXIoaXNOdW1iZXIpO1xyXG5cclxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihpID8gbWluIDogSW5maW5pdHksIC4uLnZhbHVlKTtcclxuXHRcdFx0XHRtYXggPSBNYXRoLm1heChpID8gbWF4IDogLUluZmluaXR5LCAuLi52YWx1ZSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB7bWluLCBtYXh9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbWluL21heCBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJucyB7e21pbjogQXJyYXksIG1heDogQXJyYXl9fVxyXG5cdCAqL1xyXG5cdGdldE1pbk1heERhdGEoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IEtFWS5kYXRhTWluTWF4O1xyXG5cdFx0bGV0IG1pbk1heERhdGEgPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghbWluTWF4RGF0YSkge1xyXG5cdFx0XHRjb25zdCBkYXRhID0gJCQuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKTtcclxuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4VmFsdWUoZGF0YSk7XHJcblxyXG5cdFx0XHRsZXQgbWluID0gW107XHJcblx0XHRcdGxldCBtYXggPSBbXTtcclxuXHJcblx0XHRcdGRhdGEuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCBtaW5EYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWluKTtcclxuXHRcdFx0XHRjb25zdCBtYXhEYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWF4KTtcclxuXHJcblx0XHRcdFx0aWYgKG1pbkRhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRtaW4gPSBtaW4uY29uY2F0KG1pbkRhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKG1heERhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRtYXggPSBtYXguY29uY2F0KG1heERhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGNhY2hlZCBkYXRhXHJcblx0XHRcdCQkLmNhY2hlLmFkZChjYWNoZUtleSwgbWluTWF4RGF0YSA9IHttaW4sIG1heH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtaW5NYXhEYXRhO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBzdW0gb2YgZGF0YSBwZXIgaW5kZXhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKi9cclxuXHRnZXRUb3RhbFBlckluZGV4KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBLRVkuZGF0YVRvdGFsUGVySW5kZXg7XHJcblx0XHRsZXQgc3VtID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAhc3VtKSB7XHJcblx0XHRcdHN1bSA9IFtdO1xyXG5cclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2gocm93ID0+IHtcclxuXHRcdFx0XHRyb3cudmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRcdGlmICghc3VtW2ldKSB7XHJcblx0XHRcdFx0XHRcdHN1bVtpXSA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c3VtW2ldICs9IGlzTnVtYmVyKHYudmFsdWUpID8gdi52YWx1ZSA6IDA7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdW07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRvdGFsIGRhdGEgc3VtXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBzdWJ0cmFjdEhpZGRlbiBTdWJ0cmFjdCBoaWRkZW4gZGF0YSBmcm9tIHRvdGFsXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvdGFsRGF0YVN1bShzdWJ0cmFjdEhpZGRlbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBLRVkuZGF0YVRvdGFsU3VtO1xyXG5cdFx0bGV0IHRvdGFsID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIWlzTnVtYmVyKHRvdGFsKSkge1xyXG5cdFx0XHRjb25zdCBzdW0gPSBtZXJnZUFycmF5KCQkLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IHYudmFsdWUpXHJcblx0XHRcdFx0LnJlZHVjZSgocCwgYykgPT4gcCArIGMpO1xyXG5cclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCB0b3RhbCA9IHN1bSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN1YnRyYWN0SGlkZGVuKSB7XHJcblx0XHRcdHRvdGFsIC09ICQkLmdldEhpZGRlblRvdGFsRGF0YVN1bSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0b3RhbDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdG90YWwgaGlkZGVuIGRhdGEgc3VtXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEhpZGRlblRvdGFsRGF0YVN1bSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHthcGksIHN0YXRlOiB7aGlkZGVuVGFyZ2V0SWRzfX0gPSAkJDtcclxuXHRcdGxldCB0b3RhbCA9IDA7XHJcblxyXG5cdFx0aWYgKGhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0dG90YWwgPSBhcGkuZGF0YS52YWx1ZXMuYmluZChhcGkpKGhpZGRlblRhcmdldElkcylcclxuXHRcdFx0XHQucmVkdWNlKChwLCBjKSA9PiBwICsgYyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRvdGFsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBmaWx0ZXJlZCBkYXRhIGJ5IHZhbHVlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGEgRGF0YVxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byBiZSBmaWx0ZXJlZFxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gZmlsdGVyZWQgYXJyYXkgZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RmlsdGVyZWREYXRhQnlWYWx1ZShkYXRhLCB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKHQgPT4gdGhpcy5nZXRCYXNlVmFsdWUodCkgPT09IHZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgdGhlIGRhdGFcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBtYXggZGF0YSBsZW5ndGhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldE1heERhdGFDb3VudCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLmxlbmd0aCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1heERhdGFDb3VudFRhcmdldCgpIHtcclxuXHRcdGxldCB0YXJnZXQgPSB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKSB8fCBbXTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKGxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0Lm1hcCh0ID0+IHQudmFsdWVzKVxyXG5cdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2LngpO1xyXG5cclxuXHRcdFx0dGFyZ2V0ID0gc29ydFZhbHVlKGdldFVuaXF1ZSh0YXJnZXQpKVxyXG5cdFx0XHRcdC5tYXAoKHgsIGluZGV4KSA9PiAoe3gsIGluZGV4fSkpO1xyXG5cdFx0fSBlbHNlIGlmIChsZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0WzBdLnZhbHVlcztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvSWRzKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0YXJnZXRzLm1hcChkID0+IGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvVGFyZ2V0SWRzKGlkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBpZHMgPyAoaXNBcnJheShpZHMpID8gaWRzLmNvbmNhdCgpIDogW2lkc10pIDogJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHR9LFxyXG5cclxuXHRoYXNUYXJnZXQodGFyZ2V0cywgaWQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyk7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHZhbDsgKHZhbCA9IGlkc1tpXSk7IGkrKykge1xyXG5cdFx0XHRpZiAodmFsID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGlzVGFyZ2V0VG9TaG93KHRhcmdldElkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGlzTGVnZW5kVG9TaG93KHRhcmdldElkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlclRhcmdldHNUb1Nob3codGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAodGFyZ2V0cyB8fCAkJC5kYXRhLnRhcmdldHMpLmZpbHRlcih0ID0+ICQkLmlzVGFyZ2V0VG9TaG93KHQuaWQpKTtcclxuXHR9LFxyXG5cclxuXHRtYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpc30gPSAkJDtcclxuXHRcdGxldCB4czogYW55W10gPSBbXTtcclxuXHJcblx0XHRpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR4cyA9IGdldFVuaXF1ZShcclxuXHRcdFx0XHRtZXJnZUFycmF5KHRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMubWFwKHYgPT4gK3YueCkpKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0eHMgPSBheGlzICYmIGF4aXMuaXNUaW1lU2VyaWVzKCkgPyB4cy5tYXAoeCA9PiBuZXcgRGF0ZSgreCkpIDogeHMubWFwKHggPT4gK3gpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzb3J0VmFsdWUoeHMpO1xyXG5cdH0sXHJcblxyXG5cdGFkZEhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUuaGlkZGVuVGFyZ2V0SWRzID0gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuY29uY2F0KHRhcmdldElkcyk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlSGlkZGVuVGFyZ2V0SWRzKHRhcmdldElkcyk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlblRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0fSxcclxuXHJcblx0YWRkSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcyk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcy5jb25jYXQodGFyZ2V0SWRzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcyA9IHRoaXMuc3RhdGUuaGlkZGVuTGVnZW5kSWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXN9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCB5cyA9IHt9O1xyXG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xyXG5cdFx0Y29uc3QgeHMgPSBpc011bHRpcGxlWCA/ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpXHJcblx0XHRcdC5tYXAodiA9PiAoaXNTdHJpbmcodikgPyB2IDogK3YpKSA6IG51bGw7XHJcblxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRjb25zdCBkYXRhOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYudmFsdWU7XHJcblxyXG5cdFx0XHRcdGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLnZhbHVlKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiBcImhpZ2hcIiBpbiB2YWx1ZSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLk9iamVjdC52YWx1ZXModmFsdWUpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlWlR5cGUodikpIHtcclxuXHRcdFx0XHRcdGRhdGEucHVzaChoYXNBeGlzICYmICQkLmdldEJ1YmJsZVpEYXRhKHZhbHVlLCBcInlcIikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcclxuXHRcdFx0XHRcdFx0ZGF0YVskJC5nZXRJbmRleEJ5WCh2LngsIHhzKV0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGRhdGEucHVzaCh2YWx1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHlzW3QuaWRdID0gZGF0YTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB5cztcclxuXHR9LFxyXG5cclxuXHRjaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIGNoZWNrZXI6IEZ1bmN0aW9uKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBpZHMgPSBPYmplY3Qua2V5cyh0YXJnZXRzKTtcclxuXHRcdGxldCB2YWx1ZXM7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFsdWVzID0gdGFyZ2V0c1tpZHNbaV1dLnZhbHVlcztcclxuXHJcblx0XHRcdGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0aWYgKGNoZWNrZXIodmFsdWVzW2pdLnZhbHVlKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGhhc011bHRpVGFyZ2V0cygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKS5sZW5ndGggPiAxO1xyXG5cdH0sXHJcblxyXG5cdGhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2hlY2tWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzLCB2ID0+IHYgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRoYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgdiA9PiB2ID4gMCk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrT3JkZXIodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy5kYXRhX29yZGVyO1xyXG5cclxuXHRcdHJldHVybiBpc1N0cmluZyhvcmRlcikgJiYgb3JkZXIudG9Mb3dlckNhc2UoKSA9PT0gdHlwZTtcclxuXHR9LFxyXG5cclxuXHRpc09yZGVyRGVzYygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLl9jaGVja09yZGVyKFwiZGVzY1wiKTtcclxuXHR9LFxyXG5cclxuXHRpc09yZGVyQXNjKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrT3JkZXIoXCJhc2NcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCB0YXJnZXRzIGRhdGFcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRzVmFsdWUgVGFyZ2V0IHZhbHVlXHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b3JkZXJUYXJnZXRzKHRhcmdldHNWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSBbLi4udGFyZ2V0c1ZhbHVlXTtcclxuXHRcdGNvbnN0IG9yZGVyQXNjID0gJCQuaXNPcmRlckFzYygpO1xyXG5cdFx0Y29uc3Qgb3JkZXJEZXNjID0gJCQuaXNPcmRlckRlc2MoKTtcclxuXHJcblx0XHRpZiAob3JkZXJBc2MgfHwgb3JkZXJEZXNjKSB7XHJcblx0XHRcdHRhcmdldHMuc29ydCgodDEsIHQyKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgcmVkdWNlciA9IChwLCBjKSA9PiBwICsgTWF0aC5hYnMoYy52YWx1ZSk7XHJcblx0XHRcdFx0Y29uc3QgdDFTdW0gPSB0MS52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApO1xyXG5cdFx0XHRcdGNvbnN0IHQyU3VtID0gdDIudmFsdWVzLnJlZHVjZShyZWR1Y2VyLCAwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9yZGVyQXNjID8gdDJTdW0gLSB0MVN1bSA6IHQxU3VtIC0gdDJTdW07XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5kYXRhX29yZGVyKSkge1xyXG5cdFx0XHR0YXJnZXRzLnNvcnQoY29uZmlnLmRhdGFfb3JkZXIuYmluZCgkJC5hcGkpKTtcclxuXHRcdH0gLy8gVE9ETzogYWNjZXB0IG5hbWUgYXJyYXkgZm9yIG9yZGVyXHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0fSxcclxuXHJcblx0ZmlsdGVyQnlYKHRhcmdldHMsIHgpIHtcclxuXHRcdHJldHVybiBtZXJnZUFycmF5KHRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKS5maWx0ZXIodiA9PiB2LnggLSB4ID09PSAwKTtcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJSZW1vdmVOdWxsKGRhdGEpIHtcclxuXHRcdHJldHVybiBkYXRhLmZpbHRlcihkID0+IGlzVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoZCkpKTtcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJCeVhEb21haW4odGFyZ2V0cywgeERvbWFpbikge1xyXG5cdFx0cmV0dXJuIHRhcmdldHMubWFwKHQgPT4gKHtcclxuXHRcdFx0aWQ6IHQuaWQsXHJcblx0XHRcdGlkX29yZzogdC5pZF9vcmcsXHJcblx0XHRcdHZhbHVlczogdC52YWx1ZXMuZmlsdGVyKHYgPT4geERvbWFpblswXSA8PSB2LnggJiYgdi54IDw9IHhEb21haW5bMV0pXHJcblx0XHR9KSk7XHJcblx0fSxcclxuXHJcblx0aGFzRGF0YUxhYmVsKCkge1xyXG5cdFx0Y29uc3QgZGF0YUxhYmVscyA9IHRoaXMuY29uZmlnLmRhdGFfbGFiZWxzO1xyXG5cclxuXHRcdHJldHVybiAoaXNib29sZWFuKGRhdGFMYWJlbHMpICYmIGRhdGFMYWJlbHMpIHx8XHJcblx0XHRcdChpc09iamVjdFR5cGUoZGF0YUxhYmVscykgJiYgbm90RW1wdHkoZGF0YUxhYmVscykpO1xyXG5cdH0sXHJcblxyXG5cdGdldERhdGFMYWJlbExlbmd0aChtaW4sIG1heCwga2V5KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBsZW5ndGhzID0gWzAsIDBdO1xyXG5cdFx0Y29uc3QgcGFkZGluZ0NvZWYgPSAxLjM7XHJcblxyXG5cdFx0JCQuJGVsLmNoYXJ0LnNlbGVjdChcInN2Z1wiKS5zZWxlY3RBbGwoXCIuZHVtbXlcIilcclxuXHRcdFx0LmRhdGEoW21pbiwgbWF4XSlcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LnRleHQoZCA9PiAkJC5kYXRhTGFiZWxGb3JtYXQoZC5pZCkoZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRsZW5ndGhzW2ldID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtrZXldICogcGFkZGluZ0NvZWY7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRyZXR1cm4gbGVuZ3RocztcclxuXHR9LFxyXG5cclxuXHRpc05vbmVBcmMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRpc0FyYyhkKSB7XHJcblx0XHRyZXR1cm4gXCJkYXRhXCIgaW4gZCAmJiB0aGlzLmhhc1RhcmdldCh0aGlzLmRhdGEudGFyZ2V0cywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRmaW5kU2FtZVhPZlZhbHVlcyh2YWx1ZXMsIGluZGV4KSB7XHJcblx0XHRjb25zdCB0YXJnZXRYID0gdmFsdWVzW2luZGV4XS54O1xyXG5cdFx0Y29uc3Qgc2FtZXM6IGFueVtdID0gW107XHJcblx0XHRsZXQgaTtcclxuXHJcblx0XHRmb3IgKGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcblx0XHRcdGlmICh0YXJnZXRYICE9PSB2YWx1ZXNbaV0ueCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzYW1lcy5wdXNoKHZhbHVlc1tpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpID0gaW5kZXg7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0aWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNhbWVzLnB1c2godmFsdWVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2FtZXM7XHJcblx0fSxcclxuXHJcblx0ZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyh0YXJnZXRzLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4gJCQuZmluZENsb3Nlc3QodGFyZ2V0LnZhbHVlcywgcG9zKSk7IC8vIG1hcCB0byBhcnJheSBvZiBjbG9zZXN0IHBvaW50cyBvZiBlYWNoIHRhcmdldFxyXG5cclxuXHRcdC8vIGRlY2lkZSBjbG9zZXN0IHBvaW50IGFuZCByZXR1cm5cclxuXHRcdHJldHVybiAkJC5maW5kQ2xvc2VzdChjYW5kaWRhdGVzLCBwb3MpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRDbG9zZXN0KHZhbHVlcywgcG9zKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGEgPSB2YWx1ZXMuZmlsdGVyKHYgPT4gdiAmJiBpc1ZhbHVlKHYudmFsdWUpKTtcclxuXHRcdGxldCBtaW5EaXN0ID0gY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5O1xyXG5cdFx0bGV0IGNsb3Nlc3Q7XHJcblxyXG5cdFx0Ly8gZmluZCBtb3VzZW92ZXJpbmcgYmFyXHJcblx0XHRkYXRhXHJcblx0XHRcdC5maWx0ZXIodiA9PiAkJC5pc0JhclR5cGUodi5pZCkpXHJcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh2LmlkKX0gLiR7Q0xBU1MuYmFyfS0ke3YuaW5kZXh9YCkubm9kZSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWNsb3Nlc3QgJiYgJCQuaXNXaXRoaW5CYXIoc2hhcGUpKSB7XHJcblx0XHRcdFx0XHRjbG9zZXN0ID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdC8vIGZpbmQgY2xvc2VzdCBwb2ludCBmcm9tIG5vbi1iYXJcclxuXHRcdGRhdGFcclxuXHRcdFx0LmZpbHRlcih2ID0+ICEkJC5pc0JhclR5cGUodi5pZCkpXHJcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGQgPSAkJC5kaXN0KHYsIHBvcyk7XHJcblxyXG5cdFx0XHRcdGlmIChkIDwgbWluRGlzdCkge1xyXG5cdFx0XHRcdFx0bWluRGlzdCA9IGQ7XHJcblx0XHRcdFx0XHRjbG9zZXN0ID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBjbG9zZXN0O1xyXG5cdH0sXHJcblxyXG5cdGRpc3QoZGF0YSwgcG9zKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnOiB7YXhpc19yb3RhdGVkOiBpc1JvdGF0ZWR9LCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IHhJbmRleCA9IGlzUm90YXRlZCA/IDEgOiAwO1xyXG5cdFx0Y29uc3QgeUluZGV4ID0gaXNSb3RhdGVkID8gMCA6IDE7XHJcblx0XHRjb25zdCB5ID0gJCQuY2lyY2xlWShkYXRhLCBkYXRhLmluZGV4KTtcclxuXHRcdGNvbnN0IHggPSAoc2NhbGUuem9vbSB8fCBzY2FsZS54KShkYXRhLngpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coeCAtIHBvc1t4SW5kZXhdLCAyKSArIE1hdGgucG93KHkgLSBwb3NbeUluZGV4XSwgMikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgZGF0YSBmb3Igc3RlcCB0eXBlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIE9iamVjdCBkYXRhIHZhbHVlc1xyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBzdGVwVHlwZSA9IGNvbmZpZy5saW5lX3N0ZXBfdHlwZTtcclxuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSBheGlzID8gYXhpcy5pc0NhdGVnb3JpemVkKCkgOiBmYWxzZTtcclxuXHJcblx0XHRjb25zdCBjb252ZXJ0ZWQgPSBpc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMuY29uY2F0KCkgOiBbdmFsdWVzXTtcclxuXHJcblx0XHRpZiAoIWlzUm90YXRlZCAmJiAhaXNDYXRlZ29yaXplZCkge1xyXG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluc2VydCAmIGFwcGVuZCBjbG9uaW5nIGZpcnN0L2xhc3QgdmFsdWUgdG8gYmUgZnVsbHkgcmVuZGVyZWQgY292ZXJpbmcgb24gZWFjaCBnYXAgc2lkZXNcclxuXHRcdGNvbnN0IGlkID0gY29udmVydGVkWzBdLmlkO1xyXG5cclxuXHRcdC8vIGluc2VydFxyXG5cdFx0bGV0IHggPSBjb252ZXJ0ZWRbMF0ueCAtIDE7XHJcblx0XHRsZXQgdmFsdWUgPSBjb252ZXJ0ZWRbMF0udmFsdWU7XHJcblxyXG5cdFx0aXNDYXRlZ29yaXplZCAmJiBjb252ZXJ0ZWQudW5zaGlmdCh7eCwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0c3RlcFR5cGUgPT09IFwic3RlcC1hZnRlclwiICYmXHJcblx0XHRcdGNvbnZlcnRlZC51bnNoaWZ0KHt4OiB4IC0gMSwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0Ly8gYXBwZW5kXHJcblx0XHR4ID0gY29udmVydGVkLmxlbmd0aCAtIDE7XHJcblx0XHR2YWx1ZSA9IGNvbnZlcnRlZFt4XS52YWx1ZTtcclxuXHJcblx0XHRpc0NhdGVnb3JpemVkICYmIGNvbnZlcnRlZC5wdXNoKHt4LCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRzdGVwVHlwZSA9PT0gXCJzdGVwLWJlZm9yZVwiICYmXHJcblx0XHRcdGNvbnZlcnRlZC5wdXNoKHt4OiB4ICsgMSwgdmFsdWUsIGlkfSk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnZlcnRlZDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VmFsdWVzVG9SYW5nZSh2YWx1ZXMpIHtcclxuXHRcdGNvbnN0IGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdO1xyXG5cdFx0Y29uc3QgcmFuZ2VzOiB7eDogc3RyaW5nIHwgbnVtYmVyLCBpZDogc3RyaW5nLCB2YWx1ZTogbnVtYmVyfVtdID0gW107XHJcblxyXG5cdFx0Y29udmVydGVkLmZvckVhY2gocmFuZ2UgPT4ge1xyXG5cdFx0XHRjb25zdCB7eCwgaWR9ID0gcmFuZ2U7XHJcblxyXG5cdFx0XHRyYW5nZXMucHVzaCh7XHJcblx0XHRcdFx0eCxcclxuXHRcdFx0XHRpZCxcclxuXHRcdFx0XHR2YWx1ZTogcmFuZ2UudmFsdWVbMF1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyYW5nZXMucHVzaCh7XHJcblx0XHRcdFx0eCxcclxuXHRcdFx0XHRpZCxcclxuXHRcdFx0XHR2YWx1ZTogcmFuZ2UudmFsdWVbMl1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2VzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZURhdGFBdHRyaWJ1dGVzKG5hbWUsIGF0dHJzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgY3VycmVudCA9IGNvbmZpZ1tgZGF0YV8ke25hbWV9YF07XHJcblxyXG5cdFx0aWYgKGlzVW5kZWZpbmVkKGF0dHJzKSkge1xyXG5cdFx0XHRyZXR1cm4gY3VycmVudDtcclxuXHRcdH1cclxuXHJcblx0XHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGN1cnJlbnRbaWRdID0gYXR0cnNbaWRdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0JCQucmVkcmF3KHt3aXRoTGVnZW5kOiB0cnVlfSk7XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QXJlYVJhbmdlRGF0YShkLCB0eXBlKSB7XHJcblx0XHRjb25zdCB2YWx1ZSA9IGQudmFsdWU7XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkodmFsdWUpKSB7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gW1wiaGlnaFwiLCBcIm1pZFwiLCBcImxvd1wiXS5pbmRleE9mKHR5cGUpO1xyXG5cclxuXHRcdFx0cmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiB2YWx1ZVtpbmRleF07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlW3R5cGVdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCByYXRpbyB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFJhdGlvIGZvciBnaXZlbiB0eXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSB2YWx1ZSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGFzUGVyY2VudCBDb252ZXJ0IHRoZSByZXR1cm4gYXMgcGVyY2VudCBvciBub3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBSYXRpbyB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0UmF0aW8odHlwZSwgZCwgYXNQZXJjZW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGFwaSA9ICQkLmFwaTtcclxuXHRcdGxldCByYXRpbyA9IDA7XHJcblxyXG5cdFx0aWYgKGQgJiYgYXBpLmRhdGEuc2hvd24oKS5sZW5ndGgpIHtcclxuXHRcdFx0cmF0aW8gPSBkLnJhdGlvIHx8IGQudmFsdWU7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJhcmNcIikge1xyXG5cdFx0XHRcdC8vIGlmIGhhcyBwYWRBbmdsZSBzZXQsIGNhbGN1bGF0ZSByYXRlIGJhc2VkIG9uIHZhbHVlXHJcblx0XHRcdFx0aWYgKCQkLnBpZS5wYWRBbmdsZSgpKCkpIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gZC52YWx1ZSAvICQkLmdldFRvdGFsRGF0YVN1bSh0cnVlKTtcclxuXHJcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIGJhc2VkIG9uIHRoZSByZW5kZXJlZCBhbmdsZSB2YWx1ZVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyYXRpbyA9IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIChcclxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMSA6IDIpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImluZGV4XCIpIHtcclxuXHRcdFx0XHRjb25zdCBkYXRhVmFsdWVzID0gYXBpLmRhdGEudmFsdWVzLmJpbmQoYXBpKTtcclxuXHRcdFx0XHRsZXQgdG90YWwgPSB0aGlzLmdldFRvdGFsUGVySW5kZXgoKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGxldCBoaWRkZW5TdW0gPSBkYXRhVmFsdWVzKHN0YXRlLmhpZGRlblRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChoaWRkZW5TdW0ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGhpZGRlblN1bSA9IGhpZGRlblN1bVxyXG5cdFx0XHRcdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLm1hcCgodiwgaSkgPT4gKGlzTnVtYmVyKHYpID8gdiA6IDApICsgY3VycltpXSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0dG90YWwgPSB0b3RhbC5tYXAoKHYsIGkpID0+IHYgLSBoaWRkZW5TdW1baV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZC5yYXRpbyA9IGlzTnVtYmVyKGQudmFsdWUpICYmIHRvdGFsICYmIHRvdGFsW2QuaW5kZXhdID4gMCA/XHJcblx0XHRcdFx0XHRkLnZhbHVlIC8gdG90YWxbZC5pbmRleF0gOiAwO1xyXG5cclxuXHRcdFx0XHRyYXRpbyA9IGQucmF0aW87XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdFx0cmF0aW8gPSAoXHJcblx0XHRcdFx0XHRwYXJzZUZsb2F0KFN0cmluZyhNYXRoLm1heChkLnZhbHVlLCAwKSkpIC8gc3RhdGUuY3VycmVudC5kYXRhTWF4XHJcblx0XHRcdFx0KSAqIGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFzUGVyY2VudCAmJiByYXRpbyA/IHJhdGlvICogMTAwIDogcmF0aW87XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCBkYXRhIGluZGV4IHRvIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGlja1ZhbHVlcyBUaWNrIGFycmF5IHZhbHVlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRGF0YUluZGV4QnlYKHRpY2tWYWx1ZXMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRjb25zdCB0aWNrVmFsdWVNYXAgPSB0aWNrVmFsdWVzLnJlZHVjZSgob3V0LCB0aWNrLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbTnVtYmVyKHRpY2sueCldID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gdGlja1ZhbHVlTWFwW051bWJlcih2YWx1ZS54KV07XHJcblxyXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRpbmRleCA9IHZhbHVlSW5kZXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhbHVlLmluZGV4ID0gaW5kZXg7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRGV0ZXJtaW5lIGlmIGJ1YmJsZSBoYXMgZGltZW5zaW9uIGRhdGFcclxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gZCBkYXRhIHZhbHVlXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpc0J1YmJsZVpUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuaXNCdWJibGVUeXBlKGQpICYmIChcclxuXHRcdFx0KGlzT2JqZWN0KGQudmFsdWUpICYmIChcInpcIiBpbiBkLnZhbHVlIHx8IFwieVwiIGluIGQudmFsdWUpKSB8fFxyXG5cdFx0XHQoaXNBcnJheShkLnZhbHVlKSAmJiBkLnZhbHVlLmxlbmd0aCA9PT0gMilcclxuXHRcdCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtlbmRhbGx9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGxvYWQocmF3VGFyZ2V0cywgYXJncyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHRhcmdldHMgPSByYXdUYXJnZXRzO1xyXG5cclxuXHRcdGlmICh0YXJnZXRzKSB7XHJcblx0XHRcdC8vIGZpbHRlciBsb2FkaW5nIHRhcmdldHMgaWYgbmVlZGVkXHJcblx0XHRcdGlmIChhcmdzLmZpbHRlcikge1xyXG5cdFx0XHRcdHRhcmdldHMgPSB0YXJnZXRzLmZpbHRlcihhcmdzLmZpbHRlcik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNldCB0eXBlIGlmIGFyZ3MudHlwZXMgfHwgYXJncy50eXBlIHNwZWNpZmllZFxyXG5cdFx0XHRpZiAoYXJncy50eXBlIHx8IGFyZ3MudHlwZXMpIHtcclxuXHRcdFx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB0eXBlID0gKGFyZ3MudHlwZXMgJiYgYXJncy50eXBlc1t0LmlkXSkgfHwgYXJncy50eXBlO1xyXG5cclxuXHRcdFx0XHRcdCQkLnNldFRhcmdldFR5cGUodC5pZCwgdHlwZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFVwZGF0ZS9BZGQgZGF0YVxyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChkID0+IHtcclxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChkLmlkID09PSB0YXJnZXRzW2ldLmlkKSB7XHJcblx0XHRcdFx0XHRcdGQudmFsdWVzID0gdGFyZ2V0c1tpXS52YWx1ZXM7XHJcblx0XHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHQvLyBSZWRyYXcgd2l0aCBuZXcgdGFyZ2V0c1xyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBVcGRhdGUgY3VycmVudCBzdGF0ZSBjaGFydCB0eXBlIGFuZCBlbGVtZW50cyBsaXN0IGFmdGVyIHJlZHJhd1xyXG5cdFx0JCQudXBkYXRlVHlwZXNFbGVtZW50cygpO1xyXG5cclxuXHRcdGFyZ3MuZG9uZSAmJiBhcmdzLmRvbmUuY2FsbCgkJC5hcGkpO1xyXG5cdH0sXHJcblxyXG5cdGxvYWRGcm9tQXJncyhhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBsb2FkIHdoZW4gY2hhcnQgaXMgYWxyZWFkeSBkZXN0cm95ZWRcclxuXHRcdGlmICghJCQuY29uZmlnKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXNldCBpbnRlcm5hbGx5IGNhY2hlZCBkYXRhXHJcblx0XHQkJC5jYWNoZS5yZXNldCgpO1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBhcmdzLmRhdGEgfHwgJCQuY29udmVydERhdGEoYXJncywgZCA9PiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGQpLCBhcmdzKSk7XHJcblxyXG5cdFx0ZGF0YSAmJiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpLCBhcmdzKTtcclxuXHR9LFxyXG5cclxuXHR1bmxvYWQocmF3VGFyZ2V0SWRzLCBjdXN0b21Eb25lQ2IpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0bGV0IGRvbmUgPSBjdXN0b21Eb25lQ2I7XHJcblx0XHRsZXQgdGFyZ2V0SWRzID0gcmF3VGFyZ2V0SWRzO1xyXG5cclxuXHRcdC8vIHJlc2V0IGludGVybmFsbHkgY2FjaGVkIGRhdGFcclxuXHRcdCQkLmNhY2hlLnJlc2V0KCk7XHJcblxyXG5cdFx0aWYgKCFkb25lKSB7XHJcblx0XHRcdGRvbmUgPSAoKSA9PiB7fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaWx0ZXIgZXhpc3RpbmcgdGFyZ2V0XHJcblx0XHR0YXJnZXRJZHMgPSB0YXJnZXRJZHMuZmlsdGVyKGlkID0+ICQkLmhhc1RhcmdldCgkJC5kYXRhLnRhcmdldHMsIGlkKSk7XHJcblxyXG5cdFx0Ly8gSWYgbm8gdGFyZ2V0LCBjYWxsIGRvbmUgYW5kIHJldHVyblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMgfHwgdGFyZ2V0SWRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRkb25lKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuc3ZnLnNlbGVjdEFsbCh0YXJnZXRJZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkKSkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpXHJcblx0XHRcdC5jYWxsKGVuZGFsbCwgZG9uZSk7XHJcblxyXG5cdFx0dGFyZ2V0SWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHQvLyBSZXNldCBmYWRlaW4gZm9yIGZ1dHVyZSBsb2FkXHJcblx0XHRcdHN0YXRlLndpdGhvdXRGYWRlSW5baWRdID0gZmFsc2U7XHJcblxyXG5cdFx0XHQvLyBSZW1vdmUgdGFyZ2V0J3MgZWxlbWVudHNcclxuXHRcdFx0aWYgKCRlbC5sZWdlbmQpIHtcclxuXHRcdFx0XHQkZWwubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX0keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gKS5yZW1vdmUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gUmVtb3ZlIHRhcmdldFxyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHQgPT4gdC5pZCAhPT0gaWQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGN1cnJlbnQgc3RhdGUgY2hhcnQgdHlwZSBhbmQgZWxlbWVudHMgbGlzdCBhZnRlciByZWRyYXdcclxuXHRcdCQkLnVwZGF0ZVR5cGVzRWxlbWVudHMoKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkcmFnIGFzIGQzRHJhZ30gZnJvbSBcImQzLWRyYWdcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2VtdWxhdGVFdmVudCwgaXNOdW1iZXIsIGlzT2JqZWN0fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBIYW5kbGUgZGF0YS5vbm92ZXIvb3V0IGNhbGxiYWNrIG9wdGlvbnNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzT3ZlciBPdmVyIG9yIG5vdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfG9iamVjdH0gZCBkYXRhIG9iamVjdFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0T3Zlck91dChpc092ZXI6IGJvb2xlYW4sIGQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aGFzUmFkYXJ9LCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzQXJjID0gaXNPYmplY3QoZCk7XHJcblxyXG5cdFx0Ly8gQ2FsbCBldmVudCBoYW5kbGVyXHJcblx0XHRpZiAoaXNBcmMgfHwgZCAhPT0gLTEpIHtcclxuXHRcdFx0bGV0IGNhbGxiYWNrID0gY29uZmlnW2lzT3ZlciA/IFwiZGF0YV9vbm92ZXJcIiA6IFwiZGF0YV9vbm91dFwiXS5iaW5kKCQkLmFwaSk7XHJcblxyXG5cdFx0XHRjb25maWcuY29sb3Jfb25vdmVyICYmICQkLnNldE92ZXJDb2xvcihpc092ZXIsIGQsIGlzQXJjKTtcclxuXHJcblx0XHRcdGlmIChpc0FyYykge1xyXG5cdFx0XHRcdGNhbGxiYWNrKGQsIG1haW4uc2VsZWN0KGAuJHtDTEFTUy5hcmN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKS5ub2RlKCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0bGV0IGxhc3QgPSAkJC5jYWNoZS5nZXQoS0VZLnNldE92ZXJPdXQpIHx8IFtdO1xyXG5cclxuXHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7ZH1gKVxyXG5cdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHNoYXBlXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdGlmIChsYXN0Lmxlbmd0aCA9PT0gMCB8fCBsYXN0LmV2ZXJ5KHYgPT4gdiAhPT0gdGhpcykpIHtcclxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhkLCB0aGlzKTtcclxuXHRcdFx0XHRcdFx0XHRsYXN0LnB1c2godGhpcyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAobGFzdC5sZW5ndGggPiAwICYmIHNoYXBlLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gY29uZmlnLmRhdGFfb25vdXQuYmluZCgkJC5hcGkpO1xyXG5cclxuXHRcdFx0XHRcdGxhc3QuZm9yRWFjaCh2ID0+IGNhbGxiYWNrKGQzU2VsZWN0KHYpLmRhdHVtKCksIHYpKTtcclxuXHRcdFx0XHRcdGxhc3QgPSBbXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCQkLmNhY2hlLmFkZChLRVkuc2V0T3Zlck91dCwgbGFzdCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGlzT3Zlcikge1xyXG5cdFx0XHRcdFx0Y29uZmlnLnBvaW50X2ZvY3VzX29ubHkgJiYgaGFzUmFkYXIgP1xyXG5cdFx0XHRcdFx0XHQkJC5zaG93Q2lyY2xlRm9jdXMoJCQuZ2V0QWxsVmFsdWVzT25JbmRleChkLCB0cnVlKSkgOlxyXG5cdFx0XHRcdFx0XHQkJC5leHBhbmRDaXJjbGVzQmFycyhkLCBudWxsLCB0cnVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCEkJC5pc011bHRpcGxlWCgpICYmIG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBmb3IgdG91Y2ggZXZlbnRcclxuXHQgKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IGQgdGFyZ2V0IGluZGV4IG9yIGRhdGEgb2JqZWN0IGZvciBBcmMgdHlwZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsbE92ZXJPdXRGb3JUb3VjaChkKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBsYXN0ID0gJCQuY2FjaGUuZ2V0KEtFWS5jYWxsT3Zlck91dEZvclRvdWNoKTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoZCkgJiYgbGFzdCA/IGQuaWQgIT09IGxhc3QuaWQgOiAoZCAhPT0gbGFzdCkpIHtcclxuXHRcdFx0KGxhc3QgfHwgaXNOdW1iZXIobGFzdCkpICYmICQkLnNldE92ZXJPdXQoZmFsc2UsIGxhc3QpO1xyXG5cdFx0XHQoZCB8fCBpc051bWJlcihkKSkgJiYgJCQuc2V0T3Zlck91dCh0cnVlLCBkKTtcclxuXHJcblx0XHRcdCQkLmNhY2hlLmFkZChLRVkuY2FsbE92ZXJPdXRGb3JUb3VjaCwgZCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGRyYWdnYWJsZSBzZWxlY3Rpb24gZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXREcmFnZ2FibGVTZWxlY3Rpb24oKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2RyYWdnYWJsZSAmJiAkJC5kcmFnID9cclxuXHRcdFx0ZDNEcmFnKClcclxuXHRcdFx0XHQub24oXCJkcmFnXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0JCQuZHJhZyhkM01vdXNlKHRoaXMpKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0JCQuZHJhZ3N0YXJ0KGQzTW91c2UodGhpcykpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwiZW5kXCIsICgpID0+IHsgJCQuZHJhZ2VuZCgpOyB9KSA6ICgpID0+IHt9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc3BhdGNoIGEgbW91c2UgZXZlbnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBldmVudCB0eXBlXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IG9mIGV2ZW50UmVjdFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IG1vdXNlIHggYW5kIHkgY29vcmRpbmF0ZSB2YWx1ZVxyXG5cdCAqL1xyXG5cdGRpc3BhdGNoRXZlbnQodHlwZTogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBtb3VzZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7aGFzUmFkYXJ9LCAkZWw6IHttYWluLCByYWRhcn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc011bHRpcGxlWCA9ICQkLmlzTXVsdGlwbGVYKCk7XHJcblx0XHRjb25zdCBzZWxlY3RvciA9IGhhc1JhZGFyID8gYC4ke0NMQVNTLmF4aXN9LSR7aW5kZXh9IHRleHRgIDogYC4ke2lzTXVsdGlwbGVYID8gQ0xBU1MuZXZlbnRSZWN0IDogYCR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWB9YDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdCA9IChoYXNSYWRhciA/IHJhZGFyLmF4ZXMgOiBtYWluKS5zZWxlY3Qoc2VsZWN0b3IpLm5vZGUoKTtcclxuXHJcblx0XHRjb25zdCB7d2lkdGgsIGxlZnQsIHRvcH0gPSBldmVudFJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHRjb25zdCB4ID0gbGVmdCArIChtb3VzZSA/IG1vdXNlWzBdIDogMCkgKyAoXHJcblx0XHRcdGlzTXVsdGlwbGVYIHx8ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQgPyAwIDogKHdpZHRoIC8gMilcclxuXHRcdCk7XHJcblx0XHRjb25zdCB5ID0gdG9wICsgKG1vdXNlID8gbW91c2VbMV0gOiAwKTtcclxuXHRcdGNvbnN0IHBhcmFtcyA9IHtcclxuXHRcdFx0c2NyZWVuWDogeCxcclxuXHRcdFx0c2NyZWVuWTogeSxcclxuXHRcdFx0Y2xpZW50WDogeCxcclxuXHRcdFx0Y2xpZW50WTogeVxyXG5cdFx0fTtcclxuXHJcblx0XHRlbXVsYXRlRXZlbnRbL14obW91c2V8Y2xpY2spLy50ZXN0KHR5cGUpID8gXCJtb3VzZVwiIDogXCJ0b3VjaFwiXShldmVudFJlY3QsIHR5cGUsIHBhcmFtcyk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZW5lcmF0ZUNsYXNzKHByZWZpeDogc3RyaW5nLCB0YXJnZXRJZDogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgICR7cHJlZml4fSAke3ByZWZpeCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUZXh0KGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy50ZXh0LCBkLmluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc1RleHRzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy50ZXh0cywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NTaGFwZShkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGUsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzU2hhcGVzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zaGFwZXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MoKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2xhc3NlcyA9ICQkLmNvbmZpZy5saW5lX2NsYXNzZXMgfHwgW107XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0Y29uc3QgaWQ6IHN0cmluZyA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XHJcblxyXG5cdFx0XHRpZiAoaWRzLmluZGV4T2YoaWQpIDwgMCkge1xyXG5cdFx0XHRcdGlkcy5wdXNoKGlkKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNsYXNzZXNbaWRzLmluZGV4T2YoaWQpICUgY2xhc3Nlcy5sZW5ndGhdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0xpbmUoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmxpbmUsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzTGluZXMoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lcywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaXJjbGUoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZSwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaXJjbGVzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuY2lyY2xlcywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NCYXIoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmJhciwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NCYXJzKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYmFycywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NBcmMoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQuZGF0YSkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJjLCBkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJjcyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQuZGF0YSkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJjcywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0FyZWEoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyZWEsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJlYXMoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmVhcywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NSZWdpb24oZCwgaTogbnVtYmVyKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgJHt0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MucmVnaW9uLCBpKX0gJHtcImNsYXNzXCIgaW4gZCA/IGQuY2xhc3MgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NFdmVudChkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmV2ZW50UmVjdCwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUYXJnZXQoaWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCBhZGRpdGlvbmFsQ2xhc3NTdWZmaXggPSB0aGlzLmNvbmZpZy5kYXRhX2NsYXNzZXNbaWRdO1xyXG5cdFx0bGV0IGFkZGl0aW9uYWxDbGFzcyA9IFwiXCI7XHJcblxyXG5cdFx0aWYgKGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCkge1xyXG5cdFx0XHRhZGRpdGlvbmFsQ2xhc3MgPSBgICR7Q0xBU1MudGFyZ2V0fS0ke2FkZGl0aW9uYWxDbGFzc1N1ZmZpeH1gO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGFyZ2V0LCBpZCkgKyBhZGRpdGlvbmFsQ2xhc3M7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NGb2N1cyhkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzRm9jdXNlZChkKSArIHRoaXMuY2xhc3NEZWZvY3VzZWQoZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NGb2N1c2VkKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGAgJHt0aGlzLnN0YXRlLmZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gQ0xBU1MuZm9jdXNlZCA6IFwiXCJ9YDtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0RlZm9jdXNlZChkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgICR7dGhpcy5zdGF0ZS5kZWZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gQ0xBU1MuZGVmb2N1c2VkIDogXCJcIn1gO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRUZXh0KGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0VGV4dCArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydExpbmUoZCk6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRMaW5lICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NoYXJ0QmFyKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QmFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NoYXJ0QXJjKGQpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QXJjICsgdGhpcy5jbGFzc1RhcmdldChkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRSYWRhcihkKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBDTEFTUy5jaGFydFJhZGFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUYXJnZXRTZWxlY3RvclN1ZmZpeCh0YXJnZXRJZD86IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0SWQgfHwgdGFyZ2V0SWQgPT09IDAgP1xyXG5cdFx0XHRgLSR7dGFyZ2V0SWR9YC5yZXBsYWNlKC9bXFxzPyFAIyQlXiYqKClfPSssLjw+J1wiOjtcXFtcXF1cXC98fmB7fVxcXFxdL2csIFwiLVwiKSA6IFwiXCI7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JUYXJnZXQoaWQ6IHN0cmluZywgcHJlZml4Pzogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0IHBmeCA9IHByZWZpeCB8fCBcIlwiO1xyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCk7XHJcblxyXG5cdFx0Ly8gc2VsZWN0IHRhcmdldCAmIGNpcmNsZVxyXG5cdFx0cmV0dXJuIGAke3BmeH0uJHtDTEFTUy50YXJnZXQgKyB0YXJnZXR9LCAke3BmeH0uJHtDTEFTUy5jaXJjbGVzICsgdGFyZ2V0fWA7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JUYXJnZXRzKGlkc1ZhbHVlLCBwcmVmaXg6IHN0cmluZyk6IHN0cmluZ1tdIHwgbnVsbCB7XHJcblx0XHRjb25zdCBpZHMgPSBpZHNWYWx1ZSB8fCBbXTtcclxuXHJcblx0XHRyZXR1cm4gaWRzLmxlbmd0aCA/XHJcblx0XHRcdGlkcy5tYXAoaWQgPT4gdGhpcy5zZWxlY3RvclRhcmdldChpZCwgcHJlZml4KSkgOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdG9yTGVnZW5kKGlkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGAuJHtDTEFTUy5sZWdlbmRJdGVtICsgdGhpcy5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YDtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RvckxlZ2VuZHMoaWRzKTogc3RyaW5nW10gfCBudWxsIHtcclxuXHRcdHJldHVybiBpZHMgJiYgaWRzLmxlbmd0aCA/XHJcblx0XHRcdGlkcy5tYXAoaWQgPT4gdGhpcy5zZWxlY3RvckxlZ2VuZChpZCkpIDogbnVsbDtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBDYXRlZ29yeSBOYW1lXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgSW5kZXggbnVtYmVyXHJcblx0ICogQHJldHVybnMge3N0cmluZ30gY2F0ZWdvcnkgTmFtZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2F0ZWdvcnlOYW1lKGk6IG51bWJlcik6IHN0cmluZyB7XHJcblx0XHRjb25zdCB7YXhpc194X2NhdGVnb3JpZXM6IGNhdGVnb3JpZXN9ID0gdGhpcy5jb25maWc7XHJcblxyXG5cdFx0cmV0dXJuIGkgPCBjYXRlZ29yaWVzLmxlbmd0aCA/IGNhdGVnb3JpZXNbaV0gOiBpO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtzY2FsZU9yZGluYWwgYXMgZDNTY2FsZU9yZGluYWx9IGZyb20gXCJkMy1zY2FsZVwiO1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7S0VZfSBmcm9tIFwiLi4vLi4vbW9kdWxlL0NhY2hlXCI7XHJcbmltcG9ydCB7bm90RW1wdHksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogU2V0IHBhdHRlcm4ncyBiYWNrZ3JvdW5kIGNvbG9yXHJcbiAqIChpdCBhZGRzIGEgPHJlY3Q+IGVsZW1lbnQgdG8gc2ltdWxhdGUgYmctY29sb3IpXHJcbiAqIEBwYXJhbSB7U1ZHUGF0dGVybkVsZW1lbnR9IHBhdHRlcm4gU1ZHIHBhdHRlcm4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgQ29sb3Igc3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCB0byBiZSBzZXRcclxuICogQHJldHVybnMge3tpZDogc3RyaW5nLCBub2RlOiBTVkdQYXR0ZXJuRWxlbWVudH19XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjb2xvcml6ZVBhdHRlcm4gPSAocGF0dGVybiwgY29sb3IsIGlkOiBzdHJpbmcpID0+IHtcclxuXHRjb25zdCBub2RlID0gZDNTZWxlY3QocGF0dGVybi5jbG9uZU5vZGUodHJ1ZSkpO1xyXG5cclxuXHRub2RlXHJcblx0XHQuYXR0cihcImlkXCIsIGlkKVxyXG5cdFx0Lmluc2VydChcInJlY3RcIiwgXCI6Zmlyc3QtY2hpbGRcIilcclxuXHRcdC5hdHRyKFwid2lkdGhcIiwgbm9kZS5hdHRyKFwid2lkdGhcIikpXHJcblx0XHQuYXR0cihcImhlaWdodFwiLCBub2RlLmF0dHIoXCJoZWlnaHRcIikpXHJcblx0XHQuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGlkLFxyXG5cdFx0bm9kZTogbm9kZS5ub2RlKClcclxuXHR9O1xyXG59O1xyXG5cclxuLy8gUmVwbGFjZW1lbnQgb2YgZDMuc2NoZW1lQ2F0ZWdvcnkxMC5cclxuLy8gQ29udGFpbmVkIGRpZmZlcmVudGx5IGRlcGVuZCBvbiBkMyB2ZXJzaW9uOiB2NChkMy1zY2FsZSksIHY1KGQzLXNjYWxlLWNocm9tYXRpYylcclxuY29uc3Qgc2NoZW1lQ2F0ZWdvcnkxMCA9IFtcIiMxZjc3YjRcIiwgXCIjZmY3ZjBlXCIsIFwiIzJjYTAyY1wiLCBcIiNkNjI3MjhcIiwgXCIjOTQ2N2JkXCIsIFwiIzhjNTY0YlwiLCBcIiNlMzc3YzJcIiwgXCIjN2Y3ZjdmXCIsIFwiI2JjYmQyMlwiLCBcIiMxN2JlY2ZcIl07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGNvbG9yIHBhdHRlcm4gZnJvbSBDU1MgZmlsZVxyXG5cdCAqIENTUyBzaG91bGQgYmUgZGVmaW5lZCBhczogYmFja2dyb3VuZC1pbWFnZTogdXJsKFwiIzAwYzczYzsjZmE3MTcxOyAuLi5cIik7XHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q29sb3JGcm9tQ3NzKCk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gS0VZLmNvbG9yUGF0dGVybjtcclxuXHRcdGNvbnN0IHtib2R5fSA9IGRvY3VtZW50O1xyXG5cdFx0bGV0IHBhdHRlcm4gPSBib2R5W2NhY2hlS2V5XTtcclxuXHJcblx0XHRpZiAoIXBhdHRlcm4pIHtcclxuXHRcdFx0Y29uc3QgZGVsaW1pdGVyID0gXCI7XCI7XHJcblx0XHRcdGNvbnN0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcclxuXHJcblx0XHRcdHNwYW4uY2xhc3NOYW1lID0gQ0xBU1MuY29sb3JQYXR0ZXJuO1xyXG5cdFx0XHRzcGFuLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuXHRcdFx0Ym9keS5hcHBlbmRDaGlsZChzcGFuKTtcclxuXHJcblx0XHRcdGNvbnN0IGNvbnRlbnQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzcGFuKS5iYWNrZ3JvdW5kSW1hZ2U7XHJcblxyXG5cdFx0XHRzcGFuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3Bhbik7XHJcblxyXG5cdFx0XHRpZiAoY29udGVudC5pbmRleE9mKGRlbGltaXRlcikgPiAtMSkge1xyXG5cdFx0XHRcdHBhdHRlcm4gPSBjb250ZW50XHJcblx0XHRcdFx0XHQucmVwbGFjZSgvdXJsW14jXSp8W1wiJygpXXwoXFxzfCUyMCkvZywgXCJcIilcclxuXHRcdFx0XHRcdC5zcGxpdChkZWxpbWl0ZXIpXHJcblx0XHRcdFx0XHQubWFwKHYgPT4gdi50cmltKCkucmVwbGFjZSgvW1xcXCInXFxzXS9nLCBcIlwiKSlcclxuXHRcdFx0XHRcdC5maWx0ZXIoQm9vbGVhbik7XHJcblxyXG5cdFx0XHRcdGJvZHlbY2FjaGVLZXldID0gcGF0dGVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYXR0ZXJuO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlQ29sb3IoKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5kYXRhX2NvbG9ycztcclxuXHRcdGNvbnN0IGNhbGxiYWNrID0gY29uZmlnLmRhdGFfY29sb3I7XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0bGV0IHBhdHRlcm4gPSBub3RFbXB0eShjb25maWcuY29sb3JfcGF0dGVybikgPyBjb25maWcuY29sb3JfcGF0dGVybiA6XHJcblx0XHRcdGQzU2NhbGVPcmRpbmFsKCQkLmdldENvbG9yRnJvbUNzcygpIHx8IHNjaGVtZUNhdGVnb3J5MTApLnJhbmdlKCk7XHJcblxyXG5cdFx0Y29uc3Qgb3JpZ2luYWxDb2xvclBhdHRlcm4gPSBwYXR0ZXJuO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5jb2xvcl90aWxlcykpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBjb25maWcuY29sb3JfdGlsZXMuYmluZCgkJC5hcGkpKCk7XHJcblxyXG5cdFx0XHQvLyBBZGQgYmFja2dyb3VuZCBjb2xvciB0byBwYXR0ZXJuc1xyXG5cdFx0XHRjb25zdCBjb2xvcml6ZWRQYXR0ZXJucyA9IHBhdHRlcm4ubWFwKChwLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGNvbG9yID0gcC5yZXBsYWNlKC9bI1xcKFxcKVxccyxdL2csIFwiXCIpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gYCR7JCQuc3RhdGUuZGF0ZXRpbWVJZH0tcGF0dGVybi0ke2NvbG9yfS0ke2luZGV4fWA7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjb2xvcml6ZVBhdHRlcm4odGlsZXNbaW5kZXggJSB0aWxlcy5sZW5ndGhdLCBwLCBpZCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cGF0dGVybiA9IGNvbG9yaXplZFBhdHRlcm5zLm1hcChwID0+IGB1cmwoIyR7cC5pZH0pYCk7XHJcblx0XHRcdCQkLnBhdHRlcm5zID0gY29sb3JpemVkUGF0dGVybnM7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0Y29uc3QgaWQ6IHN0cmluZyA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XHJcblx0XHRcdGNvbnN0IGlzTGluZSA9ICQkLmlzVHlwZU9mKGlkLCBbXCJsaW5lXCIsIFwic3BsaW5lXCIsIFwic3RlcFwiXSkgfHwgIWNvbmZpZy5kYXRhX3R5cGVzW2lkXTtcclxuXHRcdFx0bGV0IGNvbG9yO1xyXG5cclxuXHRcdFx0Ly8gaWYgY2FsbGJhY2sgZnVuY3Rpb24gaXMgcHJvdmlkZWRcclxuXHRcdFx0aWYgKGlzRnVuY3Rpb24oY29sb3JzW2lkXSkpIHtcclxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpZF0uYmluZCgkJC5hcGkpKGQpO1xyXG5cclxuXHRcdFx0Ly8gaWYgc3BlY2lmaWVkLCBjaG9vc2UgdGhhdCBjb2xvclxyXG5cdFx0XHR9IGVsc2UgaWYgKGNvbG9yc1tpZF0pIHtcclxuXHRcdFx0XHRjb2xvciA9IGNvbG9yc1tpZF07XHJcblxyXG5cdFx0XHQvLyBpZiBub3Qgc3BlY2lmaWVkLCBjaG9vc2UgZnJvbSBwYXR0ZXJuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcclxuXHRcdFx0XHRcdGlkcy5wdXNoKGlkKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gaXNMaW5lID8gb3JpZ2luYWxDb2xvclBhdHRlcm5baWRzLmluZGV4T2YoaWQpICUgb3JpZ2luYWxDb2xvclBhdHRlcm4ubGVuZ3RoXSA6XHJcblx0XHRcdFx0XHRwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcclxuXHJcblx0XHRcdFx0Y29sb3JzW2lkXSA9IGNvbG9yO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gaXNGdW5jdGlvbihjYWxsYmFjaykgP1xyXG5cdFx0XHRcdGNhbGxiYWNrLmJpbmQoJCQuYXBpKShjb2xvciwgZCkgOiBjb2xvcjtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVMZXZlbENvbG9yKCk6IEZ1bmN0aW9uIHwgbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgY29sb3JzID0gY29uZmlnLmNvbG9yX3BhdHRlcm47XHJcblx0XHRjb25zdCB0aHJlc2hvbGQgPSBjb25maWcuY29sb3JfdGhyZXNob2xkO1xyXG5cdFx0Y29uc3QgYXNWYWx1ZSA9IHRocmVzaG9sZC51bml0ID09PSBcInZhbHVlXCI7XHJcblx0XHRjb25zdCBtYXggPSB0aHJlc2hvbGQubWF4IHx8IDEwMDtcclxuXHRcdGNvbnN0IHZhbHVlcyA9IHRocmVzaG9sZC52YWx1ZXMgJiZcclxuXHRcdFx0dGhyZXNob2xkLnZhbHVlcy5sZW5ndGggPyB0aHJlc2hvbGQudmFsdWVzIDogW107XHJcblxyXG5cdFx0cmV0dXJuIG5vdEVtcHR5KHRocmVzaG9sZCkgPyBmdW5jdGlvbih2YWx1ZSkge1xyXG5cdFx0XHRjb25zdCB2ID0gYXNWYWx1ZSA/IHZhbHVlIDogKHZhbHVlICogMTAwIC8gbWF4KTtcclxuXHRcdFx0bGV0IGNvbG9yID0gY29sb3JzW2NvbG9ycy5sZW5ndGggLSAxXTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCBsID0gdmFsdWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHRcdGlmICh2IDw9IHZhbHVlc1tpXSkge1xyXG5cdFx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaV07XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjb2xvcjtcclxuXHRcdH0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aGUgZGF0YSBvdmVyIGNvbG9yLlxyXG5cdCAqIFdoZW4gaXMgb3V0LCB3aWxsIHJlc3RhdGUgaW4gaXRzIHByZXZpb3VzIGNvbG9yIHZhbHVlXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc092ZXIgdHJ1ZTogc2V0IG92ZXJlZCBjb2xvciwgZmFsc2U6IHJlc3RvcmVcclxuXHQgKiBAcGFyYW0ge251bWJlcnxvYmplY3R9IGQgdGFyZ2V0IGluZGV4IG9yIGRhdGEgb2JqZWN0IGZvciBBcmMgdHlwZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0T3ZlckNvbG9yKGlzT3ZlcjogYm9vbGVhbiwgZCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBvbm92ZXIgPSBjb25maWcuY29sb3Jfb25vdmVyO1xyXG5cdFx0bGV0IGNvbG9yID0gaXNPdmVyID8gb25vdmVyIDogJCQuY29sb3I7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KGNvbG9yKSkge1xyXG5cdFx0XHRjb2xvciA9ICh7aWR9KSA9PiAoaWQgaW4gb25vdmVyID8gb25vdmVyW2lkXSA6ICQkLmNvbG9yKGlkKSk7XHJcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGNvbG9yKSkge1xyXG5cdFx0XHRjb2xvciA9ICgpID0+IG9ub3ZlcjtcclxuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvbm92ZXIpKSB7XHJcblx0XHRcdGNvbG9yID0gY29sb3IuYmluZCgkJC5hcGkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdoZW4gaXMgQXJjIHR5cGVcclxuXHRcdGlmIChpc09iamVjdChkKSkge1xyXG5cdFx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKGQpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBDaGFydCB0eXBlIGNvbnN0YW50XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVFlQRSA9IHtcclxuXHRBUkVBOiBcImFyZWFcIixcclxuXHRBUkVBX0xJTkVfUkFOR0U6IFwiYXJlYS1saW5lLXJhbmdlXCIsXHJcblx0QVJFQV9TUExJTkU6IFwiYXJlYS1zcGxpbmVcIixcclxuXHRBUkVBX1NQTElORV9SQU5HRTogXCJhcmVhLXNwbGluZS1yYW5nZVwiLFxyXG5cdEFSRUFfU1RFUDogXCJhcmVhLXN0ZXBcIixcclxuXHRCQVI6IFwiYmFyXCIsXHJcblx0QlVCQkxFOiBcImJ1YmJsZVwiLFxyXG5cdERPTlVUOiBcImRvbnV0XCIsXHJcblx0R0FVR0U6IFwiZ2F1Z2VcIixcclxuXHRMSU5FOiBcImxpbmVcIixcclxuXHRQSUU6IFwicGllXCIsXHJcblx0UkFEQVI6IFwicmFkYXJcIixcclxuXHRTQ0FUVEVSOiBcInNjYXR0ZXJcIixcclxuXHRTUExJTkU6IFwic3BsaW5lXCIsXHJcblx0U1RFUDogXCJzdGVwXCJcclxufTtcclxuXHJcbi8qKlxyXG4gKiBjaGFydCB0eXBlcyBieSBjYXRlZ29yeVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRZUEVfQllfQ0FURUdPUlkgPSB7XHJcblx0QXJlYTogW1xyXG5cdFx0VFlQRS5BUkVBLFxyXG5cdFx0VFlQRS5BUkVBX1NQTElORSxcclxuXHRcdFRZUEUuQVJFQV9TUExJTkVfUkFOR0UsXHJcblx0XHRUWVBFLkFSRUFfTElORV9SQU5HRSxcclxuXHRcdFRZUEUuQVJFQV9TVEVQXHJcblx0XSxcclxuXHRBcmVhUmFuZ2U6IFtcclxuXHRcdFRZUEUuQVJFQV9TUExJTkVfUkFOR0UsXHJcblx0XHRUWVBFLkFSRUFfTElORV9SQU5HRVxyXG5cdF0sXHJcblx0QXJjOiBbXHJcblx0XHRUWVBFLlBJRSxcclxuXHRcdFRZUEUuRE9OVVQsXHJcblx0XHRUWVBFLkdBVUdFLFxyXG5cdFx0VFlQRS5SQURBUlxyXG5cdF0sXHJcblx0TGluZTogW1xyXG5cdFx0VFlQRS5MSU5FLFxyXG5cdFx0VFlQRS5TUExJTkUsXHJcblx0XHRUWVBFLkFSRUEsXHJcblx0XHRUWVBFLkFSRUFfU1BMSU5FLFxyXG5cdFx0VFlQRS5BUkVBX1NQTElORV9SQU5HRSxcclxuXHRcdFRZUEUuQVJFQV9MSU5FX1JBTkdFLFxyXG5cdFx0VFlQRS5TVEVQLFxyXG5cdFx0VFlQRS5BUkVBX1NURVBcclxuXHRdLFxyXG5cdFN0ZXA6IFtcclxuXHRcdFRZUEUuU1RFUCxcclxuXHRcdFRZUEUuQVJFQV9TVEVQXHJcblx0XSxcclxuXHRTcGxpbmU6IFtcclxuXHRcdFRZUEUuU1BMSU5FLFxyXG5cdFx0VFlQRS5BUkVBX1NQTElORSxcclxuXHRcdFRZUEUuQVJFQV9TUExJTkVfUkFOR0VcclxuXHRdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtUWVBFLCBUWVBFX0JZX0NBVEVHT1JZfSBmcm9tIFwiLi4vLi4vY29uZmlnL2NvbnN0XCI7XHJcbmltcG9ydCB7YnJ1c2hFbXB0eSwgZ2V0QnJ1c2hTZWxlY3Rpb24sIGdldE1pbk1heCwgaXNEZWZpbmVkLCBub3RFbXB0eSwgaXNWYWx1ZSwgaXNPYmplY3QsIGlzTnVtYmVyLCBkaWZmRG9tYWluLCBwYXJzZURhdGUsIHNvcnRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIik6IG51bWJlciB8IERhdGUgfCB1bmRlZmluZWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzTWluID0gdHlwZSA9PT0gXCJtaW5cIjtcclxuXHJcblx0XHRjb25zdCBkYXRhR3JvdXBzID0gY29uZmlnLmRhdGFfZ3JvdXBzO1xyXG5cdFx0Y29uc3QgaWRzID0gJCQubWFwVG9JZHModGFyZ2V0cyk7XHJcblx0XHRjb25zdCB5cyA9ICQkLmdldFZhbHVlc0FzSWRLZXllZCh0YXJnZXRzKTtcclxuXHJcblx0XHRpZiAoZGF0YUdyb3Vwcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdGNvbnN0IGhhc1ZhbHVlID0gJCRbYGhhcyR7aXNNaW4gPyBcIk5lZ2F0aXZlXCIgOiBcIlBvc2l0aXZlXCJ9VmFsdWVJblRhcmdldHNgXSh0YXJnZXRzKTtcclxuXHJcblx0XHRcdGZvciAobGV0IGogPSAwLCBpZHNJbkdyb3VwOyAoaWRzSW5Hcm91cCA9IGRhdGFHcm91cHNbal0pOyBqKyspIHtcclxuXHRcdFx0XHQvLyBEZXRlcm1pbmUgYmFzZUlkXHJcblx0XHRcdFx0aWRzSW5Hcm91cCA9IGlkc0luR3JvdXAuZmlsdGVyKHYgPT4gaWRzLmluZGV4T2YodikgPj0gMCk7XHJcblxyXG5cdFx0XHRcdGlmIChpZHNJbkdyb3VwLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBiYXNlSWQgPSBpZHNJbkdyb3VwWzBdO1xyXG5cdFx0XHRcdGNvbnN0IGJhc2VBeGlzSWQgPSBheGlzLmdldElkKGJhc2VJZCk7XHJcblxyXG5cdFx0XHRcdC8vIEluaXRpYWxpemUgYmFzZSB2YWx1ZS4gU2V0IHRvIDAgaWYgbm90IG1hdGNoIHdpdGggdGhlIGNvbmRpdGlvblxyXG5cdFx0XHRcdGlmIChoYXNWYWx1ZSAmJiB5c1tiYXNlSWRdKSB7XHJcblx0XHRcdFx0XHR5c1tiYXNlSWRdID0geXNbYmFzZUlkXS5tYXAodiA9PiAoXHJcblx0XHRcdFx0XHRcdChpc01pbiA/IHYgPCAwIDogdiA+IDApID8gdiA6IDBcclxuXHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgayA9IDEsIGlkOyAoaWQgPSBpZHNJbkdyb3VwW2tdKTsgaysrKSB7XHJcblx0XHRcdFx0XHRpZiAoIXlzW2lkXSkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCBheGlzSWQgPSBheGlzLmdldElkKGlkKTtcclxuXHJcblx0XHRcdFx0XHR5c1tpZF0uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zdCB2YWwgPSArdjtcclxuXHRcdFx0XHRcdFx0Y29uc3QgbWVldENvbmRpdGlvbiA9IGlzTWluID8gdmFsID4gMCA6IHZhbCA8IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoYXhpc0lkID09PSBiYXNlQXhpc0lkICYmICEoaGFzVmFsdWUgJiYgbWVldENvbmRpdGlvbikpIHtcclxuXHRcdFx0XHRcdFx0XHR5c1tiYXNlSWRdW2ldICs9IHZhbDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdldE1pbk1heCh0eXBlLCBPYmplY3Qua2V5cyh5cykubWFwKGtleSA9PiBnZXRNaW5NYXgodHlwZSwgeXNba2V5XSkpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluTWluKHRhcmdldHMpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1pblwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluTWF4KHRhcmdldHMpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1heFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiBoaWRkZW4gdGFyZ2V0cyBib3VuZCB0byB0aGUgZ2l2ZW4gYXhpcyBpZFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCB0byBiZSBjaGVja2VkXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpc0hpZGRlblRhcmdldFdpdGhZRG9tYWluKGlkKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLnN0YXRlLmhpZGRlblRhcmdldElkc1xyXG5cdFx0XHQuc29tZSh2ID0+ICQkLmF4aXMuZ2V0SWQodikgPT09IGlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluKHRhcmdldHMsIGF4aXNJZDogc3RyaW5nLCB4RG9tYWluKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IHBmeCA9IGBheGlzXyR7YXhpc0lkfWA7XHJcblxyXG5cdFx0aWYgKCQkLmlzU3RhY2tOb3JtYWxpemVkKCkpIHtcclxuXHRcdFx0cmV0dXJuIFswLCAxMDBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRhcmdldHNCeUF4aXNJZCA9IHRhcmdldHMuZmlsdGVyKHQgPT4gYXhpcy5nZXRJZCh0LmlkKSA9PT0gYXhpc0lkKTtcclxuXHRcdGNvbnN0IHlUYXJnZXRzID0geERvbWFpbiA/ICQkLmZpbHRlckJ5WERvbWFpbih0YXJnZXRzQnlBeGlzSWQsIHhEb21haW4pIDogdGFyZ2V0c0J5QXhpc0lkO1xyXG5cclxuXHRcdGlmICh5VGFyZ2V0cy5sZW5ndGggPT09IDApIHsgLy8gdXNlIGRvbWFpbiBvZiB0aGUgb3RoZXIgYXhpcyBpZiB0YXJnZXQgb2YgYXhpc0lkIGlzIG5vbmVcclxuXHRcdFx0aWYgKCQkLmlzSGlkZGVuVGFyZ2V0V2l0aFlEb21haW4oYXhpc0lkKSkge1xyXG5cdFx0XHRcdHJldHVybiBzY2FsZVtheGlzSWRdLmRvbWFpbigpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBheGlzSWQgPT09IFwieTJcIiA/XHJcblx0XHRcdFx0XHRzY2FsZS55LmRvbWFpbigpIDpcclxuXHRcdFx0XHRcdC8vIFdoZW4gYWxsIGRhdGEgYm91bmRzIHRvIHkyLCB5IEF4aXMgZG9tYWluIGlzIGNhbGxlZCBwcmlvciB5Mi5cclxuXHRcdFx0XHRcdC8vIFNvLCBpdCBuZWVkcyB0byBjYWxsIHRvIGdldCB5MiBkb21haW4gaGVyZVxyXG5cdFx0XHRcdFx0JCQuZ2V0WURvbWFpbih0YXJnZXRzLCBcInkyXCIsIHhEb21haW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeU1pbiA9IGNvbmZpZ1tgJHtwZnh9X21pbmBdO1xyXG5cdFx0Y29uc3QgeU1heCA9IGNvbmZpZ1tgJHtwZnh9X21heGBdO1xyXG5cdFx0bGV0IHlEb21haW5NaW4gPSAkJC5nZXRZRG9tYWluTWluKHlUYXJnZXRzKTtcclxuXHRcdGxldCB5RG9tYWluTWF4ID0gJCQuZ2V0WURvbWFpbk1heCh5VGFyZ2V0cyk7XHJcblxyXG5cdFx0Y29uc3QgY2VudGVyID0gY29uZmlnW2Ake3BmeH1fY2VudGVyYF07XHJcblx0XHRsZXQgaXNaZXJvQmFzZWQgPSBbVFlQRS5CQVIsIFRZUEUuQlVCQkxFLCBUWVBFLlNDQVRURVIsIC4uLlRZUEVfQllfQ0FURUdPUlkuTGluZV1cclxuXHRcdFx0LnNvbWUodiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdHlwZSA9IHYuaW5kZXhPZihcImFyZWFcIikgPiAtMSA/IFwiYXJlYVwiIDogdjtcclxuXHJcblx0XHRcdFx0cmV0dXJuICQkLmhhc1R5cGUodiwgeVRhcmdldHMpICYmIGNvbmZpZ1tgJHt0eXBlfV96ZXJvYmFzZWRgXTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgaXNJbnZlcnRlZCA9IGNvbmZpZ1tgJHtwZnh9X2ludmVydGVkYF07XHJcblx0XHRjb25zdCBzaG93SG9yaXpvbnRhbERhdGFMYWJlbCA9ICQkLmhhc0RhdGFMYWJlbCgpICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBzaG93VmVydGljYWxEYXRhTGFiZWwgPSAkJC5oYXNEYXRhTGFiZWwoKSAmJiAhY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBNRU1POiBhdm9pZCBpbnZlcnRpbmcgZG9tYWluIHVuZXhwZWN0ZWRseVxyXG5cdFx0eURvbWFpbk1pbiA9IGlzVmFsdWUoeU1pbikgPyB5TWluIDpcclxuXHRcdFx0KGlzVmFsdWUoeU1heCkgPyAoeURvbWFpbk1pbiA8IHlNYXggPyB5RG9tYWluTWluIDogeU1heCAtIDEwKSA6IHlEb21haW5NaW4pO1xyXG5cdFx0eURvbWFpbk1heCA9IGlzVmFsdWUoeU1heCkgPyB5TWF4IDpcclxuXHRcdFx0KGlzVmFsdWUoeU1pbikgPyAoeU1pbiA8IHlEb21haW5NYXggPyB5RG9tYWluTWF4IDogeU1pbiArIDEwKSA6IHlEb21haW5NYXgpO1xyXG5cclxuXHRcdGlmIChpc05hTih5RG9tYWluTWluKSkgeyAvLyBzZXQgbWluaW11bSB0byB6ZXJvIHdoZW4gbm90IG51bWJlclxyXG5cdFx0XHR5RG9tYWluTWluID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNOYU4oeURvbWFpbk1heCkpIHsgLy8gc2V0IG1heGltdW0gdG8gaGF2ZSBzYW1lIHZhbHVlIGFzIHlEb21haW5NaW5cclxuXHRcdFx0eURvbWFpbk1heCA9IHlEb21haW5NaW47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHlEb21haW5NaW4gPT09IHlEb21haW5NYXgpIHtcclxuXHRcdFx0eURvbWFpbk1pbiA8IDAgPyB5RG9tYWluTWF4ID0gMCA6IHlEb21haW5NaW4gPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzQWxsUG9zaXRpdmUgPSB5RG9tYWluTWluID49IDAgJiYgeURvbWFpbk1heCA+PSAwO1xyXG5cdFx0Y29uc3QgaXNBbGxOZWdhdGl2ZSA9IHlEb21haW5NaW4gPD0gMCAmJiB5RG9tYWluTWF4IDw9IDA7XHJcblxyXG5cdFx0Ly8gQ2FuY2VsIHplcm9iYXNlZCBpZiBheGlzXypfbWluIC8gYXhpc18qX21heCBzcGVjaWZpZWRcclxuXHRcdGlmICgoaXNWYWx1ZSh5TWluKSAmJiBpc0FsbFBvc2l0aXZlKSB8fCAoaXNWYWx1ZSh5TWF4KSAmJiBpc0FsbE5lZ2F0aXZlKSkge1xyXG5cdFx0XHRpc1plcm9CYXNlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxyXG5cdFx0aWYgKGlzWmVyb0Jhc2VkKSB7XHJcblx0XHRcdGlzQWxsUG9zaXRpdmUgJiYgKHlEb21haW5NaW4gPSAwKTtcclxuXHRcdFx0aXNBbGxOZWdhdGl2ZSAmJiAoeURvbWFpbk1heCA9IDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRvbWFpbkxlbmd0aCA9IE1hdGguYWJzKHlEb21haW5NYXggLSB5RG9tYWluTWluKTtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSB7dG9wOiBkb21haW5MZW5ndGggKiAwLjEsIGJvdHRvbTogZG9tYWluTGVuZ3RoICogMC4xfTtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNlbnRlcikpIHtcclxuXHRcdFx0Y29uc3QgeURvbWFpbkFicyA9IE1hdGgubWF4KE1hdGguYWJzKHlEb21haW5NaW4pLCBNYXRoLmFicyh5RG9tYWluTWF4KSk7XHJcblxyXG5cdFx0XHR5RG9tYWluTWF4ID0gY2VudGVyICsgeURvbWFpbkFicztcclxuXHRcdFx0eURvbWFpbk1pbiA9IGNlbnRlciAtIHlEb21haW5BYnM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWRkIHBhZGRpbmcgZm9yIGRhdGEgbGFiZWxcclxuXHRcdGlmIChzaG93SG9yaXpvbnRhbERhdGFMYWJlbCkge1xyXG5cdFx0XHRjb25zdCBkaWZmID0gZGlmZkRvbWFpbihzY2FsZS55LnJhbmdlKCkpO1xyXG5cdFx0XHRjb25zdCByYXRpbyA9ICQkLmdldERhdGFMYWJlbExlbmd0aCh5RG9tYWluTWluLCB5RG9tYWluTWF4LCBcIndpZHRoXCIpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IHYgLyBkaWZmKTtcclxuXHJcblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0cGFkZGluZ1t2XSArPSBkb21haW5MZW5ndGggKiAocmF0aW9baV0gLyAoMSAtIHJhdGlvWzBdIC0gcmF0aW9bMV0pKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKHNob3dWZXJ0aWNhbERhdGFMYWJlbCkge1xyXG5cdFx0XHRjb25zdCBsZW5ndGhzID0gJCQuZ2V0RGF0YUxhYmVsTGVuZ3RoKHlEb21haW5NaW4sIHlEb21haW5NYXgsIFwiaGVpZ2h0XCIpO1xyXG5cclxuXHRcdFx0W1wiYm90dG9tXCIsIFwidG9wXCJdLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRwYWRkaW5nW3ZdICs9IGF4aXMuY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmcobGVuZ3Roc1tpXSwgZG9tYWluTGVuZ3RoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgcGFkZGluZyBpcyBzZXQsIHRoZSBkb21haW4gd2lsbCBiZSB1cGRhdGVkIHJlbGF0aXZlIHRoZSBjdXJyZW50IGRvbWFpbiB2YWx1ZVxyXG5cdFx0Ly8gZXgpICQkLmhlaWdodD0zMDAsIHBhZGRpbmcudG9wPTE1MCwgZG9tYWluTGVuZ3RoPTQgIC0tPiBkb21haW49NlxyXG5cdFx0Y29uc3QgcCA9IGNvbmZpZ1tgJHtwZnh9X3BhZGRpbmdgXTtcclxuXHJcblx0XHRpZiAobm90RW1wdHkocCkpIHtcclxuXHRcdFx0W1wiYm90dG9tXCIsIFwidG9wXCJdLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0cGFkZGluZ1t2XSA9IGF4aXMuZ2V0UGFkZGluZyhwLCB2LCBwYWRkaW5nW3ZdLCBkb21haW5MZW5ndGgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBCYXIvQXJlYSBjaGFydCBzaG91bGQgYmUgMC1iYXNlZCBpZiBhbGwgcG9zaXRpdmV8bmVnYXRpdmVcclxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xyXG5cdFx0XHRpc0FsbFBvc2l0aXZlICYmIChwYWRkaW5nLmJvdHRvbSA9IHlEb21haW5NaW4pO1xyXG5cdFx0XHRpc0FsbE5lZ2F0aXZlICYmIChwYWRkaW5nLnRvcCA9IC15RG9tYWluTWF4KTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkb21haW4gPSBbeURvbWFpbk1pbiAtIHBhZGRpbmcuYm90dG9tLCB5RG9tYWluTWF4ICsgcGFkZGluZy50b3BdO1xyXG5cclxuXHRcdHJldHVybiBpc0ludmVydGVkID8gZG9tYWluLnJldmVyc2UoKSA6IGRvbWFpbjtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIHR5cGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNvbmZpZ1ZhbHVlID0gJCQuY29uZmlnW2BheGlzX3hfJHt0eXBlfWBdO1xyXG5cdFx0Y29uc3QgZGF0YVZhbHVlID0gZ2V0TWluTWF4KHR5cGUsIHRhcmdldHMubWFwKHQgPT4gZ2V0TWluTWF4KHR5cGUsIHQudmFsdWVzLm1hcCh2ID0+IHYueCkpKSk7XHJcblx0XHRsZXQgdmFsdWUgPSBpc09iamVjdChjb25maWdWYWx1ZSkgPyBjb25maWdWYWx1ZS52YWx1ZSA6IGNvbmZpZ1ZhbHVlO1xyXG5cclxuXHRcdHZhbHVlID0gaXNEZWZpbmVkKHZhbHVlKSAmJiAkJC5heGlzLmlzVGltZVNlcmllcygpID8gcGFyc2VEYXRlKHZhbHVlKSA6IHZhbHVlO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb25maWdWYWx1ZSkgJiYgY29uZmlnVmFsdWUuZml0ICYmIChcclxuXHRcdFx0KHR5cGUgPT09IFwibWluXCIgJiYgdmFsdWUgPCBkYXRhVmFsdWUpIHx8ICh0eXBlID09PSBcIm1heFwiICYmIHZhbHVlID4gZGF0YVZhbHVlKVxyXG5cdFx0KSkge1xyXG5cdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogZGF0YVZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW5NaW4odGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1pblwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluTWF4KHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpblBhZGRpbmcoZG9tYWluKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZGlmZiA9IGRvbWFpblsxXSAtIGRvbWFpblswXTtcclxuXHRcdGNvbnN0IHhQYWRkaW5nID0gY29uZmlnLmF4aXNfeF9wYWRkaW5nO1xyXG5cdFx0bGV0IG1heERhdGFDb3VudDtcclxuXHRcdGxldCBwYWRkaW5nO1xyXG5cclxuXHRcdGlmIChheGlzLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRwYWRkaW5nID0gMDtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xyXG5cdFx0XHRtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdFx0cGFkZGluZyA9IG1heERhdGFDb3VudCA+IDEgPyAoZGlmZiAvIChtYXhEYXRhQ291bnQgLSAxKSkgLyAyIDogMC41O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFkZGluZyA9IGRpZmYgKiAwLjAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBsZWZ0ID0gcGFkZGluZztcclxuXHRcdGxldCByaWdodCA9IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KHhQYWRkaW5nKSAmJiBub3RFbXB0eSh4UGFkZGluZykpIHtcclxuXHRcdFx0bGVmdCA9IGlzVmFsdWUoeFBhZGRpbmcubGVmdCkgPyB4UGFkZGluZy5sZWZ0IDogcGFkZGluZztcclxuXHRcdFx0cmlnaHQgPSBpc1ZhbHVlKHhQYWRkaW5nLnJpZ2h0KSA/IHhQYWRkaW5nLnJpZ2h0IDogcGFkZGluZztcclxuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoY29uZmlnLmF4aXNfeF9wYWRkaW5nKSkge1xyXG5cdFx0XHRsZWZ0ID0geFBhZGRpbmc7XHJcblx0XHRcdHJpZ2h0ID0geFBhZGRpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtsZWZ0LCByaWdodH07XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbih0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuYXhpcy5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5heGlzLmlzVGltZVNlcmllcygpO1xyXG5cdFx0Y29uc3QgeERvbWFpbiA9IFskJC5nZXRYRG9tYWluTWluKHRhcmdldHMpLCAkJC5nZXRYRG9tYWluTWF4KHRhcmdldHMpXTtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSAkJC5nZXRYRG9tYWluUGFkZGluZyh4RG9tYWluKTtcclxuXHRcdGxldCBbZmlyc3RYLCBsYXN0WF0gPSB4RG9tYWluO1xyXG5cdFx0bGV0IG1pbjogRGF0ZSB8IG51bWJlciA9IDA7XHJcblx0XHRsZXQgbWF4OiBEYXRlIHwgbnVtYmVyID0gMDtcclxuXHJcblx0XHQvLyBzaG93IGNlbnRlciBvZiB4IGRvbWFpbiBpZiBtaW4gYW5kIG1heCBhcmUgdGhlIHNhbWVcclxuXHRcdGlmICgoZmlyc3RYIC0gbGFzdFgpID09PSAwICYmICFpc0NhdGVnb3JpemVkKSB7XHJcblx0XHRcdGlmIChpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHRmaXJzdFggPSBuZXcgRGF0ZShmaXJzdFguZ2V0VGltZSgpICogMC41KTtcclxuXHRcdFx0XHRsYXN0WCA9IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSAqIDEuNSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zmlyc3RYID0gZmlyc3RYID09PSAwID8gMSA6IChmaXJzdFggKiAwLjUpO1xyXG5cdFx0XHRcdGxhc3RYID0gbGFzdFggPT09IDAgPyAtMSA6IChsYXN0WCAqIDEuNSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZmlyc3RYIHx8IGZpcnN0WCA9PT0gMCkge1xyXG5cdFx0XHRtaW4gPSBpc1RpbWVTZXJpZXMgPyBuZXcgRGF0ZShmaXJzdFguZ2V0VGltZSgpIC0gcGFkZGluZy5sZWZ0KSA6IGZpcnN0WCAtIHBhZGRpbmcubGVmdDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGFzdFggfHwgbGFzdFggPT09IDApIHtcclxuXHRcdFx0bWF4ID0gaXNUaW1lU2VyaWVzID8gbmV3IERhdGUobGFzdFguZ2V0VGltZSgpICsgcGFkZGluZy5yaWdodCkgOiBsYXN0WCArIHBhZGRpbmcucmlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFttaW4sIG1heF07XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWERvbWFpbih0YXJnZXRzLCB3aXRoVXBkYXRlWERvbWFpbiwgd2l0aFVwZGF0ZU9yZ1hEb21haW4sIHdpdGhUcmltLCBkb21haW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZywgc2NhbGU6IHt4LCBzdWJYfX0gPSAkJDtcclxuXHRcdGNvbnN0IHpvb21FbmFibGVkID0gY29uZmlnLnpvb21fZW5hYmxlZDtcclxuXHJcblx0XHRpZiAod2l0aFVwZGF0ZU9yZ1hEb21haW4pIHtcclxuXHRcdFx0eC5kb21haW4oZG9tYWluIHx8IHNvcnRWYWx1ZSgkJC5nZXRYRG9tYWluKHRhcmdldHMpKSk7XHJcblx0XHRcdG9yZy54RG9tYWluID0geC5kb21haW4oKTtcclxuXHJcblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcclxuXHJcblx0XHRcdHN1YlguZG9tYWluKHguZG9tYWluKCkpO1xyXG5cdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC5zY2FsZShzdWJYKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2l0aFVwZGF0ZVhEb21haW4pIHtcclxuXHRcdFx0Y29uc3QgZG9tYWluVmFsdWUgPSBkb21haW4gfHwgKCEkJC5icnVzaCB8fCBicnVzaEVtcHR5KCQkKSkgP1xyXG5cdFx0XHRcdG9yZy54RG9tYWluIDogZ2V0QnJ1c2hTZWxlY3Rpb24oJCQpLm1hcChzdWJYLmludmVydCk7XHJcblxyXG5cdFx0XHR4LmRvbWFpbihkb21haW5WYWx1ZSk7XHJcblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUcmltIGRvbWFpbiB3aGVuIHRvbyBiaWcgYnkgem9vbSBtb3VzZW1vdmUgZXZlbnRcclxuXHRcdHdpdGhUcmltICYmIHguZG9tYWluKCQkLnRyaW1YRG9tYWluKHgub3JnRG9tYWluKCkpKTtcclxuXHJcblx0XHRyZXR1cm4geC5kb21haW4oKTtcclxuXHR9LFxyXG5cclxuXHR0cmltWERvbWFpbihkb21haW4pIHtcclxuXHRcdGNvbnN0IHpvb21Eb21haW4gPSB0aGlzLmdldFpvb21Eb21haW4oKTtcclxuXHRcdGNvbnN0IFttaW4sIG1heF0gPSB6b29tRG9tYWluO1xyXG5cclxuXHRcdGlmIChkb21haW5bMF0gPD0gbWluKSB7XHJcblx0XHRcdGRvbWFpblsxXSA9ICtkb21haW5bMV0gKyAobWluIC0gZG9tYWluWzBdKTtcclxuXHRcdFx0ZG9tYWluWzBdID0gbWluO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXggPD0gZG9tYWluWzFdKSB7XHJcblx0XHRcdGRvbWFpblswXSA9ICtkb21haW5bMF0gLSAoZG9tYWluWzFdIC0gbWF4KTtcclxuXHRcdFx0ZG9tYWluWzFdID0gbWF4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkb21haW47XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0VHlwZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7QXhpc1R5cGV9IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuLyoqXHJcbiAqIEdldCBmb3JtYXR0ZWRcclxuICogQHBhcmFtIHtvYmplY3R9ICQkIENvbnRleHRcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVWYWx1ZSBBeGlzIHR5cGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHYgVmFsdWUgdG8gYmUgZm9ybWF0dGVkXHJcbiAqIEByZXR1cm5zIHtudW1iZXIgfCBzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGb3JtYXQoJCQsIHR5cGVWYWx1ZTogQXhpc1R5cGUsIHY6IG51bWJlcik6IG51bWJlciB8IHN0cmluZyB7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRjb25zdCB0eXBlID0gYGF4aXNfJHt0eXBlVmFsdWV9X3RpY2tfZm9ybWF0YDtcclxuXHRjb25zdCBmb3JtYXQgPSBjb25maWdbdHlwZV0gP1xyXG5cdFx0Y29uZmlnW3R5cGVdIDogJCQuZGVmYXVsdFZhbHVlRm9ybWF0O1xyXG5cclxuXHRyZXR1cm4gZm9ybWF0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0WUZvcm1hdChmb3JBcmM6IGJvb2xlYW4pOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQge3lGb3JtYXQsIHkyRm9ybWF0fSA9ICQkO1xyXG5cclxuXHRcdGlmIChmb3JBcmMgJiYgISQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHR5Rm9ybWF0ID0gJCQuZGVmYXVsdEFyY1ZhbHVlRm9ybWF0O1xyXG5cdFx0XHR5MkZvcm1hdCA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24odiwgcmF0aW8sIGlkKSB7XHJcblx0XHRcdGNvbnN0IGZvcm1hdCA9ICQkLmF4aXMgJiYgJCQuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIiA/XHJcblx0XHRcdFx0eTJGb3JtYXQgOiB5Rm9ybWF0O1xyXG5cclxuXHRcdFx0cmV0dXJuIGZvcm1hdC5jYWxsKCQkLCB2LCByYXRpbyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdHlGb3JtYXQodjogbnVtYmVyKTogbnVtYmVyIHwgc3RyaW5nIHtcclxuXHRcdHJldHVybiBnZXRGb3JtYXQodGhpcywgXCJ5XCIsIHYpO1xyXG5cdH0sXHJcblxyXG5cdHkyRm9ybWF0KHY6IG51bWJlcik6IG51bWJlciB8IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gZ2V0Rm9ybWF0KHRoaXMsIFwieTJcIiwgdik7XHJcblx0fSxcclxuXHJcblx0ZGVmYXVsdFZhbHVlRm9ybWF0KHYpOiBudW1iZXIgfCBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIGlzVmFsdWUodikgPyArdiA6IFwiXCI7XHJcblx0fSxcclxuXHJcblx0ZGVmYXVsdEFyY1ZhbHVlRm9ybWF0KHYsIHJhdGlvKTogc3RyaW5nIHtcclxuXHRcdHJldHVybiBgJHsocmF0aW8gKiAxMDApLnRvRml4ZWQoMSl9JWA7XHJcblx0fSxcclxuXHJcblx0ZGF0YUxhYmVsRm9ybWF0KHRhcmdldElkOiBzdHJpbmcpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzO1xyXG5cdFx0Y29uc3QgZGVmYXVsdEZvcm1hdCA9IHYgPT4gKGlzVmFsdWUodikgPyArdiA6IFwiXCIpO1xyXG5cdFx0bGV0IGZvcm1hdCA9IGRlZmF1bHRGb3JtYXQ7XHJcblxyXG5cdFx0Ly8gZmluZCBmb3JtYXQgYWNjb3JkaW5nIHRvIGF4aXMgaWRcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGRhdGFMYWJlbHMuZm9ybWF0KSkge1xyXG5cdFx0XHRmb3JtYXQgPSBkYXRhTGFiZWxzLmZvcm1hdDtcclxuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3RUeXBlKGRhdGFMYWJlbHMuZm9ybWF0KSkge1xyXG5cdFx0XHRpZiAoZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdKSB7XHJcblx0XHRcdFx0Zm9ybWF0ID0gZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdID09PSB0cnVlID9cclxuXHRcdFx0XHRcdGRlZmF1bHRGb3JtYXQgOiBkYXRhTGFiZWxzLmZvcm1hdFt0YXJnZXRJZF07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9ybWF0ID0gKCkgPT4gXCJcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmb3JtYXQuYmluZCgkJC5hcGkpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50LFxyXG5cdG5hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2NhbGxGbiwgaXNEZWZpbmVkLCBnZXRPcHRpb24sIGlzRW1wdHksIGlzRnVuY3Rpb24sIG5vdEVtcHR5LCB0cGxQcm9jZXNzfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0TGVnZW5kKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLmxlZ2VuZEl0ZW1UZXh0Qm94ID0ge307XHJcblx0XHQkJC5zdGF0ZS5sZWdlbmRIYXNSZW5kZXJlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0aWYgKCFjb25maWcubGVnZW5kX2NvbnRlbnRzX2JpbmR0bykge1xyXG5cdFx0XHRcdCRlbC5sZWdlbmQgPSAkJC4kZWwuc3ZnLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZCwgdHJ1ZSlcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE1FTU86IGNhbGwgaGVyZSB0byB1cGRhdGUgbGVnZW5kIGJveCBhbmQgdHJhbnNsYXRlIGZvciBhbGxcclxuXHRcdFx0Ly8gTUVNTzogdHJhbnNsYXRlIHdpbGwgYmUgdXBkYXRlZCBieSB0aGlzLCBzbyB0cmFuc2Zvcm0gbm90IG5lZWRlZCBpbiB1cGRhdGVMZWdlbmQoKVxyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLnN0YXRlLmhpZGRlbkxlZ2VuZElkcyA9ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGxlZ2VuZCBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgd2l0aFRyYW5zZm9ybSA6IFdoZXRoZXIgdG8gdXNlIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogV2hldGhlciB0cmFuc2l0aW9uIGlzIHVzZWQgd2hlbiB1c2luZyB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb24gOiB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0cmFuc2l0aW9ucyBSZXR1cm4gdmFsdWUgb2YgdGhlIGdlbmVyYXRlVHJhbnNpdGlvbnNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZCh0YXJnZXRJZHMsIG9wdGlvbnMsIHRyYW5zaXRpb25zKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgc2NhbGUsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IG9wdGlvbnogPSBvcHRpb25zIHx8IHtcclxuXHRcdFx0d2l0aFRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBmYWxzZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlXHJcblx0XHR9O1xyXG5cclxuXHRcdG9wdGlvbnoud2l0aFRyYW5zaXRpb24gPSBnZXRPcHRpb24ob3B0aW9ueiwgXCJ3aXRoVHJhbnNpdGlvblwiLCB0cnVlKTtcclxuXHRcdG9wdGlvbnoud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0gPSBnZXRPcHRpb24ob3B0aW9ueiwgXCJ3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybVwiLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9jb250ZW50c19iaW5kdG8gJiYgY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZSkge1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRUZW1wbGF0ZSgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kRWxlbWVudChcclxuXHRcdFx0XHR0YXJnZXRJZHMgfHwgJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSxcclxuXHRcdFx0XHRvcHRpb256LFxyXG5cdFx0XHRcdHRyYW5zaXRpb25zXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdG9nZ2xlIGxlZ2VuZCBzdGF0ZVxyXG5cdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUhpZGRlbiwgaWQgPT4gISQkLmlzVGFyZ2V0VG9TaG93KGlkKSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIHNpemUgYW5kIHNjYWxlXHJcblx0XHQkJC51cGRhdGVTY2FsZXMoZmFsc2UsICFzY2FsZS56b29tKTtcclxuXHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgZyBwb3NpdGlvbnNcclxuXHRcdCQkLnRyYW5zZm9ybUFsbChvcHRpb256LndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtLCB0cmFuc2l0aW9ucyk7XHJcblxyXG5cdFx0c3RhdGUubGVnZW5kSGFzUmVuZGVyZWQgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgdXNpbmcgdGVtcGxhdGUgb3B0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRUZW1wbGF0ZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHdyYXBwZXIgPSBkM1NlbGVjdChjb25maWcubGVnZW5kX2NvbnRlbnRzX2JpbmR0byk7XHJcblx0XHRjb25zdCB0ZW1wbGF0ZSA9IGNvbmZpZy5sZWdlbmRfY29udGVudHNfdGVtcGxhdGU7XHJcblxyXG5cdFx0aWYgKCF3cmFwcGVyLmVtcHR5KCkpIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblx0XHRcdGNvbnN0IGlkczogYW55W10gPSBbXTtcclxuXHRcdFx0bGV0IGh0bWwgPSBcIlwiO1xyXG5cclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGNvbnRlbnQgPSBpc0Z1bmN0aW9uKHRlbXBsYXRlKSA/XHJcblx0XHRcdFx0XHR0ZW1wbGF0ZS5iaW5kKCQkLmFwaSkodiwgJCQuY29sb3IodiksICQkLmFwaS5kYXRhKHYpWzBdLnZhbHVlcykgOlxyXG5cdFx0XHRcdFx0dHBsUHJvY2Vzcyh0ZW1wbGF0ZSwge1xyXG5cdFx0XHRcdFx0XHRDT0xPUjogJCQuY29sb3IodiksXHJcblx0XHRcdFx0XHRcdFRJVExFOiB2XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0aWYgKGNvbnRlbnQpIHtcclxuXHRcdFx0XHRcdGlkcy5wdXNoKHYpO1xyXG5cdFx0XHRcdFx0aHRtbCArPSBjb250ZW50O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25zdCBsZWdlbmRJdGVtID0gd3JhcHBlci5odG1sKGh0bWwpXHJcblx0XHRcdFx0LnNlbGVjdEFsbChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY2hpbGROb2RlczsgfSlcclxuXHRcdFx0XHQuZGF0YShpZHMpO1xyXG5cclxuXHRcdFx0JCQuc2V0TGVnZW5kSXRlbShsZWdlbmRJdGVtKTtcclxuXHJcblx0XHRcdCRlbC5sZWdlbmQgPSB3cmFwcGVyO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgbGVnZW5kLlxyXG5cdCAqIEBwYXJhbSB7T2JlamN0fSBzaXplIFNpemUgb2JqZWN0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVTaXplRm9yTGVnZW5kKHNpemUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7XHJcblx0XHRcdGlzTGVnZW5kVG9wLCBpc0xlZ2VuZExlZnQsIGlzTGVnZW5kUmlnaHQsIGlzTGVnZW5kSW5zZXQsIGN1cnJlbnRcclxuXHRcdH19ID0gJCQ7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xyXG5cclxuXHRcdGNvbnN0IGluc2V0TGVnZW5kUG9zaXRpb24gPSB7XHJcblx0XHRcdHRvcDogaXNMZWdlbmRUb3AgP1xyXG5cdFx0XHRcdCQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCkgKyBjb25maWcubGVnZW5kX2luc2V0X3kgKyA1LjUgOlxyXG5cdFx0XHRcdGN1cnJlbnQuaGVpZ2h0IC0gaGVpZ2h0IC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20oKSAtIGNvbmZpZy5sZWdlbmRfaW5zZXRfeSxcclxuXHRcdFx0bGVmdDogaXNMZWdlbmRMZWZ0ID9cclxuXHRcdFx0XHQkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeCArIDAuNSA6XHJcblx0XHRcdFx0Y3VycmVudC53aWR0aCAtIHdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF94ICsgMC41XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLnN0YXRlLm1hcmdpbjMgPSB7XHJcblx0XHRcdHRvcDogaXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0MCA6IGlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLnRvcCA6IGN1cnJlbnQuaGVpZ2h0IC0gaGVpZ2h0LFxyXG5cdFx0XHRyaWdodDogTmFOLFxyXG5cdFx0XHRib3R0b206IDAsXHJcblx0XHRcdGxlZnQ6IGlzTGVnZW5kUmlnaHQgP1xyXG5cdFx0XHRcdGN1cnJlbnQud2lkdGggLSB3aWR0aCA6IGlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLmxlZnQgOiAwXHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYW5zZm9ybSBMZWdlbmRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uIHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0cmFuc2Zvcm1MZWdlbmQod2l0aFRyYW5zaXRpb24pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtsZWdlbmR9ID0gJCQuJGVsO1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxlZ2VuZC50cmFuc2l0aW9uKCkgOiBsZWdlbmQpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBsZWdlbmQgc3RlcFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzdGVwIFN0ZXAgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLnN0YXRlLmxlZ2VuZFN0ZXAgPSBzdGVwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSB3aWR0aFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kSXRlbVdpZHRoKHdpZHRoOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdHRoaXMuc3RhdGUubGVnZW5kSXRlbVdpZHRoID0gd2lkdGg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGxlZ2VuZCBpdGVtIGhlaWdodFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0KGhlaWdodCk6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5sZWdlbmRJdGVtSGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSBjb2xvclxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb3JyZXNwb25kaW5nIGRhdGEgSUQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29sb3IgQ29sb3IgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcihpZDogc3RyaW5nLCBjb2xvcjogc3RyaW5nKTogdm9pZCB7XHJcblx0XHR0aGlzLiRlbC5sZWdlbmQuc2VsZWN0KGAuJHtDTEFTUy5sZWdlbmRJdGVtfS0ke2lkfSBsaW5lYClcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIGNvbG9yKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHdpZHRoIG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB3aWR0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0TGVnZW5kV2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjdXJyZW50OiB7d2lkdGh9LCBpc0xlZ2VuZFJpZ2h0LCBpc0xlZ2VuZEluc2V0LCBsZWdlbmRJdGVtV2lkdGgsIGxlZ2VuZFN0ZXB9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/IChcclxuXHRcdFx0aXNMZWdlbmRSaWdodCB8fCBpc0xlZ2VuZEluc2V0ID9cclxuXHRcdFx0XHRsZWdlbmRJdGVtV2lkdGggKiAobGVnZW5kU3RlcCArIDEpIDogd2lkdGhcclxuXHRcdCkgOiAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgaGVpZ2h0IG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBoZWlnaHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldExlZ2VuZEhlaWdodCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2N1cnJlbnQsIGlzTGVnZW5kUmlnaHQsIGxlZ2VuZEl0ZW1IZWlnaHQsIGxlZ2VuZFN0ZXB9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5sZWdlbmRfc2hvdyA/IChcclxuXHRcdFx0aXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0Y3VycmVudC5oZWlnaHQgOiBNYXRoLm1heCgyMCwgbGVnZW5kSXRlbUhlaWdodCkgKiAobGVnZW5kU3RlcCArIDEpXHJcblx0XHQpIDogMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBsZWdlbmRJdGVtIExlZ2VuZCBpdGVtIG5vZGVcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IG9wYWNpdHlcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9wYWNpdHlGb3JMZWdlbmQobGVnZW5kSXRlbSk6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0cmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjFcIjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG9wYWNpdHkgb2YgdGhlIGxlZ2VuZCB0aGF0IGlzIHVuZm9jdXNlZFxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBsZWdlbmRJdGVtIExlZ2VuZCBpdGVtIG5vZGVcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IG9wYWNpdHlcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQobGVnZW5kSXRlbSk6IHN0cmluZyB8IG51bGwge1xyXG5cdFx0cmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjAuM1wiO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIGZvY3VzIG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGZvY3VzIHdoZXRoZXIgb3Igbm90IHRvIGZvY3VzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzOiBzdHJpbmdbXSwgZm9jdXM6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtsZWdlbmR9ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWR6ID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKTtcclxuXHJcblx0XHRsZWdlbmQgJiYgbGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxyXG5cdFx0XHQuZmlsdGVyKGlkID0+IHRhcmdldElkei5pbmRleE9mKGlkKSA+PSAwKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZm9jdXMpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKDEwMClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gKGZvY3VzID8gJCQub3BhY2l0eUZvckxlZ2VuZCA6ICQkLm9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQpXHJcblx0XHRcdFx0XHQuY2FsbCgkJCwgZDNTZWxlY3QodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXZlcnQgdGhlIGxlZ2VuZCB0byBpdHMgZGVmYXVsdCBzdGF0ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmV2ZXJ0TGVnZW5kKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2xlZ2VuZH0gPSAkJC4kZWw7XHJcblxyXG5cdFx0bGVnZW5kICYmIGxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZhbHNlKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoZDNTZWxlY3QodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93cyB0aGUgbGVnZW5kXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0SWRzIElEJ3Mgb2YgdGFyZ2V0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzaG93TGVnZW5kKHRhcmdldElkczogc3RyaW5nW10pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHRjb25maWcubGVnZW5kX3Nob3cgPSB0cnVlO1xyXG5cclxuXHRcdFx0JGVsLmxlZ2VuZCA/XHJcblx0XHRcdFx0JGVsLmxlZ2VuZC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpIDpcclxuXHRcdFx0XHQkJC5pbml0TGVnZW5kKCk7XHJcblxyXG5cdFx0XHQhJCQuc3RhdGUubGVnZW5kSGFzUmVuZGVyZWQgJiYgJCQudXBkYXRlTGVnZW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQucmVtb3ZlSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCQub3BhY2l0eUZvckxlZ2VuZChkM1NlbGVjdCh0aGlzKSk7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGlkZUxlZ2VuZCh0YXJnZXRJZHM6IHN0cmluZ1tdKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgaXNFbXB0eSh0YXJnZXRJZHMpKSB7XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xyXG5cdFx0XHRsZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xyXG5cdFx0bGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgbGVnZW5kIGl0ZW0gdGV4dGJveCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgRGF0YSBJRFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSB0ZXh0RWxlbWVudCBUZXh0IG5vZGUgZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IEJvdW5kaW5nIHJlY3RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldExlZ2VuZEl0ZW1UZXh0Qm94KGlkPzogc3RyaW5nLCB0ZXh0RWxlbWVudD8pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjYWNoZX0gPSAkJDtcclxuXHRcdGxldCBkYXRhO1xyXG5cclxuXHRcdC8vIGRvIG5vdCBwcmVmaXggdy8nJCcsIHRvIG5vdCBiZSByZXNldHRlZCBjYWNoZSBpbiAubG9hZCgpIGNhbGxcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gS0VZLmxlZ2VuZEl0ZW1UZXh0Qm94O1xyXG5cclxuXHRcdGlmIChpZCkge1xyXG5cdFx0XHRkYXRhID0gY2FjaGUuZ2V0KGNhY2hlS2V5KSB8fCB7fTtcclxuXHJcblx0XHRcdGlmICghZGF0YVtpZF0pIHtcclxuXHRcdFx0XHRkYXRhW2lkXSA9ICQkLmdldFRleHRSZWN0KHRleHRFbGVtZW50LCBDTEFTUy5sZWdlbmRJdGVtKTtcclxuXHRcdFx0XHRjYWNoZS5hZGQoY2FjaGVLZXksIGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkYXRhID0gZGF0YVtpZF07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxlZ2VuZCBpdGVtIHN0eWxlICYgYmluZCBldmVudHNcclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gaXRlbSBJdGVtIG5vZGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldExlZ2VuZEl0ZW0oaXRlbSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2FwaSwgY29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cclxuXHRcdGl0ZW1cclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihpZCkge1xyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpdGVtQ2xhc3MgPSAoIW5vZGUuZW1wdHkoKSAmJiBub2RlLmF0dHIoXCJjbGFzc1wiKSkgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGl0ZW1DbGFzcyArICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGVnZW5kSXRlbSwgaWQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGlkID0+ICgkJC5pc0xlZ2VuZFRvU2hvdyhpZCkgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGlkID0+IHtcclxuXHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25jbGljaywgYXBpLCBpZCkpIHtcclxuXHRcdFx0XHRcdGlmIChkM0V2ZW50LmFsdEtleSkge1xyXG5cdFx0XHRcdFx0XHRhcGkuaGlkZSgpO1xyXG5cdFx0XHRcdFx0XHRhcGkuc2hvdyhpZCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRhcGkudG9nZ2xlKGlkKTtcclxuXHRcdFx0XHRcdFx0IWlzVG91Y2ggJiYgJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gYXBpLmZvY3VzKGlkKSA6IGFwaS5yZXZlcnQoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlzVG91Y2ggJiYgJCQuaGlkZVRvb2x0aXAoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFpc1RvdWNoKSB7XHJcblx0XHRcdGl0ZW1cclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihpZCkge1xyXG5cdFx0XHRcdFx0aWYgKCFjYWxsRm4oY29uZmlnLmxlZ2VuZF9pdGVtX29ub3V0LCBhcGksIGlkKSkge1xyXG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoaGFzR2F1Z2UpIHtcclxuXHRcdFx0XHRcdFx0XHQkJC51bmRvTWFya092ZXJsYXBwZWQoJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQkJC5hcGkucmV2ZXJ0KCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oaWQpIHtcclxuXHRcdFx0XHRcdGlmICghY2FsbEZuKGNvbmZpZy5sZWdlbmRfaXRlbV9vbm92ZXIsIGFwaSwgaWQpKSB7XHJcblx0XHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0JCQubWFya092ZXJsYXBwZWQoaWQsICQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCFzdGF0ZS50cmFuc2l0aW5nICYmICQkLmlzVGFyZ2V0VG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdFx0XHRcdGFwaS5mb2N1cyhpZCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEVsZW1lbnQodGFyZ2V0SWRzOiBzdHJpbmdbXSwgb3B0aW9ucyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge2xlZ2VuZH19ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nVG9wID0gNDtcclxuXHRcdGNvbnN0IHBhZGRpbmdSaWdodCA9IDEwO1xyXG5cdFx0Y29uc3QgcG9zTWluID0gMTA7XHJcblx0XHRjb25zdCB0aWxlV2lkdGggPSBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aCArIDU7XHJcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xyXG5cdFx0bGV0IG1heEhlaWdodCA9IDA7XHJcblx0XHRsZXQgeEZvckxlZ2VuZDtcclxuXHRcdGxldCB5Rm9yTGVnZW5kO1xyXG5cdFx0bGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuXHRcdGNvbnN0IG9mZnNldHMgPSB7fTtcclxuXHRcdGNvbnN0IHdpZHRocyA9IHt9O1xyXG5cdFx0Y29uc3QgaGVpZ2h0cyA9IHt9O1xyXG5cdFx0Y29uc3QgbWFyZ2lucyA9IFswXTtcclxuXHRcdGNvbnN0IHN0ZXBzID0ge307XHJcblx0XHRsZXQgc3RlcCA9IDA7XHJcblx0XHRsZXQgYmFja2dyb3VuZDtcclxuXHRcdGNvbnN0IGlzTGVnZW5kUmlnaHRPckluc2V0ID0gc3RhdGUuaXNMZWdlbmRSaWdodCB8fCBzdGF0ZS5pc0xlZ2VuZEluc2V0O1xyXG5cclxuXHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXHJcblx0XHRjb25zdCB0YXJnZXRJZHogPSB0YXJnZXRJZHNcclxuXHRcdFx0LmZpbHRlcihpZCA9PiAhaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgfHwgY29uZmlnLmRhdGFfbmFtZXNbaWRdICE9PSBudWxsKTtcclxuXHJcblx0XHRjb25zdCB3aXRoVHJhbnNpdGlvbiA9IG9wdGlvbnMud2l0aFRyYW5zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24odGV4dEVsZW1lbnQsIGlkLCBpbmRleCkge1xyXG5cdFx0XHRjb25zdCByZXNldCA9IGluZGV4ID09PSAwO1xyXG5cdFx0XHRjb25zdCBpc0xhc3QgPSBpbmRleCA9PT0gdGFyZ2V0SWR6Lmxlbmd0aCAtIDE7XHJcblx0XHRcdGNvbnN0IGJveCA9ICQkLmdldExlZ2VuZEl0ZW1UZXh0Qm94KGlkLCB0ZXh0RWxlbWVudCk7XHJcblx0XHRcdGNvbnN0IGl0ZW1XaWR0aCA9IGJveC53aWR0aCArIHRpbGVXaWR0aCArXHJcblx0XHRcdFx0KGlzTGFzdCAmJiAhaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAwIDogcGFkZGluZ1JpZ2h0KSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZztcclxuXHRcdFx0Y29uc3QgaXRlbUhlaWdodCA9IGJveC5oZWlnaHQgKyBwYWRkaW5nVG9wO1xyXG5cdFx0XHRjb25zdCBpdGVtTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBpdGVtSGVpZ2h0IDogaXRlbVdpZHRoO1xyXG5cdFx0XHRjb25zdCBhcmVhTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6ICQkLmdldExlZ2VuZFdpZHRoKCk7XHJcblx0XHRcdGxldCBtYXJnaW47XHJcblxyXG5cdFx0XHQvLyBNRU1POiBjYXJlIGFib3V0IGNvbmRpZmlvbiBvZiBzdGVwLCB0b3RhbExlbmd0aFxyXG5cdFx0XHRjb25zdCB1cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbihpZDIsIHdpdGhvdXRTdGVwPzogYm9vbGVhbikge1xyXG5cdFx0XHRcdGlmICghd2l0aG91dFN0ZXApIHtcclxuXHRcdFx0XHRcdG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gdG90YWxMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIGl0ZW1MZW5ndGgpIC8gMjtcclxuXHRcdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0XHRzdGVwKys7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGVwc1tpZDJdID0gc3RlcDtcclxuXHRcdFx0XHRtYXJnaW5zW3N0ZXBdID0gc3RhdGUuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luO1xyXG5cdFx0XHRcdG9mZnNldHNbaWQyXSA9IHRvdGFsTGVuZ3RoO1xyXG5cdFx0XHRcdHRvdGFsTGVuZ3RoICs9IGl0ZW1MZW5ndGg7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAocmVzZXQpIHtcclxuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDA7XHJcblx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0bWF4V2lkdGggPSAwO1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IDA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgISQkLmlzTGVnZW5kVG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdHdpZHRoc1tpZF0gPSAwO1xyXG5cdFx0XHRcdGhlaWdodHNbaWRdID0gMDtcclxuXHRcdFx0XHRzdGVwc1tpZF0gPSAwO1xyXG5cdFx0XHRcdG9mZnNldHNbaWRdID0gMDtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aWR0aHNbaWRdID0gaXRlbVdpZHRoO1xyXG5cdFx0XHRoZWlnaHRzW2lkXSA9IGl0ZW1IZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkge1xyXG5cdFx0XHRcdG1heFdpZHRoID0gaXRlbVdpZHRoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW1heEhlaWdodCB8fCBpdGVtSGVpZ2h0ID49IG1heEhlaWdodCkge1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IGl0ZW1IZWlnaHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1heExlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gbWF4SGVpZ2h0IDogbWF4V2lkdGg7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmxlZ2VuZF9lcXVhbGx5KSB7XHJcblx0XHRcdFx0T2JqZWN0LmtleXMod2lkdGhzKS5mb3JFYWNoKGlkMiA9PiAod2lkdGhzW2lkMl0gPSBtYXhXaWR0aCkpO1xyXG5cdFx0XHRcdE9iamVjdC5rZXlzKGhlaWdodHMpLmZvckVhY2goaWQyID0+IChoZWlnaHRzW2lkMl0gPSBtYXhIZWlnaHQpKTtcclxuXHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIG1heExlbmd0aCAqIHRhcmdldElkei5sZW5ndGgpIC8gMjtcclxuXHJcblx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0XHR0YXJnZXRJZHouZm9yRWFjaChpZDIgPT4gdXBkYXRlVmFsdWVzKGlkMikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHN0ZXAgPSBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgPyBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgOiB0YXJnZXRJZHoubGVuZ3RoO1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXTtcclxuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xyXG5cdFx0fSBlbHNlIGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXSArIDEwO1xyXG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXhIZWlnaHQgKiBzdGVwc1tpZF07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFRleHQgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpICsgNCArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFJlY3QgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpO1xyXG5cdFx0Y29uc3QgeDFGb3JMZWdlbmRUaWxlID0gKGlkLCBpPzogbnVtYmVyKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDI7XHJcblx0XHRjb25zdCB4MkZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpIC0gMiArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cclxuXHRcdGNvbnN0IHlGb3JMZWdlbmRUZXh0ID0gKGlkLCBpPzogbnVtYmVyKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDk7XHJcblx0XHRjb25zdCB5Rm9yTGVnZW5kUmVjdCA9IChpZCwgaT86IG51bWJlcikgPT4geUZvckxlZ2VuZChpZCwgaSkgLSA1O1xyXG5cdFx0Y29uc3QgeUZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHlGb3JMZWdlbmQoaWQsIGkpICsgNDtcclxuXHJcblx0XHRjb25zdCBwb3MgPSAtMjAwO1xyXG5cclxuXHRcdC8vIERlZmluZSBnIGZvciBsZWdlbmQgYXJlYVxyXG5cdFx0Y29uc3QgbCA9IGxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHQkJC5zZXRMZWdlbmRJdGVtKGwpO1xyXG5cclxuXHRcdGwuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRUZXh0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGV4dCk7XHJcblxyXG5cdFx0bC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbUV2ZW50KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRSZWN0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kUmVjdCk7XHJcblxyXG5cdFx0Y29uc3QgdXNlUG9pbnQgPSBjb25maWcubGVnZW5kX3VzZVBvaW50O1xyXG5cclxuXHRcdGlmICh1c2VQb2ludCkge1xyXG5cdFx0XHRjb25zdCBpZHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0XHRsLmFwcGVuZChkID0+IHtcclxuXHRcdFx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID9cclxuXHRcdFx0XHRcdGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcclxuXHJcblx0XHRcdFx0aWRzLmluZGV4T2YoZCkgPT09IC0xICYmIGlkcy5wdXNoKGQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGQpICUgcGF0dGVybi5sZW5ndGhdO1xyXG5cclxuXHRcdFx0XHRpZiAocG9pbnQgPT09IFwicmVjdGFuZ2xlXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50ID0gXCJyZWN0XCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsICQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSA/IHBvaW50IDogXCJ1c2VcIik7XHJcblx0XHRcdH0pXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRJdGVtUG9pbnQpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiaHJlZlwiLCAoZGF0YSwgaWR4LCBzZWxlY3Rpb24pID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25baWR4XTtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSA9PT0gXCJ1c2VcIiA/IGAjJHtzdGF0ZS5kYXRldGltZUlkfS1wb2ludC0ke2RhdGF9YCA6IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGwuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbVRpbGUpXHJcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MUZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MkZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX2hlaWdodCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IGJhY2tncm91bmQgZm9yIGluc2V0IGxlZ2VuZFxyXG5cdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEJhY2tncm91bmR9IHJlY3RgKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRJbnNldCAmJiBtYXhXaWR0aCA+IDAgJiYgYmFja2dyb3VuZC5zaXplKCkgPT09IDApIHtcclxuXHRcdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRCYWNrZ3JvdW5kKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHRzID0gbGVnZW5kLnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpIC8vIE1FTU86IG5lZWRlZCBmb3IgdXBkYXRlXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXHJcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JMZWdlbmRUZXh0KTtcclxuXHJcblx0XHRjb25zdCByZWN0cyA9IGxlZ2VuZC5zZWxlY3RBbGwoYHJlY3QuJHtDTEFTUy5sZWdlbmRJdGVtRXZlbnR9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KTtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyByZWN0cy50cmFuc2l0aW9uKCkgOiByZWN0cylcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBpZCA9PiB3aWR0aHNbaWRdKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBpZCA9PiBoZWlnaHRzW2lkXSlcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIHhGb3JMZWdlbmRSZWN0KVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeUZvckxlZ2VuZFJlY3QpO1xyXG5cclxuXHJcblx0XHRpZiAodXNlUG9pbnQpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBsZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtUG9pbnR9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xyXG5cclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0XHRcdFx0bGV0IHggPSBcInhcIjtcclxuXHRcdFx0XHRcdGxldCB5ID0gXCJ5XCI7XHJcblx0XHRcdFx0XHRsZXQgeE9mZnNldCA9IDI7XHJcblx0XHRcdFx0XHRsZXQgeU9mZnNldCA9IDIuNTtcclxuXHRcdFx0XHRcdGxldCByYWRpdXM7XHJcblx0XHRcdFx0XHRsZXQgd2lkdGg7XHJcblx0XHRcdFx0XHRsZXQgaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdGlmIChub2RlTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaXplID0gcG9pbnRSICogMC4yO1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IFwiY3hcIjtcclxuXHRcdFx0XHRcdFx0eSA9IFwiY3lcIjtcclxuXHRcdFx0XHRcdFx0cmFkaXVzID0gcG9pbnRSICsgc2l6ZTtcclxuXHRcdFx0XHRcdFx0eE9mZnNldCA9IHBvaW50UiAqIDI7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAtc2l6ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFwicmVjdFwiKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSBwb2ludFIgKiAyLjU7XHJcblxyXG5cdFx0XHRcdFx0XHR3aWR0aCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdGhlaWdodCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAzO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKHgsIGQgPT4geDFGb3JMZWdlbmRUaWxlKGQpICsgeE9mZnNldClcclxuXHRcdFx0XHRcdFx0LmF0dHIoeSwgZCA9PiB5Rm9yTGVnZW5kVGlsZShkKSAtIHlPZmZzZXQpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiclwiLCByYWRpdXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCB0aWxlcyA9IGxlZ2VuZC5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy5sZWdlbmRJdGVtVGlsZX1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldElkeik7XHJcblxyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aWxlcy50cmFuc2l0aW9uKCkgOiB0aWxlcylcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQubGV2ZWxDb2xvciA/IGlkID0+ICQkLmxldmVsQ29sb3IoJCQuY2FjaGUuZ2V0KGlkKS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4MUZvckxlZ2VuZFRpbGUpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5Rm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIHgyRm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcInkyXCIsIHlGb3JMZWdlbmRUaWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYmFja2dyb3VuZCkge1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgLSAxMilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIG1heFdpZHRoICogKHN0ZXAgKyAxKSArIDEwKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVcGRhdGUgYWxsIHRvIHJlZmxlY3QgY2hhbmdlIG9mIGxlZ2VuZFxyXG5cdFx0JCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobWF4SGVpZ2h0KTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7dHJhbnNpdGlvbiBhcyBkM1RyYW5zaXRpb259IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZW5lcmF0ZVdhaXR9IGZyb20gXCIuLi8uLi9tb2R1bGUvZ2VuZXJhdG9yXCI7XHJcbmltcG9ydCB7Y2FsbEZuLCBnZXRPcHRpb24sIGlzVGFiVmlzaWJsZSwgbm90RW1wdHl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdHJlZHJhdyhvcHRpb25zOiBhbnkgPSB7fSwgdHJhbnNpdGlvbnNWYWx1ZT8pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkZWw7XHJcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdGNvbnN0IGluaXRpYWxpemluZyA9IG9wdGlvbnMuaW5pdGlhbGl6aW5nO1xyXG5cdFx0Y29uc3QgZmxvdyA9IG9wdGlvbnMuZmxvdztcclxuXHRcdGNvbnN0IHd0aCA9ICQkLmdldFdpdGhPcHRpb24ob3B0aW9ucyk7XHJcblx0XHRjb25zdCBkdXJhdGlvbiA9IHd0aC5UcmFuc2l0aW9uID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JFeGl0ID0gd3RoLlRyYW5zaXRpb25Gb3JFeGl0ID8gZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JBeGlzID0gd3RoLlRyYW5zaXRpb25Gb3JBeGlzID8gZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uc1ZhbHVlIHx8ICgkJC5heGlzICYmICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbkZvckF4aXMpKTtcclxuXHJcblx0XHQkJC51cGRhdGVTaXplcyhpbml0aWFsaXppbmcpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBsZWdlbmQgYW5kIHRyYW5zZm9ybSBlYWNoIGdcclxuXHJcblx0XHRpZiAod3RoLkxlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kKCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyksIG9wdGlvbnMsIHRyYW5zaXRpb25zKTtcclxuXHRcdH0gZWxzZSBpZiAod3RoLkRpbWVuc2lvbikge1xyXG5cdFx0XHQvLyBuZWVkIHRvIHVwZGF0ZSBkaW1lbnNpb24gKGUuZy4gYXhpcy55LnRpY2sudmFsdWVzKSBiZWNhdXNlIHkgdGljayB2YWx1ZXMgc2hvdWxkIGNoYW5nZVxyXG5cdFx0XHQvLyBubyBuZWVkIHRvIHVwZGF0ZSBheGlzIGluIGl0IGJlY2F1c2UgdGhleSB3aWxsIGJlIHVwZGF0ZWQgaW4gcmVkcmF3KClcclxuXHRcdFx0JCQudXBkYXRlRGltZW5zaW9uKHRydWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRleHRcclxuXHRcdCQkLmhhc0RhdGFMYWJlbCgpICYmICQkLnVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2lyY2xlWSBiYXNlZCBvbiB1cGRhdGVkIHBhcmFtZXRlcnNcclxuXHRcdGlmICghJCQuaGFzQXJjVHlwZSgpIHx8IHN0YXRlLmhhc1JhZGFyKSB7XHJcblx0XHRcdCQkLnVwZGF0ZUNpcmNsZVkgJiYgJCQudXBkYXRlQ2lyY2xlWSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEBUT0RPOiBBeGlzICYgUmFkYXIgdHlwZVxyXG5cdFx0aWYgKCFzdGF0ZS5yZXNpemluZyAmJiAoJCQuaGFzUG9pbnRUeXBlKCkgfHwgc3RhdGUuaGFzUmFkYXIpKSB7XHJcblx0XHRcdCQkLnVwZGF0ZUNpcmNsZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBheGlzXHJcblx0XHRpZiAoc3RhdGUuaGFzQXhpcykge1xyXG5cdFx0XHQvLyBAVE9ETzogTWFrZSAnaW5pdCcgc3RhdGUgdG8gYmUgYWNjZXNzaWJsZSBldmVyeXdoZXJlIG5vdCBwYXNzaW5nIGFzIGFyZ3VtZW50LlxyXG5cdFx0XHQkJC5heGlzLnJlZHJhd0F4aXModGFyZ2V0c1RvU2hvdywgd3RoLCB0cmFuc2l0aW9ucywgZmxvdywgaW5pdGlhbGl6aW5nKTtcclxuXHJcblx0XHRcdC8vIERhdGEgZW1wdHkgbGFiZWwgcG9zaXRpb25pbmcgYW5kIHRleHQuXHJcblx0XHRcdGNvbmZpZy5kYXRhX2VtcHR5X2xhYmVsX3RleHQgJiYgbWFpbi5zZWxlY3QoYHRleHQuJHtDTEFTUy50ZXh0fS4ke0NMQVNTLmVtcHR5fWApXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIHN0YXRlLndpZHRoIC8gMilcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgc3RhdGUuaGVpZ2h0IC8gMilcclxuXHRcdFx0XHQudGV4dChjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0KVxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPyBcIm5vbmVcIiA6IG51bGwpO1xyXG5cclxuXHRcdFx0Ly8gZ3JpZFxyXG5cdFx0XHQkJC5oYXNHcmlkKCkgJiYgJCQudXBkYXRlR3JpZChkdXJhdGlvbik7XHJcblxyXG5cdFx0XHQvLyByZWN0IGZvciByZWdpb25zXHJcblx0XHRcdGNvbmZpZy5yZWdpb25zLmxlbmd0aCAmJiAkJC51cGRhdGVSZWdpb24oZHVyYXRpb24pO1xyXG5cclxuXHRcdFx0Ly8gYmFyc1xyXG5cdFx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmICQkLnVwZGF0ZUJhcihkdXJhdGlvbkZvckV4aXQpO1xyXG5cclxuXHRcdFx0Ly8gbGluZXMsIGFyZWFzIGFuZCBjaXJjbGVzXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlT2YoXCJMaW5lXCIpKSB7XHJcblx0XHRcdFx0JCQudXBkYXRlTGluZShkdXJhdGlvbkZvckV4aXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiQXJlYVwiKSkge1xyXG5cdFx0XHRcdCQkLnVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gY2lyY2xlcyBmb3Igc2VsZWN0XHJcblx0XHRcdCRlbC50ZXh0ICYmIG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZXN9YClcclxuXHRcdFx0XHQuZmlsdGVyKCQkLmlzQmFyVHlwZS5iaW5kKCQkKSlcclxuXHRcdFx0XHQuc2VsZWN0QWxsKFwiY2lyY2xlXCIpXHJcblx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0Ly8gZXZlbnQgcmVjdHMgd2lsbCByZWRyYXduIHdoZW4gZmxvdyBjYWxsZWRcclxuXHRcdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICFmbG93ICYmIHd0aC5FdmVudFJlY3QpIHtcclxuXHRcdFx0XHQkJC5iaW5kWm9vbUV2ZW50KCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGFyY1xyXG5cdFx0XHQkZWwuYXJjcyAmJiAkJC5yZWRyYXdBcmMoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCwgd3RoLlRyYW5zZm9ybSk7XHJcblxyXG5cdFx0XHQvLyByYWRhclxyXG5cdFx0XHQkZWwucmFkYXIgJiYgJCQucmVkcmF3UmFkYXIoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB0aXRsZVxyXG5cdFx0JCQucmVkcmF3VGl0bGUgJiYgJCQucmVkcmF3VGl0bGUoKTtcclxuXHJcblx0XHRpbml0aWFsaXppbmcgJiYgJCQudXBkYXRlVHlwZXNFbGVtZW50cygpO1xyXG5cclxuXHRcdCQkLmdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzVG9TaG93LCBmbG93LCBkdXJhdGlvbiwgd3RoLlN1YmNoYXJ0KTtcclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJHJlZHJhd1wiLCBvcHRpb25zLCBkdXJhdGlvbik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgcmVkcmF3IGxpc3RcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0cyB0YXJnZXRzIGRhdGEgdG8gYmUgc2hvd25cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZmxvdyBmbG93IG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBkdXJhdGlvbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFN1YmNoYXJ0IHdoZXRoZXIgb3Igbm90IHRvIHNob3cgc3ViY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzLCBmbG93OiBhbnksIGR1cmF0aW9uOiBudW1iZXIsIHdpdGhTdWJjaGFydDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBzaGFwZSA9ICQkLmdldERyYXdTaGFwZSgpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5oYXNBeGlzKSB7XHJcblx0XHRcdC8vIHN1YmNoYXJ0XHJcblx0XHRcdGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICQkLnJlZHJhd1N1YmNoYXJ0KHdpdGhTdWJjaGFydCwgZHVyYXRpb24sIHNoYXBlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBnZW5lcmF0ZSBmbG93XHJcblx0XHRjb25zdCBmbG93Rm4gPSBmbG93ICYmICQkLmdlbmVyYXRlRmxvdyh7XHJcblx0XHRcdHRhcmdldHMsXHJcblx0XHRcdGZsb3csXHJcblx0XHRcdGR1cmF0aW9uOiBmbG93LmR1cmF0aW9uLFxyXG5cdFx0XHRzaGFwZSxcclxuXHRcdFx0eHY6ICQkLnh2LmJpbmQoJCQpXHJcblx0XHR9KTtcclxuXHRcdGNvbnN0IGlzVHJhbnNpdGlvbiA9IChkdXJhdGlvbiB8fCBmbG93Rm4pICYmIGlzVGFiVmlzaWJsZSgpO1xyXG5cclxuXHRcdC8vIHJlZHJhdyBsaXN0XHJcblx0XHRjb25zdCByZWRyYXdMaXN0ID0gJCQuZ2V0UmVkcmF3TGlzdChzaGFwZSwgZmxvdywgZmxvd0ZuLCBpc1RyYW5zaXRpb24pO1xyXG5cclxuXHRcdC8vIGNhbGxiYWNrIGZ1bmN0aW9uIGFmdGVyIHJlZHJhdyBlbmRzXHJcblx0XHRjb25zdCBhZnRlclJlZHJhdyA9IGZsb3cgfHwgY29uZmlnLm9ucmVuZGVyZWQgPyAoKSA9PiB7XHJcblx0XHRcdGZsb3dGbiAmJiBmbG93Rm4oKTtcclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy5vbnJlbmRlcmVkLCAkJC5hcGkpO1xyXG5cdFx0fSA6IG51bGw7XHJcblxyXG5cdFx0aWYgKGFmdGVyUmVkcmF3KSB7XHJcblx0XHRcdC8vIE9ubHkgdXNlIHRyYW5zaXRpb24gd2hlbiBjdXJyZW50IHRhYiBpcyB2aXNpYmxlLlxyXG5cdFx0XHRpZiAoaXNUcmFuc2l0aW9uICYmIHJlZHJhd0xpc3QubGVuZ3RoKSB7XHJcblx0XHRcdFx0Ly8gV2FpdCBmb3IgZW5kIG9mIHRyYW5zaXRpb25zIGZvciBjYWxsYmFja1xyXG5cdFx0XHRcdGNvbnN0IHdhaXRGb3JEcmF3ID0gZ2VuZXJhdGVXYWl0KCk7XHJcblxyXG5cdFx0XHRcdC8vIHRyYW5zaXRpb24gc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSBvbmUgdHJhbnNpdGlvblxyXG5cdFx0XHRcdGQzVHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHRcdFx0LmVhY2goKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRyZWRyYXdMaXN0XHJcblx0XHRcdFx0XHRcdFx0LnJlZHVjZSgoYWNjLCB0MSkgPT4gYWNjLmNvbmNhdCh0MSksIFtdKVxyXG5cdFx0XHRcdFx0XHRcdC5mb3JFYWNoKHQgPT4gd2FpdEZvckRyYXcuYWRkKHQpKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQuY2FsbCh3YWl0Rm9yRHJhdywgYWZ0ZXJSZWRyYXcpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFzdGF0ZS50cmFuc2l0aW5nKSB7XHJcblx0XHRcdFx0YWZ0ZXJSZWRyYXcoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBmYWRlaW4gY29uZGl0aW9uXHJcblx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRzdGF0ZS53aXRob3V0RmFkZUluW2lkXSA9IHRydWU7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWRyYXdMaXN0KHNoYXBlLCBmbG93LCBmbG93Rm4sIGlzVHJhbnNpdGlvbjogYm9vbGVhbik6IEZ1bmN0aW9uW10ge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtoYXNBeGlzLCBoYXNSYWRhcn0sICRlbDoge2dyaWR9fSA9ICQkO1xyXG5cdFx0Y29uc3Qge2N4LCBjeSwgeEZvclRleHQsIHlGb3JUZXh0fSA9IHNoYXBlLnBvcztcclxuXHRcdGNvbnN0IGxpc3Q6IEZ1bmN0aW9uW10gPSBbXTtcclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHRjb25zdCB7YXJlYSwgYmFyLCBsaW5lfSA9IHNoYXBlLnR5cGU7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRsaXN0LnB1c2goJCQucmVkcmF3R3JpZChpc1RyYW5zaXRpb24pKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5yZWdpb25zLmxlbmd0aCkge1xyXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdSZWdpb24oaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLmhhc1R5cGVPZihcIkxpbmVcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0xpbmUobGluZSwgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdCQkLmhhc1R5cGVPZihcIkFyZWFcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0FyZWEoYXJlYSwgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0JhcihiYXIsIGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0XHQhZmxvdyAmJiBncmlkLm1haW4gJiYgbGlzdC5wdXNoKCQkLnVwZGF0ZUdyaWRGb2N1cygpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoISQkLmhhc0FyY1R5cGUoKSB8fCBoYXNSYWRhcikge1xyXG5cdFx0XHRub3RFbXB0eShjb25maWcuZGF0YV9sYWJlbHMpICYmXHJcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd1RleHQoeEZvclRleHQsIHlGb3JUZXh0LCBmbG93LCBpc1RyYW5zaXRpb24pKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoKCQkLmhhc1BvaW50VHlwZSgpIHx8IGhhc1JhZGFyKSAmJiAhY29uZmlnLnBvaW50X2ZvY3VzX29ubHkpIHtcclxuXHRcdFx0JCQucmVkcmF3Q2lyY2xlICYmIGxpc3QucHVzaCgkJC5yZWRyYXdDaXJjbGUoY3gsIGN5LCBpc1RyYW5zaXRpb24sIGZsb3dGbikpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsaXN0O1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFuZFJlZHJhdyhvcHRpb25zOiBhbnkgPSB7fSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRsZXQgdHJhbnNpdGlvbnM7XHJcblxyXG5cdFx0Ly8gc2FtZSB3aXRoIHJlZHJhd1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uXCIsIHRydWUpO1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zZm9ybVwiLCBmYWxzZSk7XHJcblx0XHRvcHRpb25zLndpdGhMZWdlbmQgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoTGVnZW5kXCIsIGZhbHNlKTtcclxuXHJcblx0XHQvLyBOT1Qgc2FtZSB3aXRoIHJlZHJhd1xyXG5cdFx0b3B0aW9ucy53aXRoVXBkYXRlWERvbWFpbiA9IHRydWU7XHJcblx0XHRvcHRpb25zLndpdGhVcGRhdGVPcmdYRG9tYWluID0gdHJ1ZTtcclxuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JFeGl0ID0gZmFsc2U7XHJcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgb3B0aW9ucy53aXRoVHJhbnNpdGlvbik7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2FsbGVkIGluIHVwZGF0ZUxlZ2VuZCBpbiByZWRyYXcgaWYgd2l0aExlZ2VuZFxyXG5cdFx0aWYgKCEob3B0aW9ucy53aXRoTGVnZW5kICYmIGNvbmZpZy5sZWdlbmRfc2hvdykpIHtcclxuXHRcdFx0aWYgKHN0YXRlLmhhc0F4aXMpIHtcclxuXHRcdFx0XHR0cmFuc2l0aW9ucyA9ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhcclxuXHRcdFx0XHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JBeGlzID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHNjYWxlc1xyXG5cdFx0XHQkJC51cGRhdGVTY2FsZXMoKTtcclxuXHRcdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIGcgcG9zaXRpb25zXHJcblx0XHRcdCQkLnRyYW5zZm9ybUFsbChvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtLCB0cmFuc2l0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRHJhdyB3aXRoIG5ldyBzaXplcyAmIHNjYWxlc1xyXG5cdFx0JCQucmVkcmF3KG9wdGlvbnMsIHRyYW5zaXRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdXaXRob3V0UmVzY2FsZSgpIHtcclxuXHRcdHRoaXMucmVkcmF3KHtcclxuXHRcdFx0d2l0aFk6IGZhbHNlLFxyXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxyXG5cdFx0XHR3aXRoRXZlbnRSZWN0OiBmYWxzZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JBeGlzOiBmYWxzZVxyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2NhbGVUaW1lIGFzIGQzU2NhbGVUaW1lLFxyXG5cdHNjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJcclxufSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuaW1wb3J0IHtpc1N0cmluZywgaXNWYWx1ZSwgcGFyc2VEYXRlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRTY2FsZShtaW46IG51bWJlciwgbWF4OiBudW1iZXIsIGZvclRpbWVzZXJpZXM/OiBib29sZWFuKSB7XHJcblx0XHRyZXR1cm4gKGZvclRpbWVzZXJpZXMgP1xyXG5cdFx0XHRkM1NjYWxlVGltZSgpIDogZDNTY2FsZUxpbmVhcigpXHJcblx0XHQpLnJhbmdlKFttaW4sIG1heF0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB4IEF4aXMgc2NhbGUgZnVuY3Rpb25cclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWluIE1pbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtYXggTWF4IHZhbHVlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZG9tYWluIERvbWFpbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldCBUaGUgb2Zmc2V0IGdldHRlciB0byBiZSBzdW1cclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHNjYWxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRYU2NhbGUobWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBkb21haW46IG51bWJlcltdLCBvZmZzZXQ6IEZ1bmN0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlLnpvb20gfHwgJCQuZ2V0U2NhbGUobWluLCBtYXgsICQkLmF4aXMuaXNUaW1lU2VyaWVzKCkpO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRDdXN0b21pemVkU2NhbGUoXHJcblx0XHRcdGRvbWFpbiA/IHNjYWxlLmRvbWFpbihkb21haW4pIDogc2NhbGUsXHJcblx0XHRcdG9mZnNldFxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgeSBBeGlzIHNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IG1pbiBNaW4gdmFsdWVcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gbWF4IE1heCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRvbWFpbiBEb21haW4gdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IFNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRZU2NhbGUobWluOiBudW1iZXIsIG1heDogbnVtYmVyLCBkb21haW46IG51bWJlcltdKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSAkJC5nZXRTY2FsZShtaW4sIG1heCwgJCQuYXhpcy5pc1RpbWVTZXJpZXNZKCkpO1xyXG5cclxuXHRcdGRvbWFpbiAmJiBzY2FsZS5kb21haW4oZG9tYWluKTtcclxuXHJcblx0XHRyZXR1cm4gc2NhbGU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHkgQXhpcyBzY2FsZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc1N1YiBXZWF0aGVyIGlzIHN1YiBBeGlzXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSBTY2FsZSBmdW5jdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WVNjYWxlQnlJZChpZDogc3RyaW5nLCBpc1N1YiA9IGZhbHNlKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgaXNZMiA9IHRoaXMuYXhpcy5nZXRJZChpZCkgPT09IFwieTJcIjtcclxuXHRcdGNvbnN0IGtleSA9IGlzU3ViID8gKGlzWTIgPyBcInN1YlkyXCIgOiBcInN1YllcIikgOiAoaXNZMiA/IFwieTJcIiA6IFwieVwiKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5zY2FsZVtrZXldO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBjdXN0b21pemVkIHNjYWxlXHJcblx0ICogQHBhcmFtIHtkMy5zY2FsZUxpbmVhcnxkMy5zY2FsZVRpbWV9IHNjYWxlVmFsdWUgU2NhbGUgZnVuY3Rpb25cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvZmZzZXRWYWx1ZSBPZmZzZXQgZ2V0dGVyIHRvIGJlIHN1bVxyXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gU2NhbGUgZnVuY3Rpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEN1c3RvbWl6ZWRTY2FsZShzY2FsZVZhbHVlOiBGdW5jdGlvbiB8IGFueSwgb2Zmc2V0VmFsdWUpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSB8fCAoKCkgPT4gJCQuYXhpcy54LnRpY2tPZmZzZXQoKSk7XHJcblx0XHRjb25zdCBzY2FsZSA9IGZ1bmN0aW9uKGQsIHJhdykge1xyXG5cdFx0XHRjb25zdCB2ID0gc2NhbGVWYWx1ZShkKSArIG9mZnNldCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJhdyA/IHYgOiBNYXRoLmNlaWwodik7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGNvcHkgb3JpZ2luYWwgc2NhbGUgbWV0aG9kc1xyXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc2NhbGVWYWx1ZSkge1xyXG5cdFx0XHRzY2FsZVtrZXldID0gc2NhbGVWYWx1ZVtrZXldO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNjYWxlLm9yZ0RvbWFpbiA9ICgpID0+IHNjYWxlVmFsdWUuZG9tYWluKCk7XHJcblx0XHRzY2FsZS5vcmdTY2FsZSA9ICgpID0+IHNjYWxlVmFsdWU7XHJcblxyXG5cdFx0Ly8gZGVmaW5lIGN1c3RvbSBkb21haW4oKSBmb3IgY2F0ZWdvcml6ZWQgYXhpc1xyXG5cdFx0aWYgKCQkLmF4aXMuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdHNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKGRvbWFpblZhbHVlKSB7XHJcblx0XHRcdFx0bGV0IGRvbWFpbiA9IGRvbWFpblZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGRvbWFpbiA9IHRoaXMub3JnRG9tYWluKCk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIFtkb21haW5bMF0sIGRvbWFpblsxXSArIDFdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2NhbGVWYWx1ZS5kb21haW4oZG9tYWluKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHNjYWxlO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzY2FsZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgc2NhbGVcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSW5pdCBQYXJhbSBpcyBnaXZlbiBhdCB0aGUgaW5pdCByZW5kZXJpbmdcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZVhEb21haW4gSWYgdXBkYXRlIHggZG9tYWluXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVTY2FsZXMoaXNJbml0OiBib29sZWFuLCB1cGRhdGVYRG9tYWluID0gdHJ1ZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgZm9ybWF0LCBvcmcsIHNjYWxlLFxyXG5cdFx0XHRzdGF0ZToge3dpZHRoLCBoZWlnaHQsIHdpZHRoMiwgaGVpZ2h0MiwgaGFzQXhpc31cclxuXHRcdH0gPSAkJDtcclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGVkZ2VzXHJcblx0XHRcdGNvbnN0IG1pbiA9IHtcclxuXHRcdFx0XHR4OiBpc1JvdGF0ZWQgPyAxIDogMCxcclxuXHRcdFx0XHR5OiBpc1JvdGF0ZWQgPyAwIDogaGVpZ2h0LFxyXG5cdFx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IDEgOiAwLFxyXG5cdFx0XHRcdHN1Ylk6IGlzUm90YXRlZCA/IDAgOiBoZWlnaHQyXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjb25zdCBtYXggPSB7XHJcblx0XHRcdFx0eDogaXNSb3RhdGVkID8gaGVpZ2h0IDogd2lkdGgsXHJcblx0XHRcdFx0eTogaXNSb3RhdGVkID8gd2lkdGggOiAxLFxyXG5cdFx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IGhlaWdodCA6IHdpZHRoLFxyXG5cdFx0XHRcdHN1Ylk6IGlzUm90YXRlZCA/IHdpZHRoMiA6IDFcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzY2FsZXNcclxuXHRcdFx0Ly8geCBBeGlzXHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSB1cGRhdGVYRG9tYWluICYmIHNjYWxlLnggJiYgc2NhbGUueC5vcmdEb21haW4oKTtcclxuXHRcdFx0Y29uc3QgeFN1YkRvbWFpbiA9IHVwZGF0ZVhEb21haW4gJiYgb3JnLnhEb21haW47XHJcblxyXG5cdFx0XHRzY2FsZS54ID0gJCQuZ2V0WFNjYWxlKG1pbi54LCBtYXgueCwgeERvbWFpbiwgKCkgPT4gYXhpcy54LnRpY2tPZmZzZXQoKSk7XHJcblx0XHRcdHNjYWxlLnN1YlggPSAkJC5nZXRYU2NhbGUobWluLngsIG1heC54LCB4U3ViRG9tYWluLCBkID0+IChkICUgMSA/IDAgOiBheGlzLnN1YlgudGlja09mZnNldCgpKSk7XHJcblxyXG5cdFx0XHRmb3JtYXQueEF4aXNUaWNrID0gYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKTtcclxuXHJcblx0XHRcdGF4aXMuc2V0QXhpcyhcInhcIiwgc2NhbGUueCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdFx0YXhpcy5zZXRBeGlzKFwic3ViWFwiLCBzY2FsZS5zdWJYLCBjb25maWcuYXhpc194X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHkgQXhpc1xyXG5cdFx0XHRzY2FsZS55ID0gJCQuZ2V0WVNjYWxlKG1pbi55LCBtYXgueSwgc2NhbGUueSA/IHNjYWxlLnkuZG9tYWluKCkgOiBjb25maWcuYXhpc195X2RlZmF1bHQpO1xyXG5cdFx0XHRzY2FsZS5zdWJZID0gJCQuZ2V0WVNjYWxlKFxyXG5cdFx0XHRcdG1pbi5zdWJZLCBtYXguc3ViWSwgc2NhbGUuc3ViWSA/IHNjYWxlLnN1YlkuZG9tYWluKCkgOiBjb25maWcuYXhpc195X2RlZmF1bHQpO1xyXG5cclxuXHRcdFx0YXhpcy5zZXRBeGlzKFwieVwiLCBzY2FsZS55LCBjb25maWcuYXhpc195X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblxyXG5cdFx0XHQvLyB5MiBBeGlzXHJcblx0XHRcdGlmIChjb25maWcuYXhpc195Ml9zaG93KSB7XHJcblx0XHRcdFx0c2NhbGUueTIgPSAkJC5nZXRZU2NhbGUobWluLnksIG1heC55LCBzY2FsZS55MiA/IHNjYWxlLnkyLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeTJfZGVmYXVsdCk7XHJcblx0XHRcdFx0c2NhbGUuc3ViWTIgPSAkJC5nZXRZU2NhbGUobWluLnN1YlksIG1heC5zdWJZLFxyXG5cdFx0XHRcdFx0c2NhbGUuc3ViWTIgPyBzY2FsZS5zdWJZMi5kb21haW4oKSA6IGNvbmZpZy5heGlzX3kyX2RlZmF1bHQpO1xyXG5cclxuXHRcdFx0XHRheGlzLnNldEF4aXMoXCJ5MlwiLCBzY2FsZS55MiwgY29uZmlnLmF4aXNfeTJfdGlja19vdXRlciwgaXNJbml0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gdXBkYXRlIGZvciBhcmNcclxuXHRcdFx0JCQudXBkYXRlQXJjICYmICQkLnVwZGF0ZUFyYygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgem9vbSBvciB1bnpvb21lZCBzY2FsZWQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge0RhdGV8bnVtYmVyfG9iamVjdH0gZCBEYXRhIHZhbHVlXHJcblx0ICogQHJldHVybnMge251bWJlcnxudWxsfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0eHgoZCk6IG51bWJlciB8IG51bGwge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGU6IHt4LCB6b29tfX0gPSAkJDtcclxuXHRcdGNvbnN0IGZuID0gY29uZmlnLnpvb21fZW5hYmxlZCAmJiB6b29tID9cclxuXHRcdFx0em9vbSA6IHg7XHJcblxyXG5cdFx0cmV0dXJuIGQgPyBmbihpc1ZhbHVlKGQueCkgPyBkLnggOiBkKSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0eHYoZCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnLCBzY2FsZToge3h9fSA9ICQkO1xyXG5cdFx0bGV0IHZhbHVlID0gJCQuZ2V0QmFzZVZhbHVlKGQpO1xyXG5cclxuXHRcdGlmIChheGlzLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdHZhbHVlID0gcGFyc2VEYXRlLmNhbGwoJCQsIHZhbHVlKTtcclxuXHRcdH0gZWxzZSBpZiAoYXhpcy5pc0NhdGVnb3JpemVkKCkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XHJcblx0XHRcdHZhbHVlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodmFsdWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLmNlaWwoeCh2YWx1ZSkpO1xyXG5cdH0sXHJcblxyXG5cdHl2KGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NjYWxlOiB7eSwgeTJ9fSA9ICQkO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gZC5heGlzICYmIGQuYXhpcyA9PT0gXCJ5MlwiID8geTIgOiB5O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmNlaWwoeVNjYWxlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cdH0sXHJcblxyXG5cdHN1Ynh4KGQpOiBudW1iZXIgfCBudWxsIHtcclxuXHRcdHJldHVybiBkID8gdGhpcy5zY2FsZS5zdWJYKGQueCkgOiBudWxsO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdGN1cnZlU3RlcEJlZm9yZSBhcyBkM0N1cnZlU3RlcEJlZm9yZSxcclxuXHRjdXJ2ZVN0ZXBBZnRlciBhcyBkM0N1cnZlU3RlcEFmdGVyLFxyXG5cdGN1cnZlQmFzaXNDbG9zZWQgYXMgZDNDdXJ2ZUJhc2lzQ2xvc2VkLFxyXG5cdGN1cnZlQmFzaXNPcGVuIGFzIGQzQ3VydmVCYXNpc09wZW4sXHJcblx0Y3VydmVCYXNpcyBhcyBkM0N1cnZlQmFzaXMsXHJcblx0Y3VydmVCdW5kbGUgYXMgZDNDdXJ2ZUJ1bmRsZSxcclxuXHRjdXJ2ZUNhcmRpbmFsQ2xvc2VkIGFzIGQzQ3VydmVDYXJkaW5hbENsb3NlZCxcclxuXHRjdXJ2ZUNhcmRpbmFsT3BlbiBhcyBkM0N1cnZlQ2FyZGluYWxPcGVuLFxyXG5cdGN1cnZlQ2FyZGluYWwgYXMgZDNDdXJ2ZUNhcmRpbmFsLFxyXG5cdGN1cnZlQ2F0bXVsbFJvbUNsb3NlZCBhcyBkM0N1cnZlQ2F0bXVsbFJvbUNsb3NlZCxcclxuXHRjdXJ2ZUNhdG11bGxSb21PcGVuIGFzIGQzQ3VydmVDYXRtdWxsUm9tT3BlbixcclxuXHRjdXJ2ZUNhdG11bGxSb20gYXMgZDNDdXJ2ZUNhdG11bGxSb20sXHJcblx0Y3VydmVMaW5lYXJDbG9zZWQgYXMgZDNDdXJ2ZUxpbmVhckNsb3NlZCxcclxuXHRjdXJ2ZUxpbmVhciBhcyBkM0N1cnZlTGluZWFyLFxyXG5cdGN1cnZlTW9ub3RvbmVYIGFzIGQzQ3VydmVNb25vdG9uZVgsXHJcblx0Y3VydmVNb25vdG9uZVkgYXMgZDNDdXJ2ZU1vbm90b25lWSxcclxuXHRjdXJ2ZU5hdHVyYWwgYXMgZDNDdXJ2ZU5hdHVyYWwsXHJcblx0Y3VydmVTdGVwIGFzIGQzQ3VydmVTdGVwXHJcbn0gZnJvbSBcImQzLXNoYXBlXCI7XHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRVbmlxdWUsIGlzT2JqZWN0VHlwZSwgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBub3RFbXB0eX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBzaGFwZSBkcmF3IGZ1bmN0aW9uXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldERyYXdTaGFwZSgpIHtcclxuXHRcdHR5cGUgU0hBUEUgPSB7XHJcblx0XHRcdGFyZWE/OiBhbnk7XHJcblx0XHRcdGJhcj86IGFueTtcclxuXHRcdFx0bGluZT86IGFueTtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHtoYXNSYWRhcn0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IHNoYXBlID0ge3R5cGU6IDxTSEFQRT4ge30sIGluZGljZXM6IDxTSEFQRT4ge30sIHBvczoge319O1xyXG5cclxuXHRcdC8vIHNldHVwIGRyYXdlciAtIE1FTU86IHRoZXNlIG11c3QgYmUgY2FsbGVkIGFmdGVyIGF4aXMgdXBkYXRlZFxyXG5cdFx0aWYgKCQkLmhhc1R5cGVPZihcIkxpbmVcIikgfHwgJCQuaGFzVHlwZShcImJ1YmJsZVwiKSB8fCAkJC5oYXNUeXBlKFwic2NhdHRlclwiKSkge1xyXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzTGluZVR5cGUpO1xyXG5cclxuXHRcdFx0c2hhcGUuaW5kaWNlcy5saW5lID0gaW5kaWNlcztcclxuXHRcdFx0c2hhcGUudHlwZS5saW5lID0gJCQuZ2VuZXJhdGVEcmF3TGluZSA/ICQkLmdlbmVyYXRlRHJhd0xpbmUoaW5kaWNlcywgZmFsc2UpIDogdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0aWYgKCQkLmhhc1R5cGVPZihcIkFyZWFcIikpIHtcclxuXHRcdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzQXJlYVR5cGUpO1xyXG5cclxuXHRcdFx0XHRzaGFwZS5pbmRpY2VzLmFyZWEgPSBpbmRpY2VzO1xyXG5cdFx0XHRcdHNoYXBlLnR5cGUuYXJlYSA9ICQkLmdlbmVyYXRlRHJhd0FyZWEgPyAkJC5nZW5lcmF0ZURyYXdBcmVhKGluZGljZXMsIGZhbHNlKSA6IHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwiYmFyXCIpKSB7XHJcblx0XHRcdGNvbnN0IGluZGljZXMgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNCYXJUeXBlKTtcclxuXHJcblx0XHRcdHNoYXBlLmluZGljZXMuYmFyID0gaW5kaWNlcztcclxuXHRcdFx0c2hhcGUudHlwZS5iYXIgPSAkJC5nZW5lcmF0ZURyYXdCYXIgPyAkJC5nZW5lcmF0ZURyYXdCYXIoaW5kaWNlcykgOiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCEkJC5oYXNBcmNUeXBlKCkgfHwgaGFzUmFkYXIpIHtcclxuXHRcdFx0Ly8gZ2VuZXJhdGUgY2lyY2xlIHgveSBmdW5jdGlvbnMgZGVwZW5kaW5nIG9uIHVwZGF0ZWQgcGFyYW1zXHJcblx0XHRcdGNvbnN0IGN4ID0gaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVggOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWSA6ICQkLmNpcmNsZVgpO1xyXG5cdFx0XHRjb25zdCBjeSA9IGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVZIDogKGlzUm90YXRlZCA/ICQkLmNpcmNsZVggOiAkJC5jaXJjbGVZKTtcclxuXHJcblx0XHRcdHNoYXBlLnBvcyA9IHtcclxuXHRcdFx0XHR4Rm9yVGV4dDogJCQuZ2VuZXJhdGVYWUZvclRleHQoc2hhcGUuaW5kaWNlcywgdHJ1ZSksXHJcblx0XHRcdFx0eUZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsIGZhbHNlKSxcclxuXHRcdFx0XHRjeDogKGN4IHx8IGZ1bmN0aW9uKCkge30pLmJpbmQoJCQpLFxyXG5cdFx0XHRcdGN5OiAoY3kgfHwgZnVuY3Rpb24oKSB7fSkuYmluZCgkJClcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2hhcGU7XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVJbmRpY2VzKHR5cGVGaWx0ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB4cyA9IGNvbmZpZy5kYXRhX3hzO1xyXG5cdFx0Y29uc3QgaGFzWHMgPSBub3RFbXB0eSh4cyk7XHJcblx0XHRjb25zdCBpbmRpY2VzID0ge307XHJcblx0XHRsZXQgaTogYW55ID0gaGFzWHMgPyB7fSA6IDA7XHJcblxyXG5cdFx0aWYgKGhhc1hzKSB7XHJcblx0XHRcdGdldFVuaXF1ZShPYmplY3Qua2V5cyh4cykubWFwKHYgPT4geHNbdl0pKVxyXG5cdFx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0aVt2XSA9IDA7XHJcblx0XHRcdFx0XHRpbmRpY2VzW3ZdID0ge307XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMuZmlsdGVyKHR5cGVGaWx0ZXIsICQkKSlcclxuXHRcdFx0LmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0Y29uc3QgeEtleSA9IGQuaWQgaW4geHMgPyB4c1tkLmlkXSA6IFwiXCI7XHJcblx0XHRcdFx0Y29uc3QgaW5kID0geEtleSA/IGluZGljZXNbeEtleV0gOiBpbmRpY2VzO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBqID0gMCwgZ3JvdXBzOyAoZ3JvdXBzID0gY29uZmlnLmRhdGFfZ3JvdXBzW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHRpZiAoZ3JvdXBzLmluZGV4T2YoZC5pZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSAwLCByb3c7IChyb3cgPSBncm91cHNba10pOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKHJvdyBpbiBpbmQpIHtcclxuXHRcdFx0XHRcdFx0XHRpbmRbZC5pZF0gPSBpbmRbcm93XTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKGluZFtkLmlkXSkpIHtcclxuXHRcdFx0XHRcdGluZFtkLmlkXSA9IHhLZXkgPyBpW3hLZXldKysgOiBpKys7XHJcblx0XHRcdFx0XHRpbmQuX19tYXhfXyA9ICh4S2V5ID8gaVt4S2V5XSA6IGkpIC0gMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBpbmRpY2VzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBpbmRpY2VzIHZhbHVlIGJhc2VkIG9uIGRhdGEgSUQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gaW5kaWNlcyBJbmRpY2VzIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBEYXRhIGlkIHZhbHVlXHJcblx0ICogQHJldHVybnMge29iamVjdH0gSW5kaWNlcyBvYmplY3RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEluZGljZXMoaW5kaWNlcywgaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgeHMgPSB0aGlzLmNvbmZpZy5kYXRhX3hzO1xyXG5cclxuXHRcdHJldHVybiBub3RFbXB0eSh4cykgP1xyXG5cdFx0XHRpbmRpY2VzW3hzW2lkXV0gOiBpbmRpY2VzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBpbmRpY2VzIG1heCBudW1iZXJcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gaW5kaWNlcyBJbmRpY2VzIG9iamVjdFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IE1heCBudW1iZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEluZGljZXNNYXgoaW5kaWNlcyk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgP1xyXG5cdFx0XHQvLyBpZiBpcyBtdWx0aXBsZSB4cywgcmV0dXJuIHRvdGFsIHN1bSBvZiB4cycgX19tYXhfXyB2YWx1ZVxyXG5cdFx0XHRPYmplY3Qua2V5cyhpbmRpY2VzKVxyXG5cdFx0XHRcdC5tYXAodiA9PiBpbmRpY2VzW3ZdLl9fbWF4X18gfHwgMClcclxuXHRcdFx0XHQucmVkdWNlKChhY2MsIGN1cnIpID0+IGFjYyArIGN1cnIpIDogaW5kaWNlcy5fX21heF9fO1xyXG5cdH0sXHJcblxyXG5cdGdldFNoYXBlWChvZmZzZXQsIGluZGljZXMsIGlzU3ViPzogYm9vbGVhbik6IChkKSA9PiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyU2NhbGUgPSBpc1N1YiA/IHNjYWxlLnN1YlggOiAoc2NhbGUuem9vbSB8fCBzY2FsZS54KTtcclxuXHRcdGNvbnN0IGJhclBhZGRpbmcgPSBjb25maWcuYmFyX3BhZGRpbmc7XHJcblx0XHRjb25zdCBzdW0gPSAocCwgYykgPT4gcCArIGM7XHJcblx0XHRjb25zdCBoYWxmV2lkdGggPSBpc09iamVjdFR5cGUob2Zmc2V0KSAmJiBvZmZzZXQudG90YWwubGVuZ3RoID8gb2Zmc2V0LnRvdGFsLnJlZHVjZShzdW0pIC8gMiA6IDA7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRjb25zdCBpbmQgPSAkJC5nZXRJbmRpY2VzKGluZGljZXMsIGQuaWQpO1xyXG5cdFx0XHRjb25zdCBpbmRleCA9IGQuaWQgaW4gaW5kID8gaW5kW2QuaWRdIDogMDtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0c051bSA9IChpbmQuX19tYXhfXyB8fCAwKSArIDE7XHJcblx0XHRcdGxldCB4ID0gMDtcclxuXHJcblx0XHRcdGlmIChub3RFbXB0eShkLngpKSB7XHJcblx0XHRcdFx0Y29uc3QgeFBvcyA9IGN1cnJTY2FsZShkLngpO1xyXG5cclxuXHRcdFx0XHRpZiAoaGFsZldpZHRoKSB7XHJcblx0XHRcdFx0XHR4ID0geFBvcyAtIChvZmZzZXRbZC5pZF0gfHwgb2Zmc2V0LndpZHRoKSArXHJcblx0XHRcdFx0XHRcdG9mZnNldC50b3RhbC5zbGljZSgwLCBpbmRleCArIDEpLnJlZHVjZShzdW0pIC1cclxuXHRcdFx0XHRcdFx0aGFsZldpZHRoO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR4ID0geFBvcyAtIChpc051bWJlcihvZmZzZXQpID8gb2Zmc2V0IDogb2Zmc2V0LndpZHRoKSAqICh0YXJnZXRzTnVtIC8gMiAtIGluZGV4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGFkanVzdCB4IHBvc2l0aW9uIGZvciBiYXIucGFkZGluZyBvcHRpb25xXHJcblx0XHRcdGlmIChvZmZzZXQgJiYgeCAmJiB0YXJnZXRzTnVtID4gMSAmJiBiYXJQYWRkaW5nKSB7XHJcblx0XHRcdFx0aWYgKGluZGV4KSB7XHJcblx0XHRcdFx0XHR4ICs9IGJhclBhZGRpbmcgKiBpbmRleDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh0YXJnZXRzTnVtID4gMikge1xyXG5cdFx0XHRcdFx0eCAtPSAodGFyZ2V0c051bSAtIDEpICogYmFyUGFkZGluZyAvIDI7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXRzTnVtID09PSAyKSB7XHJcblx0XHRcdFx0XHR4IC09IGJhclBhZGRpbmcgLyAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHg7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldFNoYXBlWShpc1N1Yj86IGJvb2xlYW4pOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpc1N0YWNrTm9ybWFsaXplZCA9ICQkLmlzU3RhY2tOb3JtYWxpemVkKCk7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IGlzU3RhY2tOb3JtYWxpemVkID8gJCQuZ2V0UmF0aW8oXCJpbmRleFwiLCBkLCB0cnVlKSA6IChcclxuXHRcdFx0XHQkJC5pc0J1YmJsZVpUeXBlKGQpID8gJCQuZ2V0QnViYmxlWkRhdGEoZC52YWx1ZSwgXCJ5XCIpIDogZC52YWx1ZVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuICQkLmdldFlTY2FsZUJ5SWQoZC5pZCwgaXNTdWIpKHZhbHVlKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHNoYXBlIGJhc2VkIHkgQXhpcyBtaW4gdmFsdWVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgRGF0YSBpZFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRTaGFwZVlNaW4oaWQ6IHN0cmluZyk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBbeU1pbl0gPSAkJC5zY2FsZVskJC5heGlzLmdldElkKGlkKV0uZG9tYWluKCk7XHJcblxyXG5cdFx0cmV0dXJuICEkJC5pc0dyb3VwZWQoaWQpICYmIHlNaW4gPiAwID8geU1pbiA6IDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IFNoYXBlJ3Mgb2Zmc2V0IGRhdGFcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlRmlsdGVyIFR5cGUgZmlsdGVyIGZ1bmN0aW9uXHJcblx0ICogQHJldHVybnMge29iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFNoYXBlT2Zmc2V0RGF0YSh0eXBlRmlsdGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gJCQub3JkZXJUYXJnZXRzKCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpKTtcclxuXHRcdGNvbnN0IGlzU3RhY2tOb3JtYWxpemVkID0gJCQuaXNTdGFja05vcm1hbGl6ZWQoKTtcclxuXHJcblx0XHRjb25zdCBzaGFwZU9mZnNldFRhcmdldHMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xyXG5cdFx0XHRsZXQgcm93VmFsdWVzID0gdGFyZ2V0LnZhbHVlcztcclxuXHRcdFx0Y29uc3QgdmFsdWVzID0ge307XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNTdGVwVHlwZSh0YXJnZXQpKSB7XHJcblx0XHRcdFx0cm93VmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcChyb3dWYWx1ZXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCByb3dWYWx1ZU1hcEJ5WFZhbHVlID0gcm93VmFsdWVzLnJlZHVjZSgob3V0LCBkKSA9PiB7XHJcblx0XHRcdFx0Y29uc3Qga2V5ID0gTnVtYmVyKGQueCk7XHJcblxyXG5cdFx0XHRcdG91dFtrZXldID0gZDtcclxuXHRcdFx0XHR2YWx1ZXNba2V5XSA9IGlzU3RhY2tOb3JtYWxpemVkID8gJCQuZ2V0UmF0aW8oXCJpbmRleFwiLCBkLCB0cnVlKSA6IGQudmFsdWU7XHJcblxyXG5cdFx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHRcdH0sIHt9KTtcclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0aWQ6IHRhcmdldC5pZCxcclxuXHRcdFx0XHRyb3dWYWx1ZXMsXHJcblx0XHRcdFx0cm93VmFsdWVNYXBCeVhWYWx1ZSxcclxuXHRcdFx0XHR2YWx1ZXNcclxuXHRcdFx0fTtcclxuXHRcdH0pO1xyXG5cdFx0Y29uc3QgaW5kZXhNYXBCeVRhcmdldElkID0gdGFyZ2V0cy5yZWR1Y2UoKG91dCwge2lkfSwgaW5kZXgpID0+IHtcclxuXHRcdFx0b3V0W2lkXSA9IGluZGV4O1xyXG5cdFx0XHRyZXR1cm4gb3V0O1xyXG5cdFx0fSwge30pO1xyXG5cclxuXHRcdHJldHVybiB7aW5kZXhNYXBCeVRhcmdldElkLCBzaGFwZU9mZnNldFRhcmdldHN9O1xyXG5cdH0sXHJcblxyXG5cdGdldFNoYXBlT2Zmc2V0KHR5cGVGaWx0ZXIsIGluZGljZXMsIGlzU3ViPzogYm9vbGVhbik6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzaGFwZU9mZnNldFRhcmdldHMsIGluZGV4TWFwQnlUYXJnZXRJZH0gPSAkJC5nZXRTaGFwZU9mZnNldERhdGEodHlwZUZpbHRlcik7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpZHgpID0+IHtcclxuXHRcdFx0Y29uc3QgaW5kID0gJCQuZ2V0SW5kaWNlcyhpbmRpY2VzLCBkLmlkKTtcclxuXHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5nZXRZU2NhbGVCeUlkKGQuaWQsIGlzU3ViKTtcclxuXHRcdFx0Y29uc3QgeTAgPSBzY2FsZSgkJC5nZXRTaGFwZVlNaW4oZC5pZCkpO1xyXG5cclxuXHRcdFx0Y29uc3QgZGF0YVhBc051bWJlciA9IE51bWJlcihkLngpO1xyXG5cdFx0XHRsZXQgb2Zmc2V0ID0geTA7XHJcblxyXG5cdFx0XHRzaGFwZU9mZnNldFRhcmdldHNcclxuXHRcdFx0XHQuZmlsdGVyKHQgPT4gdC5pZCAhPT0gZC5pZClcclxuXHRcdFx0XHQuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0XHRcdGlmIChpbmRbdC5pZF0gPT09IGluZFtkLmlkXSAmJiBpbmRleE1hcEJ5VGFyZ2V0SWRbdC5pZF0gPCBpbmRleE1hcEJ5VGFyZ2V0SWRbZC5pZF0pIHtcclxuXHRcdFx0XHRcdFx0bGV0IHJvdyA9IHQucm93VmFsdWVzW2lkeF07XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgeCB2YWx1ZXMgbGluZSB1cFxyXG5cdFx0XHRcdFx0XHRpZiAoIXJvdyB8fCBOdW1iZXIocm93LngpICE9PSBkYXRhWEFzTnVtYmVyKSB7XHJcblx0XHRcdFx0XHRcdFx0cm93ID0gdC5yb3dWYWx1ZU1hcEJ5WFZhbHVlW2RhdGFYQXNOdW1iZXJdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAocm93ICYmIHJvdy52YWx1ZSAqIGQudmFsdWUgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSBzY2FsZSh0LnZhbHVlc1tkYXRhWEFzTnVtYmVyXSkgLSB5MDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIG9mZnNldDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5TaGFwZSh0aGF0LCBkKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoYXQpO1xyXG5cdFx0bGV0IGlzV2l0aGluO1xyXG5cclxuXHRcdGlmICghJCQuaXNUYXJnZXRUb1Nob3coZC5pZCkpIHtcclxuXHRcdFx0aXNXaXRoaW4gPSBmYWxzZTtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVmFsaWRQb2ludFR5cGUodGhhdC5ub2RlTmFtZSkpIHtcclxuXHRcdFx0aXNXaXRoaW4gPSAkJC5pc1N0ZXBUeXBlKGQpID9cclxuXHRcdFx0XHQkJC5pc1dpdGhpblN0ZXAodGhhdCwgJCQuZ2V0WVNjYWxlQnlJZChkLmlkKShkLnZhbHVlKSkgOlxyXG5cdFx0XHRcdCQkLmlzV2l0aGluQ2lyY2xlKHRoYXQsICQkLmlzQnViYmxlVHlwZShkKSA/ICQkLnBvaW50U2VsZWN0UihkKSAqIDEuNSA6IDApO1xyXG5cdFx0fSBlbHNlIGlmICh0aGF0Lm5vZGVOYW1lID09PSBcInBhdGhcIikge1xyXG5cdFx0XHRpc1dpdGhpbiA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYmFyKSA/ICQkLmlzV2l0aGluQmFyKHRoYXQpIDogdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNXaXRoaW47XHJcblx0fSxcclxuXHJcblx0Z2V0SW50ZXJwb2xhdGUoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaW50ZXJwb2xhdGlvbiA9ICQkLmdldEludGVycG9sYXRlVHlwZShkKTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcImJhc2lzXCI6IGQzQ3VydmVCYXNpcyxcclxuXHRcdFx0XCJiYXNpcy1jbG9zZWRcIjogZDNDdXJ2ZUJhc2lzQ2xvc2VkLFxyXG5cdFx0XHRcImJhc2lzLW9wZW5cIjogZDNDdXJ2ZUJhc2lzT3BlbixcclxuXHRcdFx0XCJidW5kbGVcIjogZDNDdXJ2ZUJ1bmRsZSxcclxuXHRcdFx0XCJjYXJkaW5hbFwiOiBkM0N1cnZlQ2FyZGluYWwsXHJcblx0XHRcdFwiY2FyZGluYWwtY2xvc2VkXCI6IGQzQ3VydmVDYXJkaW5hbENsb3NlZCxcclxuXHRcdFx0XCJjYXJkaW5hbC1vcGVuXCI6IGQzQ3VydmVDYXJkaW5hbE9wZW4sXHJcblx0XHRcdFwiY2F0bXVsbC1yb21cIjogZDNDdXJ2ZUNhdG11bGxSb20sXHJcblx0XHRcdFwiY2F0bXVsbC1yb20tY2xvc2VkXCI6IGQzQ3VydmVDYXRtdWxsUm9tQ2xvc2VkLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLW9wZW5cIjogZDNDdXJ2ZUNhdG11bGxSb21PcGVuLFxyXG5cdFx0XHRcIm1vbm90b25lLXhcIjogZDNDdXJ2ZU1vbm90b25lWCxcclxuXHRcdFx0XCJtb25vdG9uZS15XCI6IGQzQ3VydmVNb25vdG9uZVksXHJcblx0XHRcdFwibmF0dXJhbFwiOiBkM0N1cnZlTmF0dXJhbCxcclxuXHRcdFx0XCJsaW5lYXItY2xvc2VkXCI6IGQzQ3VydmVMaW5lYXJDbG9zZWQsXHJcblx0XHRcdFwibGluZWFyXCI6IGQzQ3VydmVMaW5lYXIsXHJcblx0XHRcdFwic3RlcFwiOiBkM0N1cnZlU3RlcCxcclxuXHRcdFx0XCJzdGVwLWFmdGVyXCI6IGQzQ3VydmVTdGVwQWZ0ZXIsXHJcblx0XHRcdFwic3RlcC1iZWZvcmVcIjogZDNDdXJ2ZVN0ZXBCZWZvcmVcclxuXHRcdH1baW50ZXJwb2xhdGlvbl07XHJcblx0fSxcclxuXHJcblx0Z2V0SW50ZXJwb2xhdGVUeXBlKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0eXBlID0gY29uZmlnLnNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGU7XHJcblx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gJCQuaXNJbnRlcnBvbGF0aW9uVHlwZSh0eXBlKSA/IHR5cGUgOiBcImNhcmRpbmFsXCI7XHJcblxyXG5cdFx0cmV0dXJuICQkLmlzU3BsaW5lVHlwZShkKSA/XHJcblx0XHRcdGludGVycG9sYXRpb24gOiAoXHJcblx0XHRcdFx0JCQuaXNTdGVwVHlwZShkKSA/XHJcblx0XHRcdFx0XHRjb25maWcubGluZV9zdGVwX3R5cGUgOiBcImxpbmVhclwiXHJcblx0XHRcdCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNWYWx1ZSwgY2VpbDEwLCBjYXBpdGFsaXplfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBVcGRhdGUgY29udGFpbmVyIHNpemVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldENvbnRhaW5lclNpemUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblxyXG5cdFx0c3RhdGUuY3VycmVudC53aWR0aCA9ICQkLmdldEN1cnJlbnRXaWR0aCgpO1xyXG5cdFx0c3RhdGUuY3VycmVudC5oZWlnaHQgPSAkJC5nZXRDdXJyZW50SGVpZ2h0KCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudFdpZHRoKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5zaXplX3dpZHRoIHx8ICQkLmdldFBhcmVudFdpZHRoKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudEhlaWdodCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGggPSBjb25maWcuc2l6ZV9oZWlnaHQgfHwgJCQuZ2V0UGFyZW50SGVpZ2h0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGggPiAwID8gaCA6IDMyMCAvICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRQYWRkaW5nVG9wKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnLmF4aXNfeTJfYXhlcy5sZW5ndGg7XHJcblxyXG5cdFx0bGV0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX3RvcCkgP1xyXG5cdFx0XHRjb25maWcucGFkZGluZ190b3AgOiAwO1xyXG5cclxuXHRcdGlmICgkZWwudGl0bGUgJiYgJGVsLnRpdGxlLm5vZGUoKSkge1xyXG5cdFx0XHRwYWRkaW5nICs9ICQkLmdldFRpdGxlUGFkZGluZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGVzTGVuICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyArPSAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICogYXhlc0xlbjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZztcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGF4aXNJZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInlcIiA6IFwieFwiO1xyXG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fYXhlc2BdLmxlbmd0aDtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2JvdHRvbSkgP1xyXG5cdFx0XHRjb25maWcucGFkZGluZ19ib3R0b20gOiAwO1xyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nICsgKFxyXG5cdFx0XHRheGVzTGVuID8gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoYXhpc0lkKSAqIGF4ZXNMZW4gOiAwXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2hhc0F4aXN9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGF4aXNJZCA9IGlzUm90YXRlZCA/IFwieFwiIDogXCJ5XCI7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9heGVzYF0ubGVuZ3RoO1xyXG5cdFx0Y29uc3QgYXhpc1dpZHRoID0gaGFzQXhpcyA/ICQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKGF4aXNJZCwgd2l0aG91dFJlY29tcHV0ZSkgOiAwO1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfbGVmdCkpIHtcclxuXHRcdFx0cGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nX2xlZnQ7XHJcblx0XHR9IGVsc2UgaWYgKGhhc0F4aXMgJiYgaXNSb3RhdGVkKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAhY29uZmlnLmF4aXNfeF9zaG93ID9cclxuXHRcdFx0XHQxIDogTWF0aC5tYXgoY2VpbDEwKGF4aXNXaWR0aCksIDQwKTtcclxuXHRcdH0gZWxzZSBpZiAoaGFzQXhpcyAmJiAoIWNvbmZpZy5heGlzX3lfc2hvdyB8fCBjb25maWcuYXhpc195X2lubmVyKSkgeyAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxyXG5cdFx0XHRwYWRkaW5nID0gJCQuYXhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihcInlcIikuaXNPdXRlciA/IDMwIDogMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjZWlsMTAoYXhpc1dpZHRoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZyArIChheGlzV2lkdGggKiBheGVzTGVuKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ1JpZ2h0KHdpdGhvdXRUaWNrVGV4dE92ZXJmbG93ID0gZmFsc2UpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtoYXNBeGlzfX0gPSAkJDtcclxuXHRcdGNvbnN0IGRlZmF1bHRQYWRkaW5nID0gMTA7XHJcblx0XHRjb25zdCBsZWdlbmRXaWR0aE9uUmlnaHQgPSAkJC5zdGF0ZS5pc0xlZ2VuZFJpZ2h0ID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSArIDIwIDogMDtcclxuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWcuYXhpc195Ml9heGVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGF4aXNXaWR0aCA9IGhhc0F4aXMgPyAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChcInkyXCIpIDogMDtcclxuXHRcdGNvbnN0IHhBeGlzVGlja1RleHRPdmVyZmxvdyA9IHdpdGhvdXRUaWNrVGV4dE92ZXJmbG93ID9cclxuXHRcdFx0MCA6ICQkLmF4aXMuZ2V0WEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3coZGVmYXVsdFBhZGRpbmcpO1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfcmlnaHQpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjb25maWcucGFkZGluZ19yaWdodCArIDE7IC8vIDEgaXMgbmVlZGVkIG5vdCB0byBoaWRlIHRpY2sgbGluZVxyXG5cdFx0fSBlbHNlIGlmICgkJC5heGlzICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyA9IGRlZmF1bHRQYWRkaW5nICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xyXG5cdFx0fSBlbHNlIGlmICgkJC5heGlzICYmICghY29uZmlnLmF4aXNfeTJfc2hvdyB8fCBjb25maWcuYXhpc195Ml9pbm5lcikpIHsgLy8gJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWRcclxuXHRcdFx0cGFkZGluZyA9IE1hdGgubWF4KFxyXG5cdFx0XHRcdDIgKyBsZWdlbmRXaWR0aE9uUmlnaHQgKyAoJCQuYXhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihcInkyXCIpLmlzT3V0ZXIgPyAyMCA6IDApLFxyXG5cdFx0XHRcdHhBeGlzVGlja1RleHRPdmVyZmxvd1xyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFkZGluZyA9IE1hdGgubWF4KGNlaWwxMChheGlzV2lkdGgpICsgbGVnZW5kV2lkdGhPblJpZ2h0LCB4QXhpc1RpY2tUZXh0T3ZlcmZsb3cpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nICsgKGF4aXNXaWR0aCAqIGF4ZXNMZW4pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcGFyZW50IHJlY3QgZWxlbWVudCdzIHNpemVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IHByb3BlcnR5L2F0dHJpYnV0ZSBuYW1lXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFBhcmVudFJlY3RWYWx1ZShrZXkpOiBudW1iZXIge1xyXG5cdFx0Y29uc3Qgb2Zmc2V0TmFtZSA9IGBvZmZzZXQke2NhcGl0YWxpemUoa2V5KX1gO1xyXG5cdFx0bGV0IHBhcmVudCA9IHRoaXMuJGVsLmNoYXJ0Lm5vZGUoKTtcclxuXHRcdGxldCB2O1xyXG5cclxuXHRcdHdoaWxlICghdiAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZ05hbWUgIT09IFwiQk9EWVwiKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0diA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtrZXldO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0aWYgKG9mZnNldE5hbWUgaW4gcGFyZW50KSB7XHJcblx0XHRcdFx0XHQvLyBJbiBJRSBpbiBjZXJ0YWluIGNhc2VzIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxyXG5cdFx0XHRcdFx0Ly8gd2lsbCBjYXVzZSBhbiBcInVuc3BlY2lmaWVkIGVycm9yXCJcclxuXHRcdFx0XHRcdHYgPSBwYXJlbnRbb2Zmc2V0TmFtZV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoa2V5ID09PSBcIndpZHRoXCIpIHtcclxuXHRcdFx0Ly8gU29tZXRpbWVzIGVsZW1lbnQncyB3aWR0aCB2YWx1ZSBpcyBpbmNvcnJlY3QoZXguIGZsZXggY29udGFpbmVyKVxyXG5cdFx0XHQvLyBJbiB0aGlzIGNhc2UsIHVzZSBib2R5J3Mgb2Zmc2V0V2lkdGggaW5zdGVhZC5cclxuXHRcdFx0Y29uc3QgYm9keVdpZHRoID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcclxuXHJcblx0XHRcdHYgPiBib2R5V2lkdGggJiYgKHYgPSBib2R5V2lkdGgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2O1xyXG5cdH0sXHJcblxyXG5cdGdldFBhcmVudFdpZHRoKCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQYXJlbnRSZWN0VmFsdWUoXCJ3aWR0aFwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQYXJlbnRIZWlnaHQoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IGggPSB0aGlzLiRlbC5jaGFydC5zdHlsZShcImhlaWdodFwiKTtcclxuXHJcblx0XHRyZXR1cm4gaC5pbmRleE9mKFwicHhcIikgPiAwID8gcGFyc2VJbnQoaCwgMTApIDogMDtcclxuXHR9LFxyXG5cclxuXHRnZXRTdmdMZWZ0KHdpdGhvdXRSZWNvbXB1dGU/OiBib29sZWFuKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGhhc0xlZnRBeGlzUmVjdCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgfHwgKCFjb25maWcuYXhpc19yb3RhdGVkICYmICFjb25maWcuYXhpc195X2lubmVyKTtcclxuXHRcdGNvbnN0IGxlZnRBeGlzQ2xhc3MgPSBjb25maWcuYXhpc19yb3RhdGVkID8gQ0xBU1MuYXhpc1ggOiBDTEFTUy5heGlzWTtcclxuXHRcdGNvbnN0IGxlZnRBeGlzID0gJGVsLm1haW4uc2VsZWN0KGAuJHtsZWZ0QXhpc0NsYXNzfWApLm5vZGUoKTtcclxuXHRcdGNvbnN0IHN2Z1JlY3QgPSBsZWZ0QXhpcyAmJiBoYXNMZWZ0QXhpc1JlY3QgPyBsZWZ0QXhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IHtyaWdodDogMH07XHJcblx0XHRjb25zdCBjaGFydFJlY3QgPSAkZWwuY2hhcnQubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdFx0Y29uc3QgaGFzQXJjID0gJCQuaGFzQXJjVHlwZSgpO1xyXG5cdFx0Y29uc3Qgc3ZnTGVmdCA9IHN2Z1JlY3QucmlnaHQgLSBjaGFydFJlY3QubGVmdCAtXHJcblx0XHRcdChoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KHdpdGhvdXRSZWNvbXB1dGUpKTtcclxuXHJcblx0XHRyZXR1cm4gc3ZnTGVmdCA+IDAgPyBzdmdMZWZ0IDogMDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVEaW1lbnNpb24od2l0aG91dEF4aXM/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2hhc0F4aXN9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMgJiYgIXdpdGhvdXRBeGlzKSB7XHJcblx0XHRcdGlmICgkJC5heGlzLnggJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRcdCQkLmF4aXMueC5jcmVhdGUoJGVsLmF4aXMueCk7XHJcblx0XHRcdFx0JCQuYXhpcy5zdWJYICYmICQkLmF4aXMuc3ViWC5jcmVhdGUoJGVsLmF4aXMuc3ViWCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JCQuYXhpcy55ICYmICQkLmF4aXMueS5jcmVhdGUoJGVsLmF4aXMueSk7XHJcblx0XHRcdFx0JCQuYXhpcy55MiAmJiAkJC5heGlzLnkyLmNyZWF0ZSgkZWwuYXhpcy55Mik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBwYXNzICd3aXRob3V0QXhpcycgcGFyYW0gdG8gbm90IGFuaW1hdGUgYXQgdGhlIGluaXQgcmVuZGVyaW5nXHJcblx0XHQkJC51cGRhdGVTY2FsZXMod2l0aG91dEF4aXMpO1xyXG5cdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xyXG5cdFx0JCQudHJhbnNmb3JtQWxsKGZhbHNlKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVTdmdTaXplKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlLCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdHN2Z1xyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLmN1cnJlbnQud2lkdGgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHN0YXRlLmN1cnJlbnQuaGVpZ2h0KTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaGFzQXhpcykge1xyXG5cdFx0XHRjb25zdCBicnVzaCA9IHN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xyXG5cdFx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XHJcblx0XHRcdFx0YnJ1c2hTaXplLndpZHRoID0gK2JydXNoLmF0dHIoXCJ3aWR0aFwiKTtcclxuXHRcdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN2Zy5zZWxlY3RBbGwoW2AjJHtzdGF0ZS5jbGlwLmlkfWAsIGAjJHtzdGF0ZS5jbGlwLmlkR3JpZH1gXSlcclxuXHRcdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUud2lkdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgc3RhdGUuaGVpZ2h0KTtcclxuXHJcblx0XHRcdHN2Zy5zZWxlY3QoYCMke3N0YXRlLmNsaXAuaWRYQXhpc31gKVxyXG5cdFx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsICQkLmdldFhBeGlzQ2xpcFguYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsICQkLmdldFhBeGlzQ2xpcFkuYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5nZXRYQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5nZXRYQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFlBeGlzfWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgJCQuZ2V0WUF4aXNDbGlwWC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgJCQuZ2V0WUF4aXNDbGlwWS5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmdldFlBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldFlBeGlzQ2xpcEhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0XHRzdGF0ZS5jbGlwLmlkU3ViY2hhcnQgJiYgc3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFN1YmNoYXJ0fWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLndpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGJydXNoU2l6ZS5oZWlnaHQpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgLiR7Q0xBU1Muem9vbVJlY3R9YClcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLndpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHN0YXRlLmhlaWdodCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHNpemUgdmFsdWVzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc0luaXQgSWYgaXMgY2FsbGVkIGF0IGluaXRpYWxpemF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVTaXplcyhpc0luaXQ/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bGVnZW5kfX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBoYXNBcmMgPSAkJC5oYXNBcmNUeXBlKCk7XHJcblxyXG5cdFx0IWlzSW5pdCAmJiAkJC5zZXRDb250YWluZXJTaXplKCk7XHJcblxyXG5cdFx0Y29uc3QgY3VyckxlZ2VuZCA9IHtcclxuXHRcdFx0d2lkdGg6IGxlZ2VuZCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgOiAwLFxyXG5cdFx0XHRoZWlnaHQ6IGxlZ2VuZCA/ICQkLmdldExlZ2VuZEhlaWdodCgpIDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBsZWdlbmRIZWlnaHRGb3JCb3R0b20gPSBzdGF0ZS5pc0xlZ2VuZFJpZ2h0IHx8IHN0YXRlLmlzTGVnZW5kSW5zZXQgPyAwIDogY3VyckxlZ2VuZC5oZWlnaHQ7XHJcblx0XHRjb25zdCB4QXhpc0hlaWdodCA9IGlzUm90YXRlZCB8fCBoYXNBcmMgPyAwIDogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ4XCIpO1xyXG5cclxuXHRcdGNvbnN0IHN1YmNoYXJ0WEF4aXNIZWlnaHQgPSBjb25maWcuc3ViY2hhcnRfYXhpc194X3Nob3cgJiYgY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdyA/XHJcblx0XHRcdHhBeGlzSGVpZ2h0IDogMzA7XHJcblx0XHRjb25zdCBzdWJjaGFydEhlaWdodCA9IGNvbmZpZy5zdWJjaGFydF9zaG93ICYmICFoYXNBcmMgP1xyXG5cdFx0XHQoY29uZmlnLnN1YmNoYXJ0X3NpemVfaGVpZ2h0ICsgc3ViY2hhcnRYQXhpc0hlaWdodCkgOiAwO1xyXG5cclxuXHRcdC8vIGZvciBtYWluXHJcblx0XHRzdGF0ZS5tYXJnaW4gPSBpc1JvdGF0ZWQgPyB7XHJcblx0XHRcdHRvcDogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ5MlwiKSArICQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCksXHJcblx0XHRcdHJpZ2h0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpLFxyXG5cdFx0XHRib3R0b206ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieVwiKSArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXHJcblx0XHRcdGxlZnQ6IHN1YmNoYXJ0SGVpZ2h0ICsgKGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKSlcclxuXHRcdH0gOiB7XHJcblx0XHRcdHRvcDogNCArICQkLmdldEN1cnJlbnRQYWRkaW5nVG9wKCksIC8vIGZvciB0b3AgdGljayB0ZXh0XHJcblx0XHRcdHJpZ2h0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpLFxyXG5cdFx0XHRib3R0b206IHhBeGlzSGVpZ2h0ICsgc3ViY2hhcnRIZWlnaHQgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20gKyAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpLFxyXG5cdFx0XHRsZWZ0OiBoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KClcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gZm9yIHN1YmNoYXJ0XHJcblx0XHRzdGF0ZS5tYXJnaW4yID0gaXNSb3RhdGVkID8ge1xyXG5cdFx0XHR0b3A6IHN0YXRlLm1hcmdpbi50b3AsXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogMjAgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXHJcblx0XHRcdGxlZnQ6ICQkLnN0YXRlLnJvdGF0ZWRQYWRkaW5nLmxlZnRcclxuXHRcdH0gOiB7XHJcblx0XHRcdHRvcDogc3RhdGUuY3VycmVudC5oZWlnaHQgLSBzdWJjaGFydEhlaWdodCAtIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcclxuXHRcdFx0cmlnaHQ6IE5hTixcclxuXHRcdFx0Ym90dG9tOiBzdWJjaGFydFhBeGlzSGVpZ2h0ICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxyXG5cdFx0XHRsZWZ0OiBzdGF0ZS5tYXJnaW4ubGVmdFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmb3IgbGVnZW5kXHJcblx0XHRzdGF0ZS5tYXJnaW4zID0ge1xyXG5cdFx0XHR0b3A6IDAsXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0bGVmdDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHQkJC51cGRhdGVTaXplRm9yTGVnZW5kICYmICQkLnVwZGF0ZVNpemVGb3JMZWdlbmQoY3VyckxlZ2VuZCk7XHJcblxyXG5cdFx0c3RhdGUud2lkdGggPSBzdGF0ZS5jdXJyZW50LndpZHRoIC0gc3RhdGUubWFyZ2luLmxlZnQgLSBzdGF0ZS5tYXJnaW4ucmlnaHQ7XHJcblx0XHRzdGF0ZS5oZWlnaHQgPSBzdGF0ZS5jdXJyZW50LmhlaWdodCAtIHN0YXRlLm1hcmdpbi50b3AgLSBzdGF0ZS5tYXJnaW4uYm90dG9tO1xyXG5cclxuXHRcdGlmIChzdGF0ZS53aWR0aCA8IDApIHtcclxuXHRcdFx0c3RhdGUud2lkdGggPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5oZWlnaHQgPCAwKSB7XHJcblx0XHRcdHN0YXRlLmhlaWdodCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUud2lkdGgyID0gaXNSb3RhdGVkID9cclxuXHRcdFx0c3RhdGUubWFyZ2luLmxlZnQgLSBzdGF0ZS5yb3RhdGVkUGFkZGluZy5sZWZ0IC0gc3RhdGUucm90YXRlZFBhZGRpbmcucmlnaHQgOiBzdGF0ZS53aWR0aDtcclxuXHJcblx0XHRzdGF0ZS5oZWlnaHQyID0gaXNSb3RhdGVkID9cclxuXHRcdFx0c3RhdGUuaGVpZ2h0IDogc3RhdGUuY3VycmVudC5oZWlnaHQgLSBzdGF0ZS5tYXJnaW4yLnRvcCAtIHN0YXRlLm1hcmdpbjIuYm90dG9tO1xyXG5cclxuXHRcdGlmIChzdGF0ZS53aWR0aDIgPCAwKSB7XHJcblx0XHRcdHN0YXRlLndpZHRoMiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXRlLmhlaWdodDIgPCAwKSB7XHJcblx0XHRcdHN0YXRlLmhlaWdodDIgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBhcmNcclxuXHRcdHN0YXRlLmFyY1dpZHRoID0gc3RhdGUud2lkdGggLSAoc3RhdGUuaXNMZWdlbmRSaWdodCA/IGN1cnJMZWdlbmQud2lkdGggKyAxMCA6IDApO1xyXG5cdFx0c3RhdGUuYXJjSGVpZ2h0ID0gc3RhdGUuaGVpZ2h0IC0gKHN0YXRlLmlzTGVnZW5kUmlnaHQgPyAwIDogMTApO1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlKSB7XHJcblx0XHRcdHN0YXRlLmFyY0hlaWdodCArPSBzdGF0ZS5oZWlnaHQgLSAkJC5nZXRHYXVnZUxhYmVsSGVpZ2h0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudXBkYXRlUmFkaXVzICYmICQkLnVwZGF0ZVJhZGl1cygpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0ICYmIGhhc0FyYykge1xyXG5cdFx0XHRzdGF0ZS5tYXJnaW4zLmxlZnQgPSBzdGF0ZS5hcmNXaWR0aCAvIDIgKyBzdGF0ZS5yYWRpdXNFeHBhbmRlZCAqIDEuMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWhhc0FyYyAmJiBjb25maWcuYXhpc194X3Nob3cgJiYgY29uZmlnLmF4aXNfeF90aWNrX2F1dG9yb3RhdGUpIHtcclxuXHRcdFx0JCQudXBkYXRlWEF4aXNUaWNrQ2xpcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRzZWxlY3RBbGwgYXMgZDNTZWxlY3RBbGxcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7S0VZfSBmcm9tIFwiLi4vLi4vbW9kdWxlL0NhY2hlXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYXBpdGFsaXplLCBnZXRCb3VuZGluZ1JlY3QsIGdldFJhbmRvbSwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1N0cmluZywgZ2V0VHJhbnNsYXRpb259IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge0F4aXNUeXBlfSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0b3BhY2l0eUZvclRleHQoKTogXCIxXCIgfCBcIjBcIiB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNEYXRhTGFiZWwoKSA/IFwiMVwiIDogXCIwXCI7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUZXh0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyRlbH0gPSB0aGlzO1xyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0VGV4dHMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBjaGFydFRleHRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0cyAkJC5kYXRhLnRhcmdldHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRhcmdldHNGb3JUZXh0KHRhcmdldHMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRUZXh0ID0gJCQuY2xhc3NDaGFydFRleHQuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc1RleHRzID0gJCQuY2xhc3NUZXh0cy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgbWFpblRleHRVcGRhdGUgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0VGV4dHN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydFRleHR9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRUZXh0KGQpICsgY2xhc3NGb2N1cyhkKSk7XHJcblxyXG5cdFx0Y29uc3QgbWFpblRleHRFbnRlciA9IG1haW5UZXh0VXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRUZXh0KVxyXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XHJcblxyXG5cdFx0bWFpblRleHRFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NUZXh0cyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRleHRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25Gb3JFeGl0IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhRm4gPSAkJC5sYWJlbGlzaERhdGEuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc1RleHQgPSAkJC5jbGFzc1RleHQuYmluZCgkJCk7XHJcblxyXG5cdFx0JGVsLnRleHQgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MudGV4dH1gKVxyXG5cdFx0XHQuZGF0YShkID0+ICh0aGlzLmlzUmFkYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBkYXRhRm4oZCkpKTtcclxuXHJcblx0XHQkZWwudGV4dC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwudGV4dCA9ICRlbC50ZXh0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0Lm1lcmdlKCQkLiRlbC50ZXh0KVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBkID0+IChjb25maWcuYXhpc19yb3RhdGVkID8gKGQudmFsdWUgPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIikgOiBcIm1pZGRsZVwiKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVUZXh0Q29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnRleHQoKGQsIGksIGopID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9ICQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInpcIikgOiBkLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gJCQuZGF0YUxhYmVsRm9ybWF0KGQuaWQpKHZhbHVlLCBkLmlkLCBpLCBqKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGV4dENvbG9yKGQpOiBvYmplY3QgfCBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgbGFiZWxDb2xvcnMgPSAkJC5jb25maWcuZGF0YV9sYWJlbHNfY29sb3JzO1xyXG5cdFx0bGV0IGNvbG9yO1xyXG5cclxuXHRcdGlmIChpc1N0cmluZyhsYWJlbENvbG9ycykpIHtcclxuXHRcdFx0Y29sb3IgPSBsYWJlbENvbG9ycztcclxuXHRcdH0gZWxzZSBpZiAoaXNPYmplY3QobGFiZWxDb2xvcnMpKSB7XHJcblx0XHRcdGNvbG9yID0gbGFiZWxDb2xvcnNbZC5pZF07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbG9yIHx8ICQkLmNvbG9yKGQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyBjaGFydFRleHRcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB4IFBvc2l0aW9uaW5nIGZ1bmN0aW9uIGZvciB4XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0geSBQb3NpdGlvbmluZyBmdW5jdGlvbiBmb3IgeVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yRmxvdyBXZWF0aGVyIGlzIGZsb3dcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd1RleHQoeCwgeSwgZm9yRmxvdz86IGJvb2xlYW4sIHdpdGhUcmFuc2l0aW9uPzogYm9vbGVhbik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdDogYW55ID0gZ2V0UmFuZG9tKCk7XHJcblx0XHRjb25zdCBvcGFjaXR5Rm9yVGV4dCA9IGZvckZsb3cgPyAwIDogJCQub3BhY2l0eUZvclRleHQuYmluZCgkJCk7XHJcblxyXG5cdFx0JCQuJGVsLnRleHQuZWFjaChmdW5jdGlvbihkLCBpOiBudW1iZXIpIHtcclxuXHRcdFx0Y29uc3QgdGV4dCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0Ly8gZG8gbm90IGFwcGx5IHRyYW5zaXRpb24gZm9yIG5ld2x5IGFkZGVkIHRleHQgZWxlbWVudHNcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uICYmIHRleHQuYXR0cihcInhcIikgPyB0ZXh0LnRyYW5zaXRpb24odCkgOiB0ZXh0KVxyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCB4LmJpbmQodGhpcykoZCwgaSkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIGQgPT4geS5iaW5kKHRoaXMpKGQsIGkpKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlVGV4dENvbG9yLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBvcGFjaXR5Rm9yVGV4dCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBuZWVkIHRvIHJldHVybiAndHJ1ZScgYXMgb2YgYmVpbmcgcHVzaGVkIHRvIHRoZSByZWRyYXcgbGlzdFxyXG5cdFx0Ly8gcmVmOiBnZXRSZWRyYXdMaXN0KClcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB2YWx1ZSBvZiB0aGUgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBlbGVtZW50IFRhcmdldCBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBDbGFzcyBuYW1lXHJcblx0ICogQHJldHVybnMge29iamVjdH0gdmFsdWUgb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VGV4dFJlY3QoZWxlbWVudCwgY2xhc3NOYW1lOiBzdHJpbmcpOiBvYmplY3Qge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IGJhc2UgPSAoZWxlbWVudC5ub2RlID8gZWxlbWVudC5ub2RlKCkgOiBlbGVtZW50KTtcclxuXHJcblx0XHRpZiAoIS90ZXh0L2kudGVzdChiYXNlLnRhZ05hbWUpKSB7XHJcblx0XHRcdGJhc2UgPSBiYXNlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHQgPSBiYXNlLnRleHRDb250ZW50O1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBgJHtLRVkudGV4dFJlY3R9LSR7dGV4dC5yZXBsYWNlKC9cXFcvZywgXCJfXCIpfWA7XHJcblx0XHRsZXQgcmVjdCA9ICQkLmNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG5cdFx0aWYgKCFyZWN0KSB7XHJcblx0XHRcdCQkLiRlbC5zdmcuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0XHQuc3R5bGUoXCJmb250XCIsIGQzU2VsZWN0KGJhc2UpLnN0eWxlKFwiZm9udFwiKSlcclxuXHRcdFx0XHQuY2xhc3NlZChjbGFzc05hbWUsIHRydWUpXHJcblx0XHRcdFx0LnRleHQodGV4dClcclxuXHRcdFx0XHQuY2FsbCh2ID0+IHtcclxuXHRcdFx0XHRcdHJlY3QgPSBnZXRCb3VuZGluZ1JlY3Qodi5ub2RlKCkpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCByZWN0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB4IG9yIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBpbmRpY2VzIEluZGljZXMgdmFsdWVzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBmb3JYIHdoZXRoZXIgb3Igbm90IHRvIHhcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBjb29yZGluYXRlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVYWUZvclRleHQoaW5kaWNlcywgZm9yWD86IGJvb2xlYW4pOiAoZCwgaSkgPT4gbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHR5cGVzID0gT2JqZWN0LmtleXMoaW5kaWNlcyk7XHJcblx0XHRjb25zdCBwb2ludHMgPSB7fTtcclxuXHRcdGNvbnN0IGdldHRlciA9IGZvclggPyAkJC5nZXRYRm9yVGV4dCA6ICQkLmdldFlGb3JUZXh0O1xyXG5cclxuXHRcdCQkLmhhc1R5cGUoXCJyYWRhclwiKSAmJiB0eXBlcy5wdXNoKFwicmFkYXJcIik7XHJcblxyXG5cdFx0dHlwZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0cG9pbnRzW3ZdID0gJCRbYGdlbmVyYXRlR2V0JHtjYXBpdGFsaXplKHYpfVBvaW50c2BdKGluZGljZXNbdl0sIGZhbHNlKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdGNvbnN0IHR5cGUgPSAoJCQuaXNBcmVhVHlwZShkKSAmJiBcImFyZWFcIikgfHxcclxuXHRcdFx0XHQoJCQuaXNCYXJUeXBlKGQpICYmIFwiYmFyXCIpIHx8XHJcblx0XHRcdFx0KCQkLmlzUmFkYXJUeXBlKGQpICYmIFwicmFkYXJcIikgfHwgXCJsaW5lXCI7XHJcblxyXG5cdFx0XHRyZXR1cm4gZ2V0dGVyLmNhbGwoJCQsIHBvaW50c1t0eXBlXShkLCBpKSwgZCwgdGhpcyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBjZW50ZXJpemVkIHRleHQgcG9zaXRpb24gZm9yIGJhciB0eXBlIGRhdGEubGFiZWwudGV4dFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIERhdGEgcG9pbnRzIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGV4dEVsZW1lbnQgRGF0YSBsYWJlbCB0ZXh0IGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NpdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q2VudGVyZWRUZXh0UG9zKGQsIHBvaW50cywgdGV4dEVsZW1lbnQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2xhYmVscy5jZW50ZXJlZCAmJiAkJC5pc0JhclR5cGUoZCkpIHtcclxuXHRcdFx0Y29uc3QgcmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0ZXh0RWxlbWVudCk7XHJcblx0XHRcdGNvbnN0IGlzUG9zaXRpdmUgPSBkLnZhbHVlID49IDA7XHJcblxyXG5cdFx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgdyA9IChcclxuXHRcdFx0XHRcdGlzUG9zaXRpdmUgP1xyXG5cdFx0XHRcdFx0XHRwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV0gOlxyXG5cdFx0XHRcdFx0XHRwb2ludHNbMF1bMV0gLSBwb2ludHNbMV1bMV1cclxuXHRcdFx0XHQpIC8gMiArIChyZWN0LndpZHRoIC8gMik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gLXcgLSAzIDogdyArIDI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgaCA9IChcclxuXHRcdFx0XHRcdGlzUG9zaXRpdmUgP1xyXG5cdFx0XHRcdFx0XHRwb2ludHNbMF1bMV0gLSBwb2ludHNbMV1bMV0gOlxyXG5cdFx0XHRcdFx0XHRwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV1cclxuXHRcdFx0XHQpIC8gMiArIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaXNQb3NpdGl2ZSA/IGggOiAtaCAtIDI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgZGF0YS5sYWJlbHMucG9zaXRpb24gdmFsdWVcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgRGF0YSBpZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIHggfCB5XHJcblx0ICogQHJldHVybnMge251bWJlcn0gUG9zaXRpb24gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRleHRQb3MoaWQsIHR5cGUpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgcG9zID0gdGhpcy5jb25maWcuZGF0YV9sYWJlbHNfcG9zaXRpb247XHJcblxyXG5cdFx0cmV0dXJuIChpZCBpbiBwb3MgPyBwb3NbaWRdIDogcG9zKVt0eXBlXSB8fCAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludHMgRGF0YSBwb2ludHMgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRleHRFbGVtZW50IERhdGEgbGFiZWwgdGV4dCBlbGVtZW50XHJcblx0ICogQHJldHVybnMge251bWJlcn0geCBjb29yZGluYXRlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRYRm9yVGV4dChwb2ludHMsIGQsIHRleHRFbGVtZW50KTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCB4UG9zO1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHRwYWRkaW5nID0gJCQuaXNCYXJUeXBlKGQpID8gNCA6IDY7XHJcblx0XHRcdHhQb3MgPSBwb2ludHNbMl1bMV0gKyBwYWRkaW5nICogKGQudmFsdWUgPCAwID8gLTEgOiAxKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHhQb3MgPSAkJC5oYXNUeXBlKFwiYmFyXCIpID8gKHBvaW50c1syXVswXSArIHBvaW50c1swXVswXSkgLyAyIDogcG9pbnRzWzBdWzBdO1xyXG5cdFx0fVxyXG5cdFx0Ly8gc2hvdyBsYWJlbHMgcmVnYXJkbGVzcyBvZiB0aGUgZG9tYWluIGlmIHZhbHVlIGlzIG51bGxcclxuXHRcdGlmIChkLnZhbHVlID09PSBudWxsKSB7XHJcblx0XHRcdGlmICh4UG9zID4gc3RhdGUud2lkdGgpIHtcclxuXHRcdFx0XHRjb25zdCB7d2lkdGh9ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcclxuXHJcblx0XHRcdFx0eFBvcyA9IHN0YXRlLndpZHRoIC0gd2lkdGg7XHJcblx0XHRcdH0gZWxzZSBpZiAoeFBvcyA8IDApIHtcclxuXHRcdFx0XHR4UG9zID0gNDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0eFBvcyArPSAkJC5nZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHhQb3MgKyAkJC5nZXRUZXh0UG9zKGQuaWQsIFwieFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRleHRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gcG9pbnRzIERhdGEgcG9pbnRzIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0ZXh0RWxlbWVudCBEYXRhIGxhYmVsIHRleHQgZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHkgY29vcmRpbmF0ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WUZvclRleHQocG9pbnRzLCBkLCB0ZXh0RWxlbWVudCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCByID0gY29uZmlnLnBvaW50X3I7XHJcblx0XHRjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcclxuXHRcdGxldCBiYXNlWSA9IDM7XHJcblx0XHRsZXQgeVBvcztcclxuXHJcblx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdHlQb3MgPSAocG9pbnRzWzBdWzBdICsgcG9pbnRzWzJdWzBdICsgcmVjdC5oZWlnaHQgKiAwLjYpIC8gMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHlQb3MgPSBwb2ludHNbMl1bMV07XHJcblxyXG5cdFx0XHRpZiAoaXNOdW1iZXIocikgJiYgciA+IDUgJiYgKCQkLmlzTGluZVR5cGUoZCkgfHwgJCQuaXNTY2F0dGVyVHlwZShkKSkpIHtcclxuXHRcdFx0XHRiYXNlWSArPSBjb25maWcucG9pbnRfciAvIDIuMztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGQudmFsdWUgPCAwIHx8IChkLnZhbHVlID09PSAwICYmICFzdGF0ZS5oYXNQb3NpdGl2ZVZhbHVlICYmIHN0YXRlLmhhc05lZ2F0aXZlVmFsdWUpKSB7XHJcblx0XHRcdFx0eVBvcyArPSByZWN0LmhlaWdodCArICgkJC5pc0JhclR5cGUoZCkgPyAtYmFzZVkgOiBiYXNlWSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGRpZmYgPSAtYmFzZVkgKiAyO1xyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNCYXJUeXBlKGQpKSB7XHJcblx0XHRcdFx0XHRkaWZmID0gLWJhc2VZO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVUeXBlKGQpKSB7XHJcblx0XHRcdFx0XHRkaWZmID0gYmFzZVk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR5UG9zICs9IGRpZmY7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxyXG5cdFx0aWYgKGQudmFsdWUgPT09IG51bGwgJiYgIWlzUm90YXRlZCkge1xyXG5cdFx0XHRjb25zdCBib3hIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuXHJcblx0XHRcdGlmICh5UG9zIDwgYm94SGVpZ2h0KSB7XHJcblx0XHRcdFx0eVBvcyA9IGJveEhlaWdodDtcclxuXHRcdFx0fSBlbHNlIGlmICh5UG9zID4gc3RhdGUuaGVpZ2h0KSB7XHJcblx0XHRcdFx0eVBvcyA9IHN0YXRlLmhlaWdodCAtIDQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWlzUm90YXRlZCkge1xyXG5cdFx0XHR5UG9zICs9ICQkLmdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geVBvcyArICQkLmdldFRleHRQb3MoZC5pZCwgXCJ5XCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSBpZiB0d28gb3IgbW9yZSB0ZXh0IG5vZGVzIGFyZSBvdmVybGFwcGluZ1xyXG5cdCAqIE1hcmsgb3ZlcmxhcHBpbmcgdGV4dCBub2RlcyB3aXRoIFwidGV4dC1vdmVybGFwcGluZ1wiIGNsYXNzXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIEF4aXMgaWRcclxuXHQgKiBAcGFyYW0ge0NoYXJ0SW50ZXJuYWx9ICQkIENoYXJ0SW50ZXJuYWwgY29udGV4dFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciBzdHJpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG1hcmtPdmVybGFwcGVkKGlkOiBBeGlzVHlwZSwgJCQsIHNlbGVjdG9yOiBzdHJpbmcpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHRleHROb2RlcyA9ICQkLiRlbC5hcmNzLnNlbGVjdEFsbChzZWxlY3Rvcik7XHJcblx0XHRjb25zdCBmaWx0ZXJlZFRleHROb2RlcyA9IHRleHROb2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmRhdGEuaWQgIT09IGlkKTtcclxuXHRcdGNvbnN0IHRleHROb2RlID0gdGV4dE5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUuZGF0YS5pZCA9PT0gaWQpO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlID0gZ2V0VHJhbnNsYXRpb24odGV4dE5vZGUubm9kZSgpKTtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhlIGh5cG90ZW51c2VcclxuXHRcdGNvbnN0IGNhbGNIeXBvID0gKHgsIHkpID0+IE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKTtcclxuXHJcblx0XHR0ZXh0Tm9kZS5ub2RlKCkgJiYgZmlsdGVyZWRUZXh0Tm9kZXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgY29vcmRpbmF0ZSA9IGdldFRyYW5zbGF0aW9uKHRoaXMpO1xyXG5cdFx0XHRjb25zdCBmaWx0ZXJlZFRleHROb2RlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdGNvbnN0IG5vZGVGb3JXaWR0aCA9IGNhbGNIeXBvKHRyYW5zbGF0ZS5lLCB0cmFuc2xhdGUuZikgPiBjYWxjSHlwbyhjb29yZGluYXRlLmUsIGNvb3JkaW5hdGUuZikgP1xyXG5cdFx0XHRcdHRleHROb2RlIDogZmlsdGVyZWRUZXh0Tm9kZTtcclxuXHJcblx0XHRcdGNvbnN0IG92ZXJsYXBzWCA9IE1hdGguY2VpbChNYXRoLmFicyh0cmFuc2xhdGUuZSAtIGNvb3JkaW5hdGUuZSkpIDxcclxuXHRcdFx0XHRNYXRoLmNlaWwobm9kZUZvcldpZHRoLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSk7XHJcblx0XHRcdGNvbnN0IG92ZXJsYXBzWSA9IE1hdGguY2VpbChNYXRoLmFicyh0cmFuc2xhdGUuZiAtIGNvb3JkaW5hdGUuZikpIDxcclxuXHRcdFx0XHRwYXJzZUludCh0ZXh0Tm9kZS5zdHlsZShcImZvbnQtc2l6ZVwiKSwgMCk7XHJcblxyXG5cdFx0XHRmaWx0ZXJlZFRleHROb2RlLmNsYXNzZWQoQ0xBU1MuVGV4dE92ZXJsYXBwaW5nLCBvdmVybGFwc1ggJiYgb3ZlcmxhcHNZKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSBpZiB0d28gb3IgbW9yZSB0ZXh0IG5vZGVzIGFyZSBvdmVybGFwcGluZ1xyXG5cdCAqIFJlbW92ZSBcInRleHQtb3ZlcmxhcHBpbmdcIiBjbGFzcyBvbiBzZWxlY3RlZCB0ZXh0IG5vZGVzXHJcblx0ICogQHBhcmFtIHtDaGFydEludGVybmFsfSAkJCBDaGFydEludGVybmFsIGNvbnRleHRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3Igc3RyaW5nXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1bmRvTWFya092ZXJsYXBwZWQoJCQsIHNlbGVjdG9yKTogdm9pZCB7XHJcblx0XHQkJC4kZWwuYXJjcy5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGQzU2VsZWN0QWxsKFt0aGlzLCB0aGlzLnByZXZpb3VzU2libGluZ10pXHJcblx0XHRcdFx0XHQuY2xhc3NlZChDTEFTUy5UZXh0T3ZlcmxhcHBpbmcsIGZhbHNlKTtcclxuXHRcdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNOdW1iZXIsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHRleHQgcG9zaXRpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHBvcyByaWdodCwgbGVmdCBvciBjZW50ZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIGNoYXJ0IHdpZHRoXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVtYmVyfSB0ZXh0LWFuY2hvciB2YWx1ZSBvciBwb3NpdGlvbiBpbiBwaXhlbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VGV4dFBvcyhwb3MgPSBcImxlZnRcIiwgd2lkdGg/OiBudW1iZXIgfCBhbnkpOiBudW1iZXIgfCBcInN0YXJ0XCIgfCBcIm1pZGRsZVwiIHwgXCJlbmRcIiB7XHJcblx0Y29uc3QgaXNOdW0gPSBpc051bWJlcih3aWR0aCk7XHJcblx0bGV0IHBvc2l0aW9uO1xyXG5cclxuXHRpZiAocG9zLmluZGV4T2YoXCJjZW50ZXJcIikgPiAtMSkge1xyXG5cdFx0cG9zaXRpb24gPSBpc051bSA/IHdpZHRoIC8gMiA6IFwibWlkZGxlXCI7XHJcblx0fSBlbHNlIGlmIChwb3MuaW5kZXhPZihcInJpZ2h0XCIpID4gLTEpIHtcclxuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyB3aWR0aCA6IFwiZW5kXCI7XHJcblx0fSBlbHNlIHtcclxuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyAwIDogXCJzdGFydFwiO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHBvc2l0aW9uO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRpdGxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0VGl0bGUoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy50aXRsZV90ZXh0KSB7XHJcblx0XHRcdCRlbC50aXRsZSA9ICRlbC5zdmcuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHRcdGNvbnN0IHRleHQgPSAkZWwudGl0bGVcclxuXHRcdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIGdldFRleHRQb3MoY29uZmlnLnRpdGxlX3Bvc2l0aW9uKSlcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnRpdGxlKTtcclxuXHJcblx0XHRcdHNldFRleHRWYWx1ZSh0ZXh0LCBjb25maWcudGl0bGVfdGV4dCwgWzAuMywgMS41XSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRpdGxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdUaXRsZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y3VycmVudH0sICRlbDoge3RpdGxlfX0gPSAkJDtcclxuXHJcblx0XHRpZiAodGl0bGUpIHtcclxuXHRcdFx0Y29uc3QgeSA9ICQkLnlGb3JUaXRsZS5jYWxsKCQkKTtcclxuXHJcblx0XHRcdGlmICgvZy9pLnRlc3QodGl0bGUubm9kZSgpLnRhZ05hbWUpKSB7XHJcblx0XHRcdFx0dGl0bGUuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7Z2V0VGV4dFBvcyhjb25maWcudGl0bGVfcG9zaXRpb24sIGN1cnJlbnQud2lkdGgpfSwgJHt5fSlgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aXRsZS5hdHRyKFwieFwiLCAkJC54Rm9yVGl0bGUuY2FsbCgkJCkpLmF0dHIoXCJ5XCIsIHkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgeCBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIHRpdGxlXHJcblx0ICogQHJldHVybnMge251bWJlcn0geCBhdHRyaWJ1dGUgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHhGb3JUaXRsZSgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50fX0gPSAkJDtcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gY29uZmlnLnRpdGxlX3Bvc2l0aW9uIHx8IFwibGVmdFwiO1xyXG5cdFx0Y29uc3QgdGV4dFJlY3RXaWR0aCA9ICQkLmdldFRleHRSZWN0KCQkLiRlbC50aXRsZSwgQ0xBU1MudGl0bGUpLndpZHRoO1xyXG5cdFx0bGV0IHg7XHJcblxyXG5cdFx0aWYgKC8ocmlnaHR8Y2VudGVyKS8udGVzdChwb3NpdGlvbikpIHtcclxuXHRcdFx0eCA9IGN1cnJlbnQud2lkdGggLSB0ZXh0UmVjdFdpZHRoO1xyXG5cclxuXHRcdFx0aWYgKHBvc2l0aW9uLmluZGV4T2YoXCJyaWdodFwiKSA+PSAwKSB7XHJcblx0XHRcdFx0eCA9IGN1cnJlbnQud2lkdGggLSB0ZXh0UmVjdFdpZHRoIC0gY29uZmlnLnRpdGxlX3BhZGRpbmcucmlnaHQ7XHJcblx0XHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaW5kZXhPZihcImNlbnRlclwiKSA+PSAwKSB7XHJcblx0XHRcdFx0eCA9IChjdXJyZW50LndpZHRoIC0gdGV4dFJlY3RXaWR0aCkgLyAyO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgeyAvLyBsZWZ0XHJcblx0XHRcdHggPSAoY29uZmlnLnRpdGxlX3BhZGRpbmcubGVmdCB8fCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB5IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSB5IGF0dHJpYnV0ZSB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0eUZvclRpdGxlKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICgkJC5jb25maWcudGl0bGVfcGFkZGluZy50b3AgfHwgMCkgK1xyXG5cdFx0XHQkJC5nZXRUZXh0UmVjdCgkJC4kZWwudGl0bGUsIENMQVNTLnRpdGxlKS5oZWlnaHQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpdGxlIHBhZGRpbmdcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBwYWRkaW5nIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUaXRsZVBhZGRpbmcoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQueUZvclRpdGxlKCkgKyAoJCQuY29uZmlnLnRpdGxlX3BhZGRpbmcuYm90dG9tIHx8IDApO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0bW91c2UgYXMgZDNNb3VzZVxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzVmFsdWUsIGNhbGxGbiwgc2FuaXRpc2UsIHRwbFByb2Nlc3MsIGlzVW5kZWZpbmVkLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0VG9vbHRpcCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHtiaW5kdG99ID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XHJcblxyXG5cdFx0JGVsLnRvb2x0aXAgPSBkM1NlbGVjdChiaW5kdG8pO1xyXG5cclxuXHRcdGlmICgkZWwudG9vbHRpcC5lbXB0eSgpKSB7XHJcblx0XHRcdCRlbC50b29sdGlwID0gJGVsLmNoYXJ0XHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJkaXZcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnRvb2x0aXBDb250YWluZXIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNob3cgdG9vbHRpcCBpZiBuZWVkZWRcclxuXHRcdGlmIChjb25maWcudG9vbHRpcF9pbml0X3Nob3cpIHtcclxuXHRcdFx0aWYgKCQkLmF4aXMuaXNUaW1lU2VyaWVzKCkgJiYgaXNTdHJpbmcoY29uZmlnLnRvb2x0aXBfaW5pdF94KSkge1xyXG5cdFx0XHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHNbMF07XHJcblx0XHRcdFx0bGV0IGk7XHJcblx0XHRcdFx0bGV0IHZhbDtcclxuXHJcblx0XHRcdFx0Y29uZmlnLnRvb2x0aXBfaW5pdF94ID0gcGFyc2VEYXRlLmNhbGwoJCQsIGNvbmZpZy50b29sdGlwX2luaXRfeCk7XHJcblxyXG5cdFx0XHRcdGZvciAoaSA9IDA7ICh2YWwgPSB0YXJnZXRzLnZhbHVlc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdFx0aWYgKCh2YWwueCAtIGNvbmZpZy50b29sdGlwX2luaXRfeCkgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25maWcudG9vbHRpcF9pbml0X3ggPSBpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkZWwudG9vbHRpcC5odG1sKCQkLmdldFRvb2x0aXBIVE1MKFxyXG5cdFx0XHRcdCQkLmRhdGEudGFyZ2V0cy5tYXAoZCA9PiAkJC5hZGROYW1lKGQudmFsdWVzW2NvbmZpZy50b29sdGlwX2luaXRfeF0pKSxcclxuXHRcdFx0XHQkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpLFxyXG5cdFx0XHRcdCQkLmdldFlGb3JtYXQoJCQuaGFzQXJjVHlwZShudWxsLCBbXCJyYWRhclwiXSkpLFxyXG5cdFx0XHRcdCQkLmNvbG9yXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdFx0aWYgKCFiaW5kdG8pIHtcclxuXHRcdFx0XHQkZWwudG9vbHRpcC5zdHlsZShcInRvcFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLnRvcClcclxuXHRcdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgY29uZmlnLnRvb2x0aXBfaW5pdF9wb3NpdGlvbi5sZWZ0KVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuYmluZFRvb2x0aXBSZXNpemVQb3MoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHRvb2x0aXAgSFRNTCBzdHJpbmdcclxuXHQgKiBAcGFyYW0gIHtBcnJheX0gYXJncyBBcmd1bWVudHNcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBGb3JtYXR0ZWQgSFRNTCBzdHJpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvb2x0aXBIVE1MKC4uLmFyZ3MpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2FwaSwgY29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZy50b29sdGlwX2NvbnRlbnRzKSA/XHJcblx0XHRcdGNvbmZpZy50b29sdGlwX2NvbnRlbnRzLmJpbmQoYXBpKSguLi5hcmdzKSA6ICQkLmdldFRvb2x0aXBDb250ZW50KC4uLmFyZ3MpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHRvb2x0aXAgY29udGVudChIVE1MIHN0cmluZylcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBkYXRhXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFRpdGxlRm9ybWF0IERlZmF1bHQgdGl0bGUgZm9ybWF0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFZhbHVlRm9ybWF0IERlZmF1bHQgZm9ybWF0IGZvciBlYWNoIGRhdGEgdmFsdWUgaW4gdGhlIHRvb2x0aXAuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY29sb3IgQ29sb3IgZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBodG1sXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUb29sdGlwQ29udGVudChkLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCwgY29sb3IpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2FwaSwgY29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGxldCBbdGl0bGVGb3JtYXQsIG5hbWVGb3JtYXQsIHZhbHVlRm9ybWF0XSA9IFtcInRpdGxlXCIsIFwibmFtZVwiLCBcInZhbHVlXCJdLm1hcCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgZm4gPSBjb25maWdbYHRvb2x0aXBfZm9ybWF0XyR7dn1gXTtcclxuXHJcblx0XHRcdHJldHVybiBpc0Z1bmN0aW9uKGZuKSA/IGZuLmJpbmQoYXBpKSA6IGZuO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGl0bGVGb3JtYXQgPSB0aXRsZUZvcm1hdCB8fCBkZWZhdWx0VGl0bGVGb3JtYXQ7XHJcblx0XHRuYW1lRm9ybWF0ID0gbmFtZUZvcm1hdCB8fCAobmFtZSA9PiBuYW1lKTtcclxuXHRcdHZhbHVlRm9ybWF0ID0gdmFsdWVGb3JtYXQgfHwgKFxyXG5cdFx0XHQkJC5pc1N0YWNrTm9ybWFsaXplZCgpID8gKHYsIHJhdGlvKSA9PiBgJHsocmF0aW8gKiAxMDApLnRvRml4ZWQoMil9JWAgOiBkZWZhdWx0VmFsdWVGb3JtYXRcclxuXHRcdCk7XHJcblxyXG5cdFx0Y29uc3Qgb3JkZXIgPSBjb25maWcudG9vbHRpcF9vcmRlcjtcclxuXHRcdGNvbnN0IGdldFJvd1ZhbHVlID0gcm93ID0+ICgkJC5heGlzICYmICQkLmlzQnViYmxlWlR5cGUocm93KSA/ICQkLmdldEJ1YmJsZVpEYXRhKHJvdy52YWx1ZSwgXCJ6XCIpIDogJCQuZ2V0QmFzZVZhbHVlKHJvdykpO1xyXG5cdFx0Y29uc3QgZ2V0QmdDb2xvciA9ICQkLmxldmVsQ29sb3IgPyByb3cgPT4gJCQubGV2ZWxDb2xvcihyb3cudmFsdWUpIDogcm93ID0+IGNvbG9yKHJvdyk7XHJcblx0XHRjb25zdCBjb250ZW50cyA9IGNvbmZpZy50b29sdGlwX2NvbnRlbnRzO1xyXG5cdFx0Y29uc3QgdHBsU3RyID0gY29udGVudHMudGVtcGxhdGU7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcygpO1xyXG5cclxuXHRcdGlmIChvcmRlciA9PT0gbnVsbCAmJiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoKSB7XHJcblx0XHRcdC8vIGZvciBzdGFja2VkIGRhdGEsIG9yZGVyIHNob3VsZCBhbGlnbmVkIHdpdGggdGhlIHZpc3VhbGx5IGRpc3BsYXllZCBkYXRhXHJcblx0XHRcdGNvbnN0IGlkcyA9ICQkLm9yZGVyVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpXHJcblx0XHRcdFx0Lm1hcChpMiA9PiBpMi5pZClcclxuXHRcdFx0XHQucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0ZC5zb3J0KChhLCBiKSA9PiB7XHJcblx0XHRcdFx0bGV0IHYxID0gYSA/IGEudmFsdWUgOiBudWxsO1xyXG5cdFx0XHRcdGxldCB2MiA9IGIgPyBiLnZhbHVlIDogbnVsbDtcclxuXHJcblx0XHRcdFx0aWYgKHYxID4gMCAmJiB2MiA+IDApIHtcclxuXHRcdFx0XHRcdHYxID0gYS5pZCA/IGlkcy5pbmRleE9mKGEuaWQpIDogbnVsbDtcclxuXHRcdFx0XHRcdHYyID0gYi5pZCA/IGlkcy5pbmRleE9mKGIuaWQpIDogbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB2MSAtIHYyO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoL14oYXNjfGRlc2MpJC8udGVzdChvcmRlcikpIHtcclxuXHRcdFx0Y29uc3QgaXNBc2NlbmRpbmcgPSBvcmRlciA9PT0gXCJhc2NcIjtcclxuXHJcblx0XHRcdGQuc29ydCgoYSwgYikgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHYxID0gYSA/IGdldFJvd1ZhbHVlKGEpIDogbnVsbDtcclxuXHRcdFx0XHRjb25zdCB2MiA9IGIgPyBnZXRSb3dWYWx1ZShiKSA6IG51bGw7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpc0FzY2VuZGluZyA/IHYxIC0gdjIgOiB2MiAtIHYxO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihvcmRlcikpIHtcclxuXHRcdFx0ZC5zb3J0KG9yZGVyLmJpbmQoYXBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdHBsID0gJCQuZ2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpO1xyXG5cdFx0Y29uc3QgbGVuID0gZC5sZW5ndGg7XHJcblx0XHRsZXQgdGV4dDtcclxuXHRcdGxldCByb3c7XHJcblx0XHRsZXQgcGFyYW07XHJcblx0XHRsZXQgdmFsdWU7XHJcblx0XHRsZXQgaTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cm93ID0gZFtpXTtcclxuXHJcblx0XHRcdGlmICghcm93IHx8ICEoZ2V0Um93VmFsdWUocm93KSB8fCBnZXRSb3dWYWx1ZShyb3cpID09PSAwKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaXNVbmRlZmluZWQodGV4dCkpIHtcclxuXHRcdFx0XHRjb25zdCB0aXRsZSA9IHNhbml0aXNlKHRpdGxlRm9ybWF0ID8gdGl0bGVGb3JtYXQocm93LngpIDogcm93LngpO1xyXG5cclxuXHRcdFx0XHR0ZXh0ID0gdHBsUHJvY2Vzcyh0cGxbMF0sIHtcclxuXHRcdFx0XHRcdENMQVNTX1RPT0xUSVA6IENMQVNTLnRvb2x0aXAsXHJcblx0XHRcdFx0XHRUSVRMRTogaXNWYWx1ZSh0aXRsZSkgPyAoXHJcblx0XHRcdFx0XHRcdHRwbFN0ciA/IHRpdGxlIDogYDx0cj48dGggY29sc3Bhbj1cIjJcIj4ke3RpdGxlfTwvdGg+PC90cj5gXHJcblx0XHRcdFx0XHQpIDogXCJcIlxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwYXJhbSA9IFtyb3cucmF0aW8sIHJvdy5pZCwgcm93LmluZGV4LCBkXTtcclxuXHRcdFx0dmFsdWUgPSBzYW5pdGlzZSh2YWx1ZUZvcm1hdChnZXRSb3dWYWx1ZShyb3cpLCAuLi5wYXJhbSkpO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzQXJlYVJhbmdlVHlwZShyb3cpKSB7XHJcblx0XHRcdFx0Y29uc3QgW2hpZ2gsIGxvd10gPSBbXCJoaWdoXCIsIFwibG93XCJdLm1hcCh2ID0+IHNhbml0aXNlKFxyXG5cdFx0XHRcdFx0dmFsdWVGb3JtYXQoJCQuZ2V0QXJlYVJhbmdlRGF0YShyb3csIHYpLCAuLi5wYXJhbSlcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSBgPGI+TWlkOjwvYj4gJHt2YWx1ZX0gPGI+SGlnaDo8L2I+ICR7aGlnaH0gPGI+TG93OjwvYj4gJHtsb3d9YDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHQvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxyXG5cdFx0XHRcdGlmIChyb3cubmFtZSA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBuYW1lID0gc2FuaXRpc2UobmFtZUZvcm1hdChyb3cubmFtZSwgLi4ucGFyYW0pKTtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9IGdldEJnQ29sb3Iocm93KTtcclxuXHRcdFx0XHRjb25zdCBjb250ZW50VmFsdWUgPSB7XHJcblx0XHRcdFx0XHRDTEFTU19UT09MVElQX05BTUU6IENMQVNTLnRvb2x0aXBOYW1lICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgocm93LmlkKSxcclxuXHRcdFx0XHRcdENPTE9SOiAodHBsU3RyIHx8ICEkJC5wYXR0ZXJucykgPyBjb2xvciA6IGA8c3ZnPjxyZWN0IHN0eWxlPVwiZmlsbDoke2NvbG9yfVwiIHdpZHRoPVwiMTBcIiBoZWlnaHQ9XCIxMFwiPjwvcmVjdD48L3N2Zz5gLFxyXG5cdFx0XHRcdFx0TkFNRTogbmFtZSxcclxuXHRcdFx0XHRcdFZBTFVFOiB2YWx1ZVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGlmICh0cGxTdHIgJiYgaXNPYmplY3QoY29udGVudHMudGV4dCkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdGFyZ2V0SWRzLmluZGV4T2Yocm93LmlkKTtcclxuXHJcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhjb250ZW50cy50ZXh0KS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnRWYWx1ZVtrZXldID0gY29udGVudHMudGV4dFtrZXldW2luZGV4XTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dCArPSB0cGxQcm9jZXNzKHRwbFsxXSwgY29udGVudFZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBgJHt0ZXh0fTwvdGFibGU+YDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGNvbnRlbnQgdGVtcGxhdGUgc3RyaW5nXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRwbFN0ciBUZW1wYWx0ZSBzdHJpbmdcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRlbXBsYXRlIHN0cmluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpOiBzdHJpbmdbXSB7XHJcblx0XHRyZXR1cm4gKHRwbFN0ciB8fCBgPHRhYmxlIGNsYXNzPVwiez1DTEFTU19UT09MVElQfVwiPjx0Ym9keT5cclxuXHRcdFx0XHR7PVRJVExFfVxyXG5cdFx0XHRcdHt7PHRyIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+XHJcblx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJuYW1lXCI+JHt0aGlzLnBhdHRlcm5zID8gYHs9Q09MT1J9YCA6IGA8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ez1DT0xPUn1cIj48L3NwYW4+YH17PU5BTUV9PC90ZD5cclxuXHRcdFx0XHRcdDx0ZCBjbGFzcz1cInZhbHVlXCI+ez1WQUxVRX08L3RkPlxyXG5cdFx0XHRcdDwvdHI+fX1cclxuXHRcdFx0PC90Ym9keT48L3RhYmxlPmApXHJcblx0XHRcdC5yZXBsYWNlKC8oXFxyP1xcbnxcXHQpL2csIFwiXCIpXHJcblx0XHRcdC5zcGxpdCgve3soLiopfX0vKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhVG9TaG93IGRhdGFcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdFdpZHRoIFdpZHRoIHZhbHVlIG9mIHRvb2x0aXAgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0SGVpZ2h0IEhlaWdodCB2YWx1ZSBvZiB0b29sdGlwIGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRvb2x0aXAgZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRvcCwgbGVmdCB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dG9vbHRpcFBvc2l0aW9uKGRhdGFUb1Nob3csIHRXaWR0aDogbnVtYmVyLCB0SGVpZ2h0OiBudW1iZXIsIGVsZW1lbnQpOlxyXG5cdFx0e3RvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9IHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHQsIGN1cnJlbnQsIGlzTGVnZW5kUmlnaHQsIGlucHV0VHlwZX0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZTtcclxuXHRcdGNvbnN0IHN2Z0xlZnQgPSAkJC5nZXRTdmdMZWZ0KHRydWUpO1xyXG5cdFx0bGV0IFtsZWZ0LCB0b3BdID0gZDNNb3VzZShlbGVtZW50KTtcclxuXHRcdGxldCBjaGFydFJpZ2h0ID0gc3ZnTGVmdCArIGN1cnJlbnQud2lkdGggLSAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KHRydWUpO1xyXG5cdFx0Y29uc3QgY2hhcnRMZWZ0ID0gJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KHRydWUpO1xyXG5cdFx0Y29uc3Qgc2l6ZSA9IDIwO1xyXG5cclxuXHRcdHRvcCArPSBzaXplO1xyXG5cclxuXHRcdC8vIERldGVybWluZSB0b29sdGlwIHBvc2l0aW9uXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdGNvbnN0IHJhdyA9IGlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcclxuXHJcblx0XHRcdGlmICghcmF3KSB7XHJcblx0XHRcdFx0dG9wICs9IGhhc0dhdWdlID8gaGVpZ2h0IDogaGVpZ2h0IC8gMjtcclxuXHRcdFx0XHRsZWZ0ICs9ICh3aWR0aCAtIChpc0xlZ2VuZFJpZ2h0ID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSA6IDApKSAvIDI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGRhdGFTY2FsZSA9IHNjYWxlLngoZGF0YVRvU2hvd1swXS54KTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XHJcblx0XHRcdFx0dG9wID0gZGF0YVNjYWxlICsgc2l6ZTtcclxuXHRcdFx0XHRsZWZ0ICs9IHN2Z0xlZnQgKyAxMDA7XHJcblx0XHRcdFx0Y2hhcnRSaWdodCAtPSBzdmdMZWZ0O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRvcCAtPSA1O1xyXG5cdFx0XHRcdGxlZnQgPSBzdmdMZWZ0ICsgY2hhcnRMZWZ0ICsgc2l6ZSArICgkJC56b29tU2NhbGUgPyBsZWZ0IDogZGF0YVNjYWxlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdoZW4gdG9vbHRpcCBsZWZ0ICsgdFdpZHRoID4gY2hhcnQncyB3aWR0aFxyXG5cdFx0aWYgKChsZWZ0ICsgdFdpZHRoICsgMTUpID4gY2hhcnRSaWdodCkge1xyXG5cdFx0XHRsZWZ0IC09IHRXaWR0aCArIGNoYXJ0TGVmdDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodG9wICsgdEhlaWdodCA+IGN1cnJlbnQuaGVpZ2h0KSB7XHJcblx0XHRcdHRvcCAtPSBoYXNHYXVnZSA/IHRIZWlnaHQgKiAzIDogdEhlaWdodCArIDMwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHBvcyA9IHt0b3AsIGxlZnR9O1xyXG5cclxuXHRcdC8vIG1ha2Ugc3VyZSB0byBub3QgYmUgcG9zaXRpb25lZCBvdXQgb2Ygdmlld3BvcnRcclxuXHRcdE9iamVjdC5rZXlzKHBvcykuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0aWYgKHBvc1t2XSA8IDApIHtcclxuXHRcdFx0XHRwb3Nbdl0gPSAwO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gcG9zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgdGhlIHRvb2x0aXBcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gc2VsZWN0ZWREYXRhIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUb29sdGlwIGVsZW1lbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgZWxlbWVudCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3Rvb2x0aXB9fSA9ICQkO1xyXG5cdFx0Y29uc3Qge2JpbmR0b30gPSBjb25maWcudG9vbHRpcF9jb250ZW50cztcclxuXHRcdGNvbnN0IGZvckFyYyA9ICQkLmhhc0FyY1R5cGUobnVsbCwgW1wicmFkYXJcIl0pO1xyXG5cdFx0Y29uc3QgZGF0YVRvU2hvdyA9IHNlbGVjdGVkRGF0YS5maWx0ZXIoZCA9PiBkICYmIGlzVmFsdWUoJCQuZ2V0QmFzZVZhbHVlKGQpKSk7XHJcblxyXG5cdFx0aWYgKGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICFjb25maWcudG9vbHRpcF9zaG93KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgZGF0dW0gPSB0b29sdGlwLmRhdHVtKCk7XHJcblx0XHRsZXQge3dpZHRoID0gMCwgaGVpZ2h0ID0gMH0gPSBkYXR1bSB8fCB7fTtcclxuXHRcdGNvbnN0IGRhdGFTdHIgPSBKU09OLnN0cmluZ2lmeShzZWxlY3RlZERhdGEpO1xyXG5cclxuXHRcdGlmICghZGF0dW0gfHwgZGF0dW0uY3VycmVudCAhPT0gZGF0YVN0cikge1xyXG5cdFx0XHRjb25zdCBpbmRleCA9IHNlbGVjdGVkRGF0YS5jb25jYXQoKS5zb3J0KClbMF0uaW5kZXg7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25zaG93LCAkJC5hcGksIHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBjb250ZW50XHJcblx0XHRcdHRvb2x0aXBcclxuXHRcdFx0XHQuaHRtbCgkJC5nZXRUb29sdGlwSFRNTChcclxuXHRcdFx0XHRcdHNlbGVjdGVkRGF0YSwgLy8gZGF0YVxyXG5cdFx0XHRcdFx0JCQuYXhpcyA/ICQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCkgOiAkJC5jYXRlZ29yeU5hbWUuYmluZCgkJCksIC8vIGRlZmF1bHRUaXRsZUZvcm1hdFxyXG5cdFx0XHRcdFx0JCQuZ2V0WUZvcm1hdChmb3JBcmMpLCAvLyBkZWZhdWx0VmFsdWVGb3JtYXRcclxuXHRcdFx0XHRcdCQkLmNvbG9yIC8vIGNvbG9yXHJcblx0XHRcdFx0KSlcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBudWxsKSAvLyBmb3IgSUU5XHJcblx0XHRcdFx0LmRhdHVtKGRhdHVtID0ge1xyXG5cdFx0XHRcdFx0aW5kZXgsXHJcblx0XHRcdFx0XHRjdXJyZW50OiBkYXRhU3RyLFxyXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoID0gdG9vbHRpcC5wcm9wZXJ0eShcIm9mZnNldFdpZHRoXCIpLFxyXG5cdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQgPSB0b29sdGlwLnByb3BlcnR5KFwib2Zmc2V0SGVpZ2h0XCIpXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25zaG93biwgJCQuYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cdFx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKHRydWUsIGluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWJpbmR0bykge1xyXG5cdFx0XHRjb25zdCBmblBvcyA9IGNvbmZpZy50b29sdGlwX3Bvc2l0aW9uIHx8ICQkLnRvb2x0aXBQb3NpdGlvbjtcclxuXHJcblx0XHRcdC8vIEdldCB0b29sdGlwIGRpbWVuc2lvbnNcclxuXHRcdFx0Y29uc3QgcG9zID0gZm5Qb3MuY2FsbCh0aGlzLCBkYXRhVG9TaG93LCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KTtcclxuXHJcblx0XHRcdFtcInRvcFwiLCBcImxlZnRcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHBvc1t2XTtcclxuXHJcblx0XHRcdFx0dG9vbHRpcC5zdHlsZSh2LCBgJHt2YWx1ZX1weGApO1xyXG5cclxuXHRcdFx0XHQvLyBSZW1lbWJlciBsZWZ0IHBvcyBpbiBwZXJjZW50YWdlIHRvIGJlIHVzZWQgb24gcmVzaXplIGNhbGxcclxuXHRcdFx0XHRpZiAodiA9PT0gXCJsZWZ0XCIgJiYgIWRhdHVtLnhQb3NJblBlcmNlbnQpIHtcclxuXHRcdFx0XHRcdGRhdHVtLnhQb3NJblBlcmNlbnQgPSB2YWx1ZSAvIHN0YXRlLmN1cnJlbnQud2lkdGggKiAxMDA7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBBZGp1c3QgdG9vbHRpcCBwb3NpdGlvbiBvbiByZXNpemUgZXZlbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRUb29sdGlwUmVzaXplUG9zKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3Jlc2l6ZUZ1bmN0aW9uLCBzdGF0ZSwgJGVsOiB7dG9vbHRpcH19ID0gJCQ7XHJcblxyXG5cdFx0cmVzaXplRnVuY3Rpb24uYWRkKCgpID0+IHtcclxuXHRcdFx0aWYgKHRvb2x0aXAuc3R5bGUoXCJkaXNwbGF5XCIpID09PSBcImJsb2NrXCIpIHtcclxuXHRcdFx0XHRjb25zdCB7Y3VycmVudH0gPSBzdGF0ZTtcclxuXHRcdFx0XHRjb25zdCB7d2lkdGgsIHhQb3NJblBlcmNlbnR9ID0gdG9vbHRpcC5kYXR1bSgpO1xyXG5cdFx0XHRcdGxldCB2YWx1ZSA9IGN1cnJlbnQud2lkdGggLyAxMDAgKiB4UG9zSW5QZXJjZW50O1xyXG5cdFx0XHRcdGNvbnN0IGRpZmYgPSBjdXJyZW50LndpZHRoIC0gKHZhbHVlICsgd2lkdGgpO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0b29sdGlwIHNpemUgb3ZlcnMgY3VycmVudCB2aWV3cG9ydCBzaXplXHJcblx0XHRcdFx0aWYgKGRpZmYgPCAwKSB7XHJcblx0XHRcdFx0XHR2YWx1ZSArPSBkaWZmO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dG9vbHRpcC5zdHlsZShcImxlZnRcIiwgYCR7dmFsdWV9cHhgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSB0aGUgdG9vbHRpcFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2UgRm9yY2UgdG8gaGlkZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGlkZVRvb2x0aXAoZm9yY2U/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXBpLCBjb25maWcsICRlbDoge3Rvb2x0aXB9fSA9ICQkO1xyXG5cclxuXHRcdGlmICh0b29sdGlwLnN0eWxlKFwiZGlzcGxheVwiKSAhPT0gXCJub25lXCIgJiYgKCFjb25maWcudG9vbHRpcF9kb05vdEhpZGUgfHwgZm9yY2UpKSB7XHJcblx0XHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9IEpTT04ucGFyc2UodG9vbHRpcC5kYXR1bSgpLmN1cnJlbnQpO1xyXG5cclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uaGlkZSwgYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cclxuXHRcdFx0Ly8gaGlkZSB0b29sdGlwXHJcblx0XHRcdHRvb2x0aXBcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikgLy8gZm9yIElFOVxyXG5cdFx0XHRcdC5kYXR1bShudWxsKTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbmhpZGRlbiwgYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZSBkaXNwbGF5IGZvciBsaW5rZWQgY2hhcnQgaW5zdGFuY2VzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBzaG93IHRydWU6IHNob3csIGZhbHNlOiBoaWRlXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IHggQXhpcyBpbmRleFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2hhbmRsZUxpbmtlZENoYXJ0cyhzaG93OiBib29sZWFuLCBpbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y2hhcnRzLCBjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy50b29sdGlwX2xpbmtlZCAmJiBjaGFydHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRjb25zdCBsaW5rZWROYW1lID0gY29uZmlnLnRvb2x0aXBfbGlua2VkX25hbWU7XHJcblxyXG5cdFx0XHRjaGFydHMuZm9yRWFjaChjID0+IHtcclxuXHRcdFx0XHRpZiAoYyAhPT0gJCQuYXBpKSB7XHJcblx0XHRcdFx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gYy5pbnRlcm5hbDtcclxuXHRcdFx0XHRcdGNvbnN0IGlzTGlua2VkID0gY29uZmlnLnRvb2x0aXBfbGlua2VkO1xyXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IGNvbmZpZy50b29sdGlwX2xpbmtlZF9uYW1lO1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNJbkRvbSA9IGRvY3VtZW50LmJvZHkuY29udGFpbnMoJGVsLmNoYXJ0Lm5vZGUoKSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGlzTGlua2VkICYmIGxpbmtlZE5hbWUgPT09IG5hbWUgJiYgaXNJbkRvbSkge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhID0gYy5pbnRlcm5hbC4kZWwudG9vbHRpcC5kYXRhKClbMF07XHJcblx0XHRcdFx0XHRcdGNvbnN0IGlzTm90U2FtZUluZGV4ID0gaW5kZXggIT09IChkYXRhICYmIGRhdGEuaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gcHJldmVudCB0aHJvd2luZyBlcnJvciBmb3Igbm9uLXBhaXJlZCBsaW5rZWQgaW5kZXhlc1xyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzaG93ICYmIGlzTm90U2FtZUluZGV4KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjLnRvb2x0aXAuc2hvdyh7aW5kZXh9KTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCFzaG93KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjLnRvb2x0aXAuaGlkZSgpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZSkge31cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7YXNIYWxmUGl4ZWx9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxudHlwZSBUcmFuc2xhdGVQYXJhbSA9IFwibWFpblwiIHwgXCJjb250ZXh0XCIgfCBcImxlZ2VuZFwiIHwgXCJ4XCIgfCBcInlcIiB8IFwieTJcIiB8IFwic3ViWFwiIHwgXCJhcmNcIiB8IFwicmFkYXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRUcmFuc2xhdGUodGFyZ2V0OiBUcmFuc2xhdGVQYXJhbSwgaW5kZXggPSAwKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0bGV0IHBhZGRpbmcgPSAwO1xyXG5cdFx0bGV0IHg7XHJcblx0XHRsZXQgeTtcclxuXHJcblx0XHRpZiAoaW5kZXggJiYgL14oeHx5Mj8pJC8udGVzdCh0YXJnZXQpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAkJC5nZXRBeGlzU2l6ZSh0YXJnZXQpICogaW5kZXg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRhcmdldCA9PT0gXCJtYWluXCIpIHtcclxuXHRcdFx0eCA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi5sZWZ0KTtcclxuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi50b3ApO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwiY29udGV4dFwiKSB7XHJcblx0XHRcdHggPSBhc0hhbGZQaXhlbChzdGF0ZS5tYXJnaW4yLmxlZnQpO1xyXG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luMi50b3ApO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwibGVnZW5kXCIpIHtcclxuXHRcdFx0eCA9IHN0YXRlLm1hcmdpbjMubGVmdDtcclxuXHRcdFx0eSA9IHN0YXRlLm1hcmdpbjMudG9wICsgKGhhc0dhdWdlID8gMTAgOiAwKTtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInhcIikge1xyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gLXBhZGRpbmcgOiAwO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodCArIHBhZGRpbmc7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ5XCIpIHtcclxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiAtcGFkZGluZztcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCArIHBhZGRpbmcgOiAwO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieTJcIikge1xyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IHN0YXRlLndpZHRoICsgcGFkZGluZztcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDEgLSBwYWRkaW5nIDogMDtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInN1YlhcIikge1xyXG5cdFx0XHR4ID0gMDtcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDAgOiBzdGF0ZS5oZWlnaHQyO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwiYXJjXCIpIHtcclxuXHRcdFx0eCA9IHN0YXRlLmFyY1dpZHRoIC8gMjtcclxuXHRcdFx0eSA9IHN0YXRlLmFyY0hlaWdodCAvIDI7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdGNvbnN0IFt3aWR0aF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHJcblx0XHRcdHggPSBzdGF0ZS53aWR0aCAvIDIgLSB3aWR0aDtcclxuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi50b3ApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYDtcclxuXHR9LFxyXG5cclxuXHR0cmFuc2Zvcm1NYWluKHdpdGhUcmFuc2l0aW9uOiBib29sZWFuLCB0cmFuc2l0aW9ucyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0bGV0IHhBeGlzO1xyXG5cdFx0bGV0IHlBeGlzO1xyXG5cdFx0bGV0IHkyQXhpcztcclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1gpIHtcclxuXHRcdFx0eEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHhBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0eEF4aXMgPSB4QXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kpIHtcclxuXHRcdFx0eUF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHlBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0eUF4aXMgPSB5QXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kyKSB7XHJcblx0XHRcdHkyQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNZMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHkyQXhpcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWTJ9YCk7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHR5MkF4aXMgPSB5MkF4aXMudHJhbnNpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gbWFpbi50cmFuc2l0aW9uKCkgOiBtYWluKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcclxuXHJcblx0XHR4QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInhcIikpO1xyXG5cdFx0eUF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ5XCIpKTtcclxuXHRcdHkyQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInkyXCIpKTtcclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzfWApXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImFyY1wiKSk7XHJcblx0fSxcclxuXHJcblx0dHJhbnNmb3JtQWxsKHdpdGhUcmFuc2l0aW9uOiBib29sZWFuLCB0cmFuc2l0aW9ucyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtoYXNBeGlzfSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLnRyYW5zZm9ybU1haW4od2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcclxuXHJcblx0XHRoYXNBeGlzICYmIGNvbmZpZy5zdWJjaGFydF9zaG93ICYmXHJcblx0XHRcdCQkLnRyYW5zZm9ybUNvbnRleHQod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcclxuXHJcblx0XHQkZWwubGVnZW5kICYmICQkLnRyYW5zZm9ybUxlZ2VuZCh3aXRoVHJhbnNpdGlvbik7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNTdHJpbmcsIGlzQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge1RZUEUsIFRZUEVfQllfQ0FURUdPUll9IGZyb20gXCIuLi8uLi9jb25maWcvY29uc3RcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRzZXRUYXJnZXRUeXBlKHRhcmdldElkczogc3RyaW5nW10sIHR5cGU6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aXRob3V0RmFkZUlufX0gPSAkJDtcclxuXHJcblx0XHQkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHR3aXRob3V0RmFkZUluW2lkXSA9ICh0eXBlID09PSBjb25maWcuZGF0YV90eXBlc1tpZF0pO1xyXG5cdFx0XHRjb25maWcuZGF0YV90eXBlc1tpZF0gPSB0eXBlO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMpIHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfdHlwZSA9IHR5cGU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkdGUgY3VycmVudCB1c2VkIGNoYXJ0IHR5cGVzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVUeXBlc0VsZW1lbnRzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7Y3VycmVudH19ID0gJCQ7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMoVFlQRSkuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgdCA9IFRZUEVbdl07XHJcblx0XHRcdGNvbnN0IGhhcyA9ICQkLmhhc1R5cGUodCwgbnVsbCwgdHJ1ZSk7XHJcblx0XHRcdGNvbnN0IGlkeCA9IGN1cnJlbnQudHlwZXMuaW5kZXhPZih0KTtcclxuXHJcblx0XHRcdGlmIChpZHggPT09IC0xICYmIGhhcykge1xyXG5cdFx0XHRcdGN1cnJlbnQudHlwZXMucHVzaCh0KTtcclxuXHRcdFx0fSBlbHNlIGlmIChpZHggPiAtMSAmJiAhaGFzKSB7XHJcblx0XHRcdFx0Y3VycmVudC50eXBlcy5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGN1cnJlbnQgY2hhcnQgZWxlbWVudHMgcmVmZXJlbmNlXHJcblx0XHQkJC5zZXRDaGFydEVsZW1lbnRzKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgZ2l2ZW4gY2hhcnQgdHlwZXMgZXhpc3RzXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgQ2hhcnQgdHlwZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNWYWx1ZSBEYXRhIGFycmF5XHJcblx0ICogQHBhcmFtIHtib29sZWFufSBjaGVja0Zyb21EYXRhIEZvcmNlIHRvIGNoZWNrIHR5cGUgY290YWlucyBmcm9tIGRhdGEgdGFyZ2V0c1xyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGFzVHlwZSh0eXBlOiBzdHJpbmcsIHRhcmdldHNWYWx1ZT8sIGNoZWNrRnJvbURhdGEgPSBmYWxzZSk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50fX0gPSAkJDtcclxuXHRcdGNvbnN0IHR5cGVzID0gY29uZmlnLmRhdGFfdHlwZXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gdGFyZ2V0c1ZhbHVlIHx8ICQkLmRhdGEudGFyZ2V0cztcclxuXHRcdGxldCBoYXMgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoIWNoZWNrRnJvbURhdGEgJiYgY3VycmVudC50eXBlcy5sZW5ndGggJiYgY3VycmVudC50eXBlcy5pbmRleE9mKHR5cGUpID4gLTEpIHtcclxuXHRcdFx0aGFzID0gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godGFyZ2V0ID0+IHtcclxuXHRcdFx0XHRjb25zdCB0ID0gdHlwZXNbdGFyZ2V0LmlkXTtcclxuXHJcblx0XHRcdFx0aWYgKHQgPT09IHR5cGUgfHwgKCF0ICYmIHR5cGUgPT09IFwibGluZVwiKSkge1xyXG5cdFx0XHRcdFx0aGFzID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChPYmplY3Qua2V5cyh0eXBlcykubGVuZ3RoKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0XHRpZiAodHlwZXNbaWRdID09PSB0eXBlKSB7XHJcblx0XHRcdFx0XHRoYXMgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoYXMgPSBjb25maWcuZGF0YV90eXBlID09PSB0eXBlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoYXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgZ2l2ZW4gY2hhcnQgdHlwZXNcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIGtleVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRzIFRhcmdldCBkYXRhXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xyXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGFzVHlwZU9mKHR5cGUsIHRhcmdldHMsIGV4Y2x1ZGUgPSBbXSk6IGJvb2xlYW4ge1xyXG5cdFx0Ly8g7Iuk7KCcIOuFuOuTnCDsobTsnqwg7Jes67aA64+EIO2ZleyduO2VhOyalFxyXG5cdFx0cmV0dXJuICFUWVBFX0JZX0NBVEVHT1JZW3R5cGVdXHJcblx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0LmZpbHRlcih2ID0+IGV4Y2x1ZGUuaW5kZXhPZih2KSA9PT0gLTEpXHJcblx0XHRcdC5ldmVyeSh2ID0+ICF0aGlzLmhhc1R5cGUodiwgdGFyZ2V0cykpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGlmIGdpdmVuIGRhdGEgaXMgY2VydGFpbiBjaGFydCB0eXBlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdHlwZSBjaGFydCB0eXBlXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpc1R5cGVPZihkLCB0eXBlKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBpZCA9IGlzU3RyaW5nKGQpID8gZCA6IGQuaWQ7XHJcblx0XHRjb25zdCBkYXRhVHlwZSA9IHRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdO1xyXG5cclxuXHRcdHJldHVybiBpc0FycmF5KHR5cGUpID9cclxuXHRcdFx0dHlwZS5pbmRleE9mKGRhdGFUeXBlKSA+PSAwIDogZGF0YVR5cGUgPT09IHR5cGU7XHJcblx0fSxcclxuXHJcblx0aGFzUG9pbnRUeXBlKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5oYXNUeXBlT2YoXCJMaW5lXCIpIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzVHlwZShcInNjYXR0ZXJcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgYXJjIHR5cGVzIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldHMgVGFyZ2V0IGRhdGFcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlIEV4Y2x1ZGVkIHR5cGVzXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYXNBcmNUeXBlKHRhcmdldHMsIGV4Y2x1ZGUpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmhhc1R5cGVPZihcIkFyY1wiLCB0YXJnZXRzLCBleGNsdWRlKTtcclxuXHR9LFxyXG5cclxuXHRoYXNNdWx0aUFyY0dhdWdlKCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzVHlwZShcImdhdWdlXCIpICYmIHRoaXMuY29uZmlnLmdhdWdlX3R5cGUgPT09IFwibXVsdGlcIjtcclxuXHR9LFxyXG5cclxuXHRpc0xpbmVUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcclxuXHJcblx0XHRyZXR1cm4gIXRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdIHx8XHJcblx0XHRcdHRoaXMuaXNUeXBlT2YoaWQsIFRZUEVfQllfQ0FURUdPUlkuTGluZSk7XHJcblx0fSxcclxuXHJcblx0aXNTdGVwVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFX0JZX0NBVEVHT1JZLlN0ZXApO1xyXG5cdH0sXHJcblxyXG5cdGlzU3BsaW5lVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFX0JZX0NBVEVHT1JZLlNwbGluZSk7XHJcblx0fSxcclxuXHJcblx0aXNBcmVhVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFX0JZX0NBVEVHT1JZLkFyZWEpO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJlYVJhbmdlVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFX0JZX0NBVEVHT1JZLkFyZWFSYW5nZSk7XHJcblx0fSxcclxuXHJcblx0aXNCYXJUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYmFyXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzQnViYmxlVHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImJ1YmJsZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc1NjYXR0ZXJUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwic2NhdHRlclwiKTtcclxuXHR9LFxyXG5cclxuXHRpc1BpZVR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJwaWVcIik7XHJcblx0fSxcclxuXHJcblx0aXNHYXVnZVR5cGUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJnYXVnZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc0RvbnV0VHlwZShkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImRvbnV0XCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzUmFkYXJUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwicmFkYXJcIik7XHJcblx0fSxcclxuXHJcblx0aXNBcmNUeXBlKGQpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0aGlzLmlzUGllVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzRG9udXRUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNHYXVnZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1JhZGFyVHlwZShkKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXRlcm1pbmUgaWYgaXMgJ2NpcmNsZScgZGF0YSBwb2ludFxyXG5cdGlzQ2lyY2xlUG9pbnQobm9kZT8pOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IHBhdHRlcm4gPSBjb25maWcucG9pbnRfcGF0dGVybjtcclxuXHRcdGxldCBpc0NpcmNsZSA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChub2RlICYmIG5vZGUudGFnTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRpc0NpcmNsZSA9IHRydWU7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpc0NpcmNsZSA9IGNvbmZpZy5wb2ludF90eXBlID09PSBcImNpcmNsZVwiICYmXHJcblx0XHRcdFx0KCFwYXR0ZXJuIHx8IChcclxuXHRcdFx0XHRcdGlzQXJyYXkocGF0dGVybikgJiYgcGF0dGVybi5sZW5ndGggPT09IDBcclxuXHRcdFx0XHQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNDaXJjbGU7XHJcblx0fSxcclxuXHJcblx0bGluZURhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNMaW5lVHlwZShkKSA/IFtkXSA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdGFyY0RhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNBcmNUeXBlKGQuZGF0YSkgPyBbZF0gOiBbXTtcclxuXHR9LFxyXG5cclxuXHRiYXJEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSA/IGQudmFsdWVzIDogW107XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgYWRhcHQgZm9yIGRhdGEgbGFiZWwgc2hvd2luZ1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0bGFiZWxpc2hEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzTGluZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1NjYXR0ZXJUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNCdWJibGVUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNSYWRhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdGJhckxpbmVCdWJibGVEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fCB0aGlzLmlzTGluZVR5cGUoZCkgfHwgdGhpcy5pc0J1YmJsZVR5cGUoZCkgP1xyXG5cdFx0XHRkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZSNjdXJ2ZXNcclxuXHRpc0ludGVycG9sYXRpb25UeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0XCJiYXNpc1wiLFxyXG5cdFx0XHRcImJhc2lzLWNsb3NlZFwiLFxyXG5cdFx0XHRcImJhc2lzLW9wZW5cIixcclxuXHRcdFx0XCJidW5kbGVcIixcclxuXHRcdFx0XCJjYXJkaW5hbFwiLFxyXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiLFxyXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIixcclxuXHRcdFx0XCJjYXRtdWxsLXJvbVwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLW9wZW5cIixcclxuXHRcdFx0XCJsaW5lYXJcIixcclxuXHRcdFx0XCJsaW5lYXItY2xvc2VkXCIsXHJcblx0XHRcdFwibW9ub3RvbmUteFwiLFxyXG5cdFx0XHRcIm1vbm90b25lLXlcIixcclxuXHRcdFx0XCJuYXR1cmFsXCJcclxuXHRcdF0uaW5kZXhPZih0eXBlKSA+PSAwO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7XHJcblx0dGltZVBhcnNlIGFzIGQzVGltZVBhcnNlLFxyXG5cdHRpbWVGb3JtYXQgYXMgZDNUaW1lRm9ybWF0LFxyXG5cdHV0Y1BhcnNlIGFzIGQzVXRjUGFyc2UsXHJcblx0dXRjRm9ybWF0IGFzIGQzVXRjRm9ybWF0XHJcbn0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IFN0b3JlIGZyb20gXCIuLi9jb25maWcvU3RvcmUvU3RvcmVcIjtcclxuaW1wb3J0IE9wdGlvbnMgZnJvbSBcIi4uL2NvbmZpZy9PcHRpb25zL09wdGlvbnNcIjtcclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENhY2hlIGZyb20gXCIuLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IHtnZW5lcmF0ZVJlc2l6ZX0gZnJvbSBcIi4uL21vZHVsZS9nZW5lcmF0b3JcIjtcclxuaW1wb3J0IHtleHRlbmQsIG5vdEVtcHR5LCBjb252ZXJ0SW5wdXRUeXBlLCBnZXRPcHRpb24sIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZywgY2FsbEZuLCBzb3J0VmFsdWV9IGZyb20gXCIuLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gZGF0YVxyXG5pbXBvcnQgZGF0YUNvbnZlcnQgZnJvbSBcIi4vZGF0YS9jb252ZXJ0XCI7XHJcbmltcG9ydCBkYXRhIGZyb20gXCIuL2RhdGEvZGF0YVwiO1xyXG5pbXBvcnQgZGF0YUxvYWQgZnJvbSBcIi4vZGF0YS9sb2FkXCI7XHJcblxyXG4vLyBpbnRlcmFjdGlvbnNcclxuaW1wb3J0IGludGVyYWN0aW9uIGZyb20gXCIuL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvblwiO1xyXG5cclxuLy8gaW50ZXJuYWxzXHJcbmltcG9ydCBjbGFzc01vZHVsZSBmcm9tIFwiLi9pbnRlcm5hbHMvY2xhc3NcIjtcclxuaW1wb3J0IGNhdGVnb3J5IGZyb20gXCIuL2ludGVybmFscy9jYXRlZ29yeVwiOyAvLyB1c2VkIHRvIHJldHJpZXZlIHJhZGFyIEF4aXMgbmFtZVxyXG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vaW50ZXJuYWxzL2NvbG9yXCI7XHJcbmltcG9ydCBkb21haW4gZnJvbSBcIi4vaW50ZXJuYWxzL2RvbWFpblwiO1xyXG5pbXBvcnQgZm9ybWF0IGZyb20gXCIuL2ludGVybmFscy9mb3JtYXRcIjtcclxuaW1wb3J0IGxlZ2VuZCBmcm9tIFwiLi9pbnRlcm5hbHMvbGVnZW5kXCI7XHJcbmltcG9ydCByZWRyYXcgZnJvbSBcIi4vaW50ZXJuYWxzL3JlZHJhd1wiO1xyXG5pbXBvcnQgc2NhbGUgZnJvbSBcIi4vaW50ZXJuYWxzL3NjYWxlXCI7XHJcbmltcG9ydCBzaGFwZSBmcm9tIFwiLi9zaGFwZS9zaGFwZVwiO1xyXG5pbXBvcnQgc2l6ZSBmcm9tIFwiLi9pbnRlcm5hbHMvc2l6ZVwiO1xyXG5pbXBvcnQgdGV4dCBmcm9tIFwiLi9pbnRlcm5hbHMvdGV4dFwiO1xyXG5pbXBvcnQgdGl0bGUgZnJvbSBcIi4vaW50ZXJuYWxzL3RpdGxlXCI7XHJcbmltcG9ydCB0b29sdGlwIGZyb20gXCIuL2ludGVybmFscy90b29sdGlwXCI7XHJcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSBcIi4vaW50ZXJuYWxzL3RyYW5zZm9ybVwiO1xyXG5pbXBvcnQgdHlwZSBmcm9tIFwiLi9pbnRlcm5hbHMvdHlwZVwiO1xyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGNoYXJ0IGNsYXNzLlxyXG4gKiAtIE5vdGU6IEluc3RhbnRpYXRlZCBpbnRlcm5hbGx5LCBub3QgZXhwb3NlZCBmb3IgcHVibGljLlxyXG4gKiBAY2xhc3MgQ2hhcnRJbnRlcm5hbFxyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFydEludGVybmFsIHtcclxuXHRwdWJsaWMgYXBpO1x0Ly8gQVBJIGludGVyZmFjZVxyXG5cdHB1YmxpYyBjb25maWc7IC8vIGNvbmZpZyBvYmplY3RcclxuXHRwdWJsaWMgY2FjaGU7IC8vIGNhY2hlIGluc3RhbmNlXHJcblx0cHVibGljICRlbDsgLy8gZWxlbWVudHNcclxuXHRwdWJsaWMgc3RhdGU7IC8vIHN0YXRlIHZhcmlhYmxlc1xyXG5cdHB1YmxpYyBjaGFydHM7IC8vIGFsbCBDaGFydCBpbnN0YW5jZXMgYXJyYXkgd2l0aGluIHBhZ2UgKGVxdWl2YWxlbnQgb2YgJ2JiLmluc3RhbmNlcycpXHJcblxyXG5cdC8vIGRhdGEgb2JqZWN0XHJcblx0cHVibGljIGRhdGEgPSB7XHJcblx0XHR4czoge30sXHJcblx0XHR0YXJnZXRzOiBbXVxyXG5cdH07XHJcblxyXG5cdC8vIEF4aXNcclxuXHRwdWJsaWMgYXhpczsgLy8gQXhpc1xyXG5cclxuXHQvLyBzY2FsZXNcclxuXHRwdWJsaWMgc2NhbGUgPSB7XHJcblx0XHR4OiBudWxsLFxyXG5cdFx0eTogbnVsbCxcclxuXHRcdHkyOiBudWxsLFxyXG5cdFx0c3ViWDogbnVsbCxcclxuXHRcdHN1Ylk6IG51bGwsXHJcblx0XHRzdWJZMjogbnVsbCxcclxuXHRcdHpvb206IG51bGxcclxuXHR9XHJcblxyXG5cdC8vIG9yaWdpbmFsIHZhbHVlc1xyXG5cdHB1YmxpYyBvcmcgPSB7XHJcblx0XHR4U2NhbGU6IG51bGwsXHJcblx0XHR4RG9tYWluOiBudWxsXHJcblx0fTtcclxuXHJcblx0Ly8gZm9ybWF0dGVyIGZ1bmN0aW9uXHJcblx0cHVibGljIGNvbG9yO1xyXG5cdHB1YmxpYyBwYXR0ZXJucztcclxuXHRwdWJsaWMgbGV2ZWxDb2xvcjtcclxuXHRwdWJsaWMgcG9pbnQ7XHJcblx0cHVibGljIGJydXNoO1xyXG5cclxuXHQvLyBmb3JtYXQgZnVuY3Rpb25cclxuXHRwdWJsaWMgZm9ybWF0ID0ge1xyXG5cdFx0ZXh0cmFMaW5lQ2xhc3NlczogbnVsbCxcclxuXHRcdHhBeGlzVGljazogbnVsbCxcclxuXHRcdGRhdGFUaW1lOiBudWxsLCAvLyBkYXRhVGltZUZvcm1hdFxyXG5cdFx0ZGVmYXVsdEF4aXNUaW1lOiBudWxsLCAvLyBkZWZhdWx0QXhpc1RpbWVGb3JtYXRcclxuXHRcdGF4aXNUaW1lOiBudWxsIC8vIGF4aXNUaW1lRm9ybWF0XHJcblx0fTtcclxuXHJcblx0Y29uc3RydWN0b3IoYXBpKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuYXBpID0gYXBpOyAvLyBDaGFydCBjbGFzcyBpbnN0YW5jZSBhbGlhc1xyXG5cdFx0JCQuY29uZmlnID0gbmV3IE9wdGlvbnMoKTtcclxuXHRcdCQkLmNhY2hlID0gbmV3IENhY2hlKCk7XHJcblxyXG5cdFx0Y29uc3Qgc3RvcmUgPSBuZXcgU3RvcmUoKTtcclxuXHJcblx0XHQkJC4kZWwgPSBzdG9yZS5nZXRTdG9yZShcImVsZW1lbnRcIik7XHJcblx0XHQkJC5zdGF0ZSA9IHN0b3JlLmdldFN0b3JlKFwic3RhdGVcIik7XHJcblx0fVxyXG5cclxuXHRiZWZvcmVJbml0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGJlZm9yZUluaXRcIik7XHJcblxyXG5cdFx0Ly8gY2FuIGRvIHNvbWV0aGluZ1xyXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmJlZm9yZWluaXQsICQkLmFwaSk7XHJcblx0fVxyXG5cclxuXHRhZnRlckluaXQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkYWZ0ZXJJbml0XCIpO1xyXG5cclxuXHRcdC8vIGNhbiBkbyBzb21ldGhpbmdcclxuXHRcdGNhbGxGbigkJC5jb25maWcub25hZnRlcmluaXQsICQkLmFwaSk7XHJcblx0fVxyXG5cclxuXHRpbml0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHJcblx0XHRzdGF0ZS5oYXNBeGlzID0gISQkLmhhc0FyY1R5cGUoKTtcclxuXHRcdHN0YXRlLmhhc1JhZGFyID0gIXN0YXRlLmhhc0F4aXMgJiYgJCQuaGFzVHlwZShcInJhZGFyXCIpO1xyXG5cclxuXHRcdCQkLmluaXRQYXJhbXMoKTtcclxuXHJcblx0XHRjb25zdCBiaW5kdG8gPSB7XHJcblx0XHRcdGVsZW1lbnQ6IGNvbmZpZy5iaW5kdG8sXHJcblx0XHRcdGNsYXNzbmFtZTogXCJiYlwiXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb25maWcuYmluZHRvKSkge1xyXG5cdFx0XHRiaW5kdG8uZWxlbWVudCA9IGNvbmZpZy5iaW5kdG8uZWxlbWVudCB8fCBcIiNjaGFydFwiO1xyXG5cdFx0XHRiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgYmluZCBlbGVtZW50XHJcblx0XHQkZWwuY2hhcnQgPSBpc0Z1bmN0aW9uKGJpbmR0by5lbGVtZW50Lm5vZGUpID9cclxuXHRcdFx0Y29uZmlnLmJpbmR0by5lbGVtZW50IDogZDNTZWxlY3QoYmluZHRvLmVsZW1lbnQgfHwgW10pO1xyXG5cclxuXHRcdGlmICgkZWwuY2hhcnQuZW1wdHkoKSkge1xyXG5cdFx0XHQkZWwuY2hhcnQgPSBkM1NlbGVjdChkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuY2hhcnQuaHRtbChcIlwiKS5jbGFzc2VkKGJpbmR0by5jbGFzc25hbWUsIHRydWUpO1xyXG5cclxuXHRcdCQkLmluaXRUb1JlbmRlcigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3NcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlZCBGb3JjZSB0byByZW5kZXIgcHJvY2Vzc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFRvUmVuZGVyKGZvcmNlZD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc0hpZGRlbiA9ICgpID0+IGNoYXJ0LnN0eWxlKFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIgfHwgY2hhcnQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiO1xyXG5cclxuXHRcdGNvbnN0IGlzTGF6eSA9IGNvbmZpZy5yZW5kZXIubGF6eSB8fCBpc0hpZGRlbigpO1xyXG5cdFx0Y29uc3QgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xyXG5cclxuXHRcdGlmIChpc0xhenkgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBjb25maWcucmVuZGVyLm9ic2VydmUgIT09IGZhbHNlICYmICFmb3JjZWQpIHtcclxuXHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9uLCBvYnNlcnZlcikgPT4ge1xyXG5cdFx0XHRcdGlmICghaXNIaWRkZW4oKSkge1xyXG5cdFx0XHRcdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG5cdFx0XHRcdFx0IXN0YXRlLnJlbmRlcmVkICYmICQkLmluaXRUb1JlbmRlcih0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pLm9ic2VydmUoY2hhcnQubm9kZSgpLCB7XHJcblx0XHRcdFx0YXR0cmlidXRlczogdHJ1ZSxcclxuXHRcdFx0XHRhdHRyaWJ1dGVGaWx0ZXI6IFtcImNsYXNzXCIsIFwic3R5bGVcIl1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc0xhenkgfHwgZm9yY2VkKSB7XHJcblx0XHRcdGNvbnN0IGNvbnZlcnRlZERhdGEgPSAkJC5jb252ZXJ0RGF0YShjb25maWcsICQkLmluaXRXaXRoRGF0YSk7XHJcblxyXG5cdFx0XHRjb252ZXJ0ZWREYXRhICYmICQkLmluaXRXaXRoRGF0YShjb252ZXJ0ZWREYXRhKTtcclxuXHRcdFx0JCQuYWZ0ZXJJbml0KCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpbml0UGFyYW1zKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgZm9ybWF0LCBzdGF0ZX0gPSA8YW55PiAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Ly8gZGF0ZXRpbWUgdG8gYmUgdXNlZCBmb3IgdW5pcXVlbmVzc1xyXG5cdFx0c3RhdGUuZGF0ZXRpbWVJZCA9IGBiYi0keytuZXcgRGF0ZSgpfWA7XHJcblxyXG5cdFx0JCQuY29sb3IgPSAkJC5nZW5lcmF0ZUNvbG9yKCk7XHJcblx0XHQkJC5sZXZlbENvbG9yID0gJCQuZ2VuZXJhdGVMZXZlbENvbG9yKCk7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1BvaW50VHlwZSgpKSB7XHJcblx0XHRcdCQkLnBvaW50ID0gJCQuZ2VuZXJhdGVQb2ludCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5oYXNBeGlzKSB7XHJcblx0XHRcdCQkLmluaXRDbGlwKCk7XHJcblxyXG5cdFx0XHRmb3JtYXQuZXh0cmFMaW5lQ2xhc3NlcyA9ICQkLmdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MoKTtcclxuXHRcdFx0Zm9ybWF0LmRhdGFUaW1lID0gY29uZmlnLmRhdGFfeExvY2FsdGltZSA/IGQzVGltZVBhcnNlIDogZDNVdGNQYXJzZTtcclxuXHRcdFx0Zm9ybWF0LmF4aXNUaW1lID0gY29uZmlnLmF4aXNfeF9sb2NhbHRpbWUgPyBkM1RpbWVGb3JtYXQgOiBkM1V0Y0Zvcm1hdDtcclxuXHJcblx0XHRcdGNvbnN0IGlzRHJhZ1pvb20gPSAkJC5jb25maWcuem9vbV9lbmFibGVkICYmICQkLmNvbmZpZy56b29tX2VuYWJsZWQudHlwZSA9PT0gXCJkcmFnXCI7XHJcblxyXG5cdFx0XHRmb3JtYXQuZGVmYXVsdEF4aXNUaW1lID0gZCA9PiB7XHJcblx0XHRcdFx0Y29uc3Qge3gsIHpvb219ID0gJCQuc2NhbGU7XHJcblx0XHRcdFx0Y29uc3QgaXNab29tZWQgPSBpc0RyYWdab29tID8gem9vbSA6XHJcblx0XHRcdFx0XHR6b29tICYmIHgub3JnRG9tYWluKCkudG9TdHJpbmcoKSAhPT0gem9vbS5kb21haW4oKS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBzcGVjaWZpZXI6IHN0cmluZyA9IChkLmdldE1pbGxpc2Vjb25kcygpICYmIFwiLiVMXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXRTZWNvbmRzKCkgJiYgXCIuOiVTXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXRNaW51dGVzKCkgJiYgXCIlSTolTVwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0SG91cnMoKSAmJiBcIiVJICVwXCIpIHx8XHJcblx0XHRcdFx0XHQoZC5nZXREYXRlKCkgIT09IDEgJiYgXCIlYiAlZFwiKSB8fFxyXG5cdFx0XHRcdFx0KGlzWm9vbWVkICYmIGQuZ2V0RGF0ZSgpID09PSAxICYmIFwiJWJcXCcleVwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0TW9udGgoKSAmJiBcIiUtbS8lLWRcIikgfHwgXCIlWVwiO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZm9ybWF0LmF4aXNUaW1lKHNwZWNpZmllcikoZCk7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuaXNMZWdlbmRSaWdodCA9IGNvbmZpZy5sZWdlbmRfcG9zaXRpb24gPT09IFwicmlnaHRcIjtcclxuXHRcdHN0YXRlLmlzTGVnZW5kSW5zZXQgPSBjb25maWcubGVnZW5kX3Bvc2l0aW9uID09PSBcImluc2V0XCI7XHJcblxyXG5cdFx0c3RhdGUuaXNMZWdlbmRUb3AgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1yaWdodFwiO1xyXG5cclxuXHRcdHN0YXRlLmlzTGVnZW5kTGVmdCA9IGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1sZWZ0XCIgfHxcclxuXHRcdFx0Y29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwiYm90dG9tLWxlZnRcIjtcclxuXHJcblx0XHRzdGF0ZS5yb3RhdGVkUGFkZGluZ1JpZ2h0ID0gaXNSb3RhdGVkICYmICFjb25maWcuYXhpc194X3Nob3cgPyAwIDogMzA7XHJcblxyXG5cdFx0c3RhdGUuaW5wdXRUeXBlID0gY29udmVydElucHV0VHlwZShcclxuXHRcdFx0Y29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV9tb3VzZSxcclxuXHRcdFx0Y29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaFxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdGluaXRXaXRoRGF0YShkYXRhKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IDxhbnk+IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgc3RhdGUsICRlbCwgb3JnfSA9ICQkO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXN9ID0gc3RhdGU7XHJcblx0XHRjb25zdCBoYXNJbnRlcmFjdGlvbiA9IGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkO1xyXG5cclxuXHRcdC8vIGZvciBhcmMgdHlwZSwgc2V0IGF4ZXMgdG8gbm90IGJlIHNob3duXHJcblx0XHQvLyAkJC5oYXNBcmNUeXBlKCkgJiYgW1wieFwiLCBcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGlkID0+IChjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdID0gZmFsc2UpKTtcclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHQkJC5heGlzID0gJCQuZ2V0QXhpc0luc3RhbmNlKCk7XHJcblx0XHRcdGNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuaW5pdFpvb20oKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0IGRhdGEgYXMgdGFyZ2V0c1xyXG5cdFx0JCQuZGF0YS54cyA9IHt9O1xyXG5cdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2ZpbHRlcikge1xyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKGNvbmZpZy5kYXRhX2ZpbHRlci5iaW5kKCQkLmFwaSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzIHRvIGhpZGUgaWYgbmVlZGVkXHJcblx0XHRpZiAoY29uZmlnLmRhdGFfaGlkZSkge1xyXG5cdFx0XHQkJC5hZGRIaWRkZW5UYXJnZXRJZHMoXHJcblx0XHRcdFx0Y29uZmlnLmRhdGFfaGlkZSA9PT0gdHJ1ZSA/XHJcblx0XHRcdFx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpIDogY29uZmlnLmRhdGFfaGlkZVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfaGlkZSkge1xyXG5cdFx0XHQkJC5hZGRIaWRkZW5MZWdlbmRJZHMoXHJcblx0XHRcdFx0Y29uZmlnLmxlZ2VuZF9oaWRlID09PSB0cnVlID9cclxuXHRcdFx0XHRcdCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cykgOiBjb25maWcubGVnZW5kX2hpZGVcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0IHNpemVzIGFuZCBzY2FsZXNcclxuXHRcdCQkLnVwZGF0ZVNpemVzKCk7XHJcblx0XHQkJC51cGRhdGVTY2FsZXModHJ1ZSk7XHJcblxyXG5cdFx0Ly8gcmV0cmlldmUgc2NhbGUgYWZ0ZXIgdGhlICd1cGRhdGVTY2FsZXMoKScgaXMgY2FsbGVkXHJcblx0XHRjb25zdCB7eCwgeSwgeTIsIHN1YlgsIHN1YlksIHN1YlkyfSA9IHNjYWxlO1xyXG5cclxuXHRcdC8vIFNldCBkb21haW5zIGZvciBlYWNoIHNjYWxlXHJcblx0XHRpZiAoeCkge1xyXG5cdFx0XHR4LmRvbWFpbihzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpKSk7XHJcblx0XHRcdHN1YlguZG9tYWluKHguZG9tYWluKCkpO1xyXG5cclxuXHRcdFx0Ly8gU2F2ZSBvcmlnaW5hbCB4IGRvbWFpbiBmb3Igem9vbSB1cGRhdGVcclxuXHRcdFx0b3JnLnhEb21haW4gPSB4LmRvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh5KSB7XHJcblx0XHRcdHkuZG9tYWluKCQkLmdldFlEb21haW4oJCQuZGF0YS50YXJnZXRzLCBcInlcIikpO1xyXG5cdFx0XHRzdWJZLmRvbWFpbih5LmRvbWFpbigpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoeTIpIHtcclxuXHRcdFx0eTIuZG9tYWluKCQkLmdldFlEb21haW4oJCQuZGF0YS50YXJnZXRzLCBcInkyXCIpKTtcclxuXHRcdFx0c3ViWTIgJiYgc3ViWTIuZG9tYWluKHkyLmRvbWFpbigpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyAtLSBCYXNpYyBFbGVtZW50cyAtLVxyXG5cdFx0JGVsLnN2ZyA9ICRlbC5jaGFydC5hcHBlbmQoXCJzdmdcIilcclxuXHRcdFx0LnN0eWxlKFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG5cclxuXHRcdGlmIChoYXNJbnRlcmFjdGlvbiAmJiBzdGF0ZS5pbnB1dFR5cGUpIHtcclxuXHRcdFx0Y29uc3QgaXNUb3VjaCA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xyXG5cclxuXHRcdFx0JGVsLnN2Zy5vbihpc1RvdWNoID8gXCJ0b3VjaHN0YXJ0XCIgOiBcIm1vdXNlZW50ZXJcIiwgKCkgPT4gY2FsbEZuKGNvbmZpZy5vbm92ZXIsICQkLmFwaSkpXHJcblx0XHRcdFx0Lm9uKGlzVG91Y2ggPyBcInRvdWNoZW5kXCIgOiBcIm1vdXNlbGVhdmVcIiwgKCkgPT4gY2FsbEZuKGNvbmZpZy5vbm91dCwgJCQuYXBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnN2Z19jbGFzc25hbWUgJiYgJGVsLnN2Zy5hdHRyKFwiY2xhc3NcIiwgY29uZmlnLnN2Z19jbGFzc25hbWUpO1xyXG5cclxuXHRcdC8vIERlZmluZSBkZWZzXHJcblx0XHRjb25zdCBoYXNDb2xvclBhdHRlcm5zID0gKGlzRnVuY3Rpb24oY29uZmlnLmNvbG9yX3RpbGVzKSAmJiAkJC5wYXR0ZXJucyk7XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMgfHwgaGFzQ29sb3JQYXR0ZXJucykge1xyXG5cdFx0XHQkZWwuZGVmcyA9ICRlbC5zdmcuYXBwZW5kKFwiZGVmc1wiKTtcclxuXHJcblx0XHRcdGlmIChoYXNBeGlzKSB7XHJcblx0XHRcdFx0W1wiaWRcIiwgXCJpZFhBeGlzXCIsIFwiaWRZQXhpc1wiLCBcImlkR3JpZFwiXS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0JCQuYXBwZW5kQ2xpcCgkZWwuZGVmcywgc3RhdGUuY2xpcFt2XSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHNldCBjb2xvciBwYXR0ZXJuc1xyXG5cdFx0XHRpZiAoaGFzQ29sb3JQYXR0ZXJucykge1xyXG5cdFx0XHRcdCQkLnBhdHRlcm5zLmZvckVhY2gocCA9PiAkZWwuZGVmcy5hcHBlbmQoKCkgPT4gcC5ub2RlKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblxyXG5cdFx0Ly8gQmluZCByZXNpemUgZXZlbnRcclxuXHRcdCQkLmJpbmRSZXNpemUoKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgcmVnaW9uc1xyXG5cdFx0Y29uc3QgbWFpbiA9ICRlbC5zdmcuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5tYWluLCB0cnVlKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcclxuXHJcblx0XHQkZWwubWFpbiA9IG1haW47XHJcblxyXG5cdFx0Ly8gaW5pdGlhbGl6ZSBzdWJjaGFydCB3aGVuIHN1YmNoYXJ0IHNob3cgb3B0aW9uIGlzIHNldFxyXG5cdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQuaW5pdFN1YmNoYXJ0KCk7XHJcblxyXG5cdFx0Y29uZmlnLnRvb2x0aXBfc2hvdyAmJiAkJC5pbml0VG9vbHRpcCgpO1xyXG5cdFx0Y29uZmlnLnRpdGxlX3RleHQgJiYgJCQuaW5pdFRpdGxlKCk7XHJcblx0XHRjb25maWcubGVnZW5kX3Nob3cgJiYgJCQuaW5pdExlZ2VuZCgpO1xyXG5cclxuXHRcdC8vIC0tIE1haW4gUmVnaW9uIC0tXHJcblxyXG5cdFx0Ly8gdGV4dCB3aGVuIGVtcHR5XHJcblx0XHRpZiAoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dCkge1xyXG5cdFx0XHRtYWluLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGAke0NMQVNTLnRleHR9ICR7Q0xBU1MuZW1wdHl9YClcclxuXHRcdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpIC8vIGhvcml6b250YWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeCBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMuXHJcblx0XHRcdFx0LmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKTsgLy8gdmVydGljYWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeSBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMsIGV4Y2VwdCBJRS5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaGFzQXhpcykge1xyXG5cdFx0XHQvLyBSZWdpb25zXHJcblx0XHRcdGNvbmZpZy5yZWdpb25zLmxlbmd0aCAmJiAkJC5pbml0UmVnaW9uKCk7XHJcblxyXG5cdFx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICdmYWxzZSdcclxuXHRcdFx0IWNvbmZpZy5jbGlwUGF0aCAmJiAkJC5heGlzLmluaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnQgYXJlYVxyXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydClcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgc3RhdGUuY2xpcC5wYXRoKTtcclxuXHJcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRpbml0XCIpO1xyXG5cclxuXHRcdGlmIChoYXNBeGlzKSB7XHJcblx0XHRcdC8vIENvdmVyIHdob2xlIHdpdGggcmVjdHMgZm9yIGV2ZW50c1xyXG5cdFx0XHRoYXNJbnRlcmFjdGlvbiAmJiAkJC5pbml0RXZlbnRSZWN0ICYmICQkLmluaXRFdmVudFJlY3QoKTtcclxuXHJcblx0XHRcdC8vIEdyaWRzXHJcblx0XHRcdCQkLmluaXRHcmlkKCk7XHJcblxyXG5cdFx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICd0cnVlJ1xyXG5cdFx0XHRjb25maWcuY2xpcFBhdGggJiYgJCQuYXhpcyAmJiAkJC5heGlzLmluaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5pbml0Q2hhcnRFbGVtZW50cygpO1xyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gRHJhdyB3aXRoIHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZURpbWVuc2lvbigpO1xyXG5cclxuXHRcdC8vIG9uaW5pdCBjYWxsYmFja1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy5vbmluaXQsICQkLmFwaSk7XHJcblxyXG5cdFx0Ly8gU2V0IGJhY2tncm91bmRcclxuXHRcdCQkLnNldEJhY2tncm91bmQoKTtcclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2UsXHJcblx0XHRcdHdpdGhUcmFuc2Zvcm06IHRydWUsXHJcblx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JBeGlzOiBmYWxzZSxcclxuXHRcdFx0aW5pdGlhbGl6aW5nOiB0cnVlXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBkYXRhLm9ubWluL21heCBjYWxsYmFja1xyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX29ubWluIHx8IGNvbmZpZy5kYXRhX29ubWF4KSB7XHJcblx0XHRcdGNvbnN0IG1pbk1heCA9ICQkLmdldE1pbk1heERhdGEoKTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcuZGF0YV9vbm1pbiwgJCQuYXBpLCBtaW5NYXgubWluKTtcclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29ubWF4LCAkJC5hcGksIG1pbk1heC5tYXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLnJlbmRlcmVkID0gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdGluaXRDaGFydEVsZW1lbnRzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSA8YW55PiB0aGlzO1xyXG5cdFx0Y29uc3Qge2hhc0F4aXMsIGhhc1JhZGFyfSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgdHlwZXM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMpIHtcclxuXHRcdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiB0eXBlcy5wdXNoKFwiQmFyXCIpO1xyXG5cdFx0XHQkJC5oYXNUeXBlKFwiYnViYmxlXCIpICYmIHR5cGVzLnB1c2goXCJCdWJibGVcIik7XHJcblx0XHRcdCQkLmhhc1R5cGVPZihcIkxpbmVcIikgJiYgdHlwZXMucHVzaChcIkxpbmVcIik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIWhhc1JhZGFyKSB7XHJcblx0XHRcdFx0dHlwZXMucHVzaChcIkFyY1wiLCBcIlBpZVwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goXCJHYXVnZVwiKTtcclxuXHRcdFx0fSBlbHNlIGlmIChoYXNSYWRhcikge1xyXG5cdFx0XHRcdHR5cGVzLnB1c2goXCJSYWRhclwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHR5cGVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdCQkW2Bpbml0JHt2fWBdKCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRub3RFbXB0eSgkJC5jb25maWcuZGF0YV9sYWJlbHMpICYmICQkLmluaXRUZXh0KCk7XHJcblx0fVxyXG5cclxuXHRzZXRDaGFydEVsZW1lbnRzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbDoge1xyXG5cdFx0XHRjaGFydCwgc3ZnLCBkZWZzLCBtYWluLCB0b29sdGlwLCBsZWdlbmQsIHRpdGxlLCBncmlkLFxyXG5cdFx0XHRhcmNzOiBhcmMsXHJcblx0XHRcdGNpcmNsZTogY2lyY2xlcyxcclxuXHRcdFx0YmFyOiBiYXJzLFxyXG5cdFx0XHRsaW5lOiBsaW5lcyxcclxuXHRcdFx0YXJlYTogYXJlYXMsXHJcblx0XHRcdHRleHQ6IHRleHRzXHJcblx0XHR9fSA9ICQkO1xyXG5cclxuXHRcdCQkLmFwaS4kID0ge1xyXG5cdFx0XHRjaGFydCxcclxuXHRcdFx0c3ZnLFxyXG5cdFx0XHRkZWZzLFxyXG5cdFx0XHRtYWluLFxyXG5cdFx0XHR0b29sdGlwLFxyXG5cdFx0XHRsZWdlbmQsXHJcblx0XHRcdHRpdGxlLFxyXG5cdFx0XHRncmlkLFxyXG5cdFx0XHRhcmMsXHJcblx0XHRcdGNpcmNsZXMsXHJcblx0XHRcdGJhcjoge2JhcnN9LFxyXG5cdFx0XHRsaW5lOiB7bGluZXMsIGFyZWFzfSxcclxuXHRcdFx0dGV4dDoge3RleHRzfVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBiYWNrZ3JvdW5kIGVsZW1lbnQvaW1hZ2VcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEJhY2tncm91bmQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnOiB7YmFja2dyb3VuZDogYmd9LCBzdGF0ZSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHJcblx0XHRpZiAobm90RW1wdHkoYmcpKSB7XHJcblx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzdmcuc2VsZWN0KFwiZ1wiKVxyXG5cdFx0XHRcdC5pbnNlcnQoYmcuaW1nVXJsID8gXCJpbWFnZVwiIDogXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xyXG5cclxuXHRcdFx0aWYgKGJnLmltZ1VybCkge1xyXG5cdFx0XHRcdGVsZW1lbnQuYXR0cihcImhyZWZcIiwgYmcuaW1nVXJsKTtcclxuXHRcdFx0fSBlbHNlIGlmIChiZy5jb2xvcikge1xyXG5cdFx0XHRcdGVsZW1lbnRcclxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgYmcuY29sb3IpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBzdGF0ZS5jbGlwLnBhdGgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlbGVtZW50XHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBiZy5jbGFzcyB8fCBudWxsKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgXCIxMDAlXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRhcmdldGVkIGVsZW1lbnQgd2l0aCBnaXZlbiBkYXRhXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldHMgRGF0YSBvYmplY3QgZm9ybWF0dGVkIGFzICd0YXJnZXQnXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVUYXJnZXRzKHRhcmdldHMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtoYXNBeGlzLCBoYXNSYWRhcn0gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHQvLyBUZXh0XHJcblx0XHQkJC51cGRhdGVUYXJnZXRzRm9yVGV4dCh0YXJnZXRzKTtcclxuXHJcblx0XHQvLyBjaXJjbGVcclxuXHRcdGlmICgkJC5oYXNQb2ludFR5cGUoKSB8fCBoYXNSYWRhcikge1xyXG5cdFx0XHQkJC51cGRhdGVUYXJnZXRGb3JDaXJjbGUgJiYgJCQudXBkYXRlVGFyZ2V0Rm9yQ2lyY2xlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGhhc0F4aXMpIHtcclxuXHRcdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiAkJC51cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpOyAvLyBCYXJcclxuXHRcdFx0JCQuaGFzVHlwZU9mKFwiTGluZVwiKSAmJiAkJC51cGRhdGVUYXJnZXRzRm9yTGluZSh0YXJnZXRzKTsgLy8gTGluZVxyXG5cclxuXHRcdFx0Ly8gU3ViIENoYXJ0XHJcblx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCAmJlxyXG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCh0YXJnZXRzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEFyYyAmIFJhZGFyXHJcblx0XHRcdCQkLmhhc0FyY1R5cGUodGFyZ2V0cykgJiYgKFxyXG5cdFx0XHRcdGhhc1JhZGFyID9cclxuXHRcdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKSA6XHJcblx0XHRcdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmFkZS1pbiBlYWNoIGNoYXJ0XHJcblx0XHQkJC5zaG93VGFyZ2V0cygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGxheSB0YXJnZXRlZCBlbGVtZW50c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2hvd1RhcmdldHMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IDxhbnk+IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdHN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLnRhcmdldH1gKVxyXG5cdFx0XHQuZmlsdGVyKGQgPT4gJCQuaXNUYXJnZXRUb1Nob3coZC5pZCkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHR9XHJcblxyXG5cdGdldFdpdGhPcHRpb24ob3B0aW9ucykge1xyXG5cdFx0Y29uc3Qgd2l0aE9wdGlvbnMgPSB7XHJcblx0XHRcdFk6IHRydWUsXHJcblx0XHRcdFN1YmNoYXJ0OiB0cnVlLFxyXG5cdFx0XHRUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHRFdmVudFJlY3Q6IHRydWUsXHJcblx0XHRcdERpbWVuc2lvbjogdHJ1ZSxcclxuXHRcdFx0VHJpbVhEb21haW46IHRydWUsXHJcblx0XHRcdFRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdFVwZGF0ZVhEb21haW46IGZhbHNlLFxyXG5cdFx0XHRVcGRhdGVPcmdYRG9tYWluOiBmYWxzZSxcclxuXHRcdFx0TGVnZW5kOiBmYWxzZSxcclxuXHRcdFx0VXBkYXRlWEF4aXM6IFwiVXBkYXRlWERvbWFpblwiLFxyXG5cdFx0XHRUcmFuc2l0aW9uRm9yRXhpdDogXCJUcmFuc2l0aW9uXCIsXHJcblx0XHRcdFRyYW5zaXRpb25Gb3JBeGlzOiBcIlRyYW5zaXRpb25cIlxyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyh3aXRoT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRsZXQgZGVmVmFsID0gd2l0aE9wdGlvbnNba2V5XTtcclxuXHJcblx0XHRcdGlmIChpc1N0cmluZyhkZWZWYWwpKSB7XHJcblx0XHRcdFx0ZGVmVmFsID0gd2l0aE9wdGlvbnNbZGVmVmFsXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2l0aE9wdGlvbnNba2V5XSA9IGdldE9wdGlvbihvcHRpb25zLCBgd2l0aCR7a2V5fWAsIGRlZlZhbCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gd2l0aE9wdGlvbnM7XHJcblx0fVxyXG5cclxuXHRpbml0aWFsT3BhY2l0eShkKTogXCIxXCIgfCBcIjBcIiB7XHJcblx0XHRjb25zdCAkJCA9IDxhbnk+IHRoaXM7XHJcblx0XHRjb25zdCB7d2l0aG91dEZhZGVJbn0gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXHJcblx0XHRcdHdpdGhvdXRGYWRlSW5bZC5pZF0gPyBcIjFcIiA6IFwiMFwiO1xyXG5cdH1cclxuXHJcblx0YmluZFJlc2l6ZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gPGFueT4gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgcmVzaXplRnVuY3Rpb24gPSBnZW5lcmF0ZVJlc2l6ZSgpO1xyXG5cdFx0Y29uc3QgbGlzdDogRnVuY3Rpb25bXSA9IFtdO1xyXG5cclxuXHRcdGxpc3QucHVzaCgoKSA9PiBjYWxsRm4oY29uZmlnLm9ucmVzaXplLCAkJCwgJCQuYXBpKSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5yZXNpemVfYXV0bykge1xyXG5cdFx0XHRsaXN0LnB1c2goKCkgPT4ge1xyXG5cdFx0XHRcdHN0YXRlLnJlc2l6aW5nID0gdHJ1ZTtcclxuXHRcdFx0XHQkJC5hcGkuZmx1c2goZmFsc2UpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRsaXN0LnB1c2goKCkgPT4ge1xyXG5cdFx0XHRjYWxsRm4oY29uZmlnLm9ucmVzaXplZCwgJCQsICQkLmFwaSk7XHJcblx0XHRcdHN0YXRlLnJlc2l6aW5nID0gZmFsc2U7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBhZGQgcmVzaXplIGZ1bmN0aW9uc1xyXG5cdFx0bGlzdC5mb3JFYWNoKHYgPT4gcmVzaXplRnVuY3Rpb24uYWRkKHYpKTtcclxuXHJcblx0XHQkJC5yZXNpemVGdW5jdGlvbiA9IHJlc2l6ZUZ1bmN0aW9uO1xyXG5cclxuXHRcdC8vIGF0dGFjaCByZXNpemUgZXZlbnRcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICQkLnJlc2l6ZUZ1bmN0aW9uID0gcmVzaXplRnVuY3Rpb24pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbCBwbHVnaW4gaG9va1xyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwaGFzZSBUaGUgbGlmZWN5Y2xlIHBoYXNlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gYXJncyBBcmd1bWVudHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNhbGxQbHVnaW5Ib29rKHBoYXNlLCAuLi5hcmdzKTogdm9pZCB7XHJcblx0XHR0aGlzLmNvbmZpZy5wbHVnaW5zLmZvckVhY2godiA9PiB7XHJcblx0XHRcdGlmIChwaGFzZSA9PT0gXCIkYmVmb3JlSW5pdFwiKSB7XHJcblx0XHRcdFx0di4kJCA9IHRoaXM7XHJcblx0XHRcdFx0dGhpcy5hcGkucGx1Z2lucy5wdXNoKHYpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2W3BoYXNlXSguLi5hcmdzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG5cclxuZXh0ZW5kKENoYXJ0SW50ZXJuYWwucHJvdG90eXBlLCBbXHJcblx0Ly8gY29tbW9uXHJcblx0ZGF0YUNvbnZlcnQsXHJcblx0ZGF0YSxcclxuXHRkYXRhTG9hZCxcclxuXHRjYXRlZ29yeSxcclxuXHRjbGFzc01vZHVsZSxcclxuXHRjb2xvcixcclxuXHRkb21haW4sXHJcblx0aW50ZXJhY3Rpb24sXHJcblx0Zm9ybWF0LFxyXG5cdGxlZ2VuZCxcclxuXHRyZWRyYXcsXHJcblx0c2NhbGUsXHJcblx0c2hhcGUsXHJcblx0c2l6ZSxcclxuXHR0ZXh0LFxyXG5cdHRpdGxlLFxyXG5cdHRvb2x0aXAsXHJcblx0dHJhbnNmb3JtLFxyXG5cdHR5cGVcclxuXSk7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc0RlZmluZWQsIGlzT2JqZWN0VHlwZX0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCBPcHRpb25zIGZyb20gXCIuL09wdGlvbnMvT3B0aW9uc1wiO1xyXG5cclxuLyoqXHJcbiAqIExvYWQgY29uZmlndXJhdGlvbiBvcHRpb25cclxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBVc2VyJ3MgZ2VuZXJhdGlvbiBjb25maWcgdmFsdWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBsb2FkQ29uZmlnKGNvbmZpZzogT3B0aW9ucyk6IHZvaWQge1xyXG5cdGNvbnN0IHRoaXNDb25maWc6IE9wdGlvbnMgPSB0aGlzLmNvbmZpZztcclxuXHRsZXQgdGFyZ2V0O1xyXG5cdGxldCBrZXlzO1xyXG5cdGxldCByZWFkO1xyXG5cclxuXHRjb25zdCBmaW5kID0gKCkgPT4ge1xyXG5cdFx0Y29uc3Qga2V5ID0ga2V5cy5zaGlmdCgpO1xyXG5cclxuXHRcdGlmIChrZXkgJiYgdGFyZ2V0ICYmIGlzT2JqZWN0VHlwZSh0YXJnZXQpICYmIGtleSBpbiB0YXJnZXQpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0W2tleV07XHJcblx0XHRcdHJldHVybiBmaW5kKCk7XHJcblx0XHR9IGVsc2UgaWYgKCFrZXkpIHtcclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH07XHJcblxyXG5cdE9iamVjdC5rZXlzKHRoaXNDb25maWcpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdHRhcmdldCA9IGNvbmZpZztcclxuXHRcdGtleXMgPSBrZXkuc3BsaXQoXCJfXCIpO1xyXG5cdFx0cmVhZCA9IGZpbmQoKTtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKHJlYWQpKSB7XHJcblx0XHRcdHRoaXNDb25maWdba2V5XSA9IHJlYWQ7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7bm90RW1wdHksIGlzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogUmVzaXplIHRoZSBjaGFydC5cclxuXHQgKiBAZnVuY3Rpb24gcmVzaXplXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHNpemUgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB3aWR0aCBhbmQgaGVpZ2h0IGluIHBpeGVscy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFJlc2l6ZSB0byA2NDB4NDgwXHJcblx0ICogY2hhcnQucmVzaXplKHtcclxuXHQgKiAgICB3aWR0aDogNjQwLFxyXG5cdCAqICAgIGhlaWdodDogNDgwXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0cmVzaXplKHNpemU/OiB7d2lkdGg/OiBudW1iZXIsIGhlaWdodD86IG51bWJlcn0pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5yZW5kZXJlZCkge1xyXG5cdFx0XHRjb25maWcuc2l6ZV93aWR0aCA9IHNpemUgPyBzaXplLndpZHRoIDogbnVsbDtcclxuXHRcdFx0Y29uZmlnLnNpemVfaGVpZ2h0ID0gc2l6ZSA/IHNpemUuaGVpZ2h0IDogbnVsbDtcclxuXHJcblx0XHRcdHRoaXMuZmx1c2goZmFsc2UsIHRydWUpO1xyXG5cdFx0XHQkJC5yZXNpemVGdW5jdGlvbigpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvcmNlIHRvIHJlZHJhdy5cclxuXHQgKiBAZnVuY3Rpb24gZmx1c2hcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtzb2Z0XSBGb3Igc29mdCByZWRyYXcuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5mbHVzaCgpO1xyXG5cdCAqXHJcblx0ICogLy8gZm9yIHNvZnQgcmVkcmF3XHJcblx0ICogY2hhcnQuZmx1c2godHJ1ZSk7XHJcblx0ICovXHJcblx0Zmx1c2goc29mdD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRpZiAoc3RhdGUucmVuZGVyZWQpIHtcclxuXHRcdFx0Ly8gcmVzZXQgcG9zc2libGUgem9vbSBzY2FsZSB3aGVuIGlzIGNhbGxlZCBmcm9tIHJlc2l6ZSBldmVudFxyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXHJcblx0XHRcdGlmIChzdGF0ZS5yZXNpemluZykgeyAvLyBhcmd1bWVudHNbMV0gaXMgZ2l2ZW4gd2hlbiBpcyBjYWxsZWQgZnJvbSByZXNpemVcclxuXHRcdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC51cGRhdGVSZXNpemUoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyByZS11cGRhdGUgY29uZmlnIGluZm9cclxuXHRcdFx0XHQkJC5heGlzICYmICQkLmF4aXMuc2V0T3JpZW50KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLnNjYWxlLnpvb20gPSBudWxsO1xyXG5cclxuXHRcdFx0c29mdCA/ICQkLnJlZHJhdyh7XHJcblx0XHRcdFx0d2l0aFRyYW5zZm9ybTogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0XHRcdH0pIDogJCQudXBkYXRlQW5kUmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcclxuXHRcdFx0XHR3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0JCQuaW5pdFRvUmVuZGVyKHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc2V0IHRoZSBjaGFydCBvYmplY3QgYW5kIHJlbW92ZSBlbGVtZW50IGFuZCBldmVudHMgY29tcGxldGVseS5cclxuXHQgKiBAZnVuY3Rpb24gZGVzdHJveVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEByZXR1cm5zIHtudWxsfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuZGVzdHJveSgpO1xyXG5cdCAqL1xyXG5cdGRlc3Ryb3koKTogbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7JGVsOiB7Y2hhcnQsIHN2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG5vdEVtcHR5KCQkKSkge1xyXG5cdFx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiR3aWxsRGVzdHJveVwiKTtcclxuXHRcdFx0JCQuY2hhcnRzLnNwbGljZSgkJC5jaGFydHMuaW5kZXhPZih0aGlzKSwgMSk7XHJcblxyXG5cdFx0XHQvLyBjbGVhciB0aW1lcnMgJiYgcGVuZGluZyB0cmFuc2l0aW9uXHJcblx0XHRcdHN2Zy5zZWxlY3QoXCIqXCIpLmludGVycnVwdCgpO1xyXG5cdFx0XHQkJC5yZXNpemVGdW5jdGlvbi5jbGVhcigpO1xyXG5cclxuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24pO1xyXG5cdFx0XHRjaGFydC5jbGFzc2VkKFwiYmJcIiwgZmFsc2UpLmh0bWwoXCJcIik7XHJcblxyXG5cdFx0XHQvLyByZWxlYXNpbmcgcmVmZXJlbmNlc1xyXG5cdFx0XHRPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0a2V5ID09PSBcImludGVybmFsXCIgJiYgT2JqZWN0LmtleXMoJCQpLmZvckVhY2goayA9PiB7XHJcblx0XHRcdFx0XHQkJFtrXSA9IG51bGw7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHRoaXNba2V5XSA9IG51bGw7XHJcblx0XHRcdFx0ZGVsZXRlIHRoaXNba2V5XTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IG9yIHNldCBzaW5nbGUgY29uZmlnIG9wdGlvbiB2YWx1ZS5cclxuXHQgKiBAZnVuY3Rpb24gY29uZmlnXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG9wdGlvbiBrZXkgbmFtZS5cclxuXHQgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIGFjY2VwdGVkIGZvciBpbmRpY2F0ZWQgb3B0aW9uLlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlZHJhd10gU2V0IHRvIHJlZHJhdyB3aXRoIHRoZSBuZXcgb3B0aW9uIGNoYW5nZXMuXHJcblx0ICogLSAqKk5PVEU6KiogRG9lc24ndCBndWFyYW50ZWUgd29yayBpbiBhbGwgY2lyY3Vtc3RhbmNlcy4gSXQgY2FuIGJlIGFwcGxpZWQgZm9yIGxpbWl0ZWQgb3B0aW9ucyBvbmx5LlxyXG5cdCAqIEByZXR1cm5zIHsqfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0dGVyXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIpO1xyXG5cdCAqXHJcblx0ICogLy8gU2V0dGVyXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCk7XHJcblx0ICpcclxuXHQgKiAvLyBTZXR0ZXIgJiByZWRyYXcgd2l0aCB0aGUgbmV3IG9wdGlvblxyXG5cdCAqIGNoYXJ0LmNvbmZpZyhcImdhdWdlLm1heFwiLCAxMDAsIHRydWUpO1xyXG5cdCAqL1xyXG5cdGNvbmZpZyhuYW1lOiBzdHJpbmcsIHZhbHVlPzogYW55LCByZWRyYXc/OiBib29sZWFuKTogYW55IHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBrZXkgPSBuYW1lICYmIG5hbWUucmVwbGFjZSgvXFwuL2csIFwiX1wiKTtcclxuXHRcdGxldCByZXM7XHJcblxyXG5cdFx0aWYgKGtleSBpbiBjb25maWcpIHtcclxuXHRcdFx0aWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuXHRcdFx0XHRjb25maWdba2V5XSA9IHZhbHVlO1xyXG5cdFx0XHRcdHJlcyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZWRyYXcgJiYgdGhpcy5mbHVzaCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlcyA9IGNvbmZpZ1trZXldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgY29sb3JcclxuXHQgKiBAZnVuY3Rpb24gY29sb3JcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgaWQgdG8gZ2V0IHRoZSBjb2xvclxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5jb2xvcihcImRhdGExXCIpO1xyXG5cdCAqL1xyXG5cdGNvbG9yKGlkOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuY29sb3IoaWQpOyAvLyBtb3JlIHBhdHRlcm5zXHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7RGF0YUl0ZW19IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2V4dGVuZCwgaXNVbmRlZmluZWQsIGlzQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxudHlwZSBkYXRhUGFyYW0gPSB7eDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyLCBpZDogc3RyaW5nLCBpbmRleDogbnVtYmVyfVtdO1xyXG5cclxuLyoqXHJcbiAqIEdldCBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcbiAqIEBmdW5jdGlvbiBkYXRhXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHRhcmdldElkcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIEFQSSByZXR1cm5zIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGRhdGEuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBhbGwgb2YgZGF0YSB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IERhdGEgb2JqZWN0c1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBHZXQgb25seSBkYXRhMSBkYXRhXHJcbiAqIGNoYXJ0LmRhdGEoXCJkYXRhMVwiKTtcclxuICogLy8gLS0+IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogQXJyYXkoNil9LCAuLi5dXHJcbiAqXHJcbiAqIC8vIEdldCBkYXRhMSBhbmQgZGF0YTIgZGF0YVxyXG4gKiBjaGFydC5kYXRhKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG4gKlxyXG4gKiAvLyBHZXQgYWxsIGRhdGFcclxuICogY2hhcnQuZGF0YSgpO1xyXG4gKi9cclxuZnVuY3Rpb24gZGF0YSh0YXJnZXRJZHM6IHN0cmluZ3xzdHJpbmdbXSk6IERhdGFJdGVtW10ge1xyXG5cdGNvbnN0IHt0YXJnZXRzfSA9IHRoaXMuaW50ZXJuYWwuZGF0YTtcclxuXHJcblx0aWYgKCFpc1VuZGVmaW5lZCh0YXJnZXRJZHMpKSB7XHJcblx0XHRjb25zdCBpZHM6IGFueSA9IGlzQXJyYXkodGFyZ2V0SWRzKSA/IHRhcmdldElkcyA6IFt0YXJnZXRJZHNdO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXRzLmZpbHRlcih0ID0+IGlkcy5zb21lKHYgPT4gdiA9PT0gdC5pZCkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRhcmdldHM7XHJcbn1cclxuXHJcbmV4dGVuZChkYXRhLCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgc2hvd24gaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBmdW5jdGlvbiBkYXRh4oCkc2hvd25cclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgQVBJIGZpbHRlcnMgdGhlIGRhdGEgd2l0aCBzcGVjaWZpZWQgdGFyZ2V0IGlkcy4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGFsbCBzaG93biBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBEYXRhIG9iamVjdHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIG9ubHkgZGF0YTEgZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oXCJkYXRhMVwiKTtcclxuXHQgKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cclxuXHQgKlxyXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIGRhdGExIGFuZCBkYXRhMiBkYXRhXHJcblx0ICogY2hhcnQuZGF0YS5zaG93bihbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIEdldCBhbGwgc2hvd24gZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oKTtcclxuXHQgKi9cclxuXHRzaG93bjogZnVuY3Rpb24odGFyZ2V0SWRzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IERhdGFJdGVtW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZmlsdGVyVGFyZ2V0c1RvU2hvdyh0aGlzLmRhdGEodGFyZ2V0SWRzKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHZhbHVlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBmdW5jdGlvbiBkYXRh4oCkdmFsdWVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl8bnVsbH0gdGFyZ2V0SWRzIFRoaXMgQVBJIHJldHVybnMgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdGFyZ2V0LiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgbnVsbCB3aWxsIGJlIHJldHJ1bmVkXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBbZmxhdD10cnVlXSBHZXQgZmxhdHRlbiB2YWx1ZXNcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IERhdGEgdmFsdWVzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgZGF0YTEgdmFsdWVzXHJcblx0ICogY2hhcnQuZGF0YS52YWx1ZXMoXCJkYXRhMVwiKTtcclxuXHQgKiAvLyAtLT4gWzEwLCAyMCwgMzAsIDQwXVxyXG5cdCAqL1xyXG5cdHZhbHVlczogZnVuY3Rpb24odGFyZ2V0SWRzPzogc3RyaW5nIHwgc3RyaW5nW10sIGZsYXQ6IGJvb2xlYW4gPSB0cnVlKTogbnVtYmVyW118bnVtYmVyW11bXXxudWxsIHtcclxuXHRcdGxldCB2YWx1ZXM6IGFueSA9IG51bGw7XHJcblxyXG5cdFx0aWYgKHRhcmdldElkcykge1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzID0gdGhpcy5kYXRhKHRhcmdldElkcyk7XHJcblxyXG5cdFx0XHRpZiAodGFyZ2V0cyAmJiBpc0FycmF5KHRhcmdldHMpKSB7XHJcblx0XHRcdFx0dmFsdWVzID0gW107XHJcblxyXG5cdFx0XHRcdHRhcmdldHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGRhdGFWYWx1ZSA9IHYudmFsdWVzLm1hcChkID0+IGQudmFsdWUpO1xyXG5cclxuXHRcdFx0XHRcdGZsYXQgPyAodmFsdWVzID0gdmFsdWVzLmNvbmNhdChkYXRhVmFsdWUpKSA6IHZhbHVlcy5wdXNoKGRhdGFWYWx1ZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IG5hbWVzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRuYW1lc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBuYW1lcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbmFtZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgbmFtZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXHJcblx0ICogQHJldHVybnMge29iamVjdH0gQ29ycmVzcG9uZGluZyBuYW1lcyBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZSwgaWYgc3BlY2lmaWVkIG5hbWVzIHZhbHVlcy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IG5hbWVzXHJcblx0ICogY2hhcnQuZGF0YS5uYW1lcygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwidGVzdDFcIiwgZGF0YTI6IFwidGVzdDJcIn1cclxuXHQgKlxyXG5cdCAqIC8vIFVwZGF0ZSBuYW1lc1xyXG5cdCAqIGNoYXJ0LmRhdGEubmFtZXMoe1xyXG5cdCAqICBkYXRhMTogXCJOZXcgTmFtZSAxXCIsXHJcblx0ICogIGRhdGEyOiBcIk5ldyBOYW1lIDJcIlxyXG5cdCAqfSk7XHJcblx0ICovXHJcblx0bmFtZXM6IGZ1bmN0aW9uKG5hbWVzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0+KToge1trZXk6IHN0cmluZ106IHN0cmluZ30ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdC8vIHJlc2V0IGV4aXN0aW5nIGxlZ2VuZCBpdGVtIGRpbWVuc2lvbiBjYWNoZSBkYXRhXHJcblx0XHQkJC5jYWNoZS5yZW1vdmUoS0VZLmxlZ2VuZEl0ZW1UZXh0Qm94KTtcclxuXHJcblx0XHRyZXR1cm4gJCQudXBkYXRlRGF0YUF0dHJpYnV0ZXMoXCJuYW1lc1wiLCBuYW1lcyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgY29sb3JzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRjb2xvcnNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gY29sb3JzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjb2xvcnMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgY29sb3JzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBbZGF0YS5jb2xvcnNdKC4vT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0Y29sb3JzKS5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBDb3JyZXNwb25kaW5nIGRhdGEgY29sb3IgdmFsdWUgYWNjb3JkaW5nIGl0cyBrZXkgdmFsdWUuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBjb2xvcnNcclxuXHQgKiBjaGFydC5kYXRhLmNvbG9ycygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwiIzAwYzczY1wiLCBkYXRhMjogXCIjZmE3MTcxXCJ9XHJcblx0ICpcclxuXHQgKiAvLyBVcGRhdGUgY29sb3JzXHJcblx0ICogY2hhcnQuZGF0YS5jb2xvcnMoe1xyXG5cdCAqICBkYXRhMTogXCIjRkZGRkZGXCIsXHJcblx0ICogIGRhdGEyOiBcIiMwMDAwMDBcIlxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGNvbG9yczogZnVuY3Rpb24oY29sb3JzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0+KTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcyhcImNvbG9yc1wiLCBjb2xvcnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4ZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuXHQgKiAtICoqTk9URToqKiBJZiBhbGwgZGF0YSBpcyByZWxhdGVkIHRvIG9uZSBvZiB0aGUgYXhlcywgdGhlIGRvbWFpbiBvZiBheGlzIHdpdGhvdXQgcmVsYXRlZCBkYXRhIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGRvbWFpbiBmcm9tIHRoZSBheGlzIHdpdGggcmVsYXRlZCBkYXRhXHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRheGVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGF4ZXMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGF4ZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgYXhlcyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXNcclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSBDb3JyZXNwb25kaW5nIGF4ZXMgdmFsdWUgZm9yIGRhdGEsIGlmIHNwZWNpZmllZCBheGVzIHZhbHVlLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEuYXhlcygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwieVwifVxyXG5cdCAqXHJcblx0ICogLy8gVXBkYXRlIGF4ZXNcclxuXHQgKiBjaGFydC5kYXRhLmF4ZXMoe1xyXG5cdCAqICBkYXRhMTogXCJ5XCIsXHJcblx0ICogIGRhdGEyOiBcInkyXCJcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRheGVzOiBmdW5jdGlvbihheGVzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4pOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiYXhlc1wiLCBheGVzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG1pbmltdW0gZGF0YSB2YWx1ZSBib3VuZCB0byB0aGUgY2hhcnRcclxuXHQgKiBAZnVuY3Rpb24gZGF0YeKApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5taW4oKTtcclxuXHQgKiAvLyAtLT4gW3t4OiAwLCB2YWx1ZTogMzAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAwfSwgLi4uXVxyXG5cdCAqL1xyXG5cdG1pbjogZnVuY3Rpb24oKTogZGF0YVBhcmFtIHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLmdldE1pbk1heERhdGEoKS5taW47XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBtYXhpbXVtIGRhdGEgdmFsdWUgYm91bmQgdG8gdGhlIGNoYXJ0XHJcblx0ICogQGZ1bmN0aW9uIGRhdGHigKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IERhdGEgb2JqZWN0c1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEubWF4KCk7XHJcblx0ICogLy8gLS0+IFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi5dXHJcblx0ICovXHJcblx0bWF4OiBmdW5jdGlvbigpOiBkYXRhUGFyYW0ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1heDtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2RhdGF9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXN9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7aXNGdW5jdGlvbiwgdG9BcnJheSwgZ2V0Q3NzUnVsZXN9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZSB0byBiYXNlNjRcclxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBzdHJpbmcgdG8gYmUgZW5jb2RlZFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9XaW5kb3dCYXNlNjQvQmFzZTY0X2VuY29kaW5nX2FuZF9kZWNvZGluZ1xyXG4gKi9cclxuY29uc3QgYjY0RW5jb2RlVW5pY29kZSA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiBidG9hKFxyXG5cdGVuY29kZVVSSUNvbXBvbmVudChzdHIpXHJcblx0XHQucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgKG1hdGNoLCBwOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoYDB4JHtwfWApKSlcclxuKTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHN2ZyBub2RlIHRvIGRhdGEgdXJsXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgdGFyZ2V0IG5vZGVcclxuICogQHBhcmFtIHtvYmplY3R9IHNpemUgb2JqZWN0IGNvbnRhaW5pbmcge3dpZHRoLCBoZWlnaHR9XHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlVG9TdmdEYXRhVXJsKG5vZGUsIHNpemUpIHtcclxuXHRjb25zdCBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcclxuXHRjb25zdCBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xyXG5cdGNvbnN0IGNzc1RleHQgPSBnZXRDc3NSdWxlcyh0b0FycmF5KGRvY3VtZW50LnN0eWxlU2hlZXRzKSlcclxuXHRcdC5maWx0ZXIoKHI6IGFueSkgPT4gci5jc3NUZXh0KVxyXG5cdFx0Lm1hcCgocjogYW55KSA9PiByLmNzc1RleHQpO1xyXG5cclxuXHRjbG9uZS5zZXRBdHRyaWJ1dGUoXCJ4bWxuc1wiLCBkM05hbWVzcGFjZXMueGh0bWwpO1xyXG5cclxuXHRjb25zdCBub2RlWG1sID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhjbG9uZSk7XHJcblxyXG5cdC8vIGVzY2FwZSBjc3MgZm9yIFhNTFxyXG5cdGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cclxuXHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NUZXh0LmpvaW4oXCJcXG5cIikpKTtcclxuXHJcblx0Y29uc3Qgc3R5bGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKHN0eWxlKTtcclxuXHJcblx0Ly8gZm9yZWlnbk9iamVjdCBub3Qgc3VwcG9ydGVkIGluIElFMTEgYW5kIGJlbG93XHJcblx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDgzNDY3NSh2PXZzLjg1KS5hc3B4XHJcblx0Y29uc3QgZGF0YVN0ciA9IGA8c3ZnIHhtbG5zPVwiJHtkM05hbWVzcGFjZXMuc3ZnfVwiIHdpZHRoPVwiJHtzaXplLndpZHRofVwiIGhlaWdodD1cIiR7c2l6ZS5oZWlnaHR9XCI+XHJcblx0XHRcdDxmb3JlaWduT2JqZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIj5cclxuXHRcdFx0XHQke3N0eWxlWG1sfVxyXG5cdFx0XHRcdCR7bm9kZVhtbC5yZXBsYWNlKC8odXJsXFwoKVteI10rL2csIFwiJDFcIil9XHJcblx0XHRcdDwvZm9yZWlnbk9iamVjdD48L3N2Zz5gXHJcblx0XHQucmVwbGFjZShcIi9cXG4vZ1wiLCBcIiUwQVwiKTtcclxuXHJcblx0cmV0dXJuIGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LCR7YjY0RW5jb2RlVW5pY29kZShkYXRhU3RyKX1gO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogRXhwb3J0IGNoYXJ0IGFzIGFuIGltYWdlLlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIElFMTEgYW5kIGJlbG93IG5vdCB3b3JrIHByb3Blcmx5IGR1ZSB0byB0aGUgbGFjayBvZiB0aGUgZmVhdHVyZSg8YSBocmVmPVwiaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9oaDgzNDY3NSh2PXZzLjg1KS5hc3B4XCI+Zm9yZWlnbk9iamVjdDwvYT4pIHN1cHBvcnRcclxuXHQgKiAgIC0gVGhlIGJhc2ljIENTUyBmaWxlKGV4LiBiaWxsYm9hcmQuY3NzKSBzaG91bGQgYmUgYXQgc2FtZSBkb21haW4gYXMgQVBJIGNhbGwgY29udGV4dCB0byBnZXQgY29ycmVjdCBzdHlsZWQgZXhwb3J0IGltYWdlLlxyXG5cdCAqIEBmdW5jdGlvbiBleHBvcnRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW21pbWVUeXBlPWltYWdlL3BuZ10gVGhlIGRlc2lyZWQgb3V0cHV0IGltYWdlIGZvcm1hdC4gKGV4LiAnaW1hZ2UvcG5nJyBmb3IgcG5nLCAnaW1hZ2UvanBlZycgZm9yIGpwZWcgZm9ybWF0KVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBleHBvcnQgaXMgcmVhZHkuXHJcblx0ICogQHJldHVybnMge3N0cmluZ30gZGF0YVVSSVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGNoYXJ0LmV4cG9ydCgpO1xyXG5cdCAqICAvLyAtLT4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITi4uLlwiXHJcblx0ICpcclxuXHQgKiAgLy8gSW5pdGlhbGl6ZSB0aGUgZG93bmxvYWQgYXV0b21hdGljYWxseVxyXG5cdCAqICBjaGFydC5leHBvcnQoXCJpbWFnZS9wbmdcIiwgZGF0YVVybCA9PiB7XHJcblx0ICogICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcclxuXHQgKlxyXG5cdCAqICAgICBsaW5rLmRvd25sb2FkID0gYCR7RGF0ZS5ub3coKX0ucG5nYDtcclxuXHQgKiAgICAgbGluay5ocmVmID0gZGF0YVVybDtcclxuXHQgKiAgICAgbGluay5pbm5lckhUTUwgPSBcIkRvd25sb2FkIGNoYXJ0IGFzIGltYWdlXCI7XHJcblx0ICpcclxuXHQgKiAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcclxuXHQgKiAgfSk7XHJcblx0ICovXHJcblx0ZXhwb3J0KG1pbWVUeXBlPzogc3RyaW5nLCBjYWxsYmFjaz86IChkYXRhVXJsOiBzdHJpbmcpID0+IHZvaWQpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge3N0YXRlLCAkZWw6IHtjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzdGF0ZS5jdXJyZW50O1xyXG5cdFx0Y29uc3Qgc3ZnRGF0YVVybCA9IG5vZGVUb1N2Z0RhdGFVcmwoY2hhcnQubm9kZSgpLCB7d2lkdGgsIGhlaWdodH0pO1xyXG5cclxuXHRcdGlmIChjYWxsYmFjayAmJiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG5cdFx0XHRjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuXHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XHJcblx0XHRcdGltZy5vbmxvYWQgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuXHRcdFx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuXHRcdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcclxuXHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcclxuXHJcblx0XHRcdFx0Y2FsbGJhY2suYmluZCh0aGlzKShjYW52YXMudG9EYXRhVVJMKG1pbWVUeXBlKSk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpbWcuc3JjID0gc3ZnRGF0YVVybDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3ZnRGF0YVVybDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5cclxudHlwZSBmb2N1c1BhcmFtID0gc3RyaW5nIHwgc3RyaW5nW107XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVGhpcyBBUEkgaGlnaGxpZ2h0cyBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgZmFkZSBvdXQgdGhlIG90aGVycy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWQuXHJcblx0ICogQGZ1bmN0aW9uIGZvY3VzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZHMgdG8gYmUgaGlnaGxpZ2h0ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gZGF0YTEgd2lsbCBiZSBoaWdobGlnaHRlZCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIGZhZGVkIG91dFxyXG5cdCAqICBjaGFydC5mb2N1cyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSBmYWRlZCBvdXRcclxuXHQgKiBjaGFydC5mb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWRcclxuXHQgKiBjaGFydC5mb2N1cygpO1xyXG5cdCAqL1xyXG5cdGZvY3VzKHRhcmdldElkc1ZhbHVlPzogZm9jdXNQYXJhbSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICQkLiRlbC5zdmcuc2VsZWN0QWxsKFxyXG5cdFx0XHQkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzLmZpbHRlcigkJC5pc1RhcmdldFRvU2hvdywgJCQpKVxyXG5cdFx0KTtcclxuXHJcblx0XHR0aGlzLnJldmVydCgpO1xyXG5cdFx0dGhpcy5kZWZvY3VzKCk7XHJcblxyXG5cdFx0Y2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIHRydWUpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCBmYWxzZSk7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSAmJiAhc3RhdGUuaGFzUmFkYXIpIHtcclxuXHRcdFx0JCQuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0XHQkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiZcclxuXHRcdFx0XHQkJC5tYXJrT3ZlcmxhcHBlZCh0YXJnZXRJZHNWYWx1ZSwgJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgdHJ1ZSk7XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcclxuXHRcdHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcyA9IHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBBUEkgZmFkZXMgb3V0IHNwZWNpZmllZCB0YXJnZXRzIGFuZCByZXZlcnRzIHRoZSBvdGhlcnMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIGZhZGVkIG91dC5cclxuXHQgKiBAZnVuY3Rpb24gZGVmb2N1c1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSB0YXJnZXRJZHNWYWx1ZSBUYXJnZXQgaWRzIHRvIGJlIGZhZGVkIG91dC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQuZGVmb2N1cyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgZmFkZWQgb3V0IGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQuZGVmb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgZmFkZWQgb3V0LlxyXG5cdCAqIGNoYXJ0LmRlZm9jdXMoKTtcclxuXHQgKi9cclxuXHRkZWZvY3VzKHRhcmdldElkc1ZhbHVlPzogZm9jdXNQYXJhbSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICQkLiRlbC5zdmcuc2VsZWN0QWxsKFxyXG5cdFx0XHQkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzLmZpbHRlcigkJC5pc1RhcmdldFRvU2hvdywgJCQpKVxyXG5cdFx0KTtcclxuXHJcblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdCQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0XHQkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiZcclxuXHRcdFx0XHQkJC51bmRvTWFya092ZXJsYXBwZWQoJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdHN0YXRlLmZvY3VzZWRUYXJnZXRJZHMgPSBzdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHRcdHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIEFQSSByZXZlcnRzIHNwZWNpZmllZCB0YXJnZXRzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBAZnVuY3Rpb24gcmV2ZXJ0XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZHMgdG8gYmUgcmV2ZXJ0ZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQucmV2ZXJ0KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5yZXZlcnQoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIGNoYXJ0LnJldmVydCgpO1xyXG5cdCAqL1xyXG5cdHJldmVydCh0YXJnZXRJZHNWYWx1ZT86IGZvY3VzUGFyYW0pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJGVsLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpOyAvLyBzaG91bGQgYmUgZm9yIGFsbCB0YXJnZXRzXHJcblxyXG5cdFx0Y2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIGZhbHNlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgZmFsc2UpO1xyXG5cdFx0JCQuaGFzQXJjVHlwZSgpICYmICQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHQkJC5zaG93TGVnZW5kKHRhcmdldElkcy5maWx0ZXIoJCQuaXNMZWdlbmRUb1Nob3cuYmluZCgkJCkpKTtcclxuXHRcdFx0JGVsLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IFtdO1xyXG5cdFx0c3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzID0gW107XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBEZWZpbmUgbGVnZW5kXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNvbnN0IGxlZ2VuZCA9IHtcclxuXHQvKipcclxuXHQgKiBTaG93IGxlZ2VuZCBmb3IgZWFjaCB0YXJnZXQuXHJcblx0ICogQGZ1bmN0aW9uIGxlZ2VuZOKApHNob3dcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXHJcblx0ICogLSBJZiB0YXJnZXRJZHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBzaG93bi5cclxuXHQgKiAtIElmIG9ubHkgb25lIHRhcmdldCBpcyB0aGUgY2FuZGlkYXRlLCBTdHJpbmcgY2FuIGJlIHBhc3NlZC5cclxuXHQgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBTaG93IGxlZ2VuZCBmb3IgZGF0YTEuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMSBhbmQgZGF0YTIuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBTaG93IGFsbCBsZWdlbmQuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coKTtcclxuXHQgKi9cclxuXHRzaG93OiBmdW5jdGlvbih0YXJnZXRJZHM/OiBzdHJpbmcgfCBzdHJpbmdbXSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdCQkLnNob3dMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XHJcblx0XHQkJC51cGRhdGVBbmRSZWRyYXcoe3dpdGhMZWdlbmQ6IHRydWV9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGxlZ2VuZCBmb3IgZWFjaCB0YXJnZXQuXHJcblx0ICogQGZ1bmN0aW9uIGxlZ2VuZOKApGhpZGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXHJcblx0ICogLSBJZiB0YXJnZXRJZHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uXHJcblx0ICogLSBJZiBvbmx5IG9uZSB0YXJnZXQgaXMgdGhlIGNhbmRpZGF0ZSwgU3RyaW5nIGNhbiBiZSBwYXNzZWQuXHJcblx0ICogLSBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEhpZGUgbGVnZW5kIGZvciBkYXRhMS5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZShcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gSGlkZSBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZShbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIEhpZGUgYWxsIGxlZ2VuZC5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZSgpO1xyXG5cdCAqL1xyXG5cdGhpZGU6IGZ1bmN0aW9uKHRhcmdldElkcz86IHN0cmluZyB8IHN0cmluZ1tdKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0JCQuaGlkZUxlZ2VuZCgkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpKTtcclxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdyh7d2l0aExlZ2VuZDogdHJ1ZX0pO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtsZWdlbmR9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNTdHJpbmcsIGlzQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIExvYWQgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXHJcblx0ICogLSA8Yj5Ob3RlOjwvYj5cclxuXHQgKiAgIC0gdW5sb2FkIHNob3VsZCBiZSB1c2VkIGlmIHNvbWUgZGF0YSBuZWVkcyB0byBiZSB1bmxvYWRlZCBzaW11bHRhbmVvdXNseS5cclxuXHQgKiAgICAgSWYgeW91IGNhbGwgdW5sb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSBsb2FkIGluc3RlYWQgb2YgdW5sb2FkIHBhcmFtLCBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxyXG5cdCAqICAgLSBkb25lIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGRhdGEgbG9hZGVkLCBidXQgaXQncyBub3QgYWZ0ZXIgcmVuZGVyaW5nLlxyXG5cdCAqICAgICBJdCdzIGJlY2F1c2UgcmVuZGVyaW5nIHdpbGwgZmluaXNoIGFmdGVyIHNvbWUgdHJhbnNpdGlvbiBhbmQgdGhlcmUgaXMgc29tZSB0aW1lIGxhZyBiZXR3ZWVuIGxvYWRpbmcgYW5kIHJlbmRlcmluZ1xyXG5cdCAqIEBmdW5jdGlvbiBsb2FkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3MgVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IC0gdXJsPGJyPi0ganNvbjxicj4tIHJvd3M8YnI+LSBjb2x1bW5zIHwgVGhlIGRhdGEgd2lsbCBiZSBsb2FkZWQuIElmIGRhdGEgdGhhdCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGlkIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB1cGRhdGVkLiBPdGhlcndpc2UsIG5ldyB0YXJnZXQgd2lsbCBiZSBhZGRlZCB8XHJcblx0ICogICAgfCBkYXRhIHwgRGF0YSBvYmplY3RzIHRvIGJlIGxvYWRlZC4gQ2hlY2tvdXQgdGhlIGV4YW1wbGUuIHxcclxuXHQgKiAgICB8IG5hbWVzIHwgU2FtZSBhcyBkYXRhLm5hbWVzKCkgfFxyXG5cdCAqICAgIHwgeHMgfCBTYW1lIGFzIGRhdGEueHMgb3B0aW9uICB8XHJcblx0ICogICAgfCBjbGFzc2VzIHwgVGhlIGNsYXNzZXMgc3BlY2lmaWVkIGJ5IGRhdGEuY2xhc3NlcyB3aWxsIGJlIHVwZGF0ZWQuIGNsYXNzZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcclxuXHQgKiAgICB8IGNhdGVnb3JpZXMgfCBUaGUgY2F0ZWdvcmllcyBzcGVjaWZpZWQgYnkgYXhpcy54LmNhdGVnb3JpZXMgb3IgZGF0YS54IHdpbGwgYmUgdXBkYXRlZC4gY2F0ZWdvcmllcyBtdXN0IGJlIEFycmF5LiB8XHJcblx0ICogICAgfCBheGVzIHwgVGhlIGF4ZXMgc3BlY2lmaWVkIGJ5IGRhdGEuYXhlcyB3aWxsIGJlIHVwZGF0ZWQuIGF4ZXMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcclxuXHQgKiAgICB8IGNvbG9ycyB8IFRoZSBjb2xvcnMgc3BlY2lmaWVkIGJ5IGRhdGEuY29sb3JzIHdpbGwgYmUgdXBkYXRlZC4gY29sb3JzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XHJcblx0ICogICAgfCBoZWFkZXJzIHwgIFNldCByZXF1ZXN0IGhlYWRlciBpZiBsb2FkaW5nIHZpYSBgZGF0YS51cmxgLjxicj5Ac2VlIFtkYXRh4oCkaGVhZGVyc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0aGVhZGVycykgfFxyXG5cdCAqICAgIHwga2V5cyB8ICBDaG9vc2Ugd2hpY2ggSlNPTiBvYmplY3RzIGtleXMgY29ycmVzcG9uZCB0byBkZXNpcmVkIGRhdGEuPGJyPioqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS48YnI+QHNlZSBbZGF0YeKApGtleXNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGtleXMpIHxcclxuXHQgKiAgICB8IG1pbWVUeXBlIHwgIFNldCAnanNvbicgaWYgbG9hZGluZyBKU09OIHZpYSB1cmwuPGJyPkBzZWUgW2RhdGHigKRtaW1lVHlwZV0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0bWltZVR5cGUpIHxcclxuXHQgKiAgICB8IC0gdHlwZTxicj4tIHR5cGVzIHwgVGhlIHR5cGUgb2YgdGFyZ2V0cyB3aWxsIGJlIHVwZGF0ZWQuIHR5cGUgbXVzdCBiZSBTdHJpbmcgYW5kIHR5cGVzIG11c3QgYmUgT2JqZWN0LiB8XHJcblx0ICogICAgfCB1bmxvYWQgfCBTcGVjaWZ5IHRoZSBkYXRhIHdpbGwgYmUgdW5sb2FkZWQgYmVmb3JlIGxvYWRpbmcgbmV3IGRhdGEuIElmIHRydWUgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgdW5sb2FkZWQuIElmIHRhcmdldCBpZHMgZ2l2ZW4gYXMgU3RyaW5nIG9yIEFycmF5LCBzcGVjaWZpZWQgdGFyZ2V0cyB3aWxsIGJlIHVubG9hZGVkLiBJZiBhYnNlbnQgb3IgZmFsc2UgZ2l2ZW4sIHVubG9hZCB3aWxsIG5vdCBvY2N1ci4gfFxyXG5cdCAqICAgIHwgZG9uZSB8IFRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQufFxyXG5cdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFGcm9tVVJMKVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gTG9hZCBkYXRhMSBhbmQgdW5sb2FkIGRhdGEyIGFuZCBkYXRhM1xyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICBjb2x1bW5zOiBbXHJcblx0ICogICAgICAgIFtcImRhdGExXCIsIDEwMCwgMjAwLCAxNTAsIC4uLl0sXHJcblx0ICogICAgICAgIC4uLlxyXG5cdCAqICAgIF0sXHJcblx0ICogICAgdW5sb2FkOiBbXCJkYXRhMlwiLCBcImRhdGEzXCJdLFxyXG5cdCAqICAgIHVybDogXCIuLi5cIixcclxuXHQgKiAgICBkb25lOiBmdW5jdGlvbigpIHsgLi4uIH1cclxuXHQgKiB9KTtcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIG15QVBJLmpzb25cclxuXHQgKiAvLyB7XHJcblx0ICogLy8gICBcImRhdGExXCI6IFsyMjAsIDI0MCwgMjcwLCAyNTAsIDI4MF0sXHJcblx0ICogLy8gICBcImRhdGEyXCI6IFsxODAsIDE1MCwgMzAwLCA3MCwgMTIwXVxyXG5cdCAqIC8vIH1cclxuXHQgKlxyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICB1cmw6ICcuL2RhdGEvbXlBUEkuanNvbicsXHJcblx0ICogICAgIG1pbWVUeXBlOiBcImpzb25cIixcclxuXHQgKlxyXG5cdCAqICAgICAvLyBzZXQgcmVxdWVzdCBoZWFkZXIgaWYgaXMgbmVlZGVkXHJcblx0ICogICAgIGhlYWRlcnM6IHtcclxuXHQgKiAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvanNvblwiXHJcblx0ICogICAgIH1cclxuXHQgKiB9KTtcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmxvYWQoe1xyXG5cdCAqICAgICBkYXRhOiBbXHJcblx0ICogICAgICAgLy8gZXF1aXZhbGVudCBhczogY29sdW1uczogW1tcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1dXHJcblx0ICogICAgICAge1wiZGF0YTFcIjogMzB9LCB7XCJkYXRhMVwiOiAyMDB9LCB7XCJkYXRhMVwiOiAxMDB9XHJcblx0ICpcclxuXHQgKiAgICAgICAvLyBvclxyXG5cdCAqICAgICAgIC8vIGVxdWl2YWxlbnQgYXM6IGNvbHVtbnM6IFtbXCJkYXRhMVwiLCAxMCwgMjBdLCBbXCJkYXRhMlwiLCAxMywgMzBdXVxyXG5cdCAqICAgICAgIC8vIHtcImRhdGExXCI6IDEwLCBcImRhdGEyXCI6IDEzfSwge1wiZGF0YTFcIjogMjAsIFwiZGF0YTJcIjogMzB9fVxyXG5cdCAqICAgICBdXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bG9hZChhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB4cyBpZiBzcGVjaWZpZWRcclxuXHRcdGFyZ3MueHMgJiYgJCQuYWRkWHMoYXJncy54cyk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIG5hbWVzIGlmIGV4aXN0c1xyXG5cdFx0XCJuYW1lc1wiIGluIGFyZ3MgJiYgdGhpcy5kYXRhLm5hbWVzKGFyZ3MubmFtZXMpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBjbGFzc2VzIGlmIGV4aXN0c1xyXG5cdFx0XCJjbGFzc2VzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmNsYXNzZXMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25maWcuZGF0YV9jbGFzc2VzW2lkXSA9IGFyZ3MuY2xhc3Nlc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2F0ZWdvcmllcyBpZiBleGlzdHNcclxuXHRcdGlmIChcImNhdGVnb3JpZXNcIiBpbiBhcmdzICYmICQkLmF4aXMuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGFyZ3MuY2F0ZWdvcmllcztcclxuXHRcdH1cclxuXHJcblx0XHQvLyB1cGRhdGUgYXhlcyBpZiBleGlzdHNcclxuXHRcdFwiYXhlc1wiIGluIGFyZ3MgJiYgT2JqZWN0LmtleXMoYXJncy5heGVzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfYXhlc1tpZF0gPSBhcmdzLmF4ZXNbaWRdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNvbG9ycyBpZiBleGlzdHNcclxuXHRcdFwiY29sb3JzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmNvbG9ycykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGNvbmZpZy5kYXRhX2NvbG9yc1tpZF0gPSBhcmdzLmNvbG9yc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyB1bmxvYWQgaWYgbmVlZGVkXHJcblx0XHRpZiAoXCJ1bmxvYWRcIiBpbiBhcmdzICYmIGFyZ3MudW5sb2FkICE9PSBmYWxzZSkge1xyXG5cdFx0XHQvLyBUT0RPOiBkbyBub3QgdW5sb2FkIGlmIHRhcmdldCB3aWxsIGxvYWQgKGluY2x1ZGVkIGluIHVybC9yb3dzL2NvbHVtbnMpXHJcblx0XHRcdCQkLnVubG9hZCgkJC5tYXBUb1RhcmdldElkcyhhcmdzLnVubG9hZCA9PT0gdHJ1ZSA/IG51bGwgOiBhcmdzLnVubG9hZCksICgpID0+XHJcblx0XHRcdFx0JCQubG9hZEZyb21BcmdzKGFyZ3MpXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC5sb2FkRnJvbUFyZ3MoYXJncyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5sb2FkIGRhdGEgdG8gdGhlIGNoYXJ0Ljxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSB0b2dnbGVzLlxyXG5cdCAqIC0gPGI+Tm90ZTo8L2I+XHJcblx0ICogSWYgeW91IGNhbGwgbG9hZCBBUEkgc29vbiBhZnRlci9iZWZvcmUgdW5sb2FkLCB1bmxvYWQgcGFyYW0gb2YgbG9hZCBzaG91bGQgYmUgdXNlZC4gT3RoZXJ3aXNlIGNoYXJ0IHdpbGwgbm90IGJlIHJlbmRlcmVkIHByb3Blcmx5IGJlY2F1c2Ugb2YgY2FuY2VsIG9mIGFuaW1hdGlvbi48YnI+XHJcblx0ICogYGRvbmVgIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGRhdGEgbG9hZGVkLCBidXQgaXQncyBub3QgYWZ0ZXIgcmVuZGVyaW5nLiBJdCdzIGJlY2F1c2UgcmVuZGVyaW5nIHdpbGwgZmluaXNoIGFmdGVyIHNvbWUgdHJhbnNpdGlvbiBhbmQgdGhlcmUgaXMgc29tZSB0aW1lIGxhZyBiZXR3ZWVuIGxvYWRpbmcgYW5kIHJlbmRlcmluZy5cclxuXHQgKiBAZnVuY3Rpb24gdW5sb2FkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZ3NWYWx1ZVxyXG5cdCAqICB8IGtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgfCBpZHMgfCBTdHJpbmcgJnZlcnQ7IEFycmF5IHwgVGFyZ2V0IGlkIGRhdGEgdG8gYmUgdW5sb2FkZWQuIElmIG5vdCBnaXZlbiwgYWxsIGRhdGEgd2lsbCBiZSB1bmxvYWRlZC4gfFxyXG5cdCAqICB8IGRvbmUgfCBGdWN0aW9uIHwgQ2FsbGJhY2sgYWZ0ZXIgZGF0YSBpcyB1bmxvYWRlZC4gfFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFVubG9hZCBkYXRhMiBhbmQgZGF0YTNcclxuXHQgKiAgY2hhcnQudW5sb2FkKHtcclxuXHQgKiAgICBpZHM6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXHJcblx0ICogICAgZG9uZTogZnVuY3Rpb24oKSB7XHJcblx0ICogICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSB1bmxvYWRlZFxyXG5cdCAqICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICovXHJcblx0dW5sb2FkKGFyZ3NWYWx1ZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0bGV0IGFyZ3MgPSBhcmdzVmFsdWUgfHwge307XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkoYXJncykpIHtcclxuXHRcdFx0YXJncyA9IHtpZHM6IGFyZ3N9O1xyXG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhhcmdzKSkge1xyXG5cdFx0XHRhcmdzID0ge2lkczogW2FyZ3NdfTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpZHMgPSAkJC5tYXBUb1RhcmdldElkcyhhcmdzLmlkcyk7XHJcblxyXG5cdFx0JCQudW5sb2FkKGlkcywgKCkgPT4ge1xyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQkJC5jYWNoZS5yZW1vdmUoaWRzKTtcclxuXHRcdFx0YXJncy5kb25lICYmIGFyZ3MuZG9uZS5jYWxsKHRoaXMpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZW5kYWxsfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBTaG93L0hpZGUgZGF0YSBzZXJpZXNcclxuICogQHBhcmFtIHtib29sZWFufSBzaG93IFNob3cgb3IgaGlkZVxyXG4gKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHNWYWx1ZSBUYXJnZXQgaWQgdmFsdWVzXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIE9wdGlvbnNcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNob3dIaWRlKHNob3c6IGJvb2xlYW4sIHRhcmdldElkc1ZhbHVlOiBzdHJpbmdbXSwgb3B0aW9uczogYW55KTogdm9pZCB7XHJcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkc1ZhbHVlKTtcclxuXHJcblx0JCQuc3RhdGUudG9nZ2xpbmcgPSB0cnVlO1xyXG5cclxuXHQkJFtgJHtzaG93ID8gXCJyZW1vdmVcIiA6IFwiYWRkXCJ9SGlkZGVuVGFyZ2V0SWRzYF0odGFyZ2V0SWRzKTtcclxuXHJcblx0Y29uc3QgdGFyZ2V0cyA9ICQkLiRlbC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMpKTtcclxuXHRjb25zdCBvcGFjaXR5ID0gc2hvdyA/IFwiMVwiIDogXCIwXCI7XHJcblxyXG5cdHRhcmdldHMudHJhbnNpdGlvbigpXHJcblx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHksIFwiaW1wb3J0YW50XCIpXHJcblx0XHQuY2FsbChlbmRhbGwsICgpID0+IHtcclxuXHRcdFx0dGFyZ2V0cy5zdHlsZShcIm9wYWNpdHlcIiwgbnVsbCkuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHkpO1xyXG5cdFx0fSk7XHJcblxyXG5cdG9wdGlvbnMud2l0aExlZ2VuZCAmJiAkJFtgJHtzaG93ID8gXCJzaG93XCIgOiBcImhpZGVcIn1MZWdlbmRgXSh0YXJnZXRJZHMpO1xyXG5cclxuXHQkJC5yZWRyYXcoe1xyXG5cdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdHdpdGhMZWdlbmQ6IHRydWVcclxuXHR9KTtcclxuXHJcblx0JCQuc3RhdGUudG9nZ2xpbmcgPSBmYWxzZTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNob3cgZGF0YSBzZXJpZXMgb24gY2hhcnRcclxuXHQgKiBAZnVuY3Rpb24gc2hvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWVdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgYm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBzaG93ICdkYXRhMSdcclxuXHQgKiBjaGFydC5zaG93KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBzaG93ICdkYXRhMScgYW5kICdkYXRhMydcclxuXHQgKiBjaGFydC5zaG93KFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdHNob3codGFyZ2V0SWRzVmFsdWU/OiBzdHJpbmdbXSB8IHN0cmluZywgb3B0aW9ucyA9IHt9KTogdm9pZCB7XHJcblx0XHRzaG93SGlkZS5jYWxsKHRoaXMsIHRydWUsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGRhdGEgc2VyaWVzIGZyb20gY2hhcnRcclxuXHQgKiBAZnVuY3Rpb24gaGlkZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWVdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgYm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBoaWRlICdkYXRhMSdcclxuXHQgKiBjaGFydC5oaWRlKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBoaWRlICdkYXRhMScgYW5kICdkYXRhMydcclxuXHQgKiBjaGFydC5oaWRlKFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdGhpZGUodGFyZ2V0SWRzVmFsdWU/OiBzdHJpbmdbXSwgb3B0aW9ucyA9IHt9KTogdm9pZCB7XHJcblx0XHRzaG93SGlkZS5jYWxsKHRoaXMsIGZhbHNlLCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlIGRhdGEgc2VyaWVzIG9uIGNoYXJ0LiBXaGVuIHRhcmdldCBkYXRhIGlzIGhpZGRlbiwgaXQgd2lsbCBzaG93LiBJZiBpcyBzaG93biwgaXQgd2lsbCBoaWRlIGluIHZpY2UgdmVyc2EuXHJcblx0ICogQGZ1bmN0aW9uIHRvZ2dsZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgd2l0aExlZ2VuZCB8IGJvb2xlYW4gfCBmYWxzZSB8IHdoZXRoZXIgb3Igbm90IGRpc3BsYXkgbGVnZW5kIHxcclxuXHQgKlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gdG9nZ2xlICdkYXRhMSdcclxuXHQgKiBjaGFydC50b2dnbGUoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIHRvZ2dsZSAnZGF0YTEnIGFuZCAnZGF0YTMnXHJcblx0ICogY2hhcnQudG9nZ2xlKFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdHRvZ2dsZSh0YXJnZXRJZHM6IHN0cmluZ3xzdHJpbmdbXSwgb3B0aW9ucyA9IHt9KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB0YXJnZXRzID0ge3Nob3c6IDxzdHJpbmdbXT4gW10sIGhpZGU6IDxzdHJpbmdbXT4gW119O1xyXG5cclxuXHRcdC8vIHNvcnQgc2hvdyAmIGhpZGUgdGFyZ2V0IGlkc1xyXG5cdFx0JCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKVxyXG5cdFx0XHQuZm9yRWFjaCgoaWQ6IHN0cmluZykgPT4gdGFyZ2V0c1skJC5pc1RhcmdldFRvU2hvdyhpZCkgPyBcImhpZGVcIiA6IFwic2hvd1wiXS5wdXNoKGlkKSk7XHJcblxyXG5cdFx0Ly8gcGVyZm9ybSBzaG93ICYgaGlkZSB0YXNrIHNlcGFyYXRlbHlcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ1NFxyXG5cdFx0dGFyZ2V0cy5zaG93Lmxlbmd0aCAmJiB0aGlzLnNob3codGFyZ2V0cy5zaG93LCBvcHRpb25zKTtcclxuXHRcdHRhcmdldHMuaGlkZS5sZW5ndGggJiYgc2V0VGltZW91dCgoKSA9PiB0aGlzLmhpZGUodGFyZ2V0cy5oaWRlLCBvcHRpb25zKSwgMCk7XHJcblx0fVxyXG59O1xyXG5cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogRGVmaW5lIHRvb2x0aXBcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY29uc3QgdG9vbHRpcCA9IHtcclxuXHQvKipcclxuXHQgKiBTaG93IHRvb2x0aXBcclxuXHQgKiBAZnVuY3Rpb24gdG9vbHRpcOKApHNob3dcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gYXJncyBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IGluZGV4IHwgTnVtYmVyIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IGluZGV4IHxcclxuXHQgKiAgICB8IHggfCBOdW1iZXIgJnZlcnQ7IERhdGUgfCBEZXRlcm1pbmUgZm9jdXMgYnkgeCBBeGlzIGluZGV4IHxcclxuXHQgKiAgICB8IG1vdXNlIHwgQXJyYXkgfCBEZXRlcm1pbmUgeCBhbmQgeSBjb29yZGluYXRlIHZhbHVlIHJlbGF0aXZlIHRoZSB0YXJnZXRlZCAnLmJiLWV2ZW50LXJlY3QnIHggQXhpcy48YnI+SXQgc2hvdWxkIGJlIHVzZWQgYWxvbmcgd2l0aCBgZGF0YWAsIGBpbmRleGAgb3IgYHhgIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBzZXQgYXMgYFswLDBdYCB8XHJcblx0ICogICAgfCBkYXRhIHwgT2JqZWN0IHwgV2hlbiBbZGF0YS54c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0eHMpIG9wdGlvbiBpcyB1c2VkIG9yIFt0b29sdGlwLmdyb3VwZWRdKE9wdGlvbnMuaHRtbCMudG9vbHRpcCkgc2V0IHRvICdmYWxzZScsIGBzaG91bGQgYmUgdXNlZCBnaXZpbmcgdGhpcyBwYXJhbWAuPGJyPjxicj4qKktleToqKjxicj4tIHgge251bWJlciAmdmVyYmFyOyBEYXRlfTogeCBBeGlzIHZhbHVlPGJyPi0gaW5kZXgge251bWJlcn06IHggQXhpcyBpbmRleCAodXNlbGVzcyBmb3IgZGF0YS54cyk8YnI+LSBpZCB7c3RyaW5nfTogZGF0YSBpZDxicj4tIHZhbHVlIHtudW1iZXJ9OiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmb3IgdG9vbHRpcC4gfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gc2hvdyB0aGUgMm5kIHggQXhpcyBjb29yZGluYXRlIHRvb2x0aXBcclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICBpbmRleDogMVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRoZSAzcmQgeCBBeGlzIGluIHg6NTAgYW5kIHk6MTAwIGNvb3JkaW5hdGUgb2YgJy5iYi1ldmVudC1yZWN0JyBvZiB0aGUgeCBBeGlzLlxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIHg6IDIsXHJcblx0ICogICAgbW91c2U6IFs1MCwgMTAwXVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRpbWVzZXJpZXMgeCBheGlzXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgeDogbmV3IERhdGUoXCIyMDE4LTAxLTAyIDAwOjAwXCIpXHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHdoZW4gZGF0YS54cyBpcyB1c2VkXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgZGF0YToge1xyXG5cdCAqICAgICAgICB4OiAzLCAgLy8geCBBeGlzIHZhbHVlXHJcblx0ICogICAgICAgIGlkOiBcImRhdGExXCIsICAvLyBkYXRhIGlkXHJcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcclxuXHQgKiAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHdoZW4gZGF0YS54cyBpc24ndCB1c2VkLCBidXQgdG9vbHRpcC5ncm91cGVkPWZhbHNlIGlzIHNldFxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIGRhdGE6IHtcclxuXHQgKiAgICAgICAgaW5kZXg6IDMsICAvLyBvciAneCcga2V5IHZhbHVlXHJcblx0ICogICAgICAgIGlkOiBcImRhdGExXCIsICAvLyBkYXRhIGlkXHJcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcclxuXHQgKiAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdHNob3c6IGZ1bmN0aW9uKGFyZ3MpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aW5wdXRUeXBlfX0gPSAkJDtcclxuXHRcdGxldCBpbmRleDtcclxuXHRcdGxldCBtb3VzZTtcclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgbW91c2UgcG9zaXRpb24gb24gdGhlIGNoYXJ0XHJcblx0XHRpZiAoYXJncy5tb3VzZSkge1xyXG5cdFx0XHRtb3VzZSA9IGFyZ3MubW91c2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGV0ZXJtaW5lIGZvY3VzIGRhdGFcclxuXHRcdGlmIChhcmdzLmRhdGEpIHtcclxuXHRcdFx0Y29uc3Qge2RhdGF9ID0gYXJncztcclxuXHRcdFx0Y29uc3QgeSA9ICQkLmdldFlTY2FsZUJ5SWQoZGF0YS5pZCkoZGF0YS52YWx1ZSk7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHRcdC8vIGlmIG11bHRpcGxlIHhzLCB0YXJnZXQgcG9pbnQgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IG1vdXNlXHJcblx0XHRcdFx0bW91c2UgPSBbJCQuc2NhbGUueChkYXRhLngpLCB5XTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoIWNvbmZpZy50b29sdGlwX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRcdG1vdXNlID0gWzAsIHldO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aW5kZXggPSBpc1ZhbHVlKGRhdGEuaW5kZXgpID8gZGF0YS5pbmRleCA6ICQkLmdldEluZGV4QnlYKGRhdGEueCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKGFyZ3MueCkpIHtcclxuXHRcdFx0aW5kZXggPSAkJC5nZXRJbmRleEJ5WChhcmdzLngpO1xyXG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy5pbmRleCkpIHtcclxuXHRcdFx0aW5kZXggPSBhcmdzLmluZGV4O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGVtdWxhdGUgZXZlbnRzIHRvIHNob3dcclxuXHRcdChpbnB1dFR5cGUgPT09IFwibW91c2VcIiA/XHJcblx0XHRcdFtcIm1vdXNlb3ZlclwiLCBcIm1vdXNlbW92ZVwiXSA6IFtcInRvdWNoc3RhcnRcIl1cclxuXHRcdCkuZm9yRWFjaChldmVudE5hbWUgPT4ge1xyXG5cdFx0XHQkJC5kaXNwYXRjaEV2ZW50KGV2ZW50TmFtZSwgaW5kZXgsIG1vdXNlKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgdG9vbHRpcFxyXG5cdCAqIEBmdW5jdGlvbiB0b29sdGlw4oCkaGlkZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqL1xyXG5cdGhpZGU6IGZ1bmN0aW9uKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdC8vIHJlc2V0IGxhc3QgdG91Y2ggcG9pbnQgaW5kZXhcclxuXHRcdCQkLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcclxuXHJcblx0XHQkJC5oaWRlVG9vbHRpcCh0cnVlKTtcclxuXHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cdFx0JCQudW5leHBhbmRCYXJzKCk7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3Rvb2x0aXB9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDaGFydEludGVybmFsIGZyb20gXCIuLi9DaGFydEludGVybmFsL0NoYXJ0SW50ZXJuYWxcIjtcclxuaW1wb3J0IHtsb2FkQ29uZmlnfSBmcm9tIFwiLi4vY29uZmlnL2NvbmZpZ1wiO1xyXG5pbXBvcnQge2V4dGVuZCwgaXNGdW5jdGlvbn0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5pbXBvcnQgYXBpQ2hhcnQgZnJvbSBcIi4vYXBpL2NoYXJ0XCI7XHJcbmltcG9ydCBhcGlDb2xvciBmcm9tIFwiLi9hcGkvY29sb3JcIjtcclxuaW1wb3J0IGFwaURhdGEgZnJvbSBcIi4vYXBpL2RhdGFcIjtcclxuaW1wb3J0IGFwaUV4cG9ydCBmcm9tIFwiLi9hcGkvZXhwb3J0XCI7XHJcbmltcG9ydCBhcGlGb2N1cyBmcm9tIFwiLi9hcGkvZm9jdXNcIjtcclxuaW1wb3J0IGFwaUxlZ2VuZCBmcm9tIFwiLi9hcGkvbGVnZW5kXCI7XHJcbmltcG9ydCBhcGlMb2FkIGZyb20gXCIuL2FwaS9sb2FkXCI7XHJcbmltcG9ydCBhcGlTaG93IGZyb20gXCIuL2FwaS9zaG93XCI7XHJcbmltcG9ydCBhcGlUb29sdGlwIGZyb20gXCIuL2FwaS90b29sdGlwXCI7XHJcblxyXG4vKipcclxuICogTWFpbiBjaGFydCBjbGFzcy5cclxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgdmlhIGBiYi5nZW5lcmF0ZSgpYC5cclxuICogQGNsYXNzIENoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuICogIGRhdGE6IHtcclxuICogICAgY29sdW1uczogW1xyXG4gKlx0ICAgIFtcInhcIiwgXCIyMDE1LTExLTAyXCIsIFwiMjAxNS0xMi0wMVwiLCBcIjIwMTYtMDEtMDFcIiwgXCIyMDE2LTAyLTAxXCIsIFwiMjAxNi0wMy0wMVwiXSxcclxuICogXHQgICAgW1wiY291bnQxXCIsIDExLCA4LCA3LCA2LCA1IF0sXHJcbiAqXHQgICAgW1wiY291bnQyXCIsIDksIDMsIDYsIDIsIDggXVxyXG4gKiAgIF19XHJcbiAqIH1cclxuICogQHNlZSB7QGxpbmsgYmIuZ2VuZXJhdGV9IGZvciB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAqL1xyXG4vKipcclxuICogQWNjZXNzIGluc3RhbmNlJ3MgcHJpbWFyeSBub2RlIGVsZW1lbnRzXHJcbiAqIEBtZW1iZXIge29iamVjdH0gJFxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gJCBBY2Nlc3MgaW5zdGFuY2UncyBwcmltYXJ5IG5vZGUgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuY2hhcnQgV3JhcHBlciBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnN2ZyBNYWluIHN2ZyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmRlZnMgRGVmaW5pdGlvbiBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLm1haW4gTWFpbiBncm91cGluZyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRvb2x0aXAgVG9vbHRpcCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxlZ2VuZCBMZWdlbmQgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50aXRsZSBUaXRsZSBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmdyaWQgR3JpZCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmFyYyBBcmMgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5jaXJjbGVzIERhdGEgcG9pbnQgY2lyY2xlIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAkLmJhciBCYXIgZWxlbWVudCBvYmplY3RcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuYmFyLmJhcnMgQmFyIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSAkLmxpbmUgTGluZSBlbGVtZW50IG9iamVjdFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmxpbmVzIExpbmUgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGluZS5hcmVhcyBBcmVhcyBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge29iamVjdH0gJC50ZXh0IFRleHQgZWxlbWVudCBvYmplY3RcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudGV4dC50ZXh0cyBEYXRhIGxhYmVsIHRleHQgZWxlbWVudHNcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xyXG4gKlxyXG4gKiBjaGFydC4kLmNoYXJ0OyAvLyB3cmFwcGVyIGVsZW1lbnRcclxuICogY2hhcnQuJC5saW5lLmNpcmNsZXM7ICAvLyBhbGwgZGF0YSBwb2ludCBjaXJjbGUgZWxlbWVudHNcclxuICovXHJcbi8qKlxyXG4gKiBQbHVnaW4gaW5zdGFuY2UgYXJyYXlcclxuICogQG1lbWJlciB7QXJyYXl9IHBsdWdpbnNcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XHJcbiAqICAgICAuLi5cclxuICogICAgIHBsdWdpbnM6IFtcclxuICogICAgICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXHJcbiAqICAgICAgICBuZXcgUGx1Z2luQSgpXHJcbiAqICAgICBdXHJcbiAqICB9KTtcclxuICpcclxuICogIGNoYXJ0LnBsdWdpbnM7IC8vIFtTdGFuZm9yZCwgUGx1Z2luQV0gLSBpbnN0YW5jZSBhcnJheVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnQge1xyXG5cdHB1YmxpYyBwbHVnaW5zID0gW107XHJcblx0cHVibGljIGludGVybmFsOiBDaGFydEludGVybmFsO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcblx0XHRjb25zdCBjdHggPSB0aGlzO1xyXG5cdFx0Ly8gY29uc3Qge3R5cGUsIHR5cGVzfSA9IG9wdGlvbnMuZGF0YTtcclxuXHRcdC8vIGxldCBpc0FyYyA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmICh0eXBlKSB7XHJcblx0XHQvLyBcdGlzQXJjID0gVFlQRVMuQXJjLmluZGV4T2YodHlwZSkgPiAtMTtcclxuXHRcdC8vIH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdC8vIFx0Zm9yIChjb25zdCB4IGluIHR5cGVzKSB7XHJcblx0XHQvLyBcdFx0aWYgKFRZUEVTLkFyYy5pbmRleE9mKHR5cGVzW3hdKSA+IC0xKSB7XHJcblx0XHQvLyBcdFx0XHRpc0FyYyA9IHRydWU7XHJcblx0XHQvLyBcdFx0XHRicmVhaztcclxuXHRcdC8vIFx0XHR9XHJcblx0XHQvLyBcdH1cclxuXHRcdC8vIH1cclxuXHJcblx0XHRjb25zdCAkJCA9IG5ldyBDaGFydEludGVybmFsKGN0eCk7XHJcblxyXG5cdFx0dGhpcy5pbnRlcm5hbCA9ICQkO1xyXG5cclxuXHRcdC8vIGJpbmQgdG8gbmFtZXNwYWNlZCBBUElzXHJcblx0XHQoZnVuY3Rpb24gYmluZFRoaXMoZm4sIHRhcmdldCwgYXJnVGhpcykge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhmbikuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGlzRnVuYyA9IGlzRnVuY3Rpb24oZm5ba2V5XSk7XHJcblx0XHRcdFx0Y29uc3QgaXNDaGlsZCA9IHRhcmdldCAhPT0gYXJnVGhpcztcclxuXHRcdFx0XHRjb25zdCBoYXNDaGlsZCA9IE9iamVjdC5rZXlzKGZuW2tleV0pLmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgKCghaXNDaGlsZCAmJiBoYXNDaGlsZCkgfHwgaXNDaGlsZCkpIHtcclxuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gZm5ba2V5XS5iaW5kKGFyZ1RoaXMpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIWlzRnVuYykge1xyXG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSB7fTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGhhc0NoaWxkICYmIGJpbmRUaGlzKGZuW2tleV0sIHRhcmdldFtrZXldLCBhcmdUaGlzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KShDaGFydC5wcm90b3R5cGUsIHRoaXMsIHRoaXMpO1xyXG5cclxuXHRcdGxvYWRDb25maWcuY2FsbCgkJCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0JCQuYmVmb3JlSW5pdCgpO1xyXG5cdFx0JCQuaW5pdCgpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gZXh0ZW5kIGNvbW1vbiBBUElzIGFzIHBhcnQgb2YgQ2hhcnQgY2xhc3NcclxuZXh0ZW5kKENoYXJ0LnByb3RvdHlwZSwgW1xyXG5cdGFwaUNoYXJ0LFxyXG5cdGFwaUNvbG9yLFxyXG5cdGFwaURhdGEsXHJcblx0YXBpRXhwb3J0LFxyXG5cdGFwaUZvY3VzLFxyXG5cdGFwaUxlZ2VuZCxcclxuXHRhcGlMb2FkLFxyXG5cdGFwaVNob3csXHJcblx0YXBpVG9vbHRpcFxyXG5dKTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgaXNPYmplY3RUeXBlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG1pbi9tYXggdmFsdWVcclxuICogQHBhcmFtIHtDaGFydH0gJCQgQ2hhcnQgaW5zdGFuY2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgU2V0IHR5cGUgJ21pbicgb3IgJ21heCdcclxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlIFZhbHVlIHRvIGJlIHNldFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0TWluTWF4KCQkLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIiwgdmFsdWUpOiB2b2lkIHtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdGNvbnN0IGF4aXNYID0gYGF4aXNfeF8ke3R5cGV9YDtcclxuXHRjb25zdCBheGlzWSA9IGBheGlzX3lfJHt0eXBlfWA7XHJcblx0Y29uc3QgYXhpc1kyID0gYGF4aXNfeTJfJHt0eXBlfWA7XHJcblxyXG5cdGlmIChpc0RlZmluZWQodmFsdWUpKSB7XHJcblx0XHRpZiAoaXNPYmplY3RUeXBlKHZhbHVlKSkge1xyXG5cdFx0XHRpc1ZhbHVlKHZhbHVlLngpICYmIChjb25maWdbYXhpc1hdID0gdmFsdWUueCk7XHJcblx0XHRcdGlzVmFsdWUodmFsdWUueSkgJiYgKGNvbmZpZ1theGlzWV0gPSB2YWx1ZS55KTtcclxuXHRcdFx0aXNWYWx1ZSh2YWx1ZS55MikgJiYgKGNvbmZpZ1theGlzWTJdID0gdmFsdWUueTIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uZmlnW2F4aXNZXSA9IHZhbHVlO1xyXG5cdFx0XHRjb25maWdbYXhpc1kyXSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtaW4vbWF4IHZhbHVlXHJcbiAqIEBwYXJhbSB7Q2hhcnR9ICQkIENoYXJ0IGluc3RhbmNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFNldCB0eXBlICdtaW4nIG9yICdtYXgnXHJcbiAqIEByZXR1cm5zIHt7eCwgeSwgeTJ9fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWluTWF4KCQkLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIik6IHt4OiBudW1iZXIsIHk6IG51bWJlciwgeTI6IG51bWJlcn0ge1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiBjb25maWdbYGF4aXNfeF8ke3R5cGV9YF0sXHJcblx0XHR5OiBjb25maWdbYGF4aXNfeV8ke3R5cGV9YF0sXHJcblx0XHR5MjogY29uZmlnW2BheGlzX3kyXyR7dHlwZX1gXVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYXhpc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jb25zdCBheGlzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbGFiZWxzLlxyXG5cdCAqIEBmdW5jdGlvbiBheGlz4oCkbGFiZWxzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGxhYmVscyBzcGVjaWZpZWQgYXhpcycgbGFiZWwgdG8gYmUgdXBkYXRlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMubGFiZWxzKHtcclxuXHQgKiAgIHg6IFwiTmV3IFggQXhpcyBMYWJlbFwiLFxyXG5cdCAqICAgeTogXCJOZXcgWSBBeGlzIExhYmVsXCJcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRsYWJlbHM6IGZ1bmN0aW9uKGxhYmVsczoge3g/OiBzdHJpbmcsIHk/OiBzdHJpbmcsIHkyPzogc3RyaW5nfSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGxhYmVscykuZm9yRWFjaChheGlzSWQgPT4ge1xyXG5cdFx0XHRcdCQkLmF4aXMuc2V0TGFiZWxUZXh0KGF4aXNJZCwgbGFiZWxzW2F4aXNJZF0pO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmF4aXMudXBkYXRlTGFiZWxzKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhpcyBtaW4gdmFsdWUuXHJcblx0ICogQGZ1bmN0aW9uIGF4aXPigKRtaW5cclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gbWluIElmIG1pbiBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1pbiB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuPGJyPlxyXG5cdCAqICAgICBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG1pbiB2YWx1ZXMgc2V0IG9uIGdlbmVyYXRpbmcgb3B0aW9uIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiAgICAgSWYgbm90IHNldCBhbnkgbWluIHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fHVuZGVmaW5lZH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBtaW5cclxuXHQgKiBjaGFydC5heGlzLm1pbih7XHJcblx0ICogICB4OiAtMTAsXHJcblx0ICogICB5OiAxMDAwLFxyXG5cdCAqICAgeTI6IDEwMFxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdG1pbjogZnVuY3Rpb24obWluPzogbnVtYmVyKTogb2JqZWN0fHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdHJldHVybiBpc1ZhbHVlKG1pbikgP1xyXG5cdFx0XHRzZXRNaW5NYXgoJCQsIFwibWluXCIsIG1pbikgOlxyXG5cdFx0XHRnZXRNaW5NYXgoJCQsIFwibWluXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWF4IHZhbHVlLlxyXG5cdCAqIEBmdW5jdGlvbiBheGlz4oCkbWF4XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IG1heCBJZiBtYXggaXMgZ2l2ZW4sIHNwZWNpZmllZCBheGlzJyBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLjxicj5cclxuXHQgKiAgICAgSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBtYXggdmFsdWVzIHNldCBvbiBnZW5lcmF0aW5nIG9wdGlvbiBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogICAgIElmIG5vdCBzZXQgYW55IG1heCB2YWx1ZXMgb24gZ2VuZXJhdGlvbiwgaXQgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXHJcblx0ICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcclxuXHQgKiBjaGFydC5heGlzLm1heCh7XHJcblx0ICogICAgeDogMTAwLFxyXG5cdCAqICAgIHk6IDEwMDAsXHJcblx0ICogICAgeTI6IDEwMDAwXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bWF4OiBmdW5jdGlvbihtYXg/OiBudW1iZXIpOiBvYmplY3R8dm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xyXG5cdFx0XHRzZXRNaW5NYXgoJCQsIFwibWF4XCIsIG1heCkgOlxyXG5cdFx0XHRnZXRNaW5NYXgoJCQsIFwibWF4XCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWluIGFuZCBtYXggdmFsdWUuXHJcblx0ICogQGZ1bmN0aW9uIGF4aXPigKRyYW5nZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSByYW5nZSBJZiByYW5nZSBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1pbiBhbmQgbWF4IHZhbHVlIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IG1pbiBhbmQgbWF4IHZhbHVlcyBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybnMge29iamVjdHx1bmRlZmluZWR9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcclxuXHQgKiBjaGFydC5heGlzLnJhbmdlKHtcclxuXHQgKiAgIG1pbjoge1xyXG5cdCAqICAgICB4OiAtMTAsXHJcblx0ICogICAgIHk6IC0xMDAwLFxyXG5cdCAqICAgICB5MjogLTEwMDAwXHJcblx0ICogICB9LFxyXG5cdCAqICAgbWF4OiB7XHJcblx0ICogICAgIHg6IDEwMCxcclxuXHQgKiAgICAgeTogMTAwMCxcclxuXHQgKiAgICAgeTI6IDEwMDAwXHJcblx0ICogICB9LFxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdHJhbmdlOiBmdW5jdGlvbihyYW5nZSk6IG9iamVjdHx2b2lkIHtcclxuXHRcdGNvbnN0IHtheGlzfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0aXNEZWZpbmVkKHJhbmdlLm1heCkgJiYgYXhpcy5tYXgocmFuZ2UubWF4KTtcclxuXHRcdFx0aXNEZWZpbmVkKHJhbmdlLm1pbikgJiYgYXhpcy5taW4ocmFuZ2UubWluKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0bWF4OiBheGlzLm1heCgpLFxyXG5cdFx0XHRcdG1pbjogYXhpcy5taW4oKVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2F4aXN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgc3BlY2lmaWVkIGNhdGVnb3J5IG5hbWUgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBAZnVuY3Rpb24gY2F0ZWdvcnlcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBpbmRleCBvZiBjYXRlZ29yeSB0byBiZSBjaGFuZ2VkXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5IGNhdGVnb3J5IHZhbHVlIHRvIGJlIGNoYW5nZWRcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY2F0ZWdvcnkoMiwgXCJDYXRlZ29yeSAzXCIpO1xyXG5cdCAqL1xyXG5cdGNhdGVnb3J5KGk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV0gPSBjYXRlZ29yeTtcclxuXHRcdFx0JCQucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2F0ZWdvcnkgbmFtZXMgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBAZnVuY3Rpb24gY2F0ZWdvcmllc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNhdGVnb3JpZXMgVGhpcyBtdXN0IGJlIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgY2F0ZWdvcnkgbmFtZXMgaW4gc3RyaW5nLiBJZiBjYXRlZ29yeSBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGRhdGUgYnkgZGF0YS54IG9wdGlvbiwgdGhpcyBpcyBub3QgcmVxdWlyZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY2F0ZWdvcmllcyhbXHJcblx0ICogICAgICBcIkNhdGVnb3J5IDFcIiwgXCJDYXRlZ29yeSAyXCIsIC4uLlxyXG5cdCAqIF0pO1xyXG5cdCAqL1xyXG5cdGNhdGVnb3JpZXMoY2F0ZWdvcmllczogc3RyaW5nW10pOiBzdHJpbmdbXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XHJcblx0XHQkJC5yZWRyYXcoKTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzRGVmaW5lZCwgaXNUYWJWaXNpYmxlLCBpc1ZhbHVlLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEZsb3cgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBhcHBlbmQgbmV3IGRhdGEgcG9pbnRzIHRvIHRoZSBjaGFydC5cclxuXHQgKiBAZnVuY3Rpb24gZmxvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwganNvbiB8IE9iamVjdCB8IERhdGEgYXMgSlNPTiBmb3JtYXQgKEBzZWUgW2RhdGHigKRqc29uXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxyXG5cdCAqICAgIHwgcm93cyB8IEFycmF5IHwgRGF0YSBpbiBhcnJheSBhcyByb3cgZm9ybWF0IChAc2VlIFtkYXRh4oCkcm93c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0anNvbikpIHxcclxuXHQgKiAgICB8IGNvbHVtbnMgfCBBcnJheSB8IERhdGEgaW4gYXJyYXkgYXMgY29sdW1uIGZvcm1hdCAoQHNlZSBbZGF0YeKApGNvbHVtbnNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGNvbHVtbnMpKSB8XHJcblx0ICogICAgfCB0byB8IFN0cmluZyB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIHRvIHRoYXQgcG9pbnQuIElmIG5vdCBnaXZlbiwgdGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgYnkgdGhlIG51bWJlciBvZiBnaXZlbiBkYXRhIHBvaW50cyB8XHJcblx0ICogICAgfCBsZW5ndGggfCBOdW1iZXIgfCBUaGUgbG93ZXIgeCBlZGdlIHdpbGwgbW92ZSBieSB0aGUgbnVtYmVyIG9mIHRoaXMgYXJndW1lbnQgfFxyXG5cdCAqICAgIHwgZHVyYXRpb24gfCBOdW1iZXIgfCBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBzcGVjaWZpZWQgdmFsdWUuIElmIG5vdCBnaXZlbiwgdHJhbnNpdGlvbi5kdXJhdGlvbiB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB8XHJcblx0ICogICAgfCBkb25lIHwgRnVuY3Rpb24gfCBUaGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gZmxvdyBlbmRzIHxcclxuXHQgKlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIElmIGpzb24sIHJvd3MgYW5kIGNvbHVtbnMgZ2l2ZW4sIHRoZSBkYXRhIHdpbGwgYmUgbG9hZGVkLlxyXG5cdCAqICAgLSBJZiBkYXRhIHRoYXQgaGFzIHRoZSBzYW1lIHRhcmdldCBpZCBpcyBnaXZlbiwgdGhlIGNoYXJ0IHdpbGwgYmUgYXBwZW5kZWQuXHJcblx0ICogICAtIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkLiBPbmUgb2YgdGhlc2UgaXMgcmVxdWlyZWQgd2hlbiBjYWxsaW5nLlxyXG5cdCAqICAgLSBJZiBqc29uIHNwZWNpZmllZCwga2V5cyBpcyByZXF1aXJlZCBhcyB3ZWxsIGFzIGRhdGEuanNvbi5cclxuXHQgKiBcdCAtIElmIHRhYiBpc24ndCB2aXNpYmxlKGJ5IGV2YWx1YXRpbmcgYGRvY3VtZW50LmhpZGRlbmApLCB3aWxsIG5vdCBiZSBleGVjdXRlZCB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHdvcmsuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyAyIGRhdGEgcG9pbnRzIHdpbGwgYmUgYXBwcmVuZGVkIHRvIHRoZSB0YWlsIGFuZCBwb3BwZWQgZnJvbSB0aGUgaGVhZC5cclxuXHQgKiAvLyBBZnRlciB0aGF0LCA0IGRhdGEgcG9pbnRzIHdpbGwgYmUgYXBwZW5kZWQgYW5kIG5vIGRhdGEgcG9pbnRzIHdpbGwgYmUgcG9wcG9lZC5cclxuXHQgKiBjaGFydC5mbG93KHtcclxuXHQgKiAgY29sdW1uczogW1xyXG5cdCAqICAgIFtcInhcIiwgXCIyMDE4LTAxLTExXCIsIFwiMjAxOC0wMS0yMVwiXSxcclxuXHQgKiAgICBbXCJkYXRhMVwiLCA1MDAsIDIwMF0sXHJcblx0ICogICAgW1wiZGF0YTJcIiwgMTAwLCAzMDBdLFxyXG5cdCAqICAgIFtcImRhdGEzXCIsIDIwMCwgMTIwXVxyXG5cdCAqICBdLFxyXG5cdCAqICB0bzogXCIyMDEzLTAxLTExXCIsXHJcblx0ICogIGRvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHQgKiAgICBjaGFydC5mbG93KHtcclxuXHQgKiAgICAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgICAgW1wieFwiLCBcIjIwMTgtMDItMTFcIiwgXCIyMDE4LTAyLTEyXCIsIFwiMjAxOC0wMi0xM1wiLCBcIjIwMTgtMDItMTRcIl0sXHJcblx0ICogICAgICAgIFtcImRhdGExXCIsIDIwMCwgMzAwLCAxMDAsIDI1MF0sXHJcblx0ICogICAgICAgIFtcImRhdGEyXCIsIDEwMCwgOTAsIDQwLCAxMjBdLFxyXG5cdCAqICAgICAgICBbXCJkYXRhM1wiLCAxMDAsIDEwMCwgMzAwLCA1MDBdXHJcblx0ICogICAgICBdLFxyXG5cdCAqICAgICAgbGVuZ3RoOiAyLFxyXG5cdCAqICAgICAgZHVyYXRpb246IDE1MDBcclxuXHQgKiAgICB9KTtcclxuXHQgKiAgfVxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGZsb3coYXJncyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0bGV0IGRhdGE7XHJcblx0XHRsZXQgZG9tYWluO1xyXG5cdFx0bGV0IGxlbmd0aDogbnVtYmVyID0gMDtcclxuXHRcdGxldCB0YWlsID0gMDtcclxuXHRcdGxldCBkaWZmO1xyXG5cdFx0bGV0IHRvO1xyXG5cclxuXHRcdGlmIChhcmdzLmpzb24gfHwgYXJncy5yb3dzIHx8IGFyZ3MuY29sdW1ucykge1xyXG5cdFx0XHRkYXRhID0gJCQuY29udmVydERhdGEoYXJncyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFkYXRhIHx8ICFpc1RhYlZpc2libGUoKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgbm90Zm91bmRJZHM6IHN0cmluZ1tdID0gW107XHJcblx0XHRjb25zdCBvcmdEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5jb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhLCB0cnVlKTtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlL0FkZCBkYXRhXHJcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xyXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXSkge1xyXG5cdFx0XHRcdFx0XHR0YWlsID0gdC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0uaW5kZXggKyAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxlbmd0aCA9IHRhcmdldHNbaV0udmFsdWVzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHRhcmdldHNbaV0udmFsdWVzW2pdLmluZGV4ID0gdGFpbCArIGo7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIWlzVGltZVNlcmllcykge1xyXG5cdFx0XHRcdFx0XHRcdHRhcmdldHNbaV0udmFsdWVzW2pdLnggPSB0YWlsICsgajtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHQudmFsdWVzID0gdC52YWx1ZXMuY29uY2F0KHRhcmdldHNbaV0udmFsdWVzKTtcclxuXHRcdFx0XHRcdHRhcmdldHMuc3BsaWNlKGksIDEpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQhZm91bmQgJiYgbm90Zm91bmRJZHMucHVzaCh0LmlkKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEFwcGVuZCBudWxsIGZvciBub3QgZm91bmQgdGFyZ2V0c1xyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbm90Zm91bmRJZHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodC5pZCA9PT0gbm90Zm91bmRJZHNbaV0pIHtcclxuXHRcdFx0XHRcdHRhaWwgPSB0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXS5pbmRleCArIDE7XHJcblxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaiA9IDA7IGogPCBsZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdFx0XHR0LnZhbHVlcy5wdXNoKHtcclxuXHRcdFx0XHRcdFx0XHRpZDogdC5pZCxcclxuXHRcdFx0XHRcdFx0XHRpbmRleDogdGFpbCArIGosXHJcblx0XHRcdFx0XHRcdFx0eDogaXNUaW1lU2VyaWVzID8gJCQuZ2V0T3RoZXJUYXJnZXRYKHRhaWwgKyBqKSA6IHRhaWwgKyBqLFxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlOiBudWxsXHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgbnVsbCB2YWx1ZXMgZm9yIG5ldyB0YXJnZXRcclxuXHRcdGlmICgkJC5kYXRhLnRhcmdldHMubGVuZ3RoKSB7XHJcblx0XHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0XHRjb25zdCBtaXNzaW5nOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBpID0gJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlc1swXS5pbmRleDsgaSA8IHRhaWw7IGkrKykge1xyXG5cdFx0XHRcdFx0bWlzc2luZy5wdXNoKHtcclxuXHRcdFx0XHRcdFx0aWQ6IHQuaWQsXHJcblx0XHRcdFx0XHRcdGluZGV4OiBpLFxyXG5cdFx0XHRcdFx0XHR4OiBpc1RpbWVTZXJpZXMgPyAkJC5nZXRPdGhlclRhcmdldFgoaSkgOiBpLFxyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0di5pbmRleCArPSB0YWlsO1xyXG5cclxuXHRcdFx0XHRcdGlmICghaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0XHRcdHYueCArPSB0YWlsO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0LnZhbHVlcyA9IG1pc3NpbmcuY29uY2F0KHQudmFsdWVzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmNvbmNhdCh0YXJnZXRzKTsgLy8gYWRkIHJlbWFpbmVkXHJcblxyXG5cdFx0Ly8gY2hlY2sgZGF0YSBjb3VudCBiZWNhdXNlIGJlaGF2aW9yIG5lZWRzIHRvIGNoYW5nZSB3aGVuIGl0XCJzIG9ubHkgb25lXHJcblx0XHQvLyBjb25zdCBkYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IGJhc2VUYXJnZXQgPSAkJC5kYXRhLnRhcmdldHNbMF07XHJcblx0XHRjb25zdCBiYXNlVmFsdWUgPSBiYXNlVGFyZ2V0LnZhbHVlc1swXTtcclxuXHJcblx0XHQvLyBVcGRhdGUgbGVuZ3RoIHRvIGZsb3cgaWYgbmVlZGVkXHJcblx0XHRpZiAoaXNEZWZpbmVkKGFyZ3MudG8pKSB7XHJcblx0XHRcdGxlbmd0aCA9IDA7XHJcblx0XHRcdHRvID0gaXNUaW1lU2VyaWVzID8gcGFyc2VEYXRlLmNhbGwoJCQsIGFyZ3MudG8pIDogYXJncy50bztcclxuXHJcblx0XHRcdGJhc2VUYXJnZXQudmFsdWVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0di54IDwgdG8gJiYgbGVuZ3RoKys7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy5sZW5ndGgpKSB7XHJcblx0XHRcdGxlbmd0aCA9IGFyZ3MubGVuZ3RoO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIElmIG9ubHkgb25lIGRhdGEsIHVwZGF0ZSB0aGUgZG9tYWluIHRvIGZsb3cgZnJvbSBsZWZ0IGVkZ2Ugb2YgdGhlIGNoYXJ0XHJcblx0XHRpZiAoIW9yZ0RhdGFDb3VudCkge1xyXG5cdFx0XHRpZiAoaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0ZGlmZiA9IGJhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCA+IDEgP1xyXG5cdFx0XHRcdFx0YmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54IDpcclxuXHRcdFx0XHRcdGJhc2VWYWx1ZS54IC0gJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpWzBdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRpZmYgPSAxO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkb21haW4gPSBbYmFzZVZhbHVlLnggLSBkaWZmLCBiYXNlVmFsdWUueF07XHJcblx0XHR9IGVsc2UgaWYgKG9yZ0RhdGFDb3VudCA9PT0gMSAmJiBpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0ZGlmZiA9IChiYXNlVGFyZ2V0LnZhbHVlc1tiYXNlVGFyZ2V0LnZhbHVlcy5sZW5ndGggLSAxXS54IC0gYmFzZVZhbHVlLngpIC8gMjtcclxuXHRcdFx0ZG9tYWluID0gW25ldyBEYXRlKCtiYXNlVmFsdWUueCAtIGRpZmYpLCBuZXcgRGF0ZSgrYmFzZVZhbHVlLnggKyBkaWZmKV07XHJcblx0XHR9XHJcblxyXG5cdFx0ZG9tYWluICYmICQkLnVwZGF0ZVhEb21haW4obnVsbCwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGRvbWFpbik7XHJcblxyXG5cdFx0Ly8gU2V0IHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZVRhcmdldHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHQvLyBSZWRyYXcgd2l0aCBuZXcgdGFyZ2V0c1xyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0Zmxvdzoge1xyXG5cdFx0XHRcdGluZGV4OiBiYXNlVmFsdWUuaW5kZXgsXHJcblx0XHRcdFx0bGVuZ3RoOiBsZW5ndGgsXHJcblx0XHRcdFx0ZHVyYXRpb246IGlzVmFsdWUoYXJncy5kdXJhdGlvbikgPyBhcmdzLmR1cmF0aW9uIDogJCQuY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24sXHJcblx0XHRcdFx0ZG9uZTogYXJncy5kb25lLFxyXG5cdFx0XHRcdG9yZ0RhdGFDb3VudDogb3JnRGF0YUNvdW50LFxyXG5cdFx0XHR9LFxyXG5cdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogb3JnRGF0YUNvdW50ID4gMSxcclxuXHRcdFx0d2l0aFRyaW1YRG9tYWluOiBmYWxzZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhBeGlzOiB0cnVlXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxudHlwZSBncmlkc1BhcmFtID0ge3ZhbHVlPzogbnVtYmVyLCBjbGFzcz86IHN0cmluZywgdGV4dD86IHN0cmluZ31bXTtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgeCBncmlkIGxpbmVzLlxyXG4gKiBAZnVuY3Rpb24geGdyaWRzXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtBcnJheX0gZ3JpZHMgWCBncmlkIGxpbmVzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC54LmxpbmVzLlxyXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgLy8gU2hvdyAyIHggZ3JpZCBsaW5lc1xyXG4gKiBjaGFydC54Z3JpZHMoW1xyXG4gKiAgICB7dmFsdWU6IDEsIHRleHQ6IFwiTGFiZWwgMVwifSxcclxuICogICAge3ZhbHVlOiA0LCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuICogXSk7XHJcbiAqIC8vIC0tPiBSZXR1cm5zOiBbe3ZhbHVlOiAxLCB0ZXh0OiBcIkxhYmVsIDFcIn0sIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XVxyXG4gKi9cclxuZnVuY3Rpb24geGdyaWRzKGdyaWRzOiBncmlkc1BhcmFtKTogZ3JpZHNQYXJhbSB7XHJcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdGlmICghZ3JpZHMpIHtcclxuXHRcdHJldHVybiBjb25maWcuZ3JpZF94X2xpbmVzO1xyXG5cdH1cclxuXHJcblx0Y29uZmlnLmdyaWRfeF9saW5lcyA9IGdyaWRzO1xyXG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XHJcblxyXG5cdHJldHVybiBjb25maWcuZ3JpZF94X2xpbmVzO1xyXG59XHJcblxyXG5leHRlbmQoeGdyaWRzLCB7XHJcblx0LyoqXHJcblx0ICogQWRkIHggZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgeCBncmlkIGxpbmVzIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgeGdyaWRzLlxyXG5cdCAqIEBmdW5jdGlvbiB4Z3JpZHPigKRhZGRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fG9iamVjdH0gZ3JpZHMgTmV3IHggZ3JpZCBsaW5lcyB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC54LmxpbmVzIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIGxpbmUgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEFkZCBhIG5ldyB4IGdyaWQgbGluZVxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoXHJcblx0ICogICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqICk7XHJcblx0ICpcclxuXHQgKiAvLyBBZGQgbmV3IHggZ3JpZCBsaW5lc1xyXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoW1xyXG5cdCAqICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXHJcblx0ICogICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqIF0pO1xyXG5cdCAqL1xyXG5cdGFkZDogZnVuY3Rpb24oZ3JpZHM6IGdyaWRzUGFyYW0pOiBncmlkc1BhcmFtIHtcclxuXHRcdHJldHVybiB0aGlzLnhncmlkcyhcclxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF94X2xpbmVzXHJcblx0XHRcdFx0LmNvbmNhdChncmlkcyB8fCBbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHggZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyB4IGdyaWQgbGluZXMuXHJcblx0ICogQGZ1bmN0aW9uIHhncmlkc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB4IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeCBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHggZ3JpZCBsaW5lIG9uIHggPSAyIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe3ZhbHVlOiAyfSk7XHJcblx0ICpcclxuXHQgKiAvLyB4IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe1xyXG5cdCAqICAgY2xhc3M6IFwiZ3JpZC1BXCJcclxuXHQgKiB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCBvZiB4IGdyaWQgbGluZXMgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueGdyaWRzLnJlbW92ZSgpO1xyXG5cdCAqL1xyXG5cdHJlbW92ZTogZnVuY3Rpb24ocGFyYW1zPzogZ3JpZHNQYXJhbSk6IHZvaWQgeyAvLyBUT0RPOiBtdWx0aXBsZVxyXG5cdFx0dGhpcy5pbnRlcm5hbC5yZW1vdmVHcmlkTGluZXMocGFyYW1zLCB0cnVlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3hncmlkc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB5IGdyaWQgbGluZXMuXHJcbiAqIEBmdW5jdGlvbiB5Z3JpZHNcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge0FycmF5fSBncmlkcyBZIGdyaWQgbGluZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoaXMgYXJndW1lbnQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLnkubGluZXMuXHJcbiAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAqIEBleGFtcGxlXHJcbiAqICAvLyBTaG93IDIgeSBncmlkIGxpbmVzXHJcbiAqIGNoYXJ0LnlncmlkcyhbXHJcbiAqICAgIHt2YWx1ZTogMTAwLCB0ZXh0OiBcIkxhYmVsIDFcIn0sXHJcbiAqICAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuICogXSk7XHJcbiAqIC8vIC0tPiBSZXR1cm5zOiBbe3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgMVwifSwge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifV1cclxuICovXHJcbmZ1bmN0aW9uIHlncmlkcyhncmlkczoge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdKToge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0aWYgKCFncmlkcykge1xyXG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XHJcblx0fVxyXG5cclxuXHRjb25maWcuZ3JpZF95X2xpbmVzID0gZ3JpZHM7XHJcblx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcclxuXHJcblx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XHJcbn1cclxuXHJcbmV4dGVuZCh5Z3JpZHMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgeSBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSBhZGRzIG5ldyB5IGdyaWQgbGluZXMgaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSB5Z3JpZHMuXHJcblx0ICogQGZ1bmN0aW9uIHlncmlkc+KApGFkZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl8b2JqZWN0fSBncmlkcyBOZXcgeSBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLnkubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXHJcblx0ICogY2hhcnQueWdyaWRzLmFkZChcclxuXHQgKiAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuXHQgKiApO1xyXG5cdCAqXHJcblx0ICogLy8gQWRkIG5ldyB4IGdyaWQgbGluZXNcclxuXHQgKiBjaGFydC55Z3JpZHMuYWRkKFtcclxuXHQgKiAgIHt2YWx1ZTogMjAwLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXHJcblx0ICogICB7dmFsdWU6IDQwMCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcblx0ICogXSk7XHJcblx0ICovXHJcblx0YWRkOiBmdW5jdGlvbihncmlkczoge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdKToge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdIHtcclxuXHRcdHJldHVybiB0aGlzLnlncmlkcyhcclxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF95X2xpbmVzXHJcblx0XHRcdFx0LmNvbmNhdChncmlkcyB8fCBbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHkgZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyB4IGdyaWQgbGluZXMuXHJcblx0ICogQGZ1bmN0aW9uIHlncmlkc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB5IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB5IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHkgZ3JpZCBsaW5lIG9uIHkgPSAyMDAgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSh7dmFsdWU6IDIwMH0pO1xyXG5cdCAqXHJcblx0ICogLy8geSBncmlkIGxpbmVzIHRoYXQgaGF2ZSAnZ3JpZC1BJyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC55Z3JpZHMucmVtb3ZlKHtcclxuXHQgKiAgIGNsYXNzOiBcImdyaWQtQVwiXHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgb2YgeSBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnlncmlkcy5yZW1vdmUoKTtcclxuXHQgKi9cclxuXHRyZW1vdmU6IGZ1bmN0aW9uKHBhcmFtcz86IHt2YWx1ZT86IG51bWJlciwgY2xhc3M/OiBzdHJpbmd9KTogdm9pZCB7IC8vIFRPRE86IG11bHRpcGxlXHJcblx0XHR0aGlzLmludGVybmFsLnJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIGZhbHNlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3lncmlkc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1VuZGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGdyb3VwcyBmb3IgdGhlIHRhcmdldHMuXHJcblx0ICogQGZ1bmN0aW9uIGdyb3Vwc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGdyb3VwcyBUaGlzIGFyZ3VtZW50IG5lZWRzIHRvIGJlIGFuIEFycmF5IHRoYXQgaW5jbHVkZXMgb25lIG9yIG1vcmUgQXJyYXkgdGhhdCBpbmNsdWRlcyB0YXJnZXQgaWRzIHRvIGJlIGdyb3VwZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBHcm91cGVkIGRhdGEgbmFtZXMgYXJyYXlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBhIG5ldyBncm91cC5cclxuXHQgKiAgY2hhcnQuZ3JvdXBzKFtcclxuXHQgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXVxyXG5cdCAqICBdKTtcclxuXHQgKi9cclxuXHRncm91cHMoZ3JvdXBzOiBzdHJpbmdbXVtdKTogc3RyaW5nW11bXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmIChpc1VuZGVmaW5lZChncm91cHMpKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLmRhdGFfZ3JvdXBzID0gZ3JvdXBzO1xyXG5cdFx0JCQucmVkcmF3KCk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX2dyb3VwcztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldE9wdGlvbiwgZXh0ZW5kfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbnR5cGUgcmVnaW9uc1BhcmFtID0ge2F4aXM/OiBzdHJpbmcsIGNsYXNzPzogc3RyaW5nLCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyfVtdO1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSByZWdpb25zLlxyXG4gKiBAZnVuY3Rpb24gcmVnaW9uc1xyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJlZ2lvbnMgUmVnaW9ucyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIHJlZ2lvbnMuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gcmVnaW9uc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBTaG93IDIgcmVnaW9uc1xyXG4gKiBjaGFydC5yZWdpb25zKFtcclxuICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifSxcclxuICogICAge2F4aXM6IFwieVwiLCBlbmQ6IDUwLCBjbGFzczogXCJyZWdpb25ZXCJ9XHJcbiAqIF0pO1xyXG4gKi9cclxuZnVuY3Rpb24gcmVnaW9ucyhyZWdpb25zOiByZWdpb25zUGFyYW0pOiByZWdpb25zUGFyYW0ge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRpZiAoIXJlZ2lvbnMpIHtcclxuXHRcdHJldHVybiBjb25maWcucmVnaW9ucztcclxuXHR9XHJcblxyXG5cdGNvbmZpZy5yZWdpb25zID0gcmVnaW9ucztcclxuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRyZXR1cm4gcmVnaW9ucztcclxufVxyXG5cclxuZXh0ZW5kKHJlZ2lvbnMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgbmV3IHJlZ2lvbi48YnI+PGJyPlxyXG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHJlZ2lvbiBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHJlZ2lvbnMuXHJcblx0ICogQGZ1bmN0aW9uIHJlZ2lvbnPigKRhZGRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fG9iamVjdH0gcmVnaW9ucyBOZXcgcmVnaW9uIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyByZWdpb25zIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIHJlZ2lvbiB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gcmVnaW9uc1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gQWRkIGEgbmV3IHJlZ2lvblxyXG5cdCAqIGNoYXJ0LnJlZ2lvbnMuYWRkKFxyXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn1cclxuXHQgKiApO1xyXG5cdCAqXHJcblx0ICogLy8gQWRkIG5ldyByZWdpb25zXHJcblx0ICogY2hhcnQucmVnaW9ucy5hZGQoW1xyXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXHJcblx0ICogICAge2F4aXM6IFwieVwiLCBlbmQ6IDUwLCBjbGFzczogXCJyZWdpb25ZXCJ9XHJcblx0ICpdKTtcclxuXHQgKi9cclxuXHRhZGQ6IGZ1bmN0aW9uKHJlZ2lvbnM6IHJlZ2lvbnNQYXJhbSk6IHJlZ2lvbnNQYXJhbSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICghcmVnaW9ucykge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnJlZ2lvbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnJlZ2lvbnMgPSBjb25maWcucmVnaW9ucy5jb25jYXQocmVnaW9ucyk7XHJcblx0XHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcucmVnaW9ucztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgcmVnaW9ucy48YnI+PGJyPlxyXG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgcmVnaW9ucy5cclxuXHQgKiBAZnVuY3Rpb24gcmVnaW9uc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zVmFsdWUgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSBjbGFzc2VzLiBJZiBjbGFzc2VzIGlzIGdpdmVuLCB0aGUgcmVnaW9ucyB0aGF0IGhhdmUgb25lIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSByZWdpb25zIFJlbW92ZWQgcmVnaW9uc1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gcmVnaW9ucyB0aGF0IGhhdmUgJ3JlZ2lvbi1BJyBvciAncmVnaW9uLUInIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSh7XHJcblx0ICogICBjbGFzc2VzOiBbXHJcblx0ICogICAgIFwicmVnaW9uLUFcIiwgXCJyZWdpb24tQlwiXHJcblx0ICogICBdXHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogY2hhcnQucmVnaW9ucy5yZW1vdmUoKTtcclxuXHQgKi9cclxuXHRyZW1vdmU6IGZ1bmN0aW9uKG9wdGlvbnNWYWx1ZTogcmVnaW9uc1BhcmFtKTogcmVnaW9uc1BhcmFtIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNWYWx1ZSB8fCB7fTtcclxuXHRcdGNvbnN0IGR1cmF0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiZHVyYXRpb25cIiwgY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pO1xyXG5cdFx0Y29uc3QgY2xhc3NlcyA9IGdldE9wdGlvbihvcHRpb25zLCBcImNsYXNzZXNcIiwgW0NMQVNTLnJlZ2lvbl0pO1xyXG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnJlZ2lvbnN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChjbGFzc2VzLm1hcChjID0+IGAuJHtjfWApKTtcclxuXHJcblx0XHQoZHVyYXRpb24gPyByZWdpb25zLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikgOiByZWdpb25zKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0cmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zO1xyXG5cclxuXHRcdGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGgpIHtcclxuXHRcdFx0cmVnaW9ucyA9IHJlZ2lvbnMuZmlsdGVyKHJlZ2lvbiA9PiB7XHJcblx0XHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmICghcmVnaW9uLmNsYXNzKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJlZ2lvbi5jbGFzcy5zcGxpdChcIiBcIikuZm9yRWFjaChjID0+IHtcclxuXHRcdFx0XHRcdGlmIChjbGFzc2VzLmluZGV4T2YoYykgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiAhZm91bmQ7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSByZWdpb25zO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSBbXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVnaW9ucztcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3JlZ2lvbnN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge0RhdGFJdGVtfSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBHZXQgc2VsZWN0ZWQgZGF0YSBwb2ludHMuPGJyPjxicj5cclxuXHQgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBnZXQgc2VsZWN0ZWQgZGF0YSBwb2ludHMgaW5mb3JtYXRpb24uIFRvIHVzZSB0aGlzIEFQSSwgZGF0YS5zZWxlY3Rpb24uZW5hYmxlZCBuZWVkcyB0byBiZSBzZXQgdHJ1ZS5cclxuXHQgKiBAZnVuY3Rpb24gc2VsZWN0ZWRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldElkXSBZb3UgY2FuIGZpbHRlciB0aGUgcmVzdWx0IGJ5IGdpdmluZyB0YXJnZXQgaWQgdGhhdCB5b3Ugd2FudCB0byBnZXQuIElmIG5vdCBnaXZlbiwgYWxsIG9mIGRhdGEgcG9pbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybnMge0FycmF5fSBkYXRhUG9pbnQgQXJyYXkgb2YgdGhlIGRhdGEgcG9pbnRzLjxicj5leC4pIGBbe3g6IDEsIHZhbHVlOiAyMDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAxLCBuYW1lOiBcImRhdGExXCJ9LCAuLi5dYFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICBjaGFydC5zZWxlY3RlZCgpO1xyXG5cdCAqICAvLyAtLT4gZXguKSBbe3g6IDEsIHZhbHVlOiAyMDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAxLCBuYW1lOiBcImRhdGExXCJ9LCAuLi4gXVxyXG5cdCAqXHJcblx0ICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyBvZiBkYXRhMSB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICBjaGFydC5zZWxlY3RlZChcImRhdGExXCIpO1xyXG5cdCAqL1xyXG5cdHNlbGVjdGVkKHRhcmdldElkPzogc3RyaW5nKTogRGF0YUl0ZW1bXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCBkYXRhUG9pbnQ6IERhdGFJdGVtW10gPSBbXTtcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlcyArICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKX1gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmVhY2goZCA9PiBkYXRhUG9pbnQucHVzaChkKSk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGFQb2ludDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZGF0YSBwb2ludHMgdG8gYmUgc2VsZWN0ZWQuIChgW2RhdGEuc2VsZWN0aW9uLmVuYWJsZWRdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNHNlbGVjdGlvbiUyNUUyJTI1ODAlMjVBNGVuYWJsZWQpIG9wdGlvbiBzaG91bGQgYmUgc2V0IHRydWUgdG8gdXNlIHRoaXMgbWV0aG9kKWBcclxuXHQgKiBAZnVuY3Rpb24gc2VsZWN0XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtzdHJpbmd8QXJyYXl9IFtpZHNdIGlkIHZhbHVlIHRvIGdldCBzZWxlY3RlZC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0T3RoZXJdIFVuc2VsZWN0IGFscmVhZHkgc2VsZWN0ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xyXG5cdCAqICBjaGFydC5zZWxlY3QoKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGEyJ1xyXG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMlwiKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGExJyBhbmQgJ2RhdGEyJ1xyXG5cdCAqICBjaGFydC5zZWxlY3QoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAgLy8gc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyIGFuZCB1bnNlbGVjdCBvdGhlcnMgc2VsZWN0ZWRcclxuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTFcIiwgWzJdLCB0cnVlKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDAsIDMgYW5kIDVcclxuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTFcIiwgWzAsIDMsIDVdKTtcclxuXHQgKi9cclxuXHRzZWxlY3QoaWRzPzogc3RyaW5nW10gfCBzdHJpbmcsIGluZGljZXM/OiBudW1iZXJbXSwgcmVzZXRPdGhlcj86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YSA/IGQuZGF0YS5pZCA6IGQuaWQ7XHJcblx0XHRcdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoaXMsIGQpLmJpbmQoJCQpO1xyXG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAhaWRzIHx8IGlkcy5pbmRleE9mKGlkKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SW5kZXggPSAhaW5kaWNlcyB8fCBpbmRpY2VzLmluZGV4T2YoaSkgPj0gMDtcclxuXHRcdFx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblxyXG5cdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5saW5lKSB8fCBzaGFwZS5jbGFzc2VkKENMQVNTLmFyZWEpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNUYXJnZXRJZCAmJiBpc1RhcmdldEluZGV4KSB7XHJcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkgJiYgIWlzU2VsZWN0ZWQpIHtcclxuXHRcdFx0XHRcdFx0dG9nZ2xlKHRydWUsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIHRydWUpLCBkLCBpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChyZXNldE90aGVyKSAmJiByZXNldE90aGVyICYmIGlzU2VsZWN0ZWQpIHtcclxuXHRcdFx0XHRcdHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBkYXRhIHBvaW50cyB0byBiZSB1bi1zZWxlY3RlZC5cclxuXHQgKiBAZnVuY3Rpb24gdW5zZWxlY3RcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gYmUgdW5zZWxlY3RlZC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xyXG5cdCAqICBjaGFydC51bnNlbGVjdCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBmcm9tICdkYXRhMSdcclxuXHQgKiAgY2hhcnQudW5zZWxlY3QoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqICAvLyB1bnNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMlxyXG5cdCAqICBjaGFydC51bnNlbGVjdChcImRhdGExXCIsIFsyXSk7XHJcblx0ICovXHJcblx0dW5zZWxlY3QoaWRzPzogc3RyaW5nIHwgc3RyaW5nW10sIGluZGljZXM/OiBudW1iZXJbXSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZDtcclxuXHRcdFx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCk7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHJcblx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmXHJcblx0XHRcdFx0XHRpc1RhcmdldEluZGV4ICYmXHJcblx0XHRcdFx0XHRjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSAmJlxyXG5cdFx0XHRcdFx0aXNTZWxlY3RlZFxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNBcnJheSwgaXNPYmplY3R9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IHggdmFsdWVzIGZvciB0aGUgY2hhcnQuXHJcblx0ICogQGZ1bmN0aW9uIHhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB4IElmIHggaXMgZ2l2ZW4sIHggdmFsdWVzIG9mIGV2ZXJ5IHRhcmdldCB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBjdXJyZW50IHggdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSB0YXJnZXQgaWRzLlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHhzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gR2V0IGN1cnJlbnQgeCB2YWx1ZXNcclxuXHQgKiAgY2hhcnQueCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIFVwZGF0ZSB4IHZhbHVlcyBmb3IgYWxsIHRhcmdldHNcclxuXHQgKiAgY2hhcnQueChbMTAwLCAyMDAsIDMwMCwgNDAwLCAuLi5dKTtcclxuXHQgKi9cclxuXHR4KHg/OiBudW1iZXJbXSk6IHsgW2tleTogc3RyaW5nXSA6IG51bWJlcltdIH0ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGRhdGF9ID0gJCQ7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gYXhpcy5pc0N1c3RvbVgoKSAmJiBheGlzLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHJcblx0XHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0XHRpZiAoaXNDYXRlZ29yaXplZCkge1xyXG5cdFx0XHRcdHRoaXMuY2F0ZWdvcmllcyh4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQkJC51cGRhdGVUYXJnZXRYKGRhdGEudGFyZ2V0cywgeCk7XHJcblxyXG5cdFx0XHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNDYXRlZ29yaXplZCA/IHRoaXMuY2F0ZWdvcmllcygpIDogZGF0YS54cztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCB4IHZhbHVlcyBmb3IgdGhlIGNoYXJ0LlxyXG5cdCAqIEBmdW5jdGlvbiB4c1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHhzIElmIHhzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgeCB2YWx1ZXMgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgY3VycmVudCB4IHZhbHVlcyB3aWxsIGJlIHJldHVybmVkIGFzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGFyZSB0aGUgdGFyZ2V0IGlkcy5cclxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB4c1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEdldCBjdXJyZW50IHggdmFsdWVzXHJcblx0ICogIGNoYXJ0LnhzKCk7XHJcblx0ICpcclxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xyXG5cdCAqICBjaGFydC54cyh7XHJcblx0ICogICAgZGF0YTE6IFsxMCwgMjAsIDMwLCA0MCwgLi4uXSxcclxuXHQgKiAgICBkYXRhMjogWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXVxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHR4cyh4cz86IHsgW2tleTogc3RyaW5nXSA6IG51bWJlcltdIH0pOiB7IFtrZXk6IHN0cmluZ10gOiBudW1iZXJbXSB9IHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoeHMpKSB7XHJcblx0XHRcdCQkLnVwZGF0ZVRhcmdldFhzKCQkLmRhdGEudGFyZ2V0cywgeHMpO1xyXG5cclxuXHRcdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gJCQuZGF0YS54cztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt6b29tSWRlbnRpdHkgYXMgZDNab29tSWRlbnRpdHksIHpvb21UcmFuc2Zvcm0gYXMgZDNab29tVHJhbnNmb3JtfSBmcm9tIFwiZDMtem9vbVwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FsbEZuLCBleHRlbmQsIGdldE1pbk1heCwgaXNEZWZpbmVkLCBpc09iamVjdCwgaXNTdHJpbmcsIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRvbWFpbiBpcyB3aXRoaW4gem9vbSByYW5nZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW4gZG9tYWluIHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJhbmdlIHpvb20gcmFuZ2UgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiB3aXRoaW5SYW5nZShkb21haW46IG51bWJlcltdLCByYW5nZTogbnVtYmVyW10pOiBib29sZWFuIHtcclxuXHRjb25zdCBbbWluLCBtYXhdID0gcmFuZ2U7XHJcblxyXG5cdHJldHVybiBkb21haW4uZXZlcnkoKHYsIGkpID0+IChcclxuXHRcdGkgPT09IDAgPyAodiA+PSBtaW4pIDogKHYgPD0gbWF4KVxyXG5cdCkpO1xyXG59XHJcblxyXG4vKipcclxuICogWm9vbSBieSBnaXZpbmcgeCBkb21haW4uXHJcbiAqIC0gKipOT1RFOioqXHJcbiAqICAtIEZvciBgd2hlZWxgIHR5cGUgem9vbSwgdGhlIG1pbmltdW0gem9vbSByYW5nZSB3aWxsIGJlIHNldCBhcyB0aGUgZ2l2ZW4gZG9tYWluLiBUbyBnZXQgdGhlIGluaXRpYWwgc3RhdGUsIFsudW56b29tKCldKCN1bnpvb20pIHNob3VsZCBiZSBjYWxsZWQuXHJcbiAqICAtIFRvIGJlIHVzZWQgW3pvb20uZW5hYmxlZF0oT3B0aW9ucy5odG1sIy56b29tKSBvcHRpb24gc2hvdWxkIGJlIHNldCBhcyBgdHJ1dGh5YC5cclxuICogQGZ1bmN0aW9uIHpvb21cclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW5WYWx1ZSBJZiBkb21haW4gaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIHpvb21lZCB0byB0aGUgZ2l2ZW4gZG9tYWluLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgem9vbWVkIGRvbWFpbiB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGRvbWFpbiB2YWx1ZSBpbiBhcnJheVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgLy8gWm9vbSB0byBzcGVjaWZpZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKFsxMCwgMjBdKTtcclxuICpcclxuICogIC8vIEdldCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKCk7XHJcbiAqL1xyXG5jb25zdCB6b29tID0gZnVuY3Rpb24oZG9tYWluVmFsdWU/OiBudW1iZXJbXSk6IG51bWJlcltdIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0bGV0IGRvbWFpbiA9IGRvbWFpblZhbHVlO1xyXG5cdGxldCByZXN1bHREb21haW47XHJcblxyXG5cdGlmIChjb25maWcuem9vbV9lbmFibGVkICYmIGRvbWFpbiAmJiB3aXRoaW5SYW5nZShkb21haW4sICQkLmdldFpvb21Eb21haW4oKSkpIHtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9ICQkLmF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0aWYgKGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRjb25zdCBmbiA9IHBhcnNlRGF0ZS5iaW5kKCQkKTtcclxuXHJcblx0XHRcdGRvbWFpbiA9IGRvbWFpbi5tYXAoeCA9PiBmbih4KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdGNvbnN0IHhTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHJcblx0XHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbigpLmNhbGwoJCQuYnJ1c2gubW92ZSwgW3hTY2FsZShkb21haW5bMF0pLCB4U2NhbGUoZG9tYWluWzFdKV0pO1xyXG5cdFx0XHRyZXN1bHREb21haW4gPSBkb21haW47XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRzY2FsZS54LmRvbWFpbihkb21haW4pO1xyXG5cdFx0XHRzY2FsZS56b29tID0gc2NhbGUueDtcclxuXHRcdFx0JCQuYXhpcy54LnNjYWxlKHNjYWxlLnpvb20pO1xyXG5cclxuXHRcdFx0cmVzdWx0RG9tYWluID0gc2NhbGUuem9vbS5vcmdEb21haW4oKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGUsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHQkJC5zZXRab29tUmVzZXRCdXR0b24oKTtcclxuXHRcdGNhbGxGbihjb25maWcuem9vbV9vbnpvb20sICQkLmFwaSwgcmVzdWx0RG9tYWluKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVzdWx0RG9tYWluID0gc2NhbGUuem9vbSA/XHJcblx0XHRcdHNjYWxlLnpvb20uZG9tYWluKCkgOiBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdERvbWFpbjtcclxufTtcclxuXHJcbmV4dGVuZCh6b29tLCB7XHJcblx0LyoqXHJcblx0ICogRW5hYmxlIGFuZCBkaXNhYmxlIHpvb21pbmcuXHJcblx0ICogQGZ1bmN0aW9uIHpvb23igKRlbmFibGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ3xib29sZWFufSBlbmFibGVkIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXMgYXJlIFwid2hlZWxcIiBvciBcImRyYWdcIi4gSWYgZW5hYmxlZCBpcyB0cnVlLCBcIndoZWVsXCIgd2lsbCBiZSB1c2VkLiBJZiBmYWxzZSBpcyBnaXZlbiwgem9vbWluZyB3aWxsIGJlIGRpc2FibGVkLjxicj5XaGVuIHNldCB0byBmYWxzZSwgdGhlIGN1cnJlbnQgem9vbWluZyBzdGF0dXMgd2lsbCBiZSByZXNldC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBFbmFibGUgem9vbWluZyB1c2luZyB0aGUgbW91c2Ugd2hlZWxcclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUodHJ1ZSk7XHJcblx0ICogIC8vIE9yXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKFwid2hlZWxcIik7XHJcblx0ICpcclxuXHQgKiAgLy8gRW5hYmxlIHpvb21pbmcgYnkgZHJhZ2dpbmdcclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoXCJkcmFnXCIpO1xyXG5cdCAqXHJcblx0ICogIC8vIERpc2FibGUgem9vbWluZ1xyXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShmYWxzZSk7XHJcblx0ICovXHJcblx0ZW5hYmxlOiBmdW5jdGlvbihlbmFibGVkOiBib29sZWFuIHwgXCJ3aGVlbFwiIHwgXCJkcmFnXCIgfCBhbnkpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRsZXQgZW5hYmxlVHlwZTogYW55ID0gZW5hYmxlZDtcclxuXHJcblx0XHRpZiAoZW5hYmxlZCkge1xyXG5cdFx0XHRlbmFibGVUeXBlID0gaXNTdHJpbmcoZW5hYmxlZCkgJiYgL14oZHJhZ3x3aGVlbCkkLy50ZXN0KGVuYWJsZWQpID9cclxuXHRcdFx0XHR7dHlwZTogZW5hYmxlZH0gOiBlbmFibGVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy56b29tX2VuYWJsZWQgPSBlbmFibGVUeXBlO1xyXG5cclxuXHRcdGlmICghJCQuem9vbSkge1xyXG5cdFx0XHQkJC5pbml0Wm9vbSgpO1xyXG5cdFx0XHQkJC5iaW5kWm9vbUV2ZW50KCk7XHJcblx0XHR9IGVsc2UgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XHJcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBvciBnZXQgeCBBeGlzIG1heGltdW0gem9vbSByYW5nZSB2YWx1ZVxyXG5cdCAqIEBmdW5jdGlvbiB6b29t4oCkbWF4XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IFttYXhdIG1heGltdW0gdmFsdWUgdG8gc2V0IGZvciB6b29tXHJcblx0ICogQHJldHVybnMge251bWJlcn0gem9vbSBtYXggdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBTZXQgbWF4aW11bSByYW5nZSB2YWx1ZVxyXG5cdCAqICBjaGFydC56b29tLm1heCgyMCk7XHJcblx0ICovXHJcblx0bWF4OiBmdW5jdGlvbihtYXg/OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnOiB7eERvbWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG1heCA9PT0gMCB8fCBtYXgpIHtcclxuXHRcdFx0Y29uZmlnLnpvb21feF9tYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgW3hEb21haW5bMV0sIG1heF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWcuem9vbV94X21heDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgb3IgZ2V0IHggQXhpcyBtaW5pbXVtIHpvb20gcmFuZ2UgdmFsdWVcclxuXHQgKiBAZnVuY3Rpb24gem9vbeKApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBbbWluXSBtaW5pbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IHpvb20gbWluIHZhbHVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gU2V0IG1pbmltdW0gcmFuZ2UgdmFsdWVcclxuXHQgKiAgY2hhcnQuem9vbS5taW4oLTEpO1xyXG5cdCAqL1xyXG5cdG1pbjogZnVuY3Rpb24obWluPzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZzoge3hEb21haW59fSA9ICQkO1xyXG5cclxuXHRcdGlmIChtaW4gPT09IDAgfHwgbWluKSB7XHJcblx0XHRcdGNvbmZpZy56b29tX3hfbWluID0gZ2V0TWluTWF4KFwibWluXCIsIFt4RG9tYWluWzBdLCBtaW5dKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLnpvb21feF9taW47XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IHpvb20gcmFuZ2VcclxuXHQgKiBAZnVuY3Rpb24gem9vbeKApHJhbmdlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IFtyYW5nZV0gem9vbSByYW5nZVxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHpvb20gcmFuZ2UgdmFsdWVcclxuXHQgKiB7XHJcblx0ICogICBtaW46IDAsXHJcblx0ICogICBtYXg6IDEwMFxyXG5cdCAqIH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC56b29tLnJhbmdlKHtcclxuXHQgKiAgICAgIG1pbjogMTAsXHJcblx0ICogICAgICBtYXg6IDEwMFxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHRyYW5nZTogZnVuY3Rpb24ocmFuZ2UpOiB7bWluOiAobnVtYmVyfHVuZGVmaW5lZClbXSwgbWF4OiAobnVtYmVyfHVuZGVmaW5lZClbXX0ge1xyXG5cdFx0Y29uc3Qgem9vbSA9IHRoaXMuem9vbTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QocmFuZ2UpKSB7XHJcblx0XHRcdGNvbnN0IHttaW4sIG1heH0gPSByYW5nZTtcclxuXHJcblx0XHRcdGlzRGVmaW5lZChtaW4pICYmIHpvb20ubWluKG1pbik7XHJcblx0XHRcdGlzRGVmaW5lZChtYXgpICYmIHpvb20ubWF4KG1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0bWluOiB6b29tLm1pbigpLFxyXG5cdFx0XHRtYXg6IHpvb20ubWF4KClcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHR6b29tLFxyXG5cclxuXHQvKipcclxuXHQgKiBVbnpvb20gem9vbWVkIGFyZWFcclxuXHQgKiBAZnVuY3Rpb24gdW56b29tXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgY2hhcnQudW56b29tKCk7XHJcblx0ICovXHJcblx0dW56b29tKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuc2NhbGUuem9vbSkge1xyXG5cdFx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyA/XHJcblx0XHRcdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBudWxsKSA6XHJcblx0XHRcdFx0JCQuem9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZShkM1pvb21JZGVudGl0eSk7XHJcblxyXG5cdFx0XHQkJC51cGRhdGVab29tKHRydWUpO1xyXG5cdFx0XHQkJC56b29tLnJlc2V0QnRuICYmICQkLnpvb20ucmVzZXRCdG4uc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHRcdC8vIHJlc2V0IHRyYW5zZm9ybVxyXG5cdFx0XHRjb25zdCBldmVudFJlY3RzID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3RzfWApO1xyXG5cclxuXHRcdFx0aWYgKGQzWm9vbVRyYW5zZm9ybShldmVudFJlY3RzLm5vZGUoKSkgIT09IGQzWm9vbUlkZW50aXR5KSB7XHJcblx0XHRcdFx0JCQuem9vbS50cmFuc2Zvcm0oZXZlbnRSZWN0cywgZDNab29tSWRlbnRpdHkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7c2NhbGVMaW5lYXIgYXMgZDNTY2FsZUxpbmVhcn0gZnJvbSBcImQzLXNjYWxlXCI7XHJcbmltcG9ydCB7aXNEZWZpbmVkLCBpc051bWJlciwgaXNTdHJpbmd9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNSZW5kZXJlckhlbHBlciB7XHJcblx0cHJpdmF0ZSBvd25lcjtcclxuXHRwcml2YXRlIGNvbmZpZztcclxuXHRwcml2YXRlIHNjYWxlO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihvd25lcikge1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSBkM1NjYWxlTGluZWFyKCk7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBwYXJhbXN9ID0gb3duZXI7XHJcblxyXG5cdFx0dGhpcy5vd25lciA9IG93bmVyO1xyXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWc7XHJcblx0XHR0aGlzLnNjYWxlID0gc2NhbGU7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5ub1RyYW5zaXRpb24gfHwgIXBhcmFtcy5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbikge1xyXG5cdFx0XHRjb25maWcud2l0aG91dFRyYW5zaXRpb24gPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCByYW5nZVxyXG5cdFx0Y29uZmlnLnJhbmdlID0gdGhpcy5zY2FsZUV4dGVudCgocGFyYW1zLm9yZ1hTY2FsZSB8fCBzY2FsZSkucmFuZ2UoKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIGEgY2hhcmFjdGVyIGRpbWVuc2lvblxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBub2RlIDxnIGNsYXNzPXRpY2s+IG5vZGVcclxuXHQgKiBAcmV0dXJucyB7e3c6IG51bWJlciwgaDogbnVtYmVyfX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRTaXplRm9yMUNoYXIobm9kZT8pIHtcclxuXHRcdC8vIGRlZmF1bHQgc2l6ZSBmb3Igb25lIGNoYXJhY3RlclxyXG5cdFx0Y29uc3Qgc2l6ZSA9IHtcclxuXHRcdFx0dzogNS41LFxyXG5cdFx0XHRoOiAxMS41XHJcblx0XHR9O1xyXG5cclxuXHRcdCFub2RlLmVtcHR5KCkgJiYgbm9kZS5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdC50ZXh0KFwiMFwiKVxyXG5cdFx0XHQuY2FsbChlbCA9PiB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IGVsLm5vZGUoKS5nZXRCQm94KCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHdpZHRoICYmIGhlaWdodCkge1xyXG5cdFx0XHRcdFx0XHRzaXplLncgPSB3aWR0aDtcclxuXHRcdFx0XHRcdFx0c2l6ZS5oID0gaGVpZ2h0O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHR9IGZpbmFsbHkge1xyXG5cdFx0XHRcdFx0ZWwudGV4dChcIlwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuZ2V0U2l6ZUZvcjFDaGFyID0gKCkgPT4gc2l6ZTtcclxuXHJcblx0XHRyZXR1cm4gc2l6ZTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aWNrIHRyYW5zZm9ybSBzZXR0ZXIgZnVuY3Rpb25cclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgQXhpcyBpZFxyXG5cdCAqIEByZXR1cm5zIHtGdW5jdGlvbn0gdHJhbnNmcm9tIHNldHRlciBmdW5jdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VGlja1RyYW5zZm9ybVNldHRlcihpZDogc3RyaW5nKTogKHNlbGVjdGlvbjogZDNTZWxlY3Rpb24sIHNjYWxlKSA9PiB2b2lkIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IGZuID0gaWQgPT09IFwieFwiID9cclxuXHRcdFx0dmFsdWUgPT4gYHRyYW5zbGF0ZSgke3ZhbHVlICsgY29uZmlnLnRpY2tPZmZzZXR9LDApYCA6XHJcblx0XHRcdHZhbHVlID0+IGB0cmFuc2xhdGUoMCwke3ZhbHVlfSlgO1xyXG5cclxuXHRcdHJldHVybiAoc2VsZWN0aW9uLCBzY2FsZSkgPT4ge1xyXG5cdFx0XHRzZWxlY3Rpb24uYXR0cihcInRyYW5zZm9ybVwiLCBkID0+IGZuKE1hdGguY2VpbChzY2FsZShkKSkpKTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRzY2FsZUV4dGVudChkb21haW46IFtudW1iZXIsIG51bWJlcl0pOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdGNvbnN0IHN0YXJ0ID0gZG9tYWluWzBdO1xyXG5cdFx0Y29uc3Qgc3RvcCA9IGRvbWFpbltkb21haW4ubGVuZ3RoIC0gMV07XHJcblxyXG5cdFx0cmV0dXJuIHN0YXJ0IDwgc3RvcCA/IFtzdGFydCwgc3RvcF0gOiBbc3RvcCwgc3RhcnRdO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUaWNrcyhzY2FsZSwgaXNZQXhlczogYm9vbGVhbik6IG51bWJlcltdIHtcclxuXHRcdGNvbnN0IHt0aWNrU3RlcFNpemV9ID0gdGhpcy5vd25lci5wYXJhbXM7XHJcblx0XHRsZXQgdGlja3M6IG51bWJlcltdID0gW107XHJcblxyXG5cdFx0Ly8gV2hlbiAnYXhpc1t5fHkyXS50aWNrLnN0ZXBTaXplJyBvcHRpb24gaXMgc2V0XHJcblx0XHRpZiAoaXNZQXhlcyAmJiB0aWNrU3RlcFNpemUpIHtcclxuXHRcdFx0Y29uc3QgW3N0YXJ0LCBlbmRdID0gc2NhbGUuZG9tYWluKCk7XHJcblx0XHRcdGxldCBpbnRlcnZhbCA9IHN0YXJ0O1xyXG5cclxuXHRcdFx0d2hpbGUgKGludGVydmFsIDw9IGVuZCkge1xyXG5cdFx0XHRcdHRpY2tzLnB1c2goaW50ZXJ2YWwpO1xyXG5cdFx0XHRcdGludGVydmFsICs9IHRpY2tTdGVwU2l6ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChzY2FsZS50aWNrcykge1xyXG5cdFx0XHR0aWNrcyA9IHNjYWxlLnRpY2tzKFxyXG5cdFx0XHRcdC4uLih0aGlzLmNvbmZpZy50aWNrQXJndW1lbnRzIHx8IFtdKVxyXG5cdFx0XHQpLm1hcCh2ID0+IChcclxuXHRcdFx0XHQvLyByb3VuZCB0aGUgdGljayB2YWx1ZSBpZiBpcyBudW1iZXJcclxuXHRcdFx0XHQoaXNTdHJpbmcodikgJiYgaXNOdW1iZXIodikgJiYgIWlzTmFOKHYpICYmXHJcblx0XHRcdFx0XHRNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMFxyXG5cdFx0XHRcdCkgfHwgdlxyXG5cdFx0XHQpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IE1hdGguY2VpbChkb21haW5bMF0pOyBpIDwgZG9tYWluWzFdOyBpKyspIHtcclxuXHRcdFx0XHR0aWNrcy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID4gMCAmJiB0aWNrc1swXSA+IDApIHtcclxuXHRcdFx0XHR0aWNrcy51bnNoaWZ0KHRpY2tzWzBdIC0gKHRpY2tzWzFdIC0gdGlja3NbMF0pKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWNrcztcclxuXHR9XHJcblxyXG5cdGNvcHlTY2FsZSgpIHtcclxuXHRcdGNvbnN0IG5ld1NjYWxlID0gdGhpcy5zY2FsZS5jb3B5KCk7XHJcblxyXG5cdFx0aWYgKCFuZXdTY2FsZS5kb21haW4oKS5sZW5ndGgpIHtcclxuXHRcdFx0bmV3U2NhbGUuZG9tYWluKHRoaXMuc2NhbGUuZG9tYWluKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdTY2FsZTtcclxuXHR9XHJcblxyXG5cdHRleHRGb3JtYXR0ZWQodjogc3RyaW5nIHwgbnVtYmVyIHwgYW55KTogc3RyaW5nIHtcclxuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSB0aGlzLmNvbmZpZy50aWNrRm9ybWF0O1xyXG5cclxuXHRcdC8vIHRvIHJvdW5kIGZsb2F0IG51bWJlcnMgZnJvbSAnYmluYXJ5IGZsb2F0aW5nIHBvaW50J1xyXG5cdFx0Ly8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91YmxlLXByZWNpc2lvbl9mbG9hdGluZy1wb2ludF9mb3JtYXRcclxuXHRcdC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE3ODQ5MTAxL2xheW1hbnMtZXhwbGFuYXRpb24tZm9yLXdoeS1qYXZhc2NyaXB0LWhhcy13ZWlyZC1mbG9hdGluZy1tYXRoLWllZWUtNzU0LXN0YW5kXHJcblx0XHRjb25zdCB2YWx1ZSA9IC9cXGQrXFwuXFxkKzB7NSx9XFxkJC8udGVzdCh2KSA/ICtTdHJpbmcodikucmVwbGFjZSgvMCtcXGQkLywgXCJcIikgOiB2O1xyXG5cdFx0Y29uc3QgZm9ybWF0dGVkID0gdGlja0Zvcm1hdCA/IHRpY2tGb3JtYXQodmFsdWUpIDogdmFsdWU7XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZChmb3JtYXR0ZWQpID8gZm9ybWF0dGVkIDogXCJcIjtcclxuXHR9XHJcblxyXG5cdHRyYW5zaXRpb25pc2Uoc2VsZWN0aW9uKTogZDNTZWxlY3Rpb24ge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcud2l0aG91dFRyYW5zaXRpb24gP1xyXG5cdFx0XHRzZWxlY3Rpb24uaW50ZXJydXB0KCkgOiBzZWxlY3Rpb24udHJhbnNpdGlvbihjb25maWcudHJhbnNpdGlvbik7XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuaW1wb3J0IEhlbHBlciBmcm9tIFwiLi9BeGlzUmVuZGVyZXJIZWxwZXJcIjtcclxuaW1wb3J0IHtpc0FycmF5LCB0b0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXJ9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpc1JlbmRlcmVyIHtcclxuXHRoZWxwZXI7XHJcblx0Y29uZmlnO1xyXG5cdHBhcmFtcztcclxuXHRnO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihwYXJhbXM6IGFueSA9IHt9KSB7XHJcblx0XHRjb25zdCBjb25maWcgPSB7XHJcblx0XHRcdGlubmVyVGlja1NpemU6IDYsXHJcblx0XHRcdG91dGVyVGlja1NpemU6IHBhcmFtcy5vdXRlclRpY2sgPyA2IDogMCxcclxuXHRcdFx0b3JpZW50OiBcImJvdHRvbVwiLFxyXG5cdFx0XHRyYW5nZTogW10sXHJcblx0XHRcdHRpY2tBcmd1bWVudHM6IG51bGwsXHJcblx0XHRcdHRpY2tDZW50ZXJlZDogbnVsbCxcclxuXHRcdFx0dGlja0N1bGxpbmc6IHRydWUsXHJcblx0XHRcdHRpY2tGb3JtYXQ6IG51bGwsXHJcblx0XHRcdHRpY2tMZW5ndGg6IDksXHJcblx0XHRcdHRpY2tPZmZzZXQ6IDAsXHJcblx0XHRcdHRpY2tQYWRkaW5nOiAzLFxyXG5cdFx0XHR0aWNrVmFsdWVzOiBudWxsLFxyXG5cdFx0XHR0cmFuc2l0aW9uOiBudWxsLFxyXG5cdFx0XHRub1RyYW5zaXRpb246IHBhcmFtcy5ub1RyYW5zaXRpb25cclxuXHRcdH07XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tMZW5ndGggPSBNYXRoLm1heChjb25maWcuaW5uZXJUaWNrU2l6ZSwgMCkgKyBjb25maWcudGlja1BhZGRpbmc7XHJcblxyXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWc7XHJcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcclxuXHRcdHRoaXMuaGVscGVyID0gbmV3IEhlbHBlcih0aGlzKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBheGlzIGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gZyBBeGlzIHNlbGVjdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y3JlYXRlKGc6IGQzU2VsZWN0aW9uKTogdm9pZCB7XHJcblx0XHRjb25zdCBjdHggPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgaGVscGVyLCBwYXJhbXN9ID0gdGhpcztcclxuXHRcdGNvbnN0IHtzY2FsZX0gPSBoZWxwZXI7XHJcblx0XHRjb25zdCB7b3JpZW50fSA9IGNvbmZpZztcclxuXHRcdGNvbnN0IHNwbGl0VGlja1RleHQgPSB0aGlzLnNwbGl0VGlja1RleHQuYmluZCh0aGlzKTtcclxuXHRcdGNvbnN0IGlzTGVmdFJpZ2h0ID0gL14obGVmdHxyaWdodCkkLy50ZXN0KG9yaWVudCk7XHJcblx0XHRjb25zdCBpc1RvcEJvdHRvbSA9IC9eKHRvcHxib3R0b20pJC8udGVzdChvcmllbnQpO1xyXG5cclxuXHRcdC8vIGxpbmUvdGV4dCBlbnRlciBhbmQgcGF0aCB1cGRhdGVcclxuXHRcdGNvbnN0IHRpY2tUcmFuc2Zvcm0gPSBoZWxwZXIuZ2V0VGlja1RyYW5zZm9ybVNldHRlcihpc1RvcEJvdHRvbSA/IFwieFwiIDogXCJ5XCIpO1xyXG5cdFx0Y29uc3QgYXhpc1B4ID0gdGlja1RyYW5zZm9ybSA9PT0gaGVscGVyLmF4aXNYID8gXCJ5XCIgOiBcInhcIjtcclxuXHRcdGNvbnN0IHNpZ24gPSAvXih0b3B8bGVmdCkkLy50ZXN0KG9yaWVudCkgPyAtMSA6IDE7XHJcblxyXG5cdFx0Ly8gdGljayB0ZXh0IGhlbHBlcnNcclxuXHRcdGNvbnN0IHJvdGF0ZSA9IHBhcmFtcy50aWNrVGV4dFJvdGF0ZTtcclxuXHJcblx0XHR0aGlzLmNvbmZpZy5yYW5nZSA9IHNjYWxlLnJhbmdlRXh0ZW50ID9cclxuXHRcdFx0c2NhbGUucmFuZ2VFeHRlbnQoKSA6XHJcblx0XHRcdGhlbHBlci5zY2FsZUV4dGVudCgocGFyYW1zLm9yZ1hTY2FsZSB8fCBzY2FsZSkucmFuZ2UoKSk7XHJcblxyXG5cdFx0Y29uc3Qge2lubmVyVGlja1NpemUsIHRpY2tMZW5ndGgsIHJhbmdlfSA9IGNvbmZpZztcclxuXHJcblx0XHQvLyAvLyBnZXQgdGhlIGF4aXMnIHRpY2sgcG9zaXRpb24gY29uZmlndXJhdGlvblxyXG5cdFx0Y29uc3QgaWQgPSBwYXJhbXMuaWQ7XHJcblx0XHRjb25zdCB0aWNrVGV4dFBvcyA9IGlkICYmIC9eKHh8eXx5MikkLy50ZXN0KGlkKSA/XHJcblx0XHRcdHBhcmFtcy5jb25maWdbYGF4aXNfJHtpZH1fdGlja190ZXh0X3Bvc2l0aW9uYF0gOiB7eDogMCwgeTogMH07XHJcblxyXG5cdFx0Ly8gdGljayB2aXNpYmxpdHlcclxuXHRcdGNvbnN0IHByZWZpeCA9IGlkID09PSBcInN1YlhcIiA/IGBzdWJjaGFydF9heGlzX3hgIDogYGF4aXNfJHtpZH1gO1xyXG5cdFx0Y29uc3QgYXhpc1Nob3cgPSBwYXJhbXMuY29uZmlnW2Ake3ByZWZpeH1fc2hvd2BdO1xyXG5cdFx0Y29uc3QgdGlja1Nob3cgPSB7XHJcblx0XHRcdHRpY2s6IGF4aXNTaG93ID8gcGFyYW1zLmNvbmZpZ1tgJHtwcmVmaXh9X3RpY2tfc2hvd2BdIDogZmFsc2UsXHJcblx0XHRcdHRleHQ6IGF4aXNTaG93ID8gcGFyYW1zLmNvbmZpZ1tgJHtwcmVmaXh9X3RpY2tfdGV4dF9zaG93YF0gOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHRsZXQgJGc7XHJcblxyXG5cdFx0Zy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBnID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdGxldCBzY2FsZTAgPSB0aGlzLl9fY2hhcnRfXyB8fCBzY2FsZTtcclxuXHRcdFx0bGV0IHNjYWxlMSA9IGhlbHBlci5jb3B5U2NhbGUoKTtcclxuXHJcblx0XHRcdCRnID0gZztcclxuXHRcdFx0dGhpcy5fX2NoYXJ0X18gPSBzY2FsZTE7XHJcblxyXG5cdFx0XHRjb25maWcudGlja09mZnNldCA9IHBhcmFtcy5pc0NhdGVnb3J5ID9cclxuXHRcdFx0XHRNYXRoLmNlaWwoKHNjYWxlMSgxKSAtIHNjYWxlMSgwKSkgLyAyKSA6IDA7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgc2VsZWN0aW9uIC0gZGF0YSBqb2luXHJcblx0XHRcdGNvbnN0IHBhdGggPSBnLnNlbGVjdEFsbChcIi5kb21haW5cIikuZGF0YShbMF0pO1xyXG5cclxuXHRcdFx0Ly8gZW50ZXIgKyB1cGRhdGUgc2VsZWN0aW9uXHJcblx0XHRcdHBhdGguZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcImRvbWFpblwiKVxyXG5cdFx0XHRcdC5tZXJnZShoZWxwZXIudHJhbnNpdGlvbmlzZShwYXRoKSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3Qgb3V0ZXJUaWNrU2l6ZWQgPSBjb25maWcub3V0ZXJUaWNrU2l6ZSAqIHNpZ247XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGlzVG9wQm90dG9tID9cclxuXHRcdFx0XHRcdFx0YE0ke3JhbmdlWzBdfSwke291dGVyVGlja1NpemVkfVYwSCR7cmFuZ2VbMV19ViR7b3V0ZXJUaWNrU2l6ZWR9YCA6XHJcblx0XHRcdFx0XHRcdGBNJHtvdXRlclRpY2tTaXplZH0sJHtyYW5nZVswXX1IMFYke3JhbmdlWzFdfUgke291dGVyVGlja1NpemVkfWA7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAodGlja1Nob3cudGljayB8fCB0aWNrU2hvdy50ZXh0KSB7XHJcblx0XHRcdFx0Ly8gY291bnQgb2YgdGljayBkYXRhIGluIGFycmF5XHJcblx0XHRcdFx0Y29uc3QgdGlja3MgPSBjb25maWcudGlja1ZhbHVlcyB8fCBoZWxwZXIuZ2VuZXJhdGVUaWNrcyhzY2FsZTEsIGlzTGVmdFJpZ2h0KTtcclxuXHJcblx0XHRcdFx0Ly8gdXBkYXRlIHNlbGVjdGlvblxyXG5cdFx0XHRcdGxldCB0aWNrOiBkM1NlbGVjdGlvbiA9IGcuc2VsZWN0QWxsKFwiLnRpY2tcIilcclxuXHRcdFx0XHRcdC5kYXRhKHRpY2tzLCBzY2FsZTEpO1xyXG5cclxuXHRcdFx0XHQvLyBlbnRlciBzZWxlY3Rpb25cclxuXHRcdFx0XHRjb25zdCB0aWNrRW50ZXIgPSB0aWNrXHJcblx0XHRcdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHRcdFx0Lmluc2VydChcImdcIiwgXCIuZG9tYWluXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwidGlja1wiKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0XHRcdC8vIE1FTU86IE5vIGV4aXQgdHJhbnNpdGlvbi4gVGhlIHJlYXNvbiBpcyB0aGlzIHRyYW5zaXRpb24gYWZmZWN0cyBtYXggdGljayB3aWR0aCBjYWxjdWxhdGlvbiBiZWNhdXNlIG9sZCB0aWNrIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHRpY2tzLlxyXG5cdFx0XHRcdGNvbnN0IHRpY2tFeGl0ID0gdGljay5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRcdC8vIGVudGVyICsgdXBkYXRlIHNlbGVjdGlvblxyXG5cdFx0XHRcdHRpY2sgPSB0aWNrRW50ZXIubWVyZ2UodGljayk7XHJcblxyXG5cdFx0XHRcdHRpY2tTaG93LnRpY2sgJiYgdGlja0VudGVyLmFwcGVuZChcImxpbmVcIik7XHJcblx0XHRcdFx0dGlja1Nob3cudGV4dCAmJiB0aWNrRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2l6ZUZvcjFDaGFyID0gSGVscGVyLmdldFNpemVGb3IxQ2hhcih0aWNrKTtcclxuXHRcdFx0XHRjb25zdCBjb3VudHM6IG51bWJlcltdID0gW107XHJcblxyXG5cdFx0XHRcdGxldCB0c3BhbjogZDNTZWxlY3Rpb24gPSB0aWNrLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJ0c3BhblwiKVxyXG5cdFx0XHRcdFx0LmRhdGEoKGQsIGluZGV4KSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNwbGl0ID0gcGFyYW1zLnRpY2tNdWx0aWxpbmUgP1xyXG5cdFx0XHRcdFx0XHRcdHNwbGl0VGlja1RleHQoZCwgc2NhbGUxLCB0aWNrcywgaXNMZWZ0UmlnaHQsIHNpemVGb3IxQ2hhci53KSA6IChcclxuXHRcdFx0XHRcdFx0XHRcdGlzQXJyYXkoaGVscGVyLnRleHRGb3JtYXR0ZWQoZCkpID9cclxuXHRcdFx0XHRcdFx0XHRcdFx0aGVscGVyLnRleHRGb3JtYXR0ZWQoZCkuY29uY2F0KCkgOiBbaGVscGVyLnRleHRGb3JtYXR0ZWQoZCldXHJcblx0XHRcdFx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0XHRcdGNvdW50c1tpbmRleF0gPSBzcGxpdC5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gc3BsaXQubWFwKHNwbGl0dGVkID0+ICh7aW5kZXgsIHNwbGl0dGVkfSkpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHRzcGFuLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdFx0dHNwYW4gPSB0c3BhblxyXG5cdFx0XHRcdFx0LmVudGVyKClcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJ0c3BhblwiKVxyXG5cdFx0XHRcdFx0Lm1lcmdlKHRzcGFuKVxyXG5cdFx0XHRcdFx0LnRleHQoZCA9PiBkLnNwbGl0dGVkKTtcclxuXHJcblx0XHRcdFx0Ly8gc2V0IDx0c3Bhbj4ncyBwb3NpdGlvblxyXG5cdFx0XHRcdHRzcGFuXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgaXNUb3BCb3R0b20gPyAwIDogdGlja0xlbmd0aCAqIHNpZ24pXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsICgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdGxldCBkeCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoLyh0b3B8Ym90dG9tKS8udGVzdChvcmllbnQpICYmIHJvdGF0ZSkge1xyXG5cdFx0XHRcdFx0XHRcdGR4ID0gOCAqIE1hdGguc2luKE1hdGguUEkgKiAocm90YXRlIC8gMTgwKSkgKiAob3JpZW50ID09PSBcInRvcFwiID8gLTEgOiAxKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGR4ICsgKHRpY2tUZXh0UG9zLnggfHwgMCk7XHJcblx0XHRcdFx0XHR9KSgpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCAoZCwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBkZWZWYWx1ZSA9IFwiLjcxZW1cIjtcclxuXHRcdFx0XHRcdFx0bGV0IGR5OiBudW1iZXIgfCBzdHJpbmcgPSAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKG9yaWVudCAhPT0gXCJ0b3BcIikge1xyXG5cdFx0XHRcdFx0XHRcdGR5ID0gc2l6ZUZvcjFDaGFyLmg7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmIChpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRkeSA9IGlzTGVmdFJpZ2h0ID8gLSgoY291bnRzW2QuaW5kZXhdIC0gMSkgKiAoc2l6ZUZvcjFDaGFyLmggLyAyKSAtIDMpIDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0KHRpY2tUZXh0UG9zLnkgPT09IDAgPyBkZWZWYWx1ZSA6IDApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGlzTnVtYmVyKGR5KSAmJiB0aWNrVGV4dFBvcy55ID9cclxuXHRcdFx0XHRcdFx0XHRkeSArIHRpY2tUZXh0UG9zLnkgOiBkeSB8fCBkZWZWYWx1ZTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRjb25zdCBsaW5lVXBkYXRlID0gdGljay5zZWxlY3QoXCJsaW5lXCIpO1xyXG5cdFx0XHRcdGNvbnN0IHRleHRVcGRhdGUgPSB0aWNrLnNlbGVjdChcInRleHRcIik7XHJcblxyXG5cdFx0XHRcdHRpY2tFbnRlci5zZWxlY3QoXCJsaW5lXCIpLmF0dHIoYCR7YXhpc1B4fTJgLCBpbm5lclRpY2tTaXplICogc2lnbik7XHJcblx0XHRcdFx0dGlja0VudGVyLnNlbGVjdChcInRleHRcIikuYXR0cihheGlzUHgsIHRpY2tMZW5ndGggKiBzaWduKTtcclxuXHJcblx0XHRcdFx0Y3R4LnNldFRpY2tMaW5lVGV4dFBvc2l0aW9uKGxpbmVVcGRhdGUsIHRleHRVcGRhdGUpO1xyXG5cclxuXHRcdFx0XHQvLyBBcHBlbmQgPHRpdGxlPiBmb3IgdG9vbHRpcCBkaXNwbGF5XHJcblx0XHRcdFx0aWYgKHBhcmFtcy50aWNrVGl0bGUpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHRpdGxlID0gdGV4dFVwZGF0ZS5zZWxlY3QoXCJ0aXRsZVwiKTtcclxuXHJcblx0XHRcdFx0XHQodGl0bGUuZW1wdHkoKSA/IHRleHRVcGRhdGUuYXBwZW5kKFwidGl0bGVcIikgOiB0aXRsZSlcclxuXHRcdFx0XHRcdFx0LnRleHQoaW5kZXggPT4gcGFyYW1zLnRpY2tUaXRsZVtpbmRleF0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHNjYWxlMS5iYW5kd2lkdGgpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHggPSBzY2FsZTE7XHJcblx0XHRcdFx0XHRjb25zdCBkeCA9IHguYmFuZHdpZHRoKCkgLyAyO1xyXG5cclxuXHRcdFx0XHRcdHNjYWxlMCA9IGQgPT4geChkKSArIGR4O1xyXG5cdFx0XHRcdFx0c2NhbGUxID0gc2NhbGUwO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoc2NhbGUwLmJhbmR3aWR0aCkge1xyXG5cdFx0XHRcdFx0c2NhbGUwID0gc2NhbGUxO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aWNrVHJhbnNmb3JtKHRpY2tFeGl0LCBzY2FsZTEpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGlja1RyYW5zZm9ybSh0aWNrRW50ZXIsIHNjYWxlMCk7XHJcblx0XHRcdFx0dGlja1RyYW5zZm9ybShoZWxwZXIudHJhbnNpdGlvbmlzZSh0aWNrKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpLCBzY2FsZTEpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmcgPSAkZztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aWNrIHgveSBjb29yZGluYXRlXHJcblx0ICogQHJldHVybnMge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUaWNrWFkoKToge3g6IG51bWJlciwgeTogbnVtYmVyfSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBwb3MgPSB7eDogMCwgeTogMH07XHJcblxyXG5cdFx0aWYgKHRoaXMucGFyYW1zLmlzQ2F0ZWdvcnkpIHtcclxuXHRcdFx0cG9zLnggPSBjb25maWcudGlja0NlbnRlcmVkID8gMCA6IGNvbmZpZy50aWNrT2Zmc2V0O1xyXG5cdFx0XHRwb3MueSA9IGNvbmZpZy50aWNrQ2VudGVyZWQgPyBjb25maWcudGlja09mZnNldCA6IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aWNrIHNpemVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBkYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUaWNrU2l6ZShkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IHtzY2FsZX0gPSB0aGlzLmhlbHBlcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IHtpbm5lclRpY2tTaXplLCByYW5nZX0gPSBjb25maWc7XHJcblxyXG5cdFx0Y29uc3QgdGlja1Bvc2l0aW9uID0gc2NhbGUoZCkgK1xyXG5cdFx0XHQoY29uZmlnLnRpY2tDZW50ZXJlZCA/IDAgOiBjb25maWcudGlja09mZnNldCk7XHJcblxyXG5cdFx0cmV0dXJuIHJhbmdlWzBdIDwgdGlja1Bvc2l0aW9uICYmIHRpY2tQb3NpdGlvbiA8IHJhbmdlWzFdID8gaW5uZXJUaWNrU2l6ZSA6IDA7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGljaydzIGxpbmUgJiB0ZXh0IHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGxpbmVVcGRhdGUgTGluZSBzZWxlY3Rpb25cclxuXHQgKiBAcGFyYW0ge2QzLnNlbGVjdGlvbn0gdGV4dFVwZGF0ZSBUZXh0IHNlbGVjdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0VGlja0xpbmVUZXh0UG9zaXRpb24obGluZVVwZGF0ZSwgdGV4dFVwZGF0ZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgdGlja1BvcyA9IHRoaXMuZ2V0VGlja1hZKCk7XHJcblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgb3JpZW50LCB0aWNrTGVuZ3RoLCB0aWNrT2Zmc2V0fSA9IHRoaXMuY29uZmlnO1xyXG5cdFx0Y29uc3Qgcm90YXRlID0gdGhpcy5wYXJhbXMudGlja1RleHRSb3RhdGU7XHJcblxyXG5cdFx0Y29uc3QgdGV4dEFuY2hvckZvclRleHQgPSByID0+IHtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBbXCJzdGFydFwiLCBcImVuZFwiXTtcclxuXHJcblx0XHRcdG9yaWVudCA9PT0gXCJ0b3BcIiAmJiB2YWx1ZS5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gIXIgPyBcIm1pZGRsZVwiIDogKHIgPiAwID8gdmFsdWVbMF0gOiB2YWx1ZVsxXSk7XHJcblx0XHR9O1xyXG5cdFx0Y29uc3QgdGV4dFRyYW5zZm9ybSA9IHIgPT4gKHIgPyBgcm90YXRlKCR7cn0pYCA6IG51bGwpO1xyXG5cdFx0Y29uc3QgeUZvclRleHQgPSByID0+IHtcclxuXHRcdFx0Y29uc3QgcjIgPSByIC8gKG9yaWVudCA9PT0gXCJib3R0b21cIiA/IDE1IDogMjMpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHIgPyAxMS41IC0gMi41ICogcjIgKiAociA+IDAgPyAxIDogLTEpIDogdGlja0xlbmd0aDtcclxuXHRcdH07XHJcblxyXG5cdFx0c3dpdGNoIChvcmllbnQpIHtcclxuXHRcdFx0Y2FzZSBcImJvdHRvbVwiOlxyXG5cdFx0XHRcdGxpbmVVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieDFcIiwgdGlja1Bvcy54KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB0aWNrUG9zLngpXHJcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIHRoaXMuZ2V0VGlja1NpemUuYmluZCh0aGlzKSk7XHJcblxyXG5cdFx0XHRcdHRleHRVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCB0ZXh0QW5jaG9yRm9yVGV4dChyb3RhdGUpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdGV4dFRyYW5zZm9ybShyb3RhdGUpKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInRvcFwiOlxyXG5cdFx0XHRcdGxpbmVVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgMClcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgLWlubmVyVGlja1NpemUpO1xyXG5cclxuXHRcdFx0XHR0ZXh0VXBkYXRlXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgMClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCAteUZvclRleHQocm90YXRlKSAqIDIpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCB0ZXh0QW5jaG9yRm9yVGV4dChyb3RhdGUpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdGV4dFRyYW5zZm9ybShyb3RhdGUpKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcImxlZnRcIjpcclxuXHRcdFx0XHRsaW5lVXBkYXRlXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIC1pbm5lclRpY2tTaXplKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB0aWNrUG9zLnkpXHJcblx0XHRcdFx0XHQuYXR0cihcInkyXCIsIHRpY2tQb3MueSk7XHJcblxyXG5cdFx0XHRcdHRleHRVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAtdGlja0xlbmd0aClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB0aWNrT2Zmc2V0KVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIik7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgXCJyaWdodFwiOlxyXG5cdFx0XHRcdGxpbmVVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgaW5uZXJUaWNrU2l6ZSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgMCk7XHJcblxyXG5cdFx0XHRcdHRleHRVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCB0aWNrTGVuZ3RoKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIDApXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcInN0YXJ0XCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gdGhpcyBzaG91bGQgYmUgY2FsbGVkIG9ubHkgd2hlbiBjYXRlZ29yeSBheGlzXHJcblx0c3BsaXRUaWNrVGV4dChkLCBzY2FsZSwgdGlja3MsIGlzTGVmdFJpZ2h0LCBjaGFyV2lkdGgpIHtcclxuXHRcdGNvbnN0IHtwYXJhbXN9ID0gdGhpcztcclxuXHRcdGNvbnN0IHRpY2tUZXh0ID0gdGhpcy5oZWxwZXIudGV4dEZvcm1hdHRlZChkKTtcclxuXHRcdGNvbnN0IHNwbGl0dGVkID0gaXNTdHJpbmcodGlja1RleHQpICYmIHRpY2tUZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSA/XHJcblx0XHRcdHRpY2tUZXh0LnNwbGl0KFwiXFxuXCIpIDogW107XHJcblxyXG5cdFx0aWYgKHNwbGl0dGVkLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkodGlja1RleHQpKSB7XHJcblx0XHRcdHJldHVybiB0aWNrVGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRsZXQgdGlja1dpZHRoID0gcGFyYW1zLnRpY2tXaWR0aDtcclxuXHJcblx0XHRpZiAoIXRpY2tXaWR0aCB8fCB0aWNrV2lkdGggPD0gMCkge1xyXG5cdFx0XHR0aWNrV2lkdGggPSBpc0xlZnRSaWdodCA/IDk1IDogKFxyXG5cdFx0XHRcdHBhcmFtcy5pc0NhdGVnb3J5ID9cclxuXHRcdFx0XHRcdChNYXRoLmNlaWwoc2NhbGUodGlja3NbMV0pIC0gc2NhbGUodGlja3NbMF0pKSAtIDEyKSA6IDExMFxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNwbGl0IGdpdmVuIHRleHQgYnkgdGljayB3aWR0aCBzaXplXHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuXHRcdGZ1bmN0aW9uIHNwbGl0KHNwbGl0dGVkLCB0ZXh0KSB7XHJcblx0XHRcdGxldCBzdWJ0ZXh0O1xyXG5cdFx0XHRsZXQgc3BhY2VJbmRleDtcclxuXHRcdFx0bGV0IHRleHRXaWR0aDtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmICh0ZXh0LmNoYXJBdChpKSA9PT0gXCIgXCIpIHtcclxuXHRcdFx0XHRcdHNwYWNlSW5kZXggPSBpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3VidGV4dCA9IHRleHQuc3Vic3RyKDAsIGkgKyAxKTtcclxuXHRcdFx0XHR0ZXh0V2lkdGggPSBjaGFyV2lkdGggKiBzdWJ0ZXh0Lmxlbmd0aDtcclxuXHJcblx0XHRcdFx0Ly8gaWYgdGV4dCB3aWR0aCBnZXRzIG92ZXIgdGljayB3aWR0aCwgc3BsaXQgYnkgc3BhY2UgaW5kZXggb3IgY3VycmVudCBpbmRleFxyXG5cdFx0XHRcdGlmICh0aWNrV2lkdGggPCB0ZXh0V2lkdGgpIHtcclxuXHRcdFx0XHRcdHJldHVybiBzcGxpdChcclxuXHRcdFx0XHRcdFx0c3BsaXR0ZWQuY29uY2F0KHRleHQuc3Vic3RyKDAsIHNwYWNlSW5kZXggfHwgaSkpLFxyXG5cdFx0XHRcdFx0XHR0ZXh0LnNsaWNlKHNwYWNlSW5kZXggPyBzcGFjZUluZGV4ICsgMSA6IGkpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHNwbGl0dGVkLmNvbmNhdCh0ZXh0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc3BsaXQoc3BsaXR0ZWQsIFN0cmluZyh0aWNrVGV4dCkpO1xyXG5cdH1cclxuXHJcblx0c2NhbGUoeCk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaGVscGVyLnNjYWxlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuaGVscGVyLnNjYWxlID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdG9yaWVudCh4KTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jb25maWcub3JpZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuY29uZmlnLm9yaWVudCA9IHggaW4ge1xyXG5cdFx0XHR0b3A6IDEsXHJcblx0XHRcdHJpZ2h0OiAxLFxyXG5cdFx0XHRib3R0b206IDEsXHJcblx0XHRcdGxlZnQ6IDFcclxuXHRcdH0gPyBTdHJpbmcoeCkgOiBcImJvdHRvbVwiO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0dGlja0Zvcm1hdChmb3JtYXQpOiBBeGlzUmVuZGVyZXIge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tGb3JtYXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tGb3JtYXQgPSBmb3JtYXQ7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHR0aWNrQ2VudGVyZWQoaXNDZW50ZXJlZDogYm9vbGVhbik6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0NlbnRlcmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy50aWNrQ2VudGVyZWQgPSBpc0NlbnRlcmVkO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRpY2sncyBvZmZzZXQgdmFsdWUuXHJcblx0ICogVGhlIHZhbHVlIHdpbGwgYmUgc2V0IGZvciAnY2F0ZWdvcnknIGF4aXMgdHlwZS5cclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dGlja09mZnNldCgpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLnRpY2tPZmZzZXQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGljayBpbnRlcnZhbCBjb3VudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNpemUgVG90YWwgZGF0YSBzaXplXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKi9cclxuXHR0aWNrSW50ZXJ2YWwoc2l6ZTogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGxldCBpbnRlcnZhbDtcclxuXHJcblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRpbnRlcnZhbCA9IHRoaXMuY29uZmlnLnRpY2tPZmZzZXQgKiAyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgbGVuZ3RoID0gdGhpcy5nLnNlbGVjdChcInBhdGguZG9tYWluXCIpXHJcblx0XHRcdFx0Lm5vZGUoKVxyXG5cdFx0XHRcdC5nZXRUb3RhbExlbmd0aCgpIC0gdGhpcy5jb25maWcub3V0ZXJUaWNrU2l6ZSAqIDI7XHJcblxyXG5cdFx0XHRpbnRlcnZhbCA9IGxlbmd0aCAvIChzaXplIHx8IHRoaXMuZy5zZWxlY3RBbGwoXCJsaW5lXCIpLnNpemUoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGludGVydmFsID09PSBJbmZpbml0eSA/IDAgOiBpbnRlcnZhbDtcclxuXHR9XHJcblxyXG5cdHRpY2tzKC4uLmFyZ3MpOiBBeGlzUmVuZGVyZXIge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdGlmICghYXJncy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrQXJndW1lbnRzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy50aWNrQXJndW1lbnRzID0gdG9BcnJheShhcmdzKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tDdWxsaW5nKGN1bGxpbmcpOiBBeGlzUmVuZGVyZXIge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tDdWxsaW5nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy50aWNrQ3VsbGluZyA9IGN1bGxpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHR0aWNrVmFsdWVzKHgpOiBBeGlzUmVuZGVyZXIge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKHgpKSB7XHJcblx0XHRcdGNvbmZpZy50aWNrVmFsdWVzID0gKCkgPT4geCh0aGlzLmhlbHBlci5zY2FsZS5kb21haW4oKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tWYWx1ZXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbmZpZy50aWNrVmFsdWVzID0geDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHNldFRyYW5zaXRpb24odCk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHR0aGlzLmNvbmZpZy50cmFuc2l0aW9uID0gdDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdGF4aXNUb3AgYXMgZDNBeGlzVG9wLFxyXG5cdGF4aXNCb3R0b20gYXMgZDNBeGlzQm90dG9tLFxyXG5cdGF4aXNMZWZ0IGFzIGQzQXhpc0xlZnQsXHJcblx0YXhpc1JpZ2h0IGFzIGQzQXhpc1JpZ2h0XHJcbn0gZnJvbSBcImQzLWF4aXNcIjtcclxuaW1wb3J0IHtzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyfSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuaW1wb3J0IEF4aXNSZW5kZXJlciBmcm9tIFwiLi9BeGlzUmVuZGVyZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhcGl0YWxpemUsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc1ZhbHVlLCBpc0VtcHR5LCBpc051bWJlciwgaXNPYmplY3RUeXBlLCBtZXJnZU9iaiwgbm90RW1wdHksIHBhcnNlRGF0ZSwgc29ydFZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRBeGlzSW5zdGFuY2U6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYXhpcyB8fCBuZXcgQXhpcyh0aGlzKTtcclxuXHR9XHJcbn07XHJcblxyXG5jbGFzcyBBeGlzIHtcclxuXHRwdWJsaWMgb3duZXI7XHJcblxyXG5cdHB1YmxpYyB4O1xyXG5cdHB1YmxpYyBzdWJYO1xyXG5cdHB1YmxpYyB5O1xyXG5cdHB1YmxpYyB5MjtcclxuXHJcblx0cHJpdmF0ZSBheGVzTGlzdCA9IHt9O1xyXG5cdHB1YmxpYyB0aWNrID0ge1xyXG5cdFx0eDogbnVsbCwgeTogbnVsbCwgeTI6IG51bGxcclxuXHR9O1xyXG5cdHB1YmxpYyB4cyA9IFtdO1xyXG5cdHByaXZhdGUgb3JpZW50ID0ge1xyXG5cdFx0eDogXCJib3R0b21cIixcclxuXHRcdHk6IFwibGVmdFwiLFxyXG5cdFx0eTI6IFwicmlnaHRcIixcclxuXHRcdHN1Ylg6IFwiYm90dG9tXCJcclxuXHR9O1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihvd25lcikge1xyXG5cdFx0dGhpcy5vd25lciA9IG93bmVyO1xyXG5cdFx0dGhpcy5zZXRPcmllbnQoKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgZ2V0QXhpc0NsYXNzTmFtZShpZCkge1xyXG5cdFx0cmV0dXJuIGAke0NMQVNTLmF4aXN9ICR7Q0xBU1NbYGF4aXMke2NhcGl0YWxpemUoaWQpfWBdfWA7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGlzSG9yaXpvbnRhbCgkJCwgZm9ySG9yaXpvbnRhbCkge1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNDYXRlZ29yaXplZCgpIHtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9IHRoaXMub3duZXI7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfdHlwZS5pbmRleE9mKFwiY2F0ZWdvcnlcIikgPj0gMCB8fCBzdGF0ZS5oYXNSYWRhcjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBpc0N1c3RvbVgoKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXMub3duZXI7XHJcblxyXG5cdFx0cmV0dXJuICF0aGlzLmlzVGltZVNlcmllcygpICYmIChjb25maWcuZGF0YV94IHx8IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNUaW1lU2VyaWVzKGlkID0gXCJ4XCIpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcy5vd25lcjtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnW2BheGlzXyR7aWR9X3R5cGVgXSA9PT0gXCJ0aW1lc2VyaWVzXCI7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgaXNUaW1lU2VyaWVzWSgpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVGltZVNlcmllcyhcInlcIik7XHJcblx0fVxyXG5cclxuXHRpbml0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbiwgYXhpc30sIHN0YXRlOiB7Y2xpcH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gW1wieFwiLCBcInlcIl07XHJcblxyXG5cdFx0Y29uZmlnLmF4aXNfeTJfc2hvdyAmJiB0YXJnZXQucHVzaChcInkyXCIpO1xyXG5cclxuXHRcdHRhcmdldC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRjb25zdCBjbGFzc0F4aXMgPSB0aGlzLmdldEF4aXNDbGFzc05hbWUodik7XHJcblx0XHRcdGNvbnN0IGNsYXNzTGFiZWwgPSBDTEFTU1tgYXhpcyR7di50b1VwcGVyQ2FzZSgpfUxhYmVsYF07XHJcblxyXG5cdFx0XHRheGlzW3ZdID0gbWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0F4aXMpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IHJlcyA9IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHYgPT09IFwieFwiKSB7XHJcblx0XHRcdFx0XHRcdHJlcyA9IGNsaXAucGF0aFhBeGlzO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICh2ID09PSBcInlcIiAmJiBjb25maWcuYXhpc195X2lubmVyKSB7XHJcblx0XHRcdFx0XHRcdHJlcyA9IGNsaXAucGF0aFlBeGlzO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiByZXM7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUodikpXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWdbYGF4aXNfJHt2fV9zaG93YF0gPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpO1xyXG5cclxuXHRcdFx0YXhpc1t2XS5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xhYmVsKVxyXG5cdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIFtcInJvdGF0ZSgtOTApXCIsIG51bGxdW1xyXG5cdFx0XHRcdFx0diA9PT0gXCJ4XCIgPyArIWlzUm90YXRlZCA6ICtpc1JvdGF0ZWRcclxuXHRcdFx0XHRdKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsICgpID0+IHRoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCh2KSk7XHJcblxyXG5cdFx0XHR0aGlzLmdlbmVyYXRlQXhlcyh2KTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGF4aXMgb3JpZW50IGFjY29yZGluZyBvcHRpb24gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldE9yaWVudCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtcclxuXHRcdFx0YXhpc19yb3RhdGVkOiBpc1JvdGF0ZWQsXHJcblx0XHRcdGF4aXNfeV9pbm5lcjogeUlubmVyLFxyXG5cdFx0XHRheGlzX3kyX2lubmVyOiB5MklubmVyXHJcblx0XHR9ID0gJCQuY29uZmlnO1xyXG5cclxuXHRcdHRoaXMub3JpZW50ID0ge1xyXG5cdFx0XHR4OiBpc1JvdGF0ZWQgPyBcImxlZnRcIiA6IFwiYm90dG9tXCIsXHJcblx0XHRcdHk6IGlzUm90YXRlZCA/ICh5SW5uZXIgPyBcInRvcFwiIDogXCJib3R0b21cIikgOiAoeUlubmVyID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpLFxyXG5cdFx0XHR5MjogaXNSb3RhdGVkID8gKHkySW5uZXIgPyBcImJvdHRvbVwiIDogXCJ0b3BcIikgOiAoeTJJbm5lciA/IFwibGVmdFwiIDogXCJyaWdodFwiKSxcclxuXHRcdFx0c3ViWDogaXNSb3RhdGVkID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgYXhlc1xyXG5cdCAqIEl0J3MgdXNlZCB3aGVuIGF4aXMnIGF4ZXMgb3B0aW9uIGlzIHNldFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZUF4ZXMoaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGF4ZXM6IGFueVtdID0gW107XHJcblx0XHRjb25zdCBheGVzQ29uZmlnID0gY29uZmlnW2BheGlzXyR7aWR9X2F4ZXNgXTtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgZDNBeGlzO1xyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ4XCIpIHtcclxuXHRcdFx0ZDNBeGlzID0gaXNSb3RhdGVkID8gZDNBeGlzTGVmdCA6IGQzQXhpc0JvdHRvbTtcclxuXHRcdH0gZWxzZSBpZiAoaWQgPT09IFwieVwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc0JvdHRvbSA6IGQzQXhpc0xlZnQ7XHJcblx0XHR9IGVsc2UgaWYgKGlkID09PSBcInkyXCIpIHtcclxuXHRcdFx0ZDNBeGlzID0gaXNSb3RhdGVkID8gZDNBeGlzVG9wIDogZDNBeGlzUmlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF4ZXNDb25maWcubGVuZ3RoKSB7XHJcblx0XHRcdGF4ZXNDb25maWcuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB0aWNrID0gdi50aWNrIHx8IHt9O1xyXG5cdFx0XHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGVbaWRdLmNvcHkoKTtcclxuXHJcblx0XHRcdFx0di5kb21haW4gJiYgc2NhbGUuZG9tYWluKHYuZG9tYWluKTtcclxuXHJcblx0XHRcdFx0YXhlcy5wdXNoKFxyXG5cdFx0XHRcdFx0ZDNBeGlzKHNjYWxlKVxyXG5cdFx0XHRcdFx0XHQudGlja3ModGljay5jb3VudClcclxuXHRcdFx0XHRcdFx0LnRpY2tGb3JtYXQoaXNGdW5jdGlvbih0aWNrLmZvcm1hdCkgPyB0aWNrLmZvcm1hdC5iaW5kKCQkLmFwaSkgOiAoKHg6IGFueSkgPT4geCkpXHJcblx0XHRcdFx0XHRcdC50aWNrVmFsdWVzKHRpY2sudmFsdWVzKVxyXG5cdFx0XHRcdFx0XHQudGlja1NpemVPdXRlcih0aWNrLm91dGVyID09PSBmYWxzZSA/IDAgOiA2KVxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYXhlc0xpc3RbaWRdID0gYXhlcztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBheGVzIG5vZGVzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVBeGVzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0T2JqZWN0LmtleXModGhpcy5heGVzTGlzdCkuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGNvbnN0IGF4ZXNDb25maWcgPSBjb25maWdbYGF4aXNfJHtpZH1fYXhlc2BdO1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlW2lkXS5jb3B5KCk7XHJcblx0XHRcdGNvbnN0IHJhbmdlID0gc2NhbGUucmFuZ2UoKTtcclxuXHJcblx0XHRcdHRoaXMuYXhlc0xpc3RbaWRdLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRjb25zdCBheGlzUmFuZ2UgPSB2LnNjYWxlKCkucmFuZ2UoKTtcclxuXHJcblx0XHRcdFx0Ly8gYWRqdXN0IHJhbmdlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnRcclxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy84NTlcclxuXHRcdFx0XHRpZiAoIXJhbmdlLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBheGlzUmFuZ2VbaV0pKSB7XHJcblx0XHRcdFx0XHR2LnNjYWxlKCkucmFuZ2UocmFuZ2UpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgY2xhc3NOYW1lID0gYCR7dGhpcy5nZXRBeGlzQ2xhc3NOYW1lKGlkKX0tJHtpICsgMX1gO1xyXG5cdFx0XHRcdGxldCBnID0gbWFpbi5zZWxlY3QoYC4ke2NsYXNzTmFtZS5yZXBsYWNlKC9cXHMvLCBcIi5cIil9YCk7XHJcblxyXG5cdFx0XHRcdGlmIChnLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRcdGcgPSBtYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc05hbWUpXHJcblx0XHRcdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnW2BheGlzXyR7aWR9X3Nob3dgXSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIilcclxuXHRcdFx0XHRcdFx0LmNhbGwodik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGF4ZXNDb25maWdbaV0uZG9tYWluICYmIHNjYWxlLmRvbWFpbihheGVzQ29uZmlnW2ldLmRvbWFpbik7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy54LmhlbHBlci50cmFuc2l0aW9uaXNlKGcpXHJcblx0XHRcdFx0XHRcdC5jYWxsKHYuc2NhbGUoc2NhbGUpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGcuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoaWQsIGkgKyAxKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgQXhpcyAmIHRpY2sgdmFsdWVzXHJcblx0ICogY2FsbGVkIGZyb206IHVwZGF0ZVNjYWxlcygpXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIEF4aXMgaWQgc3RyaW5nXHJcblx0ICogQHBhcmFtIHtBcnJheX0gYXJncyBBcmd1bWVudHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEF4aXMoaWQsIC4uLmFyZ3MpOiB2b2lkIHtcclxuXHRcdGlmIChpZCAhPT0gXCJzdWJYXCIpIHtcclxuXHRcdFx0dGhpcy50aWNrW2lkXSA9IHRoaXMuZ2V0VGlja1ZhbHVlcyhpZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0dGhpc1tpZF0gPSB0aGlzLmdldEF4aXMoaWQsIC4uLmFyZ3MpO1xyXG5cdH1cclxuXHJcblx0Ly8gY2FsbGVkIGZyb20gOiBnZXRNYXhUaWNrV2lkdGgoKVxyXG5cdGdldEF4aXMoaWQsIHNjYWxlLCBvdXRlclRpY2ssIG5vVHJhbnNpdGlvbiwgbm9UaWNrVGV4dFJvdGF0ZSk6IEF4aXNSZW5kZXJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNYID0gL14oeHxzdWJYKSQvLnRlc3QoaWQpO1xyXG5cdFx0Y29uc3QgdHlwZSA9IGlzWCA/IFwieFwiIDogaWQ7XHJcblxyXG5cdFx0Y29uc3QgaXNDYXRlZ29yeSA9IGlzWCAmJiB0aGlzLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHRcdGNvbnN0IG9yaWVudCA9IHRoaXMub3JpZW50W2lkXTtcclxuXHRcdGNvbnN0IHRpY2tUZXh0Um90YXRlID0gbm9UaWNrVGV4dFJvdGF0ZSA/IDAgOiAkJC5nZXRBeGlzVGlja1JvdGF0ZSh0eXBlKTtcclxuXHRcdGxldCB0aWNrRm9ybWF0O1xyXG5cclxuXHRcdGlmIChpc1gpIHtcclxuXHRcdFx0dGlja0Zvcm1hdCA9ICQkLmZvcm1hdC54QXhpc1RpY2s7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBmbiA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2Zvcm1hdGBdO1xyXG5cclxuXHRcdFx0aWYgKGlzRnVuY3Rpb24oZm4pKSB7XHJcblx0XHRcdFx0dGlja0Zvcm1hdCA9IGZuLmJpbmQoJCQuYXBpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0aWNrVmFsdWVzID0gdGhpcy50aWNrW3R5cGVdO1xyXG5cclxuXHRcdGNvbnN0IGF4aXNQYXJhbXMgPSBtZXJnZU9iaih7XHJcblx0XHRcdG91dGVyVGljayxcclxuXHRcdFx0bm9UcmFuc2l0aW9uLFxyXG5cdFx0XHRjb25maWcsXHJcblx0XHRcdGlkLFxyXG5cdFx0XHR0aWNrVGV4dFJvdGF0ZVxyXG5cdFx0fSwgaXNYICYmIHtcclxuXHRcdFx0aXNDYXRlZ29yeSxcclxuXHRcdFx0dGlja011bHRpbGluZTogY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSxcclxuXHRcdFx0dGlja1dpZHRoOiBjb25maWcuYXhpc194X3RpY2tfd2lkdGgsXHJcblx0XHRcdHRpY2tUaXRsZTogaXNDYXRlZ29yeSAmJiBjb25maWcuYXhpc194X3RpY2tfdG9vbHRpcCAmJiAkJC5hcGkuY2F0ZWdvcmllcygpLFxyXG5cdFx0XHRvcmdYU2NhbGU6ICQkLnNjYWxlLnhcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmICghaXNYKSB7XHJcblx0XHRcdGF4aXNQYXJhbXMudGlja1N0ZXBTaXplID0gY29uZmlnW2BheGlzXyR7dHlwZX1fdGlja19zdGVwU2l6ZWBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGF4aXMgPSBuZXcgQXhpc1JlbmRlcmVyKGF4aXNQYXJhbXMpXHJcblx0XHRcdC5zY2FsZSgoaXNYICYmICQkLnNjYWxlLnpvb20pIHx8IHNjYWxlKVxyXG5cdFx0XHQub3JpZW50KG9yaWVudCk7XHJcblxyXG5cdFx0aWYgKGlzWCAmJiB0aGlzLmlzVGltZVNlcmllcygpICYmIHRpY2tWYWx1ZXMgJiYgIWlzRnVuY3Rpb24odGlja1ZhbHVlcykpIHtcclxuXHRcdFx0Y29uc3QgZm4gPSBwYXJzZURhdGUuYmluZCgkJCk7XHJcblxyXG5cdFx0XHR0aWNrVmFsdWVzID0gdGlja1ZhbHVlcy5tYXAodiA9PiBmbih2KSk7XHJcblx0XHR9IGVsc2UgaWYgKCFpc1ggJiYgdGhpcy5pc1RpbWVTZXJpZXNZKCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2Jsb2IvbWFzdGVyL0NIQU5HRVMubWQjdGltZS1pbnRlcnZhbHMtZDMtdGltZVxyXG5cdFx0XHRheGlzLnRpY2tzKGNvbmZpZy5heGlzX3lfdGlja190aW1lX3ZhbHVlKTtcclxuXHRcdFx0dGlja1ZhbHVlcyA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dGlja1ZhbHVlcyAmJiBheGlzLnRpY2tWYWx1ZXModGlja1ZhbHVlcyk7XHJcblxyXG5cdFx0Ly8gU2V0IHRpY2tcclxuXHRcdGF4aXMudGlja0Zvcm1hdChcclxuXHRcdFx0dGlja0Zvcm1hdCB8fCAoXHJcblx0XHRcdFx0IWlzWCAmJiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAoeCA9PiBgJHt4fSVgKSlcclxuXHRcdFx0KVxyXG5cdFx0KTtcclxuXHJcblx0XHRpZiAoaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRheGlzLnRpY2tDZW50ZXJlZChjb25maWcuYXhpc194X3RpY2tfY2VudGVyZWQpO1xyXG5cclxuXHRcdFx0aWYgKGlzRW1wdHkoY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcpKSB7XHJcblx0XHRcdFx0Y29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRpY2tDb3VudCA9IGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfY291bnRgXTtcclxuXHJcblx0XHR0aWNrQ291bnQgJiYgYXhpcy50aWNrcyh0aWNrQ291bnQpO1xyXG5cclxuXHRcdHJldHVybiBheGlzO1xyXG5cdH1cclxuXHJcblx0dXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHMsIGF4aXM/KTogc3RyaW5nW10ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGZpdCA9IGNvbmZpZy5heGlzX3hfdGlja19maXQ7XHJcblx0XHRsZXQgY291bnQgPSBjb25maWcuYXhpc194X3RpY2tfY291bnQ7XHJcblx0XHRsZXQgdmFsdWVzO1xyXG5cclxuXHRcdGlmIChmaXQgfHwgKGNvdW50ICYmIGZpdCkpIHtcclxuXHRcdFx0dmFsdWVzID0gJCQubWFwVGFyZ2V0c1RvVW5pcXVlWHModGFyZ2V0cyk7XHJcblxyXG5cdFx0XHQvLyBpZiBnaXZlbiBjb3VudCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIGxlbmd0aCwgdGhlbiBsaW1pdCB0aGUgY291bnQuXHJcblx0XHRcdGlmICh0aGlzLmlzQ2F0ZWdvcml6ZWQoKSAmJiBjb3VudCA+IHZhbHVlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRjb3VudCA9IHZhbHVlcy5sZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdHZhbHVlcyxcclxuXHRcdFx0XHRjb3VudCxcclxuXHRcdFx0XHR0aGlzLmlzVGltZVNlcmllcygpXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF4aXMpIHtcclxuXHRcdFx0YXhpcy50aWNrVmFsdWVzKHZhbHVlcyk7XHJcblx0XHR9IGVsc2UgaWYgKHRoaXMueCkge1xyXG5cdFx0XHR0aGlzLngudGlja1ZhbHVlcyh2YWx1ZXMpO1xyXG5cdFx0XHR0aGlzLnN1YlggJiYgdGhpcy5zdWJYLnRpY2tWYWx1ZXModmFsdWVzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH1cclxuXHJcblx0Z2V0SWQoaWQ6IHN0cmluZyk6IHN0cmluZyB7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSB0aGlzLm93bmVyO1xyXG5cdFx0bGV0IGF4aXMgPSBjb25maWcuZGF0YV9heGVzW2lkXTtcclxuXHJcblx0XHQvLyB3aGVuIGRhdGEuYXhlcyBvcHRpb24gaGFzICd5MicsIGJ1dCAnYXhpcy55Mi5zaG93PXRydWUnIGlzbid0IHNldCB3aWxsIHJldHVybiAneSdcclxuXHRcdGlmICghYXhpcyB8fCAhc2NhbGVbYXhpc10pIHtcclxuXHRcdFx0YXhpcyA9IFwieVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBheGlzO1xyXG5cdH1cclxuXHJcblx0Z2V0WEF4aXNUaWNrRm9ybWF0KCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIGZvcm1hdH0gPSAkJDtcclxuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSBjb25maWcuYXhpc194X3RpY2tfZm9ybWF0O1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gdGhpcy5pc1RpbWVTZXJpZXMoKTtcclxuXHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSB0aGlzLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHRcdGxldCBjdXJyRm9ybWF0O1xyXG5cclxuXHRcdGlmICh0aWNrRm9ybWF0KSB7XHJcblx0XHRcdGlmIChpc0Z1bmN0aW9uKHRpY2tGb3JtYXQpKSB7XHJcblx0XHRcdFx0Y3VyckZvcm1hdCA9IHRpY2tGb3JtYXQuYmluZCgkJC5hcGkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRcdGN1cnJGb3JtYXQgPSBkYXRlID0+IChkYXRlID8gZm9ybWF0LmF4aXNUaW1lKHRpY2tGb3JtYXQpKGRhdGUpIDogXCJcIik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN1cnJGb3JtYXQgPSBpc1RpbWVTZXJpZXMgPyBmb3JtYXQuZGVmYXVsdEF4aXNUaW1lIDogKFxyXG5cdFx0XHRcdGlzQ2F0ZWdvcml6ZWQgP1xyXG5cdFx0XHRcdFx0JCQuY2F0ZWdvcnlOYW1lIDogdiA9PiAodiA8IDAgPyB2LnRvRml4ZWQoMCkgOiB2KVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGN1cnJGb3JtYXQpID8gdiA9PlxyXG5cdFx0XHRjdXJyRm9ybWF0LmFwcGx5KCQkLCBpc0NhdGVnb3JpemVkID9cclxuXHRcdFx0XHRbdiwgJCQuY2F0ZWdvcnlOYW1lKHYpXSA6IFt2XVxyXG5cdFx0XHQpIDogY3VyckZvcm1hdDtcclxuXHR9XHJcblxyXG5cdGdldFRpY2tWYWx1ZXMoaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3QgdGlja1ZhbHVlcyA9ICQkLmNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3ZhbHVlc2BdO1xyXG5cdFx0Y29uc3QgYXhpcyA9ICQkW2Ake2lkfUF4aXNgXTtcclxuXHJcblx0XHRyZXR1cm4gKGlzRnVuY3Rpb24odGlja1ZhbHVlcykgPyB0aWNrVmFsdWVzLmNhbGwoJCQuYXBpKSA6IHRpY2tWYWx1ZXMpIHx8XHJcblx0XHRcdChheGlzID8gYXhpcy50aWNrVmFsdWVzKCkgOiB1bmRlZmluZWQpO1xyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vd25lci5jb25maWdbYGF4aXNfJHtpZH1fbGFiZWxgXTtcclxuXHR9XHJcblxyXG5cdGdldExhYmVsVGV4dChpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xyXG5cclxuXHRcdHJldHVybiBpc1N0cmluZyhvcHRpb24pID8gb3B0aW9uIDogKFxyXG5cdFx0XHRvcHRpb24gPyBvcHRpb24udGV4dCA6IG51bGxcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRzZXRMYWJlbFRleHQoaWQ6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcclxuXHJcblx0XHRpZiAoaXNTdHJpbmcob3B0aW9uKSkge1xyXG5cdFx0XHRjb25maWdbYGF4aXNfJHtpZH1fbGFiZWxgXSA9IHRleHQ7XHJcblx0XHR9IGVsc2UgaWYgKG9wdGlvbikge1xyXG5cdFx0XHRvcHRpb24udGV4dCA9IHRleHQ7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXRMYWJlbFBvc2l0aW9uKGlkOiBzdHJpbmcsIGRlZmF1bHRQb3NpdGlvbikge1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gdGhpcy5vd25lci5jb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3Qgb3B0aW9uID0gdGhpcy5nZXRMYWJlbE9wdGlvbkJ5QXhpc0lkKGlkKTtcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gKGlzT2JqZWN0VHlwZShvcHRpb24pICYmIG9wdGlvbi5wb3NpdGlvbikgP1xyXG5cdFx0XHRvcHRpb24ucG9zaXRpb24gOiBkZWZhdWx0UG9zaXRpb25bKyFpc1JvdGF0ZWRdO1xyXG5cclxuXHRcdGNvbnN0IGhhcyA9IHYgPT4gISF+cG9zaXRpb24uaW5kZXhPZih2KTtcclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRpc0lubmVyOiBoYXMoXCJpbm5lclwiKSxcclxuXHRcdFx0aXNPdXRlcjogaGFzKFwib3V0ZXJcIiksXHJcblx0XHRcdGlzTGVmdDogaGFzKFwibGVmdFwiKSxcclxuXHRcdFx0aXNDZW50ZXI6IGhhcyhcImNlbnRlclwiKSxcclxuXHRcdFx0aXNSaWdodDogaGFzKFwicmlnaHRcIiksXHJcblx0XHRcdGlzVG9wOiBoYXMoXCJ0b3BcIiksXHJcblx0XHRcdGlzTWlkZGxlOiBoYXMoXCJtaWRkbGVcIiksXHJcblx0XHRcdGlzQm90dG9tOiBoYXMoXCJib3R0b21cIilcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRnZXRBeGlzTGFiZWxQb3NpdGlvbihpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKGlkLCBpZCA9PT0gXCJ4XCIgPyBbXCJpbm5lci10b3BcIiwgXCJpbm5lci1yaWdodFwiXSA6IFtcImlubmVyLXJpZ2h0XCIsIFwiaW5uZXItdG9wXCJdKTtcclxuXHR9XHJcblxyXG5cdGdldExhYmVsUG9zaXRpb25CeUlkKGlkOiBzdHJpbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldEF4aXNMYWJlbFBvc2l0aW9uKGlkKTtcclxuXHR9XHJcblxyXG5cdHhGb3JBeGlzTGFiZWwoaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7d2lkdGgsIGhlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBwb3NpdGlvbiA9IHRoaXMuZ2V0QXhpc0xhYmVsUG9zaXRpb24oaWQpO1xyXG5cdFx0bGV0IHggPSBwb3NpdGlvbi5pc01pZGRsZSA/IC1oZWlnaHQgLyAyIDogMDtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGlkICE9PSBcInhcIikpIHtcclxuXHRcdFx0eCA9IHBvc2l0aW9uLmlzTGVmdCA/IDAgOiAoXHJcblx0XHRcdFx0cG9zaXRpb24uaXNDZW50ZXIgPyB3aWR0aCAvIDIgOiB3aWR0aFxyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc0JvdHRvbSkge1xyXG5cdFx0XHR4ID0gLWhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblxyXG5cdGR4Rm9yQXhpc0xhYmVsKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihpZCk7XHJcblx0XHRsZXQgZHggPSBwb3NpdGlvbi5pc0JvdHRvbSA/IFwiMC41ZW1cIiA6IFwiMFwiO1xyXG5cclxuXHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgkJCwgaWQgIT09IFwieFwiKSkge1xyXG5cdFx0XHRkeCA9IHBvc2l0aW9uLmlzTGVmdCA/IFwiMC41ZW1cIiA6IChcclxuXHRcdFx0XHRwb3NpdGlvbi5pc1JpZ2h0ID8gXCItMC41ZW1cIiA6IFwiMFwiXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzVG9wKSB7XHJcblx0XHRcdGR4ID0gXCItMC41ZW1cIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZHg7XHJcblx0fVxyXG5cclxuXHR0ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gdGhpcy5nZXRBeGlzTGFiZWxQb3NpdGlvbihpZCk7XHJcblx0XHRsZXQgYW5jaG9yID0gcG9zaXRpb24uaXNNaWRkbGUgPyBcIm1pZGRsZVwiIDogXCJlbmRcIjtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGlkICE9PSBcInhcIikpIHtcclxuXHRcdFx0YW5jaG9yID0gcG9zaXRpb24uaXNMZWZ0ID8gXCJzdGFydFwiIDogKFxyXG5cdFx0XHRcdHBvc2l0aW9uLmlzQ2VudGVyID8gXCJtaWRkbGVcIiA6IFwiZW5kXCJcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNCb3R0b20pIHtcclxuXHRcdFx0YW5jaG9yID0gXCJzdGFydFwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhbmNob3I7XHJcblx0fVxyXG5cclxuXHRkeUZvckF4aXNMYWJlbChpZDogc3RyaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGlzSW5uZXIgPSB0aGlzLmdldEF4aXNMYWJlbFBvc2l0aW9uKGlkKS5pc0lubmVyO1xyXG5cdFx0Y29uc3QgdGlja1JvdGF0ZSA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3JvdGF0ZWBdID8gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQpIDogMDtcclxuXHRcdGNvbnN0IG1heFRpY2tXaWR0aCA9IHRoaXMuZ2V0TWF4VGlja1dpZHRoKGlkKTtcclxuXHRcdGxldCBkeTtcclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiKSB7XHJcblx0XHRcdGNvbnN0IHhIZWlnaHQgPSBjb25maWcuYXhpc194X2hlaWdodDtcclxuXHJcblx0XHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0XHRkeSA9IGlzSW5uZXIgPyBcIjEuMmVtXCIgOiAtMjUgLSBtYXhUaWNrV2lkdGg7XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNJbm5lcikge1xyXG5cdFx0XHRcdGR5ID0gXCItMC41ZW1cIjtcclxuXHRcdFx0fSBlbHNlIGlmICh4SGVpZ2h0KSB7XHJcblx0XHRcdFx0ZHkgPSB4SGVpZ2h0IC0gMTA7XHJcblx0XHRcdH0gZWxzZSBpZiAodGlja1JvdGF0ZSkge1xyXG5cdFx0XHRcdGR5ID0gdGlja1JvdGF0ZSAtIDEwO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGR5ID0gXCIzZW1cIjtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZHkgPSB7XHJcblx0XHRcdFx0eTogW1wiLTAuNWVtXCIsIDEwLCBcIjNlbVwiLCBcIjEuMmVtXCIsIDEwXSxcclxuXHRcdFx0XHR5MjogW1wiMS4yZW1cIiwgLTIwLCBcIi0yLjJlbVwiLCBcIi0wLjVlbVwiLCAxNV1cclxuXHRcdFx0fVtpZF07XHJcblxyXG5cdFx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdFx0aWYgKGlzSW5uZXIpIHtcclxuXHRcdFx0XHRcdGR5ID0gZHlbMF07XHJcblx0XHRcdFx0fSBlbHNlIGlmICh0aWNrUm90YXRlKSB7XHJcblx0XHRcdFx0XHRkeSA9IHRpY2tSb3RhdGUgKiAoaWQgPT09IFwieTJcIiA/IC0xIDogMSkgLSBkeVsxXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZHkgPSBkeVsyXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZHkgPSBpc0lubmVyID9cclxuXHRcdFx0XHRcdGR5WzNdIDogKFxyXG5cdFx0XHRcdFx0XHRkeVs0XSArIChcclxuXHRcdFx0XHRcdFx0XHRjb25maWdbYGF4aXNfJHtpZH1faW5uZXJgXSA/IDAgOiAobWF4VGlja1dpZHRoICsgZHlbNF0pXHJcblx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdCkgKiAoaWQgPT09IFwieVwiID8gLTEgOiAxKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkeTtcclxuXHR9XHJcblxyXG5cdGdldE1heFRpY2tXaWR0aChpZDogc3RyaW5nLCB3aXRob3V0UmVjb21wdXRlPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2N1cnJlbnR9LCAkZWw6IHtzdmcsIGNoYXJ0fX0gPSAkJDtcclxuXHRcdGNvbnN0IGN1cnJlbnRUaWNrTWF4ID0gY3VycmVudC5tYXhUaWNrV2lkdGhzW2lkXTtcclxuXHRcdGxldCBtYXhXaWR0aCA9IDA7XHJcblxyXG5cdFx0aWYgKHdpdGhvdXRSZWNvbXB1dGUgfHwgIWNvbmZpZ1tgYXhpc18ke2lkfV9zaG93YF0gfHwgJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygpLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRyZXR1cm4gY3VycmVudFRpY2tNYXguc2l6ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3ZnKSB7XHJcblx0XHRcdGNvbnN0IGlzWUF4aXMgPSAvXnkyPyQvLnRlc3QoaWQpO1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlW2lkXS5jb3B5KCkuZG9tYWluKCQkW2BnZXQke2lzWUF4aXMgPyBcIllcIiA6IFwiWFwifURvbWFpbmBdKHRhcmdldHNUb1Nob3csIGlkKSk7XHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xyXG5cclxuXHRcdFx0Ly8gZG8gbm90IGNvbXB1dGUgaWYgZG9tYWluIGlzIHNhbWVcclxuXHRcdFx0aWYgKGRvbWFpblswXSA9PT0gZG9tYWluWzFdIHx8XHJcblx0XHRcdFx0KGlzQXJyYXkoY3VycmVudFRpY2tNYXguZG9tYWluKSAmJiBjdXJyZW50VGlja01heC5kb21haW5bMF0gPT09IGN1cnJlbnRUaWNrTWF4LmRvbWFpblsxXSlcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3VycmVudFRpY2tNYXguZG9tYWluID0gZG9tYWluO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBheGlzID0gdGhpcy5nZXRBeGlzKGlkLCBzY2FsZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcclxuXHRcdFx0Y29uc3QgdGlja0NvdW50ID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY291bnRgXTtcclxuXHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX3ZhbHVlc2BdO1xyXG5cclxuXHRcdFx0Ly8gTWFrZSB0byBnZW5lcmF0ZSB0aGUgZmluYWwgdGljayB0ZXh0IHRvIGJlIHJlbmRlcmVkXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzkyMFxyXG5cdFx0XHQvLyBEbyBub3QgZ2VuZXJhdGUgaWYgJ3RpY2sgdmFsdWVzJyBvcHRpb24gaXMgZ2l2ZW5cclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvMTI1MVxyXG5cdFx0XHRpZiAoIXRpY2tWYWx1ZXMgJiYgdGlja0NvdW50KSB7XHJcblx0XHRcdFx0YXhpcy50aWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0dGhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXMoXHJcblx0XHRcdFx0XHRcdGRvbWFpbixcclxuXHRcdFx0XHRcdFx0dGlja0NvdW50LFxyXG5cdFx0XHRcdFx0XHRpc1lBeGlzID8gdGhpcy5pc1RpbWVTZXJpZXNZKCkgOiB0aGlzLmlzVGltZVNlcmllcygpXHJcblx0XHRcdFx0XHQpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0IWlzWUF4aXMgJiYgdGhpcy51cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0c1RvU2hvdywgYXhpcyk7XHJcblxyXG5cdFx0XHRjb25zdCBkdW1teSA9IGNoYXJ0LmFwcGVuZChcInN2Z1wiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0XHQuc3R5bGUoXCJwb3NpdGlvblwiLCBcImZpeGVkXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidG9wXCIsIFwiMHB4XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwibGVmdFwiLCBcIjBweFwiKTtcclxuXHJcblx0XHRcdGF4aXMuY3JlYXRlKGR1bW15KTtcclxuXHJcblx0XHRcdGR1bW15LnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0XHRjb25zdCBjdXJyZW50VGV4dFdpZHRoID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcclxuXHJcblx0XHRcdFx0XHRtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBjdXJyZW50VGV4dFdpZHRoKTtcclxuXHRcdFx0XHRcdC8vIGNhY2hlIHRpY2sgdGV4dCB3aWR0aCBmb3IgZ2V0WEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3coKVxyXG5cdFx0XHRcdFx0aWYgKGlkID09PSBcInhcIikge1xyXG5cdFx0XHRcdFx0XHRjdXJyZW50VGlja01heC50aWNrc1tpXSA9IGN1cnJlbnRUZXh0V2lkdGg7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRkdW1teS5yZW1vdmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWF4V2lkdGggPiAwKSB7XHJcblx0XHRcdGN1cnJlbnRUaWNrTWF4LnNpemUgPSBtYXhXaWR0aDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY3VycmVudFRpY2tNYXguc2l6ZTtcclxuXHR9XHJcblxyXG5cdGdldFhBeGlzVGlja1RleHRZMk92ZXJmbG93KGRlZmF1bHRQYWRkaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHhBeGlzVGlja1JvdGF0ZSA9ICQkLmdldEF4aXNUaWNrUm90YXRlKFwieFwiKTtcclxuXHRcdGNvbnN0IHBvc2l0aXZlUm90YXRpb24gPSB4QXhpc1RpY2tSb3RhdGUgPiAwICYmIHhBeGlzVGlja1JvdGF0ZSA8IDkwO1xyXG5cclxuXHRcdGlmICgoYXhpcy5pc0NhdGVnb3JpemVkKCkgfHwgYXhpcy5pc1RpbWVTZXJpZXMoKSkgJiZcclxuXHRcdFx0Y29uZmlnLmF4aXNfeF90aWNrX2ZpdCAmJlxyXG5cdFx0XHQhY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgJiZcclxuXHRcdFx0IWNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUgJiZcclxuXHRcdFx0cG9zaXRpdmVSb3RhdGlvblxyXG5cdFx0KSB7XHJcblx0XHRcdGNvbnN0IHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCA9IHN0YXRlLmN1cnJlbnQud2lkdGggLSAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKTtcclxuXHRcdFx0Y29uc3QgbWF4T3ZlcmZsb3cgPSB0aGlzLmdldFhBeGlzVGlja01heE92ZXJmbG93KFxyXG5cdFx0XHRcdHhBeGlzVGlja1JvdGF0ZSwgd2lkdGhXaXRob3V0Q3VycmVudFBhZGRpbmdMZWZ0IC0gZGVmYXVsdFBhZGRpbmdcclxuXHRcdFx0KTtcclxuXHRcdFx0Y29uc3QgeEF4aXNUaWNrVGV4dFkyT3ZlcmZsb3cgPSBNYXRoLm1heCgwLCBtYXhPdmVyZmxvdykgK1xyXG5cdFx0XHRcdGRlZmF1bHRQYWRkaW5nOyAvLyBmb3IgZGlzcGxheSBpbmNvbnNpc3RlbmNpZXMgYmV0d2VlbiBicm93c2Vyc1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgubWluKHhBeGlzVGlja1RleHRZMk92ZXJmbG93LCB3aWR0aFdpdGhvdXRDdXJyZW50UGFkZGluZ0xlZnQgLyAyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHR9XHJcblxyXG5cdGdldFhBeGlzVGlja01heE92ZXJmbG93KHhBeGlzVGlja1JvdGF0ZSwgd2lkdGhXaXRob3V0Q3VycmVudFBhZGRpbmdMZWZ0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVGltZVNlcmllcyA9IGF4aXMuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0Y29uc3QgdGlja1RleHRXaWR0aHMgPSBzdGF0ZS5jdXJyZW50Lm1heFRpY2tXaWR0aHMueC50aWNrcztcclxuXHRcdGNvbnN0IHRpY2tDb3VudCA9IHRpY2tUZXh0V2lkdGhzLmxlbmd0aDtcclxuXHRcdGNvbnN0IHtsZWZ0LCByaWdodH0gPSBzdGF0ZS5heGlzLngucGFkZGluZztcclxuXHRcdGxldCBtYXhPdmVyZmxvdyA9IDA7XHJcblxyXG5cdFx0Y29uc3QgcmVtYWluaW5nID0gdGlja0NvdW50IC0gKGlzVGltZVNlcmllcyAmJiBjb25maWcuYXhpc194X3RpY2tfZml0ID8gMC41IDogMCk7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aWNrQ291bnQ7IGkrKykge1xyXG5cdFx0XHRjb25zdCB0aWNrSW5kZXggPSBpICsgMTtcclxuXHRcdFx0Y29uc3Qgcm90YXRlZFRpY2tUZXh0V2lkdGggPSBNYXRoLmNvcyhNYXRoLlBJICogeEF4aXNUaWNrUm90YXRlIC8gMTgwKSAqIHRpY2tUZXh0V2lkdGhzW2ldO1xyXG5cdFx0XHRjb25zdCB0aWNrc0JlZm9yZVRpY2tUZXh0ID0gdGlja0luZGV4IC0gKGlzVGltZVNlcmllcyA/IDEgOiAwLjUpICsgbGVmdDtcclxuXHJcblx0XHRcdC8vIFNraXAgdGlja3MgaWYgdGhlcmUgYXJlIG5vIHRpY2tzIGJlZm9yZSB0aGVtXHJcblx0XHRcdGlmICh0aWNrc0JlZm9yZVRpY2tUZXh0IDw9IDApIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgeEF4aXNMZW5ndGhXaXRob3V0VGlja1RleHRXaWR0aCA9IHdpZHRoV2l0aG91dEN1cnJlbnRQYWRkaW5nTGVmdCAtIHJvdGF0ZWRUaWNrVGV4dFdpZHRoO1xyXG5cdFx0XHRjb25zdCB0aWNrTGVuZ3RoID0geEF4aXNMZW5ndGhXaXRob3V0VGlja1RleHRXaWR0aCAvIHRpY2tzQmVmb3JlVGlja1RleHQ7XHJcblx0XHRcdGNvbnN0IHJlbWFpbmluZ1RpY2tzID0gcmVtYWluaW5nIC0gdGlja0luZGV4O1xyXG5cclxuXHRcdFx0Y29uc3QgcGFkZGluZ1JpZ2h0TGVuZ3RoID0gcmlnaHQgKiB0aWNrTGVuZ3RoO1xyXG5cdFx0XHRjb25zdCByZW1haW5pbmdUaWNrV2lkdGggPSAocmVtYWluaW5nVGlja3MgKiB0aWNrTGVuZ3RoKSArIHBhZGRpbmdSaWdodExlbmd0aDtcclxuXHRcdFx0Y29uc3Qgb3ZlcmZsb3cgPSByb3RhdGVkVGlja1RleHRXaWR0aCAtICh0aWNrTGVuZ3RoIC8gMikgLSByZW1haW5pbmdUaWNrV2lkdGg7XHJcblxyXG5cdFx0XHRtYXhPdmVyZmxvdyA9IE1hdGgubWF4KG1heE92ZXJmbG93LCBvdmVyZmxvdyk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV0IHRpY2tPZmZzZXQgPSAwO1xyXG5cclxuXHRcdGlmICghaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdGNvbnN0IHNjYWxlID0gZDNTY2FsZUxpbmVhcigpXHJcblx0XHRcdFx0LmRvbWFpbihbXHJcblx0XHRcdFx0XHRsZWZ0ICogLTEsXHJcblx0XHRcdFx0XHQkJC5nZXRYRG9tYWluTWF4KCQkLmRhdGEudGFyZ2V0cykgKyAxICsgcmlnaHRcclxuXHRcdFx0XHRdKVxyXG5cdFx0XHRcdC5yYW5nZShbMCwgd2lkdGhXaXRob3V0Q3VycmVudFBhZGRpbmdMZWZ0IC0gbWF4T3ZlcmZsb3ddKTtcclxuXHJcblx0XHRcdHRpY2tPZmZzZXQgPSAoTWF0aC5jZWlsKChzY2FsZSgxKSAtIHNjYWxlKDApKSAvIDIpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWF4T3ZlcmZsb3cgKyB0aWNrT2Zmc2V0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHggQXhpcyBwYWRkaW5nXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpY2tDb3VudCBUaWNrIGNvdW50XHJcblx0ICogQHJldHVybnMge29iamVjdH0gUGFkZGluZyBvYmplY3QgdmFsdWVzIHdpdGggJ2xlZnQnICYgJ3JpZ2h0JyBrZXlcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFhBeGlzUGFkZGluZyh0aWNrQ291bnQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGxldCBwYWRkaW5nID0gJCQuY29uZmlnLmF4aXNfeF9wYWRkaW5nO1xyXG5cclxuXHRcdGlmIChpc0VtcHR5KHBhZGRpbmcpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSB7bGVmdDogMCwgcmlnaHQ6IDB9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFkZGluZy5sZWZ0ID0gcGFkZGluZy5sZWZ0IHx8IDA7XHJcblx0XHRcdHBhZGRpbmcucmlnaHQgPSBwYWRkaW5nLnJpZ2h0IHx8IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCQkLmF4aXMuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0Y29uc3QgZmlyc3RYID0gKyQkLmdldFhEb21haW5NaW4oJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3QgbGFzdFggPSArJCQuZ2V0WERvbWFpbk1heCgkJC5kYXRhLnRhcmdldHMpO1xyXG5cdFx0XHRjb25zdCB0aW1lRGlmZiA9IGxhc3RYIC0gZmlyc3RYO1xyXG5cclxuXHRcdFx0Y29uc3QgcmFuZ2UgPSB0aW1lRGlmZiArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XHJcblx0XHRcdGNvbnN0IHJlbGF0aXZlVGlja1dpZHRoID0gKHRpbWVEaWZmIC8gdGlja0NvdW50KSAvIHJhbmdlO1xyXG5cclxuXHRcdFx0Y29uc3QgbGVmdCA9IHBhZGRpbmcubGVmdCAvIHJhbmdlIC8gcmVsYXRpdmVUaWNrV2lkdGggfHwgMDtcclxuXHRcdFx0Y29uc3QgcmlnaHQgPSBwYWRkaW5nLnJpZ2h0IC8gcmFuZ2UgLyByZWxhdGl2ZVRpY2tXaWR0aCB8fCAwO1xyXG5cclxuXHRcdFx0cGFkZGluZyA9IHtsZWZ0LCByaWdodH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhZGRpbmc7XHJcblx0fVxyXG5cclxuXHJcblx0dXBkYXRlTGFiZWxzKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkJC4kZWw7XHJcblxyXG5cdFx0Y29uc3QgbGFiZWxzID0ge1xyXG5cdFx0XHR4OiBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9IC4ke0NMQVNTLmF4aXNYTGFiZWx9YCksXHJcblx0XHRcdHk6IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWX0gLiR7Q0xBU1MuYXhpc1lMYWJlbH1gKSxcclxuXHRcdFx0eTI6IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWTJ9IC4ke0NMQVNTLmF4aXNZMkxhYmVsfWApXHJcblx0XHR9O1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKGxhYmVscykuZmlsdGVyKGlkID0+ICFsYWJlbHNbaWRdLmVtcHR5KCkpXHJcblx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBsYWJlbHNbdl07XHJcblxyXG5cdFx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IG5vZGUudHJhbnNpdGlvbigpIDogbm9kZSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAoKSA9PiB0aGlzLnhGb3JBeGlzTGFiZWwodikpXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsICgpID0+IHRoaXMuZHhGb3JBeGlzTGFiZWwodikpXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsICgpID0+IHRoaXMuZHlGb3JBeGlzTGFiZWwodikpXHJcblx0XHRcdFx0XHQudGV4dCgoKSA9PiB0aGlzLmdldExhYmVsVGV4dCh2KSk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Z2V0UGFkZGluZyhwYWRkaW5nLCBrZXksIGRlZmF1bHRWYWx1ZSwgZG9tYWluTGVuZ3RoKSB7XHJcblx0XHRjb25zdCBwID0gaXNOdW1iZXIocGFkZGluZykgPyBwYWRkaW5nIDogcGFkZGluZ1trZXldO1xyXG5cclxuXHRcdGlmICghaXNWYWx1ZShwKSkge1xyXG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKHAsIGRvbWFpbkxlbmd0aCk7XHJcblx0fVxyXG5cclxuXHRjb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhwaXhlbHMsIGRvbWFpbkxlbmd0aCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aWR0aCwgaGVpZ2h0fX0gPSAkJDtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyB3aWR0aCA6IGhlaWdodDtcclxuXHJcblx0XHRyZXR1cm4gZG9tYWluTGVuZ3RoICogKHBpeGVscyAvIGxlbmd0aCk7XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRpY2tWYWx1ZXModmFsdWVzLCB0aWNrQ291bnQsIGZvclRpbWVTZXJpZXMpIHtcclxuXHRcdGxldCB0aWNrVmFsdWVzID0gdmFsdWVzO1xyXG5cclxuXHRcdGlmICh0aWNrQ291bnQpIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0Q291bnQgPSBpc0Z1bmN0aW9uKHRpY2tDb3VudCkgPyB0aWNrQ291bnQoKSA6IHRpY2tDb3VudDtcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgdGlja3MgYWNjb3JkaW5nIHRvIHRpY2tDb3VudFxyXG5cdFx0XHRpZiAodGFyZ2V0Q291bnQgPT09IDEpIHtcclxuXHRcdFx0XHR0aWNrVmFsdWVzID0gW3ZhbHVlc1swXV07XHJcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Q291bnQgPT09IDIpIHtcclxuXHRcdFx0XHR0aWNrVmFsdWVzID0gW3ZhbHVlc1swXSwgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXV07XHJcblx0XHRcdH0gZWxzZSBpZiAodGFyZ2V0Q291bnQgPiAyKSB7XHJcblx0XHRcdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9IHRoaXMuaXNDYXRlZ29yaXplZCgpO1xyXG5cclxuXHRcdFx0XHRjb25zdCBjb3VudCA9IHRhcmdldENvdW50IC0gMjtcclxuXHRcdFx0XHRjb25zdCBzdGFydCA9IHZhbHVlc1swXTtcclxuXHRcdFx0XHRjb25zdCBlbmQgPSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdO1xyXG5cdFx0XHRcdGNvbnN0IGludGVydmFsID0gKGVuZCAtIHN0YXJ0KSAvIChjb3VudCArIDEpO1xyXG5cdFx0XHRcdGxldCB0aWNrVmFsdWU7XHJcblxyXG5cdFx0XHRcdC8vIHJlLWNvbnN0cnVjdCB1bmlxdWUgdmFsdWVzXHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFtzdGFydF07XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG5cdFx0XHRcdFx0dGlja1ZhbHVlID0gK3N0YXJ0ICsgaW50ZXJ2YWwgKiAoaSArIDEpO1xyXG5cdFx0XHRcdFx0dGlja1ZhbHVlcy5wdXNoKFxyXG5cdFx0XHRcdFx0XHRmb3JUaW1lU2VyaWVzID8gbmV3IERhdGUodGlja1ZhbHVlKSA6IChcclxuXHRcdFx0XHRcdFx0XHRpc0NhdGVnb3JpemVkID8gTWF0aC5yb3VuZCh0aWNrVmFsdWUpIDogdGlja1ZhbHVlXHJcblx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aWNrVmFsdWVzLnB1c2goZW5kKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZm9yVGltZVNlcmllcykge1xyXG5cdFx0XHR0aWNrVmFsdWVzID0gdGlja1ZhbHVlcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRpY2tWYWx1ZXM7XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRyYW5zaXRpb25zKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCBheGlzID0gJCQuJGVsLmF4aXM7XHJcblxyXG5cdFx0Y29uc3QgW2F4aXNYLCBheGlzWSwgYXhpc1kyLCBheGlzU3ViWF0gPSBbXCJ4XCIsIFwieVwiLCBcInkyXCIsIFwic3ViWFwiXVxyXG5cdFx0XHQubWFwKHYgPT4ge1xyXG5cdFx0XHRcdGxldCBheCA9IGF4aXNbdl07XHJcblxyXG5cdFx0XHRcdGlmIChheCAmJiBkdXJhdGlvbikge1xyXG5cdFx0XHRcdFx0YXggPSBheC50cmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGF4O1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4ge2F4aXNYLCBheGlzWSwgYXhpc1kyLCBheGlzU3ViWH07XHJcblx0fVxyXG5cclxuXHRyZWRyYXcodHJhbnNpdGlvbnMsIGlzSGlkZGVuLCBpc0luaXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IG9wYWNpdHkgPSBpc0hpZGRlbiA/IFwiMFwiIDogXCIxXCI7XHJcblxyXG5cdFx0W1wieFwiLCBcInlcIiwgXCJ5MlwiLCBcInN1YlhcIl0uZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGNvbnN0IGF4aXMgPSB0aGlzW2lkXTtcclxuXHRcdFx0Y29uc3QgJGF4aXMgPSAkZWwuYXhpc1tpZF07XHJcblxyXG5cdFx0XHRpZiAoYXhpcyAmJiAkYXhpcykge1xyXG5cdFx0XHRcdGlmICghaXNJbml0KSB7XHJcblx0XHRcdFx0XHRheGlzLmNvbmZpZy53aXRob3V0VHJhbnNpdGlvbiA9ICFjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCRheGlzLnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5KTtcclxuXHRcdFx0XHRheGlzLmNyZWF0ZSh0cmFuc2l0aW9uc1tgYXhpcyR7Y2FwaXRhbGl6ZShpZCl9YF0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZUF4ZXMoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyBheGlzXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGFyZ2V0c1RvU2hvdyB0YXJnZXRzIGRhdGEgdG8gYmUgc2hvd25cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gd3RoIG9wdGlvbiBvYmplY3RcclxuXHQgKiBAcGFyYW0ge2QzLlRyYW5zaXRpb259IHRyYW5zaXRpb25zIFRyYW5zaXRpb24gb2JqZWN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGZsb3cgZmxvdyBvYmplY3RcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzSW5pdCBjYWxsZWQgZnJvbSBpbml0aWFsaXphdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3QXhpcyh0YXJnZXRzVG9TaG93LCB3dGgsIHRyYW5zaXRpb25zLCBmbG93LCBpc0luaXQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBoYXNab29tID0gISFzY2FsZS56b29tO1xyXG5cdFx0bGV0IHhEb21haW5Gb3Jab29tO1xyXG5cclxuXHRcdGlmICghaGFzWm9vbSAmJiB0aGlzLmlzQ2F0ZWdvcml6ZWQoKSAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRzY2FsZS54LmRvbWFpbihbMCwgJGVsLmF4aXMueC5zZWxlY3RBbGwoXCIudGlja1wiKS5zaXplKCldKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2NhbGUueCAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCkge1xyXG5cdFx0XHQhaGFzWm9vbSAmJlxyXG5cdFx0XHRcdCQkLnVwZGF0ZVhEb21haW4odGFyZ2V0c1RvU2hvdywgd3RoLlVwZGF0ZVhEb21haW4sIHd0aC5VcGRhdGVPcmdYRG9tYWluLCB3dGguVHJpbVhEb21haW4pO1xyXG5cclxuXHRcdFx0aWYgKCFjb25maWcuYXhpc194X3RpY2tfdmFsdWVzKSB7XHJcblx0XHRcdFx0dGhpcy51cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0c1RvU2hvdyk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAodGhpcy54KSB7XHJcblx0XHRcdHRoaXMueC50aWNrVmFsdWVzKFtdKTtcclxuXHRcdFx0dGhpcy5zdWJYICYmIHRoaXMuc3ViWC50aWNrVmFsdWVzKFtdKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29uZmlnLnpvb21fcmVzY2FsZSAmJiAhZmxvdykge1xyXG5cdFx0XHR4RG9tYWluRm9yWm9vbSA9IHNjYWxlLngub3JnRG9tYWluKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0W1wieVwiLCBcInkyXCJdLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0Y29uc3QgYXhpc1NjYWxlID0gc2NhbGVba2V5XTtcclxuXHJcblx0XHRcdGlmIChheGlzU2NhbGUpIHtcclxuXHRcdFx0XHRjb25zdCB0aWNrVmFsdWVzID0gY29uZmlnW2BheGlzXyR7a2V5fV90aWNrX3ZhbHVlc2BdO1xyXG5cdFx0XHRcdGNvbnN0IHRpY2tDb3VudCA9IGNvbmZpZ1tgYXhpc18ke2tleX1fdGlja19jb3VudGBdO1xyXG5cclxuXHRcdFx0XHRheGlzU2NhbGUuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywga2V5LCB4RG9tYWluRm9yWm9vbSkpO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpY2tWYWx1ZXMgJiYgdGlja0NvdW50KSB7XHJcblx0XHRcdFx0XHRjb25zdCBheGlzID0gJCQuYXhpc1trZXldO1xyXG5cdFx0XHRcdFx0Y29uc3QgZG9tYWluID0gYXhpc1NjYWxlLmRvbWFpbigpO1xyXG5cclxuXHRcdFx0XHRcdGF4aXMudGlja1ZhbHVlcyhcclxuXHRcdFx0XHRcdFx0dGhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXMoXHJcblx0XHRcdFx0XHRcdFx0ZG9tYWluLFxyXG5cdFx0XHRcdFx0XHRcdGRvbWFpbi5ldmVyeSh2ID0+IHYgPT09IDApID8gMSA6IHRpY2tDb3VudCxcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmlzVGltZVNlcmllc1koKVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gYXhlc1xyXG5cdFx0dGhpcy5yZWRyYXcodHJhbnNpdGlvbnMsICQkLmhhc0FyY1R5cGUoKSwgaXNJbml0KTtcclxuXHJcblx0XHQvLyBVcGRhdGUgYXhpcyBsYWJlbFxyXG5cdFx0dGhpcy51cGRhdGVMYWJlbHMod3RoLlRyYW5zaXRpb24pO1xyXG5cclxuXHRcdC8vIHNob3cvaGlkZSBpZiBtYW51YWwgY3VsbGluZyBuZWVkZWRcclxuXHRcdGlmICgod3RoLlVwZGF0ZVhEb21haW4gfHwgd3RoLlVwZGF0ZVhBeGlzIHx8IHd0aC5ZKSAmJiB0YXJnZXRzVG9TaG93Lmxlbmd0aCkge1xyXG5cdFx0XHR0aGlzLnNldEN1bGxpbmcoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVcGRhdGUgc3ViIGRvbWFpblxyXG5cdFx0aWYgKHd0aC5ZKSB7XHJcblx0XHRcdHNjYWxlLnN1YlkgJiYgc2NhbGUuc3ViWS5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBcInlcIikpO1xyXG5cdFx0XHRzY2FsZS5zdWJZMiAmJiBzY2FsZS5zdWJZMi5kb21haW4oJCQuZ2V0WURvbWFpbih0YXJnZXRzVG9TaG93LCBcInkyXCIpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBtYW51YWwgY3VsbGluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2V0Q3VsbGluZygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y2xpcCwgY3VycmVudH0sICRlbH0gPSAkJDtcclxuXHJcblx0XHRbXCJzdWJYXCIsIFwieFwiLCBcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKHR5cGUgPT4ge1xyXG5cdFx0XHRjb25zdCBheGlzID0gJGVsLmF4aXNbdHlwZV07XHJcblxyXG5cdFx0XHQvLyBzdWJjaGFydCB4IGF4aXMgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMgY3VsbGluZ1xyXG5cdFx0XHRjb25zdCBpZCA9IHR5cGUgPT09IFwic3ViWFwiID8gXCJ4XCIgOiB0eXBlO1xyXG5cdFx0XHRjb25zdCB0b0N1bGwgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19jdWxsaW5nYF07XHJcblxyXG5cdFx0XHRpZiAoYXhpcyAmJiB0b0N1bGwpIHtcclxuXHRcdFx0XHRjb25zdCB0aWNrVGV4dCA9IGF4aXMuc2VsZWN0QWxsKFwiLnRpY2sgdGV4dFwiKTtcclxuXHRcdFx0XHRjb25zdCB0aWNrVmFsdWVzID0gc29ydFZhbHVlKHRpY2tUZXh0LmRhdGEoKSk7XHJcblx0XHRcdFx0Y29uc3QgdGlja1NpemUgPSB0aWNrVmFsdWVzLmxlbmd0aDtcclxuXHRcdFx0XHRjb25zdCBjdWxsaW5nTWF4ID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY3VsbGluZ19tYXhgXTtcclxuXHRcdFx0XHRsZXQgaW50ZXJ2YWxGb3JDdWxsaW5nO1xyXG5cclxuXHRcdFx0XHRpZiAodGlja1NpemUpIHtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdGlja1NpemU7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZiAodGlja1NpemUgLyBpIDwgY3VsbGluZ01heCkge1xyXG5cdFx0XHRcdFx0XHRcdGludGVydmFsRm9yQ3VsbGluZyA9IGk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aWNrVGV4dC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gdGlja1ZhbHVlcy5pbmRleE9mKGQpICUgaW50ZXJ2YWxGb3JDdWxsaW5nID8gXCJub25lXCIgOiBcImJsb2NrXCI7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGlja1RleHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBzZXQvdW5zZXQgeF9heGlzX3RpY2tfY2xpcHBhdGhcclxuXHRcdFx0XHRpZiAodHlwZSA9PT0gXCJ4XCIpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGNsaXBQYXRoID0gY3VycmVudC5tYXhUaWNrV2lkdGhzLnguY2xpcFBhdGggPyBjbGlwLnBhdGhYQXhpc1RpY2tUZXh0cyA6IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0JGVsLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLmF4aXNYfSAudGljayB0ZXh0YClcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcFBhdGgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRQYXRoQm94fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBDYWxsZWQgd2hlbiBkcmFnZ2luZy5cclxuXHQgKiBEYXRhIHBvaW50cyBjYW4gYmUgc2VsZWN0ZWQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gbW91c2UgT2JqZWN0XHJcblx0ICovXHJcblx0ZHJhZyhtb3VzZSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge21haW59fSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHxcclxuXHRcdFx0IWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkIHx8IC8vIGRvIG5vdGhpbmcgaWYgbm90IHNlbGVjdGFibGVcclxuXHRcdFx0KGNvbmZpZy56b29tX2VuYWJsZWQgJiYgISQkLnpvb20uYWx0RG9tYWluKSB8fCAvLyBza2lwIGlmIHpvb21hYmxlIGJlY2F1c2Ugb2YgY29uZmxpY3QgZHJhZyBiZWhhdmlvclxyXG5cdFx0XHQhY29uZmlnLmRhdGFfc2VsZWN0aW9uX211bHRpcGxlIC8vIHNraXAgd2hlbiBzaW5nbGUgc2VsZWN0aW9uIGJlY2F1c2UgZHJhZyBpcyB1c2VkIGZvciBtdWx0aXBsZSBzZWxlY3Rpb25cclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgW3N4LCBzeV0gPSBzdGF0ZS5kcmFnU3RhcnQ7XHJcblx0XHRjb25zdCBbbXgsIG15XSA9IG1vdXNlO1xyXG5cclxuXHRcdGNvbnN0IG1pblggPSBNYXRoLm1pbihzeCwgbXgpO1xyXG5cdFx0Y29uc3QgbWF4WCA9IE1hdGgubWF4KHN4LCBteCk7XHJcblx0XHRjb25zdCBtaW5ZID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyBzdGF0ZS5tYXJnaW4udG9wIDogTWF0aC5taW4oc3ksIG15KTtcclxuXHRcdGNvbnN0IG1heFkgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/IHN0YXRlLmhlaWdodCA6IE1hdGgubWF4KHN5LCBteSk7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmRyYWdhcmVhfWApXHJcblx0XHRcdC5hdHRyKFwieFwiLCBtaW5YKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgbWluWSlcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBtYXhYIC0gbWluWClcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgbWF4WSAtIG1pblkpO1xyXG5cclxuXHRcdC8vIFRPRE86IGJpbmFyeSBzZWFyY2ggd2hlbiBtdWx0aXBsZSB4c1xyXG5cdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuZmlsdGVyKGQgPT4gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCBzaGFwZTogZDNTZWxlY3Rpb24gPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblx0XHRcdFx0Y29uc3QgaXNJbmNsdWRlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQpO1xyXG5cdFx0XHRcdGxldCBpc1dpdGhpbjogYW55ID0gZmFsc2U7XHJcblx0XHRcdFx0bGV0IHRvZ2dsZTtcclxuXHJcblx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuY2lyY2xlKSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgeDogbnVtYmVyID0gK3NoYXBlLmF0dHIoXCJjeFwiKSAqIDE7XHJcblx0XHRcdFx0XHRjb25zdCB5OiBudW1iZXIgPSArc2hhcGUuYXR0cihcImN5XCIpICogMTtcclxuXHJcblx0XHRcdFx0XHR0b2dnbGUgPSAkJC50b2dnbGVQb2ludDtcclxuXHRcdFx0XHRcdGlzV2l0aGluID0gbWluWCA8IHggJiYgeCA8IG1heFggJiYgbWluWSA8IHkgJiYgeSA8IG1heFk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmJhcikpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IGdldFBhdGhCb3godGhpcyk7XHJcblxyXG5cdFx0XHRcdFx0dG9nZ2xlID0gJCQudG9nZ2xlUGF0aDtcclxuXHRcdFx0XHRcdGlzV2l0aGluID0gIShtYXhYIDwgeCB8fCB4ICsgd2lkdGggPCBtaW5YKSAmJiAhKG1heFkgPCB5IHx8IHkgKyBoZWlnaHQgPCBtaW5ZKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdGlmIChpc1dpdGhpbiBeIGlzSW5jbHVkZWQpIHtcclxuXHRcdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQsICFpc0luY2x1ZGVkKTtcclxuXHRcdFx0XHRcdC8vIFRPRE86IGluY2x1ZGVkL3VuaW5jbHVkZWQgY2FsbGJhY2sgaGVyZVxyXG5cdFx0XHRcdFx0c2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgIWlzU2VsZWN0ZWQpO1xyXG5cdFx0XHRcdFx0dG9nZ2xlLmNhbGwoJCQsICFpc1NlbGVjdGVkLCBzaGFwZSwgZCwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgZHJhZyBzdGFydHMuXHJcblx0ICogQWRkcyBhbmQgU2hvd3MgdGhlIGRyYWcgYXJlYS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtb3VzZSBPYmplY3RcclxuXHQgKi9cclxuXHRkcmFnc3RhcnQobW91c2UpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuZHJhZ1N0YXJ0ID0gbW91c2U7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZHJhZ2FyZWEpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwLjFcIik7XHJcblxyXG5cdFx0JCQuc2V0RHJhZ1N0YXR1cyh0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgZHJhZyBmaW5pc2hlcy5cclxuXHQgKiBSZW1vdmVzIHRoZSBkcmFnIGFyZWEuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRkcmFnZW5kKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHsgLy8gZG8gbm90aGluZyBpZiBub3Qgc2VsZWN0YWJsZVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmRyYWdhcmVhfWApXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKDEwMClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5JTkNMVURFRCwgZmFsc2UpO1xyXG5cclxuXHRcdCQkLnNldERyYWdTdGF0dXMoZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdHNldERyYWdTdGF0dXMoaXNEcmFnZ2luZzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0dGhpcy5zdGF0ZS5kcmFnZ2luZyA9IGlzRHJhZ2dpbmc7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZWFzZUxpbmVhciBhcyBkM0Vhc2VMaW5lYXJ9IGZyb20gXCJkMy1lYXNlXCI7XHJcbmltcG9ydCB7dHJhbnNpdGlvbiBhcyBkM1RyYW5zaXRpb259IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7Z2VuZXJhdGVXYWl0fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2dlbmVyYXRvclwiO1xyXG5pbXBvcnQge2RpZmZEb21haW59IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgZmxvd1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIG9wdGlvbiBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZUZsb3coYXJncyk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtkYXRhLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgZmxvd0xlbmd0aCA9IGFyZ3MuZmxvdy5sZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBzZXQgZmxhZ1xyXG5cdFx0XHRzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSBoZWFkIGRhdGEgYWZ0ZXIgcmVuZGVyZWRcclxuXHRcdFx0ZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0ZC52YWx1ZXMuc3BsaWNlKDAsIGZsb3dMZW5ndGgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBlbGVtZW50cyByZWxhdGVkIHRvIHggc2NhbGVcclxuXHRcdFx0aWYgKCQkLnVwZGF0ZVhHcmlkKSB7XHJcblx0XHRcdFx0JCQudXBkYXRlWEdyaWQodHJ1ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHRhcmdldCBlbGVtZW50c1xyXG5cdFx0XHRjb25zdCBlbGVtZW50cyA9IHt9O1xyXG5cclxuXHRcdFx0W1wiYXhpcy54XCIsIFwiZ3JpZC54XCIsIFwiZ3JpZExpbmVzLnhcIiwgXCJyZWdpb24ubGlzdFwiLCBcInRleHRcIiwgXCJiYXJcIiwgXCJsaW5lXCIsIFwiYXJlYVwiLCBcImNpcmNsZVwiXVxyXG5cdFx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IHYuc3BsaXQoXCIuXCIpO1xyXG5cdFx0XHRcdFx0bGV0IG5vZGUgPSAkZWxbbmFtZVswXV07XHJcblxyXG5cdFx0XHRcdFx0aWYgKG5vZGUgJiYgbmFtZS5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0XHRcdG5vZGUgPSBub2RlW25hbWVbMV1dO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChub2RlICYmIG5vZGUuc2l6ZSgpKSB7XHJcblx0XHRcdFx0XHRcdGVsZW1lbnRzW3ZdID0gbm9kZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHRcdFx0JCQuc2V0Rmxvd0xpc3QoZWxlbWVudHMsIGFyZ3MpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZmxvdyBsaXN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnRzIFRhcmdldCBlbGVtZW50c1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIG9wdGlvbiBvYmplY3RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEZsb3dMaXN0KGVsZW1lbnRzLCBhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7ZmxvdywgdGFyZ2V0c30gPSBhcmdzO1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRkdXJhdGlvbiA9IGFyZ3MuZHVyYXRpb24sXHJcblx0XHRcdGluZGV4OiBmbG93SW5kZXgsXHJcblx0XHRcdGxlbmd0aDogZmxvd0xlbmd0aCxcclxuXHRcdFx0b3JnRGF0YUNvdW50LFxyXG5cdFx0fSA9IGZsb3c7XHJcblxyXG5cdFx0Y29uc3QgdHJhbnNmb3JtID0gJCQuZ2V0Rmxvd1RyYW5zZm9ybSh0YXJnZXRzLCBvcmdEYXRhQ291bnQsIGZsb3dJbmRleCwgZmxvd0xlbmd0aCk7XHJcblx0XHRjb25zdCB3YWl0ID0gZ2VuZXJhdGVXYWl0KCk7XHJcblx0XHRjb25zdCBndCA9IGQzVHJhbnNpdGlvbigpLmVhc2UoZDNFYXNlTGluZWFyKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pO1xyXG5cclxuXHRcdHdhaXQuYWRkKE9iamVjdC5rZXlzKGVsZW1lbnRzKS5tYXAodiA9PiB7XHJcblx0XHRcdGxldCBuID0gZWxlbWVudHNbdl07XHJcblxyXG5cdFx0XHRpZiAodiA9PT0gXCJheGlzLnhcIikge1xyXG5cdFx0XHRcdG4gPSBuLnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuY2FsbChnID0+ICQkLmF4aXMueC5zZXRUcmFuc2l0aW9uKGd0KS5jcmVhdGUoZykpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwicmVnaW9uLmxpc3RcIikge1xyXG5cdFx0XHRcdG4gPSBuLmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRuID0gbi50cmFuc2l0aW9uKGd0KS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBuO1xyXG5cdFx0fSkpO1xyXG5cclxuXHRcdGd0LmNhbGwod2FpdCwgKCkgPT4ge1xyXG5cdFx0XHQkJC5jbGVhblVwRmxvdyhlbGVtZW50cywgYXJncyk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhbiB1cCBmbG93XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnRzIFRhcmdldCBlbGVtZW50c1xyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmdzIG9wdGlvbiBvYmplY3RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNsZWFuVXBGbG93KGVsZW1lbnRzLCBhcmdzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uc3Qge2Zsb3csIHNoYXBlLCB4dn0gPSBhcmdzO1xyXG5cdFx0Y29uc3Qge2N4LCBjeSwgeEZvclRleHQsIHlGb3JUZXh0fSA9IHNoYXBlLnBvcztcclxuXHRcdGNvbnN0IHtcclxuXHRcdFx0ZG9uZSA9ICgpID0+IHt9LFxyXG5cdFx0XHRsZW5ndGg6IGZsb3dMZW5ndGhcclxuXHRcdH0gPSBmbG93O1xyXG5cclxuXHRcdC8vIFJlbW92ZSBmbG93ZWQgZWxlbWVudHNcclxuXHRcdGlmIChmbG93TGVuZ3RoKSB7XHJcblx0XHRcdFtcImNpcmNsZVwiLCBcInRleHRcIiwgXCJzaGFwZVwiLCBcImV2ZW50UmVjdFwiXS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHRhcmdldDogc3RyaW5nW10gPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbG93TGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHRhcmdldC5wdXNoKGAuJHtDTEFTU1t2XX0tJHtpfWApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c3ZnLnNlbGVjdEFsbChgLiR7Q0xBU1NbYCR7dn1zYF19YCkgLy8gY2lyY2xlcywgc2hhcGVzLCB0ZXh0cywgZXZlbnRSZWN0c1xyXG5cdFx0XHRcdFx0LnNlbGVjdEFsbCh0YXJnZXQpXHJcblx0XHRcdFx0XHQucmVtb3ZlKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgLiR7Q0xBU1MueGdyaWR9YClcclxuXHRcdFx0XHQucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZHJhdyBhZ2FpbiBmb3IgcmVtb3ZpbmcgZmxvd2VkIGVsZW1lbnRzIGFuZCByZXZlcnRpbmcgYXR0clxyXG5cdFx0T2JqZWN0LmtleXMoZWxlbWVudHMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdGNvbnN0IG4gPSBlbGVtZW50c1t2XTtcclxuXHJcblx0XHRcdGlmICh2ICE9PSBcImF4aXMueFwiKSB7XHJcblx0XHRcdFx0bi5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodiA9PT0gXCJncmlkLnhcIikge1xyXG5cdFx0XHRcdG4uYXR0cihzdGF0ZS54Z3JpZEF0dHIpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwiZ3JpZExpbmVzLnhcIikge1xyXG5cdFx0XHRcdG4uYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dilcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiB4dik7XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJncmlkTGluZXMueFwiKSB7XHJcblx0XHRcdFx0bi5zZWxlY3QoXCJsaW5lXCIpLmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyAwIDogeHYpXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogeHYpO1xyXG5cclxuXHRcdFx0XHRuLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCBpc1JvdGF0ZWQgPyBzdGF0ZS53aWR0aCA6IDApXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeHYpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKC9eKGFyZWF8YmFyfGxpbmUpJC8udGVzdCh2KSkge1xyXG5cdFx0XHRcdG4uYXR0cihcImRcIiwgc2hhcGUudHlwZVt2XSk7XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJ0ZXh0XCIpIHtcclxuXHRcdFx0XHRuLmF0dHIoXCJ4XCIsIHhGb3JUZXh0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JUZXh0KVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpKTtcclxuXHRcdFx0fSBlbHNlIGlmICh2ID09PSBcImNpcmNsZVwiKSB7XHJcblx0XHRcdFx0aWYgKCQkLmlzQ2lyY2xlUG9pbnQoKSkge1xyXG5cdFx0XHRcdFx0bi5hdHRyKFwiY3hcIiwgY3gpLmF0dHIoXCJjeVwiLCBjeSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IHhGdW5jID0gZCA9PiBjeChkKSAtIGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0XHRcdFx0Y29uc3QgeUZ1bmMgPSBkID0+IGN5KGQpIC0gY29uZmlnLnBvaW50X3I7XHJcblxyXG5cdFx0XHRcdFx0bi5hdHRyKFwieFwiLCB4RnVuYylcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGdW5jKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImN4XCIsIGN4KSAvLyB3aGVuIHBhdHRlcm4gaXMgdXNlZCwgaXQgcG9zc2libHkgY29udGFpbiAnY2lyY2xlJyBhbHNvLlxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImN5XCIsIGN5KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAodiA9PT0gXCJyZWdpb24ubGlzdFwiKSB7XHJcblx0XHRcdFx0bi5zZWxlY3QoXCJyZWN0XCIpLmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAkJC5yZWdpb25YLmJpbmQoJCQpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5yZWdpb25XaWR0aC5iaW5kKCQkKSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cclxuXHRcdC8vIGNhbGxiYWNrIGZvciBlbmQgb2YgZmxvd1xyXG5cdFx0ZG9uZS5jYWxsKCQkLmFwaSk7XHJcblxyXG5cdFx0c3RhdGUuZmxvd2luZyA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBmbG93IHRyYW5zZm9ybSB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRzIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBvcmdEYXRhQ291bnQgb3JpZ2luYWwgZGF0YSBjb3VudFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmbG93SW5kZXggZmxvdyBpbmRleFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmbG93TGVuZ3RoIGZsb3cgbGVuZ3RoXHJcblx0ICogQHJldHVybnMge3N0cmluZ31cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEZsb3dUcmFuc2Zvcm0odGFyZ2V0cywgb3JnRGF0YUNvdW50LCBmbG93SW5kZXgsIGZsb3dMZW5ndGgpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2RhdGEsIHNjYWxlOiB7eH19ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhVmFsdWVzID0gZGF0YS50YXJnZXRzWzBdLnZhbHVlcztcclxuXHJcblx0XHRsZXQgZmxvd1N0YXJ0ID0gJCQuZ2V0VmFsdWVPbkluZGV4KGRhdGFWYWx1ZXMsIGZsb3dJbmRleCk7XHJcblx0XHRsZXQgZmxvd0VuZCA9ICQkLmdldFZhbHVlT25JbmRleChkYXRhVmFsdWVzLCBmbG93SW5kZXggKyBmbG93TGVuZ3RoKTtcclxuXHRcdGxldCB0cmFuc2xhdGVYO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB4IGRvbWFpbiB0byBnZW5lcmF0ZSBheGlzIGVsZW1lbnRzIGZvciBmbG93XHJcblx0XHRjb25zdCBvcmdEb21haW4gPSB4LmRvbWFpbigpO1xyXG5cdFx0Y29uc3QgZG9tYWluID0gJCQudXBkYXRlWERvbWFpbih0YXJnZXRzLCB0cnVlLCB0cnVlKTtcclxuXHJcblx0XHQvLyBnZW5lcmF0ZSB0cmFuc2Zvcm0gdG8gZmxvd1xyXG5cdFx0aWYgKCFvcmdEYXRhQ291bnQpIHsgLy8gaWYgZW1wdHlcclxuXHRcdFx0aWYgKGRhdGFWYWx1ZXMubGVuZ3RoICE9PSAxKSB7XHJcblx0XHRcdFx0dHJhbnNsYXRlWCA9IHgob3JnRG9tYWluWzBdKSAtIHgoZG9tYWluWzBdKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAoJCQuYXhpcy5pc1RpbWVTZXJpZXMoKSkge1xyXG5cdFx0XHRcdFx0Zmxvd1N0YXJ0ID0gJCQuZ2V0VmFsdWVPbkluZGV4KGRhdGFWYWx1ZXMsIDApO1xyXG5cdFx0XHRcdFx0Zmxvd0VuZCA9ICQkLmdldFZhbHVlT25JbmRleChkYXRhVmFsdWVzLCBkYXRhVmFsdWVzLmxlbmd0aCAtIDEpO1xyXG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9IHgoZmxvd1N0YXJ0LngpIC0geChmbG93RW5kLngpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0cmFuc2xhdGVYID0gZGlmZkRvbWFpbihkb21haW4pIC8gMjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAob3JnRGF0YUNvdW50ID09PSAxIHx8IChmbG93U3RhcnQgJiYgZmxvd1N0YXJ0LngpID09PSAoZmxvd0VuZCAmJiBmbG93RW5kLngpKSB7XHJcblx0XHRcdHRyYW5zbGF0ZVggPSB4KG9yZ0RvbWFpblswXSkgLSB4KGRvbWFpblswXSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0cmFuc2xhdGVYID0gJCQuYXhpcy5pc1RpbWVTZXJpZXMoKSA/XHJcblx0XHRcdFx0eChvcmdEb21haW5bMF0pIC0geChkb21haW5bMF0pIDpcclxuXHRcdFx0XHR4KGZsb3dTdGFydC54KSAtIHgoZmxvd0VuZC54KTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzY2FsZVggPSAoZGlmZkRvbWFpbihvcmdEb21haW4pIC8gZGlmZkRvbWFpbihkb21haW4pKTtcclxuXHJcblx0XHRyZXR1cm4gYHRyYW5zbGF0ZSgke3RyYW5zbGF0ZVh9LDApIHNjYWxlKCR7c2NhbGVYfSwxKWA7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0ZXZlbnQgYXMgZDNFdmVudFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtpc2Jvb2xlYW59IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIGFyZWEgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cclxuXHQgKiBBZGQgYSBjb250YWluZXIgZm9yIHRoZSB6b25lIHRoYXQgZGV0ZWN0cyB0aGUgZXZlbnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0RXZlbnRSZWN0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5ldmVudFJlY3RzKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhd3MgdGhlIGFyZWEgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd0V2ZW50UmVjdCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKTtcclxuXHRcdGxldCBldmVudFJlY3RVcGRhdGU7XHJcblxyXG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkO1xyXG5cdFx0Y29uc3QgZXZlbnRSZWN0cyA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgem9vbUVuYWJsZWQgJiYgem9vbUVuYWJsZWQudHlwZSAhPT0gXCJkcmFnXCIgPyAoXHJcblx0XHRcdFx0Y29uZmlnLmF4aXNfcm90YXRlZCA/IFwibnMtcmVzaXplXCIgOiBcImV3LXJlc2l6ZVwiXHJcblx0XHRcdCkgOiBudWxsKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5ldmVudFJlY3RzTXVsdGlwbGUsIGlzTXVsdGlwbGVYKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5ldmVudFJlY3RzU2luZ2xlLCAhaXNNdWx0aXBsZVgpO1xyXG5cclxuXHRcdC8vIGNsZWFyIG9sZCByZWN0c1xyXG5cdFx0ZXZlbnRSZWN0cy5zZWxlY3RBbGwoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5yZW1vdmUoKTtcclxuXHJcblx0XHQvLyBvcGVuIGFzIHB1YmxpYyBjb25zdGlhYmxlXHJcblx0XHQkZWwuZXZlbnRSZWN0ID0gZXZlbnRSZWN0cy5zZWxlY3RBbGwoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKTtcclxuXHJcblx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcclxuXHRcdFx0ZXZlbnRSZWN0VXBkYXRlID0gJGVsLmV2ZW50UmVjdC5kYXRhKFswXSk7XHJcblx0XHRcdC8vIHVwZGF0ZVxyXG5cdFx0XHQvLyBlbnRlcjogb25seSBvbmUgcmVjdCB3aWxsIGJlIGFkZGVkXHJcblx0XHRcdC8vIGV4aXQ6IG5vdCBuZWVkZWQgYmVjYXVzZSBhbHdheXMgb25seSBvbmUgcmVjdCBleGlzdHNcclxuXHRcdFx0ZXZlbnRSZWN0VXBkYXRlID0gJCQuZ2VuZXJhdGVFdmVudFJlY3RzRm9yTXVsdGlwbGVYcyhldmVudFJlY3RVcGRhdGUuZW50ZXIoKSlcclxuXHRcdFx0XHQubWVyZ2UoZXZlbnRSZWN0VXBkYXRlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFNldCBkYXRhIGFuZCB1cGRhdGUgJGVsLmV2ZW50UmVjdFxyXG5cdFx0XHRjb25zdCB4QXhpc1RpY2tWYWx1ZXMgPSAkJC5nZXRNYXhEYXRhQ291bnRUYXJnZXQoKTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBkYXRhJ3MgaW5kZXggdmFsdWUgdG8gYmUgYWxpbmdlZCB3aXRoIHRoZSB4IEF4aXNcclxuXHRcdFx0JCQudXBkYXRlRGF0YUluZGV4QnlYKHhBeGlzVGlja1ZhbHVlcyk7XHJcblx0XHRcdCQkLnVwZGF0ZVhzKHhBeGlzVGlja1ZhbHVlcyk7XHJcblx0XHRcdCQkLnVwZGF0ZVBvaW50Q2xhc3MgJiYgJCQudXBkYXRlUG9pbnRDbGFzcyh0cnVlKTtcclxuXHJcblx0XHRcdGV2ZW50UmVjdHMuZGF0dW0oeEF4aXNUaWNrVmFsdWVzKTtcclxuXHJcblx0XHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApO1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkZWwuZXZlbnRSZWN0LmRhdGEoZCA9PiBkKTtcclxuXHJcblx0XHRcdC8vIGV4aXRcclxuXHRcdFx0ZXZlbnRSZWN0VXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZVxyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdFVwZGF0ZS5lbnRlcigpKVxyXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RVcGRhdGU7XHJcblx0XHQkJC51cGRhdGVFdmVudFJlY3QoZXZlbnRSZWN0VXBkYXRlKTtcclxuXHJcblx0XHRpZiAoJCQuc3RhdGUuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgISRlbC5zdmcub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdFwiKSAmJiAhJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdCQkLmJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRiaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0RXZlbnRSZWN0ID0gKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB0b3VjaCA9IGQzRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblxyXG5cdFx0XHRyZXR1cm4gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGdldEluZGV4ID0gZXZlbnRSZWN0ID0+IHtcclxuXHRcdFx0bGV0IGluZGV4ID0gZXZlbnRSZWN0ICYmIGV2ZW50UmVjdC5hdHRyKFwiY2xhc3NcIikgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKVxyXG5cdFx0XHRcdC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke0NMQVNTLmV2ZW50UmVjdH0tP3xzKWAsIFwiZ1wiKSwgXCJcIikgKiAxO1xyXG5cclxuXHRcdFx0aWYgKGlzTmFOKGluZGV4KSB8fCBpbmRleCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdGluZGV4ID0gLTE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpbmRleDtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3Qgc2VsZWN0UmVjdCA9IGNvbnRleHQgPT4ge1xyXG5cdFx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcclxuXHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyhjb250ZXh0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KGV2ZW50UmVjdCk7XHJcblxyXG5cdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRpbmRleCA9PT0gLTEgP1xyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOlxyXG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvclNpbmdsZShjb250ZXh0LCBldmVudFJlY3QsIGluZGV4KTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0KClcclxuXHRcdC8vIGFjY29yZGluZyAnaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoLnByZXZlbnREZWZhdWx0JyBvcHRpb25cclxuXHRcdGNvbnN0IHByZXZlbnREZWZhdWx0ID0gY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaC5wcmV2ZW50RGVmYXVsdDtcclxuXHRcdGNvbnN0IGlzUHJldmVudGVkID0gKGlzYm9vbGVhbihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IGZhbHNlO1xyXG5cdFx0Y29uc3QgcHJldmVudFRocmVzaG9sZCA9ICghaXNOYU4ocHJldmVudERlZmF1bHQpICYmIHByZXZlbnREZWZhdWx0KSB8fCBudWxsO1xyXG5cdFx0bGV0IHN0YXJ0UHg7XHJcblxyXG5cdFx0Y29uc3QgcHJldmVudEV2ZW50ID0gZXZlbnQgPT4ge1xyXG5cdFx0XHRjb25zdCBldmVudFR5cGUgPSBldmVudC50eXBlO1xyXG5cdFx0XHRjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRjb25zdCBjdXJyZW50WFkgPSB0b3VjaFtgY2xpZW50JHtjb25maWcuYXhpc19yb3RhdGVkID8gXCJZXCIgOiBcIlhcIn1gXTtcclxuXHJcblx0XHRcdC8vIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nXHJcblx0XHRcdGlmIChldmVudFR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XHJcblx0XHRcdFx0aWYgKGlzUHJldmVudGVkKSB7XHJcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAocHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0c3RhcnRQeCA9IGN1cnJlbnRYWTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInRvdWNobW92ZVwiKSB7XHJcblx0XHRcdFx0aWYgKGlzUHJldmVudGVkIHx8IHN0YXJ0UHggPT09IHRydWUgfHwgKFxyXG5cdFx0XHRcdFx0cHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhzdGFydFB4IC0gY3VycmVudFhZKSA+PSBwcmV2ZW50VGhyZXNob2xkXHJcblx0XHRcdFx0KSkge1xyXG5cdFx0XHRcdFx0Ly8gb25jZSBwcmV2ZW50ZWQsIGtlZXAgcHJldmVudGVkIGR1cmluZyB3aG9sZSAndG91Y2htb3ZlJyBjb250ZXh0XHJcblx0XHRcdFx0XHRzdGFydFB4ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGJpbmQgdG91Y2ggZXZlbnRzXHJcblx0XHRzdmdcclxuXHRcdFx0Lm9uKFwidG91Y2hzdGFydC5ldmVudFJlY3QgdG91Y2htb3ZlLmV2ZW50UmVjdFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcclxuXHRcdFx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQ7XHJcblxyXG5cdFx0XHRcdGlmICghZXZlbnRSZWN0LmVtcHR5KCkgJiYgZXZlbnRSZWN0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0KSkge1xyXG5cdFx0XHRcdFx0Ly8gaWYgdG91Y2ggcG9pbnRzIGFyZSA+IDEsIG1lYW5zIGRvaW5nIHpvb21pbmcgaW50ZXJhY3Rpb24uIEluIHRoaXMgY2FzZSBkbyBub3QgZXhlY3V0ZSB0b29sdGlwIGNvZGVzLlxyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLmRyYWdnaW5nIHx8IHN0YXRlLmZsb3dpbmcgfHwgJCQuaGFzQXJjVHlwZSgpIHx8IGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cHJldmVudEV2ZW50KGV2ZW50KTtcclxuXHRcdFx0XHRcdHNlbGVjdFJlY3QodGhpcyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpO1xyXG5cdFx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdHJ1ZSlcclxuXHRcdFx0Lm9uKFwidG91Y2hlbmQuZXZlbnRSZWN0XCIsICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcclxuXHJcblx0XHRcdFx0aWYgKCFldmVudFJlY3QuZW1wdHkoKSAmJiBldmVudFJlY3QuY2xhc3NlZChDTEFTUy5ldmVudFJlY3QpKSB7XHJcblx0XHRcdFx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCBzdGF0ZS5jYW5jZWxDbGljaykge1xyXG5cdFx0XHRcdFx0XHRzdGF0ZS5jYW5jZWxDbGljayAmJiAoc3RhdGUuY2FuY2VsQ2xpY2sgPSBmYWxzZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGVzIHRoZSBsb2NhdGlvbiBhbmQgc2l6ZSBvZiB0aGUgZXZlbnRSZWN0LlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFJlY3RVcGRhdGUgZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHhTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdERhdGEgPSBldmVudFJlY3RVcGRhdGUgfHwgJCQuJGVsLmV2ZW50UmVjdC5kYXRhKCk7IC8vIHNldCB1cGRhdGUgc2VsZWN0aW9uIGlmIG51bGxcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgeDtcclxuXHRcdGxldCB5O1xyXG5cdFx0bGV0IHc7XHJcblx0XHRsZXQgaDtcclxuXHJcblx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHQvLyBUT0RPOiByb3RhdGVkIG5vdCBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdHggPSAwO1xyXG5cdFx0XHR5ID0gMDtcclxuXHRcdFx0dyA9IHN0YXRlLndpZHRoO1xyXG5cdFx0XHRoID0gc3RhdGUuaGVpZ2h0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IHJlY3RXO1xyXG5cdFx0XHRsZXQgcmVjdFg7XHJcblxyXG5cdFx0XHRpZiAoJCQuYXhpcy5pc0NhdGVnb3JpemVkKCkpIHtcclxuXHRcdFx0XHRyZWN0VyA9ICQkLmdldEV2ZW50UmVjdFdpZHRoKCk7XHJcblx0XHRcdFx0cmVjdFggPSBkID0+IHhTY2FsZShkLngpIC0gKHJlY3RXIC8gMik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgZ2V0UHJldk5leHRYID0gZCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IGQuaW5kZXg7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0cHJldjogJCQuZ2V0UHJldlgoaW5kZXgpLFxyXG5cdFx0XHRcdFx0XHRuZXh0OiAkJC5nZXROZXh0WChpbmRleClcclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0cmVjdFcgPSBkID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHggPSBnZXRQcmV2TmV4dFgoZCk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IG1ha2UgdGhlIGV2ZW50UmVjdCBmdWxsIHdpZHRoIChvciBoZWlnaHQpXHJcblx0XHRcdFx0XHRpZiAoeC5wcmV2ID09PSBudWxsICYmIHgubmV4dCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0IDogc3RhdGUud2lkdGg7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHgubmV4dCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR4Lm5leHQgPSB4U2NhbGUuZG9tYWluKClbMV07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KDAsICh4U2NhbGUoeC5uZXh0KSAtIHhTY2FsZSh4LnByZXYpKSAvIDIpO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJlY3RYID0gZCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB4ID0gZ2V0UHJldk5leHRYKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgdGhpc1ggPSBkLng7XHJcblxyXG5cdFx0XHRcdFx0Ly8gaWYgdGhlcmUgdGhpcyBpcyBhIHNpbmdsZSBkYXRhIHBvaW50IHBvc2l0aW9uIHRoZSBldmVudFJlY3QgYXQgMFxyXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIDA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR4LnByZXYgPSB4U2NhbGUuZG9tYWluKClbMF07XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuICh4U2NhbGUodGhpc1gpICsgeFNjYWxlKHgucHJldikpIC8gMjtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IHJlY3RYO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gcmVjdFggOiAwO1xyXG5cdFx0XHR3ID0gaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiByZWN0VztcclxuXHRcdFx0aCA9IGlzUm90YXRlZCA/IHJlY3RXIDogc3RhdGUuaGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGV2ZW50UmVjdERhdGEuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzRXZlbnQuYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwieFwiLCB4KVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeSlcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCB3KVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBoKTtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RSZWN0Rm9yU2luZ2xlKGNvbnRleHQsIGV2ZW50UmVjdCwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1NlbGVjdGlvbkVuYWJsZWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZDtcclxuXHRcdGNvbnN0IGlzU2VsZWN0aW9uR3JvdXBlZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkO1xyXG5cdFx0Y29uc3QgaXNUb29sdGlwR3JvdXBlZCA9IGNvbmZpZy50b29sdGlwX2dyb3VwZWQ7XHJcblx0XHRjb25zdCBzZWxlY3RlZERhdGEgPSAkJC5nZXRBbGxWYWx1ZXNPbkluZGV4KGluZGV4KTtcclxuXHJcblx0XHRpZiAoaXNUb29sdGlwR3JvdXBlZCkge1xyXG5cdFx0XHQkJC5zaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGNvbnRleHQpO1xyXG5cdFx0XHQkJC5zaG93R3JpZEZvY3VzKHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0XHRpZiAoIWlzU2VsZWN0aW9uRW5hYmxlZCB8fCBpc1NlbGVjdGlvbkdyb3VwZWQpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7aW5kZXh9YClcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1NlbGVjdGlvbkVuYWJsZWQpIHtcclxuXHRcdFx0XHRcdGV2ZW50UmVjdC5zdHlsZShcImN1cnNvclwiLCBpc1NlbGVjdGlvbkdyb3VwZWQgPyBcInBvaW50ZXJcIiA6IG51bGwpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCFpc1Rvb2x0aXBHcm91cGVkKSB7XHJcblx0XHRcdFx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHRcdFx0XHQkJC5oaWRlVG9vbHRpcCgpO1xyXG5cclxuXHRcdFx0XHRcdCFpc1NlbGVjdGlvbkdyb3VwZWQgJiYgJCQuZXhwYW5kQ2lyY2xlc0JhcnMoaW5kZXgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0cmV0dXJuICQkLmlzV2l0aGluU2hhcGUodGhpcywgZCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKHNlbGVjdGVkID0+IHtcclxuXHRcdFx0XHRjb25zdCBkID0gc2VsZWN0ZWQuZGF0YSgpO1xyXG5cclxuXHRcdFx0XHRpZiAoaXNTZWxlY3Rpb25FbmFibGVkICYmXHJcblx0XHRcdFx0XHQoaXNTZWxlY3Rpb25Hcm91cGVkIHx8IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpKVxyXG5cdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICghaXNUb29sdGlwR3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0JCQuc2hvd1Rvb2x0aXAoZCwgY29udGV4dCk7XHJcblx0XHRcdFx0XHQkJC5zaG93R3JpZEZvY3VzKGQpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cdFx0XHRcdFx0c2VsZWN0ZWQuZWFjaChkID0+ICQkLmV4cGFuZENpcmNsZXNCYXJzKGluZGV4LCBkLmlkKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRleHBhbmRDaXJjbGVzQmFycyhpbmRleDogbnVtYmVyLCBpZDogc3RyaW5nLCByZXNldDogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7YmFyLCBjaXJjbGV9fSA9ICQkO1xyXG5cclxuXHRcdGNpcmNsZSAmJiBjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQgJiZcclxuXHRcdFx0JCQuZXhwYW5kQ2lyY2xlcyhpbmRleCwgaWQsIHJlc2V0KTtcclxuXHJcblx0XHRiYXIgJiYgJCQuZXhwYW5kQmFycyhpbmRleCwgaWQsIHJlc2V0KTtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyhjb250ZXh0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gZG8gbm90aGluZyB3aGVuIGRyYWdnaW5nXHJcblx0XHRpZiAoJCQuZHJhZ2dpbmcgfHwgJCQuaGFzQXJjVHlwZSh0YXJnZXRzVG9TaG93KSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKGNvbnRleHQpO1xyXG5cdFx0Y29uc3QgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5tb3VzZW92ZXIgJiYgKCFjbG9zZXN0IHx8IGNsb3Nlc3QuaWQgIT09IHN0YXRlLm1vdXNlb3Zlci5pZCkpIHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfb25vdXQuY2FsbCgkJC5hcGksIHN0YXRlLm1vdXNlb3Zlcik7XHJcblx0XHRcdHN0YXRlLm1vdXNlb3ZlciA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWNsb3Nlc3QpIHtcclxuXHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBzYW1lWERhdGEgPSAoXHJcblx0XHRcdCQkLmlzQnViYmxlVHlwZShjbG9zZXN0KSB8fCAkJC5pc1NjYXR0ZXJUeXBlKGNsb3Nlc3QpIHx8ICFjb25maWcudG9vbHRpcF9ncm91cGVkXHJcblx0XHQpID8gW2Nsb3Nlc3RdIDogJCQuZmlsdGVyQnlYKHRhcmdldHNUb1Nob3csIGNsb3Nlc3QueCk7XHJcblxyXG5cdFx0Ly8gc2hvdyB0b29sdGlwIHdoZW4gY3Vyc29yIGlzIGNsb3NlIHRvIHNvbWUgcG9pbnRcclxuXHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9IHNhbWVYRGF0YS5tYXAoZCA9PiAkJC5hZGROYW1lKGQpKTtcclxuXHJcblx0XHQkJC5zaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGNvbnRleHQpO1xyXG5cclxuXHRcdC8vIGV4cGFuZCBwb2ludHNcclxuXHRcdCQkLmV4cGFuZENpcmNsZXNCYXJzKGNsb3Nlc3QuaW5kZXgsIGNsb3Nlc3QuaWQsIHRydWUpO1xyXG5cclxuXHRcdC8vIFNob3cgeGdyaWQgZm9jdXMgbGluZVxyXG5cdFx0JCQuc2hvd0dyaWRGb2N1cyhzZWxlY3RlZERhdGEpO1xyXG5cclxuXHRcdC8vIFNob3cgY3Vyc29yIGFzIHBvaW50ZXIgaWYgcG9pbnQgaXMgY2xvc2UgdG8gbW91c2UgcG9zaXRpb25cclxuXHRcdGlmICgkJC5pc0JhclR5cGUoY2xvc2VzdC5pZCkgfHwgJCQuZGlzdChjbG9zZXN0LCBtb3VzZSkgPCBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkpIHtcclxuXHRcdFx0JCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5zdHlsZShcImN1cnNvclwiLCBcInBvaW50ZXJcIik7XHJcblxyXG5cdFx0XHRpZiAoIXN0YXRlLm1vdXNlb3Zlcikge1xyXG5cdFx0XHRcdGNvbmZpZy5kYXRhX29ub3Zlci5jYWxsKCQkLmFwaSwgY2xvc2VzdCk7XHJcblx0XHRcdFx0c3RhdGUubW91c2VvdmVyID0gY2xvc2VzdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuc2VsZWN0IEV2ZW50UmVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVuc2VsZWN0UmVjdCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge2JhciwgY2lyY2xlLCB0b29sdGlwfX0gPSAkJDtcclxuXHJcblx0XHQkJC4kZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnN0eWxlKFwiY3Vyc29yXCIsIG51bGwpO1xyXG5cdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cclxuXHRcdGlmICh0b29sdGlwKSB7XHJcblx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHRcdCQkLl9oYW5kbGVMaW5rZWRDaGFydHMoZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNpcmNsZSAmJiAhY29uZmlnLnBvaW50X2ZvY3VzX29ubHkgJiYgJCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblx0XHRiYXIgJiYgJCQudW5leHBhbmRCYXJzKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlIGV2ZW50UmVjdCBmb3IgZWFjaCBkYXRhIG9uIHRoZSB4LWF4aXMuXHJcblx0ICogUmVnaXN0ZXIgdG91Y2ggYW5kIGRyYWcgZXZlbnRzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFJlY3RFbnRlciBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdEVudGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCByZWN0ID0gZXZlbnRSZWN0RW50ZXIuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzRXZlbnQuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/IFwicG9pbnRlclwiIDogbnVsbClcclxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvclNpbmdsZVguYmluZCh0aGlzKShkLCAkJCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaW5wdXRUeXBlID09PSBcIm1vdXNlXCIpIHtcclxuXHRcdFx0cmVjdFxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcclxuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmcgd2hpbGUgZHJhZ2dpbmcvZmxvd2luZ1xyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLmRyYWdnaW5nIHx8IHN0YXRlLmZsb3dpbmcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25maWcudG9vbHRpcF9ncm91cGVkICYmICQkLnNldE92ZXJPdXQodHJ1ZSwgZC5pbmRleCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXHJcblx0XHRcdFx0XHRpZiAoc3RhdGUuZHJhZ2dpbmcgfHwgc3RhdGUuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBpbmRleCA9IGQuaW5kZXg7XHJcblx0XHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSAkJC4kZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWApO1xyXG5cclxuXHRcdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpICYmXHJcblx0XHRcdFx0XHRcdGNvbmZpZy5saW5lX3N0ZXBfdHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiZcclxuXHRcdFx0XHRcdFx0ZDNNb3VzZSh0aGlzKVswXSA8ICQkLnNjYWxlLngoJCQuZ2V0WFZhbHVlKGQuaWQsIGluZGV4KSlcclxuXHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRpbmRleCAtPSAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGluZGV4ID09PSAtMSA/XHJcblx0XHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpIDogJCQuc2VsZWN0UmVjdEZvclNpbmdsZSh0aGlzLCBldmVudFJlY3QsIGluZGV4KTtcclxuXHJcblx0XHRcdFx0XHQvLyBBcyBvZiBpbmRpdmlkdWFsIGRhdGEgcG9pbnQob3IgPHBhdGg+KSBlbGVtZW50IGNhbid0IGJpbmQgbW91c2VvdmVyL291dCBldmVudFxyXG5cdFx0XHRcdFx0Ly8gdG8gZGV0ZXJtaW5lIGN1cnJlbnQgaW50ZXJhY3RpbmcgZWxlbWVudCwgc28gdXNlICdtb3VzZW1vdmUnIGV2ZW50IGluc3RlYWQuXHJcblx0XHRcdFx0XHRpZiAoIWNvbmZpZy50b29sdGlwX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRcdFx0JCQuc2V0T3Zlck91dChpbmRleCAhPT0gLTEsIGQuaW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgZCA9PiB7XHJcblx0XHRcdFx0XHQvLyBjaGFydCBpcyBkZXN0cm95ZWRcclxuXHRcdFx0XHRcdGlmICghY29uZmlnIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBkLmluZGV4KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHRjbGlja0hhbmRsZXJGb3JTaW5nbGVYKGQsIGN0eCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSBjdHg7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhJCQudG9nZ2xlU2hhcGUgfHwgc3RhdGUuY2FuY2VsQ2xpY2spIHtcclxuXHRcdFx0c3RhdGUuY2FuY2VsQ2xpY2sgJiYgKHN0YXRlLmNhbmNlbENsaWNrID0gZmFsc2UpO1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHtpbmRleH0gPSBkO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtpbmRleH1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkMikge1xyXG5cdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQyKSkge1xyXG5cdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUodGhpcywgZDIsIGluZGV4KTtcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suYmluZCgkJC5hcGkpKGQyLCB0aGlzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhbiBldmVudFJlY3QsXHJcblx0ICogUmVnaXN0ZXIgdG91Y2ggYW5kIGRyYWcgZXZlbnRzLlxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBldmVudFJlY3RFbnRlciBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdEVudGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodCwgaW5wdXRUeXBlfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdGNvbnN0IHJlY3QgPSBldmVudFJlY3RFbnRlclxyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgMClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIDApXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5ldmVudFJlY3QpXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMuYmluZCh0aGlzKSgkJCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcclxuXHJcblx0XHRpZiAoaW5wdXRUeXBlID09PSBcIm1vdXNlXCIpIHtcclxuXHRcdFx0cmVjdFxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlciBtb3VzZW1vdmVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyh0aGlzKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsICgpID0+IHtcclxuXHRcdFx0XHRcdC8vIGNoYXJ0IGlzIGRlc3Ryb3llZFxyXG5cdFx0XHRcdFx0aWYgKCEkJC5jb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHRjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTKGN0eCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSBjdHg7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSh0YXJnZXRzVG9TaG93KSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKHRoaXMpO1xyXG5cdFx0Y29uc3QgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xyXG5cclxuXHRcdGlmICghY2xvc2VzdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2VsZWN0IGlmIHNlbGVjdGlvbiBlbmFibGVkXHJcblx0XHRpZiAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSB7XHJcblx0XHRcdCQkLiRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoY2xvc2VzdC5pZCl9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtjbG9zZXN0LmluZGV4fWApXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBjbG9zZXN0KSkge1xyXG5cdFx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSh0aGlzLCBjbG9zZXN0LCBjbG9zZXN0LmluZGV4KTtcclxuXHRcdFx0XHRcdFx0Y29uZmlnLmRhdGFfb25jbGljay5iaW5kKCQkLmFwaSkoY2xvc2VzdCwgdGhpcyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7XHJcblx0YnJ1c2hYIGFzIGQzQnJ1c2hYLFxyXG5cdGJydXNoWSBhcyBkM0JydXNoWSxcclxuXHRicnVzaFNlbGVjdGlvbiBhcyBkM0JydXNoU2VsZWN0aW9uXHJcbn0gZnJvbSBcImQzLWJydXNoXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHticnVzaEVtcHR5LCBjYXBpdGFsaXplLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBnZXRSYW5kb20sIHBhcnNlRGF0ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgYnJ1c2guXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0QnJ1c2goKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgJGVsOiB7c3ViY2hhcnR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBzZXQgdGhlIGJydXNoXHJcblx0XHQkJC5icnVzaCA9IGlzUm90YXRlZCA/IGQzQnJ1c2hZKCkgOiBkM0JydXNoWCgpO1xyXG5cclxuXHRcdC8vIHNldCBcImJydXNoXCIgZXZlbnRcclxuXHRcdGNvbnN0IGJydXNoSGFuZGxlciA9ICgpID0+IHtcclxuXHRcdFx0JCQucmVkcmF3Rm9yQnJ1c2goKTtcclxuXHRcdH07XHJcblx0XHRjb25zdCBnZXRCcnVzaFNpemUgPSAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IGJydXNoID0gJCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xyXG5cdFx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XHJcblx0XHRcdFx0YnJ1c2hTaXplLndpZHRoID0gK2JydXNoLmF0dHIoXCJ3aWR0aFwiKTtcclxuXHRcdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBicnVzaFNpemVbaXNSb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl07XHJcblx0XHR9O1xyXG5cclxuXHRcdGxldCBsYXN0RG9tYWluO1xyXG5cdFx0bGV0IHRpbWVvdXQ7XHJcblxyXG5cdFx0JCQuYnJ1c2hcclxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdCQkLnN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHRcdFx0YnJ1c2hIYW5kbGVyKCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImJydXNoXCIsIGJydXNoSGFuZGxlcilcclxuXHRcdFx0Lm9uKFwiZW5kXCIsICgpID0+IHtcclxuXHRcdFx0XHRsYXN0RG9tYWluID0gc2NhbGUueC5vcmdEb21haW4oKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0JCQuYnJ1c2gudXBkYXRlUmVzaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRcdFx0bGFzdERvbWFpbiAmJiBkM0JydXNoU2VsZWN0aW9uKHNlbGVjdGlvbi5ub2RlKCkpICYmXHJcblx0XHRcdFx0XHR0aGlzLm1vdmUoc2VsZWN0aW9uLCBsYXN0RG9tYWluLm1hcChzY2FsZS5zdWJYLm9yZ1NjYWxlKCkpKTtcclxuXHRcdFx0fSwgMCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLmJydXNoLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBleHRlbnQgPSB0aGlzLmV4dGVudCgpKCk7XHJcblxyXG5cdFx0XHRpZiAoZXh0ZW50WzFdLmZpbHRlcih2ID0+IGlzTmFOKHYpKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRzdWJjaGFydC5tYWluICYmIHN1YmNoYXJ0Lm1haW4uc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKS5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc2V0IHRoZSBicnVzaCBleHRlbnRcclxuXHRcdCQkLmJydXNoLnNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuXHRcdFx0Y29uc3QgaCA9IGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCB8fCBnZXRCcnVzaFNpemUoKTtcclxuXHRcdFx0bGV0IGV4dGVudCA9ICQkLmdldEV4dGVudCgpO1xyXG5cclxuXHRcdFx0aWYgKCFleHRlbnQgJiYgc2NhbGUucmFuZ2UpIHtcclxuXHRcdFx0XHRleHRlbnQgPSBbWzAsIDBdLCBbc2NhbGUucmFuZ2UoKVsxXSwgaF1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZXh0ZW50KSkge1xyXG5cdFx0XHRcdGV4dGVudCA9IGV4dGVudC5tYXAoKHYsIGkpID0+IFt2LCBpID4gMCA/IGggOiBpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFtbeDAsIHkwXSwgW3gxLCB5MV1dLCB3aGVyZSBbeDAsIHkwXSBpcyB0aGUgdG9wLWxlZnQgY29ybmVyIGFuZCBbeDEsIHkxXSBpcyB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lclxyXG5cdFx0XHRpc1JvdGF0ZWQgJiYgZXh0ZW50WzFdLnJldmVyc2UoKTtcclxuXHRcdFx0dGhpcy5leHRlbnQoZXh0ZW50KTtcclxuXHJcblx0XHRcdC8vIHdoZW4gZXh0ZW50IHVwZGF0ZXMsIGJydXNoIHNlbGVjdGlvbiBhbHNvIGJlIHJlLWFwcGxpZWRcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2lzc3Vlcy8yOTE4XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbiA9ICgpID0+IChcclxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRzdWJjaGFydC5tYWluID8gc3ViY2hhcnQubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApIDogZDNTZWxlY3QoW10pXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIHN1YmNoYXJ0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFN1YmNoYXJ0KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjbGlwLCBoYXNBeGlzfSwgJGVsOiB7ZGVmcywgc3ZnLCBzdWJjaGFydCwgYXhpc319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFoYXNBeGlzKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB2aXNpYmlsaXR5ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCI7XHJcblx0XHRjb25zdCBjbGlwSWQgPSBgJHtjbGlwLmlkfS1zdWJjaGFydGA7XHJcblx0XHRjb25zdCBjbGlwUGF0aCA9ICQkLmdldENsaXBQYXRoKGNsaXBJZCk7XHJcblxyXG5cdFx0Y2xpcC5pZFN1YmNoYXJ0ID0gY2xpcElkO1xyXG5cdFx0JCQuYXBwZW5kQ2xpcChkZWZzLCBjbGlwSWQpO1xyXG5cdFx0JCQuaW5pdEJydXNoKCk7XHJcblxyXG5cdFx0c3ViY2hhcnQubWFpbiA9IHN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XHJcblxyXG5cdFx0Y29uc3Qge21haW59ID0gc3ViY2hhcnQ7XHJcblxyXG5cdFx0bWFpbi5zdHlsZShcInZpc2liaWxpdHlcIiwgdmlzaWJpbGl0eSk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcclxuXHRcdG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwUGF0aClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydCk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGJhciBjaGFydCBhcmVhXHJcblx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmIG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QmFycyk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGxpbmUgY2hhcnQgYXJlYVxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRMaW5lcyk7XHJcblxyXG5cdFx0Ly8gQWRkIGV4dGVudCByZWN0IGZvciBCcnVzaFxyXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmJydXNoKVxyXG5cdFx0XHQuY2FsbCgkJC5icnVzaCk7XHJcblxyXG5cdFx0Ly8gQVRURU5USU9OOiBUaGlzIG11c3QgYmUgY2FsbGVkIEFGVEVSIGNoYXJ0IGFkZGVkXHJcblx0XHQvLyBBZGQgQXhpc1xyXG5cdFx0YXhpcy5zdWJYID0gbWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuYXhpc1gpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YlhcIikpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIlwiIDogY2xpcC5wYXRoWEF4aXMpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF9zaG93ID8gdmlzaWJpbGl0eSA6IFwiaGlkZGVuXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBzdWIgY2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGFyZ2V0cyAkJC5kYXRhLnRhcmdldHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCh0YXJnZXRzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7c3ViY2hhcnQ6IHttYWlufX19ID0gJCQ7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRMaW5lID0gJCQuY2xhc3NDaGFydExpbmUuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQXJlYXMgPSAkJC5jbGFzc0FyZWFzLmJpbmQoJCQpO1xyXG5cclxuXHRcdGlmIChjb25maWcuc3ViY2hhcnRfc2hvdykge1xyXG5cdFx0XHQvLyAtLSBCYXIgLS0vL1xyXG5cdFx0XHRjb25zdCBiYXJVcGRhdGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRCYXJzfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRCYXJ9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEJhcik7XHJcblx0XHRcdGNvbnN0IGJhckVudGVyID0gYmFyVXBkYXRlLmVudGVyKClcclxuXHRcdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKVxyXG5cdFx0XHRcdC5tZXJnZShiYXJVcGRhdGUpO1xyXG5cclxuXHRcdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXHJcblx0XHRcdGJhckVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycyk7XHJcblxyXG5cdFx0XHQvLyAtLSBMaW5lIC0tLy9cclxuXHRcdFx0Y29uc3QgbGluZVVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydExpbmVzfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRMaW5lfWApXHJcblx0XHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKTtcclxuXHRcdFx0Y29uc3QgbGluZUVudGVyID0gbGluZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXHJcblx0XHRcdFx0Lm1lcmdlKGxpbmVVcGRhdGUpO1xyXG5cclxuXHRcdFx0Ly8gTGluZXMgZm9yIGVhY2ggZGF0YVxyXG5cdFx0XHRsaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMaW5lcyk7XHJcblxyXG5cdFx0XHQvLyBBcmVhXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJhcmVhXCIpICYmIGxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyZWFzKTtcclxuXHJcblx0XHRcdC8vIC0tIEJydXNoIC0tLy9cclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmJydXNofSByZWN0YClcclxuXHRcdFx0XHQuYXR0cihjb25maWcuYXhpc19yb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IHN0YXRlLndpZHRoMiA6IHN0YXRlLmhlaWdodDIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgYmFyIG9mIHRoZSBzdWIgY2hhcnRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZHVyYXRpb25Gb3JFeGl0IFRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUJhckZvclN1YmNoYXJ0KGR1cmF0aW9uRm9yRXhpdCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbDoge3N1YmNoYXJ0fX0gPSAkJDtcclxuXHJcblx0XHRzdWJjaGFydC5iYXIgPSBzdWJjaGFydC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcn1gKVxyXG5cdFx0XHQuZGF0YSgkJC5iYXJEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdWJjaGFydC5iYXJcclxuXHRcdFx0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRzdWJjaGFydC5iYXIgPSBzdWJjaGFydC5iYXJcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0Jhci5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIFwibm9uZVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2Uoc3ViY2hhcnQuYmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGhlIGJhciBvZiB0aGUgc3ViY2hhcnRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZHJhd0Jhck9uU3ViIHBhdGggaW4gc3ViY2hhcnQgbGluZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdCYXJGb3JTdWJjaGFydChkcmF3QmFyT25TdWI6IHN0cmluZywgd2l0aFRyYW5zaXRpb246IGJvb2xlYW4sIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHtiYXJ9ID0gdGhpcy4kZWwuc3ViY2hhcnQ7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gYmFyLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IGJhcilcclxuXHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXJPblN1YilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBsaW5lIG9mIHRoZSBzdWIgY2hhcnRcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb25Gb3JFeGl0IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxpbmVGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWw6IHtzdWJjaGFydH19ID0gJCQ7XHJcblxyXG5cdFx0c3ViY2hhcnQubGluZSA9IHN1YmNoYXJ0Lm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdWJjaGFydC5saW5lXHJcblx0XHRcdC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0c3ViY2hhcnQubGluZSA9IHN1YmNoYXJ0LmxpbmVcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0xpbmUuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKHN1YmNoYXJ0LmxpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgbGluZSBvZiB0aGUgc3ViY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkcmF3TGluZU9uU3ViIHBhdGggaW4gc3ViY2hhcnQgbGluZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICovXHJcblx0cmVkcmF3TGluZUZvclN1YmNoYXJ0KGRyYXdMaW5lT25TdWI6IHN0cmluZywgd2l0aFRyYW5zaXRpb246IGJvb2xlYW4sIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHtsaW5lfSA9IHRoaXMuJGVsLnN1YmNoYXJ0O1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxpbmUudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogbGluZSlcclxuXHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdMaW5lT25TdWIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgYXJlYSBvZiB0aGUgc3ViIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uRm9yRXhpdCBGYWRlLW91dCB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVBcmVhRm9yU3ViY2hhcnQoZHVyYXRpb25Gb3JFeGl0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsOiB7c3ViY2hhcnR9fSA9ICQkO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmFyZWEgPSBzdWJjaGFydC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJlYX1gKVxyXG5cdFx0XHQuZGF0YSgkJC5saW5lRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0c3ViY2hhcnQuYXJlYVxyXG5cdFx0XHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHN1YmNoYXJ0LmFyZWEgPSBzdWJjaGFydC5hcmVhXHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLnN0YXRlLm9yZ0FyZWFPcGFjaXR5ID0gZDNTZWxlY3QodGhpcykuc3R5bGUoXCJvcGFjaXR5XCIpO1xyXG5cdFx0XHRcdHJldHVybiBcIjBcIjtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm1lcmdlKHN1YmNoYXJ0LmFyZWEpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgYXJlYSBvZiB0aGUgc3ViY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBkcmF3QXJlYU9uU3ViIHBhdGggaW4gc3ViY2hhcnQgbGluZVxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICovXHJcblx0cmVkcmF3QXJlYUZvclN1YmNoYXJ0KGRyYXdBcmVhT25TdWI6IHN0cmluZywgd2l0aFRyYW5zaXRpb246IGJvb2xlYW4sIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHthcmVhfSA9IHRoaXMuJGVsLnN1YmNoYXJ0O1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IGFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogYXJlYSlcclxuXHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdBcmVhT25TdWIpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgdGhpcy5jb2xvcilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCB0aGlzLnN0YXRlLm9yZ0FyZWFPcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgc3ViY2hhcnQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHdpdGhTdWJjaGFydCB3aGV0aGVyIG9yIG5vdCB0byBzaG93IHN1YmNoYXJ0XHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uIGR1cmF0aW9uXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHNoYXBlIFNoYXBlJ3MgaW5mb1xyXG5cdCAqL1xyXG5cdHJlZHJhd1N1YmNoYXJ0KHdpdGhTdWJjaGFydDogYm9vbGVhbiwgZHVyYXRpb246IG51bWJlciwgc2hhcGUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge3N1YmNoYXJ0OiB7bWFpbn19fSA9ICQkO1xyXG5cclxuXHRcdG1haW4uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKTtcclxuXHJcblx0XHQvLyBzdWJjaGFydFxyXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdC8vIHJlZmxlY3QgbWFpbiBjaGFydCB0byBleHRlbnQgb24gc3ViY2hhcnQgaWYgem9vbWVkXHJcblx0XHRcdGlmIChkM0V2ZW50ICYmIGQzRXZlbnQudHlwZSA9PT0gXCJ6b29tXCIpIHtcclxuXHRcdFx0XHQkJC5icnVzaC51cGRhdGUoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHN1YmNoYXJ0IGVsZW1lbnRzIGlmIG5lZWRlZFxyXG5cdFx0XHRpZiAod2l0aFN1YmNoYXJ0KSB7XHJcblx0XHRcdFx0Ly8gZXh0ZW50IHJlY3RcclxuXHRcdFx0XHQhYnJ1c2hFbXB0eSgkJCkgJiYgJCQuYnJ1c2gudXBkYXRlKCk7XHJcblxyXG5cdFx0XHRcdE9iamVjdC5rZXlzKHNoYXBlLnR5cGUpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBuYW1lID0gY2FwaXRhbGl6ZSh2KTtcclxuXHRcdFx0XHRcdGNvbnN0IGRyYXcgPSAkJFtgZ2VuZXJhdGVEcmF3JHtuYW1lfWBdKHNoYXBlLmluZGljZXNbdl0sIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdCQkW2B1cGRhdGUke25hbWV9Rm9yU3ViY2hhcnRgXShkdXJhdGlvbik7XHJcblx0XHRcdFx0XHQkJFtgcmVkcmF3JHtuYW1lfUZvclN1YmNoYXJ0YF0oZHJhdywgZHVyYXRpb24sIGR1cmF0aW9uKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgYnJ1c2guXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZWRyYXdGb3JCcnVzaCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWc6IHtzdWJjaGFydF9vbmJydXNoOiBvbkJydXNoLCB6b29tX3Jlc2NhbGU6IHdpdGhZfSwgc2NhbGV9ID0gJCQ7XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoWSxcclxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHRvbkJydXNoLmJpbmQoJCQuYXBpKShzY2FsZS54Lm9yZ0RvbWFpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm0gY29udGV4dFxyXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gd2l0aFRyYW5zaXRpb24gaW5kaWNhdGVzIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0cmFuc2l0aW9ucyBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBnZW5lcmF0ZVRyYW5zaXRpb25zIG1ldGhvZCBvZiBBeGlzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dHJhbnNmb3JtQ29udGV4dCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbC5zdWJjaGFydDtcclxuXHRcdGxldCBzdWJYQXhpcztcclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1N1YlgpIHtcclxuXHRcdFx0c3ViWEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzU3ViWDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1YlhBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0c3ViWEF4aXMgPSBzdWJYQXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRtYWluLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XHJcblx0XHRzdWJYQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YlhcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBleHRlbnQgdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IGRlZmF1bHQgZXh0ZW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRFeHRlbnQoKTogbnVtYmVyW10ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRsZXQgZXh0ZW50ID0gY29uZmlnLmF4aXNfeF9leHRlbnQ7XHJcblxyXG5cdFx0aWYgKGV4dGVudCkge1xyXG5cdFx0XHRpZiAoaXNGdW5jdGlvbihleHRlbnQpKSB7XHJcblx0XHRcdFx0ZXh0ZW50ID0gZXh0ZW50LmJpbmQoJCQuYXBpKSgkJC5nZXRYRG9tYWluKCQkLmRhdGEudGFyZ2V0cyksIHNjYWxlLnN1YlgpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCQkLmF4aXMuaXNUaW1lU2VyaWVzKCkgJiYgZXh0ZW50LmV2ZXJ5KGlzTmFOKSkge1xyXG5cdFx0XHRcdGNvbnN0IGZuID0gcGFyc2VEYXRlLmJpbmQoJCQpO1xyXG5cclxuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKHYgPT4gc2NhbGUuc3ViWChmbih2KSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV4dGVudDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdGV2ZW50IGFzIGQzRXZlbnQsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RyYWcgYXMgZDNEcmFnfSBmcm9tIFwiZDMtZHJhZ1wiO1xyXG5pbXBvcnQge3pvb20gYXMgZDNab29tfSBmcm9tIFwiZDMtem9vbVwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbiwgZGlmZkRvbWFpbiwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIGlzRnVuY3Rpb259IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgem9vbS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRab29tKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLnNjYWxlLnpvb20gPSBudWxsO1xyXG5cclxuXHRcdCQkLmdlbmVyYXRlWm9vbSgpO1xyXG5cdFx0JCQuaW5pdFpvb21CZWhhdmlvdXIoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBCaW5kIHpvb20gZXZlbnRcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGJpbmQgV2VhdGhlciBiaW5kIG9yIHVuYm91bmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRab29tRXZlbnQoYmluZCA9IHRydWUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkO1xyXG5cclxuXHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cclxuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKTtcclxuXHJcblx0XHRpZiAoem9vbUVuYWJsZWQgJiYgYmluZCkge1xyXG5cdFx0XHQvLyBEbyBub3QgYmluZCB6b29tIGV2ZW50IHdoZW4gc3ViY2hhcnQgaXMgc2hvd25cclxuXHRcdFx0IWNvbmZpZy5zdWJjaGFydF9zaG93ICYmXHJcblx0XHRcdFx0JCQuYmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB6b29tRW5hYmxlZC50eXBlKTtcclxuXHRcdH0gZWxzZSBpZiAoYmluZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0JCQuYXBpLnVuem9vbSgpO1xyXG5cclxuXHRcdFx0ZXZlbnRSZWN0c1xyXG5cdFx0XHRcdC5vbihcIi56b29tXCIsIG51bGwpXHJcblx0XHRcdFx0Lm9uKFwiLmRyYWdcIiwgbnVsbCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgem9vbVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVab29tKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnLCBzY2FsZX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCB6b29tID0gZDNab29tKCkuZHVyYXRpb24oMClcclxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgJCQub25ab29tU3RhcnQuYmluZCgkJCkpXHJcblx0XHRcdC5vbihcInpvb21cIiwgJCQub25ab29tLmJpbmQoJCQpKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgJCQub25ab29tRW5kLmJpbmQoJCQpKTtcclxuXHJcblx0XHQvLyBnZXQgem9vbSBleHRlbnRcclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHpvb20ub3JnU2NhbGVFeHRlbnQgPSAoKTogW251bWJlciwgbnVtYmVyXSA9PiB7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IGNvbmZpZy56b29tX2V4dGVudCB8fCBbMSwgMTBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtleHRlbnRbMF0sIE1hdGgubWF4KCQkLmdldE1heERhdGFDb3VudCgpIC8gZXh0ZW50WzFdLCBleHRlbnRbMV0pXTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0em9vbS51cGRhdGVTY2FsZUV4dGVudCA9IGZ1bmN0aW9uKCk6IHpvb20ge1xyXG5cdFx0XHRjb25zdCByYXRpbyA9IGRpZmZEb21haW4oJCQuc2NhbGUueC5vcmdEb21haW4oKSkgLyBkaWZmRG9tYWluKCQkLmdldFpvb21Eb21haW4oKSk7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMub3JnU2NhbGVFeHRlbnQoKTtcclxuXHJcblx0XHRcdHRoaXMuc2NhbGVFeHRlbnQoW2V4dGVudFswXSAqIHJhdGlvLCBleHRlbnRbMV0gKiByYXRpb10pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVXBkYXRlIHNjYWxlIGFjY29yZGluZyB6b29tIHRyYW5zZm9ybSB2YWx1ZVxyXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IHRyYW5zZm9ybSB0cmFuc2Zvcm0gb2JqZWN0XHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICovXHJcblx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHR6b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlID0gKHRyYW5zZm9ybTogb2JqZWN0KTogdm9pZCA9PiB7XHJcblx0XHRcdC8vIGluIGNhc2Ugb2YgcmVzaXplLCB1cGRhdGUgcmFuZ2Ugb2Ygb3JnWFNjYWxlXHJcblx0XHRcdG9yZy54U2NhbGUgJiYgb3JnLnhTY2FsZS5yYW5nZShzY2FsZS54LnJhbmdlKCkpO1xyXG5cclxuXHRcdFx0Ly8gcmVzY2FsZSBmcm9tIHRoZSBvcmlnaW5hbCBzY2FsZVxyXG5cdFx0XHRjb25zdCBuZXdTY2FsZSA9IHRyYW5zZm9ybVtcclxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJyZXNjYWxlWVwiIDogXCJyZXNjYWxlWFwiXHJcblx0XHRcdF0ob3JnLnhTY2FsZSB8fCBzY2FsZS54KTtcclxuXHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9ICQkLnRyaW1YRG9tYWluKG5ld1NjYWxlLmRvbWFpbigpKTtcclxuXHRcdFx0Y29uc3QgcmVzY2FsZSA9IGNvbmZpZy56b29tX3Jlc2NhbGU7XHJcblxyXG5cdFx0XHRuZXdTY2FsZS5kb21haW4oZG9tYWluLCBvcmcueERvbWFpbik7XHJcblxyXG5cdFx0XHRzY2FsZS56b29tID0gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKG5ld1NjYWxlKTtcclxuXHRcdFx0JCQuYXhpcy54LnNjYWxlKHNjYWxlLnpvb20pO1xyXG5cclxuXHRcdFx0aWYgKHJlc2NhbGUpIHtcclxuXHRcdFx0XHQvLyBjb3B5IGN1cnJlbnQgaW5pdGlhbCB4IHNjYWxlIGluIGNhc2Ugb2YgcmVzY2FsZSBvcHRpb24gaXMgdXNlZFxyXG5cdFx0XHRcdCFvcmcueFNjYWxlICYmIChvcmcueFNjYWxlID0gc2NhbGUueC5jb3B5KCkpO1xyXG5cdFx0XHRcdHNjYWxlLnguZG9tYWluKGRvbWFpbik7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0JCQuem9vbSA9IHpvb207XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogJ3N0YXJ0JyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tU3RhcnQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQuc291cmNlRXZlbnQ7XHJcblxyXG5cdFx0aWYgKCFldmVudCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuem9vbS5zdGFydEV2ZW50ID0gZXZlbnQ7XHJcblx0XHRjYWxsRm4oJCQuY29uZmlnLnpvb21fb256b29tc3RhcnQsICQkLmFwaSwgZXZlbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqICd6b29tJyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGUsIG9yZ30gPSAkJDtcclxuXHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudDtcclxuXHRcdGNvbnN0IHtzb3VyY2VFdmVudH0gPSBldmVudDtcclxuXHJcblx0XHRpZiAoXHJcblx0XHRcdCFjb25maWcuem9vbV9lbmFibGVkIHx8XHJcblx0XHRcdCFldmVudC5zb3VyY2VFdmVudCB8fFxyXG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoID09PSAwIHx8XHJcblx0XHRcdCghc2NhbGUuem9vbSAmJiBzb3VyY2VFdmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xICYmIHNvdXJjZUV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKVxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc01vdXNlbW92ZSA9IHNvdXJjZUV2ZW50LnR5cGUgPT09IFwibW91c2Vtb3ZlXCI7XHJcblx0XHRjb25zdCBpc1pvb21PdXQgPSBzb3VyY2VFdmVudC53aGVlbERlbHRhIDwgMDtcclxuXHRcdGNvbnN0IHt0cmFuc2Zvcm19ID0gZXZlbnQ7XHJcblxyXG5cdFx0aWYgKCFpc01vdXNlbW92ZSAmJiBpc1pvb21PdXQgJiYgc2NhbGUueC5kb21haW4oKS5ldmVyeSgodiwgaSkgPT4gdiAhPT0gb3JnLnhEb21haW5baV0pKSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKG9yZy54RG9tYWluKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKHRyYW5zZm9ybSk7XHJcblxyXG5cdFx0aWYgKCQkLmF4aXMuaXNDYXRlZ29yaXplZCgpICYmIHNjYWxlLngub3JnRG9tYWluKClbMF0gPT09IG9yZy54RG9tYWluWzBdKSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKFtvcmcueERvbWFpblswXSAtIDFlLTEwLCBzY2FsZS54Lm9yZ0RvbWFpbigpWzFdXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoWTogY29uZmlnLnpvb21fcmVzY2FsZSxcclxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcclxuXHRcdFx0d2l0aEV2ZW50UmVjdDogZmFsc2UsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHQkJC5zdGF0ZS5jYW5jZWxDbGljayA9IGlzTW91c2Vtb3ZlO1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbSwgJCQuYXBpLCBzY2FsZS56b29tLmRvbWFpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiAnZW5kJyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tRW5kKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRsZXQge3N0YXJ0RXZlbnR9ID0gJCQuem9vbTtcclxuXHRcdGxldCBldmVudCA9IGQzRXZlbnQgJiYgZDNFdmVudC5zb3VyY2VFdmVudDtcclxuXHJcblx0XHRpZiAoKHN0YXJ0RXZlbnQgJiYgc3RhcnRFdmVudC50eXBlLmluZGV4T2YoXCJ0b3VjaFwiKSA+IC0xKSkge1xyXG5cdFx0XHRzdGFydEV2ZW50ID0gc3RhcnRFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuXHRcdFx0ZXZlbnQgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiBjbGljaywgZG8gbm90aGluZy4gb3RoZXJ3aXNlLCBjbGljayBpbnRlcmFjdGlvbiB3aWxsIGJlIGNhbmNlbGVkLlxyXG5cdFx0aWYgKCFzdGFydEV2ZW50IHx8XHJcblx0XHRcdChldmVudCAmJiBzdGFydEV2ZW50LmNsaWVudFggPT09IGV2ZW50LmNsaWVudFggJiYgc3RhcnRFdmVudC5jbGllbnRZID09PSBldmVudC5jbGllbnRZKVxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXdFdmVudFJlY3QoKTtcclxuXHRcdCQkLnVwZGF0ZVpvb20oKTtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLnpvb21fb256b29tZW5kLCAkJC5hcGksIHNjYWxlW3NjYWxlLnpvb20gPyBcInpvb21cIiA6IFwic3ViWFwiXS5kb21haW4oKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHpvb20gZG9tYWluXHJcblx0ICogQHJldHVybnMge0FycmF5fSB6b29tIGRvbWFpblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Wm9vbURvbWFpbigpOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZ30gPSAkJDtcclxuXHRcdGxldCBbbWluLCBtYXhdID0gb3JnLnhEb21haW47XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjb25maWcuem9vbV94X21pbikpIHtcclxuXHRcdFx0bWluID0gZ2V0TWluTWF4KFwibWluXCIsIFttaW4sIGNvbmZpZy56b29tX3hfbWluXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjb25maWcuem9vbV94X21heCkpIHtcclxuXHRcdFx0bWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsIFttYXgsIGNvbmZpZy56b29tX3hfbWF4XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFttaW4sIG1heF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHpvb21cclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlIEZvcmNlIHVuem9vbVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlWm9vbShmb3JjZTogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N1YlgsIHgsIHpvb219ID0gJCQuc2NhbGU7XHJcblxyXG5cdFx0aWYgKHpvb20pIHtcclxuXHRcdFx0Y29uc3Qgem9vbURvbWFpbiA9IHpvb20uZG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSBzdWJYLmRvbWFpbigpO1xyXG5cdFx0XHRjb25zdCBkZWx0YSA9IDAuMDE1OyAvLyBhcmJpdHJhcnkgdmFsdWVcclxuXHJcblx0XHRcdGNvbnN0IGlzZnVsbHlTaG93biA9ICh6b29tRG9tYWluWzBdIDw9IHhEb21haW5bMF0gfHwgKHpvb21Eb21haW5bMF0gLSBkZWx0YSkgPD0geERvbWFpblswXSkgJiZcclxuXHRcdFx0XHQoeERvbWFpblsxXSA8PSB6b29tRG9tYWluWzFdIHx8IHhEb21haW5bMV0gPD0gKHpvb21Eb21haW5bMV0gLSBkZWx0YSkpO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHpvb21lZCBjaGFydCBpcyBmdWxseSBzaG93biwgdGhlbiByZXNldCBzY2FsZSB3aGVuIHpvb20gaXMgb3V0IGFzIGluaXRpYWxcclxuXHRcdFx0aWYgKGZvcmNlIHx8IGlzZnVsbHlTaG93bikge1xyXG5cdFx0XHRcdCQkLmF4aXMueC5zY2FsZShzdWJYKTtcclxuXHRcdFx0XHR4LmRvbWFpbihzdWJYLm9yZ0RvbWFpbigpKTtcclxuXHRcdFx0XHQkJC5zY2FsZS56b29tID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEF0dGFjaCB6b29tIGV2ZW50IG9uIDxyZWN0PlxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBldmVudFJlY3RzIGV2ZW10IDxyZWN0PiBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgem9vbSB0eXBlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRiaW5kWm9vbU9uRXZlbnRSZWN0KGV2ZW50UmVjdHMsIHR5cGU6IFwiZHJhZ1wiIHwgXCJ3aGVlbFwiKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBiZWhhdmlvdXIgPSB0eXBlID09PSBcImRyYWdcIiA/ICQkLnpvb21CZWhhdmlvdXIgOiAkJC56b29tO1xyXG5cclxuXHRcdGV2ZW50UmVjdHNcclxuXHRcdFx0LmNhbGwoYmVoYXZpb3VyKVxyXG5cdFx0XHQub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIGRyYWcgYmVoYXZpb3VyIHVzZWQgZm9yIHpvb21pbmcuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0Wm9vbUJlaGF2aW91cigpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gMDtcclxuXHRcdGxldCB6b29tUmVjdDtcclxuXHJcblx0XHRjb25zdCBwcm9wID0ge1xyXG5cdFx0XHRheGlzOiBpc1JvdGF0ZWQgPyBcInlcIiA6IFwieFwiLFxyXG5cdFx0XHRhdHRyOiBpc1JvdGF0ZWQgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLFxyXG5cdFx0XHRpbmRleDogaXNSb3RhdGVkID8gMSA6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0JCQuem9vbUJlaGF2aW91ciA9IGQzRHJhZygpXHJcblx0XHRcdC5jbGlja0Rpc3RhbmNlKDQpXHJcblx0XHRcdC5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGlmICghem9vbVJlY3QpIHtcclxuXHRcdFx0XHRcdHpvb21SZWN0ID0gJCQuJGVsLm1haW4uYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBzdGF0ZS5jbGlwLnBhdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbUJydXNoKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogMClcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0c3RhcnQgPSBkM01vdXNlKHRoaXMpW3Byb3AuaW5kZXhdO1xyXG5cdFx0XHRcdGVuZCA9IHN0YXJ0O1xyXG5cclxuXHRcdFx0XHR6b29tUmVjdFxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCBzdGFydClcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgMCk7XHJcblxyXG5cdFx0XHRcdCQkLm9uWm9vbVN0YXJ0KCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImRyYWdcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdGVuZCA9IGQzTW91c2UodGhpcylbcHJvcC5pbmRleF07XHJcblxyXG5cdFx0XHRcdHpvb21SZWN0XHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIE1hdGgubWluKHN0YXJ0LCBlbmQpKVxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCBNYXRoLmFicyhlbmQgLSBzdGFydCkpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZS56b29tIHx8ICQkLnNjYWxlLng7XHJcblxyXG5cdFx0XHRcdCQkLnNldERyYWdTdGF0dXMoZmFsc2UpO1xyXG5cclxuXHRcdFx0XHR6b29tUmVjdFxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCAwKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXJ0ID4gZW5kKSB7XHJcblx0XHRcdFx0XHRbc3RhcnQsIGVuZF0gPSBbZW5kLCBzdGFydF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoc3RhcnQgPCAwKSB7XHJcblx0XHRcdFx0XHRlbmQgKz0gTWF0aC5hYnMoc3RhcnQpO1xyXG5cdFx0XHRcdFx0c3RhcnQgPSAwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0YXJ0ICE9PSBlbmQpIHtcclxuXHRcdFx0XHRcdCQkLmFwaS56b29tKFtzdGFydCwgZW5kXS5tYXAodiA9PiBzY2FsZS5pbnZlcnQodikpKTtcclxuXHRcdFx0XHRcdCQkLm9uWm9vbUVuZCgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTLmJpbmQodGhpcykoJCQpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50LnNvdXJjZUV2ZW50IHx8IGQzRXZlbnQ7XHJcblx0XHRcdFx0XHRcdGNvbnN0IFt4LCB5XSA9IFwiY2xpZW50WFwiIGluIGV2ZW50ID8gW2V2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFldIDogW2V2ZW50LngsIGV2ZW50LnldO1xyXG5cdFx0XHRcdFx0XHRjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xyXG5cclxuXHRcdFx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yU2luZ2xlWC5iaW5kKHRhcmdldCkoZDNTZWxlY3QodGFyZ2V0KS5kYXR1bSgpLCAkJCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRzZXRab29tUmVzZXRCdXR0b24oKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgcmVzZXRCdXR0b24gPSBjb25maWcuem9vbV9yZXNldEJ1dHRvbjtcclxuXHJcblx0XHRpZiAocmVzZXRCdXR0b24gJiYgY29uZmlnLnpvb21fZW5hYmxlZC50eXBlID09PSBcImRyYWdcIikge1xyXG5cdFx0XHRpZiAoISQkLnpvb20ucmVzZXRCdG4pIHtcclxuXHRcdFx0XHQkJC56b29tLnJlc2V0QnRuID0gJCQuJGVsLmNoYXJ0LmFwcGVuZChcImRpdlwiKVxyXG5cdFx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MuYnV0dG9uLCB0cnVlKVxyXG5cdFx0XHRcdFx0LmFwcGVuZChcInNwYW5cIilcclxuXHRcdFx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKHJlc2V0QnV0dG9uLm9uY2xpY2spICYmIHJlc2V0QnV0dG9uLm9uY2xpY2suYmluZCgkJC5hcGkpKHRoaXMpO1xyXG5cdFx0XHRcdFx0XHQkJC5hcGkudW56b29tKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MuYnV0dG9uWm9vbVJlc2V0LCB0cnVlKVxyXG5cdFx0XHRcdFx0LnRleHQocmVzZXRCdXR0b24udGV4dCB8fCBcIlJlc2V0IFpvb21cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0Q2xpcCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjbGlwfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdC8vIE1FTU86IGNsaXBJZCBuZWVkcyB0byBiZSB1bmlxdWUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2hlbiBtdWx0aXBsZSBjaGFydHMgZXhpc3RcclxuXHRcdGNsaXAuaWQgPSBgJHskJC5zdGF0ZS5kYXRldGltZUlkfS1jbGlwYDtcclxuXHRcdGNsaXAuaWRYQXhpcyA9IGAke2NsaXAuaWR9LXhheGlzYDtcclxuXHRcdGNsaXAuaWRZQXhpcyA9IGAke2NsaXAuaWR9LXlheGlzYDtcclxuXHRcdGNsaXAuaWRHcmlkID0gYCR7Y2xpcC5pZH0tZ3JpZGA7XHJcblxyXG5cdFx0Ly8gRGVmaW5lICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSB2YWx1ZXNcclxuXHRcdGNsaXAucGF0aCA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWQpO1xyXG5cdFx0Y2xpcC5wYXRoWEF4aXMgPSAkJC5nZXRDbGlwUGF0aChjbGlwLmlkWEF4aXMpO1xyXG5cdFx0Y2xpcC5wYXRoWUF4aXMgPSAkJC5nZXRDbGlwUGF0aChjbGlwLmlkWUF4aXMpO1xyXG5cdFx0Y2xpcC5wYXRoR3JpZCA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRHcmlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDbGlwUGF0aChpZDogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgoIWNvbmZpZy5jbGlwUGF0aCAmJiAvLWNsaXAkLy50ZXN0KGlkKSkgfHxcclxuXHRcdFx0KCFjb25maWcuYXhpc194X2NsaXBQYXRoICYmIC8tY2xpcC14YXhpcyQvLnRlc3QoaWQpKSB8fFxyXG5cdFx0XHQoIWNvbmZpZy5heGlzX3lfY2xpcFBhdGggJiYgLy1jbGlwLXlheGlzJC8udGVzdChpZCkpKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzSUU5ID0gd2luZG93Lm5hdmlnYXRvciA/XHJcblx0XHRcdHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvblxyXG5cdFx0XHRcdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJtc2llIDkuXCIpID49IDAgOiBmYWxzZTtcclxuXHJcblx0XHRyZXR1cm4gYHVybCgkeyhpc0lFOSA/IFwiXCIgOiBkb2N1bWVudC5VUkwuc3BsaXQoXCIjXCIpWzBdKX0jJHtpZH0pYDtcclxuXHR9LFxyXG5cclxuXHRhcHBlbmRDbGlwKHBhcmVudCwgaWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0aWQgJiYgcGFyZW50LmFwcGVuZChcImNsaXBQYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiaWRcIiwgaWQpXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xyXG5cdH0sXHJcblxyXG5cdGdldEF4aXNDbGlwWChmb3JIb3Jpem9udGFsPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCB7bWFyZ2lufSA9IHRoaXMuc3RhdGU7XHJcblx0XHQvLyBheGlzIGxpbmUgd2lkdGggKyBwYWRkaW5nIGZvciBsZWZ0XHJcblx0XHRjb25zdCBsZWZ0ID0gTWF0aC5tYXgoMzAsIG1hcmdpbi5sZWZ0KTtcclxuXHJcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0oMSArIGxlZnQpIDogLShsZWZ0IC0gMSk7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBZKGZvckhvcml6b250YWw/OiBib29sZWFuKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0IHttYXJnaW59ID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IC0yMCA6IC1tYXJnaW4udG9wO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcFgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBYKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYQXhpc0NsaXBZKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwWSghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WUF4aXNDbGlwWCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuYXhpc195X2lubmVyID9cclxuXHRcdFx0LTEgOiAkJC5nZXRBeGlzQ2xpcFgoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WUF4aXNDbGlwWSgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBXaWR0aChmb3JIb3Jpem9udGFsPzogYm9vbGVhbik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bWFyZ2luLCB3aWR0aH0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cdFx0Y29uc3QgcmlnaHQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLnJpZ2h0KTtcclxuXHJcblx0XHQvLyB3aWR0aCArIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnQvcmlnaHRcclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID9cclxuXHRcdFx0d2lkdGggKyAyICsgbGVmdCArIHJpZ2h0IDogbWFyZ2luLmxlZnQgKyAyMDtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcEhlaWdodChmb3JIb3Jpem9udGFsPzogYm9vbGVhbik6IHZvaWQge1xyXG5cdFx0Y29uc3Qge21hcmdpbiwgaGVpZ2h0fSA9IHRoaXMuc3RhdGU7XHJcblxyXG5cdFx0Ly8gbGVzcyB0aGFuIDIwIGlzIG5vdCBlbm91Z2ggdG8gc2hvdyB0aGUgYXhpcyBsYWJlbCAnb3V0ZXInIHdpdGhvdXQgbGVnZW5kXHJcblx0XHRyZXR1cm4gKGZvckhvcml6b250YWwgPyBtYXJnaW4uYm90dG9tIDogKG1hcmdpbi50b3AgKyBoZWlnaHQpKSArIDIwO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcFdpZHRoKCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcEhlaWdodCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WUF4aXNDbGlwV2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBXaWR0aCgkJC5jb25maWcuYXhpc19yb3RhdGVkKSArICgkJC5jb25maWcuYXhpc195X2lubmVyID8gMjAgOiAwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZQXhpc0NsaXBIZWlnaHQoKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWEF4aXNUaWNrQ2xpcCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge2NsaXAsIHhBeGlzSGVpZ2h0fSwgJGVsOiB7ZGVmc319ID0gJCQ7XHJcblx0XHRjb25zdCBuZXdYQXhpc0hlaWdodCA9ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieFwiKTtcclxuXHJcblx0XHRpZiAoZGVmcyAmJiAhJCQuY2xpcFhBeGlzVGlja1RleHRzKSB7XHJcblx0XHRcdGNvbnN0IGNsaXBJZCA9IGAkeyQkLmNsaXBJZH0teGF4aXN0aWNrdGV4dHNgO1xyXG5cclxuXHRcdFx0JCQuYXBwZW5kQ2xpcChkZWZzLCBjbGlwSWQpO1xyXG5cdFx0XHRjbGlwLnBhdGhYQXhpc1RpY2tUZXh0cyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRYQXhpc1RpY2tUZXh0cyk7XHJcblx0XHRcdGNsaXAuaWRYQXhpc1RpY2tUZXh0cyA9IGNsaXBJZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoISQkLmNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUgJiZcclxuXHRcdFx0JCQuZ2V0QXhpc1RpY2tSb3RhdGUoXCJ4XCIpICYmXHJcblx0XHRcdG5ld1hBeGlzSGVpZ2h0ICE9PSB4QXhpc0hlaWdodFxyXG5cdFx0KSB7XHJcblx0XHRcdCQkLnNldFhBeGlzVGlja0NsaXBXaWR0aCgpO1xyXG5cdFx0XHQkJC5zZXRYQXhpc1RpY2tUZXh0Q2xpcFBhdGhXaWR0aCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnN0YXRlLnhBeGlzSGVpZ2h0ID0gbmV3WEF4aXNIZWlnaHQ7XHJcblx0fSxcclxuXHJcblx0c2V0WEF4aXNUaWNrQ2xpcFdpZHRoKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50OiB7bWF4VGlja1dpZHRoc319fSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHhBeGlzVGlja1JvdGF0ZSA9ICQkLmdldEF4aXNUaWNrUm90YXRlKFwieFwiKTtcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUgJiYgeEF4aXNUaWNrUm90YXRlKSB7XHJcblx0XHRcdGNvbnN0IHNpblJvdGF0aW9uID0gTWF0aC5zaW4oTWF0aC5QSSAvIDE4MCAqIE1hdGguYWJzKHhBeGlzVGlja1JvdGF0ZSkpO1xyXG5cclxuXHRcdFx0bWF4VGlja1dpZHRocy54LmNsaXBQYXRoID0gKCQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieFwiKSAtIDIwKSAvIHNpblJvdGF0aW9uO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWF4VGlja1dpZHRocy54LmNsaXBQYXRoID0gbnVsbDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzZXRYQXhpc1RpY2tUZXh0Q2xpcFBhdGhXaWR0aCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge2NsaXAsIGN1cnJlbnR9LCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChzdmcpIHtcclxuXHRcdFx0c3ZnLnNlbGVjdChgIyR7Y2xpcC5pZFhBeGlzVGlja1RleHRzfSByZWN0YClcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIGN1cnJlbnQubWF4VGlja1dpZHRocy54LmNsaXBQYXRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIDMwKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0c2VsZWN0QWxsIGFzIGQzU2VsZWN0QWxsXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNBcnJheSwgaXNWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vLyBHcmlkIHBvc2l0aW9uIGFuZCB0ZXh0IGFuY2hvciBoZWxwZXJzXHJcbmNvbnN0IGdldEdyaWRUZXh0QW5jaG9yID0gZCA9PiBpc1ZhbHVlKGQucG9zaXRpb24pIHx8IFwiZW5kXCI7XHJcbmNvbnN0IGdldEdyaWRUZXh0RHggPSBkID0+IChkLnBvc2l0aW9uID09PSBcInN0YXJ0XCIgPyA0IDogKGQucG9zaXRpb24gPT09IFwibWlkZGxlXCIgPyAwIDogLTQpKTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgZ3JpZCB0ZXh0IHggdmFsdWUgZ2V0dGVyIGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNYIElzIHggQXhpc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggdmFsdWVcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgdmFsdWVcclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R3JpZFRleHRYKGlzWCwgd2lkdGgsIGhlaWdodCk6IEZ1bmN0aW9uIHtcclxuXHRyZXR1cm4gZCA9PiB7XHJcblx0XHRsZXQgeCA9IGlzWCA/IDAgOiB3aWR0aDtcclxuXHJcblx0XHRpZiAoZC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XHJcblx0XHRcdHggPSBpc1ggPyAtaGVpZ2h0IDogMDtcclxuXHRcdH0gZWxzZSBpZiAoZC5wb3NpdGlvbiA9PT0gXCJtaWRkbGVcIikge1xyXG5cdFx0XHR4ID0gKGlzWCA/IC1oZWlnaHQgOiB3aWR0aCkgLyAyO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB4O1xyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgY29vcmRpbmF0ZSBhdHRyaWJ1dGVzIHZhbHVlXHJcbiAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBlbCBUYXJnZXQgbm9kZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzbW9vdGhMaW5lcyhlbCwgdHlwZTogc3RyaW5nKTogdm9pZCB7XHJcblx0aWYgKHR5cGUgPT09IFwiZ3JpZFwiKSB7XHJcblx0XHRlbC5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBnID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRbXCJ4MVwiLCBcIngyXCIsIFwieTFcIiwgXCJ5MlwiXVxyXG5cdFx0XHRcdC5mb3JFYWNoKHYgPT4gZy5hdHRyKHYsIE1hdGguY2VpbCgrZy5hdHRyKHYpKSkpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aGFzR3JpZCgpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gW1wieFwiLCBcInlcIl1cclxuXHRcdFx0LnNvbWUodiA9PiBjb25maWdbYGdyaWRfJHt2fV9zaG93YF0gfHwgY29uZmlnW2BncmlkXyR7dn1fbGluZXNgXS5sZW5ndGgpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRHcmlkKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmhhc0dyaWQoKSAmJiAkJC5pbml0R3JpZExpbmVzKCk7XHJcblx0XHQkJC5jb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiAkJC5pbml0Rm9jdXNHcmlkKCk7XHJcblx0fSxcclxuXHJcblx0aW5pdEdyaWRMaW5lcygpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y2xpcH0sICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpIHtcclxuXHRcdFx0JGVsLmdyaWRMaW5lcy5tYWluID0gJGVsLm1haW4uaW5zZXJ0KFwiZ1wiLCBgLiR7Q0xBU1MuY2hhcnR9JHtjb25maWcuZ3JpZF9saW5lc19mcm9udCA/IFwiICsgKlwiIDogXCJcIn1gKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXAucGF0aEdyaWQpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBgJHtDTEFTUy5ncmlkfSAke0NMQVNTLmdyaWRMaW5lc31gKTtcclxuXHJcblx0XHRcdCRlbC5ncmlkTGluZXMubWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy54Z3JpZExpbmVzKTtcclxuXHRcdFx0JGVsLmdyaWRMaW5lcy5tYWluLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkTGluZXMpO1xyXG5cclxuXHRcdFx0JGVsLmdyaWRMaW5lcy54ID0gZDNTZWxlY3RBbGwoW10pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVhHcmlkKHdpdGhvdXRVcGRhdGUpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZSwgJGVsOiB7bWFpbiwgZ3JpZH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgeGdyaWREYXRhID0gJCQuZ2VuZXJhdGVHcmlkRGF0YShjb25maWcuZ3JpZF94X3R5cGUsIHNjYWxlLngpO1xyXG5cdFx0Y29uc3QgdGlja09mZnNldCA9ICQkLmF4aXMuaXNDYXRlZ29yaXplZCgpID8gJCQuYXhpcy54LnRpY2tPZmZzZXQoKSA6IDA7XHJcblx0XHRjb25zdCBwb3MgPSBkID0+IChcclxuXHRcdFx0KHNjYWxlLnpvb20gfHwgc2NhbGUueCkoZCkgKyAoXHJcblx0XHRcdFx0dGlja09mZnNldCAqIChpc1JvdGF0ZWQgPyAtMSA6IDEpXHJcblx0XHRcdCkpO1xyXG5cclxuXHRcdHN0YXRlLnhncmlkQXR0ciA9IGlzUm90YXRlZCA/IHtcclxuXHRcdFx0XCJ4MVwiOiAwLFxyXG5cdFx0XHRcIngyXCI6IHN0YXRlLndpZHRoLFxyXG5cdFx0XHRcInkxXCI6IHBvcyxcclxuXHRcdFx0XCJ5MlwiOiBwb3MsXHJcblx0XHR9IDoge1xyXG5cdFx0XHRcIngxXCI6IHBvcyxcclxuXHRcdFx0XCJ4MlwiOiBwb3MsXHJcblx0XHRcdFwieTFcIjogMCxcclxuXHRcdFx0XCJ5MlwiOiBzdGF0ZS5oZWlnaHQsXHJcblx0XHR9O1xyXG5cclxuXHRcdGdyaWQueCA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy54Z3JpZHN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWR9YClcclxuXHRcdFx0LmRhdGEoeGdyaWREYXRhKTtcclxuXHJcblx0XHRncmlkLnguZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdGdyaWQueCA9IGdyaWQueC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWQpXHJcblx0XHRcdC5tZXJnZShncmlkLngpO1xyXG5cclxuXHRcdGlmICghd2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRncmlkLnguZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCBncmlkID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdE9iamVjdC5rZXlzKHN0YXRlLnhncmlkQXR0cikuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdFx0XHRncmlkLmF0dHIoaWQsIHN0YXRlLnhncmlkQXR0cltpZF0pXHJcblx0XHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgKCkgPT4gKFxyXG5cdFx0XHRcdFx0XHRcdGdyaWQuYXR0cihpc1JvdGF0ZWQgPyBcInkxXCIgOiBcIngxXCIpID09PSAoaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0IDogMCkgP1xyXG5cdFx0XHRcdFx0XHRcdFx0XCIwXCIgOiBcIjFcIlxyXG5cdFx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWUdyaWQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7Z3JpZCwgbWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgZ3JpZFZhbHVlcyA9ICQkLmF4aXMueS50aWNrVmFsdWVzKCkgfHwgJCQuc2NhbGUueS50aWNrcyhjb25maWcuZ3JpZF95X3RpY2tzKTtcclxuXHRcdGNvbnN0IHBvcyA9IGQgPT4gTWF0aC5jZWlsKCQkLnNjYWxlLnkoZCkpO1xyXG5cclxuXHRcdGdyaWQueSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy55Z3JpZHN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueWdyaWR9YClcclxuXHRcdFx0LmRhdGEoZ3JpZFZhbHVlcyk7XHJcblxyXG5cdFx0Z3JpZC55LmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRncmlkLnkgPSBncmlkLnlcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZClcclxuXHRcdFx0Lm1lcmdlKGdyaWQueSk7XHJcblxyXG5cdFx0Z3JpZC55LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyBwb3MgOiAwKVxyXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHBvcyA6IHN0YXRlLndpZHRoKVxyXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IDAgOiBwb3MpXHJcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0IDogcG9zKTtcclxuXHJcblx0XHRzbW9vdGhMaW5lcyhncmlkLnksIFwiZ3JpZFwiKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVHcmlkKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsOiB7Z3JpZCwgZ3JpZExpbmVzfX0gPSAkJDtcclxuXHJcblx0XHQhZ3JpZExpbmVzLm1haW4gJiYgJCQuaW5pdEdyaWRMaW5lcygpO1xyXG5cclxuXHRcdC8vIGhpZGUgaWYgYXJjIHR5cGVcclxuXHRcdGdyaWQubWFpbi5zdHlsZShcInZpc2liaWxpdHlcIiwgJCQuaGFzQXJjVHlwZSgpID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcclxuXHJcblx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHQkJC51cGRhdGVYR3JpZExpbmVzKGR1cmF0aW9uKTtcclxuXHRcdCQkLnVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBYIEdyaWQgbGluZXNcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gZHVyYXRpb24gRHJhdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtncmlkTGluZXMsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRjb25maWcuZ3JpZF94X3Nob3cgJiYgJCQudXBkYXRlWEdyaWQoKTtcclxuXHJcblx0XHRsZXQgeExpbmVzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLnhncmlkTGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWRMaW5lfWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5ncmlkX3hfbGluZXMpO1xyXG5cclxuXHRcdC8vIGV4aXRcclxuXHRcdHhMaW5lcy5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIGVudGVyXHJcblx0XHRjb25zdCB4Z3JpZExpbmUgPSB4TGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdHhncmlkTGluZS5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHhncmlkTGluZS5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGlzUm90YXRlZCA/IFwiXCIgOiBcInJvdGF0ZSgtOTApXCIpXHJcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHhMaW5lcyA9IHhncmlkTGluZS5tZXJnZSh4TGluZXMpO1xyXG5cclxuXHRcdHhMaW5lc1xyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueGdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcclxuXHRcdFx0LnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBnZXRHcmlkVGV4dEFuY2hvcilcclxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0Z3JpZExpbmVzLnggPSB4TGluZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIFkgR3JpZCBsaW5lc1xyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkdXJhdGlvbiBEdXJhdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlWUdyaWRMaW5lcyhkdXJhdGlvbjogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3dpZHRoLCBoZWlnaHR9LCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbmZpZy5ncmlkX3lfc2hvdyAmJiAkJC51cGRhdGVZR3JpZCgpO1xyXG5cclxuXHRcdGxldCB5Z3JpZExpbmVzID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy55Z3JpZExpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnlncmlkTGluZX1gKVxyXG5cdFx0XHQuZGF0YShjb25maWcuZ3JpZF95X2xpbmVzKTtcclxuXHJcblx0XHQvLyBleGl0XHJcblx0XHR5Z3JpZExpbmVzLmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIGVudGVyXHJcblx0XHRjb25zdCB5Z3JpZExpbmUgPSB5Z3JpZExpbmVzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBpc1JvdGF0ZWQgPyBcInJvdGF0ZSgtOTApXCIgOiBcIlwiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHR5Z3JpZExpbmVzID0geWdyaWRMaW5lLm1lcmdlKHlncmlkTGluZXMpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZVxyXG5cdFx0Y29uc3QgeXYgPSAkJC55di5iaW5kKCQkKTtcclxuXHJcblx0XHR5Z3JpZExpbmVzXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHtDTEFTUy55Z3JpZExpbmV9ICR7ZC5jbGFzcyB8fCBcIlwifWAudHJpbSgpKVxyXG5cdFx0XHQuc2VsZWN0KFwibGluZVwiKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyB5diA6IDApXHJcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8geXYgOiB3aWR0aClcclxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogeXYpXHJcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gaGVpZ2h0IDogeXYpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgZ2V0R3JpZFRleHRBbmNob3IpXHJcblx0XHRcdC5hdHRyKFwiZHhcIiwgZ2V0R3JpZFRleHREeClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBnZXRHcmlkVGV4dFgoaXNSb3RhdGVkLCB3aWR0aCwgaGVpZ2h0KSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHl2KVxyXG5cdFx0XHQudGV4dChkID0+IGQudGV4dClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHJcblx0XHQkZWwuZ3JpZExpbmVzLnkgPSB5Z3JpZExpbmVzO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0dyaWQod2l0aFRyYW5zaXRpb246IGJvb2xlYW4pOiBhbnlbXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGNvbmZpZzoge2F4aXNfcm90YXRlZDogaXNSb3RhdGVkfSxcclxuXHRcdFx0c3RhdGU6IHt3aWR0aCwgaGVpZ2h0fSxcclxuXHRcdFx0JGVsOiB7Z3JpZExpbmVzfVxyXG5cdFx0fSA9ICQkO1xyXG5cdFx0Y29uc3QgeHYgPSAkJC54di5iaW5kKCQkKTtcclxuXHJcblx0XHRsZXQgbGluZXMgPSBncmlkTGluZXMueC5zZWxlY3QoXCJsaW5lXCIpO1xyXG5cdFx0bGV0IHRleHRzID0gZ3JpZExpbmVzLnguc2VsZWN0KFwidGV4dFwiKTtcclxuXHJcblx0XHRsaW5lcyA9ICh3aXRoVHJhbnNpdGlvbiA/IGxpbmVzLnRyYW5zaXRpb24oKSA6IGxpbmVzKVxyXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dilcclxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyB3aWR0aCA6IHh2KVxyXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IHh2IDogMClcclxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyB4diA6IGhlaWdodCk7XHJcblxyXG5cdFx0dGV4dHMgPSAod2l0aFRyYW5zaXRpb24gPyB0ZXh0cy50cmFuc2l0aW9uKCkgOiB0ZXh0cylcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIGdldEdyaWRUZXh0WCghaXNSb3RhdGVkLCB3aWR0aCwgaGVpZ2h0KSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHh2KVxyXG5cdFx0XHQudGV4dChkID0+IGQudGV4dCk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gbGluZXMudHJhbnNpdGlvbigpIDogbGluZXMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIiksXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdGluaXRGb2N1c0dyaWQoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXB9LCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc0Zyb250ID0gY29uZmlnLmdyaWRfZnJvbnQ7XHJcblx0XHRjb25zdCBjbGFzc05hbWUgPSBgLiR7Q0xBU1NbaXNGcm9udCAmJiAkZWwuZ3JpZExpbmVzLm1haW4gPyBcImdyaWRMaW5lc1wiIDogXCJjaGFydFwiXX0ke2lzRnJvbnQgPyBcIiArICpcIiA6IFwiXCJ9YDtcclxuXHJcblx0XHRjb25zdCBncmlkID0gJGVsLm1haW4uaW5zZXJ0KFwiZ1wiLCBjbGFzc05hbWUpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXAucGF0aEdyaWQpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZ3JpZCk7XHJcblxyXG5cdFx0JGVsLmdyaWQubWFpbiA9IGdyaWQ7XHJcblxyXG5cdFx0Y29uZmlnLmdyaWRfeF9zaG93ICYmXHJcblx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRzKTtcclxuXHJcblx0XHRjb25maWcuZ3JpZF95X3Nob3cgJiZcclxuXHRcdFx0Z3JpZC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZHMpO1xyXG5cclxuXHRcdGlmIChjb25maWcuZ3JpZF9mb2N1c19zaG93KSB7XHJcblx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cylcclxuXHRcdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cyk7XHJcblxyXG5cdFx0XHQvLyB0byBzaG93IHh5IGZvY3VzIGdyaWQgbGluZSwgc2hvdWxkIGJlICd0b29sdGlwLmdyb3VwZWQ9ZmFsc2UnXHJcblx0XHRcdGlmIChjb25maWcuZ3JpZF9mb2N1c195ICYmICFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0Z3JpZC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkRm9jdXMpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZEZvY3VzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgZ3JpZCBmb2N1cyBsaW5lXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZGF0YSBTZWxlY3RlZCBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzaG93R3JpZEZvY3VzKGRhdGE/KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3dpZHRoLCBoZWlnaHR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGZvY3VzRWwgPSAkJC4kZWwubWFpbi5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfSwgbGluZS4ke0NMQVNTLnlncmlkRm9jdXN9YCk7XHJcblxyXG5cdFx0Y29uc3QgZGF0YVRvU2hvdyA9IChkYXRhIHx8IFtmb2N1c0VsLmRhdHVtKCldKS5maWx0ZXIoZCA9PiBkICYmIGlzVmFsdWUoJCQuZ2V0QmFzZVZhbHVlKGQpKSk7XHJcblxyXG5cdFx0Ly8gSGlkZSB3aGVuIGJ1YmJsZS9zY2F0dGVyL3N0YW5mb3JkIHBsb3QgZXhpc3RzXHJcblx0XHRpZiAoIWNvbmZpZy50b29sdGlwX3Nob3cgfHwgZGF0YVRvU2hvdy5sZW5ndGggPT09IDAgfHwgJCQuaGFzVHlwZShcImJ1YmJsZVwiKSB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzRWRnZSA9IGNvbmZpZy5ncmlkX2ZvY3VzX2VkZ2UgJiYgIWNvbmZpZy50b29sdGlwX2dyb3VwZWQ7XHJcblx0XHRjb25zdCB4eCA9ICQkLnh4LmJpbmQoJCQpO1xyXG5cclxuXHRcdGZvY3VzRWxcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIilcclxuXHRcdFx0LmRhdGEoZGF0YVRvU2hvdy5jb25jYXQoZGF0YVRvU2hvdykpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBlbCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IHBvcyA9IHtcclxuXHRcdFx0XHRcdHg6IHh4KGQpLFxyXG5cdFx0XHRcdFx0eTogJCQuZ2V0WVNjYWxlQnlJZChkLmlkKShkLnZhbHVlKVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0bGV0IHh5O1xyXG5cclxuXHRcdFx0XHRpZiAoZWwuY2xhc3NlZChDTEFTUy54Z3JpZEZvY3VzKSkge1xyXG5cdFx0XHRcdFx0Ly8gd2lsbCBjb250YWluICd4MSwgeTEsIHgyLCB5Micgb3JkZXJcclxuXHRcdFx0XHRcdHh5ID0gaXNSb3RhdGVkID9cclxuXHRcdFx0XHRcdFx0W1xyXG5cdFx0XHRcdFx0XHRcdG51bGwsIC8vIHgxXHJcblx0XHRcdFx0XHRcdFx0cG9zLngsIC8vIHkxXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlID8gcG9zLnkgOiB3aWR0aCwgLy8geDJcclxuXHRcdFx0XHRcdFx0XHRwb3MueCAvLyB5MlxyXG5cdFx0XHRcdFx0XHRdIDogW1xyXG5cdFx0XHRcdFx0XHRcdHBvcy54LFxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSA/IHBvcy55IDogbnVsbCxcclxuXHRcdFx0XHRcdFx0XHRwb3MueCxcclxuXHRcdFx0XHRcdFx0XHRoZWlnaHRcclxuXHRcdFx0XHRcdFx0XTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNZMiA9ICQkLmF4aXMuZ2V0SWQoZC5pZCkgPT09IFwieTJcIjtcclxuXHJcblx0XHRcdFx0XHR4eSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRcdFtcclxuXHRcdFx0XHRcdFx0XHRwb3MueSwgLy8geDFcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgJiYgIWlzWTIgPyBwb3MueCA6IG51bGwsIC8vIHkxXHJcblx0XHRcdFx0XHRcdFx0cG9zLnksIC8vIHgyXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlICYmIGlzWTIgPyBwb3MueCA6IGhlaWdodCAvLyB5MlxyXG5cdFx0XHRcdFx0XHRdIDogW1xyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSAmJiBpc1kyID8gcG9zLnggOiBudWxsLFxyXG5cdFx0XHRcdFx0XHRcdHBvcy55LFxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSAmJiAhaXNZMiA/IHBvcy54IDogd2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0cG9zLnlcclxuXHRcdFx0XHRcdFx0XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFtcIngxXCIsIFwieTFcIiwgXCJ4MlwiLCBcInkyXCJdXHJcblx0XHRcdFx0XHQuZm9yRWFjaCgodiwgaSkgPT4gZWwuYXR0cih2LCB4eVtpXSkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRzbW9vdGhMaW5lcyhmb2N1c0VsLCBcImdyaWRcIik7XHJcblx0XHQkJC5zaG93Q2lyY2xlRm9jdXMgJiYgJCQuc2hvd0NpcmNsZUZvY3VzKGRhdGEpO1xyXG5cdH0sXHJcblxyXG5cdGhpZGVHcmlkRm9jdXMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHtpbnB1dFR5cGV9LCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoaW5wdXRUeXBlID09PSBcIm1vdXNlXCIpIHtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfSwgbGluZS4ke0NMQVNTLnlncmlkRm9jdXN9YClcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG5cclxuXHRcdFx0JCQuaGlkZUNpcmNsZUZvY3VzICYmICQkLmhpZGVDaXJjbGVGb2N1cygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUdyaWRGb2N1cygpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge2lucHV0VHlwZSwgd2lkdGgsIGhlaWdodCwgcmVzaXppbmd9LCAkZWw6IHtncmlkfX0gPSAkJDtcclxuXHRcdGNvbnN0IHhncmlkRm9jdXMgPSBncmlkLm1haW4uc2VsZWN0KGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c31gKTtcclxuXHJcblx0XHRpZiAoaW5wdXRUeXBlID09PSBcInRvdWNoXCIpIHtcclxuXHRcdFx0aWYgKHhncmlkRm9jdXMuZW1wdHkoKSkge1xyXG5cdFx0XHRcdHJlc2l6aW5nICYmICQkLnNob3dDaXJjbGVGb2N1cygpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCQkLnNob3dHcmlkRm9jdXMoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRcdHhncmlkRm9jdXNcclxuXHRcdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiAtMTApXHJcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyB3aWR0aCA6IC0xMClcclxuXHRcdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IC0xMCA6IDApXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyAtMTAgOiBoZWlnaHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG5lZWQgdG8gcmV0dXJuICd0cnVlJyBhcyBvZiBiZWluZyBwdXNoZWQgdG8gdGhlIHJlZHJhdyBsaXN0XHJcblx0XHQvLyByZWY6IGdldFJlZHJhd0xpc3QoKVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHcmlkRGF0YSh0eXBlOiBzdHJpbmcsIHNjYWxlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0aWNrTnVtID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH1gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKFwiLnRpY2tcIilcclxuXHRcdFx0LnNpemUoKTtcclxuXHRcdGxldCBncmlkRGF0YTogRGF0ZVtdID0gW107XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09IFwieWVhclwiKSB7XHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSAkJC5nZXRYRG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IGZpcnN0WWVhciA9IHhEb21haW5bMF0uZ2V0RnVsbFllYXIoKTtcclxuXHRcdFx0Y29uc3QgbGFzdFllYXIgPSB4RG9tYWluWzFdLmdldEZ1bGxZZWFyKCk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gZmlyc3RZZWFyOyBpIDw9IGxhc3RZZWFyOyBpKyspIHtcclxuXHRcdFx0XHRncmlkRGF0YS5wdXNoKG5ldyBEYXRlKGAke2l9LTAxLTAxIDAwOjAwOjAwYCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRncmlkRGF0YSA9IHNjYWxlLnRpY2tzKDEwKTtcclxuXHJcblx0XHRcdGlmIChncmlkRGF0YS5sZW5ndGggPiB0aWNrTnVtKSB7IC8vIHVzZSBvbmx5IGludFxyXG5cdFx0XHRcdGdyaWREYXRhID0gZ3JpZERhdGEuZmlsdGVyKGQgPT4gU3RyaW5nKGQpLmluZGV4T2YoXCIuXCIpIDwgMCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ3JpZERhdGE7XHJcblx0fSxcclxuXHJcblx0Z2V0R3JpZEZpbHRlclRvUmVtb3ZlKHBhcmFtcyk6IEZ1bmN0aW9uIHtcclxuXHRcdHJldHVybiBwYXJhbXMgPyBsaW5lID0+IHtcclxuXHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHQoaXNBcnJheShwYXJhbXMpID8gcGFyYW1zLmNvbmNhdCgpIDogW3BhcmFtc10pLmZvckVhY2gocGFyYW0gPT4ge1xyXG5cdFx0XHRcdGlmICgoKFwidmFsdWVcIiBpbiBwYXJhbSAmJiBsaW5lLnZhbHVlID09PSBwYXJhbS52YWx1ZSkgfHwgKFwiY2xhc3NcIiBpbiBwYXJhbSAmJiBsaW5lLmNsYXNzID09PSBwYXJhbS5jbGFzcykpKSB7XHJcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBmb3VuZDtcclxuXHRcdH0gOiAoKSA9PiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUdyaWRMaW5lcyhwYXJhbXMsIGZvclg/OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdG9SZW1vdmUgPSAkJC5nZXRHcmlkRmlsdGVyVG9SZW1vdmUocGFyYW1zKTtcclxuXHRcdGNvbnN0IHRvU2hvdyA9IGxpbmUgPT4gIXRvUmVtb3ZlKGxpbmUpO1xyXG5cdFx0Y29uc3QgY2xhc3NMaW5lcyA9IGZvclggPyBDTEFTUy54Z3JpZExpbmVzIDogQ0xBU1MueWdyaWRMaW5lcztcclxuXHRcdGNvbnN0IGNsYXNzTGluZSA9IGZvclggPyBDTEFTUy54Z3JpZExpbmUgOiBDTEFTUy55Z3JpZExpbmU7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGAuJHtjbGFzc0xpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke2NsYXNzTGluZX1gKVxyXG5cdFx0XHQuZmlsdGVyKHRvUmVtb3ZlKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdGNvbnN0IGdyaWRMaW5lcyA9IGBncmlkXyR7Zm9yWCA/IFwieFwiIDogXCJ5XCJ9X2xpbmVzYDtcclxuXHJcblx0XHRjb25maWdbZ3JpZExpbmVzXSA9IGNvbmZpZ1tncmlkTGluZXNdLmZpbHRlcih0b1Nob3cpO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjsgLy8gc2VsZWN0aW9uXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtpc1ZhbHVlLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge0F4aXNUeXBlfSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0UmVnaW9uKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbH0gPSAkJDtcclxuXHJcblx0XHQkZWwucmVnaW9uLm1haW4gPSAkZWwubWFpbi5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsICQkLnN0YXRlLmNsaXAucGF0aClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5yZWdpb25zKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVSZWdpb24oZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICghJGVsLnJlZ2lvbi5tYWluKSB7XHJcblx0XHRcdCQkLmluaXRSZWdpb24oKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBoaWRlIGlmIGFyYyB0eXBlXHJcblx0XHQkZWwucmVnaW9uLm1haW4uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsICQkLmhhc0FyY1R5cGUoKSA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIik7XHJcblxyXG5cdFx0Ly8gc2VsZWN0IDxnPiBlbGVtZW50XHJcblx0XHRsZXQgbGlzdCA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MucmVnaW9uc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5yZWdpb259YClcclxuXHRcdFx0LmRhdGEoY29uZmlnLnJlZ2lvbnMpO1xyXG5cclxuXHRcdGxpc3QuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0bGlzdCA9IGxpc3QuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQubWVyZ2UobGlzdClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc1JlZ2lvbi5iaW5kKCQkKSk7XHJcblxyXG5cdFx0bGlzdFxyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdCRlbC5yZWdpb24ubGlzdCA9IGxpc3Q7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3UmVnaW9uKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgcmVnaW9ucyA9ICQkLiRlbC5yZWdpb24ubGlzdC5zZWxlY3QoXCJyZWN0XCIpO1xyXG5cclxuXHRcdHJlZ2lvbnMgPSAod2l0aFRyYW5zaXRpb24gPyByZWdpb25zLnRyYW5zaXRpb24oKSA6IHJlZ2lvbnMpXHJcblx0XHRcdC5hdHRyKFwieFwiLCAkJC5yZWdpb25YLmJpbmQoJCQpKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgJCQucmVnaW9uWS5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5yZWdpb25XaWR0aC5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQucmVnaW9uSGVpZ2h0LmJpbmQoJCQpKTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyByZWdpb25zLnRyYW5zaXRpb24oKSA6IHJlZ2lvbnMpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIGQgPT4gKGlzVmFsdWUoZC5vcGFjaXR5KSA/IGQub3BhY2l0eSA6IFwiMC4xXCIpKVxyXG5cdFx0XHRcdC5vbihcImVuZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdC8vIHJlbW92ZSB1bm5lY2Vzc2FyeSByZWN0IGFmdGVyIHRyYW5zaXRpb25cclxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMucGFyZW50Tm9kZSlcclxuXHRcdFx0XHRcdFx0LnNlbGVjdEFsbChcInJlY3Q6bm90KFt4XSlcIilcclxuXHRcdFx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdGdldFJlZ2lvblhZKHR5cGU6IEF4aXNUeXBlLCBkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGlzWCA9IHR5cGUgPT09IFwieFwiO1xyXG5cdFx0bGV0IGtleSA9IFwic3RhcnRcIjtcclxuXHRcdGxldCBjdXJyU2NhbGU7XHJcblx0XHRsZXQgcG9zID0gMDtcclxuXHJcblx0XHRpZiAoZC5heGlzID09PSBcInlcIiB8fCBkLmF4aXMgPT09IFwieTJcIikge1xyXG5cdFx0XHRpZiAoIWlzWCkge1xyXG5cdFx0XHRcdGtleSA9IFwiZW5kXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgoaXNYID8gaXNSb3RhdGVkIDogIWlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcclxuXHRcdFx0XHRjdXJyU2NhbGUgPSBzY2FsZVtkLmF4aXNdO1xyXG5cdFx0XHRcdHBvcyA9IGN1cnJTY2FsZShkW2tleV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKChpc1ggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRjdXJyU2NhbGUgPSBzY2FsZS56b29tIHx8IHNjYWxlLng7XHJcblx0XHRcdHBvcyA9IGN1cnJTY2FsZSgkJC5heGlzLmlzVGltZVNlcmllcygpID8gcGFyc2VEYXRlLmNhbGwoJCQsIGRba2V5XSkgOiBkW2tleV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb3M7XHJcblx0fSxcclxuXHJcblx0cmVnaW9uWChkKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieFwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRyZWdpb25ZKGQpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uWFkoXCJ5XCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFJlZ2lvblNpemUodHlwZSwgZCk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaXNXaWR0aCA9IHR5cGUgPT09IFwid2lkdGhcIjtcclxuXHRcdGNvbnN0IHN0YXJ0ID0gJCRbaXNXaWR0aCA/IFwicmVnaW9uWFwiIDogXCJyZWdpb25ZXCJdKGQpO1xyXG5cdFx0bGV0IGN1cnJTY2FsZTtcclxuXHRcdGxldCBrZXkgPSBcImVuZFwiO1xyXG5cdFx0bGV0IGVuZCA9IHN0YXRlW3R5cGVdO1xyXG5cclxuXHRcdGlmIChkLmF4aXMgPT09IFwieVwiIHx8IGQuYXhpcyA9PT0gXCJ5MlwiKSB7XHJcblx0XHRcdGlmICghaXNXaWR0aCkge1xyXG5cdFx0XHRcdGtleSA9IFwic3RhcnRcIjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKChpc1dpZHRoID8gaXNSb3RhdGVkIDogIWlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcclxuXHRcdFx0XHRjdXJyU2NhbGUgPSBzY2FsZVtkLmF4aXNdO1xyXG5cdFx0XHRcdGVuZCA9IGN1cnJTY2FsZShkW2tleV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKChpc1dpZHRoID8gIWlzUm90YXRlZCA6IGlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcclxuXHRcdFx0Y3VyclNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cdFx0XHRlbmQgPSBjdXJyU2NhbGUoJCQuYXhpcy5pc1RpbWVTZXJpZXMoKSA/IHBhcnNlRGF0ZS5jYWxsKCQkLCBkW2tleV0pIDogZFtrZXldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZW5kIDwgc3RhcnQgPyAwIDogZW5kIC0gc3RhcnQ7XHJcblx0fSxcclxuXHJcblx0cmVnaW9uV2lkdGgoZCk6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25TaXplKFwid2lkdGhcIiwgZCk7XHJcblx0fSxcclxuXHJcblx0cmVnaW9uSGVpZ2h0KGQpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcImhlaWdodFwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRpc1JlZ2lvbk9uWChkKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gIWQuYXhpcyB8fCBkLmF4aXMgPT09IFwieFwiO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtyZ2IgYXMgZDNSZ2J9IGZyb20gXCJkMy1jb2xvclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FsbEZufSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZWxlY3QgYSBwb2ludFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IHBvaW50XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBJbmRleCBudW1iZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNlbGVjdFBvaW50KHRhcmdldCwgZCwgaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBjeCA9IChpc1JvdGF0ZWQgPyAkJC5jaXJjbGVZIDogJCQuY2lyY2xlWCkuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjeSA9IChpc1JvdGF0ZWQgPyAkJC5jaXJjbGVYIDogJCQuY2lyY2xlWSkuYmluZCgkJCk7XHJcblx0XHRjb25zdCByID0gJCQucG9pbnRTZWxlY3RSLmJpbmQoJCQpO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuZGF0YV9vbnNlbGVjdGVkLCAkJC5hcGksIGQsIHRhcmdldC5ub2RlKCkpO1xyXG5cclxuXHRcdC8vIGFkZCBzZWxlY3RlZC1jaXJjbGUgb24gbG93IGxheWVyIGdcclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZX0tJHtpfWApXHJcblx0XHRcdC5kYXRhKFtkXSlcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImNpcmNsZVwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICgpID0+ICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2VsZWN0ZWRDaXJjbGUsIGkpKVxyXG5cdFx0XHQuYXR0cihcImN4XCIsIGN4KVxyXG5cdFx0XHQuYXR0cihcImN5XCIsIGN5KVxyXG5cdFx0XHQuYXR0cihcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0LmF0dHIoXCJyXCIsIGQyID0+ICQkLnBvaW50U2VsZWN0UihkMikgKiAxLjQpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKDEwMClcclxuXHRcdFx0LmF0dHIoXCJyXCIsIHIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuZWxlY3QgYSBwb2ludFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgVGFyZ2V0IHBvaW50XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBJbmRleCBudW1iZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVuc2VsZWN0UG9pbnQodGFyZ2V0LCBkLCBpOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb251bnNlbGVjdGVkLCAkJC5hcGksIGQsIHRhcmdldC5ub2RlKCkpO1xyXG5cclxuXHRcdC8vIHJlbW92ZSBzZWxlY3RlZC1jaXJjbGUgZnJvbSBsb3cgbGF5ZXIgZ1xyXG5cdFx0JGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZX0tJHtpfWApXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKDEwMClcclxuXHRcdFx0LmF0dHIoXCJyXCIsIDApXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2YgcG9pbnRzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBJbmRleCBudW1iZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRvZ2dsZVBvaW50KHNlbGVjdGVkLCB0YXJnZXQsIGQsIGk6IG51bWJlcik6IHZvaWQge1xyXG5cdFx0Y29uc3QgbWV0aG9kID0gYCR7c2VsZWN0ZWQgPyBcIlwiIDogXCJ1blwifXNlbGVjdFBvaW50YDtcclxuXHJcblx0XHR0aGlzW21ldGhvZF0odGFyZ2V0LCBkLCBpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZWxlY3QgYSBwYXRoXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgcGF0aFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZWxlY3RQYXRoKHRhcmdldCwgZCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2JyaWdodGVuKSB7XHJcblx0XHRcdHRhcmdldC50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgKCkgPT4gZDNSZ2IoJCQuY29sb3IoZCkpLmJyaWdodGVyKDAuNzUpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbmVsZWN0IGEgcGF0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgcGF0aFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICovXHJcblx0dW5zZWxlY3RQYXRoKHRhcmdldCwgZCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb251bnNlbGVjdGVkLCAkJC5hcGksIGQsIHRhcmdldC5ub2RlKCkpO1xyXG5cclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fYnJpZ2h0ZW4pIHtcclxuXHRcdFx0dGFyZ2V0LnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAoKSA9PiAkJC5jb2xvcihkKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIGxpbmVzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QuXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaSBJbmRleCBudW1iZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRvZ2dsZVBhdGgoc2VsZWN0ZWQsIHRhcmdldCwgZCwgaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzW1xyXG5cdFx0XHRgJHtzZWxlY3RlZCA/IFwiXCIgOiBcInVuXCJ9c2VsZWN0UGF0aGBcclxuXHRcdF0odGFyZ2V0LCBkLCBpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB0b2dnbGUgbWV0aG9kIG9mIHRoZSB0YXJnZXRcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gdGhhdCBzaGFwZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSB0b2dnbGUgbWV0aG9kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUb2dnbGUodGhhdCwgZCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gdGhhdC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIgP1xyXG5cdFx0XHQkJC50b2dnbGVQYXRoIDogKFxyXG5cdFx0XHRcdCQkLmlzU3RlcFR5cGUoZCkgP1xyXG5cdFx0XHRcdFx0KCkgPT4ge30gOiAvLyBjaXJjbGUgaXMgaGlkZGVuIGluIHN0ZXAgY2hhcnQsIHNvIHRyZWF0IGFzIHdpdGhpbiB0aGUgY2xpY2sgYXJlYVxyXG5cdFx0XHRcdFx0JCQudG9nZ2xlUG9pbnRcclxuXHRcdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2Ygc2hhcGVzXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IHRoYXQgc2hhcGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpIEluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dG9nZ2xlU2hhcGUodGhhdCwgZCwgaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhhdCk7XHJcblx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhhdCwgZCkuYmluZCgkJCk7XHJcblx0XHRsZXQgdG9nZ2xlZFNoYXBlO1xyXG5cclxuXHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSkge1xyXG5cdFx0XHRpZiAoIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9tdWx0aXBsZSkge1xyXG5cdFx0XHRcdGxldCBzZWxlY3RvciA9IGAuJHtDTEFTUy5zaGFwZXN9YDtcclxuXHJcblx0XHRcdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkKSB7XHJcblx0XHRcdFx0XHRzZWxlY3RvciArPSAkJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG1haW4uc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG5cdFx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKSkge1xyXG5cdFx0XHRcdFx0XHRcdHRvZ2dsZWRTaGFwZSA9IHNoYXBlO1xyXG5cdFx0XHRcdFx0XHRcdHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICghdG9nZ2xlZFNoYXBlIHx8IHRvZ2dsZWRTaGFwZS5ub2RlKCkgIT09IHNoYXBlLm5vZGUoKSkge1xyXG5cdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcclxuXHRcdFx0XHR0b2dnbGUoIWlzU2VsZWN0ZWQsIHNoYXBlLCBkLCBpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtBeGlzVHlwZX0gZnJvbSBcIi4uLy4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IEF4aXMgc2l6ZSBhY2NvcmRpbmcgaXRzIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIEF4aXMgaWQgdmFsdWUgLSB4LCB5IG9yIHkyXHJcblx0ICogQHJldHVybnMge251bWJlcn0gc2l6ZSBBeGlzIHNpemUgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEF4aXNTaXplKGlkOiBBeGlzVHlwZSk6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdHJldHVybiAoaXNSb3RhdGVkICYmIGlkID09PSBcInhcIikgfHwgKCFpc1JvdGF0ZWQgJiYgL3kyPy8udGVzdChpZCkpID9cclxuXHRcdFx0JCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoaWQsIHRydWUpIDpcclxuXHRcdFx0JCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkOiBBeGlzVHlwZSwgd2l0aG91dFJlY29tcHV0ZT86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdGlmICgkJC5heGlzKSB7XHJcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gJCQuYXhpcyAmJiAkJC5heGlzLmdldExhYmVsUG9zaXRpb25CeUlkKGlkKTtcclxuXHJcblx0XHRcdHJldHVybiAkJC5heGlzLmdldE1heFRpY2tXaWR0aChpZCwgd2l0aG91dFJlY29tcHV0ZSkgK1xyXG5cdFx0XHRcdChwb3NpdGlvbi5pc0lubmVyID8gMjAgOiA0MCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gNDA7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQ6IEF4aXNUeXBlKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3Qge2N1cnJlbnQsIHJvdGF0ZWRQYWRkaW5nLCBpc0xlZ2VuZFJpZ2h0LCBpc0xlZ2VuZEluc2V0fSA9IHN0YXRlO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCBoID0gMzA7XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInhcIiAmJiAhY29uZmlnLmF4aXNfeF9zaG93KSB7XHJcblx0XHRcdHJldHVybiA4O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ4XCIgJiYgY29uZmlnLmF4aXNfeF9oZWlnaHQpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfaGVpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ5XCIgJiYgIWNvbmZpZy5heGlzX3lfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmxlZ2VuZF9zaG93ICYmXHJcblx0XHRcdFx0IWlzTGVnZW5kUmlnaHQgJiZcclxuXHRcdFx0XHQhaXNMZWdlbmRJbnNldCA/IDEwIDogMTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaWQgPT09IFwieTJcIiAmJiAhY29uZmlnLmF4aXNfeTJfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gcm90YXRlZFBhZGRpbmcudG9wO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJvdGF0ZSA9ICQkLmdldEF4aXNUaWNrUm90YXRlKGlkKTtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgeC95IGF4aXMgaGVpZ2h0IHdoZW4gdGljayByb3RhdGVkXHJcblx0XHRpZiAoXHJcblx0XHRcdCgoaWQgPT09IFwieFwiICYmICFpc1JvdGF0ZWQpIHx8ICgveTI/Ly50ZXN0KGlkKSAmJiBpc1JvdGF0ZWQpKSAmJiByb3RhdGVcclxuXHRcdCkge1xyXG5cdFx0XHRoID0gMzAgK1xyXG5cdFx0XHRcdCQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkKSAqXHJcblx0XHRcdFx0TWF0aC5jb3MoTWF0aC5QSSAqICg5MCAtIHJvdGF0ZSkgLyAxODApO1xyXG5cclxuXHRcdFx0aWYgKCFjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lICYmIGN1cnJlbnQuaGVpZ2h0KSB7XHJcblx0XHRcdFx0aWYgKGggPiBjdXJyZW50LmhlaWdodCAvIDIpIHtcclxuXHRcdFx0XHRcdGggPSBjdXJyZW50LmhlaWdodCAvIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGggK1xyXG5cdFx0XHQoJCQuYXhpcy5nZXRMYWJlbFBvc2l0aW9uQnlJZChpZCkuaXNJbm5lciA/IDAgOiAxMCkgK1xyXG5cdFx0XHQoaWQgPT09IFwieTJcIiAmJiAhaXNSb3RhdGVkID8gLTEwIDogMCk7XHJcblx0fSxcclxuXHJcblx0Z2V0RXZlbnRSZWN0V2lkdGgoKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiBNYXRoLm1heCgwLCB0aGlzLmF4aXMueC50aWNrSW50ZXJ2YWwoKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGF4aXMgdGljayB0ZXN0IHJvdGF0ZSB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBeGlzIGlkXHJcblx0ICogQHJldHVybnMge251bWJlcn0gcm90YXRlIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRBeGlzVGlja1JvdGF0ZShpZDogQXhpc1R5cGUpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2F4aXMsIGNvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHRcdGxldCByb3RhdGUgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19yb3RhdGVgXTtcclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiKSB7XHJcblx0XHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSBheGlzLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHRcdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gYXhpcy5pc1RpbWVTZXJpZXMoKTtcclxuXHRcdFx0Y29uc3QgYWxsb3dlZFhBeGlzVHlwZXMgPSBpc0NhdGVnb3JpemVkIHx8IGlzVGltZVNlcmllcztcclxuXHRcdFx0bGV0IHRpY2tDb3VudCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfeF90aWNrX2ZpdCAmJiBhbGxvd2VkWEF4aXNUeXBlcykge1xyXG5cdFx0XHRcdHRpY2tDb3VudCA9IHN0YXRlLmN1cnJlbnQubWF4VGlja1dpZHRocy54LnRpY2tzLmxlbmd0aCArIChpc1RpbWVTZXJpZXMgPyAtMSA6IDEpO1xyXG5cclxuXHRcdFx0XHRpZiAodGlja0NvdW50ICE9PSBzdGF0ZS5heGlzLngudGlja0NvdW50KSB7XHJcblx0XHRcdFx0XHRzdGF0ZS5heGlzLngucGFkZGluZyA9ICQkLmF4aXMuZ2V0WEF4aXNQYWRkaW5nKHRpY2tDb3VudCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGF0ZS5heGlzLngudGlja0NvdW50ID0gdGlja0NvdW50O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoJGVsLnN2ZyAmJlxyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19maXQgJiZcclxuXHRcdFx0XHQhY29uZmlnLmF4aXNfeF90aWNrX211bHRpbGluZSAmJlxyXG5cdFx0XHRcdCFjb25maWcuYXhpc194X3RpY2tfY3VsbGluZyAmJlxyXG5cdFx0XHRcdGNvbmZpZy5heGlzX3hfdGlja19hdXRvcm90YXRlICYmXHJcblx0XHRcdFx0YWxsb3dlZFhBeGlzVHlwZXNcclxuXHRcdFx0KSB7XHJcblx0XHRcdFx0cm90YXRlID0gJCQubmVlZFRvUm90YXRlWEF4aXNUaWNrVGV4dHMoKSA/XHJcblx0XHRcdFx0XHRjb25maWcuYXhpc194X3RpY2tfcm90YXRlIDogMDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByb3RhdGU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgd2VhdGhlciBheGlzIHRpY2sgdGV4dCBuZWVkcyB0byBiZSByb3RhdGVkXHJcblx0ICogQHJldHVybnMge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRuZWVkVG9Sb3RhdGVYQXhpc1RpY2tUZXh0cygpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge2F4aXMsIGN1cnJlbnR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgeEF4aXNMZW5ndGggPSBjdXJyZW50LndpZHRoIC1cclxuXHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KGZhbHNlKSAtICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQodHJ1ZSk7XHJcblx0XHRjb25zdCB0aWNrQ291bnRXaXRoUGFkZGluZyA9IGF4aXMueC50aWNrQ291bnQgK1xyXG5cdFx0XHRheGlzLngucGFkZGluZy5sZWZ0ICsgYXhpcy54LnBhZGRpbmcucmlnaHQ7XHJcblxyXG5cdFx0Y29uc3QgbWF4VGlja1dpZHRoID0gJCQuYXhpcy5nZXRNYXhUaWNrV2lkdGgoXCJ4XCIpO1xyXG5cdFx0Y29uc3QgdGlja0xlbmd0aCA9ICh4QXhpc0xlbmd0aCAvIHRpY2tDb3VudFdpdGhQYWRkaW5nKSB8fCAwO1xyXG5cclxuXHRcdHJldHVybiBtYXhUaWNrV2lkdGggPiB0aWNrTGVuZ3RoO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogTW9kdWxlcyBleHBvcnRzIGZvciBBeGlzIGJhc2VkIGNoYXJ0XHJcbiAqL1xyXG4vLyBDaGFydFxyXG5pbXBvcnQgYXBpQXhpcyBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2F4aXNcIjtcclxuaW1wb3J0IGFwaUNhdGVnb3J5IGZyb20gXCIuLi8uLi9DaGFydC9hcGkvY2F0ZWdvcnlcIjtcclxuaW1wb3J0IGFwaUZsb3cgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9mbG93XCI7XHJcbmltcG9ydCBhcGlYR3JpZCBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2dyaWQueFwiO1xyXG5pbXBvcnQgYXBpWUdyaWQgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9ncmlkLnlcIjtcclxuaW1wb3J0IGFwaUdyb3VwIGZyb20gXCIuLi8uLi9DaGFydC9hcGkvZ3JvdXBcIjtcclxuaW1wb3J0IGFwaVJlZ2lvbiBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL3JlZ2lvbnNcIjtcclxuaW1wb3J0IGFwaVNlbGVjdGlvbiBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL3NlbGVjdGlvblwiO1xyXG5pbXBvcnQgYXBpWCBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL3hcIjtcclxuaW1wb3J0IGFwaVpvb20gZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS96b29tXCI7XHJcblxyXG4vLyBDaGFydEludGVybmFsXHJcbmltcG9ydCBheGlzIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL0F4aXMvQXhpc1wiO1xyXG5pbXBvcnQgZHJhZyBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZHJhZ1wiO1xyXG5pbXBvcnQgZmxvdyBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZmxvd1wiO1xyXG5pbXBvcnQgZXZlbnRyZWN0IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9ldmVudHJlY3RcIjtcclxuaW1wb3J0IHN1YmNoYXJ0IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9zdWJjaGFydFwiO1xyXG5pbXBvcnQgem9vbSBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvem9vbVwiO1xyXG5cclxuaW1wb3J0IGNsaXAgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NsaXBcIjtcclxuaW1wb3J0IGdyaWQgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2dyaWRcIjtcclxuaW1wb3J0IHJlZ2lvbiBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvcmVnaW9uXCI7XHJcbmltcG9ydCBzZWxlY3Rpb24gZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3NlbGVjdGlvblwiO1xyXG5pbXBvcnQgc2l6ZUF4aXMgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3NpemUuYXhpc1wiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGFwaSA9IFtcclxuXHRhcGlBeGlzLFxyXG5cdGFwaUNhdGVnb3J5LFxyXG5cdGFwaUZsb3csXHJcblx0YXBpWEdyaWQsXHJcblx0YXBpWUdyaWQsXHJcblx0YXBpR3JvdXAsXHJcblx0YXBpUmVnaW9uLFxyXG5cdGFwaVNlbGVjdGlvbixcclxuXHRhcGlYLFxyXG5cdGFwaVpvb21cclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBpbnRlcm5hbCA9IFtcclxuXHRheGlzLFxyXG5cdGRyYWcsXHJcblx0ZmxvdyxcclxuXHRzdWJjaGFydCxcclxuXHR6b29tLFxyXG5cclxuXHRjbGlwLFxyXG5cdGV2ZW50cmVjdCxcclxuXHRncmlkLFxyXG5cdHJlZ2lvbixcclxuXHRzZWxlY3Rpb24sXHJcblx0c2l6ZUF4aXNcclxuXTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge1xyXG5cdGFyYyBhcyBkM0FyYyxcclxuXHRwaWUgYXMgZDNQaWVcclxufSBmcm9tIFwiZDMtc2hhcGVcIjtcclxuaW1wb3J0IHtpbnRlcnBvbGF0ZSBhcyBkM0ludGVycG9sYXRlfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGVuZGFsbCwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzVW5kZWZpbmVkLCBzZXRUZXh0VmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0UGllKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFUeXBlID0gY29uZmlnLmRhdGFfdHlwZTtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcucGllX3BhZGRpbmc7XHJcblx0XHRjb25zdCBzdGFydGluZ0FuZ2xlID0gY29uZmlnW2Ake2RhdGFUeXBlfV9zdGFydGluZ0FuZ2xlYF0gfHwgMDtcclxuXHRcdGNvbnN0IHBhZEFuZ2xlID0gKFxyXG5cdFx0XHQkJC5oYXNUeXBlKFwicGllXCIpICYmIHBhZGRpbmcgPyBwYWRkaW5nICogMC4wMSA6XHJcblx0XHRcdFx0Y29uZmlnW2Ake2RhdGFUeXBlfV9wYWRBbmdsZWBdXHJcblx0XHQpIHx8IDA7XHJcblx0XHRjb25zdCBzb3J0VmFsdWU6IGFueSA9ICQkLmlzT3JkZXJBc2MoKSB8fCAkJC5pc09yZGVyRGVzYygpID9cclxuXHRcdFx0KGEsIGIpID0+ICgkJC5pc09yZGVyQXNjKCkgPyBhIC0gYiA6IGIgLSBhKSA6IG51bGw7XHJcblxyXG5cdFx0JCQucGllID0gZDNQaWUoKVxyXG5cdFx0XHQuc3RhcnRBbmdsZShzdGFydGluZ0FuZ2xlKVxyXG5cdFx0XHQuZW5kQW5nbGUoc3RhcnRpbmdBbmdsZSArICgyICogTWF0aC5QSSkpXHJcblx0XHRcdC5wYWRBbmdsZShwYWRBbmdsZSlcclxuXHRcdFx0LnNvcnRWYWx1ZXMoc29ydFZhbHVlKVxyXG5cdFx0XHQudmFsdWUoKGQ6IGFueSkgPT4gZC52YWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYi52YWx1ZSwgMCkpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGl1cygpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgcmFkaXVzID0gY29uZmlnLnBpZV9pbm5lclJhZGl1cztcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcucGllX3BhZGRpbmc7XHJcblx0XHRjb25zdCB3ID0gY29uZmlnLmdhdWdlX3dpZHRoIHx8IGNvbmZpZy5kb251dF93aWR0aDtcclxuXHRcdGNvbnN0IGdhdWdlQXJjV2lkdGggPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoICpcclxuXHRcdFx0Y29uZmlnLmdhdWdlX2FyY3NfbWluV2lkdGg7XHJcblxyXG5cdFx0c3RhdGUucmFkaXVzRXhwYW5kZWQgPSBNYXRoLm1pbihzdGF0ZS5hcmNXaWR0aCwgc3RhdGUuYXJjSGVpZ2h0KSAvIDIgKiAoXHJcblx0XHRcdCQkLmhhc011bHRpQXJjR2F1Z2UoKSA/IDAuODUgOiAxKTtcclxuXHRcdHN0YXRlLnJhZGl1cyA9IHN0YXRlLnJhZGl1c0V4cGFuZGVkICogMC45NTtcclxuXHRcdHN0YXRlLmlubmVyUmFkaXVzUmF0aW8gPSB3ID8gKHN0YXRlLnJhZGl1cyAtIHcpIC8gc3RhdGUucmFkaXVzIDogMC42O1xyXG5cdFx0c3RhdGUuZ2F1Z2VBcmNXaWR0aCA9IHcgfHwgKFxyXG5cdFx0XHRnYXVnZUFyY1dpZHRoIDw9IHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzdGF0ZS5pbm5lclJhZGl1cyA6XHJcblx0XHRcdFx0KGdhdWdlQXJjV2lkdGggPD0gc3RhdGUucmFkaXVzID8gZ2F1Z2VBcmNXaWR0aCA6IHN0YXRlLnJhZGl1cylcclxuXHRcdCk7XHJcblxyXG5cdFx0Y29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXMgfHwgKFxyXG5cdFx0XHRwYWRkaW5nID8gcGFkZGluZyAqIChzdGF0ZS5pbm5lclJhZGl1c1JhdGlvICsgMC4xKSA6IDBcclxuXHRcdCk7XHJcblxyXG5cdFx0Ly8gTk9URTogaW5uZXJSYWRpdXMgY2FuIGJlIGFuIG9iamVjdCBieSB1c2VyIHNldHRpbmcsIG9ubHkgZm9yICdwaWUnIHR5cGVcclxuXHRcdHN0YXRlLmlubmVyUmFkaXVzID0gJCQuaGFzVHlwZShcImRvbnV0XCIpIHx8ICQkLmhhc1R5cGUoXCJnYXVnZVwiKSA/XHJcblx0XHRcdHN0YXRlLnJhZGl1cyAqIHN0YXRlLmlubmVyUmFkaXVzUmF0aW8gOiBpbm5lclJhZGl1cztcclxuXHR9LFxyXG5cclxuXHRnZXRJbm5lclJhZGl1cyhkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB7aW5uZXJSYWRpdXN9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0aWYgKCFpc051bWJlcihpbm5lclJhZGl1cykgJiYgZCkge1xyXG5cdFx0XHRpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzW2QuZGF0YS5pZF0gfHwgMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5uZXJSYWRpdXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJjKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLnN2Z0FyYyA9ICQkLmdldFN2Z0FyYygpO1xyXG5cdFx0JCQuc3ZnQXJjRXhwYW5kZWQgPSAkJC5nZXRTdmdBcmNFeHBhbmRlZCgpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFuZ2xlKGRWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRsZXQgcGllID0gJCQucGllO1xyXG5cdFx0bGV0IGQgPSBkVmFsdWU7XHJcblx0XHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoIWNvbmZpZykge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByYWRpdXMgPSBNYXRoLlBJICogKGNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpO1xyXG5cdFx0Y29uc3QgZ1N0YXJ0ID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XHJcblxyXG5cdFx0aWYgKGQuZGF0YSAmJiAkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmICEkJC5oYXNNdWx0aUFyY0dhdWdlKCkpIHtcclxuXHRcdFx0Ly8gdG8gcHJldmVudCBleGNsdWRpbmcgdG90YWwgZGF0YSBzdW0gZHVyaW5nIHRoZSBpbml0KHdoZW4gZGF0YS5oaWRlIG9wdGlvbiBpcyB1c2VkKSwgdXNlICQkLnJlbmRlcmVkIHN0YXRlIHZhbHVlXHJcblx0XHRcdGNvbnN0IHRvdGFsU3VtID0gJCQuZ2V0VG90YWxEYXRhU3VtKHN0YXRlLnJlbmRlcmVkKTtcclxuXHJcblx0XHRcdC8vIGlmIGdhdWdlX21heCBsZXNzIHRoYW4gdG90YWxTdW0sIG1ha2UgdG90YWxTdW0gdG8gbWF4IHZhbHVlXHJcblx0XHRcdGlmICh0b3RhbFN1bSA+IGNvbmZpZy5nYXVnZV9tYXgpIHtcclxuXHRcdFx0XHRjb25maWcuZ2F1Z2VfbWF4ID0gdG90YWxTdW07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGdFbmQgPSByYWRpdXMgKiAodG90YWxTdW0gLyAoY29uZmlnLmdhdWdlX21heCAtIGNvbmZpZy5nYXVnZV9taW4pKTtcclxuXHJcblx0XHRcdHBpZSA9IHBpZVxyXG5cdFx0XHRcdC5zdGFydEFuZ2xlKGdTdGFydClcclxuXHRcdFx0XHQuZW5kQW5nbGUoZ0VuZCArIGdTdGFydCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cGllKCQkLmZpbHRlclRhcmdldHNUb1Nob3coKSlcclxuXHRcdFx0LmZvckVhY2goKHQsIGkpID0+IHtcclxuXHRcdFx0XHRpZiAoIWZvdW5kICYmIHQuZGF0YS5pZCA9PT0gZC5kYXRhLmlkKSB7XHJcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRkID0gdDtcclxuXHRcdFx0XHRcdGQuaW5kZXggPSBpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzTmFOKGQuc3RhcnRBbmdsZSkpIHtcclxuXHRcdFx0ZC5zdGFydEFuZ2xlID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNOYU4oZC5lbmRBbmdsZSkpIHtcclxuXHRcdFx0ZC5lbmRBbmdsZSA9IGQuc3RhcnRBbmdsZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZC5kYXRhICYmICQkLmhhc011bHRpQXJjR2F1Z2UoKSkge1xyXG5cdFx0XHRjb25zdCBtYXhWYWx1ZSA9ICQkLmdldE1pbk1heERhdGEoKS5tYXhbMF0udmFsdWU7XHJcblxyXG5cdFx0XHQvLyBpZiBnYXVnZV9tYXggbGVzcyB0aGFuIG1heFZhbHVlLCBtYWtlIG1heFZhbHVlIHRvIG1heCB2YWx1ZVxyXG5cdFx0XHRpZiAobWF4VmFsdWUgPiBjb25maWcuZ2F1Z2VfbWF4KSB7XHJcblx0XHRcdFx0Y29uZmlnLmdhdWdlX21heCA9IG1heFZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBnTWluID0gY29uZmlnLmdhdWdlX21pbjtcclxuXHRcdFx0Y29uc3QgZ01heCA9IGNvbmZpZy5nYXVnZV9tYXg7XHJcblx0XHRcdGNvbnN0IGdUaWMgPSByYWRpdXMgLyAoZ01heCAtIGdNaW4pO1xyXG5cdFx0XHRjb25zdCBnVmFsdWUgPSBkLnZhbHVlIDwgZ01pbiA/IDAgOiBkLnZhbHVlIDwgZ01heCA/IGQudmFsdWUgLSBnTWluIDogKGdNYXggLSBnTWluKTtcclxuXHJcblx0XHRcdGQuc3RhcnRBbmdsZSA9IGdTdGFydDtcclxuXHRcdFx0ZC5lbmRBbmdsZSA9IGdTdGFydCArIGdUaWMgKiBnVmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZvdW5kID8gZCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0U3ZnQXJjKCk6IEZ1bmN0aW9uIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlyID0gJCQuZ2V0SW5uZXJSYWRpdXMoKTtcclxuXHRcdGNvbnN0IHNpbmdsZUFyY1dpZHRoID0gc3RhdGUuZ2F1Z2VBcmNXaWR0aCAvICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGg7XHJcblx0XHRjb25zdCBoYXNNdWx0aUFyY0dhdWdlID0gJCQuaGFzTXVsdGlBcmNHYXVnZSgpO1xyXG5cclxuXHRcdGxldCBhcmMgPSBkM0FyYygpXHJcblx0XHRcdC5vdXRlclJhZGl1cygoZDogYW55KSA9PiAoXHJcblx0XHRcdFx0aGFzTXVsdGlBcmNHYXVnZSA/IChzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIGQuaW5kZXgpIDogc3RhdGUucmFkaXVzKSlcclxuXHRcdFx0LmlubmVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIChkLmluZGV4ICsgMSkgOlxyXG5cdFx0XHRcdGlzTnVtYmVyKGlyKSA/IGlyIDogMCkpO1xyXG5cclxuXHRcdGNvbnN0IG5ld0FyYyA9IGZ1bmN0aW9uKGQsIHdpdGhvdXRVcGRhdGUpIHtcclxuXHRcdFx0bGV0IHBhdGg6IHN0cmluZyB8IG51bGwgPSBcIk0gMCAwXCI7XHJcblxyXG5cdFx0XHRpZiAoZC52YWx1ZSB8fCBkLmRhdGEpIHtcclxuXHRcdFx0XHRpZiAoIWlzTnVtYmVyKGlyKSkge1xyXG5cdFx0XHRcdFx0YXJjID0gYXJjLmlubmVyUmFkaXVzKCQkLmdldElubmVyUmFkaXVzKGQpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAhd2l0aG91dFVwZGF0ZSAmJiAkJC51cGRhdGVBbmdsZShkKTtcclxuXHJcblx0XHRcdFx0aWYgKHdpdGhvdXRVcGRhdGUpIHtcclxuXHRcdFx0XHRcdHBhdGggPSBhcmMoZCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRwYXRoID0gYXJjKHVwZGF0ZWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGg7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFRPRE86IGV4dGVuZHMgYWxsIGZ1bmN0aW9uXHJcblx0XHRuZXdBcmMuY2VudHJvaWQgPSBhcmMuY2VudHJvaWQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ld0FyYztcclxuXHR9LFxyXG5cclxuXHRnZXRTdmdBcmNFeHBhbmRlZChyYXRlPzogbnVtYmVyKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgbmV3UmF0ZSA9IHJhdGUgfHwgMTtcclxuXHRcdGNvbnN0IHNpbmdsZUFyY1dpZHRoID0gc3RhdGUuZ2F1Z2VBcmNXaWR0aCAvICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGg7XHJcblx0XHRjb25zdCBoYXNNdWx0aUFyY0dhdWdlID0gJCQuaGFzTXVsdGlBcmNHYXVnZSgpO1xyXG5cdFx0Y29uc3QgZXhwYW5kV2lkdGggPSBNYXRoLm1pbihzdGF0ZS5yYWRpdXNFeHBhbmRlZCAqIG5ld1JhdGUgLSBzdGF0ZS5yYWRpdXMsXHJcblx0XHRcdHNpbmdsZUFyY1dpZHRoICogMC44IC0gKDEgLSBuZXdSYXRlKSAqIDEwMFxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBhcmMgPSBkM0FyYygpXHJcblx0XHRcdC5vdXRlclJhZGl1cygoZDogYW55KSA9PiAoaGFzTXVsdGlBcmNHYXVnZSA/XHJcblx0XHRcdFx0c3RhdGUucmFkaXVzIC0gc2luZ2xlQXJjV2lkdGggKiBkLmluZGV4ICsgZXhwYW5kV2lkdGggOlxyXG5cdFx0XHRcdHN0YXRlLnJhZGl1c0V4cGFuZGVkICogbmV3UmF0ZSlcclxuXHRcdFx0KVxyXG5cdFx0XHQuaW5uZXJSYWRpdXMoKGQ6IGFueSkgPT4gKGhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogKGQuaW5kZXggKyAxKSA6IHN0YXRlLmlubmVyUmFkaXVzKSk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cclxuXHRcdFx0aWYgKHVwZGF0ZWQpIHtcclxuXHRcdFx0XHRyZXR1cm4gKFxyXG5cdFx0XHRcdFx0aGFzTXVsdGlBcmNHYXVnZSA/IGFyYyA6IGFyYy5pbm5lclJhZGl1cygkJC5nZXRJbm5lclJhZGl1cyhkKSlcclxuXHRcdFx0XHQpKHVwZGF0ZWQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJldHVybiBcIk0gMCAwXCI7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0QXJjKGQsIHdpdGhvdXRVcGRhdGU6IGJvb2xlYW4sIGZvcmNlPzogYm9vbGVhbik6IHN0cmluZyB7XHJcblx0XHRyZXR1cm4gZm9yY2UgfHwgdGhpcy5pc0FyY1R5cGUoZC5kYXRhKSA/IHRoaXMuc3ZnQXJjKGQsIHdpdGhvdXRVcGRhdGUpIDogXCJNIDAgMFwiO1xyXG5cdH0sXHJcblxyXG5cdHRyYW5zZm9ybUZvckFyY0xhYmVsKGQpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtyYWRpdXMsIHJhZGl1c0V4cGFuZGVkfX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRsZXQgdHJhbnNsYXRlID0gXCJcIjtcclxuXHJcblx0XHRpZiAodXBkYXRlZCkge1xyXG5cdFx0XHRpZiAoJCQuaGFzTXVsdGlBcmNHYXVnZSgpKSB7XHJcblx0XHRcdFx0Y29uc3QgeTEgPSBNYXRoLnNpbih1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDIpO1xyXG5cclxuXHRcdFx0XHRjb25zdCB4ID0gTWF0aC5jb3ModXBkYXRlZC5lbmRBbmdsZSAtIE1hdGguUEkgLyAyKSAqIChyYWRpdXNFeHBhbmRlZCArIDI1KTtcclxuXHRcdFx0XHRjb25zdCB5ID0geTEgKiAocmFkaXVzRXhwYW5kZWQgKyAxNSAtIE1hdGguYWJzKHkxICogMTApKSArIDM7XHJcblxyXG5cdFx0XHRcdHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt4fSwke3l9KWA7XHJcblx0XHRcdH0gZWxzZSBpZiAoISQkLmhhc1R5cGUoXCJnYXVnZVwiKSB8fCAkJC5kYXRhLnRhcmdldHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdGNvbnN0IGMgPSB0aGlzLnN2Z0FyYy5jZW50cm9pZCh1cGRhdGVkKTtcclxuXHRcdFx0XHRjb25zdCB4ID0gaXNOYU4oY1swXSkgPyAwIDogY1swXTtcclxuXHRcdFx0XHRjb25zdCB5ID0gaXNOYU4oY1sxXSkgPyAwIDogY1sxXTtcclxuXHRcdFx0XHRjb25zdCBoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cclxuXHRcdFx0XHRsZXQgcmF0aW8gPSAoJCQuaGFzVHlwZShcImRvbnV0XCIpICYmIGNvbmZpZy5kb251dF9sYWJlbF9yYXRpbykgfHxcclxuXHRcdFx0XHRcdCgkJC5oYXNUeXBlKFwicGllXCIpICYmIGNvbmZpZy5waWVfbGFiZWxfcmF0aW8pO1xyXG5cclxuXHRcdFx0XHRpZiAocmF0aW8pIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gaXNGdW5jdGlvbihyYXRpbykgPyByYXRpby5iaW5kKCQkLmFwaSkoZCwgcmFkaXVzLCBoKSA6IHJhdGlvO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyYXRpbyA9IHJhZGl1cyAmJiAoXHJcblx0XHRcdFx0XHRcdGggPyAoMzYgLyByYWRpdXMgPiAwLjM3NSA/IDEuMTc1IC0gMzYgLyByYWRpdXMgOiAwLjgpICogcmFkaXVzIC8gaCA6IDBcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0cmFuc2xhdGUgPSBgdHJhbnNsYXRlKCR7eCAqIHJhdGlvfSwke3kgKiByYXRpb30pYDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cmFuc2xhdGU7XHJcblx0fSxcclxuXHJcblx0Y29udmVydFRvQXJjRGF0YShkKTogb2JqZWN0IHtcclxuXHRcdHJldHVybiB0aGlzLmFkZE5hbWUoe1xyXG5cdFx0XHRpZDogZC5kYXRhLmlkLFxyXG5cdFx0XHR2YWx1ZTogZC52YWx1ZSxcclxuXHRcdFx0cmF0aW86IHRoaXMuZ2V0UmF0aW8oXCJhcmNcIiwgZCksXHJcblx0XHRcdGluZGV4OiBkLmluZGV4LFxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dGV4dEZvckFyY0xhYmVsKHNlbGVjdGlvbjogZDNTZWxlY3Rpb24pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cclxuXHRcdGlmICgkJC5zaG91bGRTaG93QXJjTGFiZWwoKSkge1xyXG5cdFx0XHRzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdFx0XHRjb25zdCByYXRpbyA9ICQkLmdldFJhdGlvKFwiYXJjXCIsIHVwZGF0ZWQpO1xyXG5cdFx0XHRcdGNvbnN0IGlzVW5kZXJUaHJlc2hvbGQgPSAhKFxyXG5cdFx0XHRcdFx0IWhhc0dhdWdlICYmICEkJC5tZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1VuZGVyVGhyZXNob2xkKSB7XHJcblx0XHRcdFx0XHRjb25zdCB7dmFsdWV9ID0gdXBkYXRlZCB8fCBkO1xyXG5cdFx0XHRcdFx0Y29uc3QgdGV4dCA9IChcclxuXHRcdFx0XHRcdFx0JCQuZ2V0QXJjTGFiZWxGb3JtYXQoKSB8fCAkJC5kZWZhdWx0QXJjVmFsdWVGb3JtYXRcclxuXHRcdFx0XHRcdCkodmFsdWUsIHJhdGlvLCBkLmRhdGEuaWQpLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRcdFx0c2V0VGV4dFZhbHVlKG5vZGUsIHRleHQsIFstMSwgMV0sIGhhc0dhdWdlKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0bm9kZS50ZXh0KFwiXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dGV4dEZvckdhdWdlTWluTWF4KHZhbHVlOiBudW1iZXIsIGlzTWF4PzogYm9vbGVhbik6IG51bWJlciB8IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZm9ybWF0ID0gY29uZmlnLmdhdWdlX2xhYmVsX2V4dGVudHM7XHJcblxyXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdC5iaW5kKCQkLmFwaSkodmFsdWUsIGlzTWF4KSA6IHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEFyYyh0YXJnZXRJZHM6IHN0cmluZ1tdKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHt0cmFuc2l0aW5nfSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdC8vIE1FTU86IGF2b2lkIHRvIGNhbmNlbCB0cmFuc2l0aW9uXHJcblx0XHRpZiAodHJhbnNpdGluZykge1xyXG5cdFx0XHRjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuXHRcdFx0XHRpZiAoIXRyYW5zaXRpbmcpIHtcclxuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG5cclxuXHRcdFx0XHRcdCRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZH1gKS5zaXplKCkgPiAwICYmXHJcblx0XHRcdFx0XHRcdCQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgMTApO1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG5ld1RhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0JGVsLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKG5ld1RhcmdldElkcywgYC4ke0NMQVNTLmNoYXJ0QXJjfWApKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0aWYgKCEkJC5zaG91bGRFeHBhbmQoZC5kYXRhLmlkKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgZXhwYW5kRHVyYXRpb24gPSAkJC5nZXRFeHBhbmRDb25maWcoZC5kYXRhLmlkLCBcImR1cmF0aW9uXCIpO1xyXG5cdFx0XHRcdGNvbnN0IHN2Z0FyY0V4cGFuZGVkU3ViID0gJCQuZ2V0U3ZnQXJjRXhwYW5kZWQoJCQuZ2V0RXhwYW5kQ29uZmlnKGQuZGF0YS5pZCwgXCJyYXRlXCIpKTtcclxuXHJcblx0XHRcdFx0ZDNTZWxlY3QodGhpcykuc2VsZWN0QWxsKFwicGF0aFwiKVxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHRcdFx0LmR1cmF0aW9uKGV4cGFuZER1cmF0aW9uKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsICQkLnN2Z0FyY0V4cGFuZGVkKVxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHRcdFx0LmR1cmF0aW9uKGV4cGFuZER1cmF0aW9uICogMilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZFwiLCBzdmdBcmNFeHBhbmRlZFN1Yik7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHVuZXhwYW5kQXJjKHRhcmdldElkczogc3RyaW5nW10pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge3RyYW5zaXRpbmd9LCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdGlmICh0cmFuc2l0aW5nKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBuZXdUYXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdHN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKG5ld1RhcmdldElkcywgYC4ke0NMQVNTLmNoYXJ0QXJjfWApKVxyXG5cdFx0XHQuc2VsZWN0QWxsKFwicGF0aFwiKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkID0+ICQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwiZHVyYXRpb25cIikpXHJcblx0XHRcdC5hdHRyKFwiZFwiLCAkJC5zdmdBcmMpO1xyXG5cclxuXHRcdHN2Zy5zZWxlY3RBbGwoYCR7Q0xBU1MuYXJjfWApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBleHBhbmQgY29uZmlnIHZhbHVlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIGRhdGEgSURcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30ga2V5IGNvbmZpZyBrZXk6ICdkdXJhdGlvbiB8IHJhdGUnXHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEV4cGFuZENvbmZpZyhpZDogc3RyaW5nLCBrZXk6IFwiZHVyYXRpb25cIiB8IFwicmF0ZVwiKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkZWYgPSB7XHJcblx0XHRcdGR1cmF0aW9uOiA1MCxcclxuXHRcdFx0cmF0ZTogMC45OFxyXG5cdFx0fTtcclxuXHRcdGxldCB0eXBlO1xyXG5cclxuXHRcdGlmICgkJC5pc0RvbnV0VHlwZShpZCkpIHtcclxuXHRcdFx0dHlwZSA9IFwiZG9udXRcIjtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNHYXVnZVR5cGUoaWQpKSB7XHJcblx0XHRcdHR5cGUgPSBcImdhdWdlXCI7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmlzUGllVHlwZShpZCkpIHtcclxuXHRcdFx0dHlwZSA9IFwicGllXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHR5cGUgPyBjb25maWdbYCR7dHlwZX1fZXhwYW5kXyR7a2V5fWBdIDogZGVmW2tleV07XHJcblx0fSxcclxuXHJcblx0c2hvdWxkRXhwYW5kKGlkOiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuICgkJC5pc0RvbnV0VHlwZShpZCkgJiYgY29uZmlnLmRvbnV0X2V4cGFuZCkgfHxcclxuXHRcdFx0KCQkLmlzR2F1Z2VUeXBlKGlkKSAmJiBjb25maWcuZ2F1Z2VfZXhwYW5kKSB8fFxyXG5cdFx0XHQoJCQuaXNQaWVUeXBlKGlkKSAmJiBjb25maWcucGllX2V4cGFuZCk7XHJcblx0fSxcclxuXHJcblx0c2hvdWxkU2hvd0FyY0xhYmVsKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gW1wicGllXCIsIFwiZG9udXRcIiwgXCJnYXVnZVwiXVxyXG5cdFx0XHQuc29tZSh2ID0+ICQkLmhhc1R5cGUodikgJiYgY29uZmlnW2Ake3Z9X2xhYmVsX3Nob3dgXSk7XHJcblx0fSxcclxuXHJcblx0bWVldHNBcmNMYWJlbFRocmVzaG9sZChyYXRpbzogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGhyZXNob2xkID0gJCQuaGFzVHlwZShcImRvbnV0XCIpID8gY29uZmlnLmRvbnV0X2xhYmVsX3RocmVzaG9sZCA6IGNvbmZpZy5waWVfbGFiZWxfdGhyZXNob2xkO1xyXG5cclxuXHRcdHJldHVybiByYXRpbyA+PSB0aHJlc2hvbGQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QXJjTGFiZWxGb3JtYXQoKTogbnVtYmVyIHwgc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRsZXQgZm9ybWF0ID0gY29uZmlnLnBpZV9sYWJlbF9mb3JtYXQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHRmb3JtYXQgPSBjb25maWcuZ2F1Z2VfbGFiZWxfZm9ybWF0O1xyXG5cdFx0fSBlbHNlIGlmICgkJC5oYXNUeXBlKFwiZG9udXRcIikpIHtcclxuXHRcdFx0Zm9ybWF0ID0gY29uZmlnLmRvbnV0X2xhYmVsX2Zvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0LmJpbmQoJCQuYXBpKSA6IGZvcm1hdDtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmNUaXRsZSgpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdHlwZSA9ICgkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgXCJkb251dFwiKSB8fCAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmIFwiZ2F1Z2VcIik7XHJcblxyXG5cdFx0cmV0dXJuIHR5cGUgPyAkJC5jb25maWdbYCR7dHlwZX1fdGl0bGVgXSA6IFwiXCI7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0c0ZvckFyYyh0YXJnZXRzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkJC4kZWw7XHJcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRBcmMgPSAkJC5jbGFzc0NoYXJ0QXJjLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NBcmNzID0gJCQuY2xhc3NBcmNzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBtYWluUGllVXBkYXRlID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEFyY31gKVxyXG5cdFx0XHQuZGF0YSgkJC5waWUodGFyZ2V0cykpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0QXJjKGQpICsgY2xhc3NGb2N1cyhkLmRhdGEpKTtcclxuXHJcblx0XHRjb25zdCBtYWluUGllRW50ZXIgPSBtYWluUGllVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRBcmMpO1xyXG5cclxuXHRcdG1haW5QaWVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBcmNzKVxyXG5cdFx0XHQubWVyZ2UobWFpblBpZVVwZGF0ZSk7XHJcblxyXG5cdFx0bWFpblBpZUVudGVyLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJkeVwiLCBoYXNHYXVnZSAmJiAhJCQuaGFzTXVsdGlUYXJnZXRzKCkgPyBcIi0uMWVtXCIgOiBcIi4zNWVtXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHRcdC8vIE1FTU86IGNhbiBub3Qga2VlcCBzYW1lIGNvbG9yLi4uLCBidXQgbm90IGJhZCB0byB1cGRhdGUgY29sb3IgaW4gcmVkcmF3XHJcblx0XHQvLyBtYWluUGllVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHR9LFxyXG5cclxuXHRpbml0QXJjKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbH0gPSAkJDtcclxuXHJcblx0XHQkZWwuYXJjcyA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3MpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImFyY1wiKSk7XHJcblxyXG5cdFx0JCQuc2V0QXJjVGl0bGUoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYXJjIHRpdGxlIHRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEFyY1RpdGxlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGl0bGUgPSAkJC5nZXRBcmNUaXRsZSgpO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblxyXG5cdFx0aWYgKHRpdGxlKSB7XHJcblx0XHRcdGNvbnN0IHRleHQgPSAkJC4kZWwuYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTU1toYXNHYXVnZSA/IFwiY2hhcnRBcmNzR2F1Z2VUaXRsZVwiIDogXCJjaGFydEFyY3NUaXRsZVwiXSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcclxuXHJcblx0XHRcdGlmIChoYXNHYXVnZSkge1xyXG5cdFx0XHRcdHRleHRcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCItMC4zZW1cIilcclxuXHRcdFx0XHRcdC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjI3cHhcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNldFRleHRWYWx1ZSh0ZXh0LCB0aXRsZSwgaGFzR2F1Z2UgPyB1bmRlZmluZWQgOiBbLTAuNiwgMS4zNV0sIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyYyhkdXJhdGlvbjogbnVtYmVyLCBkdXJhdGlvbkZvckV4aXQ6IG51bWJlciwgd2l0aFRyYW5zZm9ybT86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGhhc0ludGVyYWN0aW9uID0gY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQ7XHJcblxyXG5cdFx0bGV0IG1haW5BcmMgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmN9YClcclxuXHRcdFx0LmRhdGEoJCQuYXJjRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0bWFpbkFyYy5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRtYWluQXJjID0gbWFpbkFyYy5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyYy5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQuZGF0YSkpXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChoYXNJbnRlcmFjdGlvbiAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlLmJpbmQoJCQuYXBpKShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRpZiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSkge1xyXG5cdFx0XHRcdFx0ZC5zdGFydEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XHJcblx0XHRcdFx0XHRkLmVuZEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9jdXJyZW50ID0gZDtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm1lcmdlKG1haW5BcmMpO1xyXG5cclxuXHRcdCQkLmhhc011bHRpQXJjR2F1Z2UoKSAmJiAkJC5yZWRyYXdNdWx0aUFyY0dhdWdlKCk7XHJcblxyXG5cdFx0bWFpbkFyY1xyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+ICghJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSAmJiB3aXRoVHJhbnNmb3JtID8gXCJzY2FsZSgwKVwiIDogXCJcIikpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdHJldHVybiBkID09PSB0aGlzLl9jdXJyZW50ID8gXCIwXCIgOiBcIjFcIjtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmVhY2goKCkgPT4ge1xyXG5cdFx0XHRcdHN0YXRlLnRyYW5zaXRpbmcgPSB0cnVlO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LmF0dHJUd2VlbihcImRcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHJcblx0XHRcdFx0aWYgKCF1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCkgPT4gXCJNIDAgMFwiO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5lbmRBbmdsZSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnQuZW5kQW5nbGUgPSB0aGlzLl9jdXJyZW50LnN0YXJ0QW5nbGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGF0ZSA9IGQzSW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgdXBkYXRlZCk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGludGVycG9sYXRlZCA9IGludGVycG9sYXRlKHQpO1xyXG5cclxuXHRcdFx0XHRcdGludGVycG9sYXRlZC5kYXRhID0gZC5kYXRhOyAvLyBkYXRhLmlkIHdpbGwgYmUgdXBkYXRlZCBieSBpbnRlcnBvcmF0b3JcclxuXHRcdFx0XHRcdHJldHVybiAkJC5nZXRBcmMoaW50ZXJwb2xhdGVkLCB0cnVlKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB3aXRoVHJhbnNmb3JtID8gXCJzY2FsZSgxKVwiIDogXCJcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+IHtcclxuXHRcdFx0XHRsZXQgY29sb3I7XHJcblxyXG5cdFx0XHRcdGlmICgkJC5sZXZlbENvbG9yKSB7XHJcblx0XHRcdFx0XHRjb2xvciA9ICQkLmxldmVsQ29sb3IoZC5kYXRhLnZhbHVlc1swXS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGRhdGEncyBjb2xvclxyXG5cdFx0XHRcdFx0Y29uZmlnLmRhdGFfY29sb3JzW2QuZGF0YS5pZF0gPSBjb2xvcjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29sb3IgPSAkJC5jb2xvcihkLmRhdGEuaWQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGNvbG9yO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQvLyBXaGVyZSBnYXVnZSByZWFkaW5nIGNvbG9yIHdvdWxkIHJlY2VpdmUgY3VzdG9taXphdGlvbi5cclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdFx0LmNhbGwoZW5kYWxsLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoJCQubGV2ZWxDb2xvcikge1xyXG5cdFx0XHRcdFx0Y29uc3QgcGF0aCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdFx0Y29uc3QgZDogYW55ID0gcGF0aC5kYXR1bSgpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcihkLmRhdGEuaWQsIHBhdGguc3R5bGUoXCJmaWxsXCIpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN0YXRlLnRyYW5zaXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRjYWxsRm4oY29uZmlnLm9ucmVuZGVyZWQsICQkLmFwaSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdC8vIGJpbmQgYXJjIGV2ZW50c1xyXG5cdFx0aGFzSW50ZXJhY3Rpb24gJiYgJCQuYmluZEFyY0V2ZW50KG1haW5BcmMpO1xyXG5cclxuXHRcdCQkLnJlZHJhd0FyY1RleHQoZHVyYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd011bHRpQXJjR2F1Z2UoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qge2hpZGRlblRhcmdldElkc30gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRjb25zdCBhcmNMYWJlbExpbmVzID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY0xhYmVsTGluZX1gKVxyXG5cdFx0XHQuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluQXJjTGFiZWxMaW5lID0gYXJjTGFiZWxMaW5lcy5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHtDTEFTUy5hcmNMYWJlbExpbmV9ICR7Q0xBU1MudGFyZ2V0fSAke0NMQVNTLnRhcmdldH0tJHtkLmRhdGEuaWR9YClcclxuXHRcdFx0Lm1lcmdlKGFyY0xhYmVsTGluZXMpO1xyXG5cclxuXHRcdG1haW5BcmNMYWJlbExpbmVcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICgkJC5sZXZlbENvbG9yID8gJCQubGV2ZWxDb2xvcihkLmRhdGEudmFsdWVzWzBdLnZhbHVlKSA6ICQkLmNvbG9yKGQuZGF0YSkpKVxyXG5cdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gXCJcIiA6IFwibm9uZVwiKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0bGV0IGxpbmVMZW5ndGggPSAwO1xyXG5cdFx0XHRcdGNvbnN0IGxpbmVUaGlja25lc3MgPSAyO1xyXG5cdFx0XHRcdGxldCB4ID0gMDtcclxuXHRcdFx0XHRsZXQgeSA9IDA7XHJcblx0XHRcdFx0bGV0IHRyYW5zZm9ybSA9IFwiXCI7XHJcblxyXG5cdFx0XHRcdGlmIChoaWRkZW5UYXJnZXRJZHMuaW5kZXhPZihkLmRhdGEuaWQpIDwgMCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgaW5uZXJMaW5lTGVuZ3RoID0gc3RhdGUuZ2F1Z2VBcmNXaWR0aCAvICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggKlxyXG5cdFx0XHRcdFx0XHQodXBkYXRlZC5pbmRleCArIDEpO1xyXG5cdFx0XHRcdFx0Y29uc3QgbGluZUFuZ2xlID0gdXBkYXRlZC5lbmRBbmdsZSAtIE1hdGguUEkgLyAyO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjSW5uZXJSYWRpdXMgPSBzdGF0ZS5yYWRpdXMgLSBpbm5lckxpbmVMZW5ndGg7XHJcblx0XHRcdFx0XHRjb25zdCBsaW5lUG9zaXRpb25pbmdBbmdsZSA9IGxpbmVBbmdsZSAtIChhcmNJbm5lclJhZGl1cyA9PT0gMCA/IDAgOiAoMSAvIGFyY0lubmVyUmFkaXVzKSk7XHJcblxyXG5cdFx0XHRcdFx0bGluZUxlbmd0aCA9IHN0YXRlLnJhZGl1c0V4cGFuZGVkIC0gc3RhdGUucmFkaXVzICsgaW5uZXJMaW5lTGVuZ3RoO1xyXG5cdFx0XHRcdFx0eCA9IE1hdGguY29zKGxpbmVQb3NpdGlvbmluZ0FuZ2xlKSAqIGFyY0lubmVyUmFkaXVzO1xyXG5cdFx0XHRcdFx0eSA9IE1hdGguc2luKGxpbmVQb3NpdGlvbmluZ0FuZ2xlKSAqIGFyY0lubmVyUmFkaXVzO1xyXG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gYHJvdGF0ZSgke2xpbmVBbmdsZSAqIDE4MCAvIE1hdGguUEl9LCAke3h9LCAke3l9KWA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeSlcclxuXHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbGluZUxlbmd0aClcclxuXHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGxpbmVUaGlja25lc3MpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIGAwLCAke2xpbmVMZW5ndGggKyBsaW5lVGhpY2tuZXNzfSwgMGApO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRiaW5kQXJjRXZlbnQoYXJjKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHRcdGNvbnN0IGlzTW91c2UgPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwibW91c2VcIjtcclxuXHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuXHRcdGZ1bmN0aW9uIHNlbGVjdEFyYyhfdGhpcywgYXJjRGF0YSwgaWQpIHtcclxuXHRcdFx0Ly8gdHJhbnNpdGlvbnNcclxuXHRcdFx0JCQuZXhwYW5kQXJjKGlkKTtcclxuXHRcdFx0JCQuYXBpLmZvY3VzKGlkKTtcclxuXHRcdFx0JCQudG9nZ2xlRm9jdXNMZWdlbmQoaWQsIHRydWUpO1xyXG5cdFx0XHQkJC5zaG93VG9vbHRpcChbYXJjRGF0YV0sIF90aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuXHRcdGZ1bmN0aW9uIHVuc2VsZWN0QXJjKGFyY0RhdGE/KSB7XHJcblx0XHRcdGNvbnN0IGlkID0gKGFyY0RhdGEgJiYgYXJjRGF0YS5pZCkgfHwgdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0JCQudW5leHBhbmRBcmMoaWQpO1xyXG5cdFx0XHQkJC5hcGkucmV2ZXJ0KCk7XHJcblx0XHRcdCQkLnJldmVydExlZ2VuZCgpO1xyXG5cdFx0XHQkJC5oaWRlVG9vbHRpcCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFyY1xyXG5cdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdGxldCBhcmNEYXRhO1xyXG5cclxuXHRcdFx0XHRpZiAodXBkYXRlZCkge1xyXG5cdFx0XHRcdFx0YXJjRGF0YSA9ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCk7XHJcblxyXG5cdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUgJiYgJCQudG9nZ2xlU2hhcGUodGhpcywgYXJjRGF0YSwgaSk7XHJcblx0XHRcdFx0XHRjb25maWcuZGF0YV9vbmNsaWNrLmJpbmQoJCQuYXBpKShhcmNEYXRhLCB0aGlzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdC8vIG1vdXNlIGV2ZW50c1xyXG5cdFx0aWYgKGlzTW91c2UpIHtcclxuXHRcdFx0YXJjXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGlmIChzdGF0ZS50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHRcdFx0XHRcdGNvbnN0IGlkID0gKGFyY0RhdGEgJiYgYXJjRGF0YS5pZCkgfHwgdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0XHRcdHNlbGVjdEFyYyh0aGlzLCBhcmNEYXRhLCBpZCk7XHJcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KHRydWUsIGFyY0RhdGEpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgZCA9PiB7XHJcblx0XHRcdFx0XHRpZiAoc3RhdGUudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0dW5zZWxlY3RBcmMoKTtcclxuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQoZmFsc2UsIGFyY0RhdGEpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XHJcblxyXG5cdFx0XHRcdFx0JCQuc2hvd1Rvb2x0aXAoW2FyY0RhdGFdLCB0aGlzKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB0b3VjaCBldmVudHNcclxuXHRcdGlmIChpc1RvdWNoICYmICQkLmhhc0FyY1R5cGUoKSAmJiAhJCQucmFkYXJzKSB7XHJcblx0XHRcdGNvbnN0IGdldEV2ZW50QXJjID0gKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHRvdWNoID0gZDNFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcclxuXHRcdFx0XHRjb25zdCBldmVudEFyYyA9IGQzU2VsZWN0KGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSkpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZXZlbnRBcmM7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRjb25zdCBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKHN0YXRlLnRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBldmVudEFyYyA9IGdldEV2ZW50QXJjKCk7XHJcblx0XHRcdFx0Y29uc3QgZGF0dW06IGFueSA9IGV2ZW50QXJjLmRhdHVtKCk7XHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9IChkYXR1bSAmJiBkYXR1bS5kYXRhICYmIGRhdHVtLmRhdGEuaWQpID8gJCQudXBkYXRlQW5nbGUoZGF0dW0pIDogbnVsbDtcclxuXHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gKGFyY0RhdGEgJiYgYXJjRGF0YS5pZCkgfHwgdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0XHQkJC5jYWxsT3Zlck91dEZvclRvdWNoKGFyY0RhdGEpO1xyXG5cclxuXHRcdFx0XHRpc1VuZGVmaW5lZChpZCkgP1xyXG5cdFx0XHRcdFx0dW5zZWxlY3RBcmMoKSA6IHNlbGVjdEFyYyh0aGlzLCBhcmNEYXRhLCBpZCk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQkJC4kZWwuc3ZnXHJcblx0XHRcdFx0Lm9uKFwidG91Y2hzdGFydFwiLCBoYW5kbGVyKVxyXG5cdFx0XHRcdC5vbihcInRvdWNobW92ZVwiLCBoYW5kbGVyKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRyZWRyYXdBcmNUZXh0KGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWluLCBhcmNzfX0gPSAkJDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0Y29uc3QgaGFzTXVsdGlBcmNHYXVnZSA9ICQkLmhhc011bHRpQXJjR2F1Z2UoKTtcclxuXHRcdGxldCB0ZXh0O1xyXG5cclxuXHRcdC8vIGZvciBnYXVnZSB0eXBlLCB1cGRhdGUgdGV4dCB3aGVuIGhhcyBubyB0aXRsZSAmIG11bHRpIGRhdGFcclxuXHRcdGlmICghKGhhc0dhdWdlICYmICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPT09IDEgJiYgY29uZmlnLmdhdWdlX3RpdGxlKSkge1xyXG5cdFx0XHR0ZXh0ID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QXJjfWApXHJcblx0XHRcdFx0LnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSA/IENMQVNTLmdhdWdlVmFsdWUgOiBudWxsKSlcclxuXHRcdFx0XHQuY2FsbCgkJC50ZXh0Rm9yQXJjTGFiZWwuYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQudHJhbnNmb3JtRm9yQXJjTGFiZWwuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwiZm9udC1zaXplXCIsIGQgPT4gKFxyXG5cdFx0XHRcdFx0JCQuaXNHYXVnZVR5cGUoZC5kYXRhKSAmJiAkJC5kYXRhLnRhcmdldHMubGVuZ3RoID09PSAxICYmICFoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRcdFx0YCR7TWF0aC5yb3VuZChzdGF0ZS5yYWRpdXMgLyA1KX1weGAgOiBudWxsXHJcblx0XHRcdFx0KSlcclxuXHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZCA9PiAoJCQuaXNUYXJnZXRUb1Nob3coZC5kYXRhLmlkKSAmJiAkJC5pc0FyY1R5cGUoZC5kYXRhKSA/IFwiMVwiIDogXCIwXCIpKTtcclxuXHJcblx0XHRcdGhhc011bHRpQXJjR2F1Z2UgJiYgdGV4dC5hdHRyKFwiZHlcIiwgXCItLjFlbVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzVGl0bGV9YClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgaGFzR2F1Z2UgPyBcIjFcIiA6IFwiMFwiKTtcclxuXHJcblx0XHRpZiAoaGFzR2F1Z2UpIHtcclxuXHRcdFx0Y29uc3QgaXNGdWxsQ2lyY2xlID0gY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGU7XHJcblx0XHRcdGNvbnN0IHN0YXJ0QW5nbGUgPSAtMSAqIE1hdGguUEkgLyAyO1xyXG5cdFx0XHRjb25zdCBlbmRBbmdsZSA9IChpc0Z1bGxDaXJjbGUgPyAtNCA6IC0xKSAqIHN0YXJ0QW5nbGU7XHJcblxyXG5cdFx0XHRpc0Z1bGxDaXJjbGUgJiYgdGV4dCAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBgJHtNYXRoLnJvdW5kKHN0YXRlLnJhZGl1cyAvIDE0KX1gKTtcclxuXHJcblx0XHRcdGxldCBiYWNrZ3JvdW5kQXJjID0gJCQuJGVsLmFyY3Muc2VsZWN0KFxyXG5cdFx0XHRcdGAke2hhc011bHRpQXJjR2F1Z2UgPyBcImdcIiA6IFwiXCJ9LiR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH1gXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRpZiAoaGFzTXVsdGlBcmNHYXVnZSkge1xyXG5cdFx0XHRcdGxldCBpbmRleCA9IDA7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMgPSBiYWNrZ3JvdW5kQXJjXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKGBwYXRoLiR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH1gKVxyXG5cdFx0XHRcdFx0LmRhdGEoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHRcdFx0YmFja2dyb3VuZEFyYy5lbnRlcigpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH0gJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfS0ke2l9YClcclxuXHRcdFx0XHRcdC5tZXJnZShiYWNrZ3JvdW5kQXJjKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGQxID0+IHtcclxuXHRcdFx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5pbmRleE9mKGQxLmlkKSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiTSAwIDBcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZCA9IHtcclxuXHRcdFx0XHRcdFx0XHRkYXRhOiBbe3ZhbHVlOiBjb25maWcuZ2F1Z2VfbWF4fV0sXHJcblx0XHRcdFx0XHRcdFx0c3RhcnRBbmdsZSxcclxuXHRcdFx0XHRcdFx0XHRlbmRBbmdsZSxcclxuXHRcdFx0XHRcdFx0XHRpbmRleDogaW5kZXgrK1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhkLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmV4aXQoKS5yZW1vdmUoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmF0dHIoXCJkXCIsICgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGQgPSB7XHJcblx0XHRcdFx0XHRcdGRhdGE6IFt7dmFsdWU6IGNvbmZpZy5nYXVnZV9tYXh9XSxcclxuXHRcdFx0XHRcdFx0c3RhcnRBbmdsZSxcclxuXHRcdFx0XHRcdFx0ZW5kQW5nbGVcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhkLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdH1gKVxyXG5cdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuNzVlbVwiKVxyXG5cdFx0XHRcdC50ZXh0KGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gY29uZmlnLmdhdWdlX3VuaXRzIDogXCJcIik7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cpIHtcclxuXHRcdFx0XHRhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VNaW59YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7LTEgKiAoc3RhdGUuaW5uZXJSYWRpdXMgKyAoKHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzKSAvIChpc0Z1bGxDaXJjbGUgPyAxIDogMikpKX1weGApXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcclxuXHRcdFx0XHRcdC50ZXh0KCQkLnRleHRGb3JHYXVnZU1pbk1heChjb25maWcuZ2F1Z2VfbWluLCBmYWxzZSkpO1xyXG5cclxuXHRcdFx0XHQvLyBzaG93IG1heCB0ZXh0IHdoZW4gaXNuJ3QgZnVsbENpcmNsZVxyXG5cdFx0XHRcdCFpc0Z1bGxDaXJjbGUgJiYgYXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0dhdWdlTWF4fWApXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIGAke3N0YXRlLmlubmVyUmFkaXVzICsgKChzdGF0ZS5yYWRpdXMgLSBzdGF0ZS5pbm5lclJhZGl1cykgLyAyKX1weGApXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcclxuXHRcdFx0XHRcdC50ZXh0KCQkLnRleHRGb3JHYXVnZU1pbk1heChjb25maWcuZ2F1Z2VfbWF4LCB0cnVlKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRpbml0R2F1Z2UoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHthcmNzfX0gPSAkJDtcclxuXHRcdGNvbnN0IGFwcGVuZFRleHQgPSBjbGFzc05hbWUgPT4ge1xyXG5cdFx0XHRhcmNzLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHRhcmNzLmFwcGVuZCgkJC5oYXNNdWx0aUFyY0dhdWdlKCkgPyBcImdcIiA6IFwicGF0aFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZCk7XHJcblxyXG5cdFx0XHRjb25maWcuZ2F1Z2VfdW5pdHMgJiYgYXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZVVuaXQpO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93KSB7XHJcblx0XHRcdFx0YXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZU1pbik7XHJcblx0XHRcdFx0IWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlICYmIGFwcGVuZFRleHQoQ0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0R2F1Z2VMYWJlbEhlaWdodCgpOiAyMCB8IDAge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyAyMCA6IDA7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7YXJlYSBhcyBkM0FyZWF9IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0UmFuZG9tLCBpc0Z1bmN0aW9ufSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0QXJlYShtYWluTGluZUVudGVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0bWFpbkxpbmVFbnRlclxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYXMuYmluZCgkJCkpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWFHcmFkaWVudCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7ZGF0ZXRpbWVJZH0sICRlbDoge2RlZnN9fSA9ICQkO1xyXG5cclxuXHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRjb25zdCBpZCA9IGAke2RhdGV0aW1lSWR9LWFyZWFHcmFkaWVudCR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpICYmIGRlZnMuc2VsZWN0KGAjJHtpZH1gKS5lbXB0eSgpKSB7XHJcblx0XHRcdFx0Y29uc3QgY29sb3IgPSAkJC5jb2xvcihkKTtcclxuXHRcdFx0XHRjb25zdCB7XHJcblx0XHRcdFx0XHR4ID0gWzAsIDBdLFxyXG5cdFx0XHRcdFx0eSA9IFswLCAxXSxcclxuXHRcdFx0XHRcdHN0b3BzID0gW1swLCBjb2xvciwgMV0sIFsxLCBjb2xvciwgMF1dXHJcblx0XHRcdFx0fSA9IGNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50O1xyXG5cclxuXHRcdFx0XHRjb25zdCBsaW5lYXJHcmFkaWVudCA9IGRlZnMuYXBwZW5kKFwibGluZWFyR3JhZGllbnRcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiaWRcIiwgYCR7aWR9YClcclxuXHRcdFx0XHRcdC5hdHRyKFwieDFcIiwgeFswXSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgeFsxXSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTFcIiwgeVswXSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgeVsxXSk7XHJcblxyXG5cdFx0XHRcdHN0b3BzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBzdG9wQ29sb3IgPSBpc0Z1bmN0aW9uKHZbMV0pID8gdlsxXS5iaW5kKCQkLmFwaSkoZC5pZCkgOiB2WzFdO1xyXG5cclxuXHRcdFx0XHRcdGxpbmVhckdyYWRpZW50LmFwcGVuZChcInN0b3BcIilcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJvZmZzZXRcIiwgdlswXSlcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJzdG9wLWNvbG9yXCIsIHN0b3BDb2xvciB8fCBjb2xvcilcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJzdG9wLW9wYWNpdHlcIiwgdlsyXSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWFDb2xvcihkKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQgP1xyXG5cdFx0XHRgdXJsKCMkeyQkLnN0YXRlLmRhdGV0aW1lSWR9LWFyZWFHcmFkaWVudCR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9KWAgOlxyXG5cdFx0XHQkJC5jb2xvcihkKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmVhKGR1cmF0aW9uRm9yRXhpdDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50ICYmICQkLnVwZGF0ZUFyZWFHcmFkaWVudCgpO1xyXG5cclxuXHRcdCRlbC5hcmVhID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwuYXJlYS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwuYXJlYSA9ICRlbC5hcmVhLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3RhdGUub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XHJcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2UoJGVsLmFyZWEpO1xyXG5cclxuXHRcdCRlbC5hcmVhXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgc3RhdGUub3JnQXJlYU9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyZWEoZHJhd0FyZWEsIHdpdGhUcmFuc2l0aW9uPzogYm9vbGVhbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge29yZ0FyZWFPcGFjaXR5fSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/ICQkLiRlbC5hcmVhLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpIDogJCQuJGVsLmFyZWEpXHJcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdBcmVhKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlQXJlYUNvbG9yLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZCA9PiBTdHJpbmcoJCQuaXNBcmVhUmFuZ2VUeXBlKGQpID8gb3JnQXJlYU9wYWNpdHkgLyAxLjc1IDogb3JnQXJlYU9wYWNpdHkpKVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSBhcmVhIHBhdGggZGF0YVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhcmVhSW5kaWNlcyBJbmRpY2VzXHJcblx0ICogQHBhcmFtIHtib29sZWFufSBpc1N1YiBXZWF0aGVyIGlzIHN1YiBheGlzXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVEcmF3QXJlYShhcmVhSW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogKGQpID0+IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgbGluZUNvbm5lY3ROdWxsID0gY29uZmlnLmxpbmVfY29ubmVjdE51bGw7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QXJlYVBvaW50cyhhcmVhSW5kaWNlcywgaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gJCQuZ2V0WVNjYWxlQnlJZC5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cdFx0Y29uc3QgdmFsdWUwID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHR5U2NhbGUoZC5pZCwgaXNTdWIpKFxyXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XHJcblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwiaGlnaFwiKSA6ICQkLmdldFNoYXBlWU1pbihkLmlkKVxyXG5cdFx0XHQpKTtcclxuXHRcdGNvbnN0IHZhbHVlMSA9IChkLCBpKSA9PiAoJCQuaXNHcm91cGVkKGQuaWQpID9cclxuXHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzFdWzFdIDpcclxuXHRcdFx0eVNjYWxlKGQuaWQsIGlzU3ViKShcclxuXHRcdFx0XHQkJC5pc0FyZWFSYW5nZVR5cGUoZCkgP1xyXG5cdFx0XHRcdFx0JCQuZ2V0QXJlYVJhbmdlRGF0YShkLCBcImxvd1wiKSA6IGQudmFsdWVcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRsZXQgdmFsdWVzID0gbGluZUNvbm5lY3ROdWxsID8gJCQuZmlsdGVyUmVtb3ZlTnVsbChkLnZhbHVlcykgOiBkLnZhbHVlcztcclxuXHRcdFx0bGV0IHgwID0gMDtcclxuXHRcdFx0bGV0IHkwID0gMDtcclxuXHRcdFx0bGV0IHBhdGg7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNBcmVhVHlwZShkKSkge1xyXG5cdFx0XHRcdGxldCBhcmVhID0gZDNBcmVhKCk7XHJcblxyXG5cdFx0XHRcdGFyZWEgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFx0YXJlYS55KHhWYWx1ZSlcclxuXHRcdFx0XHRcdFx0LngwKHZhbHVlMClcclxuXHRcdFx0XHRcdFx0LngxKHZhbHVlMSkgOlxyXG5cdFx0XHRcdFx0YXJlYS54KHhWYWx1ZSlcclxuXHRcdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdFx0XHQueTAoY29uZmlnLmFyZWFfYWJvdmUgPyAwIDogdmFsdWUwKVxyXG5cdFx0XHRcdFx0XHQueTEodmFsdWUxKTtcclxuXHJcblx0XHRcdFx0aWYgKCFsaW5lQ29ubmVjdE51bGwpIHtcclxuXHRcdFx0XHRcdGFyZWEgPSBhcmVhLmRlZmluZWQoZCA9PiAkJC5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdHZhbHVlcyA9ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHBhdGggPSBhcmVhLmN1cnZlKCQkLmdldEN1cnZlKGQpKSh2YWx1ZXMpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh2YWx1ZXNbMF0pIHtcclxuXHRcdFx0XHRcdHgwID0gJCQuc2NhbGUueCh2YWx1ZXNbMF0ueCk7XHJcblx0XHRcdFx0XHR5MCA9ICQkLmdldFlTY2FsZUJ5SWQoZC5pZCkodmFsdWVzWzBdLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHBhdGggPSBpc1JvdGF0ZWQgPyBgTSAke3kwfSAke3gwfWAgOiBgTSAke3gwfSAke3kwfWA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBwYXRoIHx8IFwiTSAwIDBcIjtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yj86IGJvb2xlYW4pOiBGdW5jdGlvbiB7XHJcblx0XHQvLyBwYXJ0aWFsIGR1cGxpY2F0aW9uIG9mIGdlbmVyYXRlR2V0QmFyUG9pbnRzXHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgeCA9ICQkLmdldFNoYXBlWCgwLCBhcmVhSW5kaWNlcywgISFpc1N1Yik7XHJcblx0XHRjb25zdCB5ID0gJCQuZ2V0U2hhcGVZKCEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgYXJlYU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzQXJlYVR5cGUsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IHlTY2FsZSA9ICQkLmdldFlTY2FsZUJ5SWQuYmluZCgkJCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoJCQuZ2V0U2hhcGVZTWluKGQuaWQpKTtcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gYXJlYU9mZnNldChkLCBpKSB8fCB5MDsgLy8gb2Zmc2V0IGlzIGZvciBzdGFja2VkIGFyZWEgY2hhcnRcclxuXHRcdFx0Y29uc3QgcG9zWCA9IHgoZCk7XHJcblx0XHRcdGxldCBwb3NZID0geShkKTtcclxuXHJcblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCAmJiAoXHJcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcclxuXHRcdFx0KSkge1xyXG5cdFx0XHRcdHBvc1kgPSB5MDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gMSBwb2ludCB0aGF0IG1hcmtzIHRoZSBhcmVhIHBvc2l0aW9uXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0sXHJcblx0XHRcdFx0W3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSxcclxuXHRcdFx0XHRbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldLCAvLyBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSAvLyBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7bW91c2UgYXMgZDNNb3VzZX0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0UmFuZG9tLCBnZXRSZWN0U2VnTGlzdCwgaXNOdW1iZXIsIGlzT2JqZWN0VHlwZSwgaXNWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdEJhcigpOiB2b2lkIHtcclxuXHRcdGNvbnN0IHskZWx9ID0gdGhpcztcclxuXHJcblx0XHQkZWwuYmFyID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQvLyBzaG91bGQgcG9zaXRpb25lZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzaGFwZSBub2RlIHRvIG5vdCBvdmVybGFwIG90aGVyc1xyXG5cdFx0XHQuaW5zZXJ0KFwiZ1wiLCBcIjpmaXJzdC1jaGlsZFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QmFycyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0c0ZvckJhcih0YXJnZXRzKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cclxuXHRcdGlmICghJGVsLmJhcikge1xyXG5cdFx0XHQkJC5pbml0QmFyKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbWFpbkJhclVwZGF0ZSA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRCYXJzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QmFyfWApXHJcblx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0QmFyKGQpICsgY2xhc3NGb2N1cyhkKSk7XHJcblxyXG5cdFx0Y29uc3QgbWFpbkJhckVudGVyID0gbWFpbkJhclVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XHJcblxyXG5cdFx0Ly8gQmFycyBmb3IgZWFjaCBkYXRhXHJcblx0XHRtYWluQmFyRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycylcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGQgPT4gKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUuYmluZCgkJC5hcGkpKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQmFyKGR1cmF0aW9uRm9yRXhpdDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgYmFyRGF0YSA9ICQkLmJhckRhdGEuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0JhciA9ICQkLmNsYXNzQmFyLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgaW5pdGlhbE9wYWNpdHkgPSAkJC5pbml0aWFsT3BhY2l0eS5iaW5kKCQkKTtcclxuXHJcblx0XHQkZWwuYmFyID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyfWApXHJcblx0XHRcdC5kYXRhKGJhckRhdGEpO1xyXG5cclxuXHRcdCRlbC5iYXIuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0JGVsLmJhciA9ICRlbC5iYXIuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXIpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5tZXJnZSgkZWwuYmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGluaXRpYWxPcGFjaXR5KTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdCYXIoZHJhd0Jhciwgd2l0aFRyYW5zaXRpb24/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCB7YmFyfSA9IHRoaXMuJGVsO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IGJhci50cmFuc2l0aW9uKGdldFJhbmRvbSgpKSA6IGJhcilcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0JhcilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIHRoaXMuY29sb3IpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0Z2V0QmFyVyhheGlzLCBiYXJUYXJnZXRzTnVtOiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XHJcblx0XHRjb25zdCB0aWNrSW50ZXJ2YWwgPSAoc2NhbGUuem9vbSB8fCAkJCkgJiYgISQkLmF4aXMuaXNDYXRlZ29yaXplZCgpID9cclxuXHRcdFx0JCQueHgoc2NhbGUuc3ViWC5kb21haW4oKVsxXSkgLyBtYXhEYXRhQ291bnQgOiBheGlzLnRpY2tJbnRlcnZhbChtYXhEYXRhQ291bnQpO1xyXG5cdFx0bGV0IHJlc3VsdDtcclxuXHJcblx0XHRjb25zdCBnZXRXaWR0aCA9IChpZD86IHN0cmluZykgPT4ge1xyXG5cdFx0XHRjb25zdCB3aWR0aCA9IGlkID8gY29uZmlnLmJhcl93aWR0aFtpZF0gOiBjb25maWcuYmFyX3dpZHRoO1xyXG5cdFx0XHRjb25zdCByYXRpbyA9IGlkID8gd2lkdGgucmF0aW8gOiBjb25maWcuYmFyX3dpZHRoX3JhdGlvO1xyXG5cdFx0XHRjb25zdCBtYXggPSBpZCA/IHdpZHRoLm1heCA6IGNvbmZpZy5iYXJfd2lkdGhfbWF4O1xyXG5cdFx0XHRjb25zdCB3ID0gaXNOdW1iZXIod2lkdGgpID9cclxuXHRcdFx0XHR3aWR0aCA6IGJhclRhcmdldHNOdW0gPyAodGlja0ludGVydmFsICogcmF0aW8pIC8gYmFyVGFyZ2V0c051bSA6IDA7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWF4ICYmIHcgPiBtYXggPyBtYXggOiB3O1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXN1bHQgPSBnZXRXaWR0aCgpO1xyXG5cclxuXHRcdGlmICghaXNHcm91cGVkICYmIGlzT2JqZWN0VHlwZShjb25maWcuYmFyX3dpZHRoKSkge1xyXG5cdFx0XHRyZXN1bHQgPSB7d2lkdGg6IHJlc3VsdCwgdG90YWw6IFtdfTtcclxuXHJcblx0XHRcdCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdGlmIChjb25maWcuYmFyX3dpZHRoW3YuaWRdKSB7XHJcblx0XHRcdFx0XHRyZXN1bHRbdi5pZF0gPSBnZXRXaWR0aCh2LmlkKTtcclxuXHRcdFx0XHRcdHJlc3VsdC50b3RhbC5wdXNoKHJlc3VsdFt2LmlkXSB8fCByZXN1bHQud2lkdGgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9LFxyXG5cclxuXHRnZXRCYXJzKGk6IG51bWJlciwgaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xyXG5cclxuXHRcdHJldHVybiAoaWQgPyBtYWluXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiBtYWluKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9JHtzdWZmaXh9YCk7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQmFycyhpOiBudW1iZXIsIGlkOiBzdHJpbmcsIHJlc2V0OiBib29sZWFuKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmVzZXQgJiYgJCQudW5leHBhbmRCYXJzKCk7XHJcblx0XHQkJC5nZXRCYXJzKGksIGlkKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHR1bmV4cGFuZEJhcnMoaTogbnVtYmVyKTogdm9pZCB7XHJcblx0XHR0aGlzLmdldEJhcnMoaSkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlRHJhd0JhcihiYXJJbmRpY2VzLCBpc1N1Yj86IGJvb2xlYW4pOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgaXNTdWIpO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XHJcblx0XHRjb25zdCBiYXJSYWRpdXMgPSBjb25maWcuYmFyX3JhZGl1cztcclxuXHRcdGNvbnN0IGJhclJhZGl1c1JhdGlvID0gY29uZmlnLmJhcl9yYWRpdXNfcmF0aW87XHJcblxyXG5cdFx0Ly8gZ2V0IHRoZSBiYXIgcmFkaXVzXHJcblx0XHRjb25zdCBnZXRSYWRpdXMgPSBpc051bWJlcihiYXJSYWRpdXMpICYmIGJhclJhZGl1cyA+IDAgP1xyXG5cdFx0XHQoKSA9PiBiYXJSYWRpdXMgOiAoXHJcblx0XHRcdFx0aXNOdW1iZXIoYmFyUmFkaXVzUmF0aW8pID8gdyA9PiB3ICogYmFyUmFkaXVzUmF0aW8gOiBudWxsXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0XHRcdC8vIDQgcG9pbnRzIHRoYXQgbWFrZSBhIGJhclxyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBnZXRQb2ludHMoZCwgaSk7XHJcblxyXG5cdFx0XHQvLyBzd2l0Y2ggcG9pbnRzIGlmIGF4aXMgaXMgcm90YXRlZCwgbm90IGFwcGxpY2FibGUgZm9yIHN1YiBjaGFydFxyXG5cdFx0XHRjb25zdCBpbmRleFggPSAraXNSb3RhdGVkO1xyXG5cdFx0XHRjb25zdCBpbmRleFkgPSArIWluZGV4WDtcclxuXHJcblx0XHRcdGNvbnN0IGlzTmVnYXRpdmUgPSBkLnZhbHVlIDwgMDtcclxuXHRcdFx0Y29uc3QgcGF0aFJhZGl1cyA9IFtcIlwiLCBcIlwiXTtcclxuXHRcdFx0bGV0IHJhZGl1cyA9IDA7XHJcblxyXG5cdFx0XHRpZiAoZ2V0UmFkaXVzICYmICFpc0dyb3VwZWQpIHtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGlzUm90YXRlZCA/IGluZGV4WSA6IGluZGV4WDtcclxuXHRcdFx0XHRjb25zdCBiYXJXID0gcG9pbnRzWzJdW2luZGV4XSAtIHBvaW50c1swXVtpbmRleF07XHJcblxyXG5cdFx0XHRcdHJhZGl1cyA9IGdldFJhZGl1cyhiYXJXKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgYXJjID0gYGEke3JhZGl1c30sJHtyYWRpdXN9ICR7aXNOZWdhdGl2ZSA/IGAxIDAgMGAgOiBgMCAwIDFgfSBgO1xyXG5cclxuXHRcdFx0XHRwYXRoUmFkaXVzWyshaXNSb3RhdGVkXSA9IGAke2FyY30ke3JhZGl1c30sJHtyYWRpdXN9YDtcclxuXHRcdFx0XHRwYXRoUmFkaXVzWytpc1JvdGF0ZWRdID0gYCR7YXJjfSR7Wy1yYWRpdXMsIHJhZGl1c11baXNSb3RhdGVkID8gXCJzb3J0XCIgOiBcInJldmVyc2VcIl0oKX1gO1xyXG5cclxuXHRcdFx0XHRpc05lZ2F0aXZlICYmIHBhdGhSYWRpdXMucmV2ZXJzZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBwYXRoIHN0cmluZyBkYXRhIHNob3VsZG4ndCBiZSBjb250YWluaW5nIG5ldyBsaW5lIGNoYXJzXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzUzMFxyXG5cdFx0XHRjb25zdCBwYXRoID0gaXNSb3RhdGVkID9cclxuXHRcdFx0XHRgSCR7cG9pbnRzWzFdW2luZGV4WF0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1swXX1WJHtwb2ludHNbMl1baW5kZXhZXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzFdfUgke3BvaW50c1szXVtpbmRleFhdfWAgOlxyXG5cdFx0XHRcdGBWJHtwb2ludHNbMV1baW5kZXhZXSArIChpc05lZ2F0aXZlID8gLXJhZGl1cyA6IHJhZGl1cyl9ICR7cGF0aFJhZGl1c1swXX1IJHtwb2ludHNbMl1baW5kZXhYXSAtIHJhZGl1c30gJHtwYXRoUmFkaXVzWzFdfVYke3BvaW50c1szXVtpbmRleFldfWA7XHJcblxyXG5cdFx0XHRyZXR1cm4gYE0ke3BvaW50c1swXVtpbmRleFhdfSwke3BvaW50c1swXVtpbmRleFldfSR7cGF0aH16YDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRCYXJQb2ludHMoYmFySW5kaWNlcywgaXNTdWI/OiBib29sZWFuKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGF4aXMgPSBpc1N1YiA/ICQkLmF4aXMuc3ViWCA6ICQkLmF4aXMueDtcclxuXHRcdGNvbnN0IGJhclRhcmdldHNOdW0gPSAkJC5nZXRJbmRpY2VzTWF4KGJhckluZGljZXMpICsgMTtcclxuXHRcdGNvbnN0IGJhclcgPSAkJC5nZXRCYXJXKGF4aXMsIGJhclRhcmdldHNOdW0pO1xyXG5cdFx0Y29uc3QgYmFyWCA9ICQkLmdldFNoYXBlWChiYXJXLCBiYXJJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IGJhclkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XHJcblx0XHRjb25zdCBiYXJPZmZzZXQgPSAkJC5nZXRTaGFwZU9mZnNldCgkJC5pc0JhclR5cGUsIGJhckluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gJCQuZ2V0WVNjYWxlQnlJZC5iaW5kKCQkKTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoJCQuZ2V0U2hhcGVZTWluKGQuaWQpKTtcclxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gYmFyT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYmFyIGNoYXJ0XHJcblx0XHRcdGNvbnN0IHdpZHRoID0gaXNOdW1iZXIoYmFyVykgPyBiYXJXIDogYmFyV1tkLmlkXSB8fCBiYXJXLndpZHRoO1xyXG5cdFx0XHRjb25zdCBwb3NYID0gYmFyWChkKTtcclxuXHRcdFx0bGV0IHBvc1kgPSBiYXJZKGQpO1xyXG5cclxuXHRcdFx0Ly8gZml4IHBvc1kgbm90IHRvIG92ZXJmbG93IG9wcG9zaXRlIHF1YWRyYW50XHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkICYmIChcclxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxyXG5cdFx0XHQpKSB7XHJcblx0XHRcdFx0cG9zWSA9IHkwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwb3NZIC09ICh5MCAtIG9mZnNldCk7XHJcblxyXG5cdFx0XHQvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSxcclxuXHRcdFx0XHRbcG9zWCwgcG9zWV0sXHJcblx0XHRcdFx0W3Bvc1ggKyB3aWR0aCwgcG9zWV0sXHJcblx0XHRcdFx0W3Bvc1ggKyB3aWR0aCwgb2Zmc2V0XVxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpbkJhcih0aGF0KTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2UodGhhdCk7XHJcblx0XHRjb25zdCBsaXN0ID0gZ2V0UmVjdFNlZ0xpc3QodGhhdCk7XHJcblx0XHRjb25zdCBbc2VnMCwgc2VnMV0gPSBsaXN0O1xyXG5cdFx0Y29uc3QgeCA9IE1hdGgubWluKHNlZzAueCwgc2VnMS54KTtcclxuXHRcdGNvbnN0IHkgPSBNYXRoLm1pbihzZWcwLnksIHNlZzEueSk7XHJcblx0XHRjb25zdCBvZmZzZXQgPSB0aGlzLmNvbmZpZy5iYXJfc2Vuc2l0aXZpdHk7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGF0LmdldEJCb3goKTtcclxuXHRcdGNvbnN0IHN4ID0geCAtIG9mZnNldDtcclxuXHRcdGNvbnN0IGV4ID0geCArIHdpZHRoICsgb2Zmc2V0O1xyXG5cdFx0Y29uc3Qgc3kgPSB5ICsgaGVpZ2h0ICsgb2Zmc2V0O1xyXG5cdFx0Y29uc3QgZXkgPSB5IC0gb2Zmc2V0O1xyXG5cclxuXHRcdHJldHVybiBzeCA8IG1vdXNlWzBdICYmXHJcblx0XHRcdG1vdXNlWzBdIDwgZXggJiZcclxuXHRcdFx0ZXkgPCBtb3VzZVsxXSAmJlxyXG5cdFx0XHRtb3VzZVsxXSA8IHN5O1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge0tFWX0gZnJvbSBcIi4uLy4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2dldE1pbk1heCwgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzT2JqZWN0fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdEJ1YmJsZSgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJidWJibGVcIikpIHtcclxuXHRcdFx0Y29uZmlnLnBvaW50X3Nob3cgPSB0cnVlO1xyXG5cdFx0XHRjb25maWcucG9pbnRfdHlwZSA9IFwiY2lyY2xlXCI7XHJcblx0XHRcdGNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSA9IDI1O1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB1c2VyIGFnZW50J3MgY29tcHV0ZWQgdmFsdWVcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZUxlbmd0aCgpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IEtFWS5idWJibGVCYXNlTGVuZ3RoO1xyXG5cdFx0bGV0IGJhc2VMZW5ndGggPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghYmFzZUxlbmd0aCkge1xyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIGJhc2VMZW5ndGggPSBnZXRNaW5NYXgoXCJtaW5cIiwgW3dpZHRoLCBoZWlnaHRdKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJhc2VMZW5ndGg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSByYWRpdXMgdmFsdWUgZm9yIGJ1YmJsZSBjaXJjbGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRCdWJibGVSKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IG1heFIgPSAkJC5jb25maWcuYnViYmxlX21heFI7XHJcblxyXG5cdFx0aWYgKGlzRnVuY3Rpb24obWF4UikpIHtcclxuXHRcdFx0bWF4UiA9IG1heFIuYmluZCgkJC5hcGkpKGQpO1xyXG5cdFx0fSBlbHNlIGlmICghaXNOdW1iZXIobWF4UikpIHtcclxuXHRcdFx0bWF4UiA9ICgkJC5nZXRCYXNlTGVuZ3RoKCkgLyAoJCQuZ2V0TWF4RGF0YUNvdW50KCkgKiAyKSkgKyAxMjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgJCQuZ2V0TWluTWF4RGF0YSgpLm1heC5tYXAoZCA9PiAoXHJcblx0XHRcdCQkLmlzQnViYmxlWlR5cGUoZCkgP1xyXG5cdFx0XHRcdCQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwieVwiKSA6IChcclxuXHRcdFx0XHRcdGlzT2JqZWN0KGQudmFsdWUpID8gZC52YWx1ZS5taWQgOiBkLnZhbHVlXHJcblx0XHRcdFx0KVxyXG5cdFx0KSkpO1xyXG5cdFx0Y29uc3QgbWF4QXJlYSA9IG1heFIgKiBtYXhSICogTWF0aC5QSTtcclxuXHRcdGNvbnN0IGFyZWEgPSAoJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwielwiKSA6IGQudmFsdWUpICogKG1heEFyZWEgLyBtYXgpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoYXJlYSAvIE1hdGguUEkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBidWJibGUgZGltZW5zaW9uIGRhdGFcclxuXHQgKiBAcGFyYW0ge29iamVjdHxBcnJheX0gZCBkYXRhIHZhbHVlXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSB5IG9yIHpcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QnViYmxlWkRhdGEoZCwgdHlwZTogXCJ5XCIgfCBcInpcIik6IG51bWJlciB7XHJcblx0XHRyZXR1cm4gaXNPYmplY3QoZCkgPyBkW3R5cGVdIDogZFt0eXBlID09PSBcInlcIiA/IDAgOiAxXTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRhcmVhIGFzIGQzQXJlYSxcclxuXHRsaW5lIGFzIGQzTGluZVxyXG59IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge1xyXG5cdG1vdXNlIGFzIGQzTW91c2UsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0UmFuZG9tLCBpc0FycmF5LCBpc0RlZmluZWQsIGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkLCBpc1ZhbHVlLCBwYXJzZURhdGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRMaW5lKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgeyRlbH0gPSB0aGlzO1xyXG5cclxuXHRcdCRlbC5saW5lID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRMaW5lcyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0c0ZvckxpbmUodGFyZ2V0cyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRMaW5lID0gJCQuY2xhc3NDaGFydExpbmUuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0xpbmVzID0gJCQuY2xhc3NMaW5lcy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cclxuXHRcdGlmICghJGVsLmxpbmUpIHtcclxuXHRcdFx0JCQuaW5pdExpbmUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYWluTGluZVVwZGF0ZSA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRMaW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydExpbmV9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGNsYXNzQ2hhcnRMaW5lKGQpICsgY2xhc3NGb2N1cyhkKSk7XHJcblxyXG5cdFx0Y29uc3QgbWFpbkxpbmVFbnRlciA9IG1haW5MaW5lVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRMaW5lKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XHJcblxyXG5cdFx0Ly8gTGluZXMgZm9yIGVhY2ggZGF0YVxyXG5cdFx0bWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NMaW5lcyk7XHJcblxyXG5cdFx0Ly8gQXJlYXNcclxuXHRcdCQkLmhhc1R5cGVPZihcIkFyZWFcIikgJiZcclxuXHRcdFx0JCQuaW5pdEFyZWEobWFpbkxpbmVFbnRlcik7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi5cclxuXHRcdC8vIG1haW5MaW5lVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2Zvcm1hdDoge2V4dHJhTGluZUNsYXNzZXN9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLmxpbmUgPSAkZWwubWFpblxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwubGluZS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwubGluZSA9ICRlbC5saW5lLmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAkeyQkLmNsYXNzTGluZS5iaW5kKCQkKShkKX0gJHtleHRyYUxpbmVDbGFzc2VzKGQpIHx8IFwiXCJ9YClcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2UoJGVsLmxpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInNoYXBlLXJlbmRlcmluZ1wiLCBkID0+ICgkJC5pc1N0ZXBUeXBlKGQpID8gXCJjcmlzcEVkZ2VzXCIgOiBcIlwiKSlcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3TGluZShkcmF3TGluZSwgd2l0aFRyYW5zaXRpb24/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCB7bGluZX0gPSB0aGlzLiRlbDtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBsaW5lLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpIDogbGluZSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0xpbmUpXHJcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIHRoaXMuY29sb3IpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBjdXJ2ZSBpbnRlcnBvbGF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRDdXJ2ZShkKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkU3RlcFR5cGUgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkICYmICQkLmlzU3RlcFR5cGUoZCk7XHJcblxyXG5cdFx0Ly8gd2hlbiBpcyBzdGVwICYgcm90YXRlZCwgc2hvdWxkIGJlIGNvbXB1dGVkIGluIGRpZmZlcmVudCB3YXlcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ3MVxyXG5cdFx0cmV0dXJuIGlzUm90YXRlZFN0ZXBUeXBlID8gY29udGV4dCA9PiB7XHJcblx0XHRcdGNvbnN0IHN0ZXAgPSAkJC5nZXRJbnRlcnBvbGF0ZShkKShjb250ZXh0KTtcclxuXHJcblx0XHRcdC8vIGtlZXAgdGhlIG9yaWdpbmFsIG1ldGhvZFxyXG5cdFx0XHRzdGVwLm9yZ1BvaW50ID0gc3RlcC5wb2ludDtcclxuXHJcblx0XHRcdC8vIHRvIGdldCByb3RhdGVkIHBhdGggZGF0YVxyXG5cdFx0XHRzdGVwLnBvaW50Um90YXRlZCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHR0aGlzLl9wb2ludCA9PT0gMSAmJiAodGhpcy5fcG9pbnQgPSAyKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgeTEgPSB0aGlzLl95ICogKDEgLSB0aGlzLl90KSArIHkgKiB0aGlzLl90O1xyXG5cclxuXHRcdFx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5MSk7XHJcblx0XHRcdFx0dGhpcy5fY29udGV4dC5saW5lVG8oeCwgeTEpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0XHR0aGlzLl95ID0geTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHN0ZXAucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0dGhpcy5fcG9pbnQgPT09IDAgPyB0aGlzLm9yZ1BvaW50KHgsIHkpIDogdGhpcy5wb2ludFJvdGF0ZWQoeCwgeSk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gc3RlcDtcclxuXHRcdH0gOiAkJC5nZXRJbnRlcnBvbGF0ZShkKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZURyYXdMaW5lKGxpbmVJbmRpY2VzLCBpc1N1Yj86IGJvb2xlYW4pOiAoZCkgPT4gc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgbGluZUNvbm5lY3ROdWxsID0gY29uZmlnLmxpbmVfY29ubmVjdE51bGw7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0TGluZVBvaW50cyhsaW5lSW5kaWNlcywgaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gJCQuZ2V0WVNjYWxlQnlJZC5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cdFx0Y29uc3QgeVZhbHVlID0gKGQsIGkpID0+IChcclxuXHRcdFx0JCQuaXNHcm91cGVkKGQuaWQpID9cclxuXHRcdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHRcdHlTY2FsZShkLmlkLCBpc1N1YikoJCQuZ2V0QmFzZVZhbHVlKGQpKVxyXG5cdFx0KTtcclxuXHJcblx0XHRsZXQgbGluZSA9IGQzTGluZSgpO1xyXG5cclxuXHRcdGxpbmUgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRsaW5lLngoeVZhbHVlKS55KHhWYWx1ZSkgOiBsaW5lLngoeFZhbHVlKS55KHlWYWx1ZSk7XHJcblxyXG5cdFx0aWYgKCFsaW5lQ29ubmVjdE51bGwpIHtcclxuXHRcdFx0bGluZSA9IGxpbmUuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeCA9IGlzU3ViID8gc2NhbGUuc3ViWCA6IHNjYWxlLng7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRjb25zdCB5ID0geVNjYWxlKGQuaWQsIGlzU3ViKTtcclxuXHRcdFx0bGV0IHZhbHVlcyA9IGxpbmVDb25uZWN0TnVsbCA/ICQkLmZpbHRlclJlbW92ZU51bGwoZC52YWx1ZXMpIDogZC52YWx1ZXM7XHJcblx0XHRcdGxldCB4MCA9IDA7XHJcblx0XHRcdGxldCB5MCA9IDA7XHJcblx0XHRcdGxldCBwYXRoO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzTGluZVR5cGUoZCkpIHtcclxuXHRcdFx0XHRjb25zdCByZWdpb25zID0gY29uZmlnLmRhdGFfcmVnaW9uc1tkLmlkXTtcclxuXHJcblx0XHRcdFx0aWYgKHJlZ2lvbnMpIHtcclxuXHRcdFx0XHRcdHBhdGggPSAkJC5saW5lV2l0aFJlZ2lvbnModmFsdWVzLCB4LCB5LCByZWdpb25zKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHBhdGggPSBsaW5lLmN1cnZlKCQkLmdldEN1cnZlKGQpKSh2YWx1ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZiAodmFsdWVzWzBdKSB7XHJcblx0XHRcdFx0XHR4MCA9IHgodmFsdWVzWzBdLngpO1xyXG5cdFx0XHRcdFx0eTAgPSB5KHZhbHVlc1swXS52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwYXRoID0gaXNSb3RhdGVkID8gYE0gJHt5MH0gJHt4MH1gIDogYE0gJHt4MH0gJHt5MH1gO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdC8vIGdlbmVyYXRlR2V0TGluZVBvaW50cyhsaW5lSW5kaWNlcywgaXNTdWJWYWx1ZT86IGJvb2xlYW4pOkZ1bmN0aW9uIHsgLy8gcGFydGlhbCBkdXBsaWNhdGlvbiBvZiBnZW5lcmF0ZUdldEJhclBvaW50c1xyXG5cdC8vIFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdC8vIFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHQvLyBcdGNvbnN0IGlzU3ViID0gISFpc1N1YlZhbHVlO1xyXG5cdC8vIFx0Y29uc3QgeCA9ICQkLmdldFNoYXBlWCgwLCBsaW5lSW5kaWNlcywgaXNTdWIpO1xyXG5cdC8vIFx0Y29uc3QgeSA9ICQkLmdldFNoYXBlWShpc1N1Yik7XHJcblx0Ly8gXHRjb25zdCBsaW5lT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNMaW5lVHlwZSwgbGluZUluZGljZXMsIGlzU3ViKTtcclxuXHQvLyBcdGNvbnN0IHlTY2FsZSA9ICQkLmdldFlTY2FsZUJ5SWQuYmluZCgkJCk7XHJcblxyXG5cdC8vIFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0Ly8gXHRcdGNvbnN0IHkwID0geVNjYWxlLmNhbGwoJCQsIGQuaWQpKCQkLmdldFNoYXBlWU1pbihkLmlkKSk7XHJcblx0Ly8gXHRcdGNvbnN0IG9mZnNldCA9IGxpbmVPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XHJcblx0Ly8gXHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xyXG5cdC8vIFx0XHRsZXQgcG9zWSA9IHkoZCk7XHJcblxyXG5cdC8vIFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcclxuXHQvLyBcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxyXG5cdC8vIFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXHJcblx0Ly8gXHRcdCkpIHtcclxuXHQvLyBcdFx0XHRwb3NZID0geTA7XHJcblx0Ly8gXHRcdH1cclxuXHJcblx0Ly8gXHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgbGluZSBwb3NpdGlvblxyXG5cdC8vIFx0XHRjb25zdCBwb2ludCA9IFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV07XHJcblxyXG5cdC8vIFx0XHRyZXR1cm4gW1xyXG5cdC8vIFx0XHRcdHBvaW50LFxyXG5cdC8vIFx0XHRcdHBvaW50LCAvLyBmcm9tIGhlcmUgYW5kIGJlbG93LCBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcclxuXHQvLyBcdFx0XHRwb2ludCxcclxuXHQvLyBcdFx0XHRwb2ludFxyXG5cdC8vIFx0XHRdO1xyXG5cdC8vIFx0fTtcclxuXHQvLyB9LFxyXG5cclxuXHRsaW5lV2l0aFJlZ2lvbnMoZCwgeCwgeSwgX3JlZ2lvbnMpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5heGlzLmlzVGltZVNlcmllcygpO1xyXG5cdFx0Y29uc3QgeE9mZnNldCA9ICQkLmF4aXMuaXNDYXRlZ29yaXplZCgpID8gMC41IDogMDtcclxuXHRcdGNvbnN0IHJlZ2lvbnM6IGFueVtdID0gW107XHJcblx0XHRjb25zdCBkYXNoYXJyYXkgPSBcIjIgMlwiOyAvLyBkZWZhdWx0IHZhbHVlXHJcblxyXG5cdFx0bGV0IHhwO1xyXG5cdFx0bGV0IHlwO1xyXG5cdFx0bGV0IGRpZmY7XHJcblx0XHRsZXQgZGlmZngyO1xyXG5cclxuXHRcdC8vIGNoZWNrIHdlYXRoZXIgZGF0YSBpcyB3aXRoaW4gcmVnaW9uXHJcblx0XHRjb25zdCBpc1dpdGhpblJlZ2lvbnMgPSAod2l0aGluWCwgd2l0aGluUmVnaW9ucykgPT4ge1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgcmVnOyAocmVnID0gd2l0aGluUmVnaW9uc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdGlmIChyZWcuc3RhcnQgPCB3aXRoaW5YICYmIHdpdGhpblggPD0gcmVnLmVuZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlZy5zdHlsZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQ2hlY2sgc3RhcnQvZW5kIG9mIHJlZ2lvbnNcclxuXHRcdGlmIChpc0RlZmluZWQoX3JlZ2lvbnMpKSB7XHJcblx0XHRcdGNvbnN0IGdldFZhbHVlID0gKHY6IERhdGUgfCBhbnksIGRlZjogbnVtYmVyKTogRGF0ZSB8IGFueSA9PiAoXHJcblx0XHRcdFx0aXNVbmRlZmluZWQodikgPyBkZWYgOiAoaXNUaW1lU2VyaWVzID8gcGFyc2VEYXRlLmNhbGwoJCQsIHYpIDogdilcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCByZWc7IChyZWcgPSBfcmVnaW9uc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gZ2V0VmFsdWUocmVnLnN0YXJ0LCBkWzBdLngpO1xyXG5cdFx0XHRcdGNvbnN0IGVuZCA9IGdldFZhbHVlKHJlZy5lbmQsIGRbZC5sZW5ndGggLSAxXS54KTtcclxuXHRcdFx0XHRjb25zdCBzdHlsZSA9IHJlZy5zdHlsZSB8fCB7ZGFzaGFycmF5fTtcclxuXHJcblx0XHRcdFx0cmVnaW9uc1tpXSA9IHtzdGFydCwgZW5kLCBzdHlsZX07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgc2NhbGVzXHJcblx0XHRjb25zdCB4VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB5KGR0LnZhbHVlKSA6IGR0ID0+IHgoZHQueCk7XHJcblx0XHRjb25zdCB5VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB4KGR0LngpIDogZHQgPT4geShkdC52YWx1ZSk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIHN2ZyBnZW5lcmF0b3IgZnVuY3Rpb24gZm9yIHJlZ2lvblxyXG5cdFx0Y29uc3QgZ2VuZXJhdGVNID0gcG9pbnRzID0+IGBNJHtwb2ludHNbMF1bMF19LCR7cG9pbnRzWzBdWzFdfUwke3BvaW50c1sxXVswXX0sJHtwb2ludHNbMV1bMV19YDtcclxuXHJcblx0XHRjb25zdCBzV2l0aFJlZ2lvbiA9IGlzVGltZVNlcmllcyA/IChkMCwgZDEsIGssIHRpbWVzZXJpZXNEaWZmKSA9PiB7XHJcblx0XHRcdGNvbnN0IHgwID0gZDAueC5nZXRUaW1lKCk7XHJcblx0XHRcdGNvbnN0IHhEaWZmID0gZDEueCAtIGQwLng7XHJcblx0XHRcdGNvbnN0IHh2MCA9IG5ldyBEYXRlKHgwICsgeERpZmYgKiBrKTtcclxuXHRcdFx0Y29uc3QgeHYxID0gbmV3IERhdGUoeDAgKyB4RGlmZiAqIChrICsgdGltZXNlcmllc0RpZmYpKTtcclxuXHJcblx0XHRcdGNvbnN0IHBvaW50cyA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0W1t5KHlwKGspKSwgeCh4djApXSwgW3koeXAoayArIGRpZmYpKSwgeCh4djEpXV0gOlxyXG5cdFx0XHRcdFtbeCh4djApLCB5KHlwKGspKV0sIFt4KHh2MSksIHkoeXAoayArIGRpZmYpKV1dO1xyXG5cclxuXHRcdFx0cmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xyXG5cdFx0fSA6IChkMCwgZDEsIGssIG90aGVyRGlmZikgPT4ge1xyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFtbeSh5cChrKSwgdHJ1ZSksIHgoeHAoaykpXSwgW3koeXAoayArIG90aGVyRGlmZiksIHRydWUpLCB4KHhwKGsgKyBvdGhlckRpZmYpKV1dIDpcclxuXHRcdFx0XHRbW3goeHAoayksIHRydWUpLCB5KHlwKGspKV0sIFt4KHhwKGsgKyBvdGhlckRpZmYpLCB0cnVlKSwgeSh5cChrICsgb3RoZXJEaWZmKSldXTtcclxuXHJcblx0XHRcdHJldHVybiBnZW5lcmF0ZU0ocG9pbnRzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGVcclxuXHRcdGxldCBwYXRoID0gXCJcIjtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMCwgZGF0YTsgKGRhdGEgPSBkW2ldKTsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHByZXZEYXRhID0gZFtpIC0gMV07XHJcblx0XHRcdGNvbnN0IGhhc1ByZXZEYXRhID0gcHJldkRhdGEgJiYgaXNWYWx1ZShwcmV2RGF0YS52YWx1ZSk7XHJcblx0XHRcdGxldCBzdHlsZSA9IGlzV2l0aGluUmVnaW9ucyhkYXRhLngsIHJlZ2lvbnMpO1xyXG5cclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvMTE3MlxyXG5cdFx0XHRpZiAoIWlzVmFsdWUoZGF0YS52YWx1ZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRHJhdyBhcyBub3JtYWxcclxuXHRcdFx0aWYgKGlzVW5kZWZpbmVkKHJlZ2lvbnMpIHx8ICFzdHlsZSB8fCAhaGFzUHJldkRhdGEpIHtcclxuXHRcdFx0XHRwYXRoICs9IGAke2kgJiYgaGFzUHJldkRhdGEgPyBcIkxcIiA6IFwiTVwifSR7eFZhbHVlKGRhdGEpfSwke3lWYWx1ZShkYXRhKX1gO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGhhc1ByZXZEYXRhKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHN0eWxlID0gc3R5bGUuZGFzaGFycmF5LnNwbGl0KFwiIFwiKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRzdHlsZSA9IGRhc2hhcnJheS5zcGxpdChcIiBcIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBEcmF3IHdpdGggcmVnaW9uIC8vIFRPRE86IEZpeCBmb3IgaG9yaXpvdGFsIGNoYXJ0c1xyXG5cdFx0XHRcdHhwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEueCArIHhPZmZzZXQsIGRhdGEueCArIHhPZmZzZXQsIGlzVGltZVNlcmllcyk7XHJcblx0XHRcdFx0eXAgPSAkJC5nZXRTY2FsZShwcmV2RGF0YS52YWx1ZSwgZGF0YS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGR4ID0geChkYXRhLngpIC0geChwcmV2RGF0YS54KTtcclxuXHRcdFx0XHRjb25zdCBkeSA9IHkoZGF0YS52YWx1ZSkgLSB5KHByZXZEYXRhLnZhbHVlKTtcclxuXHRcdFx0XHRjb25zdCBkZCA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xyXG5cclxuXHRcdFx0XHRkaWZmID0gc3R5bGVbMF0gLyBkZDtcclxuXHRcdFx0XHRkaWZmeDIgPSBkaWZmICogc3R5bGVbMV07XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGogPSBkaWZmOyBqIDw9IDE7IGogKz0gZGlmZngyKSB7XHJcblx0XHRcdFx0XHRwYXRoICs9IHNXaXRoUmVnaW9uKHByZXZEYXRhLCBkYXRhLCBqLCBkaWZmKTtcclxuXHJcblx0XHRcdFx0XHQvLyB0byBtYWtlIHN1cmUgY29ycmVjdCBsaW5lIGRyYXdpbmdcclxuXHRcdFx0XHRcdGlmIChqICsgZGlmZngyID49IDEpIHtcclxuXHRcdFx0XHRcdFx0cGF0aCArPSBzV2l0aFJlZ2lvbihwcmV2RGF0YSwgZGF0YSwgMSwgMCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhdGg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJlYUdyYWRpZW50KCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtkYXRldGltZUlkfSwgJGVsOiB7ZGVmc319ID0gJCQ7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdGNvbnN0IGlkID0gYCR7ZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzQXJlYVR5cGUoZCkgJiYgZGVmcy5zZWxlY3QoYCMke2lkfWApLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9ICQkLmNvbG9yKGQpO1xyXG5cdFx0XHRcdGNvbnN0IHtcclxuXHRcdFx0XHRcdHggPSBbMCwgMF0sXHJcblx0XHRcdFx0XHR5ID0gWzAsIDFdLFxyXG5cdFx0XHRcdFx0c3RvcHMgPSBbWzAsIGNvbG9yLCAxXSwgWzEsIGNvbG9yLCAwXV1cclxuXHRcdFx0XHR9ID0gY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQ7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGxpbmVhckdyYWRpZW50ID0gZGVmcy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJpZFwiLCBgJHtpZH1gKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4WzBdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB4WzFdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5WzBdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB5WzFdKTtcclxuXHJcblx0XHRcdFx0c3RvcHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHN0b3BDb2xvciA9IGlzRnVuY3Rpb24odlsxXSkgPyB2WzFdLmJpbmQoJCQuYXBpKShkLmlkKSA6IHZbMV07XHJcblxyXG5cdFx0XHRcdFx0bGluZWFyR3JhZGllbnQuYXBwZW5kKFwic3RvcFwiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcIm9mZnNldFwiLCB2WzBdKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcInN0b3AtY29sb3JcIiwgc3RvcENvbG9yIHx8IGNvbG9yKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcInN0b3Atb3BhY2l0eVwiLCB2WzJdKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJlYUNvbG9yKGQpOiBzdHJpbmcge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCA/XHJcblx0XHRcdGB1cmwoIyR7JCQuc3RhdGUuZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX0pYCA6XHJcblx0XHRcdCQkLmNvbG9yKGQpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0OiBudW1iZXIpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Y29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQgJiYgJCQudXBkYXRlQXJlYUdyYWRpZW50KCk7XHJcblxyXG5cdFx0JGVsLmFyZWEgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyZWFzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyZWF9YClcclxuXHRcdFx0LmRhdGEoJCQubGluZURhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdCRlbC5hcmVhLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdCRlbC5hcmVhID0gJGVsLmFyZWEuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmVhLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLnVwZGF0ZUFyZWFDb2xvci5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzdGF0ZS5vcmdBcmVhT3BhY2l0eSA9IGQzU2VsZWN0KHRoaXMpLnN0eWxlKFwib3BhY2l0eVwiKTtcclxuXHRcdFx0XHRyZXR1cm4gXCIwXCI7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5tZXJnZSgkZWwuYXJlYSk7XHJcblxyXG5cdFx0JGVsLmFyZWFcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBzdGF0ZS5vcmdBcmVhT3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3QXJlYShkcmF3QXJlYSwgd2l0aFRyYW5zaXRpb24/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7b3JnQXJlYU9wYWNpdHl9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gJCQuJGVsLmFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiAkJC4kZWwuYXJlYSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+IFN0cmluZygkJC5pc0FyZWFSYW5nZVR5cGUoZCkgPyBvcmdBcmVhT3BhY2l0eSAvIDEuNzUgOiBvcmdBcmVhT3BhY2l0eSkpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGFyZWEgcGF0aCBkYXRhXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGFyZWFJbmRpY2VzIEluZGljZXNcclxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ViIFdlYXRoZXIgaXMgc3ViIGF4aXNcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZURyYXdBcmVhKGFyZWFJbmRpY2VzLCBpc1N1Yj86IGJvb2xlYW4pOiAoZCkgPT4gc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGUgPSAkJC5nZXRZU2NhbGVCeUlkLmJpbmQoJCQpO1xyXG5cclxuXHRcdGNvbnN0IHhWYWx1ZSA9IGQgPT4gKGlzU3ViID8gJCQuc3VieHggOiAkJC54eCkuY2FsbCgkJCwgZCk7XHJcblx0XHRjb25zdCB2YWx1ZTAgPSAoZCwgaSkgPT4gKCQkLmlzR3JvdXBlZChkLmlkKSA/XHJcblx0XHRcdGdldFBvaW50cyhkLCBpKVswXVsxXSA6XHJcblx0XHRcdHlTY2FsZShkLmlkLCBpc1N1YikoXHJcblx0XHRcdFx0JCQuaXNBcmVhUmFuZ2VUeXBlKGQpID9cclxuXHRcdFx0XHRcdCQkLmdldEFyZWFSYW5nZURhdGEoZCwgXCJoaWdoXCIpIDogJCQuZ2V0U2hhcGVZTWluKGQuaWQpXHJcblx0XHRcdCkpO1xyXG5cdFx0Y29uc3QgdmFsdWUxID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMV1bMV0gOlxyXG5cdFx0XHR5U2NhbGUoZC5pZCwgaXNTdWIpKFxyXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XHJcblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwibG93XCIpIDogZC52YWx1ZVxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xyXG5cdFx0XHRsZXQgeDAgPSAwO1xyXG5cdFx0XHRsZXQgeTAgPSAwO1xyXG5cdFx0XHRsZXQgcGF0aDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpKSB7XHJcblx0XHRcdFx0bGV0IGFyZWEgPSBkM0FyZWEoKTtcclxuXHJcblx0XHRcdFx0YXJlYSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRhcmVhLnkoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQueDAodmFsdWUwKVxyXG5cdFx0XHRcdFx0XHQueDEodmFsdWUxKSA6XHJcblx0XHRcdFx0XHRhcmVhLngoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHRcdC55MChjb25maWcuYXJlYV9hYm92ZSA/IDAgOiB2YWx1ZTApXHJcblx0XHRcdFx0XHRcdC55MSh2YWx1ZTEpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWxpbmVDb25uZWN0TnVsbCkge1xyXG5cdFx0XHRcdFx0YXJlYSA9IGFyZWEuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xyXG5cdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGFyZWEuY3VydmUoJCQuZ2V0Q3VydmUoZCkpKHZhbHVlcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xyXG5cdFx0XHRcdFx0eDAgPSAkJC5zY2FsZS54KHZhbHVlc1swXS54KTtcclxuXHRcdFx0XHRcdHkwID0gJCQuZ2V0WVNjYWxlQnlJZChkLmlkKSh2YWx1ZXNbMF0udmFsdWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGlzUm90YXRlZCA/IGBNICR7eTB9ICR7eDB9YCA6IGBNICR7eDB9ICR7eTB9YDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGggfHwgXCJNIDAgMFwiO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdldEFyZWFQb2ludHMoYXJlYUluZGljZXMsIGlzU3ViPzogYm9vbGVhbik6IEZ1bmN0aW9uIHtcclxuXHRcdC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB4ID0gJCQuZ2V0U2hhcGVYKDAsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XHJcblx0XHRjb25zdCBhcmVhT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNBcmVhVHlwZSwgYXJlYUluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gJCQuZ2V0WVNjYWxlQnlJZC5iaW5kKCQkKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRjb25zdCB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgkJC5nZXRTaGFwZVlNaW4oZC5pZCkpO1xyXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBhcmVhT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYXJlYSBjaGFydFxyXG5cdFx0XHRjb25zdCBwb3NYID0geChkKTtcclxuXHRcdFx0bGV0IHBvc1kgPSB5KGQpO1xyXG5cclxuXHRcdFx0Ly8gZml4IHBvc1kgbm90IHRvIG92ZXJmbG93IG9wcG9zaXRlIHF1YWRyYW50XHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkICYmIChcclxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxyXG5cdFx0XHQpKSB7XHJcblx0XHRcdFx0cG9zWSA9IHkwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyAxIHBvaW50IHRoYXQgbWFya3MgdGhlIGFyZWEgcG9zaXRpb25cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRbcG9zWCwgb2Zmc2V0XSxcclxuXHRcdFx0XHRbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldLFxyXG5cdFx0XHRcdFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRcdFtwb3NYLCBvZmZzZXRdIC8vIG5lZWRlZCBmb3IgY29tcGF0aWJpbGl0eVxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpblN0ZXAodGhhdCwgeTogbnVtYmVyKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoeSAtIGQzTW91c2UodGhhdClbMV0pIDwgMzA7XHJcblx0fSxcclxuXHJcblx0c2hvdWxkRHJhd1BvaW50c0ZvckxpbmUoZCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgbGluZVBvaW50ID0gdGhpcy5jb25maWcubGluZV9wb2ludDtcclxuXHJcblx0XHRyZXR1cm4gbGluZVBvaW50ID09PSB0cnVlIHx8XHJcblx0XHRcdChpc0FycmF5KGxpbmVQb2ludCkgJiYgbGluZVBvaW50LmluZGV4T2YoZC5pZCkgIT09IC0xKTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXMsXHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3RcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQge2dldEJvdW5kaW5nUmVjdCwgZ2V0UmFuZG9tLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNPYmplY3RUeXBlLCBpc1VuZGVmaW5lZCwgaXNWYWx1ZSwgdG9BcnJheSwgbm90RW1wdHl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuY29uc3QgZ2V0VHJhbnNpdGlvbk5hbWUgPSAoKSA9PiBnZXRSYW5kb20oKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRoYXNWYWxpZFBvaW50VHlwZSh0eXBlPzogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gL14oY2lyY2xlfHJlY3QoYW5nbGUpP3xwb2x5Z29ufGVsbGlwc2V8dXNlKSQvaS50ZXN0KHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZSk7XHJcblx0fSxcclxuXHJcblx0aGFzVmFsaWRQb2ludERyYXdNZXRob2RzKHR5cGU/OiBzdHJpbmcpOiBib29sZWFuIHtcclxuXHRcdGNvbnN0IHBvaW50VHlwZSA9IHR5cGUgfHwgdGhpcy5jb25maWcucG9pbnRfdHlwZTtcclxuXHJcblx0XHRyZXR1cm4gaXNPYmplY3RUeXBlKHBvaW50VHlwZSkgJiZcclxuXHRcdFx0aXNGdW5jdGlvbihwb2ludFR5cGUuY3JlYXRlKSAmJiBpc0Z1bmN0aW9uKHBvaW50VHlwZS51cGRhdGUpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlKGQpOiBcIjFcIiB8IFwiMFwiIHtcclxuXHRcdGNvbnN0IHt3aXRob3V0RmFkZUlufSA9IHRoaXMuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXHJcblx0XHRcdHdpdGhvdXRGYWRlSW5bZC5pZF0gPyB0aGlzLm9wYWNpdHlGb3JDaXJjbGUoZCkgOiBcIjBcIjtcclxuXHR9LFxyXG5cclxuXHRvcGFjaXR5Rm9yQ2lyY2xlKGQpOiBcIjAuNVwiIHwgXCIxXCIgfCBcIjBcIiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBvcGFjaXR5ID0gY29uZmlnLnBvaW50X3Nob3cgJiYgIWNvbmZpZy5wb2ludF9mb2N1c19vbmx5ID8gXCIxXCIgOiBcIjBcIjtcclxuXHJcblx0XHRyZXR1cm4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkgP1xyXG5cdFx0XHQodGhpcy5pc0J1YmJsZVR5cGUoZCkgfHwgdGhpcy5pc1NjYXR0ZXJUeXBlKGQpID9cclxuXHRcdFx0XHRcIjAuNVwiIDogb3BhY2l0eSkgOiBcIjBcIjtcclxuXHR9LFxyXG5cclxuXHRpbml0Q2lyY2xlKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0JCQucG9pbnQgPSAkJC5nZW5lcmF0ZVBvaW50KCk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydENpcmNsZXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldEZvckNpcmNsZSh0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBkYXRhLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCEkZWwuY2lyY2xlICYmIGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdCQkLmluaXRDaXJjbGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBjbGFzc0NpcmNsZXMgPSAkJC5jbGFzc0NpcmNsZXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gKHQgfHwgZGF0YS50YXJnZXRzKVxyXG5cdFx0XHQuZmlsdGVyKHYgPT4gKFxyXG5cdFx0XHRcdCEkJC5pc0JhclR5cGUodikgJiYgKFxyXG5cdFx0XHRcdFx0ISQkLmlzTGluZVR5cGUodikgfHwgJCQuc2hvdWxkRHJhd1BvaW50c0ZvckxpbmUodilcclxuXHRcdFx0XHQpICYmICQkLmxhYmVsaXNoRGF0YSh2KVxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluQ2lyY2xlID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydENpcmNsZXN9YClcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0cylcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NpcmNsZXMpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5DaXJjbGVFbnRlciA9IG1haW5DaXJjbGUuZW50ZXIoKTtcclxuXHJcblx0XHQvLyBDaXJjbGVzIGZvciBlYWNoIGRhdGEgcG9pbnQgb24gbGluZXNcclxuXHRcdGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIG1haW5DaXJjbGVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlcywgZC5pZCkpO1xyXG5cclxuXHRcdG1haW5DaXJjbGVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaXJjbGVzKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZS5iaW5kKCQkLmFwaSkoZCkgPyBcInBvaW50ZXJcIiA6IG51bGwpKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgZGF0ZSBmb3Igc2VsZWN0ZWQgY2lyY2xlc1xyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHQkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHQuaWQpfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgJHtDTEFTUy5zZWxlY3RlZENpcmNsZX1gKVxyXG5cdFx0XHRcdC5lYWNoKGQgPT4ge1xyXG5cdFx0XHRcdFx0ZC52YWx1ZSA9IHQudmFsdWVzW2QuaW5kZXhdLnZhbHVlO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQ2lyY2xlKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGZvY3VzT25seSA9IGNvbmZpZy5wb2ludF9mb2N1c19vbmx5O1xyXG5cclxuXHRcdGlmIChjb25maWcucG9pbnRfc2hvdyAmJiAhc3RhdGUudG9nZ2xpbmcpIHtcclxuXHRcdFx0Y29uc3QgY3VyckluZGV4ID0gZm9jdXNPbmx5ICYmICRlbC5jaXJjbGUgP1xyXG5cdFx0XHRcdCRlbC5jaXJjbGUuZGF0YSgpWzBdLmluZGV4IDogMDtcclxuXHJcblx0XHRcdGNvbnN0IGNpcmNsZXMgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGV9YClcclxuXHRcdFx0XHQuZGF0YShkID0+IChmb2N1c09ubHkgPyBbZC52YWx1ZXNbY3VyckluZGV4XV0gOiBkLnZhbHVlcykpO1xyXG5cclxuXHRcdFx0Y2lyY2xlcy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRjb25zdCBmbiA9ICQkLnBvaW50KFwiY3JlYXRlXCIsIHRoaXMsICQkLnBvaW50Ui5iaW5kKCQkKSwgJCQuY29sb3IpO1xyXG5cclxuXHRcdFx0Y2lyY2xlcy5lbnRlcigpXHJcblx0XHRcdFx0LmZpbHRlcihkID0+IGQpXHJcblx0XHRcdFx0LmFwcGVuZChmbilcclxuXHRcdFx0XHQubWVyZ2UoY2lyY2xlcylcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQuY29sb3IpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5pbml0aWFsT3BhY2l0eUZvckNpcmNsZS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0XHQkZWwuY2lyY2xlID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfSAuJHtDTEFTUy5jaXJjbGV9YCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVkcmF3Q2lyY2xlKGN4OiBGdW5jdGlvbiwgY3k6IEZ1bmN0aW9uLCB3aXRoVHJhbnNpdGlvbjogYm9vbGVhbiwgZmxvdykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7cmVuZGVyZWR9LCAkZWw6IHtjaXJjbGUsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2VsZWN0ZWRDaXJjbGVzID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfWApO1xyXG5cclxuXHRcdGlmICghJCQuY29uZmlnLnBvaW50X3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuIFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJ1cGRhdGVcIiwgJCQsIGN4LCBjeSwgJCQuY29sb3IsIHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpO1xyXG5cdFx0Y29uc3QgcG9zQXR0ciA9ICQkLmlzQ2lyY2xlUG9pbnQoKSA/IFwiY1wiIDogXCJcIjtcclxuXHJcblx0XHRjb25zdCB0OiBhbnkgPSBnZXRSYW5kb20oKTtcclxuXHRcdGNvbnN0IG9wYWNpdHlTdHlsZUZuID0gJCQub3BhY2l0eUZvckNpcmNsZS5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCBtYWluQ2lyY2xlczogYW55W10gPSBbXTtcclxuXHJcblx0XHRjaXJjbGUuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdGxldCByZXN1bHQ6IGQzU2VsZWN0aW9uIHwgYW55ID0gZm4uYmluZCh0aGlzKShkKTtcclxuXHJcblx0XHRcdHJlc3VsdCA9ICgod2l0aFRyYW5zaXRpb24gfHwgIXJlbmRlcmVkKSA/IHJlc3VsdC50cmFuc2l0aW9uKHQpIDogcmVzdWx0KVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eVN0eWxlRm4pO1xyXG5cclxuXHRcdFx0bWFpbkNpcmNsZXMucHVzaChyZXN1bHQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0bWFpbkNpcmNsZXMsXHJcblx0XHRcdHNlbGVjdGVkQ2lyY2xlc1xyXG5cdFx0XHRcdC5hdHRyKGAke3Bvc0F0dHJ9eGAsIGN4KVxyXG5cdFx0XHRcdC5hdHRyKGAke3Bvc0F0dHJ9eWAsIGN5KVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IGZvY3VzZWQgZGF0YSBwb2ludCBjaXJjbGVcclxuXHQgKiBAcGFyYW0ge29iamVjdH0gZCBTZWxlY3RlZCBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzaG93Q2lyY2xlRm9jdXMoZD8pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aGFzUmFkYXIsIHJlc2l6aW5nLCB0b2dnbGluZywgdHJhbnNpdGluZ30sICRlbH0gPSAkJDtcclxuXHRcdGxldCB7Y2lyY2xlfSA9ICRlbDtcclxuXHJcblx0XHRpZiAodHJhbnNpdGluZyA9PT0gZmFsc2UgJiYgY29uZmlnLnBvaW50X2ZvY3VzX29ubHkgJiYgY2lyY2xlKSB7XHJcblx0XHRcdGNvbnN0IGN4ID0gKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVYIDogJCQuY2lyY2xlWCkuYmluZCgkJCk7XHJcblx0XHRcdGNvbnN0IGN5ID0gKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVZIDogJCQuY2lyY2xlWSkuYmluZCgkJCk7XHJcblx0XHRcdGNvbnN0IHdpdGhUcmFuc2l0aW9uID0gdG9nZ2xpbmcgfHwgaXNVbmRlZmluZWQoZCk7XHJcblx0XHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJ1cGRhdGVcIiwgJCQsIGN4LCBjeSwgJCQuY29sb3IsIHJlc2l6aW5nID8gZmFsc2UgOiB3aXRoVHJhbnNpdGlvbik7XHJcblxyXG5cdFx0XHRpZiAoZCkge1xyXG5cdFx0XHRcdGNpcmNsZSA9IGNpcmNsZVxyXG5cdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbih0KSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBkLmZpbHRlcih2ID0+IHYuaWQgPT09IHQuaWQpO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGRhdGEubGVuZ3RoID9cclxuXHRcdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5kYXR1bShkYXRhWzBdKSA6IGZhbHNlO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNpcmNsZVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgdGhpcy51cGRhdGVQb2ludENsYXNzLmJpbmQodGhpcykpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRjb25zdCB7aWQsIGluZGV4LCB2YWx1ZX0gPSBkO1xyXG5cdFx0XHRcdFx0bGV0IHZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xyXG5cclxuXHRcdFx0XHRcdGlmIChpc1ZhbHVlKHZhbHVlKSkge1xyXG5cdFx0XHRcdFx0XHRmbi5iaW5kKHRoaXMpKGQpO1xyXG5cdFx0XHRcdFx0XHQkJC5leHBhbmRDaXJjbGVzKGluZGV4LCBpZCk7XHJcblx0XHRcdFx0XHRcdHZpc2liaWxpdHkgPSBcIlwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRoaXMuc3R5bGUudmlzaWJpbGl0eSA9IHZpc2liaWxpdHk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSBmb2N1c2VkIGRhdGEgcG9pbnQgY2lyY2xlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoaWRlQ2lyY2xlRm9jdXMoKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtjaXJjbGV9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcucG9pbnRfZm9jdXNfb25seSAmJiBjaXJjbGUpIHtcclxuXHRcdFx0JCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblx0XHRcdGNpcmNsZS5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y2lyY2xlWChkKTogbnVtYmVyIHwgbnVsbCB7XHJcblx0XHRyZXR1cm4gdGhpcy54eChkKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVDaXJjbGVZKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKCQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKSwgZmFsc2UpO1xyXG5cclxuXHRcdCQkLmNpcmNsZVkgPSAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCBpZCA9IGQuaWQ7XHJcblxyXG5cdFx0XHRyZXR1cm4gJCQuaXNHcm91cGVkKGlkKSA/XHJcblx0XHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzBdWzFdIDpcclxuXHRcdFx0XHQkJC5nZXRZU2NhbGVCeUlkKGlkKSgkJC5nZXRCYXNlVmFsdWUoZCkpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRDaXJjbGVzKGk6IG51bWJlciwgaWQ6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xyXG5cclxuXHRcdHJldHVybiAoaWQgPyAkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiAkJC4kZWwubWFpbilcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlfSR7c3VmZml4fWApO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZENpcmNsZXMoaTogbnVtYmVyLCBpZDogc3RyaW5nLCByZXNldD86IGJvb2xlYW4pOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHIgPSAkJC5wb2ludEV4cGFuZGVkUi5iaW5kKCQkKTtcclxuXHJcblx0XHRyZXNldCAmJiAkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHJcblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpLCBpZCkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XHJcblx0XHRjb25zdCBzY2FsZSA9IHIoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcjtcclxuXHRcdGNvbnN0IHJhdGlvID0gMSAtIHNjYWxlO1xyXG5cclxuXHRcdGlmICgkJC5pc0NpcmNsZVBvaW50KCkpIHtcclxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwiclwiLCByKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHRyYW5zZm9ybSBtdXN0IGJlIGFwcGxpZWQgdG8gZWFjaCBub2RlIGluZGl2aWR1YWxseVxyXG5cdFx0XHRjaXJjbGVzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMudGFnTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInJcIiwgcik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuZ2V0QkJveCgpO1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHJhdGlvICogKCtwb2ludC5hdHRyKFwieFwiKSArIHdpZHRoIC8gMik7XHJcblx0XHRcdFx0XHRjb25zdCB5ID0gcmF0aW8gKiAoK3BvaW50LmF0dHIoXCJ5XCIpICsgaGVpZ2h0IC8gMik7XHJcblxyXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eH0gJHt5fSkgc2NhbGUoJHtzY2FsZX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1bmV4cGFuZENpcmNsZXMoaSk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgciA9ICQkLnBvaW50Ui5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVEKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIGZhbHNlKTtcclxuXHJcblx0XHRjaXJjbGVzLmF0dHIoXCJyXCIsIHIpO1xyXG5cclxuXHRcdCEkJC5pc0NpcmNsZVBvaW50KCkgJiZcclxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3IoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcn0pYCk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRSKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0bGV0IHIgPSBwb2ludFI7XHJcblxyXG5cdFx0aWYgKCQkLmlzQnViYmxlVHlwZShkKSkge1xyXG5cdFx0XHRyID0gJCQuZ2V0QnViYmxlUihkKTtcclxuXHRcdH0gZWxzZSBpZiAoaXNGdW5jdGlvbihwb2ludFIpKSB7XHJcblx0XHRcdHIgPSBwb2ludFIuYmluZCgkJC5hcGkpKGQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50RXhwYW5kZWRSKGQpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHNjYWxlID0gJCQuaXNCdWJibGVUeXBlKGQpID8gMS4xNSA6IDEuNzU7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCA/XHJcblx0XHRcdChjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX3IgfHwgJCQucG9pbnRSKGQpICogc2NhbGUpIDogJCQucG9pbnRSKGQpO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50U2VsZWN0UihkKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNlbGVjdFIgPSAkJC5jb25maWcucG9pbnRfc2VsZWN0X3I7XHJcblxyXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oc2VsZWN0UikgP1xyXG5cdFx0XHRzZWxlY3RSKGQpIDogKHNlbGVjdFIgfHwgJCQucG9pbnRSKGQpICogNCk7XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5DaXJjbGUobm9kZSwgcj86IG51bWJlcik6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKG5vZGUpO1xyXG5cdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KG5vZGUpO1xyXG5cdFx0Y29uc3QgcHJlZml4ID0gdGhpcy5pc0NpcmNsZVBvaW50KG5vZGUpID8gXCJjXCIgOiBcIlwiO1xyXG5cdFx0bGV0IGN4ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eGApO1xyXG5cdFx0bGV0IGN5ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eWApO1xyXG5cclxuXHRcdC8vIGlmIG5vZGUgZG9uJ3QgaGF2ZSBjeC95IG9yIHgveSBhdHRyaWJ1dGUgdmFsdWVcclxuXHRcdGlmICghKGN4IHx8IGN5KSAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XHJcblx0XHRcdGNvbnN0IHt4LCB5fSA9IGdldEJvdW5kaW5nUmVjdChub2RlKTtcclxuXHJcblx0XHRcdGN4ID0geDtcclxuXHRcdFx0Y3kgPSB5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoXHJcblx0XHRcdE1hdGgucG93KGN4IC0gbW91c2VbMF0sIDIpICsgTWF0aC5wb3coY3kgLSBtb3VzZVsxXSwgMilcclxuXHRcdCkgPCAociB8fCB0aGlzLmNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSk7XHJcblx0fSxcclxuXHJcblx0aW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgaWQ6IHN0cmluZyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY29weUF0dHIgPSAoZnJvbSwgdGFyZ2V0KSA9PiB7XHJcblx0XHRcdGNvbnN0IGF0dHJpYnMgPSBmcm9tLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbmFtZTsgKG5hbWUgPSBhdHRyaWJzW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0bmFtZSA9IG5hbWUubmFtZTtcclxuXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIGZyb20uZ2V0QXR0cmlidXRlKG5hbWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHBvaW50LCBcImltYWdlL3N2Zyt4bWxcIik7XHJcblx0XHRjb25zdCBub2RlID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XHJcblxyXG5cdFx0Y2xvbmUuaWQgPSBpZDtcclxuXHRcdGNsb25lLnN0eWxlLmZpbGwgPSBcImluaGVyaXRcIjtcclxuXHRcdGNsb25lLnN0eWxlLnN0cm9rZSA9IFwiaW5oZXJpdFwiO1xyXG5cclxuXHRcdGNvcHlBdHRyKG5vZGUsIGNsb25lKTtcclxuXHJcblx0XHRpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZDNTZWxlY3QoY2xvbmUpO1xyXG5cclxuXHRcdFx0aWYgKFwiaW5uZXJIVE1MXCIgaW4gY2xvbmUpIHtcclxuXHRcdFx0XHRwYXJlbnQuaHRtbChub2RlLmlubmVySFRNTCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dG9BcnJheShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb3B5QXR0cih2LCBwYXJlbnQuYXBwZW5kKHYudGFnTmFtZSkubm9kZSgpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCQkLiRlbC5kZWZzLm5vZGUoKS5hcHBlbmRDaGlsZChjbG9uZSk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRGcm9tRGVmcyhpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy4kZWwuZGVmcy5zZWxlY3QoYCMke2lkfWApO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVBvaW50Q2xhc3MoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NpcmNsZX0gPSAkJC4kZWw7XHJcblx0XHRsZXQgcG9pbnRDbGFzcyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChkKSB8fCBjaXJjbGUpIHtcclxuXHRcdFx0cG9pbnRDbGFzcyA9IGQgPT09IHRydWUgP1xyXG5cdFx0XHRcdGNpcmNsZS5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGxldCBjbGFzc05hbWUgPSAkJC5jbGFzc0NpcmNsZS5iaW5kKCQkKShkKTtcclxuXHJcblx0XHRcdFx0XHRpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5pbmRleE9mKENMQVNTLkVYUEFOREVEKSA+IC0xKSB7XHJcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSArPSBgICR7Q0xBU1MuRVhQQU5ERUR9YDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNsYXNzTmFtZSk7XHJcblx0XHRcdFx0fSkgOiAkJC5jbGFzc0NpcmNsZShkKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9pbnRDbGFzcztcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdldExpbmVQb2ludHMobGluZUluZGljZXMsIGlzU3ViVmFsdWU/OiBib29sZWFuKTpGdW5jdGlvbiB7IC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1N1YiA9ICEhaXNTdWJWYWx1ZTtcclxuXHRcdGNvbnN0IHggPSAkJC5nZXRTaGFwZVgoMCwgbGluZUluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoaXNTdWIpO1xyXG5cdFx0Y29uc3QgbGluZU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzTGluZVR5cGUsIGxpbmVJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGUgPSAkJC5nZXRZU2NhbGVCeUlkLmJpbmQoJCQpO1xyXG5cclxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCB5MCA9IHlTY2FsZS5jYWxsKCQkLCBkLmlkKSgkJC5nZXRTaGFwZVlNaW4oZC5pZCkpO1xyXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBsaW5lT2Zmc2V0KGQsIGkpIHx8IHkwOyAvLyBvZmZzZXQgaXMgZm9yIHN0YWNrZWQgYXJlYSBjaGFydFxyXG5cdFx0XHRjb25zdCBwb3NYID0geChkKTtcclxuXHRcdFx0bGV0IHBvc1kgPSB5KGQpO1xyXG5cclxuXHRcdFx0Ly8gZml4IHBvc1kgbm90IHRvIG92ZXJmbG93IG9wcG9zaXRlIHF1YWRyYW50XHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkICYmIChcclxuXHRcdFx0XHQoZC52YWx1ZSA+IDAgJiYgcG9zWSA8IHkwKSB8fCAoZC52YWx1ZSA8IDAgJiYgeTAgPCBwb3NZKVxyXG5cdFx0XHQpKSB7XHJcblx0XHRcdFx0cG9zWSA9IHkwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyAxIHBvaW50IHRoYXQgbWFya3MgdGhlIGxpbmUgcG9zaXRpb25cclxuXHRcdFx0Y29uc3QgcG9pbnQgPSBbcG9zWCwgcG9zWSAtICh5MCAtIG9mZnNldCldO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludCwgLy8gZnJvbSBoZXJlIGFuZCBiZWxvdywgbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVQb2ludCgpOiBGdW5jdGlvbiB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2RhdGV0aW1lSWR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0Y29uc3QgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5wb2ludF9wYXR0ZXJuKSA/IGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24obWV0aG9kLCBjb250ZXh0LCAuLi5hcmdzKSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3QgaWQ6IHN0cmluZyA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XHJcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRpZHMuaW5kZXhPZihpZCkgPCAwICYmIGlkcy5wdXNoKGlkKTtcclxuXHJcblx0XHRcdFx0bGV0IHBvaW50ID0gcGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBwYXR0ZXJuLmxlbmd0aF07XHJcblxyXG5cdFx0XHRcdGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZShwb2ludCkpIHtcclxuXHRcdFx0XHRcdHBvaW50ID0gJCRbcG9pbnRdO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoISQkLmhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyhwb2ludCkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50SWQgPSBgJHtkYXRldGltZUlkfS1wb2ludC0ke2lkfWA7XHJcblx0XHRcdFx0XHRjb25zdCBwb2ludEZyb21EZWZzID0gJCQucG9pbnRGcm9tRGVmcyhwb2ludElkKTtcclxuXHJcblx0XHRcdFx0XHRpZiAocG9pbnRGcm9tRGVmcy5zaXplKCkgPCAxKSB7XHJcblx0XHRcdFx0XHRcdCQkLmluc2VydFBvaW50SW5mb0RlZnMocG9pbnQsIHBvaW50SWQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChtZXRob2QgPT09IFwiY3JlYXRlXCIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmN1c3RvbS5jcmVhdGUuYmluZChjb250ZXh0KShlbGVtZW50LCBwb2ludElkLCAuLi5hcmdzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobWV0aG9kID09PSBcInVwZGF0ZVwiKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAkJC5jdXN0b20udXBkYXRlLmJpbmQoY29udGV4dCkoZWxlbWVudCwgLi4uYXJncyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gcG9pbnRbbWV0aG9kXS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIC4uLmFyZ3MpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRjdXN0b206IHtcclxuXHRcdGNyZWF0ZShlbGVtZW50LCBpZCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xyXG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJ1c2VcIilcclxuXHRcdFx0XHQuYXR0cihcInhsaW5rOmhyZWZcIiwgYCMke2lkfWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgeFBvc0ZuMiA9IGQgPT4geFBvc0ZuKGQpIC0gd2lkdGggLyAyO1xyXG5cdFx0XHRjb25zdCB5UG9zRm4yID0gZCA9PiB5UG9zRm4oZCkgLSBoZWlnaHQgLyAyO1xyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSBnZXRUcmFuc2l0aW9uTmFtZSgpO1xyXG5cclxuXHRcdFx0XHRmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJ4XCIsIHhQb3NGbjIpO1xyXG5cclxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcyAmJiBzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbihnZXRUcmFuc2l0aW9uTmFtZSgpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1haW5DaXJjbGVzXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhQb3NGbjIpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlQb3NGbjIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gJ2NpcmNsZScgZGF0YSBwb2ludFxyXG5cdGNpcmNsZToge1xyXG5cdFx0Y3JlYXRlKGVsZW1lbnQsIHNpemVGbiwgZmlsbFN0eWxlRm4pIHtcclxuXHRcdFx0cmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwiY2lyY2xlXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuYXR0cihcInJcIiwgc2l6ZUZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBmaWxsU3R5bGVGbixcclxuXHRcdFx0d2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykge1xyXG5cdFx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRcdGxldCBtYWluQ2lyY2xlcyA9IGVsZW1lbnQ7XHJcblxyXG5cdFx0XHQvLyB3aGVuICcubG9hZCgpJyBjYWxsZWQsIGJ1YmJsZSBzaXplIHNob3VsZCBiZSB1cGRhdGVkXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlKFwiYnViYmxlXCIpKSB7XHJcblx0XHRcdFx0bWFpbkNpcmNsZXMuYXR0cihcInJcIiwgJCQucG9pbnRSLmJpbmQoJCQpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSBnZXRUcmFuc2l0aW9uTmFtZSgpO1xyXG5cclxuXHRcdFx0XHRmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiLCB4UG9zRm4pO1xyXG5cclxuXHRcdFx0XHRpZiAobWFpbkNpcmNsZXMuYXR0cihcImN4XCIpKSB7XHJcblx0XHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzICYmIHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKGdldFRyYW5zaXRpb25OYW1lKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihcImN4XCIsIHhQb3NGbilcclxuXHRcdFx0XHQuYXR0cihcImN5XCIsIHlQb3NGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyAncmVjdGFuZ2xlJyBkYXRhIHBvaW50XHJcblx0cmVjdGFuZ2xlOiB7XHJcblx0XHRjcmVhdGUoZWxlbWVudCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xyXG5cdFx0XHRjb25zdCByZWN0U2l6ZUZuID0gZCA9PiBzaXplRm4oZCkgKiAyLjA7XHJcblxyXG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHJlY3RTaXplRm4pXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgcmVjdFNpemVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0XHRjb25zdCByID0gJCQuY29uZmlnLnBvaW50X3I7XHJcblx0XHRcdGNvbnN0IHJlY3RYUG9zRm4gPSBkID0+IHhQb3NGbihkKSAtIHI7XHJcblx0XHRcdGNvbnN0IHJlY3RZUG9zRm4gPSBkID0+IHlQb3NGbihkKSAtIHI7XHJcblxyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSBnZXRUcmFuc2l0aW9uTmFtZSgpO1xyXG5cclxuXHRcdFx0XHRmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJ4XCIsIHJlY3RYUG9zRm4pO1xyXG5cclxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcyAmJiBzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbihnZXRUcmFuc2l0aW9uTmFtZSgpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1haW5DaXJjbGVzXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIHJlY3RYUG9zRm4pXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIHJlY3RZUG9zRm4pXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7S0VZfSBmcm9tIFwiLi4vLi4vbW9kdWxlL0NhY2hlXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRNaW5NYXgsIGdldFJhbmdlLCBpc0RlZmluZWQsIGlzRW1wdHksIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgc2V0VGV4dFZhbHVlLCB0b0FycmF5fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHBvc2l0aW9uIHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNDbG9ja3dpc2UgSWYgdGhlIGRpcmVjdGlvbiBpcyBjbG9ja3dpc2VcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgQ29vcmRpbmF0ZSB0eXBlICd4JyBvciAneSdcclxuICogQHBhcmFtIHtudW1iZXJ9IGVkZ2UgTnVtYmVyIG9mIGVkZ2VcclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBUaGUgaW5kZXhlZCBwb3NpdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFuZ2UgUmFuZ2UgdmFsdWVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhdGlvIFJhdGlvIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihpc0Nsb2Nrd2lzZTogYm9vbGVhbiwgdHlwZTogXCJ4XCIgfCBcInlcIiwgZWRnZTogbnVtYmVyLCBwb3M6IG51bWJlciwgcmFuZ2U6IG51bWJlciwgcmF0aW86IG51bWJlcik6IG51bWJlciB7XHJcblx0Y29uc3QgaW5kZXggPSBpc0Nsb2Nrd2lzZSAmJiBwb3MgPiAwID8gZWRnZSAtIHBvcyA6IHBvcztcclxuXHRjb25zdCByID0gMiAqIE1hdGguUEk7XHJcblx0Y29uc3QgZnVuYyA9IHR5cGUgPT09IFwieFwiID8gTWF0aC5zaW4gOiBNYXRoLmNvcztcclxuXHJcblx0cmV0dXJuIHJhbmdlICogKDEgLSByYXRpbyAqIGZ1bmMoaW5kZXggKiByIC8gZWRnZSkpO1xyXG59XHJcblxyXG4vLyBjYWNoZSBrZXlcclxuY29uc3QgY2FjaGVLZXkgPSBLRVkucmFkYXJQb2ludHM7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdFJhZGFyKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50fSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwicmFkYXJcIikpIHtcclxuXHRcdFx0JGVsLnJhZGFyID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydFJhZGFycyk7XHJcblxyXG5cdFx0XHQvLyBsZXZlbFxyXG5cdFx0XHQkZWwucmFkYXIubGV2ZWxzID0gJGVsLnJhZGFyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmxldmVscyk7XHJcblxyXG5cdFx0XHQvLyBheGlzXHJcblx0XHRcdCRlbC5yYWRhci5heGVzID0gJGVsLnJhZGFyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXMpO1xyXG5cclxuXHRcdFx0Ly8gc2hhcGVzXHJcblx0XHRcdCRlbC5yYWRhci5zaGFwZXMgPSAkZWwucmFkYXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muc2hhcGVzKTtcclxuXHJcblx0XHRcdGN1cnJlbnQuZGF0YU1heCA9IGNvbmZpZy5yYWRhcl9heGlzX21heCB8fCAkJC5nZXRNaW5NYXhEYXRhKCkubWF4WzBdLnZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldFJhZGFyU2l6ZSgpOiBbbnVtYmVyLCBudW1iZXJdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7YXJjV2lkdGgsIGFyY0hlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCA8IDQgPyAtMjAgOiAxMDtcclxuXHRcdGNvbnN0IHNpemUgPSAoTWF0aC5taW4oYXJjV2lkdGgsIGFyY0hlaWdodCkgLSBwYWRkaW5nKSAvIDI7XHJcblxyXG5cdFx0cmV0dXJuIFtzaXplLCBzaXplXTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yUmFkYXIodGFyZ2V0cyk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoaXNFbXB0eShjb25maWcuYXhpc194X2NhdGVnb3JpZXMpKSB7XHJcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGdldFJhbmdlKDAsIGdldE1pbk1heChcIm1heFwiLCB0YXJnZXRzLm1hcCh2ID0+IHYudmFsdWVzLmxlbmd0aCkpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5nZW5lcmF0ZVJhZGFyUG9pbnRzKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkYXJQb3NpdGlvbih0eXBlLCBpbmRleDogbnVtYmVyLCByYW5nZSwgcmF0aW86IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XHJcblx0XHRjb25zdCBlZGdlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGlzQ2xvY2t3aXNlID0gY29uZmlnLnJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U7XHJcblxyXG5cdFx0Y29uc3QgcG9zID0gdG9BcnJheSh0eXBlKS5tYXAodiA9PiBnZXRQb3NpdGlvbihcclxuXHRcdFx0aXNDbG9ja3dpc2UsXHJcblx0XHRcdHYsXHJcblx0XHRcdGVkZ2UsXHJcblx0XHRcdGluZGV4LFxyXG5cdFx0XHRpc0RlZmluZWQocmFuZ2UpID8gcmFuZ2UgOiAodHlwZSA9PT0gXCJ4XCIgPyB3aWR0aCA6IGhlaWdodCksXHJcblx0XHRcdGlzTnVtYmVyKHJhdGlvKSA/IHJhdGlvIDogY29uZmlnLnJhZGFyX3NpemVfcmF0aW9cclxuXHRcdCkpO1xyXG5cclxuXHRcdHJldHVybiBwb3MubGVuZ3RoID09PSAxID8gcG9zWzBdIDogcG9zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGRhdGEgcG9pbnRzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVJhZGFyUG9pbnRzKCk6IHZvaWQge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cztcclxuXHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IHBvaW50cyA9ICQkLmNhY2hlLmdldChjYWNoZUtleSkgfHwge307XHJcblx0XHRjb25zdCBzaXplID0gcG9pbnRzLl9zaXplO1xyXG5cclxuXHRcdC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9ubHkgd2hlbiB0aGUgcHJldmlvdXMgZGltZW5zaW9uIGhhcyBiZWVuIGNoYW5nZWRcclxuXHRcdGlmICghc2l6ZSB8fCAoc2l6ZS53aWR0aCAhPT0gd2lkdGggJiYgc2l6ZS5oZWlnaHQgIT09IGhlaWdodCkpIHtcclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRcdHBvaW50c1tkLmlkXSA9IGQudmFsdWVzLm1hcCgodiwgaSkgPT4gKFxyXG5cdFx0XHRcdFx0JCQuZ2V0UmFkYXJQb3NpdGlvbihbXCJ4XCIsIFwieVwiXSwgaSwgdW5kZWZpbmVkLCAkJC5nZXRSYXRpbyhcInJhZGFyXCIsIHYpKVxyXG5cdFx0XHRcdCkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHBvaW50cy5fc2l6ZSA9IHt3aWR0aCwgaGVpZ2h0fTtcclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCBwb2ludHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd1JhZGFyKGR1cmF0aW9uRm9yRXhpdDogbnVtYmVyKTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7cmFkYXIsIG1haW59ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlID0gJCQuZ2V0VHJhbnNsYXRlKFwicmFkYXJcIik7XHJcblxyXG5cdFx0Ly8gQWRqdXN0IHJhZGFyLCBjaXJjbGVzIGFuZCB0ZXh0cycgcG9zaXRpb25cclxuXHRcdGlmICh0cmFuc2xhdGUpIHtcclxuXHRcdFx0cmFkYXIuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xyXG5cdFx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlc31gKS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XHJcblx0XHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydFRleHRzfWApLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlKTtcclxuXHJcblx0XHRcdCQkLmdlbmVyYXRlUmFkYXJQb2ludHMoKTtcclxuXHRcdFx0JCQudXBkYXRlUmFkYXJMZXZlbCgpO1xyXG5cdFx0XHQkJC51cGRhdGVSYWRhckF4ZXMoKTtcclxuXHRcdFx0JCQudXBkYXRlUmFkYXJTaGFwZShkdXJhdGlvbkZvckV4aXQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0UmFkYXJQb2ludHMoKTogRnVuY3Rpb24ge1xyXG5cdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCBwb2ludCA9IHBvaW50c1tkLmlkXVtpXTtcclxuXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnQsXHJcblx0XHRcdFx0cG9pbnRcclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkYXJMZXZlbCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtyYWRhcn19ID0gJCQ7XHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IGRlcHRoID0gY29uZmlnLnJhZGFyX2xldmVsX2RlcHRoO1xyXG5cdFx0Y29uc3QgZWRnZSA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5sZW5ndGg7XHJcblx0XHRjb25zdCBzaG93VGV4dCA9IGNvbmZpZy5yYWRhcl9sZXZlbF90ZXh0X3Nob3c7XHJcblxyXG5cdFx0Y29uc3QgcmFkYXJMZXZlbHMgPSByYWRhci5sZXZlbHM7XHJcblx0XHRjb25zdCBsZXZlbERhdGEgPSBnZXRSYW5nZSgwLCBkZXB0aCk7XHJcblxyXG5cdFx0Y29uc3QgcmFkaXVzID0gY29uZmlnLnJhZGFyX3NpemVfcmF0aW8gKiBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdGNvbnN0IGxldmVsUmF0aW8gPSBsZXZlbERhdGEubWFwKGwgPT4gcmFkaXVzICogKChsICsgMSkgLyBkZXB0aCkpO1xyXG5cdFx0Y29uc3QgbGV2ZWxUZXh0Rm9ybWF0ID0gKGNvbmZpZy5yYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdCB8fCBmdW5jdGlvbigpIHt9KS5iaW5kKCQkLmFwaSk7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgcG9pbnRzXHJcblx0XHRjb25zdCBwb2ludHMgPSBsZXZlbERhdGEubWFwKHYgPT4ge1xyXG5cdFx0XHRjb25zdCByYW5nZSA9IGxldmVsUmF0aW9bdl07XHJcblx0XHRcdGNvbnN0IHBvcyA9IGdldFJhbmdlKDAsIGVkZ2UpLm1hcChpID0+IChcclxuXHRcdFx0XHQkJC5nZXRSYWRhclBvc2l0aW9uKFtcInhcIiwgXCJ5XCJdLCBpLCByYW5nZSwgMSkpLmpvaW4oXCIsXCIpXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcG9zLmpvaW4oXCIgXCIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWwgPSByYWRhckxldmVsc1xyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZXZlbH1gKVxyXG5cdFx0XHQuZGF0YShsZXZlbERhdGEpO1xyXG5cclxuXHRcdGxldmVsLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRjb25zdCBsZXZlbEVudGVyID0gbGV2ZWwuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGAke0NMQVNTLmxldmVsfSAke0NMQVNTLmxldmVsfS0ke2l9YCk7XHJcblxyXG5cdFx0bGV2ZWxFbnRlci5hcHBlbmQoXCJwb2x5Z29uXCIpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnJhZGFyX2xldmVsX3Nob3cgPyBudWxsIDogXCJoaWRkZW5cIik7XHJcblxyXG5cdFx0aWYgKHNob3dUZXh0KSB7XHJcblx0XHRcdGlmIChyYWRhckxldmVscy5zZWxlY3QoXCJ0ZXh0XCIpLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRyYWRhckxldmVsc1xyXG5cdFx0XHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi0uN2VtXCIpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxyXG5cdFx0XHRcdFx0LnRleHQoKCkgPT4gbGV2ZWxUZXh0Rm9ybWF0KDApKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV2ZWxFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJkeFwiLCBcIi0uNWVtXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcclxuXHRcdFx0XHQudGV4dChkID0+IGxldmVsVGV4dEZvcm1hdChcclxuXHRcdFx0XHRcdHN0YXRlLmN1cnJlbnQuZGF0YU1heCAvIGxldmVsRGF0YS5sZW5ndGggKiAoZCArIDEpXHJcblx0XHRcdFx0KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV2ZWxFbnRlclxyXG5cdFx0XHQubWVyZ2UobGV2ZWwpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgke3dpZHRoIC0gbGV2ZWxSYXRpb1tkXX0sICR7aGVpZ2h0IC0gbGV2ZWxSYXRpb1tkXX0pYClcclxuXHRcdFx0LnNlbGVjdEFsbChcInBvbHlnb25cIilcclxuXHRcdFx0LmF0dHIoXCJwb2ludHNcIiwgZCA9PiBwb2ludHNbZF0pO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBsZXZlbCB0ZXh0IHBvc2l0aW9uXHJcblx0XHRpZiAoc2hvd1RleHQpIHtcclxuXHRcdFx0cmFkYXJMZXZlbHMuc2VsZWN0QWxsKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCBkID0+IChpc1VuZGVmaW5lZChkKSA/IHdpZHRoIDogcG9pbnRzW2RdLnNwbGl0KFwiLFwiKVswXSkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIGQgPT4gKGlzVW5kZWZpbmVkKGQpID8gaGVpZ2h0IDogMCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGFyQXhlcygpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge3JhZGFyfX0gPSAkJDtcclxuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cdFx0Y29uc3QgY2F0ZWdvcmllcyA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcztcclxuXHJcblx0XHRsZXQgYXhpcyA9IHJhZGFyLmF4ZXMuc2VsZWN0QWxsKFwiZ1wiKVxyXG5cdFx0XHQuZGF0YShjYXRlZ29yaWVzKTtcclxuXHJcblx0XHRheGlzLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRjb25zdCBheGlzRW50ZXIgPSBheGlzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBgJHtDTEFTUy5heGlzfS0ke2l9YCk7XHJcblxyXG5cdFx0Y29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93ICYmIGF4aXNFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xyXG5cdFx0Y29uZmlnLnJhZGFyX2F4aXNfdGV4dF9zaG93ICYmIGF4aXNFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpO1xyXG5cclxuXHRcdGF4aXMgPSBheGlzRW50ZXIubWVyZ2UoYXhpcyk7XHJcblxyXG5cdFx0Ly8gYXhpcyBsaW5lXHJcblx0XHRpZiAoY29uZmlnLnJhZGFyX2F4aXNfbGluZV9zaG93KSB7XHJcblx0XHRcdGF4aXMuc2VsZWN0KFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgd2lkdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBoZWlnaHQpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAoZCwgaSkgPT4gJCQuZ2V0UmFkYXJQb3NpdGlvbihcInhcIiwgaSkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAoZCwgaSkgPT4gJCQuZ2V0UmFkYXJQb3NpdGlvbihcInlcIiwgaSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGF4aXMgdGV4dFxyXG5cdFx0aWYgKGNvbmZpZy5yYWRhcl9heGlzX3RleHRfc2hvdykge1xyXG5cdFx0XHRjb25zdCB7eCA9IDAsIHkgPSAwfSA9IGNvbmZpZy5yYWRhcl9heGlzX3RleHRfcG9zaXRpb247XHJcblxyXG5cdFx0XHRheGlzLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuNWVtXCIpXHJcblx0XHRcdFx0LmNhbGwoc2VsZWN0aW9uID0+IHtcclxuXHRcdFx0XHRcdHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0c2V0VGV4dFZhbHVlKGQzU2VsZWN0KHRoaXMpLCBTdHJpbmcoZCksIFstMC42LCAxLjJdKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LmRhdHVtKChkLCBpKSA9PiAoe2luZGV4OiBpfSkpXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHRoaXMud2lkdGgpKSB7XHJcblx0XHRcdFx0XHRcdC8vIGNhY2hlIGV2YWx1YXRlZCBheGlzIHRleHQgd2lkdGhcclxuXHRcdFx0XHRcdFx0dGhpcy53aWR0aCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyAyO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBwb3NYID0gJCQuZ2V0UmFkYXJQb3NpdGlvbihcInhcIiwgZC5pbmRleCwgdW5kZWZpbmVkLCAxKTtcclxuXHRcdFx0XHRcdGxldCBwb3NZID0gTWF0aC5yb3VuZCgkJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBkLmluZGV4LCB1bmRlZmluZWQsIDEpKTtcclxuXHJcblx0XHRcdFx0XHRpZiAocG9zWCA+IHdpZHRoKSB7XHJcblx0XHRcdFx0XHRcdHBvc1ggKz0gdGhpcy53aWR0aCArIHg7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKE1hdGgucm91bmQocG9zWCkgPCB3aWR0aCkge1xyXG5cdFx0XHRcdFx0XHRwb3NYIC09IHRoaXMud2lkdGggKyB4O1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChwb3NZID4gaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdC8vIHVwZGF0ZSB2ZXJ0aWNhbCBjZW50ZXJlZCBlZGdlIGF4aXMgdGV4dCBkeSBwb3NpdGlvblxyXG5cdFx0XHRcdFx0XHRpZiAocG9zWSAvIDIgPT09IGhlaWdodCAmJiB0aGlzLmZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gXCJ0c3BhblwiKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcImR5XCIsIFwiMGVtXCIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRwb3NZICs9IHk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHBvc1kgPCBoZWlnaHQpIHtcclxuXHRcdFx0XHRcdFx0cG9zWSAtPSB5O1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBgdHJhbnNsYXRlKCR7cG9zWH0gJHtwb3NZfSlgO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmJpbmRFdmVudCgpO1xyXG5cdH0sXHJcblxyXG5cdGJpbmRFdmVudCgpOiB2b2lkIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aW5wdXRUeXBlLCB0cmFuc2l0aW5nfSwgJGVsOiB7cmFkYXIsIHN2Z319ID0gJCQ7XHJcblx0XHRjb25zdCBmb2N1c09ubHkgPSBjb25maWcucG9pbnRfZm9jdXNfb25seTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0Y29uc3QgaXNNb3VzZSA9IGlucHV0VHlwZSA9PT0gXCJtb3VzZVwiO1xyXG5cdFx0XHRjb25zdCBnZXRJbmRleCA9ICgpID0+IHtcclxuXHRcdFx0XHRsZXQgdGFyZ2V0ID0gZDNFdmVudC50YXJnZXQ7XHJcblxyXG5cdFx0XHRcdC8vIGluIGNhc2Ugb2YgbXVsdGlsaW5lZCBheGlzIHRleHRcclxuXHRcdFx0XHRpZiAoL3RzcGFuL2kudGVzdCh0YXJnZXQudGFnTmFtZSkpIHtcclxuXHRcdFx0XHRcdHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgZDogYW55ID0gZDNTZWxlY3QodGFyZ2V0KS5kYXR1bSgpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gZCAmJiBPYmplY3Qua2V5cyhkKS5sZW5ndGggPT09IDEgPyBkLmluZGV4IDogdW5kZWZpbmVkO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRjb25zdCBoaWRlID0gKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoKTtcclxuXHRcdFx0XHRjb25zdCBub0luZGV4ID0gaXNVbmRlZmluZWQoaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRpZiAoaXNNb3VzZSB8fCBub0luZGV4KSB7XHJcblx0XHRcdFx0XHQkJC5oaWRlVG9vbHRpcCgpO1xyXG5cclxuXHRcdFx0XHRcdGZvY3VzT25seSA/XHJcblx0XHRcdFx0XHRcdCQkLmhpZGVDaXJjbGVGb2N1cygpIDpcclxuXHRcdFx0XHRcdFx0JCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGlzTW91c2UpIHtcclxuXHRcdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub0luZGV4KSB7XHJcblx0XHRcdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyYWRhci5heGVzLnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0XHQub24oaXNNb3VzZSA/IFwibW91c2VvdmVyIFwiIDogXCJ0b3VjaHN0YXJ0XCIsICgpID0+IHtcclxuXHRcdFx0XHRcdGlmICh0cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBnZXRJbmRleCgpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JTaW5nbGUoc3ZnLm5vZGUoKSwgbnVsbCwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0aXNNb3VzZSA/ICQkLnNldE92ZXJPdXQodHJ1ZSwgaW5kZXgpIDogJCQuY2FsbE92ZXJPdXRGb3JUb3VjaChpbmRleCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBpc01vdXNlID8gaGlkZSA6IG51bGwpO1xyXG5cclxuXHRcdFx0aWYgKCFpc01vdXNlKSB7XHJcblx0XHRcdFx0c3ZnLm9uKFwidG91Y2hzdGFydFwiLCBoaWRlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGFyU2hhcGUoZHVyYXRpb25Gb3JFeGl0KTogdm9pZCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzO1xyXG5cdFx0Y29uc3QgcG9pbnRzID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRjb25zdCBhcmVhcyA9ICQkLiRlbC5yYWRhci5zaGFwZXNcclxuXHRcdFx0LnNlbGVjdEFsbChcInBvbHlnb25cIilcclxuXHRcdFx0LmRhdGEodGFyZ2V0cyk7XHJcblxyXG5cdFx0Y29uc3QgYXJlYXNFbnRlciA9IGFyZWFzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQ2hhcnRSYWRhci5iaW5kKCQkKSk7XHJcblxyXG5cdFx0YXJlYXMuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0YXJlYXNFbnRlclxyXG5cdFx0XHQuYXBwZW5kKFwicG9seWdvblwiKVxyXG5cdFx0XHQubWVyZ2UoYXJlYXMpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0LmF0dHIoXCJwb2ludHNcIiwgZCA9PiBwb2ludHNbZC5pZF0uam9pbihcIiBcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhIHBvaW50IHggY29vcmRpbmF0ZVxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybnMge251bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJhZGFyQ2lyY2xlWChkKTogbnVtYmVyIHtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlLmdldChjYWNoZUtleSlbZC5pZF1bZC5pbmRleF1bMF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgcG9pbnQgeSBjb29yZGluYXRlXHJcblx0ICogQHBhcmFtIHtvYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmFkYXJDaXJjbGVZKGQpOiBudW1iZXIge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KVtkLmlkXVtkLmluZGV4XVsxXTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZCBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IENoYXJ0IGZyb20gXCIuL0NoYXJ0L0NoYXJ0XCI7XHJcbmltcG9ydCB7aXNPYmplY3QsIG1lcmdlT2JqfSBmcm9tIFwiLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXHJcbmV4cG9ydCB7YmIsIGJiIGFzIGRlZmF1bHR9O1xyXG5cclxubGV0IGRlZmF1bHRzID0ge307XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBiYlxyXG4gKiBAdmVyc2lvbiAyLjAuMC1hbHBoYVxyXG4gKi9cclxuY29uc3QgYmIgPSB7XHJcblx0LyoqXHJcblx0ICogVmVyc2lvbiBpbmZvcm1hdGlvblxyXG5cdCAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB2ZXJzaW9uIHZlcnNpb25cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAgIGJiLnZlcnNpb247ICAvLyBcIjEuMC4wXCJcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKi9cclxuXHR2ZXJzaW9uOiBcIjIuMC4wLWFscGhhXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtPcHRpb25zfSBjb25maWcgY2hhcnQgb3B0aW9uc1xyXG5cdCAqIEBtZW1iZXJvZiBiYlxyXG5cdCAqIEByZXR1cm5zIHtDaGFydH1cclxuXHQgKiBAc2VlIHtAbGluayBPcHRpb25zfSBmb3IgZGlmZmVyZW50IGdlbmVyYXRpb24gb3B0aW9uc1xyXG5cdCAqIEBzZWUge0BsaW5rIENoYXJ0fSBmb3IgZGlmZmVyZW50IG1ldGhvZHMgQVBJXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgPCEtLSBjaGFydCBob2xkZXIgLS0+XHJcblx0ICogPGRpdiBpZD1cIkxpbmVDaGFydFwiPjwvZGl2PlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogICAvLyBnZW5lcmF0ZSBjaGFydCB3aXRoIG9wdGlvbnNcclxuXHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xyXG5cdCAqICAgICAgXCJiaW5kdG9cIjogXCIjTGluZUNoYXJ0XCJcclxuXHQgKiAgICAgIFwiZGF0YVwiOiB7XHJcblx0ICogICAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgKiAgICAgICAgICAgICAgW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwLCA0MDAsIDE1MCwgMjUwXSxcclxuXHQgKiAgICAgICAgICAgICAgW1wiZGF0YTJcIiwgNTAsIDIwLCAxMCwgNDAsIDE1LCAyNV1cclxuXHQgKiAgICAgICAgICAgXVxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBjYWxsIHNvbWUgQVBJXHJcblx0ICogIC8vIGV4KSBnZXQgdGhlIGRhdGEgb2YgJ2RhdGExJ1xyXG5cdCAqICBjaGFydC5kYXRhKFwiZGF0YTFcIik7XHJcblx0ICovXHJcblx0Z2VuZXJhdGUoY29uZmlnKSB7XHJcblx0XHRjb25zdCBvcHRpb25zID0gbWVyZ2VPYmooe30sIGRlZmF1bHRzLCBjb25maWcpO1xyXG5cdFx0Y29uc3QgaW5zdCA9IG5ldyBDaGFydChvcHRpb25zKTtcclxuXHJcblx0XHRpbnN0LmludGVybmFsLmNoYXJ0cyA9IHRoaXMuaW5zdGFuY2U7XHJcblx0XHR0aGlzLmluc3RhbmNlLnB1c2goaW5zdCk7XHJcblxyXG5cdFx0cmV0dXJuIGluc3Q7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG9yIGdldCBnbG9iYWwgZGVmYXVsdCBvcHRpb25zLlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIFRoZSBvcHRpb25zIHZhbHVlcyBzZXR0aW5ncyBhcmUgdmFsaWQgd2l0aGluIHBhZ2UgY29udGV4dCBvbmx5LlxyXG5cdCAqICAgLSBJZiBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHdpbGwgb3ZlcnJpZGUgdGhlIGxhc3QgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKiBAcmV0dXJucyB7T3B0aW9uc31cclxuXHQgKiBAc2VlIHtAbGluayBPcHRpb25zfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gU2V0IHNhbWUgb3B0aW9uIHZhbHVlIGFzIGZvciBgLmdlbmVyYXRlKClgXHJcblx0ICogYmIuZGVmYXVsdHMoe1xyXG5cdCAqICAgZGF0YToge1xyXG5cdCAqICAgICB0eXBlOiBcImJhclwiXHJcblx0ICogICB9XHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiBiYi5kZWZhdWx0cygpOyAgLy8ge2RhdGE6e3R5cGU6IFwiYmFyXCJ9fVxyXG5cdCAqXHJcblx0ICogLy8gZGF0YS50eXBlIGRlZmF1bHRzIHRvICdiYXInXHJcblx0ICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XHJcblx0ICovXHJcblx0ZGVmYXVsdHMob3B0aW9ucz8pIHtcclxuXHRcdGlmIChpc09iamVjdChvcHRpb25zKSkge1xyXG5cdFx0XHRkZWZhdWx0cyA9IG9wdGlvbnM7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRlZmF1bHRzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaW5zdGFuY2UgY3JlYXRlZFxyXG5cdCAqIEBwcm9wZXJ0eSB7QXJyYXl9IGluc3RhbmNlIGluc3RhbmNlIGFycmF5XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gZ2VuZXJhdGUgY2hhcnRzXHJcblx0ICogIHZhciBjaGFydDEgPSBiYi5nZW5lcmF0ZSguLi4pO1xyXG5cdCAqICB2YXIgY2hhcnQyID0gYmIuZ2VuZXJhdGUoLi4uKTtcclxuXHQgKlxyXG5cdCAqICBiYi5pbnN0YW5jZTsgIC8vIFsgY2hhcnQxLCBjaGFydDIsIC4uLiBdXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICovXHJcblx0aW5zdGFuY2U6IFtdLFxyXG5cclxuXHQvKipcclxuXHQgKiBOYW1lc3BhY2UgZm9yIHBsdWdpbnNcclxuXHQgKiBAcHJvcGVydHkge29iamVjdH0gcGx1Z2luIHBsdWdpbiBuYW1lc3BhY2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBTdGFuZm9yZCBkaWFncmFtIHBsdWdpblxyXG5cdCAqICBiYi5wbHVnaW4uc3RhbmZvcmQ7XHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICovXHJcblx0cGx1Z2luOiB7fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcblxyXG5pbXBvcnQgQ2hhcnQgZnJvbSBcIi4vQ2hhcnQvQ2hhcnRcIjtcclxuaW1wb3J0IENoYXJ0SW50ZXJuYWwgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbC9DaGFydEludGVybmFsXCI7XHJcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gQXhpc1xyXG5pbXBvcnQge1xyXG5cdGFwaSBhcyBhcGlBeGlzLFxyXG5cdGludGVybmFsIGFzIGludGVybmFsQXhpc1xyXG59IGZyb20gXCIuL2NvbmZpZy9yZXNvbHZlci9heGlzXCI7XHJcblxyXG4vLyBTaGFwZVxyXG5pbXBvcnQgc2hhcGVBcmMgZnJvbSBcIi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9hcmNcIjtcclxuaW1wb3J0IHNoYXBlQXJlYSBmcm9tIFwiLi9DaGFydEludGVybmFsL3NoYXBlL2FyZWFcIjtcclxuaW1wb3J0IHNoYXBlQmFyIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYmFyXCI7XHJcbmltcG9ydCBzaGFwZUJ1YmJsZSBmcm9tIFwiLi9DaGFydEludGVybmFsL3NoYXBlL2J1YmJsZVwiO1xyXG5pbXBvcnQgc2hhcGVMaW5lIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWwvc2hhcGUvbGluZVwiO1xyXG5pbXBvcnQgc2hhcGVQb2ludCBmcm9tIFwiLi9DaGFydEludGVybmFsL3NoYXBlL3BvaW50XCI7XHJcbmltcG9ydCBzaGFwZVJhZGFyIGZyb20gXCIuL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcmFkYXJcIjtcclxuXHJcbmV4cG9ydCB7ZGVmYXVsdCwgYmJ9IGZyb20gXCIuL2NvcmVcIjtcclxuXHJcbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwgW1xyXG5cdC4uLmludGVybmFsQXhpcyxcclxuXHRzaGFwZUFyYyxcclxuXHRzaGFwZUFyZWEsXHJcblx0c2hhcGVCYXIsXHJcblx0c2hhcGVCdWJibGUsXHJcblx0c2hhcGVMaW5lLFxyXG5cdHNoYXBlUG9pbnQsXHJcblx0c2hhcGVSYWRhclxyXG5dKTtcclxuXHJcbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIGFwaUF4aXMpO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9