(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-zoom"), require("d3-ease"), require("d3-color"), require("d3-shape"), require("d3-interpolate"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-transition", "d3-brush", "d3-axis", "d3-scale", "d3-dsv", "d3-drag", "d3-zoom", "d3-ease", "d3-color", "d3-shape", "d3-interpolate"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-drag"), require("d3-zoom"), require("d3-ease"), require("d3-color"), require("d3-shape"), require("d3-interpolate")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__36__, __WEBPACK_EXTERNAL_MODULE__37__, __WEBPACK_EXTERNAL_MODULE__38__, __WEBPACK_EXTERNAL_MODULE__39__, __WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__41__, __WEBPACK_EXTERNAL_MODULE__42__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__45__, __WEBPACK_EXTERNAL_MODULE__46__, __WEBPACK_EXTERNAL_MODULE__47__, __WEBPACK_EXTERNAL_MODULE__48__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(32);
module.exports = __webpack_require__(49);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(3);

var socket = __webpack_require__(5);

var overlay = __webpack_require__(9);

var _require = __webpack_require__(15),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(17);

var reloadApp = __webpack_require__(18);

var createSocketUrl = __webpack_require__(21);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(30);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost:8080"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(4)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(6);
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(7);

var BaseClient = __webpack_require__(8);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(6);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* sockjs-client v1.4.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.4.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(10);

var _require = __webpack_require__(11),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(12),
  Html4Entities: __webpack_require__(13),
  Html5Entities: __webpack_require__(14),
  AllHtmlEntities: __webpack_require__(14)
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(16).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(15),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(19);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(20);
module.exports = new EventEmitter();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(22);

var getCurrentScriptSource = __webpack_require__(29);

function createSocketUrl(resourceQuery, currentLocation) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL
    .substr(1) // replace first `&` with `?` to have a valid query string
    .replace('&', '?'), true);
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();
    urlParts = url.parse(scriptHost || '/', true, true);
  } // Use parameter to allow passing location in unit tests


  if (typeof currentLocation === 'string' && currentLocation !== '') {
    currentLocation = url.parse(currentLocation);
  } else {
    currentLocation = self.location;
  }

  return getSocketUrl(urlParts, currentLocation);
}
/*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */


function getSocketUrl(urlParts, loc) {
  var auth = urlParts.auth,
      query = urlParts.query;
  var hostname = urlParts.hostname,
      protocol = urlParts.protocol,
      port = urlParts.port;

  if (!port || port === '0') {
    port = loc.port;
  } // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384


  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {
    hostname = loc.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = loc.protocol;
  } // all of these sock url params are optionally passed in through
  // resourceQuery, so we need to fall back to the default if
  // they are not provided


  var sockHost = query.sockHost || hostname;
  var sockPath = query.sockPath || '/sockjs-node';
  var sockPort = query.sockPort || port;

  if (sockPort === 'location') {
    sockPort = loc.port;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(23);
var util = __webpack_require__(25);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(26);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)(module)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(27);
exports.encode = exports.stringify = __webpack_require__(28);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 31
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 30;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(33);
            var content = __webpack_require__(34);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(35);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px sans-serif;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc rect {\n  stroke: #fff;\n  stroke-width: 1; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused {\n  opacity: 0.3 !important; }\n  .bb-target.bb-defocused .text-overlapping {\n    opacity: .05 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px sans-serif; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10;\n  user-select: none; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: #fff; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__36__;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__37__;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__38__;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__39__;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__41__;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__42__;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__46__;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__48__;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(36);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(37);

// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(38);

// CONCATENATED MODULE: ./src/config/classes.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcLabelLine: "bb-arc-label-line",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridFocus: "bb-ygrid-focus",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_",
  TextOverlapping: "text-overlapping"
});
// CONCATENATED MODULE: ./src/config/Store.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var Store_state = function () {
  return {
    width: 0,
    width2: 0,
    height: 0,
    height2: 0,
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin2: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin3: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    arcWidth: 0,
    arcHeight: 0,
    currentWidth: 0,
    currentHeight: 0,
    // legend
    isLegendRight: !1,
    isLegendInset: !1,
    isLegendTop: !1,
    isLegendLeft: !1,
    legendStep: 0,
    legendItemWidth: 0,
    legendItemHeight: 0,
    legendHasRendered: !1,
    currentMaxTickWidths: {
      x: {
        size: 0,
        domain: ""
      },
      y: {
        size: 0,
        domain: ""
      },
      y2: {
        size: 0,
        domain: ""
      }
    },
    rotatedPadding: {
      left: 30,
      right: 0,
      top: 5
    },
    withoutFadeIn: {},
    inputType: "",
    datetimeId: "",
    // clip id string
    clip: {
      id: "",
      idXAxis: "",
      idYAxis: "",
      idGrid: "",
      idSubchart: "",
      // clipIdForSubchart
      path: "",
      pathXAxis: "",
      pathYAxis: "",
      pathGrid: ""
    },
    // status
    dragStart: null,
    dragging: !1,
    flowing: !1,
    cancelClick: !1,
    mouseover: !1,
    rendered: !1,
    transiting: !1,
    hasNegativeValue: !1,
    hasPositiveValue: !0,
    orgAreaOpacity: "0.2",
    // ID strings
    hiddenTargetIds: [],
    hiddenLegendIds: [],
    focusedTargetIds: [],
    defocusedTargetIds: [],
    // value for Arc
    radius: 0,
    innerRadius: 0,
    innerRadiusRatio: 0,
    gaugeArcWidth: 0,
    radiusExpanded: 0,
    // xgrid attribute
    xgridAttr: {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }
  };
};


// CONCATENATED MODULE: ./src/config/Options/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data config options
 */
/* harmony default export */ var data_data = ({
  /**
   * Converts data id value
   * @name data․idConverter
   * @memberof Options
   * @type {Function}
   * @default function(id) { return id; }
   * @example
   * data: {
   *    idConverter: function(id) {
   *       // when id is 'data1', converts to be 'data2'
   *       // 'data2' should be given as the initial data value
   *       if (id === "data1") {
   *          return "data2";
   *       } else {
   *          return id;
   *       }
   *    }
   * }
   */
  data_idConverter: function data_idConverter(id) {
    return id;
  },

  /**
   * Set custom data name.
   * @name data․names
   * @memberof Options
   * @type {Object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
   * @example
   * data: {
   *   names: {
   *     data1: "Data Name 1",
   *     data2: "Data Name 2"
   *   }
   * }
   */
  data_names: {},

  /**
   * Set custom data class.<br><br>
   * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
   * @name data․classes
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   classes: {
   *     data1: "additional-data1-class",
   *     data2: "additional-data2-class"
   *   }
   * }
   */
  data_classes: {},

  /**
   * Set chart type at once.<br><br>
   * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
   * **Available Values:**
   * - area
   * - area-line-range
   * - area-spline
   * - area-spline-range
   * - area-step
   * - bar
   * - bubble
   * - donut
   * - gauge
   * - line
   * - pie
   * - radar
   * - scatter
   * - spline
   * - step
   * @name data․type
   * @memberof Options
   * @type {String}
   * @default line
   * @example
   * data: {
   *    type: "bar"
   * }
   */
  data_type: undefined,

  /**
   * Set chart type for each data.<br>
   * This setting overwrites data.type setting.
   * - **NOTE:** `radar` type can't be combined with other types.
   * @name data․types
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   types: {
   *     data1: "bar",
   *     data2: "spline"
   *   }
   * }
   */
  data_types: {},

  /**
   *  This option changes the order of stacking data and pieces of pie/donut.
   *  - If `null` specified, it will be the order the data loaded.
   *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
   *
   *  **Available Values:**
   *  - `desc`: In descending order
   *  - `asc`: In ascending order
   *  - `null`: It keeps the data load order
   *  - `function(data1, data2) { ... }`: Array.sort compareFunction
   * @name data․order
   * @memberof Options
   * @type {String|Function|null}
   * @default desc
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
   * @example
   * data: {
   *   // in descending order (default)
   *   order: "desc"
   *
   *   // in ascending order
   *   order: "asc"
   *
   *   // keeps data input order
   *   order: null
   *
   *   // specifying sort function
   *   order: function(a, b) {
   *       // param data passed format
   *       {
   *          id: "data1", id_org: "data1", values: [
   *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
   *              ...
   *          ]
   *       }
   *   }
   * }
   */
  data_order: "desc",

  /**
   * Set color converter function.<br><br>
   * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
   * @name data․color
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
   * @example
   * data: {
   *   color: function(color, d) { ... }
   * }
   */
  data_color: undefined,

  /**
   * Set color for each data.
   * @name data․colors
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   colors: {
   *     data1: "#ff0000",
   *     data2: function(d) {
   *        return "#000";
   *     }
   *     ...
   *   }
   * }
   */
  data_colors: {},

  /**
   * Hide each data when the chart appears.<br><br>
   * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
   * @name data․hide
   * @memberof Options
   * @type {Boolean|Array}
   * @default false
   * @example
   * data: {
   *   // all of data will be hidden
   *   hide: true
   *
   *   // specified data will be hidden
   *   hide: ["data1", ...]
   * }
   */
  data_hide: !1,

  /**
   * Filter values to be shown
   * The data value is the same as the returned by `.data()`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
   * @name data․filter
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * data: {
   *   // filter for id value
   *   filter: function(v) {
   *      // v: [{id: "data1", id_org: "data1", values: [
   *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
   *      //    }, ...]
   *      return v.id !== "data1";
   *   }
   */
  data_filter: undefined,

  /**
   * Set a callback for click event on each data point.<br><br>
   * This callback will be called when each data point clicked and will receive `d` and element as the arguments.
   * - `d` is the data clicked and element is the element clicked.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onclick
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onclick: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onclick: function data_onclick() {},

  /**
   * Set a callback for mouse/touch over event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.
   * - `d` is the data where mouse cursor moves onto.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onover
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onover: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onover: function data_onover() {},

  /**
   * Set a callback for mouse/touch out event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.
   * - `d` is the data where mouse cursor moves out.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onout
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onout: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onout: function data_onout() {},

  /**
  * Set a callback for minimum data
  * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
  * @name data․onmin
  * @memberof Options
  * @type {Function}
  * @default undefined
  * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
  * @example
  *  onmin: function(data) {
  *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
  *    ...
  *  }
  */
  data_onmin: undefined,

  /**
   * Set a callback for maximum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmax
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmax: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmax: undefined,

  /**
   * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
   * @name data․url
   * @memberof Options
   * @type {String}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
   * @example
   * data: {
   *     url: "/data/test.csv"
   * }
   */
  data_url: undefined,

  /**
   * XHR header value
   * - **NOTE:** Should be used with `data.url` option
   * @name data․headers
   * @memberof Options
   * @type {String}
   * @default undefined
   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
   * @example
   * data: {
   *     url: "/data/test.csv",
   *     headers: {
   *        "Content-Type": "text/xml",
   *        ...
   *     }
   * }
   */
  data_headers: undefined,

  /**
   * Parse a JSON object for data. See also data.keys.
   * @name data․json
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [data․keys](#.data%25E2%2580%25A4keys)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_json: undefined,

  /**
   * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
   * @name data․rows
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
   * @example
   * data: {
   *   rows: [
   *     ["A", "B", "C"],
   *     [90, 120, 300],
   *     [40, 160, 240],
   *     [50, 200, 290],
   *     [120, 160, 230],
   *     [80, 130, 300],
   *     [90, 220, 320]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {high:150, mid: 140, low: 110}, 120
   *        [150, 140, 110], 120
   *      ],
   *      [[155, 130, 115], 55],
   *      [[160, 135, 120], 60]
   *   ],
   *   types: {
   *       data1: "area-line-range",
   *       data2: "line"
   *   }
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {y:10, z: 140}, 120
   *        [10, 140], 120
   *      ],
   *      [[100, 30], 55],
   *      [[50, 100], 60]
   *   ],
   *   types: {
   *       data1: "bubble",
   *       data2: "line"
   *   }
   * }
   */
  data_rows: undefined,

  /**
   * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
   * @name data․columns
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
   * @example
   * data: {
   *   columns: [
   *      ["data1", 30, 20, 50, 40, 60, 50],
   *      ["data2", 200, 130, 90, 240, 130, 220],
   *      ["data3", 300, 200, 160, 400, 250, 250]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   columns: [
   *      ["data1",
   *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
   *          [150, 140, 110],
   *          [150, 140, 110]
   *      ]
   *   ],
   *   type: "area-line-range"
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   columns: [
   *      ["data1",
   *          [10, 140],  // or {y:10, z: 140}
   *          [100, 30],
   *          [50, 100]
   *      ]
   *   ],
   *   type: "bubble"
   * }
   */
  data_columns: undefined,

  /**
   * Used if loading JSON via data.url.
   * - **Available Values:**
   *   - json
   *   - csv
   *   - tsv
   * @name data․mimeType
   * @memberof Options
   * @type {String}
   * @default csv
   * @example
   * data: {
   *     mimeType: "json"
   * }
   */
  data_mimeType: "csv",

  /**
   * Choose which JSON object keys correspond to desired data.
   * - **NOTE:** Only for JSON object given as array.
   * @name data․keys
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_keys: undefined,

  /**
   * Set text label to be displayed when there's no data to show.
   * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
   * @name data․empty․label․text
   * @memberof Options
   * @type {String}
   * @default ""
   * @example
   * data: {
   *   empty: {
   *     label: {
   *       text: "No Data"
   *     }
   *   }
   * }
   */
  data_empty_label_text: ""
});
// CONCATENATED MODULE: ./src/config/Options/common/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * color config options
 */
/* harmony default export */ var common_color = ({
  /**
   * Set color of the data values
   * @name color
   * @memberof Options
   * @type {Object}
   * @property {String|Object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
   * @property {Array} [color.pattern=[]] custom color pattern
   * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
   *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
   *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
   *    - `bb-colorize-pattern-red`
   *    - `bb-colorize-pattern-fff`
   * @property {Object} [color.threshold] color threshold for gauge and tooltip color
   * @property {String} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
   * @property {Array} [color.threshold.values] Threshold values for each steps
   * @property {Number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
   * @example
   *  color: {
   *      pattern: ["#1f77b4", "#aec7e8", ...],
   *
   *      // Set colors' patterns
   *      // it should return an array of SVGPatternElement
   *      tiles: function() {
   *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
   *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
   *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
   *
   *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
   *         pattern.setAttribute("width", "32");
   *         pattern.setAttribute("height", "32");
   *
   *         g.style.fill = "#000";
   *         g.style.opacity = "0.2";
   *
   *         circle1.setAttribute("cx", "3");
   *         circle1.setAttribute("cy", "3");
   *         circle1.setAttribute("r", "3");
   *
   *         g.appendChild(circle1);
   *         pattern.appendChild(g);
   *
   *         return [pattern];
   *      },
   *
   *      // for threshold usage, pattern values should be set for each steps
   *      pattern: ["grey", "green", "yellow", "orange", "red"],
   *      threshold: {
   *          unit: "value",
   *
   *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
   *          values: [10, 20, 30, 40, 50],
   *
   *          // the equation for max:
   *          // - unit == 'value': max => 30
   *          // - unit != 'value': max => value*100/30
   *          max: 30
   *      },
   *
   *      // set all data to 'red'
   *      onover: "red",
   *
   *      // set different color for data
   *      onover: {
   *          data1: "red",
   *          data2: "yellow"
   *      },
   *
   *      // will pass data object to the callback
   *      onover: function(d) {
   *          return d.id === "data1" ? "red" : "green";
   *      }
   *  }
   */
  color_pattern: [],
  color_tiles: undefined,
  color_threshold: {},
  color_onover: undefined
});
// CONCATENATED MODULE: ./src/config/Options/common/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * interaction config options
 */
/* harmony default export */ var interaction = ({
  /**
   * Interaction options
   * @name interaction
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
   *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
   * @property {Boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
   * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
   * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
   * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
   * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
   * @example
   * interaction: {
   *    enabled: false,
   *    brighten: false,
   *    inputType: {
   *        mouse: true,
   *        touch: false
   *
   *        // or declare preventDefault explicitly.
   *        // In this case touch inputType is enabled by default
   *        touch: {
   *            preventDefault: true
   *
   *            // or threshold pixel value (pixel moved from touchstart to touchmove)
   *            preventDefault: 5
   *        }
   *    }
   * }
   */
  interaction_enabled: !0,
  interaction_brighten: !0,
  interaction_inputType_mouse: !0,
  interaction_inputType_touch: {}
});
// CONCATENATED MODULE: ./src/config/Options/common/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * legend config options
 */
/* harmony default export */ var common_legend = ({
  /**
   * Legend options
   * @name legend
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [legend.show=true] Show or hide legend.
   * @property {Boolean} [legend.hide=false] Hide legend
   *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
   * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
   * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
   *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
   *    - {=COLOR}: data color value
   *    - {=TITLE}: data title value
   *  - If set `function` value, will pass following arguments to the given function:
   *   - title {String}: data's id value
   *   - color {String}: color string
   *   - data {Array}: data array
   * @property {String} [legend.position=bottom] Change the position of legend.<br>
   *  Available values are: `bottom`, `right` and `inset` are supported.
   * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
   *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
   *  - **anchor** decides the position of the legend:
   *   - top-left
   *   - top-right
   *   - bottom-left
   *   - bottom-right
   *  - **x** and **y**:
   *   - set the position of the legend based on the anchor.
   *  - **step**:
   *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
   * @property {Boolean} [legend.equally=false] Set to all items have same width size.
   * @property {Boolean} [legend.padding=0] Set padding value
   * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
   * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
   * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
   * @property {Number} [legend.item.tile.width=10] Set width of item tile element
   * @property {Number} [legend.item.tile.height=10] Set height of item tile element
   * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
   * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
   * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
   * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
   * @example
   *  legend: {
   *      show: true,
   *      hide: true,
   *      //or hide: "data1"
   *      //or hide: ["data1", "data2"]
   *      contents: {
   *          bindto: "#legend",   // <ul id='legend'></ul>
   *
   *          // will be as: <li style='background-color:#1f77b4'>data1</li>
   *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
   *
   *          // or using function
   *          template: function(id, color, data) {
   *               // if you want omit some legend, return falsy value
   *               if (title !== "data1") {
   *                    return "<li style='background-color:"+ color +">"+ title +"</li>";
   *               }
   *          }
   *      },
   *      position: "bottom",  // bottom, right, inset
   *      inset: {
   *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
   *          x: 20,
   *          y: 10,
   *          step: 2
   *      },
   *      equally: false,
   *      padding: 10,
   *      item: {
   *          onclick: function(id) { ... },
   *          onover: function(id) { ... },
   *          onout: function(id) { ... },
   *
   *          // set tile's size
   *          tile: {
   *              width: 20,
   *              height: 15
   *          }
   *      },
   *      usePoint: true
   *  }
   */
  legend_show: !0,
  legend_hide: !1,
  legend_contents_bindto: undefined,
  legend_contents_template: undefined,
  legend_position: "bottom",
  legend_inset_anchor: "top-left",
  legend_inset_x: 10,
  legend_inset_y: 0,
  legend_inset_step: undefined,
  legend_item_onclick: undefined,
  legend_item_onover: undefined,
  legend_item_onout: undefined,
  legend_equally: !1,
  legend_padding: 0,
  legend_item_tile_width: 10,
  legend_item_tile_height: 10,
  legend_usePoint: !1
});
// CONCATENATED MODULE: ./src/config/Options/common/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * title config options
 */
/* harmony default export */ var common_title = ({
  /**
   * Set title options
   * @name title
   * @memberof Options
   * @type {Object}
   * @property {String} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
   * @property {Number} [title.padding.top=0] Top padding value.
   * @property {Number} [title.padding.right=0] Right padding value.
   * @property {Number} [title.padding.bottom=0] Bottom padding value.
   * @property {Number} [title.padding.left=0] Left padding value.
   * @property {String} [title.position=center] Available values are: 'center', 'right' and 'left'.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
   * @example
   *  title: {
   *      text: "Title Text",
   *
   *      // or Multiline title text
   *      text: "Main title text\nSub title text",
   *
   *      padding: {
   *          top: 10,
   *          right: 10,
   *          bottom: 10,
   *          left: 10
   *      },
   *      position: "center"
   *  }
   */
  title_text: undefined,
  title_padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  title_position: "center"
});
// CONCATENATED MODULE: ./src/config/Options/common/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * tooltip config options
 */
/* harmony default export */ var common_tooltip = ({
  /**
   * Tooltip options
   * @name tooltip
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [tooltip.show=true] Show or hide tooltip.
   * @property {Boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
   * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
   *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
   * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
   * @property {String} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
   * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
   *  Specified function receives x of the data point to show.
   * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   *  If undefined returned, the row of that value will be skipped.
   * @property {Function} [tooltip.position] Set custom position for the tooltip.<br>
   *  This option can be used to modify the tooltip position by returning object that has top and left.
   * @property {Function|Object} [tooltip.contents] Set custom HTML for the tooltip.<br>
   *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
   * @property {String|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
   *  - **NOTE:** When is specified, will not be updating tooltip's position.
   * @property {String} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
   *  Within template, below syntax will be replaced using template-like syntax string:
   *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
   *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
   *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
   *    - **{=TITLE}**: title value.
   *    - **{=COLOR}**: data color.
   *    - **{=VALUE}**: data value.
   * @property {Object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
   *  - **NOTE:** It should contain `{ key: Array, ... }` value
   *    - 'key' name is used as substitution within template as '{=KEY}'
   *    - The value array length should match with the data length
   * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
   * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
   * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
   * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
   * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
   * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
   * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
   * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
   *  **Available Values:**
   *  - `desc`: In descending data value order
   *  - `asc`: In ascending data value order
   *  - `null`: It keeps the data display order<br>
   *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
   *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
   *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
   * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
   * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
   * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
   * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
   * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
   * @example
   *  tooltip: {
   *      show: true,
   *      doNotHide: true,
   *      grouped: false,
   *      format: {
   *          title: function(x) { return "Data " + x; },
   *          name: function(name, ratio, id, index) { return name; },
   *          value: function(value, ratio, id, index) { return ratio; }
   *      },
   *      position: function(data, width, height, element) {
   *          return {top: 0, left: 0}
   *      },
   *
   *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
   *          return ... // formatted html as you want
   *      },
   *
   *       // specify tooltip contents using template
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
   *      		'}}</ul>'
   *      }
   *
   *       // with additional text value
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	text: {
   *      		// a) 'key' name is used as substitution within template as '{=KEY}'
   *      		// b) the length should match with the data length
   *      		VAR1: ["text1", "text2"],
   *      		VAR2: ["comment1", "comment2"],
   *      	},
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
   *      		'}}</ul>'
   *      }
   *
   *      // sort tooltip data value display in ascending order
   *      order: "asc",
   *
   *      // specifying sort function
   *      order: function(a, b) {
   *         // param data passed format
   *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
   *           ...
   *      },
   *
   *      // show at the initialization
   *      init: {
   *          show: true,
   *          x: 2,
   *          position: {
   *              top: "150px",
   *              left: "250px"
   *          }
   *      },
   *
   *      // fires prior tooltip is shown
   *      onshow: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires prior tooltip is hidden
   *      onhide: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is shown
   *      onshown: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is hidden
   *      onhidden: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
   *      // Useful for timeseries correlation
   *      linked: true,
   *
   *      // Specify name to interact those with the same name only.
   *      linked: {
   *          name: "some-group"
   *      }
   *  }
   */
  tooltip_show: !0,
  tooltip_doNotHide: !1,
  tooltip_grouped: !0,
  tooltip_format_title: undefined,
  tooltip_format_name: undefined,
  tooltip_format_value: undefined,
  tooltip_position: undefined,
  tooltip_contents: {},
  tooltip_init_show: !1,
  tooltip_init_x: 0,
  tooltip_init_position: {
    top: "0px",
    left: "50px"
  },
  tooltip_linked: !1,
  tooltip_linked_name: "",
  tooltip_onshow: function tooltip_onshow() {},
  tooltip_onhide: function tooltip_onhide() {},
  tooltip_onshown: function tooltip_onshown() {},
  tooltip_onhidden: function tooltip_onhidden() {},
  tooltip_order: null
});
// CONCATENATED MODULE: ./src/config/Options/data/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Axis based chart data config options
 */
/* harmony default export */ var data_axis = ({
  /**
   * Specify the key of x values in the data.<br><br>
   * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
   * @name data․x
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * data: {
   *   x: "date"
   * }
   */
  data_x: undefined,

  /**
   * Specify the keys of the x values for each data.<br><br>
   * This option can be used if we want to show the data that has different x values.
   * @name data․xs
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   xs: {
   *      data1: "x1",
   *      data2: "x2"
   *   }
   * }
   */
  data_xs: {},

  /**
   * Set a format specifier to parse string specifed as x.
   * @name data․xFormat
   * @memberof Options
   * @type {String}
   * @default %Y-%m-%d
   * @example
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "01012019", "02012019", "03012019"],
   *        ["data1", 30, 200, 100]
   *    ],
   *    // Format specifier to parse as datetime for given 'x' string value
   *    xFormat: "%m%d%Y"
   * },
   * axis: {
   *    x: {
   *        type: "timeseries"
   *    }
   * }
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   */
  data_xFormat: "%Y-%m-%d",

  /**
   * Set localtime format to parse x axis.
   * @name data․xLocaltime
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *   xLocaltime: false
   * }
   */
  data_xLocaltime: !0,

  /**
   * Sort on x axis.
   * @name data․xSort
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *   xSort: false
   * }
   */
  data_xSort: !0,

  /**
   * Set groups for the data for stacking.
   * @name data․groups
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * data: {
   *   groups: [
   *     ["data1", "data2"],
   *     ["data3"]
   *   ]
   * }
   */
  data_groups: [],

  /**
   * Set y axis the data related to. y and y2 can be used.
  * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @name data․axes
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   axes: {
   *     data1: "y",
   *     data2: "y2"
   *   }
   * }
   */
  data_axes: {},

  /**
   * Set labels options
   * @name data․labels
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [data.labels=false] Show or hide labels on each data points
   * @property {Boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
   * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
   * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
   *  - `v` is the value of the data point where the label is shown.
   *  - `id` is the id of the data where the label is shown.
   *  - `i` is the index of the data point where the label is shown.
   *  - `j` is the sub index of the data point where the label is shown.<br><br>
   * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
   * @property {String|Object} [data.labels.colors] Set label text colors.
   * @property {Object} [data.labels.position] Set each dataset position, relative the original.
   * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
   * @property {Number} [data.labels.position.y=0] y coordinate position, relative the original.
   * @memberof Options
   * @type {Object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
   * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
   * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
   * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
   * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
   * @example
   * data: {
   *   labels: true,
   *
   *   // or set specific options
   *   labels: {
   *     format: function(v, id, i, j) { ... },
   *
   *     // it's possible to set for each data
   *     format: {
   *         data1: function(v, id, i, j) { ... },
   *         ...
   *     },
   *
   *     // align text to center of the 'bar' shape (works only for 'bar' type)
   *     centered: true,
   *
   *     // apply for all label texts
   *     colors: "red",
   *
   *     // or set different colors per dataset
   *     // for not specified dataset, will have the default color value
   *     colors: {
   *        data1: "yellow",
   *        data3: "green"
   *     },
   *
   *     // set x, y coordinate position
   *     position: {
   *        x: -10,
   *        y: 10
   *     },
   *
   *     // or set x, y coordinate position by each dataset
   *     position: {
   *        data1: {x: 5, y: 5},
   *        data2: {x: 10, y: -20}
   *     }
   *   }
   * }
   */
  data_labels: {},
  data_labels_colors: undefined,
  data_labels_position: {},

  /**
   * Define regions for each data.<br>
   * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
   * - The object type should be as:
   *   - start {Number}: Start data point number. If not set, the start will be the first data point.
   *   - [end] {Number}: End data point number. If not set, the end will be the last data point.
   *   - [style.dasharray="2 2"] {Object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
   * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
   * @name data․regions
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   regions: {
   *     data1: [{
   *         start: 1,
   *         end: 2,
   *         style: {
   *             dasharray: "5 2"
   *         }
   *     }, {
   *         start: 3
   *     }],
   *     ...
   *   }
   * }
   */
  data_regions: {},

  /**
   * Set the stacking to be normalized
   * - **NOTE:**
   *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
   *   - y Axis will be set in percentage value (0 ~ 100%)
   *   - Must have postive values
   * @name data․stack․normalize
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
   * @example
   * data: {
   *   stack: {
   *      normalize: true
   *   }
   * }
   */
  data_stack_normalize: !1
});
// CONCATENATED MODULE: ./src/config/Options/data/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data.selection config options
 */
/* harmony default export */ var data_selection = ({
  /**
   * Set data selection enabled<br><br>
   * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
   * @name data․selection․enabled
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
   * @example
   * data: {
   *    selection: {
   *       enabled: true
   *    }
   * }
   */
  data_selection_enabled: !1,

  /**
   * Set grouped selection enabled.<br><br>
   * If this option set true, multiple data points that have same x value will be selected by one selection.
   * @name data․selection․grouped
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       grouped: true
   *    }
   * }
   */
  data_selection_grouped: !1,

  /**
   * Set a callback for each data point to determine if it's selectable or not.<br><br>
   * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
   * @name data․selection․isselectable
   * @memberof Options
   * @type {Function}
   * @default function() { return true; }
   * @example
   * data: {
   *    selection: {
   *       isselectable: function(d) { ... }
   *    }
   * }
   */
  data_selection_isselectable: function data_selection_isselectable() {
    return !0;
  },

  /**
   * Set multiple data points selection enabled.<br><br>
   * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
   * @name data․selection․multiple
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *    selection: {
   *       multiple: false
   *    }
   * }
   */
  data_selection_multiple: !0,

  /**
   * Enable to select data points by dragging.
   * If this option set true, data points can be selected by dragging.
   * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
   * @name data․selection․draggable
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       draggable: true
   *   }
   * }
   */
  data_selection_draggable: !1,

  /**
   * Set a callback for on data selection.
   * @name data․onselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onselected: function data_onselected() {},

  /**
   * Set a callback for on data un-selection.
   * @name data․onunselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onunselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onunselected: function data_onunselected() {}
});
// CONCATENATED MODULE: ./src/config/Options/axis/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var axis_x = ({
  /**
   * Set clip-path attribute for x axis element
   * @name axis․x․clipPath
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo]()
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_x_clipPath: !0,

  /**
   * Show or hide x axis.
   * @name axis․x․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     show: false
   *   }
   * }
   */
  axis_x_show: !0,

  /**
   * Set type of x axis.<br><br>
   * **Available Values:**
   * - timeseries
   * - category
   * - indexed
   * @name axis․x․type
   * @memberof Options
   * @type {String}
   * @default indexed
   * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
   * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
   * @example
   * axis: {
   *   x: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_x_type: "indexed",

  /**
   * Set how to treat the timezone of x values.<br>
   * If true, treat x value as localtime. If false, convert to UTC internally.
   * @name axis․x․localtime
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     localtime: false
   *   }
   * }
   */
  axis_x_localtime: !0,

  /**
   * Set category names on category axis.
   * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @name axis․x․categories
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * axis: {
   *   x: {
   *     categories: ["Category 1", "Category 2", ...]
   *   }
   * }
   */
  axis_x_categories: [],

  /**
   * centerize ticks on category axis.
   * @name axis․x․tick․centered
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       centered: true
   *     }
   *   }
   * }
   */
  axis_x_tick_centered: !1,

  /**
   * A function to format tick value. Format string is also available for timeseries data.
   * @name axis․x․tick․format
   * @memberof Options
   * @type {Function|String}
   * @default undefined
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *        // for timeseries, a 'datetime' object is given as parameter
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *
   *       // for category, index(Number) and categoryName(String) are given as parameter
   *       format: function(index, categoryName) {
   *           return categoryName.substr(0, 10);
   *       },
   *
   *        // for timeseries format specifier
   *        format: "%Y-%m-%d %H:%M:%S"
   *     }
   *   }
   * }
   */
  axis_x_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.x.tick.culling.max.
   * @name axis․x․tick․culling
   * @memberof Options
   * @type {Boolean}
   * @default
   * - true for indexed axis and timeseries axis
   * - false for category axis
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_x_tick_culling: {},

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․x․tick․culling․max
   * @memberof Options
   * @type {Number}
   * @default 10
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_culling_max: 10,

  /**
   * The number of x axis ticks to show.<br><br>
   * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
   * @name axis․x․tick․count
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_x_tick_count: undefined,

  /**
   * Show or hide x axis tick line.
   * @name axis․x․tick․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_x_tick_show: !0,

  /**
   * Show or hide x axis tick text.
   * @name axis․x․tick․text․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_show: !0,

  /**
   * Set the x Axis tick text's position relatively its original position
   * @name axis․x․tick․text․position
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Fit x axis ticks.
   * - **true**: ticks will be positioned nicely to have same intervals.
   * - **false**: ticks will be positioned according to x value of the data points.
   * @name axis․x․tick․fit
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
   * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       fit: false
   *     }
   *   }
   * }
   */
  axis_x_tick_fit: !0,

  /**
   * Set the x values of ticks manually.<br><br>
   * If this option is provided, the position of the ticks will be determined based on those values.<br>
   * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.
   * @name axis․x․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       values: [1, 2, 4, 8, 16, 32, ...],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_values: null,

  /**
   * Rotate x axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.
   * @name axis․x․tick․rotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_x_tick_rotate: 0,

  /**
   * Show x axis outer tick.
   * @name axis․x․tick․outer
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_x_tick_outer: !0,

  /**
   * Set tick text to be multiline
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
   * @name axis․x․tick․multiline
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       multiline: false
   *     }
   *   }
   * }
   * @example
   * // example of line break with '\n'
   * // In this case, 'axis.x.tick.width' is ignored
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "long\ntext", "Another\nLong\nText"],
   *        ...
   *    ],
   * }
   */
  axis_x_tick_multiline: !0,

  /**
   * Set tick width
   * - **NOTE:**
   *  > When x tick text contains `\n`, this option is ignored.
   * @name axis․x․tick․width
   * @memberof Options
   * @type {Number}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       width: 50
   *     }
   *   }
   * }
   */
  axis_x_tick_width: null,

  /**
   * Set to display system tooltip(via 'title' attribute) for tick text
   * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
   * @name axis․x․tick․tooltip
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       tooltip: true
   *     }
   *   }
   * }
   */
  axis_x_tick_tooltip: !1,

  /**
   * Set max value of x axis range.
   * @name axis․x․max
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     max: 100
   *   }
   * }
   */
  axis_x_max: undefined,

  /**
   * Set min value of x axis range.
   * @name axis․x․min
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     min: -100
   *   }
   * }
   */
  axis_x_min: undefined,

  /**
   * Set padding for x axis.<br><br>
   * If this option is set, the range of x axis will increase/decrease according to the values.
   * If no padding is needed in the rage of x axis, 0 should be set.
   * - **NOTE:**
   *   The padding values aren't based on pixels. It differs according axis types<br>
   *   - **category:** The unit of tick value
   *     ex. the given value `1`, is same as the width of 1 tick width
   *   - **timeseries:** Numeric time value
   *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
   * @name axis․x․padding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   x: {
   *     padding: {
   *       // when axis type is 'category'
   *       left: 1,  // set left padding width of equivalent value of a tick's width
   *       right: 0.5  // set right padding width as half of equivalent value of tick's width
   *
   *       // when axis type is 'timeseries'
   *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
   *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_x_padding: {},

  /**
   * Set height of x axis.<br><br>
   * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
   * @name axis․x․height
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     height: 20
   *   }
   * }
   */
  axis_x_height: undefined,

  /**
   * Set default extent for subchart and zoom. This can be an array or function that returns an array.
   * @name axis․x․extent
   * @memberof Options
   * @type {Array|Function}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     // extent range as a pixel value
   *     extent: [0, 200],
   *
   *     // when axis is 'timeseries', parsable datetime string
   *     extent: ["2019-03-01", "2019-03-05"],
   *
   *     // return extent value
   *     extent: function(domain, scale) {
   *    	 var extent = domain.map(function(v) {
   *     	    return scale(v);
   *     	 });
   *
   *   	 // it should return a format of array
   *   	 // ex) [0, 584]
   *     	 return extent;
   *     }
   *   }
   * }
   */
  axis_x_extent: undefined,

  /**
   * Set label on x axis.<br><br>
   * You can set x axis label and change its position by this option.
   * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
   * Available position differs according to the axis direction (vertical or horizontal).
   * If string set, the position will be the default.
   *
   *  - **If it's horizontal axis:**
   *    - inner-right [default]
   *    - inner-center
   *    - inner-left
   *    - outer-right
   *    - outer-center
   *    - outer-left
   *  - **If it's vertical axis:**
   *    - inner-top [default]
   *    - inner-middle
   *    - inner-bottom
   *    - outer-top
   *    - outer-middle
   *    - outer-bottom
   * @name axis․x․label
   * @memberof Options
   * @type {String|Object}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     label: "Your X Axis"
   *   }
   * }
   *
   * axis: {
   *   x: {
   *     label: {
   *        text: "Your X Axis",
   *        position: "outer-center"
   *     }
   *   }
   * }
   */
  axis_x_label: {},

  /**
   * Set additional axes for x Axis.
   * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․x․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * x: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main x Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_x_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y Axis  config options
 */
/* harmony default export */ var axis_y = ({
  /**
   * Set clip-path attribute for y axis element
   * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.
   * @name axis․y․clipPath
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_y_clipPath: !0,

  /**
   * Show or hide y axis.
   * @name axis․y․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     show: false
   *   }
   * }
   */
  axis_y_show: !0,

  /**
   * Set type of y axis.<br><br>
   * **Available Values:**
   *   - timeseries
   *   - category
   *   - indexed
   * @name axis․y․type
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_y_type: undefined,

  /**
   * Set max value of y axis.
   * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․max
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     max: 1000
   *   }
   * }
   */
  axis_y_max: undefined,

  /**
   * Set min value of y axis.
   * - **NOTE:**
   *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․min
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     min: 1000
   *   }
   * }
   */
  axis_y_min: undefined,

  /**
   * Change the direction of y axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y․inverted
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inverted: true
   *   }
   * }
   */
  axis_y_inverted: !1,

  /**
   * Set center value of y axis.
   * @name axis․y․center
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     center: 0
   *   }
   * }
   */
  axis_y_center: undefined,

  /**
   * Show y axis inside of the chart.
   * @name axis․y․inner
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inner: true
   *   }
   * }
   */
  axis_y_inner: !1,

  /**
   * Set label on y axis.<br><br>
   * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y․label
   * @memberof Options
   * @type {String|Object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y: {
   *     label: "Your Y Axis"
   *   }
   * }
   *
   * axis: {
   *   y: {
   *     label: {
   *        text: "Your Y Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y_label: {},

  /**
   * Set formatter for y axis tick text.<br><br>
   * This option accepts d3.format object as well as a function you define.
   * @name axis․y․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y․tick․culling
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y․tick․culling․max
   * @memberof Options
   * @type {Number}
   * @default 5
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_culling_max: 5,

  /**
   * Show y axis outer tick.
   * @name axis․y․tick․outer
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y_tick_outer: !0,

  /**
   * Set y axis tick values manually.
   * @name axis․y․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_values: null,

  /**
   * Rotate y axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y․tick․rotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y_tick_rotate: 0,

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․count
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y_tick_count: undefined,

  /**
   * Show or hide y axis tick line.
   * @name axis․y․tick․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.
   * @name axis․y․tick․stepSize
   * @memberof Options
   * @type {Number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y_tick_stepSize: null,

  /**
  * Show or hide y axis tick text.
  * @name axis․y․tick․text․show
  * @memberof Options
  * @type {Boolean}
  * @default true
  * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
  * @example
  * axis: {
  *   y: {
  *     tick: {
  *       text: {
  *           show: false
  *       }
  *     }
  *   }
  * }
  */
  axis_y_tick_text_show: !0,

  /**
   * Set the y Axis tick text's position relatively its original position
   * @name axis․y․tick․text․position
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․time
   * @memberof Options
   * @private
   * @type {Object}
   * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       time: {
   *          // ticks at 15-minute intervals
   *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
   *          value: d3.timeMinute.every(15)
   *       }
   *     }
   *   }
   * }
   */
  // @TODO: not fully implemented yet
  axis_y_tick_time_value: undefined,

  /**
   * Set padding for y axis.<br><br>
   * You can set padding for y axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:** For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axis․y․padding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   y: {
   *     padding: {
   *       top: 0,
   *       bottom: 0
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_y_padding: {},

  /**
   * Set default range of y axis.<br><br>
   * This option set the default value for y axis when there is no data on init.
   * @name axis․y․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y_default: undefined,

  /**
   * Set additional axes for y Axis.
   * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y2.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y2 Axis  config options
 */
/* harmony default export */ var axis_y2 = ({
  /**
   * Show or hide y2 axis.
   * - **NOTE**:
   *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
   *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
   * @name axis․y2․show
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     show: true
   *   }
   * }
   */
  axis_y2_show: !1,

  /**
   * Set max value of y2 axis.
   * @name axis․y2․max
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     max: 1000
   *   }
   * }
   */
  axis_y2_max: undefined,

  /**
   * Set min value of y2 axis.
   * @name axis․y2․min
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     min: -1000
   *   }
   * }
   */
  axis_y2_min: undefined,

  /**
   * Change the direction of y2 axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y2․inverted
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inverted: true
   *   }
   * }
   */
  axis_y2_inverted: !1,

  /**
   * Set center value of y2 axis.
   * @name axis․y2․center
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     center: 0
   *   }
   * }
   */
  axis_y2_center: undefined,

  /**
   * Show y2 axis inside of the chart.
   * @name axis․y2․inner
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inner: true
   *   }
   * }
   */
  axis_y2_inner: !1,

  /**
   * Set label on y2 axis.<br><br>
   * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y2․label
   * @memberof Options
   * @type {String|Object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y2: {
   *     label: "Your Y2 Axis"
   *   }
   * }
   *
   * axis: {
   *   y2: {
   *     label: {
   *        text: "Your Y2 Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y2_label: {},

  /**
   * Set formatter for y2 axis tick text.<br><br>
   * This option works in the same way as axis.y.format.
   * @name axis․y2․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       format: d3.format("$,")
   *       //or format: function(d) { return "$" + d; }
   *     }
   *   }
   * }
   */
  axis_y2_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y2․tick․culling
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y2․tick․culling․max
   * @memberof Options
   * @type {Number}
   * @default 5
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling_max: 5,

  /**
   * Show or hide y2 axis outer tick.
   * @name axis․y2․tick․outer
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_outer: !0,

  /**
   * Set y2 axis tick values manually.
   * @name axis․y2․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_values: null,

  /**
   * Rotate y2 axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y2․tick․rotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y2_tick_rotate: 0,

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axis․y2․tick․count
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y2_tick_count: undefined,

  /**
   * Show or hide y2 axis tick line.
   * @name axis․y2․tick․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.
   * @name axis․y2․tick․stepSize
   * @memberof Options
   * @type {Number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y2_tick_stepSize: null,

  /**
   * Show or hide y2 axis tick text.
   * @name axis․y2․tick․text․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_show: !0,

  /**
   * Set the y2 Axis tick text's position relatively its original position
   * @name axis․y2․tick․text․position
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axis․y2․padding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   y2: {
   *     padding: {
   *       top: 100,
   *       bottom: 100
   *     }
   *
   *     // or set both values at once.
   *     padding: 10
   * }
   */
  axis_y2_padding: {},

  /**
   * Set default range of y2 axis.<br><br>
   * This option set the default value for y2 axis when there is no data on init.
   * @name axis․y2․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y2_default: undefined,

  /**
   * Set additional axes for y2 Axis.
   * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y2․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y2: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y2 Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y2_axes: []
});
// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(39);

// CONCATENATED MODULE: ./src/module/browser.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @module
 * @ignore
 */

/* eslint-disable no-new-func, no-undef */


var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    browser_doc = win && win.document;
/* eslint-enable no-new-func, no-undef */
// CONCATENATED MODULE: ./src/module/util.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */






var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isBoolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof v === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return Array.isArray(arr);
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
};

function getOption(options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
}

function util_hasValue(dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
}
/**
 * Call function with arguments
 * @param {Function} fn Function to be called
 * @param {*} args Arguments
 * @return {Boolean} true: fn is function, false: fn is not function
 * @private
 */


function callFn(fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
}
/**
 * Replace tag sign to html entity
 * @param {String} str
 * @return {String}
 * @private
 */


function sanitise(str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
}
/**
 * Set text value. If there's multiline add nodes.
 * @param {d3Selection} node Text node
 * @param {String} text Text value string
 * @param {Array} dy dy value for multilined text
 * @param {Boolean} toMiddle To be alingned vertically middle
 * @private
 */


function setTextValue(node, text, dy, toMiddle) {
  if (dy === void 0 && (dy = [-1, 1]), toMiddle === void 0 && (toMiddle = !1), node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"),
          len = toMiddle ? multiline.length - 1 : 1;
      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", (i === 0 ? dy[0] * len : dy[1]) + "em").text(v);
      });
    }
  }
} // substitution of SVGPathSeg API polyfill


function getRectSegList(path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height
  } // seg3
  ];
}

function getPathBox(path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
} // return brush selection array


function getBrushSelection(_ref) {
  var selection,
      $el = _ref.$el,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = $el.context || $el.main;
  return event && event.type === "brush" ? selection = event.selection : main && (selection = main.select("." + config_classes.brush).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
} // Get boundingClientRect. cache the evaluated value once it was called.


var getBoundingRect = function (node) {
  return node.rect || (node.rect = node.getBoundingClientRect());
}; // retrun random number


function getRandom(asStr) {
  asStr === void 0 && (asStr = !0);
  var rand = Math.random();
  return asStr ? rand + "" : rand;
}

function brushEmpty(ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
}

function extend(target, source) {
  // exclude name with only numbers
  for (var p in target === void 0 && (target = {}), isArray(source) && source.forEach(function (v) {
    return extend(target, v);
  }), source) /^\d+$/.test(p) || (target[p] = source[p]);

  return target;
}
/**
 * Return first letter capitalized
 * @param {String} str
 * @return {String} capitalized string
 * @private
 */


var capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
};
/**
 * Convert to array
 * @param {Object} v
 * @returns {Array}
 * @private
 */


/**
 * Get css rules for specified stylesheets
 * @param {Array} styleSheets The stylesheets to get the rules from
 * @returns {Array}
 * @private
 */
function getCssRules(styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from " + sheet.href + ": " + e.toString());
    }
  }), rules;
}
/**
 * Gets the SVGMatrix of an SVGElement
 * @param {SVGElement} element
 * @return {SVGMatrix} matrix
 * @private
 */


function getTranslation(node) {
  var transform = node ? node.transform : null,
      baseVal = transform ? transform.baseVal : [];
  return baseVal.length ? baseVal.getItem(0).matrix : {
    a: 0,
    b: 0,
    c: 0,
    d: 0,
    e: 0,
    f: 0
  };
}
/**
 * Get unique value from array
 * @param {Array} data
 * @return {Array} Unique array value
 * @private
 */


function getUnique(data) {
  var isDate = data[0] instanceof Date,
      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
  return isDate ? d.map(function (v) {
    return new Date(v);
  }) : d;
}
/**
 * Merge array
 * @param {Array} arr
 * @return {Array}
 * @private
 */


function mergeArray(arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
}
/**
 * Merge object returning new object
 * @param {Object} target
 * @param {Object} objectN
 * @returns {Object} merged target object
 * @private
 */


function mergeObj(target) {
  for (var _len2 = arguments.length, objectN = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) objectN[_key2 - 1] = arguments[_key2];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}
/**
 * Sort value
 * @param {Array} data value to be sorted
 * @param {Boolean} isAsc true: asc, false: desc
 * @return {Number|String|Date} sorted date
 * @private
 */


function util_sortValue(data, isAsc) {
  isAsc === void 0 && (isAsc = !0);
  var fn;
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
}
/**
 * Get min/max value
 * @param {String} type 'min' or 'max'
 * @param {Array} data Array data value
 * @retun {Number|Date|undefined}
 * @private
 */


function getMinMax(type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, res) : res[0] instanceof Date && (res = util_sortValue(res, type === "min")[0]) : res = undefined, res;
}
/**
 * Get range
 * @param {Number} start Start number
 * @param {Number} end End number
 * @return {Array}
 * @private
 */


function getRange(start, end) {
  var res = [];

  for (var i = start; i < end; i++) res.push(i);

  return res;
} // emulate event


var emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType, params) {
        params === void 0 && (params = getParams()), el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType, params) {
        params === void 0 && (params = getParams());
        var mouseEvent = browser_doc.createEvent("MouseEvent"); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent

        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, win, 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(mergeObj({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
};
/**
 * Process the template  & return bound string
 * @param {String} tpl Template string
 * @param {Object} data Data value to be replaced
 * @return {String}
 * @private
 */

function tplProcess(tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=" + x + "}", "g"), data[x]);

  return res;
}
// CONCATENATED MODULE: ./src/config/Options/axis/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
* y Axis  config options
*/

/* harmony default export */ var axis_axis = (mergeObj({
  /**
   * Switch x and y axis position.
   * @name axis․rotated
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   rotated: true
   * }
   */
  axis_rotated: !1
}, axis_x, axis_y, axis_y2));
// CONCATENATED MODULE: ./src/config/Options/common/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * grid config options
 */
/* harmony default export */ var common_grid = ({
  /**
   * Set related options
   * @name grid
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
   * @property {Boolean} [x.show=false] Show grids along x axis.
   * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
   *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
   *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
   * @property {Boolean} [y.show=false] Show grids along x axis.
   * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
   *  This option accepts array including object that has value, text, position and class.
   * @property {Number} [y.ticks=10] Number of y grids to be shown.
   * @property {Boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {Boolean} [focus.show=true] Show grid line when focus.
   * @property {Boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {Boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
   * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
   * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
   * @example
   * grid: {
   *   x: {
   *     show: true,
   *     lines: [
   *       {value: 2, text: "Label on 2"},
   *       {value: 5, text: "Label on 5", class: "label-5"},
   *       {value: 6, text: "Label on 6", position: "start"}
   *     ]
   *   },
   *   y: {
   *     show: true,
   *     lines: [
   *       {value: 100, text: "Label on 100"},
   *       {value: 200, text: "Label on 200", class: "label-200"},
   *       {value: 300, text: "Label on 300", position: 'middle'}
   *     ],
   *     ticks: 5
   *   },
   *   front: true,
   *   focus: {
   *      show: false,
   *
   *      // Below options are available when 'tooltip.grouped=false' option is set
   *      edge: true,
   *      y: true
   *   },
   *   lines: {
   *      front: false
   *   }
   * }
   */
  grid_x_show: !1,
  grid_x_type: "tick",
  grid_x_lines: [],
  grid_y_show: !1,
  grid_y_lines: [],
  grid_y_ticks: 10,
  grid_focus_edge: !1,
  grid_focus_show: !0,
  grid_focus_y: !1,
  grid_front: !1,
  grid_lines_front: !0
});
// CONCATENATED MODULE: ./src/config/Options/common/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * point config options
 */
/* harmony default export */ var common_point = ({
  /**
   * Set point options
   * @name point
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [point.show=true] Whether to show each point in line.
   * @property {Number|Function} [point.r=2.5] The radius size of each point.
   *  - **NOTE:** Disabled for 'bubble' type
   * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
   * @property {Number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
   *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
   * @property {Number} [point.sensitivity=10] The senstivity value for interaction boundary.
   * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
   * @property {String} [point.type="circle"] The type of point to be drawn
   * - **NOTE:**
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
   * - **NOTE:**
   *   - This is an `experimental` feature and can have some unexpected behaviors.
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   *   - svg shape tag interpreted as string<br>
   *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
   * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
   * @example
   *  point: {
   *      show: false,
   *      r: 5,
   *
   *      // or customize the radius
   *      r: function(d) {
   *          ...
   *          return r;
   *      },
   *
   *      focus: {
   *          expand: {
   *              enabled: true,
   *              r: 1
   *          }
   *      },
   *      select: {
   *          r: 3
   *      },
   *
   *      // having lower value, means how closer to be for interaction
   *      sensitivity: 3,
   *
   *      // valid values are "circle" or "rectangle"
   *      type: "rectangle",
   *
   *      // or indicate as pattern
   *      pattern: [
   *        "circle",
   *        "rectangle",
   *        "<polygon points='0 6 4 0 -4 0'></polygon>"
   *     ],
   *  }
   */
  point_show: !0,
  point_r: 2.5,
  point_sensitivity: 10,
  point_focus_expand_enabled: !0,
  point_focus_expand_r: undefined,
  point_pattern: [],
  point_select_r: undefined,
  point_type: "circle"
});
// CONCATENATED MODULE: ./src/config/Options/common/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var common_subchart = ({
  /**
   * Set subchart options
   * @name subchart
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
   * @property {Boolean} [subchart.axis.x.show=true] Show or hide x axis.
   * @property {Boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
   * @property {Boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
   * @property {Number} [subchart.size.height] Change the height of the subchart.
   * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
   *  Specified function receives the current zoomed x domain.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
   * @example
   *  subchart: {
   *      axis: {
   *      	x: {
   *      	  show: true,
   *      	    tick: {
   *      	      show: true,
   *      	      text: {
   *      	        show: false
   *      	      }
   *      	    }
   *      	}
   *      },
   *      show: true,
   *      size: {
   *          height: 20
   *      },
   *      onbrush: function(domain) { ... }
   *  }
   */
  subchart_show: !1,
  subchart_size_height: 60,
  subchart_axis_x_show: !0,
  subchart_axis_x_tick_show: !0,
  subchart_axis_x_tick_text_show: !0,
  subchart_onbrush: function subchart_onbrush() {}
});
// CONCATENATED MODULE: ./src/config/Options/common/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * zoom config options
 */
/* harmony default export */ var common_zoom = ({
  /**
   * Set zoom options
   * @name zoom
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [zoom.enabled=false] Enable zooming.
   * @property {String} [zoom.enabled.type='wheel'] Set zoom interaction type.
   *  - **Available types:**
   *    - wheel
   *    - drag
   * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
   *  If true set, y domain will be updated according to the zoomed region.
   * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
   * @property {Number|Date} [zoom.x.min] Set x Axis minimum zoom range
   * @property {Number|Date} [zoom.x.max] Set x Axis maximum zoom range
   * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
   *  Specified function receives the zoom event.
   * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
   *  Specified function receives the zoomed domain.
   * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
   *  Specified function receives the zoomed domain.
   * @property {Boolean|Object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
   * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.
   * @property {String} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
   * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
   * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
   * @example
   *  zoom: {
   *      enabled: {
   *          type: "drag"
   *      },
   *      rescale: true,
   *      extent: [1, 100]  // enable more zooming
   *      x: {
   *          min: -1,  // set min range
   *          max: 10  // set max range
   *      },
   *      onzoomstart: function(event) { ... },
   *      onzoom: function(domain) { ... },
   *      onzoomend: function(domain) { ... },
   *
   *      // show reset button when is zoomed-in
   *      resetButton: true,
   *
   *      resetButton: {
   *          // onclick callback when reset button is clicked
   *          onclick: function(button) {
   *            button; // Reset button element reference
   *            ...
   *          },
   *
   *          // customized text value for reset zoom button
   *          text: "Unzoom"
   *      }
   *  }
   */
  zoom_enabled: undefined,
  zoom_extent: undefined,
  zoom_privileged: !1,
  zoom_rescale: !1,
  zoom_onzoom: undefined,
  zoom_onzoomstart: undefined,
  zoom_onzoomend: undefined,
  zoom_resetButton: !0,
  zoom_x_min: undefined,
  zoom_x_max: undefined
});
// CONCATENATED MODULE: ./src/config/Options/shape/area.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * area config options
 */
/* harmony default export */ var shape_area = ({
  /**
   * Set area options
   * @name area
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
   * @property {Boolean} [area.above=false] Set background area above the data chart line.
   * @property {Boolean|Object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
   * Or customize by giving below object value:
   *  - x {Array}: `x1`, `x2` value
   *  - y {Array}: `y1`, `y2` value
   *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
   * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
   * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
   * @example
   *  area: {
   *      zerobased: false,
   *      above: true,
   *
   *      // will generate follwing linearGradient:
   *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
   *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
   *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
   *      // </linearGradient>
   *      linearGradient: true,
   *
   *      // Or customized gradient
   *      linearGradient: {
   *      	x: [0, 0],  // x1, x2 attributes
   *      	y: [0, 0],  // y1, y2 attributes
   *      	stops: [
   *      	  // offset, stop-color, stop-opacity
   *      	  [0, "#7cb5ec", 1],
   *
   *      	  // setting 'null' for stop-color, will set its original data color
   *      	  [0.5, null, 0],
   *
   *      	  // setting 'function' for stop-color, will pass data id as argument.
   *      	  // It should return color string or null value
   *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
   *      	]
   *      }
   *  }
   */
  area_zerobased: !0,
  area_above: !1,
  area_linearGradient: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bar config options
 */
/* harmony default export */ var shape_bar = ({
  /**
   * Set bar options
   * @name bar
   * @memberof Options
   * @type {Object}
   * @property {Number} [bar.padding=0] The padding pixel value between each bar.
   * @property {Number} [bar.radius] Set the radius of bar edge in pixel.
   * - **NOTE:** Works only for non-stacked bar
   * @property {Number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
   * @property {Number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
   * @property {Number} [bar.width] Change the width of bar chart.
   * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
   * @property {Number} [bar.width.max] The maximum width value for ratio.
   * @property {Number} [bar.width.dataname] Change the width of bar for indicated dataset only.
   * - **NOTE:**
   *   - Works only for non-stacked bar
   *   - Bars are centered accoding its total width value
   * @property {Number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
   * @property {Number} [bar.width.dataname.max] The maximum width value for ratio.
   * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
   * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
   * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
   * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
   * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
   * @example
   *  bar: {
   *      padding: 1,
   *
   *      // the 'radius' option can be used only for non-stacking bars
   *      radius: 10,
   *      // or
   *      radius: {
   *          ratio: 0.5
   *      }
   *
   *      // will not have offset between each bar elements for interaction
   *      sensitivity: 0,
   *
   *      width: 10,
   *
   *      // or
   *      width: {
   *          ratio: 0.2,
   *          max: 20
   *      },
   *
   *      // or specify width per dataset
   *      width: {
   *          data1: 20,
   *          data2: {
   *              ratio: 0.2,
   *              max: 20
   *          }
   *      },
   *
   *      zerobased: false
   *  }
   */
  bar_padding: 0,
  bar_radius: undefined,
  bar_sensitivity: 2,
  bar_width: undefined,
  bar_width_ratio: .6,
  bar_width_max: undefined,
  bar_zerobased: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bubble config options
 */
/* harmony default export */ var bubble = ({
  /**
   * Set bubble options
   * @name bubble
   * @memberof Options
   * @type {Object}
   * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
   * @property {Boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.
   * @example
   *  bubble: {
   *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
   *      // And the lesser will have radius relatively from tha max value.
   *      maxR: 50,
   *
   *      // or set radius callback
   *      maxR: function(d) {
   *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
   *          ...
   *          return Math.sqrt(d.value * 2);
   *      },
   *      zerobased: false
   *  }
   */
  bubble_maxR: 35,
  bubble_zerobased: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * line config options
 */
/* harmony default export */ var shape_line = ({
  /**
   * Set line options
   * @name line
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
   *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
   * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
   * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
   * **Available values:**
   * - step
   * - step-before
   * - step-after
   * @property {Boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
   * @property {Boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.
   * @example
   *  line: {
   *      connectNull: true,
   *      classes: [
   *          "line-class1",
   *          "line-class2"
   *      ],
   *      step: {
   *          type: "step-after"
   *      },
   *
   *      // hide all data points ('point.show=false' also has similar effect)
   *      point: false,
   *
   *      // show data points for only indicated datas
   *      point: [
   *          "data1", "data3"
   *      ],
   *
   *      zerobased: false
   *  }
   */
  line_connectNull: !1,
  line_step_type: "step",
  line_zerobased: !1,
  line_classes: undefined,
  line_point: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/spline.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var spline = ({
  /**
   * Set spline options
   * - **Available interpolation type values:**
   *  - basis (d3.curveBasis)
   *  - basis-closed (d3.curveBasisClosed)
   *  - basis-open (d3.curveBasisOpen)
   *  - bundle (d3.curveBundle)
   *  - cardinal (d3.curveCardinal)
   *  - cardinal-closed (d3.curveCardinalClosed)
   *  - cardinal-open (d3.curveCardinalOpen)
   *  - catmull-rom (d3.curveCatmullRom)
   *  - catmull-rom-closed (d3.curveCatmullRomClosed)
   *  - catmull-rom-open (d3.curveCatmullRomOpen)
   *  - monotone-x (d3.curveMonotoneX)
   *  - monotone-y (d3.curveMonotoneY)
   *  - natural (d3.curveNatural)
   *  - linear-closed (d3.curveLinearClosed)
   *  - linear (d3.curveLinear)
   *  - step (d3.curveStep)
   *  - step-after (d3.curveStepAfter)
   *  - step-before (d3.curveStepBefore)
   * @name spline
   * @memberof Options
   * @type {Object}
   * @property {String} [spline.interpolation.type="cardinal"]
   * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
   * @example
   *  spline: {
   *      interpolation: {
   *          type: "cardinal"
   *      }
   *  }
   */
  spline_interpolation_type: "cardinal"
});
// CONCATENATED MODULE: ./src/config/Options/shape/donut.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * donut config options
 */
/* harmony default export */ var donut = ({
  /**
   * Set donut options
   * @name donut
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
   * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
   * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
   * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
   * @property {Number} [donut.expand.rate=0.98] Set expand rate.
   * @property {Number} [donut.expand.duration=50] Set expand transition time in ms.
   * @property {Number} [donut.width] Set width of donut chart.
   * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
   * @property {Number} [donut.padAngle=0] Set padding between data.
   * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  donut: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *          	...
   *          	return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      width: 10,
   *      padAngle: 0.2,
   *      startingAngle: 1,
   *      title: "Donut Title"
   *
   *      // title with line break
   *      title: "Title1\nTitle2"
   *  }
   */
  donut_label_show: !0,
  donut_label_format: undefined,
  donut_label_threshold: .05,
  donut_label_ratio: undefined,
  donut_width: undefined,
  donut_title: "",
  donut_expand: {},
  donut_expand_rate: .98,
  donut_expand_duration: 50,
  donut_padAngle: 0,
  donut_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/gauge.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * gauge config options
 */
/* harmony default export */ var gauge = ({
  /**
   * Set gauge options
   * @name gauge
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
   * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
   * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
   * @property {Function} [gauge.label.extents] Set customized min/max label text.
   * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
   * @property {Number} [gauge.expand.rate=0.98] Set expand rate.
   * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
   * @property {Number} [gauge.min=0] Set min value of the gauge.
   * @property {Number} [gauge.max=100] Set max value of the gauge.
   * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.
   * @property {String} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
   * @property {String} [gauge.units] Set units of the gauge.
   * @property {Number} [gauge.width] Set width of gauge chart.
   * @property {String} [gauge.type="single"] Set type of gauge to be displayed.<br><br>
   * **Available Values:**
   * - single
   * - multi
   * @property {String} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.
   * @example
   *  gauge: {
   *      fullCircle: false,
   *      label: {
   *          show: false,
   *          format: function(value, ratio) {
   *              return value;
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          extents: function(value, isMax) {
   *              return (isMax ? "Max:" : "Min:") + value;
   *          }
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      min: -100,
   *      max: 200,
   *      type: "single"  // or 'multi'
   *      title: "Title Text",
   *      units: "%",
   *      width: 10,
   *      arcs: {
   *          minWidth: 5
   *      }
   *  }
   */
  gauge_fullCircle: !1,
  gauge_label_show: !0,
  gauge_label_format: undefined,
  gauge_label_extents: undefined,
  gauge_min: 0,
  gauge_max: 100,
  gauge_type: "single",
  gauge_startingAngle: -1 * Math.PI / 2,
  gauge_title: "",
  gauge_units: undefined,
  gauge_width: undefined,
  gauge_arcs_minWidth: 5,
  gauge_expand: {},
  gauge_expand_rate: .98,
  gauge_expand_duration: 50
});
// CONCATENATED MODULE: ./src/config/Options/shape/pie.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var pie = ({
  /**
   * Set pie options
   * @name pie
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
   * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
   * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
   * @property {Boolean|Object} [pie.expand=true] Enable or disable expanding pie pieces.
   * @property {Number} [pie.expand.rate=0.98] Set expand rate.
   * @property {Number} [pie.expand.duration=50] Set expand transition time in ms.
   * @property {Number|Object} [pie.innerRadius=0] Sets the inner radius of pie arc.
   * @property {Number} [pie.padAngle=0] Set padding between data.
   * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
   * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  pie: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *              ...
   *              return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      innerRadius: 0,
   *
   *      // set different innerRadius for each data
   *      innerRadius: {
   *      	data1: 10,
   *      	data2: 0
   *      }
   *
   *      padAngle: 0.1,
   *      padding: 0,
   *      startingAngle: 1
   *  }
   */
  pie_label_show: !0,
  pie_label_format: undefined,
  pie_label_threshold: .05,
  pie_label_ratio: undefined,
  pie_expand: {},
  pie_expand_rate: .98,
  pie_expand_duration: 50,
  pie_innerRadius: 0,
  pie_padAngle: 0,
  pie_padding: 0,
  pie_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var radar = ({
  /**
   * Set radar options
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break.
   * @name radar
   * @memberof Options
   * @type {Object}
   * @property {Number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
   * @property {Boolean} [radar.axis.line.show=true] Show or hide axis line.
   * @property {Number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
   * @property {NUmber} [radar.axis.text.position.y=0] y coordinate position, relative the original.
   * @property {Boolean} [radar.axis.text.show=true] Show or hide axis text.
   * @property {Boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
   * @property {Number} [radar.level.depth=3] Set the level depth.
   * @property {Boolean} [radar.level.show=true] Show or hide level.
   * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
   * @property {Boolean} [radar.level.text.show=true] Show or hide level text.
   * @property {Number} [radar.size.ratio=0.87] Set size ratio.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
   * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
   * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
   * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
   * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
   * @example
   *  radar: {
   *      axis: {
   *          max: 50,
   *          line: {
   *              show: false
   *          },
   *          text: {
   *              position: {
   *              	x: 0,
   *              	y: 0
   *              },
   *              show: false
   *          }
   *      },
   *      direction: {
   *          clockwise: true
   *      },
   *      level: {
   *          show: false,
   *          text: {
   *              format: function(x) {
   *                  return x + "%";
   *              },
   *              show: true
   *          }
   *      },
   *      size: {
   *          ratio: 0.7
   *      }
   *  }
   */
  radar_axis_max: undefined,
  radar_axis_line_show: !0,
  radar_axis_text_show: !0,
  radar_axis_text_position: {},
  radar_level_depth: 3,
  radar_level_show: !0,
  radar_level_text_format: function radar_level_text_format(x) {
    return x % 1 === 0 ? x : x.toFixed(2);
  },
  radar_level_text_show: !0,
  radar_size_ratio: .87,
  radar_direction_clockwise: !1
});
// CONCATENATED MODULE: ./src/config/Options/Options.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
// common





 // Axis based












 // Non-Axis based






/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */

var Options = function () {
  var config = [data_data, common_color, interaction, common_legend, common_title, common_tooltip].concat([donut, gauge, pie, radar], [data_axis, data_selection, axis_axis, common_grid, common_point, common_subchart, common_zoom], [shape_area, shape_bar, bubble, shape_line, spline]);
  return mergeObj.apply(void 0, [{
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
     * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
     * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set chart background.
     * @name background
     * @memberof Options
     * @property {String} background.class Specify the class name for background element.
     * @property {String} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.
     * @property {String} background.imgUrl Specify the image url string for background.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)
     * @example
     * background: {
     *    class: "myClass",
     *    color: "red",
     *
     *    // Set image url for background.
     *    // If specified, 'color' option will be ignored.
     *    imgUrl: "https://naver.github.io/billboard.js/img/logo/billboard.js.svg",
     * }
     */
    background: {},

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {Object}
     * @property {String} [svg.classname] class name for svg element
     * @example
     * svg: {
              *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {Object}
     * @property {Number} [size.width] width of the chart element
     * @property {Number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
              *   width: 640,
              *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {Object}
     * @property {Number} [padding.top] padding on the top of chart
     * @property {Number} [padding.right] padding on the right of chart
     * @property {Number} [padding.bottom] padding on the bottom of chart
     * @property {Number} [padding.left] padding on the left of chart
     * @example
     * padding: {
              *   top: 20,
              *   right: 20,
              *   bottom: 20,
              *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onover: function(ctx) {
     *   ...
     * }
     */
    onover: undefined,

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onout: function(ctx) {
     *   ...
     * }
     */
    onout: undefined,

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresize: function(ctx) {
     *   ...
     * }
     */
    onresize: undefined,

    /**
     * Set a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresized: function(ctx) {
     *   ...
     * }
     */
    onresized: undefined,

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onbeforeinit: function(ctx) {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * oninit: function(ctx) {
     *   ...
     * }
     */
    oninit: undefined,

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onafterinit: function(ctx) {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onrendered: function(ctx) {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {Object}
     * @property {Number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
     * Set scatter options
     * @name scatter
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.
     * @example
     *  scatter: {
     *      connectNull: true,
     *      step: {
     *          type: "step-after"
     *      },
     *
     *      // hide all data points ('point.show=false' also has similar effect)
     *      point: false,
     *
     *      // show data points for only indicated datas
     *      point: [
     *          "data1", "data3"
     *      ],
     *
     *      zerobased: false
     *  }
     */
    scatter_zerobased: !1,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Control the render timing
     * @name render
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
     * @property {Boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
     * @example
     *  render: {
     *    lazy: true,
     *    observe: true
     * }
     *
     * @example
     *	// <!-- render.lazy will detect visibility defined -->
     *  // (a) <div id='chart' class='hide'></div>
     *  // (b) <div id='chart' style='display:none'></div>
     *
     *  // render.lazy enabled by default when element is hidden
     *  var chart = bb.generate({ ... });
     *
     *  // chart will be rendered automatically when element's visibility changes
     *  // Note: works only for inlined css property or class attribute changes
     *  document.getElementById('chart').classList.remove('hide')  // (a)
     *  document.getElementById('chart').style.display = 'block';  // (b)
     *
     * @example
     *	// chart won't be rendered and not observing bind element's visiblity changes
     *  var chart = bb.generate({
     *     render: {
     *          lazy: true,
     *          observe: false
     *     }
     *  });
     *
     *  // call at any point when you want to render
     *  chart.flush();
     */
    render: {},

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class.
     * The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end.
     * If not specified, the edge values will be used.
     * If timeseries x axis, date string, Date object and unixtime integer can be used.
     * If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: []
  }].concat(config));
};


// CONCATENATED MODULE: ./src/module/Cache.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


var Cache_Cache =
/*#__PURE__*/
function () {
  function Cache() {
    _defineProperty(this, "cache", {});
  }

  var _proto = Cache.prototype;
  return _proto.add =
  /**
   * Add cache
   * @param {String} key
   * @param {*} value
   * @param {Boolean} isDataType
   * @private
   */
  function add(key, value, isDataType) {
    return isDataType === void 0 && (isDataType = !1), this.cache[key] = isDataType ? this.cloneTarget(value) : value, this.cache[key];
  }
  /**
   * Remove cache
   * @param {String|Array} key
   * @private
   */
  , _proto.remove = function remove(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  }
  /**
   * Get cahce
   * @param {String|Array} key
   * @param {Boolean} isDataType
   * @return {*}
   * @private
   */
  , _proto.get = function get(key, isDataType) {
    if (isDataType === void 0 && (isDataType = !1), isDataType) {
      for (var id, targets = [], i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    return this.cache[key] || null;
  }
  /**
   * reset cached data
   * @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
  	 */
  , _proto.reset = function reset(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }, _proto.cloneTarget = function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  }, Cache;
}();


// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(40);

// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(41);

// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRendererHelper.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper =
/*#__PURE__*/
function () {
  function AxisRendererHelper(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "scale", void 0);
    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])(),
        config = owner.config,
        params = owner.params;
    this.owner = owner, this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node
   * @return {{w: number, h: number}}
   * @private
   */


  AxisRendererHelper.getSizeFor1Char = function getSizeFor1Char(node) {
    // default size for one character
    var size = {
      w: 5.5,
      h: 11.5
    };
    return node.empty() || node.select("text").text("0").call(function (el) {
      try {
        var _el$node$getBBox = el.node().getBBox(),
            width = _el$node$getBBox.width,
            height = _el$node$getBBox.height;

        width && height && (size.w = width, size.h = height), el.text("");
      } catch (e) {}
    }), this.getSizeFor1Char = function () {
      return size;
    }, size;
  };

  var _proto = AxisRendererHelper.prototype;
  return _proto.axisX = function axisX(selection, x) {
    var _this = this;

    selection.attr("transform", function (d) {
      return "translate(" + Math.ceil(x(d) + _this.config.tickOffset) + ",0)";
    });
  }, _proto.axisY = function axisY(selection, y) {
    selection.attr("transform", function (d) {
      return "translate(0," + Math.ceil(y(d)) + ")";
    });
  }, _proto.scaleExtent = function scaleExtent(domain) {
    var start = domain[0],
        stop = domain[domain.length - 1];
    return start < stop ? [start, stop] : [stop, start];
  }, _proto.generateTicks = function generateTicks(scale, isYAxes) {
    var tickStepSize = this.owner.params.tickStepSize,
        ticks = [];
    // When 'axis[y|y2].tick.stepSize' option is set
    if (isYAxes && tickStepSize) for (var _scale$domain = scale.domain(), start = _scale$domain[0], end = _scale$domain[1], interval = start; interval <= end;) ticks.push(interval), interval += tickStepSize;else if (scale.ticks) ticks = scale.ticks.apply(scale, this.config.tickArguments || []).map(function (v) {
      return (// round the tick value if is number
        isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
      );
    });else {
      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
    }
    return ticks;
  }, _proto.copyScale = function copyScale() {
    var newScale = this.scale.copy();
    return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
  }, _proto.textFormatted = function textFormatted(v) {
    var tickFormat = this.config.tickFormat,
        value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
        formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
    // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
    // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

    return isDefined(formatted) ? formatted : "";
  }, _proto.transitionise = function transitionise(selection) {
    var config = this.config;
    return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
  }, AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRenderer.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer =
/*#__PURE__*/
function () {
  function AxisRenderer(params) {
    params === void 0 && (params = {}), _defineProperty(this, "helper", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "params", void 0), _defineProperty(this, "g", void 0);
    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.config = config, this.params = params, this.helper = new AxisRendererHelper_AxisRendererHelper(this);
  }
  /**
   * Create axis element
   * @param {d3.selection} g
   * @private
   */


  var _proto = AxisRenderer.prototype;
  return _proto.create = function create(g) {
    var ctx = this,
        config = this.config,
        params = this.params,
        helperInst = this.helper,
        scale = helperInst.scale,
        orient = config.orient,
        splitTickText = this.splitTickText.bind(this),
        isLeftRight = /^(left|right)$/.test(orient),
        isTopBottom = /^(top|bottom)$/.test(orient),
        tickTransform = helperInst[isTopBottom ? "axisX" : "axisY"],
        axisPx = tickTransform === helperInst.axisX ? "y" : "x",
        sign = /^(top|left)$/.test(orient) ? -1 : 1,
        rotate = params.tickTextRotate;
    this.config.range = scale.rangeExtent ? scale.rangeExtent() : helperInst.scaleExtent((params.orgXScale || scale).range());
    var $g,
        _config = config,
        innerTickSize = _config.innerTickSize,
        tickLength = _config.tickLength,
        range = _config.range,
        name = params.name,
        tickTextPos = name && /^(x|y|y2)$/.test(name) ? params.config["axis_" + name + "_tick_text_position"] : {
      x: 0,
      y: 0
    },
        prefix = name === "subX" ? "subchart_axis_x" : "axis_" + name,
        axisShow = params.config[prefix + "_show"],
        tickShow = {
      tick: !!axisShow && params.config[prefix + "_tick_show"],
      text: !!axisShow && params.config[prefix + "_tick_text_show"]
    }; // // get the axis' tick position configuration

    g.each(function () {
      var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          scale0 = this.__chart__ || scale,
          scale1 = helperInst.copyScale();
      $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
      // update selection - data join
      var path = g.selectAll(".domain").data([0]); // enter + update selection

      if (path.enter().append("path").attr("class", "domain").merge(helperInst.transitionise(path)).attr("d", function () {
        var outerTickSized = config.outerTickSize * sign;
        return isTopBottom ? "M" + range[0] + "," + outerTickSized + "V0H" + range[1] + "V" + outerTickSized : "M" + outerTickSized + "," + range[0] + "H0V" + range[1] + "H" + outerTickSized;
      }), tickShow.tick || tickShow.text) {
        // count of tick data in array
        var ticks = config.tickValues || helperInst.generateTicks(scale1, isLeftRight),
            tick = g.selectAll(".tick").data(ticks, scale1),
            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
            tickExit = tick.exit().remove(); // update selection

        tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
        var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
            counts = [],
            tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
          var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helperInst.textFormatted(d)) ? helperInst.textFormatted(d).concat() : [helperInst.textFormatted(d)];
          return counts[index] = split.length, split.map(function (splitted) {
            return {
              index: index,
              splitted: splitted
            };
          });
        });
        tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
          return d.splitted;
        }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
          var dx = 0;
          return /(top|bottom)/.test(orient) && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180)) * (orient === "top" ? -1 : 1)), dx + (tickTextPos.x || 0);
        }()).attr("dy", function (d, i) {
          var dy = 0;
          return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
        });
        var lineUpdate = tick.select("line"),
            textUpdate = tick.select("text");

        if (tickEnter.select("line").attr(axisPx + "2", innerTickSize * sign), tickEnter.select("text").attr("" + axisPx, tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle && textUpdate.append && textUpdate.append("title").each(function (index) {
          Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).text(params.tickTitle[index]);
        }), scale1.bandwidth) {
          var x = scale1,
              dx = x.bandwidth() / 2;
          scale0 = function (d) {
            return x(d) + dx;
          }, scale1 = scale0;
        } else scale0.bandwidth ? scale0 = scale1 : tickTransform.call(helperInst, tickExit, scale1);

        tickTransform.call(helperInst, tickEnter, scale0), tickTransform.call(helperInst, helperInst.transitionise(tick).style("opacity", "1"), scale1);
      }
    }), this.g = $g;
  }
  /**
   * Get tick x/y coordinate
   * @return {{x: number, y: number}}
   * @private
   */
  , _proto.getTickXY = function getTickXY() {
    var config = this.config,
        pos = {
      x: 0,
      y: 0
    };
    return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
  }
  /**
   * Get tick size
   * @param d
   * @return {number}
   * @private
   */
  , _proto.getTickSize = function getTickSize(d) {
    var scale = this.helper.scale,
        config = this.config,
        _config2 = config,
        innerTickSize = _config2.innerTickSize,
        range = _config2.range,
        tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
    return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
  }
  /**
   * Set tick's line & text position
   * @param lineUpdate
   * @param textUpdate
   * @param scale
   * @private
   */
  , _proto.setTickLineTextPosition = function setTickLineTextPosition(lineUpdate, textUpdate) {
    var tickPos = this.getTickXY(),
        _this$config = this.config,
        innerTickSize = _this$config.innerTickSize,
        orient = _this$config.orient,
        tickLength = _this$config.tickLength,
        tickOffset = _this$config.tickOffset,
        rotate = this.params.tickTextRotate,
        textAnchorForText = function (r) {
      var value = ["start", "end"];
      return orient === "top" && value.reverse(), r ? r > 0 ? value[0] : value[1] : "middle";
    },
        textTransform = function (r) {
      return r ? "rotate(" + r + ")" : null;
    },
        yForText = function (r) {
      var r2 = r / (orient === "bottom" ? 15 : 23);
      return r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;
    };

    orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -yForText(rotate) * 2).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
  } // this should be called only when category axis
  , _proto.splitTickText = function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
    function split(splitted, text) {
      for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
      if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

      return splitted.concat(text);
    }

    var params = this.params,
        tickText = this.helper.textFormatted(d),
        splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
    if (splitted.length) return splitted;
    if (isArray(tickText)) return tickText;
    var tickWidth = params.tickWidth;
    return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
  }, _proto.scale = function scale(x) {
    return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
  }, _proto.orient = function orient(x) {
    return arguments.length ? (this.config.orient = x in {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    } ? x + "" : "bottom", this) : this.config.orient;
  }, _proto.tickFormat = function tickFormat(format) {
    var config = this.config;
    return arguments.length ? (config.tickFormat = format, this) : config.tickFormat;
  }, _proto.tickCentered = function tickCentered(isCentered) {
    var config = this.config;
    return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
  }
  /**
   * Return tick's offset value.
   * The value will be set for 'category' axis type.
   * @return {number}
   * @private
   */
  , _proto.tickOffset = function tickOffset() {
    return this.config.tickOffset;
  }
  /**
   * Get tick interval count
   * @private
   * @param {Number} size Total data size
   * @return {number}
   */
  , _proto.tickInterval = function tickInterval(size) {
    var interval;
    if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
      var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
      interval = length / (size || this.g.selectAll("line").size());
    }
    return interval === Infinity ? 0 : interval;
  }, _proto.ticks = function ticks() {
    for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
  }, _proto.tickCulling = function tickCulling(culling) {
    var config = this.config;
    return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
  }, _proto.tickValues = function tickValues(x) {
    var _this = this,
        config = this.config;

    if (isFunction(x)) config.tickValues = function () {
      return x(_this.helper.scale.domain());
    };else {
      if (!arguments.length) return config.tickValues;
      config.tickValues = x;
    }
    return this;
  }, _proto.setTransition = function setTransition(t) {
    return this.config.transition = t, this;
  }, AxisRenderer;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/Axis.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var Axis_Axis =
/*#__PURE__*/
function () {
  function Axis(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "axesList", {}), _defineProperty(this, "tick", {
      x: null,
      y: null,
      y2: null
    }), _defineProperty(this, "xs", []), _defineProperty(this, "orient", {
      x: "bottom",
      y: "left",
      y2: "right",
      subX: "bottom"
    }), this.owner = owner, this.setOrient();
  }

  var _proto = Axis.prototype;
  return _proto.getAxisClassName = function getAxisClassName(id) {
    return config_classes.axis + " " + config_classes["axis" + capitalize(id)];
  }, _proto.isHorizontal = function isHorizontal($$, forHorizontal) {
    var isRotated = $$.config.axis_rotated;
    return forHorizontal ? isRotated : !isRotated;
  }, _proto.init = function init() {
    var _this = this,
        $$ = this.owner,
        config = $$.config,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        axis = _$$$$el.axis,
        clip = $$.state.clip,
        isRotated = config.axis_rotated,
        target = ["x", "y"];

    config.axis_y2_show && target.push("y2"), target.forEach(function (v) {
      var classAxis = _this.getAxisClassName(v),
          axisId = v.toUpperCase(),
          classLabel = config_classes["axis" + axisId + "Label"];

      axis[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
        var res = null;
        return v === "x" ? res = clip.pathXAxis : v === "y" && config.axis_y_inner && (res = clip.pathYAxis), res;
      }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_" + v + "_show"] ? "visible" : "hidden"), axis[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", _this["textAnchorFor" + axisId + "AxisLabel"].bind(_this)), _this.generateAxes(v);
    });
  }
  /**
   * Set axis orient according option value
   * @private
   */
  , _proto.setOrient = function setOrient() {
    var $$ = this.owner,
        _$$$config = $$.config,
        isRotated = _$$$config.axis_rotated,
        yInner = _$$$config.axis_y_inner,
        y2Inner = _$$$config.axis_y2_inner;
    this.orient = {
      x: isRotated ? "left" : "bottom",
      y: isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left",
      y2: isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right",
      subX: isRotated ? "left" : "bottom"
    };
  }
  /**
   * Generate axes
   * It's used when axis' axes option is set
   * @param {String} id Axis id
   * @private
   */
  , _proto.generateAxes = function generateAxes(id) {
    var d3Axis,
        $$ = this.owner,
        config = $$.config,
        axes = [],
        axesConfig = config["axis_" + id + "_axes"],
        isRotated = config.axis_rotated;
    id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
      var tick = v.tick || {},
          scale = $$.scale[id].copy();
      v.domain && scale.domain(v.domain), axes.push(d3Axis(scale).ticks(tick.count).tickFormat(tick.format || function (x) {
        return x;
      }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
    }), this.axesList[id] = axes;
  }
  /**
   * Update axes nodes
   * @private
   */
  , _proto.updateAxes = function updateAxes() {
    var _this2 = this,
        $$ = this.owner,
        config = $$.config,
        main = $$.$el.main;

    Object.keys(this.axesList).forEach(function (id) {
      var axesConfig = config["axis_" + id + "_axes"],
          scale = $$.scale[id].copy(),
          range = scale.range();

      _this2.axesList[id].forEach(function (v, i) {
        var axisRange = v.scale().range(); // adjust range value with the current
        // https://github.com/naver/billboard.js/issues/859

        range.every(function (v, i) {
          return v === axisRange[i];
        }) || v.scale().range(range);
        var className = _this2.getAxisClassName(id) + "-" + (i + 1),
            g = main.select("." + className.replace(/\s/, "."));
        g.empty() ? g = main.append("g").attr("class", className).style("visibility", config["axis_" + id + "_show"] ? "visible" : "hidden").call(v) : (axesConfig[i].domain && scale.domain(axesConfig[i].domain), $$.axis.x.helper.transitionise(g).call(v.scale(scale))), g.attr("transform", $$.getTranslate(id, i + 1));
      });
    });
  } // called from : updateScales() & getMaxTickWidth()
  , _proto.getAxis = function getAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
    var $$ = this.owner,
        config = $$.config,
        isX = /^(x|subX)$/.test(name),
        type = isX ? "x" : name,
        isCategory = isX && $$.isCategorized(),
        orient = this.orient[name],
        tickFormat = isX ? $$.format.xAxisTick : config["axis_" + name + "_tick_format"],
        tickValues = $$.axis.tick[type],
        axisParams = mergeObj({
      outerTick: outerTick,
      noTransition: noTransition,
      config: config,
      name: name,
      tickTextRotate: noTickTextRotate ? 0 : config["axis_" + type + "_tick_rotate"]
    }, isX && {
      isCategory: isCategory,
      tickMultiline: config.axis_x_tick_multiline,
      tickWidth: config.axis_x_tick_width,
      tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
      orgXScale: $$.scale.x
    });
    isX || (axisParams.tickStepSize = config["axis_" + type + "_tick_stepSize"]);
    var axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.scale.zoom || scale).orient(orient);
    return isX && $$.isTimeSeries() && tickValues && !isFunction(tickValues) ? tickValues = tickValues.map(function (v) {
      return $$.parseDate(v);
    }) : !isX && $$.isTimeSeriesY() && (axis.ticks(config.axis_y_tick_time_value), tickValues = null), tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
      return x + "%";
    }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1)), config["axis_" + type + "_tick_count"] && axis.ticks(config["axis_" + type + "_tick_count"]), axis;
  }, _proto.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
    var values,
        $$ = this.owner,
        config = $$.config,
        fit = config.axis_x_tick_fit,
        count = config.axis_x_tick_count;
    return (fit || count && fit) && (values = this.generateTickValues($$.mapTargetsToUniqueXs(targets), count, $$.isTimeSeries())), axis ? axis.tickValues(values) : $$.axis.x && ($$.axis.x.tickValues(values), $$.axis.subX && $$.axis.subX.tickValues(values)), values;
  }, _proto.getId = function getId(id) {
    var _this$owner = this.owner,
        config = _this$owner.config,
        scale = _this$owner.scale,
        axis = config.data_axes[id];
    return axis && scale[axis] || (axis = "y"), axis;
  }, _proto.getXAxisTickFormat = function getXAxisTickFormat() {
    var currFormat,
        $$ = this.owner,
        config = $$.config,
        format = $$.format,
        tickFormat = config.axis_x_tick_format,
        isTimeSeries = $$.isTimeSeries(),
        isCategorized = $$.isCategorized();
    return tickFormat ? isFunction(tickFormat) ? currFormat = tickFormat : isTimeSeries && (currFormat = function (date) {
      return date ? format.axisTime(tickFormat)(date) : "";
    }) : currFormat = isTimeSeries ? format.defaultAxisTime : isCategorized ? $$.categoryName : function (v) {
      return v < 0 ? v.toFixed(0) : v;
    }, isFunction(currFormat) ? function (v) {
      return currFormat.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
    } : currFormat;
  }, _proto.getTickValues = function getTickValues(id) {
    var $$ = this.owner,
        tickValues = $$.config["axis_" + id + "_tick_values"],
        axis = $$[id + "Axis"];
    return (isFunction(tickValues) ? tickValues() : tickValues) || (axis ? axis.tickValues() : undefined);
  }, _proto.getLabelOptionByAxisId = function getLabelOptionByAxisId(id) {
    return this.owner.config["axis_" + id + "_label"];
  }, _proto.getLabelText = function getLabelText(id) {
    var option = this.getLabelOptionByAxisId(id);
    return isString(option) ? option : option ? option.text : null;
  }, _proto.setLabelText = function setLabelText(id, text) {
    var $$ = this.owner,
        config = $$.config,
        option = this.getLabelOptionByAxisId(id);
    isString(option) ? config["axis_" + id + "_label"] = text : option && (option.text = text);
  }, _proto.getLabelPosition = function getLabelPosition(id, defaultPosition) {
    var isRotated = this.owner.config.axis_rotated,
        option = this.getLabelOptionByAxisId(id),
        position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
        has = function (v) {
      return !!~position.indexOf(v);
    };

    return {
      isInner: has("inner"),
      isOuter: has("outer"),
      isLeft: has("left"),
      isCenter: has("center"),
      isRight: has("right"),
      isTop: has("top"),
      isMiddle: has("middle"),
      isBottom: has("bottom")
    };
  }, _proto.getXAxisLabelPosition = function getXAxisLabelPosition() {
    return this.getLabelPosition("x", ["inner-top", "inner-right"]);
  }, _proto.getYAxisLabelPosition = function getYAxisLabelPosition() {
    return this.getLabelPosition("y", ["inner-right", "inner-top"]);
  }, _proto.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
    return this.getLabelPosition("y2", ["inner-right", "inner-top"]);
  }, _proto.getLabelPositionById = function getLabelPositionById(id) {
    return this["get" + id.toUpperCase() + "AxisLabelPosition"]();
  }, _proto.textForXAxisLabel = function textForXAxisLabel() {
    return this.getLabelText("x");
  }, _proto.textForYAxisLabel = function textForYAxisLabel() {
    return this.getLabelText("y");
  }, _proto.textForY2AxisLabel = function textForY2AxisLabel() {
    return this.getLabelText("y2");
  }, _proto.xForAxisLabel = function xForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        x = position.isMiddle ? -height / 2 : 0;
    return this.isHorizontal($$, forHorizontal) ? x = position.isLeft ? 0 : position.isCenter ? width / 2 : width : position.isBottom && (x = -$$.state.height), x;
  }, _proto.dxForAxisLabel = function dxForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        dx = position.isBottom ? "0.5em" : "0";
    return this.isHorizontal($$, forHorizontal) ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
  }, _proto.textAnchorForAxisLabel = function textAnchorForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        anchor = position.isMiddle ? "middle" : "end";
    return this.isHorizontal($$, forHorizontal) ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
  }, _proto.xForXAxisLabel = function xForXAxisLabel() {
    return this.xForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.xForYAxisLabel = function xForYAxisLabel() {
    return this.xForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.xForY2AxisLabel = function xForY2AxisLabel() {
    return this.xForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.dxForXAxisLabel = function dxForXAxisLabel() {
    return this.dxForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.dxForYAxisLabel = function dxForYAxisLabel() {
    return this.dxForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.dxForY2AxisLabel = function dxForY2AxisLabel() {
    return this.dxForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.dyForXAxisLabel = function dyForXAxisLabel() {
    var $$ = this.owner,
        config = $$.config,
        isInner = this.getXAxisLabelPosition().isInner,
        xHeight = config.axis_x_height;
    return config.axis_rotated ? isInner ? "1.2em" : -25 - this.getMaxTickWidth("x") : isInner ? "-0.5em" : xHeight ? xHeight - 10 : "3em";
  }, _proto.dyForYAxisLabel = function dyForYAxisLabel() {
    var $$ = this.owner,
        isInner = this.getYAxisLabelPosition().isInner;
    return $$.config.axis_rotated ? isInner ? "-0.5em" : "3em" : isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth("y") + 10);
  }, _proto.dyForY2AxisLabel = function dyForY2AxisLabel() {
    var $$ = this.owner,
        isInner = this.getY2AxisLabelPosition().isInner;
    return $$.config.axis_rotated ? isInner ? "1.2em" : "-2.2em" : isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth("y2") + 15);
  }, _proto.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
    return this.textAnchorForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
    return this.textAnchorForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
    return this.textAnchorForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
    var $$ = this.owner,
        config = $$.config,
        _$$$$el2 = $$.$el,
        svg = _$$$$el2.svg,
        chart = _$$$$el2.chart,
        currentTickMax = $$.state.currentMaxTickWidths[id],
        maxWidth = 0;
    if (withoutRecompute || !config["axis_" + id + "_show"]) return currentTickMax.size;

    if (svg) {
      var isYAxis = /^y2?$/.test(id),
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          scale = $$.scale[id].copy().domain($$["get" + (isYAxis ? "Y" : "X") + "Domain"](targetsToShow, id)),
          domain = scale.domain();
      // do not compute if domain is same
      if (isArray(currentTickMax.domain) && currentTickMax.domain.every(function (v, i) {
        return v === domain[i];
      })) return currentTickMax.size;
      currentTickMax.domain = domain;
      var axis = this.getAxis(id, scale, !1, !1, !0),
          tickCount = config["axis_" + id + "_tick_count"];
      tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? $$.isTimeSeriesY() : $$.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
      var dummy = chart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
      axis.create(dummy), dummy.selectAll("text").each(function () {
        maxWidth = Math.max(maxWidth, this.getBoundingClientRect().width);
      }), dummy.remove();
    }

    return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
  }, _proto.updateLabels = function updateLabels(withTransition) {
    var _this3 = this,
        $$ = this.owner,
        main = $$.$el.main,
        labels = {
      X: main.select("." + config_classes.axisX + " ." + config_classes.axisXLabel),
      Y: main.select("." + config_classes.axisY + " ." + config_classes.axisYLabel),
      Y2: main.select("." + config_classes.axisY2 + " ." + config_classes.axisY2Label)
    };

    Object.keys(labels).filter(function (id) {
      return !labels[id].empty();
    }).forEach(function (v) {
      var node = labels[v],
          axisLabel = v + "AxisLabel";
      (withTransition ? node.transition() : node).attr("x", _this3["xFor" + axisLabel].bind(_this3)).attr("dx", _this3["dxFor" + axisLabel].bind(_this3)).attr("dy", _this3["dyFor" + axisLabel].bind(_this3)).text(_this3["textFor" + axisLabel].bind(_this3));
    });
  }, _proto.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
    var p = isNumber(padding) ? padding : padding[key];
    return isValue(p) ? this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
  }, _proto.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
    var $$ = this.owner,
        config = $$.config,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        length = config.axis_rotated ? width : height;
    return domainLength * (pixels / length);
  }, _proto.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
    var start,
        end,
        count,
        interval,
        i,
        tickValue,
        tickValues = values;

    if (tickCount) {
      var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

      if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
        var isCategorized = this.owner.isCategorized();

        for (count = targetCount - 2, start = values[0], end = values[values.length - 1], interval = (end - start) / (count + 1), tickValues = [start], i = 0; i < count; i++) tickValue = +start + interval * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : isCategorized ? Math.round(tickValue) : tickValue);

        tickValues.push(end);
      }
    }

    return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
      return a - b;
    })), tickValues;
  }, _proto.generateTransitions = function generateTransitions(duration) {
    var $$ = this.owner,
        axis = $$.$el.axis,
        _map = ["x", "y", "y2", "subX"].map(function (v) {
      var ax = axis[v];
      return ax && duration && (ax = ax.transition().duration(duration)), ax;
    }),
        axisX = _map[0],
        axisY = _map[1],
        axisY2 = _map[2],
        axisSubX = _map[3];

    return {
      axisX: axisX,
      axisY: axisY,
      axisY2: axisY2,
      axisSubX: axisSubX
    };
  }, _proto.redraw = function redraw(transitions, isHidden, isInit) {
    var $$ = this.owner,
        config = $$.config,
        $el = $$.$el,
        opacity = isHidden ? "0" : "1";
    ["x", "y", "y2", "subX"].forEach(function (id) {
      var axis = $$.axis[id],
          $axis = $el.axis[id];
      axis && $axis && (!isInit && (axis.config.withoutTransition = !config.transition_duration), $axis.style("opacity", opacity), axis.create(transitions["axis" + capitalize(id)]));
    }), this.updateAxes();
  }
  /**
   * Redraw axis
   * @param {Object} targetsToShow targets data to be shown
   * @param {Object} wth
   * @param {Ojbect} transitions
   * @param {Object} flow
   * @private
   */
  , _proto.redrawAxis = function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
    var xDomainForZoom,
        _this4 = this,
        $$ = this.owner,
        config = $$.config,
        scale = $$.scale,
        $el = $$.$el,
        hasZoom = !!scale.zoom;

    !hasZoom && $$.isCategorized() && targetsToShow.length === 0 && scale.x.domain([0, $el.axis.x.selectAll(".tick").size()]), scale.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : $$.axis.x && ($$.axis.x.tickValues([]), $$.axis.subX && $$.axis.subX.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = scale.x.orgDomain()), ["y", "y2"].forEach(function (key) {
      var axis = scale[key];

      if (axis) {
        var tickValues = config["axis_" + key + "_tick_values"],
            tickCount = config["axis_" + key + "_tick_count"];

        if (axis.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
          var domain = axis.domain();
          $$[key + "Axis"].tickValues(_this4.generateTickValues(domain, domain.every(function (v) {
            return v === 0;
          }) ? 1 : tickCount, $$.isTimeSeriesY()));
        }
      }
    }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length && this.setCulling(), wth.Y && (scale.subY && scale.subY.domain($$.getYDomain(targetsToShow, "y")), scale.subY2 && scale.subY2.domain($$.getYDomain(targetsToShow, "y2")));
  }
  /**
   * Set manual culling
   * @private
   */
  , _proto.setCulling = function setCulling() {
    var $$ = this.owner,
        config = $$.config,
        $el = $$.$el;
    ["subX", "x", "y", "y2"].forEach(function (type) {
      var axis = $el.axis[type],
          id = type === "subX" ? "x" : type,
          toCull = config["axis_" + id + "_tick_culling"]; // subchart x axis should be aligned with x axis culling

      if (axis && toCull) {
        var intervalForCulling,
            tickText = axis.selectAll(".tick text"),
            tickValues = util_sortValue(tickText.data()),
            tickSize = tickValues.length,
            cullingMax = config["axis_" + id + "_tick_culling_max"];

        if (tickSize) {
          for (var _i = 1; _i < tickSize; _i++) if (tickSize / _i < cullingMax) {
            intervalForCulling = _i;
            break;
          }

          tickText.each(function (d) {
            this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
          });
        } else tickText.style("display", "block");
      }
    });
  }, Axis;
}();


// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(42);

// CONCATENATED MODULE: ./src/ChartInternal/data/data.convert.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Data convert
 * @memberof ChartInternal
 * @private
 */

/* harmony default export */ var data_convert = ({
  /**
   * Convert data according its type
   * @param {Object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @return {Object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_" + v;
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) this.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = this.convertJsonToData(data.json, data.keys);else if (data.rows) data = this.convertRowsToData(data.rows);else if (data.columns) data = this.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return isArray(data) && data;
  },

  /**
   * Convert URL data
   * @param {String} url Remote URL
   * @param {String} mimeType MIME type string: json | csv | tsv
   * @param {Object} headers Header object
   * @param {Object} keys Key object
   * @param {Function} done Callback function
   * @private
   */
  convertUrlToData: function convertUrlToData(url, mimeType, headers, keys, done) {
    var _this = this;

    mimeType === void 0 && (mimeType = "csv");
    var req = new XMLHttpRequest();
    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert" + capitalize(mimeType) + "ToData"](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error(url + ": Something went wrong loading!");
    }, req.send();
  },

  /**
   * Convert CSV/TSV data
   * @param {Object} parser Parser object
   * @param {Object} xsv Data
   * @private
   * @return {Object}
   */
  convertCsvTsvToData: function convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];
    return rows.forEach(function (row, i) {
      if (i > 0) {
        var newRow = {};
        row.forEach(function (v, j) {
          if (isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRow[keys[j]] = v;
        }), newRows.push(newRow);
      }
    }), newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];
    return columns.forEach(function (col, i) {
      var key = col[0];
      col.forEach(function (v, j) {
        if (j > 0) {
          if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRows[j - 1][key] = v;
        }
      });
    }), newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var xsData,
        _this3 = this,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isTimeSeries = $$.isTimeSeries(),
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];

    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      _this3.isCustomX() || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"" + id + "\".");
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter(id),
          xKey = $$.getXKey(id),
          isCategorized = $$.isCustomX() && $$.isCategorized(),
          hasCategory = isCategorized && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +value, isCategorized && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(value) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), state.hasNegativeValue = $$.hasNegativeValueInTargets(targets), state.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.cache.add(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var ChartInternal_data_data = ({
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && util_hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return !!(config.data_stack_normalize && config.data_groups.length);
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|Number|String} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @return {Number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this,
        config = $$.config;
    Object.keys(xs).forEach(function (id) {
      config.data_xs[id] = xs[id];
    });
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this,
        config = $$.config;
    return data && (name = config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },
  getAllValuesOnIndex: function getAllValuesOnIndex(index) {
    var $$ = this;
    return $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        x = $$.isCategorized() ? index : rawX || index;
    return $$.isTimeSeries() ? x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index)) : $$.isCustomX() && !$$.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index)), x;
  },
  updateXs: function updateXs(values) {
    values.length && (this.axis.xs = values.map(function (v) {
      return v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.axis.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.axis.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param data Data object
   * @return {Number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        value = data.value;
    return value && $$.isAxis && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @return {{min: {Number}, max: {Number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(value)), max = Math.max.apply(Math, [i ? max : -Infinity].concat(value));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @return {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = "$minMaxData",
        minMaxData = $$.cache.get(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.cache.add(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @return {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        sum = $$.cache.get("$totalPerIndex");
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @return {Number}
  	 * @private
   */
  getTotalDataSum: function getTotalDataSum() {
    var $$ = this,
        cacheKey = "$totalDataSum",
        totalDataSum = $$.cache.get(cacheKey);

    if (!totalDataSum) {
      var total = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.cache.add(cacheKey, totalDataSum = total);
    }

    return totalDataSum;
  },

  /**
   * Get filtered data by value
   * @param {Object} data
   * @param {Number} value
   * @return {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @return {Number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, this.data.targets.map(function (t) {
      return t.values.length;
    }));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget() {
    var target = this.filterTargetsToShow() || [],
        length = target.length;
    return length > 1 ? (target = target.map(function (t) {
      return t.values;
    }).reduce(function (a, b) {
      return a.concat(b);
    }).map(function (v) {
      return v.x;
    }), target = util_sortValue(getUnique(target)).map(function (x, index) {
      return {
        x: x,
        index: index
      };
    })) : length && (target = target[0].values), target;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.state.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.state.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = $$.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), util_sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, value) : isObject(value) && "high" in value ? data.push.apply(data, Object.values(value)) : $$.isBubbleZType(v) ? data.push($$.isAxis && $$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue
   * @return {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = [].concat(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();
    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isBoolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.$el.chart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        data = values.filter(function (v) {
      return v && isValue(v.value);
    }),
        minDist = config.point_sensitivity;
    return data.filter(function (v) {
      return $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = main.select("." + config_classes.bars + $$.getTargetSelectorSuffix(v.id) + " ." + config_classes.bar + "-" + v.index).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), data.filter(function (v) {
      return !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        scale = $$.scale,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = (scale.zoom || scale.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @return {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = $$.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length, value = converted[x - 1].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_" + name];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {String} type Ratio for given type
   * @param {Object} d Data value object
   * @param {Boolean} asPercent Convert the return as percent or not
   * @return {Number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        api = $$.api,
        ratio = 0;

    if (d && api.data.shown().length) {
      var dataValues = api.data.values.bind(api);
      if (ratio = d.ratio || d.value, type === "arc") {
          // if has padAngle set, calculate rate based on value
          if ($$.pie.padAngle()()) {
            var total = $$.getTotalDataSum();
            state.hiddenTargetIds.length && (total -= dataValues(state.hiddenTargetIds).reduce(function (p, c) {
              return p + c;
            })), ratio = d.value / total;
          } else ratio = (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));
      } else if (type === "index") {
        var _total = this.getTotalPerIndex();

        if (state.hiddenTargetIds.length) {
          var hiddenSum = dataValues(state.hiddenTargetIds, !1);
          hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
            return acc.map(function (v, i) {
              return (isNumber(v) ? v : 0) + curr[i];
            });
          }), _total = _total.map(function (v, i) {
            return v - hiddenSum[i];
          }));
        }

        d.ratio = isNumber(d.value) && _total && _total[d.index] > 0 ? d.value / _total[d.index] : 0, ratio = d.ratio;
      } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0) + "") / $$.maxValue * config.radar_size_ratio);
    }

    return asPercent && ratio ? ratio * 100 : ratio;
  },

  /**
   * Sort data index to be aligned with x axis.
   * @param {Array} tickValues Tick array values
   * @private
   */
  updateDataIndexByX: function updateDataIndexByX(tickValues) {
    var $$ = this,
        tickValueMap = tickValues.reduce(function (out, tick, index) {
      return out[+tick.x] = index, out;
    }, {});
    $$.data.targets.forEach(function (t) {
      t.values.forEach(function (value, valueIndex) {
        var index = tickValueMap[+value.x];
        index === undefined && (index = valueIndex), value.index = index;
      });
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var data_load = ({
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), args.done && args.done();
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.cache.reset();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      data && $$.load($$.convertDataToTargets(data), args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        state = $$.state,
        $el = $$.$el,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.cache.reset(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ($el.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
      state.withoutFadeIn[id] = !1, $el.legend && $el.legend.selectAll("." + config_classes.legendItem + $$.getTargetSelectorSuffix(id)).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    })) : void done();
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(43);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_interaction = ({
  /**
   * Handle data.onover/out callback options
   * @param {Boolean} isOver
   * @param {Number|Object} d
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      if (config.color_onover && $$.setOverColor(isOver, d, isArc), isArc) callback(d, main.select("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).node());else if (!config.tooltip_grouped) {
        var callee = $$.setOverOut,
            last = callee.last || [],
            shape = main.selectAll("." + config_classes.shape + "-" + d).filter(function (d) {
          return $$.isWithinShape(this, d);
        });
        shape.each(function (d) {
          var _this = this;

          (last.length === 0 || last.every(function (v) {
            return v !== _this;
          })) && (callback(d, this), last.push(this));
        }), last.length > 0 && shape.empty() && (callback = config.data_onout.bind($$.api), last.forEach(function (v) {
          return callback(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(v).datum(), v);
        }), last = []), callee.last = last;
      } else isOver && $$.expandCirclesBars(d, null, !0), $$.isMultipleX() || main.selectAll("." + config_classes.shape + "-" + d).each(function (d) {
        callback(d, this);
      });
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        callee = $$.callOverOutForTouch,
        last = callee.last;
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
  },

  /**
   * Return draggable selection function
   * @return {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      // @ts-ignore
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      // @ts-ignore
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {String} type event type
   * @param {Number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        isMultipleX = $$.isMultipleX(),
        selector = "." + (isMultipleX ? config_classes.eventRect : config_classes.eventRect + "-" + index),
        eventRect = $$.$el.main.select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX || $$.config.axis_rotated ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/class.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_class = ({
  generateClass: function generateClass(prefix, targetId) {
    return " " + prefix + " " + (prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return this.generateClass(config_classes.region, i) + " " + ("class" in d ? d.class : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " " + config_classes.target + "-" + additionalClassSuffix), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " " + (this.state.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " " + (this.state.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? ("-" + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    return (prefix || "") + "." + (config_classes.target + this.getTargetSelectorSuffix(id));
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return "." + (config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {String} color Color string
 * @param {String} id ID to be set
 * @return {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


/* harmony default export */ var internals_color = ({
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @return {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var body = browser_doc.body,
        pattern = body["__colorPattern__"];

    if (!pattern) {
      var span = browser_doc.createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = win.getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body["__colorPattern__"] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = $$.state.datetimeId + "-pattern-" + color + "-" + index;
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#" + p.id + ")";
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id](d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restate in its previous color value
   * @param {Boolean} isOver true: set overed color, false: restore
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (_ref) {
      var id = _ref.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) && (color = function () {
      return onover;
    }), isObject(d) ? main.selectAll("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).style("fill", color(d)) : main.selectAll("." + config_classes.shape + "-" + d).style("fill", color);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/domain.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_domain = ({
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has" + (isMin ? "Negative" : "Positive") + "ValueInTargets"](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = $$.axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = $$.axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return $$.axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;
    if (yTargets.length === 0) // use domain of the other axis if target of axisId is none
      return axisId === "y2" ? scale.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.
      // So, it needs to call to get y2 domain here
      $$.getYDomain(targets, "y2", xDomain);
    var yMin = config["axis_" + axisId + "_min"],
        yMax = config["axis_" + axisId + "_max"],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config["axis_" + axisId + "_center"],
        isZeroBased = ["area", "bar", "bubble", "line", "scatter"].some(function (v) {
      return $$.hasType(v, yTargets) && config[v + "_zerobased"];
    }),
        isInverted = config["axis_" + axisId + "_inverted"],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain(scale.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += $$.axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    }

    if (/^y2?$/.test(axisId)) {
      var p = config["axis_" + axisId + "_padding"];
      notEmpty(p) && ["bottom", "top"].forEach(function (v) {
        padding[v] = $$.axis.getPadding(p, v, padding[v], domainLength);
      });
    } // Bar/Area chart should be 0-based if all positive|negative


    isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        value = $$.config["axis_x_" + type];
    return isDefined(value) ? $$.isTimeSeries() ? $$.parseDate(value) : value : getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    }));
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        _xDomain = xDomain,
        firstX = _xDomain[0],
        lastX = _xDomain[1],
        padding = $$.getXDomainPadding(xDomain),
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        subX = _$$$scale.subX,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && (x.domain(domain || util_sortValue($$.getXDomain(targets))), org.xDomain = x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), subX.domain(x.domain()), $$.brush && $$.brush.scale(subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? org.xDomain : getBrushSelection($$).map(subX.invert);
      x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && x.domain($$.trimXDomain(x.orgDomain())), x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        min = zoomDomain[0],
        max = zoomDomain[1];
    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/format.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


function getFormat($$, typeValue, v) {
  var config = $$.config,
      type = "axis_" + typeValue + "_tick_format",
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
}

/* harmony default export */ var internals_format = ({
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        yFormat = $$.yFormat,
        y2Format = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (yFormat = $$.defaultArcValueFormat, y2Format = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis && $$.axis.getId(id) === "y2" ? y2Format : yFormat;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return (ratio * 100).toFixed(1) + "%";
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_legend = ({
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.state.legendHasRendered = !1, $el.legend = $$.$el.svg.append("g"), config.legend_show ? ($el.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegend()) : ($$.$el.legend.style("visibility", "hidden"), $$.state.hiddenLegendIds = $$.mapToIds($$.data.targets));
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {Object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        scale = $$.scale,
        $el = $$.$el,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !scale.zoom), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), state.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.call($$, v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $el.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @private
   * @param {Obejct} size S
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        isLegendTop = _$$$state.isLegendTop,
        isLegendLeft = _$$$state.isLegendLeft,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        currentWidth = _$$$state.currentWidth,
        currentHeight = _$$$state.currentHeight,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : currentHeight - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : currentWidth - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.state.margin3 = {
      top: isLegendRight ? 0 : isLegendInset ? insetLegendPosition.top : currentHeight - height,
      right: NaN,
      bottom: 0,
      left: isLegendRight ? currentWidth - width : isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @private
   * @param {Boolean} whether or not to transition.
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this,
        legend = $$.$el.legend;
    (withTransition ? legend.transition() : legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @private
   * @param {Number} step
   */
  updateLegendStep: function updateLegendStep(step) {
    this.state.legendStep = step;
  },

  /**
   * Update legend item width
   * @private
   * @param {Number} width
   */
  updateLegendItemWidth: function updateLegendItemWidth(w) {
    this.state.legendItemWidth = w;
  },

  /**
   * Update legend item height
   * @private
   * @param {Number} height
   */
  updateLegendItemHeight: function updateLegendItemHeight(h) {
    this.state.legendItemHeight = h;
  },

  /**
   * Update legend item color
   * @private
   * @param {String} id Corresponding data ID value
   * @param {String} color Color value
   */
  updateLegendItemColor: function updateLegendItemColor(id, color) {
    this.$el.legend.select("." + config_classes.legendItem + "-" + id + " line").style("stroke", color);
  },

  /**
   * Get the width of the legend
   * @private
   * @return {Number} width
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this,
        _$$$state2 = $$.state,
        currentWidth = _$$$state2.currentWidth,
        isLegendRight = _$$$state2.isLegendRight,
        isLegendInset = _$$$state2.isLegendInset,
        legendItemWidth = _$$$state2.legendItemWidth,
        legendStep = _$$$state2.legendStep;
    return $$.config.legend_show ? isLegendRight || isLegendInset ? legendItemWidth * (legendStep + 1) : currentWidth : 0;
  },

  /**
   * Get the height of the legend
   * @return {Number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this,
        _$$$state3 = $$.state,
        currentHeight = _$$$state3.currentHeight,
        isLegendRight = _$$$state3.isLegendRight,
        legendItemHeight = _$$$state3.legendItemHeight,
        legendStep = _$$$state3.legendStep;
    return $$.config.legend_show ? isLegendRight ? currentHeight : Math.max(20, legendItemHeight) * (legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @private
   * @param {Object} d3.Select
   * @returns {Number} opacity
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @private
   * @param {Object} legendItem, d3.Select
   * @returns {Number} opacity
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @private
   * @param {Array} ID's of target
   * @param {Boolean} whether or not to focus.
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        targetIdz = $$.mapToTargetIds(targetIds);
    $$.$el.legend.selectAll("." + config_classes.legendItem).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this;
    $$.$el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @private
   * @param {Array} ID's of target
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show || (config.legend_show = !0, legend.style("visibility", "visible"), !$$.state.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @private
   * @param {Array} ID's of target
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Get legend item textbox dimension
   * @param {String} id
   * @param {HTMLElement|d3.selection} textElement
   */
  getLegendItemTextBox: function getLegendItemTextBox(id, textElement) {
    var $$ = this,
        cache = $$.cache,
        cacheKey = "$legendItemTextBox";

    if (id) {
      var data = cache.get(cacheKey);
      return data || (data = {}), data[id] || (data[id] = $$.getTextRect(textElement, config_classes.legendItem), cache.add(cacheKey, data)), data[id];
    }

    cache.remove(cacheKey);
  },

  /**
   * Set legend item style & bind events
   * @private
   * @param {d3.selection} item
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        hasGauge = $$.hasType("gauge");
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, $$, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? ($$.api.hide(), $$.api.show(id)) : ($$.api.toggle(id), !isTouch && $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), hasGauge && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), hasGauge && $$.markOverlapped(id, $$, "." + config_classes.gaugeValue), !state.transiting && $$.isTargetToShow(id) && $$.api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
  	 * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        state = $$.state,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = state.isLegendRight || state.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = $$.getLegendItemTextBox(id, textElement),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = state.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    state.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), state.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : state.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        legend = $$.$el.legend,
        l = legend.selectAll("." + config_classes.legendItem).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#" + state.datetimeId + "-point-" + data : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = legend.select("." + config_classes.legendBackground + " rect"), state.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = legend.insert("g", "." + config_classes.legendItem).attr("class", config_classes.legendBackground).append("rect"));
    var texts = legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = legend.selectAll("rect." + config_classes.legendItemEvent).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = legend.selectAll("." + config_classes.legendItemPoint).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = legend.selectAll("line." + config_classes.legendItemTile).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.levelColor ? function (id) {
        return $$.levelColor($$.cache.get(id).values[0].value);
      } : $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/scale.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_scale = ({
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @param {Function} offset The offset getter to be sum
   * @return {Function} scale
   * @private
   */
  getX: function getX(min, max, domain, offset) {
    var $$ = this,
        scale = $$.scale.zoom || $$.getScale(min, max, $$.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @return {Function} scale
   * @private
   */
  getY: function getY(min, max, domain) {
    var scale = this.getScale(min, max, this.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue
   * @param {Function} offsetValue Offset getter to be sum
   * @return {} scale
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.axis.x.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },
  getYScale: function getYScale(id) {
    var _this$scale = this.scale,
        y = _this$scale.y,
        y2 = _this$scale.y2;
    return this.axis.getId(id) === "y2" ? y2 : y;
  },
  getSubYScale: function getSubYScale(id) {
    var _this$scale2 = this.scale,
        subY = _this$scale2.subY,
        subY2 = _this$scale2.subY2;
    return this.axis.getId(id) === "y2" ? subY2 : subY;
  },

  /**
   * Update scale
   * @private
   * @param {Boolean} isInit - param is given at the init rendering
   */
  updateScales: function updateScales(isInit, updateXDomain) {
    updateXDomain === void 0 && (updateXDomain = !0);
    var $$ = this,
        axis = $$.axis,
        config = $$.config,
        format = $$.format,
        org = $$.org,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        width2 = _$$$state.width2,
        height2 = _$$$state.height2;

    if ($$.isAxis) {
      var isRotated = config.axis_rotated,
          min = {
        x: isRotated ? 1 : 0,
        y: isRotated ? 0 : height,
        subX: isRotated ? 1 : 0,
        subY: isRotated ? 0 : height2
      },
          max = {
        x: isRotated ? height : width,
        y: isRotated ? width : 1,
        subX: isRotated ? height : width,
        subY: isRotated ? width2 : 1
      },
          xDomain = updateXDomain && scale.x && scale.x.orgDomain(),
          xSubDomain = updateXDomain && org.xDomain; // update edges

      // y Axis
      scale.x = $$.getX(min.x, max.x, xDomain, function () {
        return axis.x.tickOffset();
      }), scale.subX = $$.getX(min.x, max.x, xSubDomain, function (d) {
        return d % 1 ? 0 : axis.subX.tickOffset();
      }), format.xAxisTick = axis.getXAxisTickFormat(), axis.tick.x = axis.getTickValues("x"), axis.x = axis.getAxis("x", scale.x, config.axis_x_tick_outer, isInit), config.subchart_show && (axis.subX = axis.getAxis("subX", scale.subX, config.axis_x_tick_outer, isInit)), scale.y = $$.getY(min.y, max.y, scale.y ? scale.y.domain() : config.axis_y_default), scale.subY = $$.getY(min.subY, max.subY, scale.subY ? scale.subY.domain() : config.axis_y_default), axis.tick.y = axis.getTickValues("y"), axis.y = axis.getAxis("y", scale.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && (scale.y2 = $$.getY(min.y, max.y, scale.y2 ? scale.y2.domain() : config.axis_y2_default), scale.subY2 = $$.getY(min.subY, max.subY, scale.subY2 ? scale.subY2.domain() : config.axis_y2_default), axis.tick.y2 = axis.getTickValues("y2"), axis.y2 = axis.getAxis("y2", scale.y2, config.axis_y2_tick_outer, isInit));
    } else // update for arc
    $$.updateArc && $$.updateArc();
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/size.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_size = ({
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this,
        state = $$.state;
    state.currentWidth = $$.getCurrentWidth(), state.currentHeight = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {String} id Axis id value - x, y or y2
   * @return {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        isRotated = $$.config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $el.title && $el.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_" + axisId + "_axes"].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_" + axisId + "_axes"].length,
        axisWidth = $$.isAxis ? $$.getAxisWidthByAxisId(axisId, withoutRecompute) : 0;
    return padding = isValue(config.padding_left) ? config.padding_left : isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight() {
    var padding,
        $$ = this,
        config = $$.config,
        legendWidthOnRight = $$.state.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2");
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : $$.axis && config.axis_rotated ? 10 + legendWidthOnRight : $$.axis && (!config.axis_y2_show || config.axis_y2_inner) ? 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : ceil10(axisWidth) + legendWidthOnRight, padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {String} key property/attribute name
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset" + capitalize(key), parent = this.$el.chart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser_doc.body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.$el.chart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $el.main.select("." + leftAxisClass).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $el.chart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this;

    if ($$.axis) {
      var position = $$.axis && $$.axis.getLabelPositionById(id);
      return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
    }

    return 40;
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        rotatedPadding = _$$$state.rotatedPadding,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        isRotated = config.axis_rotated,
        h = 30;
    if (id === "x" && !config.axis_x_show) return 8;
    if (id === "x" && config.axis_x_height) return config.axis_x_height;
    if (id === "y" && !config.axis_y_show) return !config.legend_show || isLegendRight || isLegendInset ? 1 : 10;
    if (id === "y2" && !config.axis_y2_show) return rotatedPadding.top;
    var rotate = config["axis_" + id + "_tick_rotate"]; // Calculate x/y axis height when tick rotated

    return (id === "x" && !isRotated || /y2?/.test(id) && isRotated) && rotate && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - rotate) / 180)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10);
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.axis.x.tickInterval());
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/text.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_text = ({
  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var main = this.$el.main;
    main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartTexts);
  },

  /**
   * Update chartText
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.$el.main.select("." + config_classes.chartTexts).selectAll("." + config_classes.chartText).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").attr("class", classChartText).style("opacity", "0").style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $el.text = $el.main.selectAll("." + config_classes.texts).selectAll("." + config_classes.text).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $el.text.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $el.text = $el.text.enter().append("text").merge($$.$el.text).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {Boolean} forFlow
   * @param {Boolean} withTransition transition is enabled
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    return [this.$el.text.each(function () {
      var text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this); // do not apply transition for newly added text elements

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x).attr("y", y).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    })];
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @private
   * @param {HTMLElement|d3.selection} element
   * @param {String} className
   * @returns {Object} value of element.getBoundingClientRect()
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = "$" + text.replace(/\W/g, "_"),
        rect = $$.cache.get(cacheKey);
    return rect || ($$.$el.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = getBoundingRect(v.node());
    }).remove(), $$.cache.add(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {Object} indices Indices values
   * @param {Boolean} forX whether or not to x
   * @returns {Number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet" + capitalize(v) + "Points"](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @private
   * @param {Object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {Number} Position value
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = getBoundingRect(textElement),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Get data.labels.position value
   * @param {String} id Data id value
   * @param {String} type x | y
   * @return {Number} Position value
   * @private
   */
  getTextPos: function getTextPos(id, type) {
    var pos = this.config.data_labels_position;
    return (id in pos ? pos[id] : pos)[type] || 0;
  },

  /**
   * Gets the x coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} x coordinate
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated;
    // show labels regardless of the domain if value is null
    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > state.width) {
      var _getBoundingRect = getBoundingRect(textElement),
          width = _getBoundingRect.width;

      xPos = state.width - width;
    } else xPos < 0 && (xPos = 4);
    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + $$.getTextPos(d.id, "x");
  },

  /**
   * Gets the y coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} y coordinate
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = getBoundingRect(textElement),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !state.hasPositiveValue && state.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + $$.getTextPos(d.id, "y");
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Mark overlapping text nodes with "text-overlapping" class
   * @private
   * @param {number} id
   * @param {ChartInternal} $$
   * @param {string} selector
   */
  markOverlapped: function markOverlapped(id, $$, selector) {
    var textNodes = $$.$el.arcs.selectAll(selector),
        filteredTextNodes = textNodes.filter(function (node) {
      return node.data.id !== id;
    }),
        textNode = textNodes.filter(function (node) {
      return node.data.id === id;
    }),
        translate = getTranslation(textNode.node()),
        calcHypo = function (x, y) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    textNode.node() && filteredTextNodes.each(function () {
      var coordinate = getTranslation(this),
          filteredTextNode = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          nodeForWidth = calcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ? textNode : filteredTextNode,
          overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) < Math.ceil(nodeForWidth.node().getComputedTextLength()),
          overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) < parseInt(textNode.style("font-size"), 0);
      filteredTextNode.classed(config_classes.TextOverlapping, overlapsX && overlapsY);
    });
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Remove "text-overlapping" class on selected text nodes
   * @private
   * @param {ChartInternal} $$
   * @param {string} selector
   */
  undoMarkOverlapped: function undoMarkOverlapped($$, selector) {
    $$.$el.arcs.selectAll(selector).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([this, this.previousSibling]).classed(config_classes.TextOverlapping, !1);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get the text position
 * @param {String} pos right, left or center
 * @param {Number} width chart width
 * @return {String|Number} text-anchor value or position in pixel
 * @private
 */

function getTextPos(pos, width) {
  pos === void 0 && (pos = "left");
  var position,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
}

/* harmony default export */ var internals_title = ({
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.title_text) {
      $el.title = $el.svg.append("g");
      var text = $el.title.append("text").style("text-anchor", getTextPos(config.title_position)).attr("class", config_classes.title);
      setTextValue(text, config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this,
        config = $$.config,
        currentWidth = $$.state.currentWidth,
        title = $$.$el.title;

    if (title) {
      var y = $$.yForTitle.call($$);
      /g/i.test(title.node().tagName) ? title.attr("transform", "translate(" + getTextPos(config.title_position, currentWidth) + ", " + y + ")") : title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @private
   * @returns {Number} x attribute value
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        currentWidth = $$.state.currentWidth,
        position = config.title_position || "left",
        textRectWidth = $$.getTextRect($$.$el.title, config_classes.title).width;
    return /(right|center)/.test(position) ? (x = currentWidth - textRectWidth, position.indexOf("right") >= 0 ? x = currentWidth - textRectWidth - config.title_padding.right : position.indexOf("center") >= 0 && (x = (currentWidth - textRectWidth) / 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @private
   * @returns {Number} y attribute value
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.$el.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @private
   * @returns {Number} padding value
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_tooltip = ({
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($el.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $el.tooltip.empty() && ($el.tooltip = $el.chart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = $$.parseDate(config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $el.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $el.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }
  },

  /**
   * Get the tooltip HTML string
   * @param  {...any} args
   * @private
   * @return {String} Formatted HTML string
   */
  getTooltipHTML: function getTooltipHTML() {
    for (var _config$tooltip_conte, _$$2, $$ = this, config = $$.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return isFunction(config.tooltip_contents) ? (_config$tooltip_conte = config.tooltip_contents).call.apply(_config$tooltip_conte, [$$].concat(args)) : (_$$2 = $$).getTooltipContent.apply(_$$2, args);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {Object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {String} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        config = $$.config,
        titleFormat = config.tooltip_format_title || defaultTitleFormat,
        nameFormat = config.tooltip_format_name || function (name) {
      return name;
    },
        valueFormat = config.tooltip_format_value || ($$.isStackNormalized() ? function (v, ratio) {
      return (ratio * 100).toFixed(2) + "%";
    } : defaultValueFormat),
        order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.axis && $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template,
        targetIds = $$.mapToTargetIds();

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order);

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr),
        len = d.length;

    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">" + title + "</th></tr>" : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(param))), $$.isAreaRangeType(row)) {
        var _map = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(param)));
        }),
            high = _map[0],
            low = _map[1];

        value = "<b>Mid:</b> " + value + " <b>High:</b> " + high + " <b>Low:</b> " + low;
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(param))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:" + color + "\" width=\"10\" height=\"10\"></rect></svg>",
            NAME: name,
            VALUE: value
          };

          if (tplStr && isObject(contents.text)) {
            var index = targetIds.indexOf(row.id);
            Object.keys(contents.text).forEach(function (key) {
              contentValue[key] = contents.text[key][index];
            });
          }

          text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return text + "</table>";
  },

  /**
   * Get the content template string
   * @param {String} tplStr
   * @return {String} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">" + (this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>") + "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>").replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {Object} dataToShow data
   * @param {String} tWidth Width value of tooltip element
   * @param {String} tHeight Height value of tooltip element
   * @param {HTMLElement} element
   * @returns {Object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        currentWidth = _$$$state.currentWidth,
        currentHeight = _$$$state.currentHeight,
        isLegendRight = _$$$state.isLegendRight,
        inputType = _$$$state.inputType,
        hasGauge = $$.hasType("gauge") && !config.gauge_fullCircle,
        svgLeft = $$.getSvgLeft(!0),
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        left = _d3Mouse[0],
        top = _d3Mouse[1],
        chartRight = svgLeft + currentWidth - $$.getCurrentPaddingRight();

    // Determine tooltip position
    if (top += 20, $$.hasArcType()) {
      var raw = inputType === "touch" || $$.hasType("radar");
      raw || (top += hasGauge ? height : height / 2, left += (width - (isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = scale.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + 20, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + $$.getCurrentPaddingLeft(!0) + 20 + (scale.zoom ? left : dataScale));
    }

    var right = left + tWidth;
    return right > chartRight && (left -= right - chartRight + 20), top + tHeight > currentHeight && (top -= hasGauge ? tHeight * 3 : tHeight + 30), top < 0 && (top = 0), {
      top: top,
      left: left
    };
  },

  /**
   * Show the tooltip
   * @private
   * @param {Object} selectedData
   * @param {HTMLElement} element
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        tooltip = $$.$el.tooltip,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    }),
        positionFunction = config.tooltip_position || $$.tooltipPosition;

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = tooltip.datum(),
          dataStr = JSON.stringify(selectedData),
          width = datum && datum.width || 0,
          height = datum && datum.height || 0;

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$, $$.api, selectedData), tooltip.html($$.getTooltipHTML(selectedData, $$.axis && $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", null).style("visibility", null) // for IE9
        .datum({
          index: index,
          current: dataStr,
          width: width = tooltip.property("offsetWidth"),
          height: height = tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$, $$.api, selectedData), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        // Get tooltip dimensions
        var position = positionFunction.call(this, dataToShow, width, height, element); // Set tooltip position

        tooltip.style("top", position.top + "px").style("left", position.left + "px");
      }
    }
  },

  /**
   * Hide the tooltip
   * @param {Boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        config = $$.config,
        tooltip = $$.$el.tooltip;

    if (tooltip.style("display") !== "none" && (!config.tooltip_doNotHide || force)) {
      var selectedData = JSON.parse(tooltip.datum().current);
      // hide tooltip
      callFn(config.tooltip_onhide, $$, $$.api, selectedData), tooltip.style("display", "none").style("visibility", "hidden") // for IE9
      .datum(null), callFn(config.tooltip_onhidden, $$, $$.api, selectedData);
    }
  },

  /**
   * Toggle display for linked chart instances
   * @param {Boolean} show true: show, false: hide
   * @param {Number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this,
        charts = $$.charts,
        config = $$.config;

    if (config.tooltip_linked && charts.length > 1) {
      var linkedName = config.tooltip_linked_name;
      charts.forEach(function (c) {
        if (c !== $$.api) {
          var _config = c.internal.config,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser_doc.body.contains(c.element);

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.$el.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/config/const.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
// defined chart types as category
var TYPES = {
  Area: ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"],
  AreaRange: ["area-spline-range", "area-line-range"],
  Arc: ["pie", "donut", "gauge", "radar"],
  Line: ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"],
  Step: ["step", "area-step"],
  Spline: ["spline", "area-spline", "area-spline-range"]
};
// CONCATENATED MODULE: ./src/ChartInternal/internals/type.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var internals_type = ({
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config,
        withoutFadeIn = $$.state.withoutFadeIn;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },
  hasType: function hasType(type, targetsValue) {
    var $$ = this,
        config = $$.config,
        types = config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      (t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @parma {String} type Type key
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets, exclude) {
    var _this = this;

    return exclude === void 0 && (exclude = []), !TYPES[type] // @ts-ignore
    .filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {Object} d Data object
   * @param {String|Array} type chart type
   * @return {Boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },

  /**
   * Check if contains arc types chart
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  hasMultiArcGauge: function hasMultiArcGauge() {
    return this.hasType("gauge") && this.config.gauge_type === "multi";
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPES.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPES.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPES.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPES.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPES.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint() {
    var config = this.config,
        pattern = config.point_pattern;
    return config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0);
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {Object} d Data object
   * @return {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Set the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @param {Object} value
 * @return {undefined}
 * @private
 */

function setMinMax($$, type, value) {
  var config = $$.config,
      axisY = "axis_y_" + type,
      axisY2 = "axis_y2_" + type;
  return isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config["axis_x_" + type] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  })), undefined;
}
/**
 * Get the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @return {{x, y, y2}}
 * @private
 */


function axis_getMinMax($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_" + type],
    y: config["axis_y_" + type],
    y2: config["axis_y2_" + type]
  };
}
/**
 * Define axis
 * @ignore
 */


var api_axis_axis = {
  /**
   * Get and set axis labels.
   * @method axis․labels
   * @instance
   * @memberof Chart
   * @param {Object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @method axis․min
   * @instance
   * @memberof Chart
   * @param {Object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return isValue(_min) ? setMinMax($$, "min", _min) : axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @method axis․max
   * @instance
   * @memberof Chart
   * @param {Object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @method axis․range
   * @instance
   * @memberof Chart
   * @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
};
/* harmony default export */ var api_axis = ({
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/Chart/api/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var category = ({
  /**
   * Set specified category name on category axis.
   * @method category
   * @instance
   * @memberof Chart
   * @param {Number} i index of category to be changed
   * @param {String} category category value to be changed
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @method categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/Chart/api/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_flow = ({
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @method flow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [data․json](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [data․rows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [data․columns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
      *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && $$.isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0);
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, $$.isTimeSeries() || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, $$.isTimeSeries() || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
});
// CONCATENATED MODULE: ./src/Chart/api/grid.x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update x grid lines.
 * @method xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 */

function xgrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
}

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @method xgrids․add
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @method xgrids․remove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});
/* harmony default export */ var grid_x = ({
  xgrids: xgrids
});
// CONCATENATED MODULE: ./src/Chart/api/grid.y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update y grid lines.
 * @method ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 */

function ygrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  if (!grids) return config.grid_y_lines;
  config.grid_y_lines = grids;

  http: //jindo.com/git/billboard.js/demo/work/chart.html
  $$.redrawWithoutRescale();

  return config.grid_y_lines;
}

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @method ygrids․add
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @method ygrids․remove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
});
/* harmony default export */ var grid_y = ({
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/Chart/api/group.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var group = ({
  /**
   * Update groups for the targets.
   * @method groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @return {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/Chart/api/regions.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update regions.
 * @method regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @return {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */

function regions_regions(regions) {
  var $$ = this.internal,
      config = $$.config;
  return regions ? (config.regions = regions, $$.redrawWithoutRescale(), regions) : config.regions;
}

extend(regions_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @method regions․add
   * @instance
   * @memberof Chart
   * @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @return {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @method regions․remove
   * @instance
   * @memberof Chart
   * @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @return {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.$el.main.select("." + config_classes.regions).selectAll(classes.map(function (c) {
      return "." + c;
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region.class || (region.class.split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
});
/* harmony default export */ var api_regions = ({
  regions: regions_regions
});
// CONCATENATED MODULE: ./src/Chart/api/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var api_selection = ({
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @method selected
   * @instance
   * @memberof Chart
   * @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.$el.main.selectAll("." + (config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll("." + config_classes.shape).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @method select
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {Boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @method unselect
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config,
        $el = $$.$el;
    config.data_selection_enabled && $el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/Chart/api/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_x = ({
  /**
   * Get and set x values for the chart.
   * @method x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        isCategorized = $$.isCustomX() && $$.isCategorized();
    return isArray(_x) && (isCategorized ? this.categories(_x) : ($$.updateTargetX($$.data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? this.categories() : $$.data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @method xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(44);

// CONCATENATED MODULE: ./src/Chart/api/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Check if the given domain is within zoom range
 * @param {Array} domain
 * @return {Boolean}
 * @private
 */

function withinRange(domain, range) {
  var min = range[0],
      max = range[1];
  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
}

/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @method zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @return {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */
var zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      config = $$.config,
      scale = $$.scale,
      domain = domainValue;

  if (config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.isTimeSeries();

    if (isTimeSeries && (domain = domain.map(function (x) {
      return $$.parseDate(x);
    })), config.subchart_show) {
      var xScale = scale.zoom || scale.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else scale.x.domain(domain), scale.zoom = scale.x, $$.axis.x.scale(scale.zoom), resultDomain = scale.zoom.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn(config.zoom_onzoom, this, resultDomain);
  } else resultDomain = scale.zoom ? scale.zoom.domain() : scale.x.orgDomain();

  return resultDomain;
};

extend(zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @method zoom․enable
   * @instance
   * @memberof Chart
   * @param {String|Boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable(enabled) {
    var $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @method zoom․max
   * @instance
   * @memberof Chart
   * @param {Number} [max] maximum value to set for zoom
   * @return {Number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [xDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @method zoom․min
   * @instance
   * @memberof Chart
   * @param {Number} [min] minimum value to set for zoom
   * @return {Number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [xDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @method zoom․range
   * @instance
   * @memberof Chart
   * @param {Object} [range]
   * @return {Object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range) {
    var zoom = this.zoom;

    if (isObject(_range)) {
      var min = _range.min,
          max = _range.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
});
/* harmony default export */ var api_zoom = ({
  zoom: zoom_zoom,

  /**
   * Unzoom zoomed area
   * @method unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.scale.zoom) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.$el.main.select("." + config_classes.eventRects);
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/drag.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var interactions_drag = ({
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {Object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _state$dragStart = state.dragStart,
            sx = _state$dragStart[0],
            sy = _state$dragStart[1],
            mx = mouse[0],
            my = mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? state.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? state.height : Math.max(sy, my);
        main.select("." + config_classes.dragarea).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).filter(function (d) {
          return config.data_selection_isselectable(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = +shape.attr("cx") * 1,
                y = +shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return; // @ts-ignore


          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {Object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (state.dragStart = mouse, main.select("." + config_classes.chart).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (main.select("." + config_classes.dragarea).transition().duration(100).style("opacity", "0").remove(), main.selectAll("." + config_classes.shape).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(45);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_flow = ({
  /**
   * Generate flow
   * @memberof ChartInternal
   * @private
   * @param {Object} args
   * @return {Function}
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    return function () {
      var translateX,
          targets = args.targets,
          flow = args.flow,
          _args$shape$type = args.shape.type,
          drawBar = _args$shape$type.bar,
          drawLine = _args$shape$type.line,
          drawArea = _args$shape$type.area,
          _args$shape$pos = args.shape.pos,
          cx = _args$shape$pos.cx,
          cy = _args$shape$pos.cy,
          xForText = _args$shape$pos.xForText,
          yForText = _args$shape$pos.yForText,
          xv = args.xv,
          duration = args.duration,
          scaleX = 1,
          flowIndex = flow.index,
          flowLength = flow.length,
          flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
          orgDomain = $$.scale.x.domain(),
          durationForFlow = flow.duration || duration,
          done = flow.done || function () {},
          wait = $$.generateWait(),
          xgrid = $el.grid.x,
          xgridLines = $el.gridLines.x,
          mainRegion = $el.region.list,
          mainText = $el.text,
          mainBar = $el.bar,
          mainLine = $el.line,
          mainArea = $el.area,
          mainCircle = $el.circle;

      state.flowing = !0, $$.data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      });
      // update x domain to generate axis elements for flow
      var domain = $$.updateXDomain(targets, !0, !0); // update elements related to x scale

      $$.updateXGrid && $$.updateXGrid(!0);
      var x = $$.scale.x; // generate transform to flow

      flow.orgDataCount ? flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = x(orgDomain[0]) - x(domain[0]) : $$.isTimeSeries() ? translateX = x(orgDomain[0]) - x(domain[0]) : translateX = x(flowStart.x) - x(flowEnd.x) : $$.data.targets[0].values.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1), translateX = x(flowStart.x) - x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = x(orgDomain[0]) - x(domain[0]), scaleX = diffDomain(orgDomain) / diffDomain(domain);
      var transform = "translate(" + translateX + ",0) scale(" + scaleX + ",1)";
      $$.hideGridFocus();
      var gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(durationForFlow);
      wait.add([$$.$el.axis.x.transition(gt).call(function (g) {
        return $$.axis.x.setTransition(gt).create(g);
      }), mainBar.transition(gt).attr("transform", transform), mainLine.transition(gt).attr("transform", transform), mainArea.transition(gt).attr("transform", transform), mainCircle.transition(gt).attr("transform", transform), mainText.transition(gt).attr("transform", transform), mainRegion.filter($$.isRegionOnX).transition(gt).attr("transform", transform), xgrid.transition(gt).attr("transform", transform), xgridLines.transition(gt).attr("transform", transform)]), gt.call(wait, function () {
        var isRotated = config.axis_rotated; // remove flowed elements

        if (flowLength) {
          for (var target = {
            shapes: [],
            texts: [],
            eventRects: []
          }, i = 0; i < flowLength; i++) target.shapes.push("." + config_classes.shape + "-" + i), target.texts.push("." + config_classes.text + "-" + i), target.eventRects.push("." + config_classes.eventRect + "-" + i);

          ["shapes", "texts", "eventRects"].forEach(function (v) {
            $el.svg.selectAll("." + config_classes[v]).selectAll(target[v]).remove();
          }), $el.svg.select("." + config_classes.xgrid).remove();
        } // draw again for removing flowed elements and reverting attr


        if (xgrid.size() && xgrid.attr("transform", null).attr(state.xgridAttr), xgridLines.attr("transform", null), xgridLines.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv), xgridLines.select("text").attr("x", isRotated ? state.width : 0).attr("y", xv), mainBar.attr("transform", null).attr("d", drawBar), mainLine.attr("transform", null).attr("d", drawLine), mainArea.attr("transform", null).attr("d", drawArea), mainCircle.attr("transform", null), $$.isCirclePoint()) mainCircle.attr("cx", cx).attr("cy", cy);else {
          var xFunc = function (d) {
            return cx(d) - config.point_r;
          },
              yFunc = function (d) {
            return cy(d) - config.point_r;
          };

          mainCircle.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
          .attr("cy", cy);
        }
        mainText.attr("transform", null).attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$)), mainRegion.attr("transform", null), mainRegion.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$)), config.interaction_enabled && $$.redrawEventRect(), done(), state.flowing = !1;
      });
    };
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/eventrect.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var eventrect = ({
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.$el.main.select("." + config_classes.eventRects).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll("." + config_classes.eventRect).remove(), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), isMultipleX) eventRectUpdate = $el.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $el.eventRect
      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), eventRectUpdate = $el.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $el.eventRect = eventRectUpdate, $$.updateEventRect(eventRectUpdate), $$.state.inputType !== "touch" || $el.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        state = $$.state,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(" + config_classes.eventRect + "-?|s)", "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isBoolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client" + (config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    $$.$el.svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect(),
          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
        if (state.dragging || state.flowing || $$.hasArcType() || event.touches.length > 1) return;
        preventEvent(event), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }, !0).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || state.cancelClick) && state.cancelClick && (state.cancelClick = !1);
    }, !0);
  },

  /**
   * Updates the location and size of the eventRect.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        xScale = scale.zoom || scale.x,
        eventRectData = eventRectUpdate || $$.$el.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = state.width, h = state.height;else {
      var rectW, rectX;
      if ($$.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? state.height : state.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = d.x;
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? state.width : rectW, h = isRotated ? rectW : state.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || main.selectAll("." + config_classes.shape + "-" + index).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config;
    config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if (state.mouseover && (!closest || closest.id !== state.mouseover.id) && (config.data_onout.call($$.api, state.mouseover), state.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.$el.svg.select("." + config_classes.eventRect).style("cursor", "pointer"), !state.mouseover && (config.data_onover.call($$.api, closest), state.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this;
    $$.$el.svg.select("." + config_classes.eventRect).style("cursor", null), $$.hideGridFocus(), $$.hideTooltip(), $$._handleLinkedCharts(!1), $$.unexpandCircles(), $$.unexpandBars();
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return state.inputType === "mouse" && rect.on("mouseover", function (d) {
      state.dragging || state.flowing || $$.hasArcType() || config.tooltip_grouped && $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!(state.dragging || state.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.$el.svg.select("." + config_classes.eventRect + "-" + index);
        $$.isStepType(d) && config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.scale.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index), config.tooltip_grouped || $$.setOverOut(index !== -1, d.index);
      }
    }).on("mouseout", function (d) {
      !config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config,
        state = $$.state;
    if ($$.hasArcType() || !$$.toggleShape || state.cancelClick) return void (state.cancelClick && (state.cancelClick = !1));
    var index = d.index;
    $$.$el.main.selectAll("." + config_classes.shape + "-" + index).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.call($$.api, d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        inputType = _$$$state.inputType,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", width).attr("height", height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.$el.main.selectAll("." + config_classes.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll("." + config_classes.shape + "-" + closest.index).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.call($$.api, closest, this));
      });
    } // select if selection enabled

  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_subchart = ({
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        context = $$.$el.context,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.$el.svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.state.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = scale.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map(scale.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && context && context.select("." + config_classes.brush).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return (// @ts-ignore
        context ? context.select("." + config_classes.brush) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([])
      );
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        _$$$$el = $$.$el,
        defs = _$$$$el.defs,
        svg = _$$$$el.svg,
        subchart = _$$$$el.subchart,
        axis = _$$$$el.axis,
        visibility = config.subchart_show ? "visible" : "hidden",
        clipId = clip.id + "-subchart",
        clipPath = $$.getClipPath(clipId);
    clip.idSubchart = clipId, $$.appendClip(defs, clipId), $$.initBrush(), subchart.main = svg.append("g").attr("transform", $$.getTranslate("context"));
    var main = subchart.main;
    // Define g for chart area
    // Define g for bar chart area
    // Define g for line chart area
    // Add extent rect for Brush
    // ATTENTION: This must be called AFTER chart added
    // Add Axis
    main.style("visibility", visibility), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars), main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines), main.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), axis.subX = main.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subX")).attr("clip-path", config.axis_rotated ? "" : clip.pathXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
  },

  /**
   * Update sub chart
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.subchart.main,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var barUpdate = main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", classChartBar),
          barEnter = barUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(barUpdate);
      barEnter.append("g").attr("class", classBars);
      // -- Line --//
      var lineUpdate = main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", classChartLine),
          lineEnter = lineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(lineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      lineEnter.append("g").attr("class", classLines), $$.hasType("area") && lineEnter.append("g").attr("class", classAreas), main.selectAll("." + config_classes.brush + " rect").attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? state.width2 : state.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @private
   * @param {Object} durationForExit
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.bar = subchart.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data($$.barData.bind($$)), subchart.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.bar = subchart.bar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge(subchart.bar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @private
   * @param {String} path in subchart bar
   * @param {Boolean} whether or not to transition.
   * @param {Number} transition duration
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var bar = this.$el.subchart.bar;
    (withTransition ? bar.transition(getRandom()).duration(duration) : bar).attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.line = subchart.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), subchart.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.line = subchart.line.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge(subchart.line).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var line = this.$el.subchart.line;
    (withTransition ? line.transition(getRandom()).duration(duration) : line).attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this,
        subchart = $$.$el.subchart;
    subchart.area = subchart.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), subchart.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), subchart.area = subchart.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge(subchart.area).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var area = this.$el.subchart.area;
    (withTransition ? area.transition(getRandom()).duration(duration) : area).attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.state.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {Boolean} withSubchart whether or not to show subchart
   * @param {Number} duration duration
   * @param {Object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.subchart.main;
    main.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw" + name](shape.indices[v], !0);
      $$["update" + name + "ForSubchart"](duration), $$["redraw" + name + "ForSubchart"](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this,
        _$$$config = $$.config,
        subchart_onbrush = _$$$config.subchart_onbrush,
        withY = _$$$config.zoom_rescale,
        scale = $$.scale;
    $$.redraw({
      withTransition: !1,
      withY: withY,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), subchart_onbrush.call($$.api, scale.x.orgDomain());
  },

  /**
   * Transform context
   * @private
   * @param {Boolean} indicates transition is enabled
   * @param {Object} The return value of the generateTransitions method of Axis.
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this,
        main = $$.$el.subchart.main;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = main.select("." + config_classes.axisX), withTransition && (subXAxis = subXAxis.transition())), main.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subX"));
  },

  /**
   * Get extent value
   * @private
   * @returns {Array} default extent
   */
  getExtent: function getExtent() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        extent = config.axis_x_extent;
    return extent && (isFunction(extent) ? extent = extent($$.getXDomain($$.data.targets), scale.subX) : $$.isTimeSeries() && extent.every(isNaN) && (extent = extent.map(function (v) {
      return scale.subX($$.parseDate(v));
    }))), extent;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var interactions_zoom = ({
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.scale.zoom = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {Boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent(bind) {
    bind === void 0 && (bind = !0);
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        zoomEnabled = config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = main.select("." + config_classes.eventRects);
    zoomEnabled && bind ? !config.subchart_show && $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        scale = $$.scale,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent
    // @ts-ignore
    // @ts-ignore

    /**
     * Update scale according zoom transform value
     * @param {Object} transform
     * @private
     */
    // @ts-ignore
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.scale.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      org.xScale && org.xScale.range(scale.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"](org.xScale || scale.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, org.xDomain), scale.zoom = $$.getCustomizedScale(newScale), $$.axis.x.scale(scale.zoom), rescale && (!org.xScale && (org.xScale = scale.x.copy()), scale.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        org = $$.org,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
        sourceEvent = event.sourceEvent;

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && (scale.zoom || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
      var isMousemove = sourceEvent.type === "mousemove",
          isZoomOut = sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && scale.x.domain().every(function (v, i) {
        return v !== org.xDomain[i];
      }) && scale.x.domain(org.xDomain), $$.zoom.updateTransformScale(transform), $$.isCategorized() && scale.x.orgDomain()[0] === org.xDomain[0] && scale.x.domain([org.xDomain[0] - 1e-10, scale.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.state.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, scale.zoom.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        startEvent = $$.zoom.startEvent,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn(config.zoom_onzoomend, $$.api, scale[scale.zoom ? "zoom" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
  	 * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _org$xDomain = org.xDomain,
        min = _org$xDomain[0],
        max = _org$xDomain[1];
    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {Boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this,
        _$$$scale = $$.scale,
        subX = _$$$scale.subX,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom;

    if (zoom) {
      var zoomDomain = zoom.domain(),
          xDomain = subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.axis.x.scale(subX), x.domain(subX.orgDomain()), zoom = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var zoomRect,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      // @ts-ignore
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.$el.main.append("rect").attr("clip-path", state.clip.path).attr("class", config_classes.zoomBrush).attr("width", isRotated ? state.width : 0).attr("height", isRotated ? 0 : state.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      // @ts-ignore
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.scale.zoom || $$.scale.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event3 = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event3 ? [_event3.clientX, _event3.clientY] : [_event3.x, _event3.y],
            x = _ref2[0],
            y = _ref2[1],
            target = browser_doc.elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.$el.chart.append("div").classed(config_classes.button, !0).append("span").on("click", function () {
      isFunction(resetButton.onclick) && resetButton.onclick(this), $$.api.unzoom();
    }).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var internals_category = ({
  /**
   * Category Name
   * @private
   * @param {Number} index
   * @returns {String} gategory Name
   */
  categoryName: function categoryName(i) {
    var categories = this.config.axis_x_categories;
    return i < categories.length ? categories[i] : i;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/clip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_clip = ({
  initClip: function initClip() {
    var $$ = this,
        clip = $$.state.clip;
    // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
    // Define 'clip-path' attribute values
    clip.id = $$.state.datetimeId + "-clip", clip.idXAxis = clip.id + "-xaxis", clip.idYAxis = clip.id + "-yaxis", clip.idGrid = clip.id + "-grid", clip.path = $$.getClipPath(clip.id), clip.pathXAxis = $$.getClipPath(clip.idXAxis), clip.pathYAxis = $$.getClipPath(clip.idYAxis), clip.pathGrid = $$.getClipPath(clip.idGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!win.navigator && win.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(" + (isIE9 ? "" : browser_doc.URL.split("#")[0]) + "#" + id + ")";
  },
  appendClip: function appendClip(parent, id) {
    return parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    var margin = this.state.margin,
        left = Math.max(30, margin.left); // axis line width + padding for left

    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    var margin = this.state.margin;
    return forHorizontal ? -20 : -margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        _$$$state = $$.state,
        margin = _$$$state.margin,
        width = _$$$state.width,
        left = Math.max(30, margin.left),
        right = Math.max(30, margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? width + 2 + left + right : margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    var _this$state = this.state,
        margin = _this$state.margin,
        height = _this$state.height; // less than 20 is not enough to show the axis label 'outer' without legend

    return (forHorizontal ? margin.bottom : margin.top + height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
},
    getGridTextX = function (isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
};

/* harmony default export */ var internals_grid = ({
  initGrid: function initGrid() {
    var $$ = this;
    $$.initGridLines(), $$.initFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        _$$$$el = $$.$el,
        gridLines = _$$$$el.gridLines,
        main = _$$$$el.main;
    (config.grid_x_lines.length || config.grid_y_lines.length) && (gridLines.main = main.insert("g", "." + config_classes.chart + (config.grid_lines_front ? " + *" : "")).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid + " " + config_classes.gridLines), gridLines.main.append("g").attr("class", config_classes.xgridLines), gridLines.main.append("g").attr("class", config_classes.ygridLines), gridLines.x = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        _$$$$el2 = $$.$el,
        main = _$$$$el2.main,
        grid = _$$$$el2.grid,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, scale.x),
        tickOffset = $$.isCategorized() ? $$.axis.x.tickOffset() : 0,
        pos = function (d) {
      return ((scale.zoom || scale.x)(d) + tickOffset) * (isRotated ? -1 : 1);
    };

    state.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": state.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": state.height
    }, grid.x = main.select("." + config_classes.xgrids).selectAll("." + config_classes.xgrid).data(xgridData), grid.x.exit().remove(), grid.x = grid.x.enter().append("line").attr("class", config_classes.xgrid).merge(grid.x), withoutUpdate || grid.x.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys(state.xgridAttr).forEach(function (id) {
        grid.attr(id, state.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? state.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el3 = $$.$el,
        grid = _$$$$el3.grid,
        main = _$$$$el3.main,
        isRotated = config.axis_rotated,
        gridValues = $$.axis.y.tickValues() || $$.scale.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.scale.y(d));
    };

    grid.y = main.select("." + config_classes.ygrids).selectAll("." + config_classes.ygrid).data(gridValues), grid.y.exit().remove(), grid.y = grid.y.enter().append("line").attr("class", config_classes.ygrid).merge(grid.y), grid.y.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : state.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? state.height : pos), $$.smoothLines(grid.y, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this,
        _$$$$el4 = $$.$el,
        grid = _$$$$el4.grid,
        gridLines = _$$$$el4.gridLines;
    // hide if arc type
    gridLines.main || $$.initGridLines(), grid.main.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.hideGridFocus(), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {Number} duration
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$$el5 = $$.$el,
        gridLines = _$$$$el5.gridLines,
        main = _$$$$el5.main,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid();
    var xLines = main.select("." + config_classes.xgridLines).selectAll("." + config_classes.xgridLine).data(config.grid_x_lines); // exit

    xLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = xLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), xLines = xgridLine.merge(xLines), xLines.attr("class", function (d) {
      return (config_classes.xgridLine + " " + (d.class || "")).trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), gridLines.x = xLines;
  },

  /**
   * Update Y Grid lines
   * @param {Number} duration
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        $el = $$.$el,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid();
    var ygridLines = $el.main.select("." + config_classes.ygridLines).selectAll("." + config_classes.ygridLine).data(config.grid_y_lines); // exit

    ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), ygridLines = ygridLine.merge(ygridLines);
    // update
    var yv = $$.yv.bind($$);
    ygridLines.attr("class", function (d) {
      return (config_classes.ygridLine + " " + (d.class || "")).trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? height : yv).transition().style("opacity", "1"), ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, width, height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), $el.gridLines.y = ygridLines;
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        gridLines = $$.$el.gridLines,
        xv = $$.xv.bind($$),
        lines = gridLines.x.select("line"),
        texts = gridLines.x.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, width, height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initFocusGrid: function initFocusGrid() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el,
        isFront = config.grid_front,
        className = "." + config_classes[isFront && $el.grid.main ? "gridLines" : "chart"] + (isFront ? " + *" : ""),
        grid = $el.grid.main = $el.main.insert("g", className).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid);
    config.grid_x_show && grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && (grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus), config.grid_focus_y && !config.tooltip_grouped && grid.append("g").attr("class", config_classes.ygridFocus).append("line").attr("class", config_classes.ygridFocus));
  },

  /**
   * Show grid focus line
   * @param {Array} selectedData
   * @private
   */
  showGridFocus: function showGridFocus(selectedData) {
    var $$ = this,
        config = $$.config,
        _$$$state3 = $$.state,
        width = _$$$state3.width,
        height = _$$$state3.height,
        isRotated = config.axis_rotated,
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    // Hide when bubble/scatter/stanford plot exists
    if (!(!config.tooltip_show || dataToShow.length === 0 || $$.hasType("bubble") || $$.hasArcType())) {
      var focusEl = $$.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus),
          isEdge = config.grid_focus_edge && !config.tooltip_grouped,
          xx = $$.xx.bind($$);
      focusEl.style("visibility", "visible").data(dataToShow.concat(dataToShow)).each(function (d) {
        var xy,
            el = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            pos = {
          x: xx(d),
          y: $$.getYScale(d.id)(d.value)
        };
        if (el.classed(config_classes.xgridFocus)) xy = isRotated ? [null, // x1
        pos.x, // y1
        isEdge ? pos.y : width, // x2
        pos.x // y2
        ] : [pos.x, isEdge ? pos.y : null, pos.x, height];else {
          var isY2 = $$.axis.getId(d.id) === "y2";
          xy = isRotated ? [pos.y, // x1
          isEdge && !isY2 ? pos.x : null, // y1
          pos.y, // x2
          isEdge && isY2 ? pos.x : height // y2
          ] : [isEdge && isY2 ? pos.x : null, pos.y, isEdge && !isY2 ? pos.x : width, pos.y];
        }
        ["x1", "y1", "x2", "y2"].forEach(function (v, i) {
          return el.attr(v, xy[i]);
        });
      }), $$.smoothLines(focusEl, "grid");
    }
  },
  hideGridFocus: function hideGridFocus() {
    this.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus).style("visibility", "hidden");
  },
  updategridFocus: function updategridFocus() {
    var $$ = this,
        _$$$state4 = $$.state,
        width = _$$$state4.width,
        height = _$$$state4.height,
        isRotated = $$.config.axis_rotated;
    $$.$el.main.select("line." + config_classes.xgridFocus).attr("x1", isRotated ? 0 : -10).attr("x2", isRotated ? width : -10).attr("y1", isRotated ? -10 : 0).attr("y2", isRotated ? -10 : height);
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.$el.main.select("." + config_classes.axisX).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date(i + "-01-01 00:00:00"));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line.class === param.class) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.$el.main.select("." + classLines).selectAll("." + classLine).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_" + (forX ? "x" : "y") + "_lines";
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/region.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection



/* harmony default export */ var region = ({
  initRegion: function initRegion() {
    var $$ = this,
        $el = $$.$el;
    $el.region.main = $el.main.append("g").attr("clip-path", $$.state.clip.path).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $el.region.main.style("visibility", $$.hasArcType() ? "hidden" : "visible");
    // select <g> element
    var list = $el.main.select("." + config_classes.regions).selectAll("." + config_classes.region).data(config.regions);
    list.exit().transition().duration(duration).style("opacity", "0").remove(), list = list.enter().append("g").merge(list).attr("class", $$.classRegion.bind($$)), list.append("rect").style("fill-opacity", "0"), $el.region.list = list;
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.$el.region.list.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], pos = currScale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, pos = currScale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = state[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], end = currScale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, end = currScale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(46);

// CONCATENATED MODULE: ./src/ChartInternal/internals/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_selection = ({
  /**
   * Select a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    // remove selected-circle from low layer g
    callFn(config.data_onunselected, $$.api, d, target.node()), $el.main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = (selected ? "" : "un") + "selectPoint";
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  togglePath: function togglePath(selected, target, d, i) {
    this[(selected ? "" : "un") + "selectPath"](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @returns {Function} toggle method
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
      if (!config.data_selection_multiple) {
        var selector = "." + config_classes.shapes;
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), main.selectAll(selector).selectAll("." + config_classes.shape).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_shape_bar = ({
  initBar: function initBar() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainBarUpdate = $$.$el.main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        $el = $$.$el,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $el.bar = $el.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data(barData), $el.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.bar = $el.bar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($el.bar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    var bar = this.$el.bar;
    return [(withTransition ? bar.transition(getRandom()) : bar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        maxDataCount = $$.getMaxDataCount(),
        isGrouped = config.data_groups.length,
        tickInterval = (scale.zoom || $$) && !$$.isCategorized() ? $$.xx(scale.subX.domain()[1]) / maxDataCount : axis.tickInterval(maxDataCount),
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        main = $$.$el.main,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? main.selectAll("." + config_classes.bars + $$.getTargetSelectorSuffix(id)) : main).selectAll("." + config_classes.bar + suffix);
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a" + radius + "," + radius + " " + (isNegative ? "1 0 0" : "0 0 1") + " ";
        pathRadius[+!isRotated] = "" + arc + radius + "," + radius, pathRadius[+isRotated] = "" + arc + [-radius, radius][isRotated ? "sort" : "reverse"](), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H" + (points[1][indexX] - radius) + " " + pathRadius[0] + "V" + (points[2][indexY] - radius) + " " + pathRadius[1] + "H" + points[3][indexX] : "V" + (points[1][indexY] + (isNegative ? -radius : radius)) + " " + pathRadius[0] + "H" + (points[2][indexX] - radius) + " " + pathRadius[1] + "V" + points[3][indexY];
      return "M" + points[0][indexX] + "," + points[0][indexY] + path + "z";
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        axis = isSub ? $$.axis.subX : $$.axis.x,
        barTargetsNum = $$.getIndicesMax(barIndices) + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list = list,
        seg0 = _list[0],
        seg1 = _list[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var shape_bubble = ({
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value for the total length of the path in user units
   * https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
   * @return {Number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        axis = $$.$el.axis,
        cacheKey = "$baseLength",
        baseLength = $$.cache.get(cacheKey);
    return baseLength || $$.cache.add(cacheKey, baseLength = getMinMax("min", [axis.x.select("path").node().getTotalLength(), axis.y.select("path").node().getTotalLength()])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {Object} d
   * @return {Number}
   * @private
  	 */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  },

  /**
   * Get bubble dimension data
   * @param {Object|Array} d data value
   * @param {String} type - y or z
   * @return {Number}
   * @private
   */
  getBubbleZData: function getBubbleZData(d, type) {
    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
  },

  /**
   * Determine if bubble has dimension data
   * @param {Object|array} d data value
   * @return {Boolean}
   * @private
   */
  isBubbleZType: function isBubbleZType(d) {
    var $$ = this;
    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(47);

// CONCATENATED MODULE: ./src/ChartInternal/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var ChartInternal_shape_line = ({
  initLine: function initLine() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$),
        classCircles = $$.classCircles.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainLineUpdate = main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    // Areas
    // Update date for selected circles
    mainLineEnter.append("g").attr("class", classLines), mainLineEnter.append("g").attr("class", classAreas), config.point_show && (config.data_selection_enabled && mainLineEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainLineEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    })), targets.forEach(function (t) {
      main.selectAll("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll("" + config_classes.selectedCircle).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this,
        extraLineClasses = $$.format.extraLineClasses,
        $el = $$.$el;
    $el.line = $el.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), $el.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.line = $el.line.enter().append("path").attr("class", function (d) {
      return $$.classLine.bind($$)(d) + " " + (extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($el.line).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    var line = this.$el.line;
    return [(withTransition ? line.transition(getRandom()) : line).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @return {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      var p = (isSub ? $$.subxx : $$.xx).call($$, d); // if (d.value === 200) {
      // 	console.log(p);
      // }

      return p;
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? scale.subX : scale.x;
    return function (d) {
      var path,
          y = yScaleGetter.call($$, d.id),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.isTimeSeries(),
        xOffset = $$.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? $$.parseDate(v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M" + points[0][0] + "," + points[0][1] + "L" + points[1][0] + "," + points[1][1];
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          hasPrevData = prevData && isValue(prevData.value),
          style = isWithinRegions(data.x, regions);
      // https://github.com/naver/billboard.js/issues/1172
      if (isValue(data.value)) // Draw as normal
        if (isUndefined(regions) || !style || !hasPrevData) path += "" + (_i && hasPrevData ? "L" : "M") + xValue(data) + "," + yValue(data);else if (hasPrevData) {
          try {
            style = style.dasharray.split(" ");
          } catch (e) {
            style = dasharray.split(" ");
          } // Draw with region // TODO: Fix for horizotal charts


          xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
          var dx = x(data.x) - x(prevData.x),
              dy = y(data.value) - y(prevData.value),
              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = style[0] / dd, diffx2 = diff * style[1];

          for (var _j = diff; _j <= 1; _j += diffx2) path += sWithRegion(prevData, data, _j, diff), _j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
        }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        defs = $$.$el.defs;
    $$.data.targets.forEach(function (d) {
      var id = datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id);

      if ($$.isAreaType(d) && defs.select("#" + id).empty()) {
        var color = $$.color(d),
            _config$area_linearGr = config.area_linearGradient,
            _config$area_linearGr2 = _config$area_linearGr.x,
            x = _config$area_linearGr2 === void 0 ? [0, 0] : _config$area_linearGr2,
            _config$area_linearGr3 = _config$area_linearGr.y,
            y = _config$area_linearGr3 === void 0 ? [0, 1] : _config$area_linearGr3,
            _config$area_linearGr4 = _config$area_linearGr.stops,
            stops = _config$area_linearGr4 === void 0 ? [[0, color, 1], [1, color, 0]] : _config$area_linearGr4,
            linearGradient = defs.append("linearGradient").attr("id", "" + id).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1](d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#" + $$.state.datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id) + ")" : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    config.area_linearGradient && $$.updateAreaGradient(), $el.area = $el.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), $el.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.area = $el.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($el.area), $el.area.style("opacity", state.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this,
        orgAreaOpacity = $$.state.orgAreaOpacity;
    return [(withTransition ? $$.$el.area.transition(getRandom()) : $$.$el.area).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? orgAreaOpacity / 1.75 : orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param areaIndices
   * @param isSub
   * @return {function(*=): (*|string)}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : 0);
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue) // @ts-ignore
        .y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.scale.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        x = $$.getShapeX(0, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var shape_point = ({
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  updateCircle: function updateCircle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.point_show) {
      $el.circle = $el.main.selectAll("." + config_classes.circles).selectAll("." + config_classes.circle).data(function (d) {
        return !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
      }), $el.circle.exit().remove();
      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
      $el.circle = $el.circle.enter().append(fn).merge($el.circle).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$));
    }
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        selectedCircles = $$.$el.main.selectAll("." + config_classes.selectedCircle);
    if (!$$.config.point_show) return [];
    var mainCircles = [];
    $$.$el.circle.each(function (d) {
      var fn = $$.point("update", $$, cx, cy, $$.opacityForCircle.bind($$), $$.color, withTransition, flow, selectedCircles).bind(this),
          result = fn(d);
      mainCircles.push(result);
    });
    var posAttr = $$.isCirclePoint() ? "c" : "";
    return [mainCircles, selectedCircles.attr(posAttr + "x", cx).attr(posAttr + "y", cy)];
  },
  circleX: function circleX(d) {
    var $$ = this,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom,
        hasValue = isValue(d.x);
    return $$.config.zoom_enabled && zoom ? hasValue ? zoom(d.x) : null : hasValue ? x(d.x) : null;
  },
  updateCircleY: function updateCircleY() {
    var $$ = this,
        getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), !1);

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? getPoints(d, i)[0][1] : $$.getYScale(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? $$.$el.main.selectAll("." + config_classes.circles + $$.getTargetSelectorSuffix(id)) : $$.$el.main).selectAll("." + config_classes.circle + suffix);
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(" + x + " " + y + ") scale(" + scale + ")");
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(" + r(circles) / $$.config.point_r + ")");
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint() ? "c" : "",
        cx = +element.attr(prefix + "x"),
        cy = +element.attr(prefix + "y");

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _ref = node.getBBox ? node.getBBox() : node.getBoundingClientRect(),
          x = _ref.x,
          y = _ref.y;

      cx = x, cy = y;
    }

    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.$el.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.$el.defs.select("#" + id);
  },
  updatePointClass: function updatePointClass(d) {
    var $$ = this,
        circle = $$.$el.circle,
        pointClass = !1;
    return (isObject(d) || circle) && (pointClass = d === !0 ? circle.attr("class", $$.classCircle.bind($$)) : $$.classCircle(d)), pointClass;
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ids.indexOf(id) < 0 && ids.push(id);
        var point = pattern[ids.indexOf(id) % pattern.length];
        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = datetimeId + "-point-" + id,
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  getTransitionName: function getTransitionName() {
    return getRandom();
  },
  custom: {
    create: function create(element, id, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#" + id).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
        return yPosFn(d) - height / 2;
      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
        return yPosFn(d) - r;
      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/shape.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var shape_shape = ({
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        xs = config.data_xs,
        hasXs = notEmpty(xs),
        indices = {},
        i = hasXs ? {} : 0;
    return hasXs && getUnique(Object.keys(xs).map(function (v) {
      return xs[v];
    })).forEach(function (v) {
      i[v] = 0, indices[v] = {};
    }), $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, xKey = (d.id in xs) ? xs[d.id] : "", ind = xKey ? indices[xKey] : indices, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in ind) {
        ind[d.id] = ind[_row4];
        break;
      }

      isUndefined(ind[d.id]) && (ind[d.id] = xKey ? i[xKey]++ : i++, ind.__max__ = (xKey ? i[xKey] : i) - 1);
    }), indices;
  },

  /**
   * Get indices value based on data ID value
   * @param {Object} indices Indices object
   * @param {String} id Data id value
   * @return {Object} Indices object
   * @private
   */
  getIndices: function getIndices(indices, id) {
    var xs = this.config.data_xs;
    return notEmpty(xs) ? indices[xs[id]] : indices;
  },

  /**
   * Get indices max number
   * @param {Object} indices Indices object
   * @return {Number} Max number
   * @private
   */
  getIndicesMax: function getIndicesMax(indices) {
    return notEmpty(this.config.data_xs) ? // if is multiple xs, return total sum of xs' __max__ value
    Object.keys(indices).map(function (v) {
      return indices[v].__max__ || 0;
    }).reduce(function (acc, curr) {
      return acc + curr;
    }) : indices.__max__;
  },
  getShapeX: function getShapeX(offset, indices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        currScale = isSub ? scale.subX : scale.zoom || scale.x,
        barPadding = config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var ind = $$.getIndices(indices, d.id),
          index = d.id in ind ? ind[d.id] : 0,
          targetsNum = (ind.__max__ || 0) + 1,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = currScale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
      return (isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id))(value);
    };
  },

  /**
   * Get Shape's offset data
   * @param {function(Object): boolean} typeFilter
   * @return {{shapeOffsetTargets: ShapeOffsetTarget[], indexMapByTargetId: object}}
   * @private
   */
  getShapeOffsetData: function getShapeOffsetData(typeFilter) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        shapeOffsetTargets = targets.map(function (target) {
      var rowValues = target.values;
      $$.isStepType(target) && (rowValues = $$.convertValuesToStep(rowValues));
      var rowValueMapByXValue = rowValues.reduce(function (out, value) {
        return out[+value.x] = value, out;
      }, {}),
          values = rowValues.map($$.isStackNormalized() ? function (v) {
        return $$.getRatio("index", v, !0);
      } : function (_ref) {
        var value = _ref.value;
        return value;
      });
      return {
        id: target.id,
        rowValues: rowValues,
        rowValueMapByXValue: rowValueMapByXValue,
        values: values
      };
    }),
        indexMapByTargetId = targets.reduce(function (out, _ref2, index) {
      var id = _ref2.id;
      return out[id] = index, out;
    }, {});
    return {
      indexMapByTargetId: indexMapByTargetId,
      shapeOffsetTargets: shapeOffsetTargets
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        _$$$getShapeOffsetDat = $$.getShapeOffsetData(typeFilter),
        shapeOffsetTargets = _$$$getShapeOffsetDat.shapeOffsetTargets,
        indexMapByTargetId = _$$$getShapeOffsetDat.indexMapByTargetId;

    return function (d, idx) {
      var ind = $$.getIndices(indices, d.id),
          scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
          y0 = scale(0),
          dataXAsNumber = +d.x,
          offset = y0;
      return shapeOffsetTargets.forEach(function (t) {
        var rowValues = t.rowValues,
            values = t.values;

        if (t.id !== d.id && ind[t.id] === ind[d.id] && indexMapByTargetId[t.id] < indexMapByTargetId[d.id]) {
          var _rowValue = rowValues[idx]; // check if the x values line up

          _rowValue && +_rowValue.x === dataXAsNumber || (_rowValue = t.rowValueMapByXValue[dataXAsNumber]), _rowValue && _rowValue.value * d.value >= 0 && (offset += scale(values[_rowValue.index]) - y0);
        }
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        config = $$.config,
        type = config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? config.line_step_type : "linear";
  }
});
// CONCATENATED MODULE: ./src/config/resolver/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Axis based chart
 */
// Chart









 // ChartInternal
















/* harmony default export */ var resolver_axis = ({
  api: [api_axis, category, api_flow, grid_x, grid_y, group, api_regions, api_selection, api_x, api_zoom],
  internal: [internals_category, interactions_drag, interactions_flow, interactions_subchart, interactions_zoom, internals_clip, internals_grid, region, internals_selection, eventrect, ChartInternal_shape_bar, shape_bubble, ChartInternal_shape_line, shape_point, shape_shape]
});
// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(48);

// CONCATENATED MODULE: ./src/ChartInternal/shape/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var shape_arc = ({
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        dataType = config.data_type,
        padding = config.pie_padding,
        startingAngle = config[dataType + "_startingAngle"] || 0,
        padAngle = ($$.hasType("pie") && padding ? padding * .01 : config[dataType + "_padAngle"]) || 0,
        sortValue = $$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().startAngle(startingAngle).endAngle(startingAngle + 2 * Math.PI).padAngle(padAngle).sortValues(sortValue).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width,
        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * config.gauge_arcs_minWidth;
    state.radiusExpanded = Math.min(state.arcWidth, state.arcHeight) / 2 * ($$.hasMultiArcGauge() ? .85 : 1), state.radius = state.radiusExpanded * .95, state.innerRadiusRatio = w ? (state.radius - w) / state.radius : .6, state.gaugeArcWidth = w || (gaugeArcWidth <= state.radius - state.innerRadius ? state.radius - state.innerRadius : gaugeArcWidth <= state.radius ? gaugeArcWidth : state.radius);
    var innerRadius = radius || (padding ? padding * (state.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    state.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? state.radius * state.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        innerRadius = $$.state.innerRadius;
    return !isNumber(innerRadius) && d && (innerRadius = innerRadius[d.data.id] || 0), innerRadius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded();
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;
    var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
        gStart = config.gauge_startingAngle;

    if (d.data && $$.isGaugeType(d.data)) {
      var totalSum = $$.getTotalDataSum(); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    if (pie($$.filterTargetsToShow()).forEach(function (t, i) {
      found || t.data.id !== d.data.id || (found = !0, d = t, d.index = i);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), d.data && $$.hasMultiArcGauge()) {
      var maxValue = $$.getMinMaxData().max[0].value; // if gauge_max less than maxValue, make maxValue to max value

      maxValue > config.gauge_max && (config.gauge_max = maxValue);
      var gMin = config.gauge_min,
          gMax = config.gauge_max,
          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
      d.startAngle = gStart, d.endAngle = gStart + radius / (gMax - gMin) * gValue;
    }

    return found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        state = $$.state,
        ir = $$.getInnerRadius(),
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index : state.radius;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : isNumber(ir) ? ir : 0;
    }),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        state = $$.state,
        newRate = rate || 1,
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        expandWidth = Math.min(state.radiusExpanded * newRate - state.radius, singleArcWidth * .8 - (1 - newRate) * 100),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index + expandWidth : state.radiusExpanded * newRate;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : state.innerRadius;
    });
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? (hasMultiArcGauge ? arc : arc.innerRadius($$.getInnerRadius(d)))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        radius = _$$$state.radius,
        radiusExpanded = _$$$state.radiusExpanded,
        updated = $$.updateAngle(d),
        translate = "";
    if (updated) if ($$.hasMultiArcGauge()) {
      var y1 = Math.sin(updated.endAngle - Math.PI / 2),
          x = Math.cos(updated.endAngle - Math.PI / 2) * (radiusExpanded + 25),
          y = y1 * (radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
      translate = "translate(" + x + "," + y + ")";
    } else if (!$$.hasType("gauge") || $$.data.targets.length > 1) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio(d, radius, h) : ratio : radius && (h ? (36 / radius > .375 ? 1.175 - 36 / radius : .8) * radius / h : 0), translate = "translate(" + x * ratio + "," + y * ratio + ")";
    }
    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this;
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          value = updated ? updated.value : d.value,
          ratio = $$.getRatio("arc", updated),
          id = d.data.id,
          hasGauge = $$.hasType("gauge"),
          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, id).toString();
        setTextValue(node, text, [-1, 1], hasGauge);
      }
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var format = this.getGaugeLabelExtents();
    return format ? format(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        $el = $$.$el;

    // MEMO: avoid to cancel transition
    if (transiting) {
      var interval = setInterval(function () {
        transiting || (clearInterval(interval), $el.legend.selectAll("." + config_classes.legendItemFocused).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $el.svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).each(function (d) {
      if ($$.shouldExpand(d.data.id)) {
        var expandDuration = $$.getExpandConfig(d.data.id, "duration"),
            svgArcExpandedSub = $$.getSvgArcExpanded($$.getExpandConfig(d.data.id, "rate"));
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        svg = $$.$el.svg;

    if (!transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).selectAll("path").transition().duration(function (d) {
        return $$.getExpandConfig(d.data.id, "duration");
      }).attr("d", $$.svgArc), svg.selectAll("" + config_classes.arc).style("opacity", "1");
    }
  },

  /**
   * Get expand config value
   * @param {String} id data ID
   * @param {String} key config key: 'duration | rate'
   * @return {Number}
   * @private
   */
  getExpandConfig: function getExpandConfig(id, key) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config[type + "_expand_" + key] : {
      duration: 50,
      rate: .98
    }[key];
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config[v + "_label_show"];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), format;
  },
  getGaugeLabelExtents: function getGaugeLabelExtents() {
    var config = this.config;
    return config.gauge_label_extents;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config[type + "_title"] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.$el.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select("." + config_classes.chartArcs).selectAll("." + config_classes.chartArc).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this,
        $el = $$.$el;
    $el.arcs = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.$el.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arc).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && config.data_selection_isselectable(d) ? "pointer" : null;
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), $$.hasMultiArcGauge() && $$.redrawMultiArcGauge(), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      state.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      var color;
      return $$.levelColor ? (color = $$.levelColor(d.data.values[0].value), config.data_colors[d.data.id] = color) : color = $$.color(d.data.id), color;
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call($$.endall, function () {
      if ($$.levelColor) {
        var path = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            d = path.datum();
        $$.updateLegendItemColor(d.data.id, path.style("fill"));
      }

      state.transiting = !1, callFn(config.onrendered, $$, $$.api);
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  redrawMultiArcGauge: function redrawMultiArcGauge() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        arcLabelLines = $el.main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arcLabelLine).data($$.arcData.bind($$)),
        mainArcLabelLine = arcLabelLines.enter().append("rect").attr("class", function (d) {
      return config_classes.arcLabelLine + " " + config_classes.target + " " + config_classes.target + "-" + d.data.id;
    }).merge(arcLabelLines);
    mainArcLabelLine.style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
    }).style("display", config.gauge_label_show ? "" : "none").each(function (d) {
      var lineLength = 0,
          lineThickness = 2,
          x = 0,
          y = 0,
          transform = "";

      if (hiddenTargetIds.indexOf(d.data.id) < 0) {
        var updated = $$.updateAngle(d),
            innerLineLength = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
            lineAngle = updated.endAngle - Math.PI / 2,
            arcInnerRadius = state.radius - innerLineLength,
            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
        lineLength = state.radiusExpanded - state.radius + innerLineLength, x = Math.cos(linePositioningAngle) * arcInnerRadius, y = Math.sin(linePositioningAngle) * arcInnerRadius, transform = "rotate(" + lineAngle * 180 / Math.PI + ", " + x + ", " + y + ")";
      }

      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr("x", x).attr("y", y).attr("width", lineLength).attr("height", lineThickness).attr("transform", transform).style("stroke-dasharray", "0, " + (lineLength + lineThickness) + ", 0");
    });
  },
  bindArcEvent: function bindArcEvent(arc) {
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    }

    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        isMouse = state.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), config.data_onclick.call($$.api, arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!state.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.$el.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var text,
        $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        arcs = _$$$$el.arcs,
        hasGauge = $$.hasType("gauge"),
        hasMultiArcGauge = $$.hasMultiArcGauge();

    if (hasGauge && $$.data.targets.length === 1 && config.gauge_title || (text = main.selectAll("." + config_classes.chartArc).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ? Math.round(state.radius / 5) + "px" : null;
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    }), hasMultiArcGauge && text.attr("dy", "-.1em")), main.select("." + config_classes.chartArcsTitle).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          startAngle = -1 * Math.PI / 2,
          endAngle = (isFullCircle ? -4 : -1) * startAngle;
      isFullCircle && text && text.attr("dy", "" + Math.round(state.radius / 14));
      var backgroundArc = $$.$el.arcs.select((hasMultiArcGauge ? "g" : "") + "." + config_classes.chartArcsBackground);

      if (hasMultiArcGauge) {
        var index = 0;
        backgroundArc = backgroundArc.selectAll("path." + config_classes.chartArcsBackground).data($$.data.targets), backgroundArc.enter().append("path").attr("class", function (d, i) {
          return config_classes.chartArcsBackground + " " + config_classes.chartArcsBackground + "-" + i;
        }).merge(backgroundArc).attr("d", function (d1) {
          if (state.hiddenTargetIds.indexOf(d1.id) >= 0) return "M 0 0";
          var d = {
            data: [{
              value: config.gauge_max
            }],
            startAngle: startAngle,
            endAngle: endAngle,
            index: index++
          };
          return $$.getArc(d, !0, !0);
        }), backgroundArc.exit().remove();
      } else backgroundArc.attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: startAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      });

      arcs.select("." + config_classes.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && (arcs.select("." + config_classes.chartArcsGaugeMin).attr("dx", -1 * (state.innerRadius + (state.radius - state.innerRadius) / (isFullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && arcs.select("." + config_classes.chartArcsGaugeMax).attr("dx", state.innerRadius + (state.radius - state.innerRadius) / 2 + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.$el.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append($$.hasMultiArcGauge() ? "g" : "path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get the position value
 * @param {Boolean} isClockwise If the direction is clockwise
 * @param {String} type Coordinate type 'x' or 'y'
 * @param {Number} edge Number of edge
 * @param {Number} pos The indexed position
 * @param {Number} range
 * @param {Number} ratio
 * @return {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = "$radarPoints";
/* harmony default export */ var shape_radar = ({
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config;
    $$.hasType("radar") && ($$.radars = $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartRadars), $$.radars.levels = $$.radars.append("g").attr("class", config_classes.levels), $$.radars.axes = $$.radars.append("g").attr("class", config_classes.axis), $$.radars.shapes = $$.radars.append("g").attr("class", config_classes.shapes), $$.maxValue = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        arcWidth = _$$$state.arcWidth,
        arcHeight = _$$$state.arcHeight,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min(arcWidth, arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        width = _$$$getRadarSize[0],
        height = _$$$getRadarSize[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize2 = $$.getRadarSize(),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        points = $$.cache.get(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.cache.add(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(duration, durationForExit) {
    var $$ = this,
        main = $$.$el.main,
        translate = $$.getTranslate("radar");
    translate && ($$.radars.attr("transform", translate), main.selectAll("." + config_classes.circles).attr("transform", translate), main.select("." + config_classes.chartTexts).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(duration, durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var points = this.cache.get(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize3 = $$.getRadarSize(),
        width = _$$$getRadarSize3[0],
        height = _$$$getRadarSize3[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = $$.radars.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = config.radar_level_text_format,
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll("." + config_classes.level).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return config_classes.level + " " + config_classes.level + "-" + i;
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat($$.maxValue / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(" + (width - levelRatio[d]) + ", " + (height - levelRatio[d]) + ")";
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize4 = $$.getRadarSize(),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        categories = config.axis_x_categories,
        axis = $$.radars.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return config_classes.axis + "-" + i;
    });

    // axis text
    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show) {
      var _config$radar_axis_te = config.radar_axis_text_position,
          _config$radar_axis_te2 = _config$radar_axis_te.x,
          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
          _config$radar_axis_te3 = _config$radar_axis_te.y,
          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
        selection.each(function (d) {
          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
        });
      }).datum(function (d, i) {
        return {
          index: i
        };
      }).attr("transform", function (d) {
        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(" + posX + " " + posY + ")";
      });
    }

    $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var _this = this,
        $$ = this,
        config = $$.config,
        _$$$state2 = $$.state,
        inputType = _$$$state2.inputType,
        transiting = _$$$state2.transiting,
        svg = $$.$el.svg;

    if (config.interaction_enabled) {
      var isMouse = inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && (_this.hideTooltip(), _this.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      $$.radars.select("." + config_classes.axis).on(isMouse ? "mouseover " : "touchstart", function () {
        if (!transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle(svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(duration, durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.cache.get(radar_cacheKey),
        areas = $$.radars.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).style("fill", function (d) {
      return $$.color(d);
    }).style("stroke", function (d) {
      return $$.color(d);
    }).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/config/resolver/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Modules exports for Arc based chart
 */
// shape


/* harmony default export */ var resolver_arc = ({
  internal: [shape_arc, shape_radar]
});
// CONCATENATED MODULE: ./src/ChartInternal/ChartInternal.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */








 // for Types

// Axis
 // data



 // interactions

 // internals















/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */
var ChartInternal_ChartInternal =
/*#__PURE__*/
function () {
  // API interface
  // config object
  // cache instance
  // state variables
  // all Chart instances array within page (equivalent of 'bb.instances')
  // if is Arc type chart
  // data object
  // selections
  // Axis
  // Axis
  // scales
  // original values
  // formatter function
  // format function
  function ChartInternal(api) {
    _defineProperty(this, "api", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "cache", void 0), _defineProperty(this, "state", void 0), _defineProperty(this, "charts", void 0), _defineProperty(this, "isArc", !1), _defineProperty(this, "data", {
      xs: {},
      targets: []
    }), _defineProperty(this, "$el", {
      chart: null,
      main: null,
      svg: null,
      axis: {
        // axes
        x: null,
        y: null,
        y2: null,
        subX: null
      },
      defs: null,
      tooltip: null,
      legend: null,
      title: null,
      subchart: {
        main: null,
        bar: null,
        line: null,
        area: null
      },
      arcs: null,
      bar: null,
      //mainBar,
      line: null,
      //mainLine,
      area: null,
      //mainArea,
      circle: null,
      //mainCircle,
      text: null,
      //mainText,
      grid: {
        main: null,
        // grid (also focus)
        x: null,
        // xgrid,
        y: null // ygrid,

      },
      gridLines: {
        main: null,
        // gridLines
        x: null,
        // xgridLines,
        y: null // ygridLines

      },
      region: {
        main: null,
        //region
        list: null // mainRegion

      },
      eventRect: null
    }), _defineProperty(this, "axis", void 0), _defineProperty(this, "scale", {
      x: null,
      y: null,
      y2: null,
      subX: null,
      subY: null,
      subY2: null,
      zoom: null
    }), _defineProperty(this, "org", {
      xScale: null,
      xDomain: null
    }), _defineProperty(this, "color", void 0), _defineProperty(this, "patterns", void 0), _defineProperty(this, "levelColor", void 0), _defineProperty(this, "point", void 0), _defineProperty(this, "brush", void 0), _defineProperty(this, "format", {
      extraLineClasses: null,
      xAxisTick: null,
      dataTime: null,
      // dataTimeFormat
      defaultAxisTime: null,
      // defaultAxisTimeFormat
      axisTime: null // axisTimeFormat

    }), _defineProperty(this, "isAxis", void 0);
    var $$ = this;
    $$.api = api, $$.config = new Options(), $$.cache = new Cache_Cache(), $$.state = new Store_state();
  }

  var _proto = ChartInternal.prototype;
  return _proto.beforeInit = function beforeInit() {
    var $$ = this;
    $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$, $$.api);
  }, _proto.afterInit = function afterInit() {
    var $$ = this;
    $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$, $$.api);
  }, _proto.init = function init() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.isAxis = !$$.hasArcType(), $$.initParams();
    var bindto = {
      element: config.bindto,
      classname: "bb"
    };
    isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $el.chart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $el.chart.empty() && ($el.chart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.body.appendChild(browser_doc.createElement("div")))), $el.chart.html("").classed(bindto.classname, !0), $$.initToRender();
  }
  /**
   * Initialize the rendering process
   * @param {Boolean} forced Force to render process
   * @private
   */
  , _proto.initToRender = function initToRender(forced) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        chart = $$.$el.chart,
        isHidden = function () {
      return chart.style("display") === "none" || chart.style("visibility") === "hidden";
    },
        isLazy = config.render.lazy || isHidden(),
        MutationObserver = win.MutationObserver;

    if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
      isHidden() || (observer.disconnect(), !state.rendered && $$.initToRender(!0));
    }).observe(chart.node(), {
      attributes: !0,
      attributeFilter: ["class", "style"]
    }), !isLazy || forced) {
      var convertedData = $$.convertData(config, $$.initWithData);
      convertedData && $$.initWithData(convertedData);
    }
  }, _proto.initParams = function initParams() {
    var $$ = this,
        config = $$.config,
        format = $$.format,
        state = $$.state,
        isRotated = config.axis_rotated;

    if (state.datetimeId = "bb-" + +new Date(), $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), ($$.isAxis || $$.hasType("radar")) && ($$.point = $$.generatePoint()), $$.isAxis) {
      $$.initClip(), format.extraLineClasses = $$.generateExtraLineClass(), format.dataTime = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], format.axisTime = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
      var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";

      format.defaultAxisTime = function (d) {
        var _$$$scale = $$.scale,
            x = _$$$scale.x,
            zoom = _$$$scale.zoom,
            isZoomed = isDragZoom ? zoom : zoom && x.orgDomain().toString() !== zoom.domain().toString(),
            specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
        return format.axisTime(specifier)(d);
      };
    }

    state.isLegendRight = config.legend_position === "right", state.isLegendInset = config.legend_position === "inset", state.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", state.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", state.rotatedPaddingRight = isRotated && !config.axis_x_show ? 0 : 30, state.inputType = $$.convertInputType();
  }, _proto.initWithData = function initWithData(data) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        _$$$scale2 = $$.scale,
        x = _$$$scale2.x,
        y = _$$$scale2.y,
        y2 = _$$$scale2.y2,
        subX = _$$$scale2.subX,
        subY = _$$$scale2.subY,
        subY2 = _$$$scale2.subY2,
        org = $$.org;

    if ($$.isAxis && ($$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom()), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter)), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.updateSizes(), $$.updateScales(!0), x && (x.domain(util_sortValue($$.getXDomain($$.data.targets))), subX.domain(x.domain()), org.xDomain = x.domain()), y && (y.domain($$.getYDomain($$.data.targets, "y")), subY.domain(y.domain())), y2 && (y2.domain($$.getYDomain($$.data.targets, "y2")), subY2 && subY2.domain(y2.domain())), $el.svg = $el.chart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && state.inputType) {
      var isTouch = state.inputType === "touch";
      $el.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
        return callFn(config.onover, $$, $$.api);
      }).on(isTouch ? "touchend" : "mouseleave", function () {
        return callFn(config.onout, $$, $$.api);
      });
    }

    config.svg_classname && $el.svg.attr("class", config.svg_classname), $$.isAxis && ($el.defs = $el.svg.append("defs"), $$.appendClip($el.defs, state.clip.id), $$.appendClip($el.defs, state.clip.idXAxis), $$.appendClip($el.defs, state.clipYAxis), $$.appendClip($el.defs, state.clip.idGrid)), isFunction(config.color_tiles) && $$.patterns && $$.patterns.forEach(function (p) {
      return $el.defs.append(function () {
        return p.node;
      });
    }), $$.updateSvgSize();
    // Define regions
    var main = $el.svg.append("g").attr("transform", $$.getTranslate("main"));

    // data.onmin/max callback
    if ($el.main = main, config.subchart_show && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), config.data_empty_label_text && main.append("text").attr("class", config_classes.text + " " + config_classes.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
    .attr("dominant-baseline", "middle"), $$.isAxis && ($$.initRegion && $$.initRegion(), !config.clipPath && $$.axis.init()), main.append("g").attr("class", config_classes.chart).attr("clip-path", state.clip.path), $$.callPluginHook("$init"), $$.isAxis && ($$.initEventRect && $$.initEventRect(), $$.initGrid && $$.initGrid(), $$.isAxis && main.insert("rect", config.zoom_privileged ? null : "g." + config_classes.regions).attr("class", config_classes.zoomRect).attr("width", $$.state.width).attr("height", $$.state.height).style("opacity", "0").on("dblclick.zoom", null), config.clipPath && $$.axis && $$.axis.init()), $$.initChartElements(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$, $$.api), $$.setBackground(), $$.redraw({
      withTransition: !1,
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withTransitionForAxis: !1,
      initializing: !0
    }), config.data_onmin || config.data_onmax) {
      var minMax = $$.getMinMaxData();
      callFn(config.data_onmin, $$, minMax.min), callFn(config.data_onmax, $$, minMax.max);
    } // Bind resize event


    $$.bindResize(), $$.api.element = $el.chart.node(), state.rendered = !0;
  }, _proto.initChartElements = function initChartElements() {
    var $$ = this,
        types = $$.isAxis ? ["Bar", "Bubble", "Line"] : ["Arc", "Gauge", "Pie", "Radar"];
    types.forEach(function (v) {
      $$["init" + v]();
    }), notEmpty($$.config.data_labels) && $$.initText();
  }, _proto.setChartElements = function setChartElements() {
    var $$ = this,
        $el = $$.$el;
    $$.api.$ = {
      chart: $el.chart,
      svg: $el.svg,
      defs: $el.defs,
      main: $el.main,
      tooltip: $el.tooltip,
      legend: $el.legend,
      title: $el.title,
      grid: $el.grid,
      arc: $el.arcs,
      bar: {
        bars: $el.bar
      },
      line: {
        lines: $el.line,
        areas: $el.area,
        circles: $el.circle
      },
      text: {
        texts: $el.text
      }
    };
  }
  /**
   * Set background element/image
   * @private
   */
  , _proto.setBackground = function setBackground() {
    var $$ = this,
        bg = $$.config.background,
        svg = $$.$el.svg;

    if (notEmpty(bg)) {
      var element = svg.select("." + config_classes[$$.hasArcType() ? "chart" : "regions"]).insert(bg.imgUrl ? "image" : "rect", ":first-child");
      bg.imgUrl ? element.attr("href", bg.imgUrl) : bg.color && element.style("fill", bg.color), element.attr("class", bg.class || null).attr("width", "100%").attr("height", "100%");
    }
  }, _proto.smoothLines = function smoothLines(el, type) {
    type === "grid" && el.each(function () {
      var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      ["x1", "x2", "y1", "y2"].forEach(function (v) {
        return g.attr(v, Math.ceil(+g.attr(v)));
      });
    });
  }
  /**
   * Update size values
   * @param {Boolean} isInit If is called at initialization
   * @private
   */
  , _proto.updateSizes = function updateSizes(isInit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        isRotated = config.axis_rotated,
        hasArc = $$.hasArcType(),
        currLegend = {
      width: legend ? $$.getLegendWidth() : 0,
      height: legend ? $$.getLegendHeight() : 0
    },
        legendHeightForBottom = state.isLegendRight || state.isLegendInset ? 0 : currLegend.height,
        xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
        subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
        subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
    isInit || $$.setContainerSize(), state.margin = isRotated ? {
      top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
    } : {
      top: 4 + $$.getCurrentPaddingTop(),
      // for top tick text
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: hasArc ? 0 : $$.getCurrentPaddingLeft()
    }, state.margin2 = isRotated ? {
      top: state.margin.top,
      right: NaN,
      bottom: 20 + legendHeightForBottom,
      left: $$.state.rotatedPadding.left
    } : {
      top: state.currentHeight - subchartHeight - legendHeightForBottom,
      right: NaN,
      bottom: subchartXAxisHeight + legendHeightForBottom,
      left: state.margin.left
    }, state.margin3 = {
      top: 0,
      right: NaN,
      bottom: 0,
      left: 0
    }, $$.updateSizeForLegend && $$.updateSizeForLegend(currLegend), state.width = state.currentWidth - state.margin.left - state.margin.right, state.height = state.currentHeight - state.margin.top - state.margin.bottom, state.width < 0 && (state.width = 0), state.height < 0 && (state.height = 0), state.width2 = isRotated ? state.margin.left - state.rotatedPadding.left - state.rotatedPadding.right : state.width, state.height2 = isRotated ? state.height : state.currentHeight - state.margin2.top - state.margin2.bottom, state.width2 < 0 && (state.width2 = 0), state.height2 < 0 && (state.height2 = 0), state.arcWidth = state.width - (state.isLegendRight ? currLegend.width + 10 : 0), state.arcHeight = state.height - (state.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && (state.arcHeight += state.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), state.isLegendRight && hasArc && (state.margin3.left = state.arcWidth / 2 + state.radiusExpanded * 1.1);
  }
  /**
   * Update targeted element with given data
   * @param {Object} targets Data object formatted as 'target'
   * @private
   */
  , _proto.updateTargets = function updateTargets(targets) {
    var $$ = this; // Text

    $$.updateTargetsForText(targets), $$.isAxis ? ($$.updateTargetsForBar(targets), $$.updateTargetsForLine(targets), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets)) : $$.hasArcType(targets) && ($$.hasType("radar") ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.showTargets();
  }
  /**
   * Display targeted elements
   * @private
   */
  , _proto.showTargets = function showTargets() {
    var $$ = this;
    $$.$el.svg.selectAll("." + config_classes.target).filter(function (d) {
      return $$.isTargetToShow(d.id);
    }).transition().duration($$.config.transition_duration).style("opacity", "1");
  }, _proto.getWithOption = function getWithOption(options) {
    var withOptions = {
      Y: !0,
      Subchart: !0,
      Transition: !0,
      EventRect: !0,
      Dimension: !0,
      TrimXDomain: !0,
      Transform: !1,
      UpdateXDomain: !1,
      UpdateOrgXDomain: !1,
      Legend: !1,
      UpdateXAxis: "UpdateXDomain",
      TransitionForExit: "Transition",
      TransitionForAxis: "Transition"
    };
    return Object.keys(withOptions).forEach(function (key) {
      var defVal = withOptions[key];
      isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with" + key, defVal);
    }), withOptions;
  }, _proto.redraw = function redraw(options, transitionsValue) {
    options === void 0 && (options = {});
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        main = $el.main,
        targetsToShow = $$.filterTargetsToShow($$.data.targets),
        initializing = options.initializing,
        flow = options.flow,
        wth = $$.getWithOption(options),
        duration = wth.Transition ? config.transition_duration : 0,
        durationForExit = wth.TransitionForExit ? duration : 0,
        durationForAxis = wth.TransitionForAxis ? duration : 0,
        transitions = transitionsValue || $$.axis && $$.axis.generateTransitions(durationForAxis);
    initializing && config.tooltip_init_show || state.inputType !== "touch" || $$.hideTooltip(), $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), ($$.isAxis || $$.hasType("radar")) && $$.updateCircle(), $$.isAxis ? ($$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), $$.updateCircleY(), $$.updategridFocus(), config.data_empty_label_text && main.select("text." + config_classes.text + "." + config_classes.empty).attr("x", state.width / 2).attr("y", state.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.updateGrid(duration), $$.updateRegion(duration), $$.updateBar(durationForExit), $$.updateLine(durationForExit), $$.updateArea(durationForExit), $$.hasDataLabel() && $$.updateText(durationForExit), $el.text && main.selectAll("." + config_classes.selectedCircles).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && $$.bindZoomEvent()) : ($el.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $$.radars && $$.redrawRadar(duration, durationForExit)), $$.redrawTitle && $$.redrawTitle(), initializing && $$.setChartElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
  }
  /**
   * Generate redraw list
   * @param {Object} targets targets data to be shown
   * @param {Object} flow
   * @param {Object} duration
   * @param {Boolean} withSubchart whether or not to show subchart
   * @private
   */
  , _proto.generateRedrawList = function generateRedrawList(targets, flow, duration, withSubchart) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        shape = $$.getDrawShape();
    $$.isAxis && config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
    // generate flow
    var flowFn = flow && $$.generateFlow({
      targets: targets,
      flow: flow,
      duration: flow.duration,
      shape: shape,
      xv: $$.xv.bind($$)
    }),
        isTransition = (duration || flowFn) && $$.isTabVisible(),
        redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
        afterRedraw = flow || config.onrendered ? function () {
      flowFn && flowFn(), callFn(config.onrendered, $$, $$.api);
    } : null;
    if (afterRedraw) // Only use transition when current tab is visible.
      if (isTransition && redrawList.length) {
        // Wait for end of transitions for callback
        var waitForDraw = $$.generateWait(); // transition should be derived from one transition

        Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
          redrawList.reduce(function (acc, t1) {
            return acc.concat(t1);
          }, []).forEach(function (t) {
            return waitForDraw.add(t);
          });
        }).call(waitForDraw, afterRedraw);
      } else state.transiting || afterRedraw(); // update fadein condition

    $$.mapToIds($$.data.targets).forEach(function (id) {
      state.withoutFadeIn[id] = !0;
    });
  }
  /**
   * Get the shape draw function
   * @return {Object}
   * @private
   */
  , _proto.getDrawShape = function getDrawShape() {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        hasRadar = $$.hasType("radar"),
        shape = {
      type: {},
      indices: {},
      pos: {}
    };

    // setup drawer - MEMO: these must be called after axis updated
    if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
      var indices = $$.getShapeIndices($$.isLineType);

      if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
        var _indices = $$.getShapeIndices($$.isAreaType);

        shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
      }
    }

    if ($$.hasType("bar")) {
      var _indices2 = $$.getShapeIndices($$.isBarType);

      shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
    }

    return ($$.isAxis || hasRadar) && (shape.pos = {
      xForText: $$.generateXYForText(shape.indices, !0),
      yForText: $$.generateXYForText(shape.indices, !1),
      // generate circle x/y functions depending on updated params
      cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
      cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
    }), shape;
  }, _proto.getRedrawList = function getRedrawList(shape, flow, flowFn, isTransition) {
    var $$ = this,
        config = $$.config,
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        list = [];

    if ($$.isAxis) {
      var _shape$type = shape.type,
          area = _shape$type.area,
          bar = _shape$type.bar,
          line = _shape$type.line;
      (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && (list.push($$.redrawLine(line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition))), $$.hasType("bar") && list.push($$.redrawBar(bar, isTransition)), notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition));
    }

    return ($$.isAxis || $$.hasType("radar")) && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
  }, _proto.updateAndRedraw = function updateAndRedraw(options) {
    options === void 0 && (options = {});
    var transitions,
        $$ = this,
        config = $$.config;
    options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
  }, _proto.redrawWithoutRescale = function redrawWithoutRescale() {
    this.redraw({
      withY: !1,
      withSubchart: !1,
      withEventRect: !1,
      withTransitionForAxis: !1
    });
  }, _proto.isTimeSeries = function isTimeSeries() {
    return this.config.axis_x_type === "timeseries";
  }, _proto.isCategorized = function isCategorized() {
    return this.config.axis_x_type.indexOf("category") >= 0 || this.hasType("radar");
  }, _proto.isCustomX = function isCustomX() {
    var $$ = this,
        config = $$.config;
    return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
  }, _proto.isTimeSeriesY = function isTimeSeriesY() {
    return this.config.axis_y_type === "timeseries";
  }, _proto.getTranslate = function getTranslate(target, index) {
    index === void 0 && (index = 0);
    var x,
        y,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        hasGauge = $$.hasType("gauge"),
        padding = 0;
    if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel(state.margin.left), y = asHalfPixel(state.margin.top);else if (target === "context") x = asHalfPixel(state.margin2.left), y = asHalfPixel(state.margin2.top);else if (target === "legend") x = state.margin3.left, y = state.margin3.top + (hasGauge ? 10 : 0);else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : state.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? state.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : state.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subX") x = 0, y = isRotated ? 0 : state.height2;else if (target === "arc") x = state.arcWidth / 2, y = state.arcHeight / 2;else if (target === "radar") {
      var _$$$getRadarSize = $$.getRadarSize(),
          width = _$$$getRadarSize[0];

      x = state.width / 2 - width, y = asHalfPixel(state.margin.top);
    }
    return "translate(" + x + ", " + y + ")";
  }, _proto.initialOpacity = function initialOpacity(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? "1" : "0";
  }, _proto.initialOpacityForCircle = function initialOpacityForCircle(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
  }, _proto.opacityForCircle = function opacityForCircle(d) {
    var opacity = this.config.point_show ? "1" : "0";
    return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
  }, _proto.opacityForText = function opacityForText() {
    return this.hasDataLabel() ? "1" : "0";
  }
  /**
   * Get the zoom or unzoomed scaled value
   * @param {Date|Number|Object} d Data value
   * @private
   */
  , _proto.xx = function xx(d) {
    var $$ = this,
        config = $$.config,
        _$$$scale3 = $$.scale,
        x = _$$$scale3.x,
        zoom = _$$$scale3.zoom,
        fn = config.zoom_enabled && zoom ? zoom : x;
    return d ? fn(isValue(d.x) ? d.x : d) : null;
  }, _proto.xv = function xv(d) {
    var $$ = this,
        config = $$.config,
        x = $$.scale.x,
        value = $$.getBaseValue(d);
    return $$.isTimeSeries() ? value = $$.parseDate(value) : $$.isCategorized() && isString(value) && (value = config.axis_x_categories.indexOf(value)), Math.ceil(x(value));
  }, _proto.yv = function yv(d) {
    var $$ = this,
        _$$$scale4 = $$.scale,
        y = _$$$scale4.y,
        y2 = _$$$scale4.y2,
        yScale = d.axis && d.axis === "y2" ? y2 : y;
    return Math.ceil(yScale($$.getBaseValue(d)));
  }, _proto.subxx = function subxx(d) {
    return d ? this.scale.subX(d.x) : null;
  }, _proto.transformMain = function transformMain(withTransition, transitions) {
    var xAxis,
        yAxis,
        y2Axis,
        $$ = this,
        main = $$.$el.main;
    transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = main.select("." + config_classes.axisX), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = main.select("." + config_classes.axisY), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = main.select("." + config_classes.axisY2), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? main.transition() : main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), main.select("." + config_classes.chartArcs).attr("transform", $$.getTranslate("arc"));
  }, _proto.transformAll = function transformAll(withTransition, transitions) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.transformMain(withTransition, transitions), config.subchart_show && $$.transformContext(withTransition, transitions), $el.legend && $$.transformLegend(withTransition);
  }, _proto.updateSvgSize = function updateSvgSize() {
    var $$ = this,
        state = $$.state,
        svg = $$.$el.svg;

    if (svg.attr("width", state.currentWidth).attr("height", state.currentHeight), $$.isAxis) {
      var brush = svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), svg.selectAll(["#" + state.clip.id, "#" + state.clip.idGrid]).select("rect").attr("width", state.width).attr("height", state.height), svg.select("#" + state.clip.idXAxis).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), svg.select("#" + state.clip.idYAxis).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), state.clip.idSubchart && svg.select("#" + state.clip.idSubchart).select("rect").attr("width", state.width).attr("height", brushSize.height), svg.select("." + config_classes.zoomRect).attr("width", state.width).attr("height", state.height);
    }
  }, _proto.updateDimension = function updateDimension(withoutAxis) {
    var $$ = this,
        config = $$.config,
        axis = $$.$el.axis;
    $$.isAxis && !withoutAxis && ($$.axis.x && config.axis_rotated ? ($$.axis.x.create(axis.x), $$.axis.subX && $$.axis.subX.create(axis.subX)) : ($$.axis.y && $$.axis.y.create(axis.y), $$.axis.y2 && $$.axis.y2.create(axis.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
  }, _proto.bindResize = function bindResize() {
    var $$ = this,
        config = $$.config;
    $$.resizeFunction = $$.generateResize(), $$.resizeFunction.add(function () {
      return callFn(config.onresize, $$, $$.api);
    }), config.resize_auto && $$.resizeFunction.add(function () {
      $$.resizeTimeout && (win.clearTimeout($$.resizeTimeout), $$.resizeTimeout = null), $$.resizeTimeout = win.setTimeout(function () {
        $$.api.flush(!1, !0);
      }, 200);
    }), $$.resizeFunction.add(function () {
      return callFn(config.onresized, $$, $$.api);
    }), win.addEventListener("resize", $$.resizeFunction);
  }, _proto.generateResize = function generateResize() {
    function callResizeFunctions() {
      resizeFunctions.forEach(function (f) {
        return f();
      });
    }

    var resizeFunctions = [];
    return callResizeFunctions.add = function (f) {
      return resizeFunctions.push(f);
    }, callResizeFunctions.remove = function (f) {
      return resizeFunctions.splice(resizeFunctions.indexOf(f), 1);
    }, callResizeFunctions;
  }, _proto.endall = function endall(transition, callback) {
    var n = 0;
    transition.each(function () {
      return ++n;
    }).on("end", function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

      --n || callback.apply.apply(callback, [this].concat(args));
    });
  }, _proto.generateWait = function generateWait() {
    var transitionsToWait = [],
        f = function (t, callback) {
      function loop() {
        for (var _t, done = 0, i = 0; _t = transitionsToWait[i]; i++) {
          if (_t.empty()) {
            done++;
            continue;
          }

          try {
            _t.transition();
          } catch (e) {
            done++;
          }
        }

        timer && clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = setTimeout(loop, 50);
      }

      var timer;
      loop();
    };

    return f.add = function (t) {
      isArray(t) ? transitionsToWait = transitionsToWait.concat(t) : transitionsToWait.push(t);
    }, f;
  }, _proto.parseDate = function parseDate(date) {
    var parsedDate,
        $$ = this;
    return date instanceof Date ? parsedDate = date : isString(date) ? parsedDate = $$.format.dataTime($$.config.data_xFormat)(date) : isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date)), (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '" + date + "' to Date object"), parsedDate;
  }, _proto.isTabVisible = function isTabVisible() {
    return !browser_doc.hidden;
  }, _proto.convertInputType = function convertInputType() {
    var $$ = this,
        config = $$.config,
        isMobile = !1;

    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop
    if (/Mobi/.test(win.navigator.userAgent) && config.interaction_inputType_touch) {
      // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
      var hasTouchPoints = win.navigator && "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0,
          hasTouch = "ontouchmove" in win || win.DocumentTouch && browser_doc instanceof win.DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
      // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

      isMobile = hasTouchPoints || hasTouch;
    }

    var hasMouse = config.interaction_inputType_mouse && !isMobile && "onmouseover" in win;
    return hasMouse && "mouse" || isMobile && "touch" || null;
  }
  /**
   * Call plugin hook
   * @param {String} phase The lifecycle phase
   * @private
   */
  , _proto.callPluginHook = function callPluginHook(phase) {
    for (var _this = this, _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];

    this.config.plugins.forEach(function (v) {
      phase === "$beforeInit" && (v.$$ = _this, _this.api.plugins.push(v)), v[phase].apply(v, args);
    });
  }, ChartInternal;
}();


extend(ChartInternal_ChartInternal.prototype, [// common
data_convert, ChartInternal_data_data, data_load, internals_class, internals_color, internals_domain, interactions_interaction, internals_format, internals_legend, internals_scale, internals_size, internals_text, internals_title, internals_tooltip, internals_type].concat(resolver_arc.internal, resolver_axis.internal));
// CONCATENATED MODULE: ./src/config/config.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Load configuration option
 * @param {Object} config User's generation config value
 * @private
 */

function loadConfig(config) {
  var target,
      keys,
      read,
      thisConfig = this.config,
      find = function () {
    var key = keys.shift();
    return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
  };

  Object.keys(thisConfig).forEach(function (key) {
    target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
  });
}
// CONCATENATED MODULE: ./src/chart/api/chart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_chart = ({
  /**
   * Resize the chart.
   * @method resize
   * @instance
   * @memberof Chart
   * @param {Object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var config = this.internal.config;
    config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0);
  },

  /**
   * Force to redraw.
   * @method flush
   * @instance
   * @memberof Chart
   * @param {Boolean} [soft] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft, _isFromResize) {
    var $$ = this.internal;
    $$.state.rendered ? (_isFromResize ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.scale.zoom = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    })) : $$.initToRender(!0);
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @method destroy
   * @instance
   * @memberof Chart
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal,
        _$$$$el = $$.$el,
        chart = _$$$$el.chart,
        svg = _$$$$el.svg;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), svg.select("*").interrupt(), isDefined($$.resizeTimeout) && win.clearTimeout($$.resizeTimeout), win.removeEventListener("resize", $$.resizeFunction), chart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @method config
   * @instance
   * @memberof Chart
   * @param {String} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {Boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function (name, value, redraw) {
    var res,
        $$ = this.internal,
        config = $$.config,
        key = name && name.replace(/\./g, "_");
    return key in config && (isDefined(value) ? (config[key] = value, res = value, redraw && this.flush()) : res = config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/chart/api/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_color = ({
  /**
   * Get the color
   * @method color
   * @instance
   * @memberof Chart
   * @param {String} id id to get the color
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/chart/api/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Get data loaded in the chart.
 * @method data
 * @instance
 * @memberof Chart
 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @return {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */

function api_data_data(targetIds) {
  var targets = this.internal.data.targets;

  if (!isUndefined(targetIds)) {
    var ids = isArray(targetIds) ? targetIds : [targetIds];
    return targets.filter(function (t) {
      return ids.some(function (v) {
        return v === t.id;
      });
    });
  }

  return targets;
}

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @method data․shown
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @return {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @method data․values
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @return {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetId, flat) {
    flat === void 0 && (flat = !0);
    var values;

    if (targetId) {
      var targets = this.data(targetId);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @method data․names
   * @instance
   * @memberof Chart
   * @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @return {Object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    var $$ = this.internal; // reset existing legend item dimension data

    return $$.getLegendItemTextBox(), $$.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @method data․colors
   * @instance
   * @memberof Chart
   * @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @return {Object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @method data․axes
   * @instance
   * @memberof Chart
   * @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @return {Object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @method data․min
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @method data․max
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
});
/* harmony default export */ var api_data = ({
  data: api_data_data
});
// CONCATENATED MODULE: ./src/chart/api/export.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Encode to base64
 * @param {String} str
 * @return {String}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode(+("0x" + p));
  }));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node
 * @param {object} size
 * @return {String}
 * @private
 */


function nodeToSvgDataUrl(node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser_doc.styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser_doc.createElement("style"); // escape css for XML

  style.appendChild(browser_doc.createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = ("<svg xmlns=\"" + external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg + "\" width=\"" + size.width + "\" height=\"" + size.height + "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t" + styleXml + "\n\t\t\t\t" + nodeXml.replace(/(url\()[^#]+/g, "$1") + "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64," + b64EncodeUnicode(dataStr);
}

/* harmony default export */ var api_export = ({
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @method export
   * @instance
   * @memberof Chart
   * @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @return {String} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  export: function _export(mimeType, callback) {
    var $$ = this.internal,
        _$$$state = $$.state,
        width = _$$$state.currentWidth,
        height = _$$$state.currentHeight,
        size = {
      width: width,
      height: height
    },
        svgDataUrl = nodeToSvgDataUrl(this.element, size);

    if (callback && isFunction(callback)) {
      var img = new Image();
      img.crossOrigin = "Anonymous", img.onload = function () {
        var canvas = browser_doc.createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = size.width, canvas.height = size.height, ctx.drawImage(img, 0, 0), callback(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/chart/api/focus.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_focus = ({
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @method focus
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && ($$.expandArc(targetIds), $$.hasType("gauge") && $$.markOverlapped(targetIdsValue, $$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !0), state.focusedTargetIds = targetIds, state.defocusedTargetIds = state.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @method defocus
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && ($$.unexpandArc(targetIds), $$.hasType("gauge") && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !1), state.focusedTargetIds = state.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), state.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @method revert
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $el.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $el.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), state.focusedTargetIds = [], state.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/chart/api/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define legend
 * @ignore
 */
var legend_legend = {
  /**
   * Show legend for each target.
   * @method legend․show
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @method legend․hide
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
};
/* harmony default export */ var api_legend = ({
  legend: legend_legend
});
// CONCATENATED MODULE: ./src/chart/api/load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var load = ({
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @method load
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded. Checkout the example. |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set request header if loading via `data.url`.<br>@see [data․headers](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [data․keys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [data․mimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json",
   *
   *     // set request header if is needed
   *     headers: {
   *       "Content-Type": "text/json"
   *     }
   * });
   * @example
   * chart.load({
   *     data: [
   *       // equivalent as: columns: [["data1", 30, 200, 100]]
   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
   *
   *       // or
   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
   *     ]
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @method unload
   * @instance
   * @memberof Chart
   * @param {Object} args
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var $$ = this.internal,
        args = argsValue || {};
    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.cache.remove(ids), args.done && args.done();
    });
  }
});
// CONCATENATED MODULE: ./src/chart/api/show.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Show/Hide data series
 * @private
 */
function showHide(show, targetIdsValue, options) {
  var $$ = this.internal,
      targetIds = $$.mapToTargetIds(targetIdsValue);
  $$[(show ? "remove" : "add") + "HiddenTargetIds"](targetIds);
  var targets = $$.$el.svg.selectAll($$.selectorTargets(targetIds)),
      opacity = show ? "1" : "0";
  targets.transition().style("opacity", opacity, "important").call($$.endall, function () {
    targets.style("opacity", null).style("opacity", opacity);
  }), options.withLegend && $$[(show ? "show" : "hide") + "Legend"](targetIds), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0,
    withLegend: !0
  });
}

/* harmony default export */ var api_show = ({
  /**
   * Show data series on chart
   * @method show
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @method hide
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @method toggle
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds, options) {
    var _this = this;

    options === void 0 && (options = {});
    var $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };
    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/chart/api/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define tooltip
 * @ignore
 */

var tooltip_tooltip = {
  /**
   * Show tooltip
   * @method tooltip․show
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {Number &verbar; Date}: x Axis value<br>- index {Number}: x Axis index (useless for data.xs)<br>- id {String}: data id<br>- value {Number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.
   *  chart.tooltip.show({
   *    x: 2,
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show(args) {
    var index,
        mouse,
        $$ = this.internal,
        config = $$.config,
        inputType = $$.state.inputType;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var y = $$.getYScale(args.data.id)(args.data.value);
      $$.isMultipleX() ? mouse = [$$.scale.x(args.data.x), y] : (!config.tooltip_grouped && (mouse = [0, y]), index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    (inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @method tooltip․hide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal;
    $$.hideTooltip(!0), $$.hideGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
};
/* harmony default export */ var api_tooltip = ({
  tooltip: tooltip_tooltip
});
// CONCATENATED MODULE: ./src/chart/Chart.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */













/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
*/

/**
 * Access instance's primary node elements
 * @member {Object} $
 * @property {Object} $
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {Object} $.bar
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {Object} $.line
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {d3.selection} $.line.circles Data point circle elements
 * @property {Object} $.text
 * @property {d3.selection} $.text.texts Data label text elements
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

var Chart_Chart =
/**
 * Plugin instance array
 * @member {Array} plugins
 * @memberof Chart
 * @instance
 * @example
 *  var chart = bb.generate({
 *     ...
 *     plugins: [
 *        new bb.plugin.stanford({ ... }),
 *        new PluginA()
 *     ]
 *  });
 *
 *  chart.plugins; // [Stanford, PluginA] - instance array
 */
function Chart(options) {
  _defineProperty(this, "plugins", []), _defineProperty(this, "internal", void 0);
  var ctx = this,
      _options$data = options.data,
      type = _options$data.type,
      types = _options$data.types,
      $$ = new ChartInternal_ChartInternal(ctx);
  // bind to namespaced APIs
  this.internal = $$, function bindThis(fn, target, argThis) {
    Object.keys(fn).forEach(function (key) {
      var isFunc = isFunction(fn[key]),
          isChild = target !== argThis,
          hasChild = Object.keys(fn[key]).length > 0;
      isFunc && (!isChild && hasChild || isChild) ? target[key] = fn[key].bind(argThis) : !isFunc && (target[key] = {}), hasChild && bindThis(fn[key], target[key], argThis);
    });
  }(Chart.prototype, this, this), loadConfig.call($$, options), $$.beforeInit(), $$.init(), $$.afterInit();
}; // extend common APIs as part of Chart class



extend(Chart_Chart.prototype, [api_chart, api_color, api_data, api_export, api_focus, api_legend, load, api_show, api_tooltip].concat(resolver_axis.api));
// CONCATENATED MODULE: ./src/index.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bb", function() { return bb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return bb; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */

 // eslint-disable-next-line no-use-before-define


var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {String} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "2.0.0-alpha",

  /**
   * Generate chart
   * @param {Options} options chart options
   * @memberof bb
   * @return {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @return {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {Object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {}
};
/**
 * @namespace bb
 * @version 2.0.0-alpha
 */

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw1LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvbG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3JlbG9hZEFwcC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvY3JlYXRlU29ja2V0VXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90IHN5bmMgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIiwid2VicGFjazovLy8od2VicGFjaykvaG90L2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2Nzcz8xYjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2NzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdGltZS1mb3JtYXRcIixcImNvbW1vbmpzMlwiOlwiZDMtdGltZS1mb3JtYXRcIixcImFtZFwiOlwiZDMtdGltZS1mb3JtYXRcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2VsZWN0aW9uXCIsXCJjb21tb25qczJcIjpcImQzLXNlbGVjdGlvblwiLFwiYW1kXCI6XCJkMy1zZWxlY3Rpb25cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdHJhbnNpdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJhbWRcIjpcImQzLXRyYW5zaXRpb25cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYnJ1c2hcIixcImNvbW1vbmpzMlwiOlwiZDMtYnJ1c2hcIixcImFtZFwiOlwiZDMtYnJ1c2hcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYXhpc1wiLFwiY29tbW9uanMyXCI6XCJkMy1heGlzXCIsXCJhbWRcIjpcImQzLWF4aXNcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2NhbGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2NhbGVcIixcImFtZFwiOlwiZDMtc2NhbGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHN2XCIsXCJjb21tb25qczJcIjpcImQzLWRzdlwiLFwiYW1kXCI6XCJkMy1kc3ZcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHJhZ1wiLFwiY29tbW9uanMyXCI6XCJkMy1kcmFnXCIsXCJhbWRcIjpcImQzLWRyYWdcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtem9vbVwiLFwiY29tbW9uanMyXCI6XCJkMy16b29tXCIsXCJhbWRcIjpcImQzLXpvb21cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZWFzZVwiLFwiY29tbW9uanMyXCI6XCJkMy1lYXNlXCIsXCJhbWRcIjpcImQzLWVhc2VcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtY29sb3JcIixcImNvbW1vbmpzMlwiOlwiZDMtY29sb3JcIixcImFtZFwiOlwiZDMtY29sb3JcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2hhcGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2hhcGVcIixcImFtZFwiOlwiZDMtc2hhcGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtaW50ZXJwb2xhdGVcIixcImNvbW1vbmpzMlwiOlwiZDMtaW50ZXJwb2xhdGVcIixcImFtZFwiOlwiZDMtaW50ZXJwb2xhdGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NsYXNzZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9TdG9yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvZGF0YS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9pbnRlcmFjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL2xlZ2VuZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3RpdGxlLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vdG9vbHRpcC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvZGF0YS9heGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9kYXRhL3NlbGVjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy94LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9heGlzL3kudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2F4aXMveTIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZS9icm93c2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvdXRpbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy9heGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3BvaW50LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vc3ViY2hhcnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi96b29tLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9hcmVhLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9iYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL2J1YmJsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvbGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvc3BsaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9kb251dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvZ2F1Z2UudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL3BpZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvcmFkYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL09wdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZS9DYWNoZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXNSZW5kZXJlckhlbHBlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXNSZW5kZXJlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9BeGlzL0F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvZGF0YS9kYXRhLmNvbnZlcnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvZGF0YS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvZGF0YS5sb2FkLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2xhc3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9kb21haW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2Zvcm1hdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvbGVnZW5kLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zY2FsZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvc2l6ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdGV4dC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdGl0bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3Rvb2x0aXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25zdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvdHlwZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL2Zsb3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncmlkLngudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncmlkLnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9ncm91cC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnQvYXBpL3JlZ2lvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0L2FwaS94LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydC9hcGkvem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZHJhZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZmxvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZXZlbnRyZWN0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9zdWJjaGFydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2F0ZWdvcnkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NsaXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2dyaWQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3JlZ2lvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvc2VsZWN0aW9uLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL2Jhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9idWJibGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvbGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9wb2ludC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9zaGFwZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL3Jlc29sdmVyL2F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYXJjLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL3JhZGFyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvcmVzb2x2ZXIvYXJjLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL0NoYXJ0SW50ZXJuYWwudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9jb25maWcudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS9jaGFydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL2NvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL2V4cG9ydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL2ZvY3VzLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvbGVnZW5kLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvbG9hZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL3Nob3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS90b29sdGlwLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9DaGFydC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOlsiYXJjIiwiYXJjTGFiZWxMaW5lIiwiYXJjcyIsImFyZWEiLCJhcmVhcyIsImF4aXMiLCJheGlzWCIsImF4aXNYTGFiZWwiLCJheGlzWSIsImF4aXNZMiIsImF4aXNZMkxhYmVsIiwiYXhpc1lMYWJlbCIsImJhciIsImJhcnMiLCJicnVzaCIsImJ1dHRvbiIsImJ1dHRvblpvb21SZXNldCIsImNoYXJ0IiwiY2hhcnRBcmMiLCJjaGFydEFyY3MiLCJjaGFydEFyY3NCYWNrZ3JvdW5kIiwiY2hhcnRBcmNzR2F1Z2VNYXgiLCJjaGFydEFyY3NHYXVnZU1pbiIsImNoYXJ0QXJjc0dhdWdlVW5pdCIsImNoYXJ0QXJjc1RpdGxlIiwiY2hhcnRBcmNzR2F1Z2VUaXRsZSIsImNoYXJ0QmFyIiwiY2hhcnRCYXJzIiwiY2hhcnRMaW5lIiwiY2hhcnRMaW5lcyIsImNoYXJ0UmFkYXIiLCJjaGFydFJhZGFycyIsImNoYXJ0VGV4dCIsImNoYXJ0VGV4dHMiLCJjaXJjbGUiLCJjaXJjbGVzIiwiY29sb3JQYXR0ZXJuIiwiY29sb3JTY2FsZSIsImRlZm9jdXNlZCIsImRyYWdhcmVhIiwiZW1wdHkiLCJldmVudFJlY3QiLCJldmVudFJlY3RzIiwiZXZlbnRSZWN0c011bHRpcGxlIiwiZXZlbnRSZWN0c1NpbmdsZSIsImZvY3VzZWQiLCJnYXVnZVZhbHVlIiwiZ3JpZCIsImdyaWRMaW5lcyIsImxlZ2VuZEJhY2tncm91bmQiLCJsZWdlbmRJdGVtIiwibGVnZW5kSXRlbUV2ZW50IiwibGVnZW5kSXRlbUZvY3VzZWQiLCJsZWdlbmRJdGVtSGlkZGVuIiwibGVnZW5kSXRlbVBvaW50IiwibGVnZW5kSXRlbVRpbGUiLCJsZXZlbCIsImxldmVscyIsImxpbmUiLCJsaW5lcyIsInJlZ2lvbiIsInJlZ2lvbnMiLCJzZWxlY3RlZENpcmNsZSIsInNlbGVjdGVkQ2lyY2xlcyIsInNoYXBlIiwic2hhcGVzIiwic3RhbmZvcmRFbGVtZW50cyIsInN0YW5mb3JkTGluZSIsInN0YW5mb3JkTGluZXMiLCJzdGFuZm9yZFJlZ2lvbiIsInN0YW5mb3JkUmVnaW9ucyIsInRhcmdldCIsInRleHQiLCJ0ZXh0cyIsInRpdGxlIiwidG9vbHRpcCIsInRvb2x0aXBDb250YWluZXIiLCJ0b29sdGlwTmFtZSIsInhncmlkIiwieGdyaWRGb2N1cyIsInhncmlkTGluZSIsInhncmlkTGluZXMiLCJ4Z3JpZHMiLCJ5Z3JpZCIsInlncmlkRm9jdXMiLCJ5Z3JpZExpbmUiLCJ5Z3JpZExpbmVzIiwieWdyaWRzIiwiem9vbUJydXNoIiwiem9vbVJlY3QiLCJFWFBBTkRFRCIsIlNFTEVDVEVEIiwiSU5DTFVERUQiLCJUZXh0T3ZlcmxhcHBpbmciLCJzdGF0ZSIsIndpZHRoIiwid2lkdGgyIiwiaGVpZ2h0IiwiaGVpZ2h0MiIsIm1hcmdpbiIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsIm1hcmdpbjIiLCJtYXJnaW4zIiwiYXJjV2lkdGgiLCJhcmNIZWlnaHQiLCJjdXJyZW50V2lkdGgiLCJjdXJyZW50SGVpZ2h0IiwiaXNMZWdlbmRSaWdodCIsImlzTGVnZW5kSW5zZXQiLCJpc0xlZ2VuZFRvcCIsImlzTGVnZW5kTGVmdCIsImxlZ2VuZFN0ZXAiLCJsZWdlbmRJdGVtV2lkdGgiLCJsZWdlbmRJdGVtSGVpZ2h0IiwibGVnZW5kSGFzUmVuZGVyZWQiLCJjdXJyZW50TWF4VGlja1dpZHRocyIsIngiLCJzaXplIiwiZG9tYWluIiwieSIsInkyIiwicm90YXRlZFBhZGRpbmciLCJ3aXRob3V0RmFkZUluIiwiaW5wdXRUeXBlIiwiZGF0ZXRpbWVJZCIsImNsaXAiLCJpZCIsImlkWEF4aXMiLCJpZFlBeGlzIiwiaWRHcmlkIiwiaWRTdWJjaGFydCIsInBhdGgiLCJwYXRoWEF4aXMiLCJwYXRoWUF4aXMiLCJwYXRoR3JpZCIsImRyYWdTdGFydCIsImRyYWdnaW5nIiwiZmxvd2luZyIsImNhbmNlbENsaWNrIiwibW91c2VvdmVyIiwicmVuZGVyZWQiLCJ0cmFuc2l0aW5nIiwiaGFzTmVnYXRpdmVWYWx1ZSIsImhhc1Bvc2l0aXZlVmFsdWUiLCJvcmdBcmVhT3BhY2l0eSIsImhpZGRlblRhcmdldElkcyIsImhpZGRlbkxlZ2VuZElkcyIsImZvY3VzZWRUYXJnZXRJZHMiLCJkZWZvY3VzZWRUYXJnZXRJZHMiLCJyYWRpdXMiLCJpbm5lclJhZGl1cyIsImlubmVyUmFkaXVzUmF0aW8iLCJnYXVnZUFyY1dpZHRoIiwicmFkaXVzRXhwYW5kZWQiLCJ4Z3JpZEF0dHIiLCJ4MSIsIngyIiwieTEiLCJkYXRhX2lkQ29udmVydGVyIiwiZGF0YV9uYW1lcyIsImRhdGFfY2xhc3NlcyIsImRhdGFfdHlwZSIsInVuZGVmaW5lZCIsImRhdGFfdHlwZXMiLCJkYXRhX29yZGVyIiwiZGF0YV9jb2xvciIsImRhdGFfY29sb3JzIiwiZGF0YV9oaWRlIiwiZGF0YV9maWx0ZXIiLCJkYXRhX29uY2xpY2siLCJkYXRhX29ub3ZlciIsImRhdGFfb25vdXQiLCJkYXRhX29ubWluIiwiZGF0YV9vbm1heCIsImRhdGFfdXJsIiwiZGF0YV9oZWFkZXJzIiwiZGF0YV9qc29uIiwiZGF0YV9yb3dzIiwiZGF0YV9jb2x1bW5zIiwiZGF0YV9taW1lVHlwZSIsImRhdGFfa2V5cyIsImRhdGFfZW1wdHlfbGFiZWxfdGV4dCIsImNvbG9yX3BhdHRlcm4iLCJjb2xvcl90aWxlcyIsImNvbG9yX3RocmVzaG9sZCIsImNvbG9yX29ub3ZlciIsImludGVyYWN0aW9uX2VuYWJsZWQiLCJpbnRlcmFjdGlvbl9icmlnaHRlbiIsImludGVyYWN0aW9uX2lucHV0VHlwZV9tb3VzZSIsImludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaCIsImxlZ2VuZF9zaG93IiwibGVnZW5kX2hpZGUiLCJsZWdlbmRfY29udGVudHNfYmluZHRvIiwibGVnZW5kX2NvbnRlbnRzX3RlbXBsYXRlIiwibGVnZW5kX3Bvc2l0aW9uIiwibGVnZW5kX2luc2V0X2FuY2hvciIsImxlZ2VuZF9pbnNldF94IiwibGVnZW5kX2luc2V0X3kiLCJsZWdlbmRfaW5zZXRfc3RlcCIsImxlZ2VuZF9pdGVtX29uY2xpY2siLCJsZWdlbmRfaXRlbV9vbm92ZXIiLCJsZWdlbmRfaXRlbV9vbm91dCIsImxlZ2VuZF9lcXVhbGx5IiwibGVnZW5kX3BhZGRpbmciLCJsZWdlbmRfaXRlbV90aWxlX3dpZHRoIiwibGVnZW5kX2l0ZW1fdGlsZV9oZWlnaHQiLCJsZWdlbmRfdXNlUG9pbnQiLCJ0aXRsZV90ZXh0IiwidGl0bGVfcGFkZGluZyIsInRpdGxlX3Bvc2l0aW9uIiwidG9vbHRpcF9zaG93IiwidG9vbHRpcF9kb05vdEhpZGUiLCJ0b29sdGlwX2dyb3VwZWQiLCJ0b29sdGlwX2Zvcm1hdF90aXRsZSIsInRvb2x0aXBfZm9ybWF0X25hbWUiLCJ0b29sdGlwX2Zvcm1hdF92YWx1ZSIsInRvb2x0aXBfcG9zaXRpb24iLCJ0b29sdGlwX2NvbnRlbnRzIiwidG9vbHRpcF9pbml0X3Nob3ciLCJ0b29sdGlwX2luaXRfeCIsInRvb2x0aXBfaW5pdF9wb3NpdGlvbiIsInRvb2x0aXBfbGlua2VkIiwidG9vbHRpcF9saW5rZWRfbmFtZSIsInRvb2x0aXBfb25zaG93IiwidG9vbHRpcF9vbmhpZGUiLCJ0b29sdGlwX29uc2hvd24iLCJ0b29sdGlwX29uaGlkZGVuIiwidG9vbHRpcF9vcmRlciIsImRhdGFfeCIsImRhdGFfeHMiLCJkYXRhX3hGb3JtYXQiLCJkYXRhX3hMb2NhbHRpbWUiLCJkYXRhX3hTb3J0IiwiZGF0YV9ncm91cHMiLCJkYXRhX2F4ZXMiLCJkYXRhX2xhYmVscyIsImRhdGFfbGFiZWxzX2NvbG9ycyIsImRhdGFfbGFiZWxzX3Bvc2l0aW9uIiwiZGF0YV9yZWdpb25zIiwiZGF0YV9zdGFja19ub3JtYWxpemUiLCJkYXRhX3NlbGVjdGlvbl9lbmFibGVkIiwiZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCIsImRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZSIsImRhdGFfc2VsZWN0aW9uX211bHRpcGxlIiwiZGF0YV9zZWxlY3Rpb25fZHJhZ2dhYmxlIiwiZGF0YV9vbnNlbGVjdGVkIiwiZGF0YV9vbnVuc2VsZWN0ZWQiLCJheGlzX3hfY2xpcFBhdGgiLCJheGlzX3hfc2hvdyIsImF4aXNfeF90eXBlIiwiYXhpc194X2xvY2FsdGltZSIsImF4aXNfeF9jYXRlZ29yaWVzIiwiYXhpc194X3RpY2tfY2VudGVyZWQiLCJheGlzX3hfdGlja19mb3JtYXQiLCJheGlzX3hfdGlja19jdWxsaW5nIiwiYXhpc194X3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3hfdGlja19jb3VudCIsImF4aXNfeF90aWNrX3Nob3ciLCJheGlzX3hfdGlja190ZXh0X3Nob3ciLCJheGlzX3hfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc194X3RpY2tfZml0IiwiYXhpc194X3RpY2tfdmFsdWVzIiwiYXhpc194X3RpY2tfcm90YXRlIiwiYXhpc194X3RpY2tfb3V0ZXIiLCJheGlzX3hfdGlja19tdWx0aWxpbmUiLCJheGlzX3hfdGlja193aWR0aCIsImF4aXNfeF90aWNrX3Rvb2x0aXAiLCJheGlzX3hfbWF4IiwiYXhpc194X21pbiIsImF4aXNfeF9wYWRkaW5nIiwiYXhpc194X2hlaWdodCIsImF4aXNfeF9leHRlbnQiLCJheGlzX3hfbGFiZWwiLCJheGlzX3hfYXhlcyIsImF4aXNfeV9jbGlwUGF0aCIsImF4aXNfeV9zaG93IiwiYXhpc195X3R5cGUiLCJheGlzX3lfbWF4IiwiYXhpc195X21pbiIsImF4aXNfeV9pbnZlcnRlZCIsImF4aXNfeV9jZW50ZXIiLCJheGlzX3lfaW5uZXIiLCJheGlzX3lfbGFiZWwiLCJheGlzX3lfdGlja19mb3JtYXQiLCJheGlzX3lfdGlja19jdWxsaW5nIiwiYXhpc195X3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3lfdGlja19vdXRlciIsImF4aXNfeV90aWNrX3ZhbHVlcyIsImF4aXNfeV90aWNrX3JvdGF0ZSIsImF4aXNfeV90aWNrX2NvdW50IiwiYXhpc195X3RpY2tfc2hvdyIsImF4aXNfeV90aWNrX3N0ZXBTaXplIiwiYXhpc195X3RpY2tfdGV4dF9zaG93IiwiYXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeV90aWNrX3RpbWVfdmFsdWUiLCJheGlzX3lfcGFkZGluZyIsImF4aXNfeV9kZWZhdWx0IiwiYXhpc195X2F4ZXMiLCJheGlzX3kyX3Nob3ciLCJheGlzX3kyX21heCIsImF4aXNfeTJfbWluIiwiYXhpc195Ml9pbnZlcnRlZCIsImF4aXNfeTJfY2VudGVyIiwiYXhpc195Ml9pbm5lciIsImF4aXNfeTJfbGFiZWwiLCJheGlzX3kyX3RpY2tfZm9ybWF0IiwiYXhpc195Ml90aWNrX2N1bGxpbmciLCJheGlzX3kyX3RpY2tfY3VsbGluZ19tYXgiLCJheGlzX3kyX3RpY2tfb3V0ZXIiLCJheGlzX3kyX3RpY2tfdmFsdWVzIiwiYXhpc195Ml90aWNrX3JvdGF0ZSIsImF4aXNfeTJfdGlja19jb3VudCIsImF4aXNfeTJfdGlja19zaG93IiwiYXhpc195Ml90aWNrX3N0ZXBTaXplIiwiYXhpc195Ml90aWNrX3RleHRfc2hvdyIsImF4aXNfeTJfdGlja190ZXh0X3Bvc2l0aW9uIiwiYXhpc195Ml9wYWRkaW5nIiwiYXhpc195Ml9kZWZhdWx0IiwiYXhpc195Ml9heGVzIiwid2luIiwiZGVmIiwibyIsInNlbGYiLCJ3aW5kb3ciLCJnbG9iYWwiLCJnbG9iYWxUaGlzIiwiRnVuY3Rpb24iLCJkb2MiLCJkb2N1bWVudCIsImlzVmFsdWUiLCJ2IiwiaXNGdW5jdGlvbiIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc1VuZGVmaW5lZCIsImlzRGVmaW5lZCIsImlzQm9vbGVhbiIsImNlaWwxMCIsIk1hdGgiLCJjZWlsIiwiYXNIYWxmUGl4ZWwiLCJuIiwiZGlmZkRvbWFpbiIsImQiLCJpc09iamVjdFR5cGUiLCJpc0VtcHR5IiwibGVuZ3RoIiwiRGF0ZSIsIk9iamVjdCIsImtleXMiLCJpc05hTiIsIm5vdEVtcHR5IiwiaXNBcnJheSIsImFyciIsIkFycmF5IiwiaXNPYmplY3QiLCJvYmoiLCJub2RlVHlwZSIsImdldE9wdGlvbiIsIm9wdGlvbnMiLCJrZXkiLCJkZWZhdWx0VmFsdWUiLCJoYXNWYWx1ZSIsImRpY3QiLCJ2YWx1ZSIsImZvdW5kIiwiZm9yRWFjaCIsImNhbGxGbiIsImZuIiwiaXNGbiIsImFyZ3MiLCJjYWxsIiwic2FuaXRpc2UiLCJzdHIiLCJyZXBsYWNlIiwic2V0VGV4dFZhbHVlIiwibm9kZSIsImR5IiwidG9NaWRkbGUiLCJpbmRleE9mIiwiZGlmZiIsIm1hcCIsIm11bHRpbGluZSIsInNwbGl0IiwibGVuIiwiaHRtbCIsImkiLCJhcHBlbmQiLCJhdHRyIiwiZ2V0UmVjdFNlZ0xpc3QiLCJnZXRCQm94IiwiZ2V0UGF0aEJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIml0ZW1zIiwibWluIiwiZ2V0QnJ1c2hTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCIkZWwiLCJldmVudCIsImQzRXZlbnQiLCJtYWluIiwiY29udGV4dCIsInR5cGUiLCJzZWxlY3QiLCJDTEFTUyIsImQzQnJ1c2hTZWxlY3Rpb24iLCJnZXRCb3VuZGluZ1JlY3QiLCJyZWN0IiwiZ2V0UmFuZG9tIiwiYXNTdHIiLCJyYW5kIiwicmFuZG9tIiwiYnJ1c2hFbXB0eSIsImN0eCIsImV4dGVuZCIsInNvdXJjZSIsInAiLCJ0ZXN0IiwiY2FwaXRhbGl6ZSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJ0b0FycmF5IiwiZ2V0Q3NzUnVsZXMiLCJzdHlsZVNoZWV0cyIsInJ1bGVzIiwic2hlZXQiLCJjc3NSdWxlcyIsImNvbmNhdCIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJocmVmIiwidG9TdHJpbmciLCJnZXRUcmFuc2xhdGlvbiIsInRyYW5zZm9ybSIsImJhc2VWYWwiLCJnZXRJdGVtIiwibWF0cml4IiwiYSIsImIiLCJjIiwiZiIsImdldFVuaXF1ZSIsImRhdGEiLCJpc0RhdGUiLCJOdW1iZXIiLCJmaWx0ZXIiLCJtZXJnZUFycmF5IiwicmVkdWNlIiwibWVyZ2VPYmoiLCJvYmplY3ROIiwic2hpZnQiLCJzb3J0VmFsdWUiLCJpc0FzYyIsImV2ZXJ5Iiwic29ydCIsImdldE1pbk1heCIsInJlcyIsImdldFJhbmdlIiwic3RhcnQiLCJlbmQiLCJwdXNoIiwiZW11bGF0ZUV2ZW50IiwibW91c2UiLCJnZXRQYXJhbXMiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJNb3VzZUV2ZW50IiwiZWwiLCJldmVudFR5cGUiLCJwYXJhbXMiLCJkaXNwYXRjaEV2ZW50IiwibW91c2VFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdE1vdXNlRXZlbnQiLCJ0b3VjaCIsInRvdWNoT2JqIiwiVG91Y2giLCJpZGVudGlmaWVyIiwibm93IiwicmFkaXVzWCIsInJhZGl1c1kiLCJyb3RhdGlvbkFuZ2xlIiwiZm9yY2UiLCJUb3VjaEV2ZW50Iiwic2hpZnRLZXkiLCJ0b3VjaGVzIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUb3VjaGVzIiwidHBsUHJvY2VzcyIsInRwbCIsIlJlZ0V4cCIsImF4aXNfcm90YXRlZCIsImdyaWRfeF9zaG93IiwiZ3JpZF94X3R5cGUiLCJncmlkX3hfbGluZXMiLCJncmlkX3lfc2hvdyIsImdyaWRfeV9saW5lcyIsImdyaWRfeV90aWNrcyIsImdyaWRfZm9jdXNfZWRnZSIsImdyaWRfZm9jdXNfc2hvdyIsImdyaWRfZm9jdXNfeSIsImdyaWRfZnJvbnQiLCJncmlkX2xpbmVzX2Zyb250IiwicG9pbnRfc2hvdyIsInBvaW50X3IiLCJwb2ludF9zZW5zaXRpdml0eSIsInBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkIiwicG9pbnRfZm9jdXNfZXhwYW5kX3IiLCJwb2ludF9wYXR0ZXJuIiwicG9pbnRfc2VsZWN0X3IiLCJwb2ludF90eXBlIiwic3ViY2hhcnRfc2hvdyIsInN1YmNoYXJ0X3NpemVfaGVpZ2h0Iiwic3ViY2hhcnRfYXhpc194X3Nob3ciLCJzdWJjaGFydF9heGlzX3hfdGlja19zaG93Iiwic3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93Iiwic3ViY2hhcnRfb25icnVzaCIsInpvb21fZW5hYmxlZCIsInpvb21fZXh0ZW50Iiwiem9vbV9wcml2aWxlZ2VkIiwiem9vbV9yZXNjYWxlIiwiem9vbV9vbnpvb20iLCJ6b29tX29uem9vbXN0YXJ0Iiwiem9vbV9vbnpvb21lbmQiLCJ6b29tX3Jlc2V0QnV0dG9uIiwiem9vbV94X21pbiIsInpvb21feF9tYXgiLCJhcmVhX3plcm9iYXNlZCIsImFyZWFfYWJvdmUiLCJhcmVhX2xpbmVhckdyYWRpZW50IiwiYmFyX3BhZGRpbmciLCJiYXJfcmFkaXVzIiwiYmFyX3NlbnNpdGl2aXR5IiwiYmFyX3dpZHRoIiwiYmFyX3dpZHRoX3JhdGlvIiwiYmFyX3dpZHRoX21heCIsImJhcl96ZXJvYmFzZWQiLCJidWJibGVfbWF4UiIsImJ1YmJsZV96ZXJvYmFzZWQiLCJsaW5lX2Nvbm5lY3ROdWxsIiwibGluZV9zdGVwX3R5cGUiLCJsaW5lX3plcm9iYXNlZCIsImxpbmVfY2xhc3NlcyIsImxpbmVfcG9pbnQiLCJzcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlIiwiZG9udXRfbGFiZWxfc2hvdyIsImRvbnV0X2xhYmVsX2Zvcm1hdCIsImRvbnV0X2xhYmVsX3RocmVzaG9sZCIsImRvbnV0X2xhYmVsX3JhdGlvIiwiZG9udXRfd2lkdGgiLCJkb251dF90aXRsZSIsImRvbnV0X2V4cGFuZCIsImRvbnV0X2V4cGFuZF9yYXRlIiwiZG9udXRfZXhwYW5kX2R1cmF0aW9uIiwiZG9udXRfcGFkQW5nbGUiLCJkb251dF9zdGFydGluZ0FuZ2xlIiwiZ2F1Z2VfZnVsbENpcmNsZSIsImdhdWdlX2xhYmVsX3Nob3ciLCJnYXVnZV9sYWJlbF9mb3JtYXQiLCJnYXVnZV9sYWJlbF9leHRlbnRzIiwiZ2F1Z2VfbWluIiwiZ2F1Z2VfbWF4IiwiZ2F1Z2VfdHlwZSIsImdhdWdlX3N0YXJ0aW5nQW5nbGUiLCJQSSIsImdhdWdlX3RpdGxlIiwiZ2F1Z2VfdW5pdHMiLCJnYXVnZV93aWR0aCIsImdhdWdlX2FyY3NfbWluV2lkdGgiLCJnYXVnZV9leHBhbmQiLCJnYXVnZV9leHBhbmRfcmF0ZSIsImdhdWdlX2V4cGFuZF9kdXJhdGlvbiIsInBpZV9sYWJlbF9zaG93IiwicGllX2xhYmVsX2Zvcm1hdCIsInBpZV9sYWJlbF90aHJlc2hvbGQiLCJwaWVfbGFiZWxfcmF0aW8iLCJwaWVfZXhwYW5kIiwicGllX2V4cGFuZF9yYXRlIiwicGllX2V4cGFuZF9kdXJhdGlvbiIsInBpZV9pbm5lclJhZGl1cyIsInBpZV9wYWRBbmdsZSIsInBpZV9wYWRkaW5nIiwicGllX3N0YXJ0aW5nQW5nbGUiLCJyYWRhcl9heGlzX21heCIsInJhZGFyX2F4aXNfbGluZV9zaG93IiwicmFkYXJfYXhpc190ZXh0X3Nob3ciLCJyYWRhcl9heGlzX3RleHRfcG9zaXRpb24iLCJyYWRhcl9sZXZlbF9kZXB0aCIsInJhZGFyX2xldmVsX3Nob3ciLCJyYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdCIsInRvRml4ZWQiLCJyYWRhcl9sZXZlbF90ZXh0X3Nob3ciLCJyYWRhcl9zaXplX3JhdGlvIiwicmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZSIsIk9wdGlvbnMiLCJjb25maWciLCJjb2xvciIsImludGVyYWN0aW9uIiwibGVnZW5kIiwiZG9udXQiLCJnYXVnZSIsInBpZSIsInJhZGFyIiwiZGF0YUF4aXMiLCJkYXRhU2VsZWN0aW9uIiwicG9pbnQiLCJzdWJjaGFydCIsInpvb20iLCJidWJibGUiLCJzcGxpbmUiLCJiaW5kdG8iLCJiYWNrZ3JvdW5kIiwiY2xpcFBhdGgiLCJzdmdfY2xhc3NuYW1lIiwic2l6ZV93aWR0aCIsInNpemVfaGVpZ2h0IiwicGFkZGluZ19sZWZ0IiwicGFkZGluZ19yaWdodCIsInBhZGRpbmdfdG9wIiwicGFkZGluZ19ib3R0b20iLCJyZXNpemVfYXV0byIsIm9ub3ZlciIsIm9ub3V0Iiwib25yZXNpemUiLCJvbnJlc2l6ZWQiLCJvbmJlZm9yZWluaXQiLCJvbmluaXQiLCJvbmFmdGVyaW5pdCIsIm9ucmVuZGVyZWQiLCJ0cmFuc2l0aW9uX2R1cmF0aW9uIiwic2NhdHRlcl96ZXJvYmFzZWQiLCJwbHVnaW5zIiwicmVuZGVyIiwiQ2FjaGUiLCJhZGQiLCJpc0RhdGFUeXBlIiwiY2FjaGUiLCJjbG9uZVRhcmdldCIsInJlbW92ZSIsImdldCIsInRhcmdldHMiLCJyZXNldCIsImFsbCIsIiQkIiwiaWRfb3JnIiwidmFsdWVzIiwiQXhpc1JlbmRlcmVySGVscGVyIiwib3duZXIiLCJzY2FsZSIsImQzU2NhbGVMaW5lYXIiLCJub1RyYW5zaXRpb24iLCJ3aXRob3V0VHJhbnNpdGlvbiIsInJhbmdlIiwic2NhbGVFeHRlbnQiLCJvcmdYU2NhbGUiLCJnZXRTaXplRm9yMUNoYXIiLCJ3IiwiaCIsInRpY2tPZmZzZXQiLCJzdG9wIiwiZ2VuZXJhdGVUaWNrcyIsImlzWUF4ZXMiLCJ0aWNrU3RlcFNpemUiLCJ0aWNrcyIsImludGVydmFsIiwidGlja0FyZ3VtZW50cyIsInJvdW5kIiwidW5zaGlmdCIsImNvcHlTY2FsZSIsIm5ld1NjYWxlIiwiY29weSIsInRleHRGb3JtYXR0ZWQiLCJ0aWNrRm9ybWF0IiwiZm9ybWF0dGVkIiwidHJhbnNpdGlvbmlzZSIsImludGVycnVwdCIsInRyYW5zaXRpb24iLCJBeGlzUmVuZGVyZXIiLCJpbm5lclRpY2tTaXplIiwib3V0ZXJUaWNrU2l6ZSIsIm91dGVyVGljayIsIm9yaWVudCIsInRpY2tDZW50ZXJlZCIsInRpY2tDdWxsaW5nIiwidGlja0xlbmd0aCIsInRpY2tQYWRkaW5nIiwidGlja1ZhbHVlcyIsIm1heCIsImhlbHBlciIsIkhlbHBlciIsImNyZWF0ZSIsImciLCJoZWxwZXJJbnN0Iiwic3BsaXRUaWNrVGV4dCIsImJpbmQiLCJpc0xlZnRSaWdodCIsImlzVG9wQm90dG9tIiwidGlja1RyYW5zZm9ybSIsImF4aXNQeCIsInNpZ24iLCJyb3RhdGUiLCJ0aWNrVGV4dFJvdGF0ZSIsInJhbmdlRXh0ZW50IiwiJGciLCJuYW1lIiwidGlja1RleHRQb3MiLCJwcmVmaXgiLCJheGlzU2hvdyIsInRpY2tTaG93IiwidGljayIsImVhY2giLCJkM1NlbGVjdCIsInNjYWxlMCIsIl9fY2hhcnRfXyIsInNjYWxlMSIsImlzQ2F0ZWdvcnkiLCJzZWxlY3RBbGwiLCJlbnRlciIsIm1lcmdlIiwib3V0ZXJUaWNrU2l6ZWQiLCJ0aWNrRW50ZXIiLCJpbnNlcnQiLCJzdHlsZSIsInRpY2tFeGl0IiwiZXhpdCIsInNpemVGb3IxQ2hhciIsImNvdW50cyIsInRzcGFuIiwiaW5kZXgiLCJ0aWNrTXVsdGlsaW5lIiwic3BsaXR0ZWQiLCJkeCIsInNpbiIsImxpbmVVcGRhdGUiLCJ0ZXh0VXBkYXRlIiwic2V0VGlja0xpbmVUZXh0UG9zaXRpb24iLCJ0aWNrVGl0bGUiLCJiYW5kd2lkdGgiLCJnZXRUaWNrWFkiLCJwb3MiLCJnZXRUaWNrU2l6ZSIsInRpY2tQb3NpdGlvbiIsInRpY2tQb3MiLCJ0ZXh0QW5jaG9yRm9yVGV4dCIsInIiLCJyZXZlcnNlIiwidGV4dFRyYW5zZm9ybSIsInlGb3JUZXh0IiwicjIiLCJjaGFyV2lkdGgiLCJzdWJ0ZXh0Iiwic3BhY2VJbmRleCIsInRleHRXaWR0aCIsInN1YnN0ciIsInRpY2tXaWR0aCIsInRpY2tUZXh0IiwiYXJndW1lbnRzIiwiZm9ybWF0IiwiaXNDZW50ZXJlZCIsInRpY2tJbnRlcnZhbCIsImdldFRvdGFsTGVuZ3RoIiwiSW5maW5pdHkiLCJjdWxsaW5nIiwic2V0VHJhbnNpdGlvbiIsInQiLCJBeGlzIiwic3ViWCIsInNldE9yaWVudCIsImdldEF4aXNDbGFzc05hbWUiLCJpc0hvcml6b250YWwiLCJmb3JIb3Jpem9udGFsIiwiaXNSb3RhdGVkIiwiaW5pdCIsImNsYXNzQXhpcyIsImF4aXNJZCIsImNsYXNzTGFiZWwiLCJnZXRUcmFuc2xhdGUiLCJnZW5lcmF0ZUF4ZXMiLCJ5SW5uZXIiLCJ5MklubmVyIiwiZDNBeGlzIiwiYXhlcyIsImF4ZXNDb25maWciLCJkM0F4aXNMZWZ0IiwiZDNBeGlzQm90dG9tIiwiZDNBeGlzVG9wIiwiZDNBeGlzUmlnaHQiLCJjb3VudCIsInRpY2tTaXplT3V0ZXIiLCJvdXRlciIsImF4ZXNMaXN0IiwidXBkYXRlQXhlcyIsImF4aXNSYW5nZSIsImNsYXNzTmFtZSIsImdldEF4aXMiLCJub1RpY2tUZXh0Um90YXRlIiwiaXNYIiwiaXNDYXRlZ29yaXplZCIsInhBeGlzVGljayIsImF4aXNQYXJhbXMiLCJhcGkiLCJjYXRlZ29yaWVzIiwiaXNUaW1lU2VyaWVzIiwicGFyc2VEYXRlIiwiaXNUaW1lU2VyaWVzWSIsImlzU3RhY2tOb3JtYWxpemVkIiwidXBkYXRlWEF4aXNUaWNrVmFsdWVzIiwiZml0IiwiZ2VuZXJhdGVUaWNrVmFsdWVzIiwibWFwVGFyZ2V0c1RvVW5pcXVlWHMiLCJnZXRJZCIsImdldFhBeGlzVGlja0Zvcm1hdCIsImN1cnJGb3JtYXQiLCJkYXRlIiwiYXhpc1RpbWUiLCJkZWZhdWx0QXhpc1RpbWUiLCJjYXRlZ29yeU5hbWUiLCJhcHBseSIsImdldFRpY2tWYWx1ZXMiLCJnZXRMYWJlbE9wdGlvbkJ5QXhpc0lkIiwiZ2V0TGFiZWxUZXh0Iiwib3B0aW9uIiwic2V0TGFiZWxUZXh0IiwiZ2V0TGFiZWxQb3NpdGlvbiIsImRlZmF1bHRQb3NpdGlvbiIsInBvc2l0aW9uIiwiaGFzIiwiaXNJbm5lciIsImlzT3V0ZXIiLCJpc0xlZnQiLCJpc0NlbnRlciIsImlzUmlnaHQiLCJpc1RvcCIsImlzTWlkZGxlIiwiaXNCb3R0b20iLCJnZXRYQXhpc0xhYmVsUG9zaXRpb24iLCJnZXRZQXhpc0xhYmVsUG9zaXRpb24iLCJnZXRZMkF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0TGFiZWxQb3NpdGlvbkJ5SWQiLCJ0ZXh0Rm9yWEF4aXNMYWJlbCIsInRleHRGb3JZQXhpc0xhYmVsIiwidGV4dEZvclkyQXhpc0xhYmVsIiwieEZvckF4aXNMYWJlbCIsImR4Rm9yQXhpc0xhYmVsIiwidGV4dEFuY2hvckZvckF4aXNMYWJlbCIsImFuY2hvciIsInhGb3JYQXhpc0xhYmVsIiwieEZvcllBeGlzTGFiZWwiLCJ4Rm9yWTJBeGlzTGFiZWwiLCJkeEZvclhBeGlzTGFiZWwiLCJkeEZvcllBeGlzTGFiZWwiLCJkeEZvclkyQXhpc0xhYmVsIiwiZHlGb3JYQXhpc0xhYmVsIiwieEhlaWdodCIsImdldE1heFRpY2tXaWR0aCIsImR5Rm9yWUF4aXNMYWJlbCIsImR5Rm9yWTJBeGlzTGFiZWwiLCJ0ZXh0QW5jaG9yRm9yWEF4aXNMYWJlbCIsInRleHRBbmNob3JGb3JZQXhpc0xhYmVsIiwidGV4dEFuY2hvckZvclkyQXhpc0xhYmVsIiwid2l0aG91dFJlY29tcHV0ZSIsInN2ZyIsImN1cnJlbnRUaWNrTWF4IiwibWF4V2lkdGgiLCJpc1lBeGlzIiwidGFyZ2V0c1RvU2hvdyIsImZpbHRlclRhcmdldHNUb1Nob3ciLCJ0aWNrQ291bnQiLCJkdW1teSIsInVwZGF0ZUxhYmVscyIsIndpdGhUcmFuc2l0aW9uIiwibGFiZWxzIiwiWCIsIlkiLCJZMiIsImF4aXNMYWJlbCIsImdldFBhZGRpbmciLCJwYWRkaW5nIiwiZG9tYWluTGVuZ3RoIiwiY29udmVydFBpeGVsc1RvQXhpc1BhZGRpbmciLCJwaXhlbHMiLCJmb3JUaW1lU2VyaWVzIiwidGlja1ZhbHVlIiwidGFyZ2V0Q291bnQiLCJnZW5lcmF0ZVRyYW5zaXRpb25zIiwiZHVyYXRpb24iLCJheCIsImF4aXNTdWJYIiwicmVkcmF3IiwidHJhbnNpdGlvbnMiLCJpc0hpZGRlbiIsImlzSW5pdCIsIm9wYWNpdHkiLCIkYXhpcyIsInJlZHJhd0F4aXMiLCJ3dGgiLCJmbG93IiwieERvbWFpbkZvclpvb20iLCJoYXNab29tIiwidXBkYXRlWERvbWFpbiIsIlVwZGF0ZVhEb21haW4iLCJVcGRhdGVPcmdYRG9tYWluIiwiVHJpbVhEb21haW4iLCJvcmdEb21haW4iLCJnZXRZRG9tYWluIiwiaGFzQXJjVHlwZSIsIlRyYW5zaXRpb24iLCJVcGRhdGVYQXhpcyIsInNldEN1bGxpbmciLCJzdWJZIiwic3ViWTIiLCJ0b0N1bGwiLCJpbnRlcnZhbEZvckN1bGxpbmciLCJ0aWNrU2l6ZSIsImN1bGxpbmdNYXgiLCJkaXNwbGF5IiwiY29udmVydERhdGEiLCJjYWxsYmFjayIsInVybCIsImNvbnZlcnRVcmxUb0RhdGEiLCJtaW1lVHlwZSIsImhlYWRlcnMiLCJqc29uIiwiY29udmVydEpzb25Ub0RhdGEiLCJyb3dzIiwiY29udmVydFJvd3NUb0RhdGEiLCJjb2x1bW5zIiwiY29udmVydENvbHVtbnNUb0RhdGEiLCJFcnJvciIsImRvbmUiLCJyZXEiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZXRSZXF1ZXN0SGVhZGVyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsInJlc3BvbnNlIiwicmVzcG9uc2VUZXh0IiwiSlNPTiIsInBhcnNlIiwic2VuZCIsImNvbnZlcnRDc3ZUc3ZUb0RhdGEiLCJwYXJzZXIiLCJ4c3YiLCJjb252ZXJ0Q3N2VG9EYXRhIiwiZDNDc3ZQYXJzZVJvd3MiLCJkM0NzdlBhcnNlIiwiY29udmVydFRzdlRvRGF0YSIsInRzdiIsImQzVHN2UGFyc2VSb3dzIiwiZDNUc3ZQYXJzZSIsImtleXNQYXJhbSIsInRhcmdldEtleXMiLCJuZXdSb3dzIiwibmV3Um93IiwiZmluZFZhbHVlSW5Kc29uIiwidG1wIiwib2JqZWN0IiwiY29udmVydGVkUGF0aCIsInBhdGhBcnJheSIsInNvbWUiLCJrIiwicm93IiwiaiIsImNvbCIsImNvbnZlcnREYXRhVG9UYXJnZXRzIiwiYXBwZW5kWHMiLCJ4c0RhdGEiLCJkYXRhS2V5cyIsImlkcyIsImlzTm90WCIsInhzIiwieEtleSIsImdldFhLZXkiLCJpc0N1c3RvbVgiLCJyYXdYIiwiZ2VuZXJhdGVUYXJnZXRYIiwiZ2V0T3RoZXJUYXJnZXRYcyIsImdldFhWYWx1ZXNPZlhLZXkiLCJjb252ZXJ0ZWRJZCIsImhhc0NhdGVnb3J5IiwidjEiLCJ2MiIsImhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHMiLCJoYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzIiwic2V0VGFyZ2V0VHlwZSIsIm1hcFRvSWRzIiwiZGF0YUtleSIsImV4aXN0VmFsdWUiLCJpc0dyb3VwZWQiLCJ4VmFsdWVzIiwiZ2V0SW5kZXhCeVgiLCJiYXNlZFgiLCJmaWx0ZXJCeVgiLCJnZXRYVmFsdWUiLCJpZHNGb3JYIiwiZ2V0T3RoZXJUYXJnZXRYIiwiYWRkWHMiLCJpc011bHRpcGxlWCIsImhhc1R5cGUiLCJhZGROYW1lIiwiZ2V0QWxsVmFsdWVzT25JbmRleCIsImdldFZhbHVlT25JbmRleCIsInZhbHVlT25JbmRleCIsInVwZGF0ZVRhcmdldFgiLCJ1cGRhdGVUYXJnZXRYcyIsInVwZGF0ZVhzIiwiZ2V0UHJldlgiLCJnZXROZXh0WCIsImdldEJhc2VWYWx1ZSIsImlzQXhpcyIsImlzQXJlYVJhbmdlVHlwZSIsImdldEFyZWFSYW5nZURhdGEiLCJpc0J1YmJsZVpUeXBlIiwiZ2V0QnViYmxlWkRhdGEiLCJnZXRNaW5NYXhWYWx1ZSIsImdldE1pbk1heERhdGEiLCJjYWNoZUtleSIsIm1pbk1heERhdGEiLCJtaW5NYXgiLCJtaW5EYXRhIiwiZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSIsIm1heERhdGEiLCJnZXRUb3RhbFBlckluZGV4Iiwic3VtIiwiZ2V0VG90YWxEYXRhU3VtIiwidG90YWxEYXRhU3VtIiwidG90YWwiLCJnZXRNYXhEYXRhQ291bnQiLCJnZXRNYXhEYXRhQ291bnRUYXJnZXQiLCJtYXBUb1RhcmdldElkcyIsImhhc1RhcmdldCIsInZhbCIsImlzVGFyZ2V0VG9TaG93IiwidGFyZ2V0SWQiLCJpc0xlZ2VuZFRvU2hvdyIsImFkZEhpZGRlblRhcmdldElkcyIsInRhcmdldElkcyIsInJlbW92ZUhpZGRlblRhcmdldElkcyIsImFkZEhpZGRlbkxlZ2VuZElkcyIsInJlbW92ZUhpZGRlbkxlZ2VuZElkcyIsImdldFZhbHVlc0FzSWRLZXllZCIsInlzIiwiY2hlY2tWYWx1ZUluVGFyZ2V0cyIsImNoZWNrZXIiLCJoYXNNdWx0aVRhcmdldHMiLCJfY2hlY2tPcmRlciIsIm9yZGVyIiwidG9Mb3dlckNhc2UiLCJpc09yZGVyRGVzYyIsImlzT3JkZXJBc2MiLCJvcmRlclRhcmdldHMiLCJ0YXJnZXRzVmFsdWUiLCJvcmRlckFzYyIsIm9yZGVyRGVzYyIsInQxIiwidDIiLCJyZWR1Y2VyIiwiYWJzIiwidDFTdW0iLCJ0MlN1bSIsImZpbHRlclJlbW92ZU51bGwiLCJmaWx0ZXJCeVhEb21haW4iLCJ4RG9tYWluIiwiaGFzRGF0YUxhYmVsIiwiZGF0YUxhYmVscyIsImdldERhdGFMYWJlbExlbmd0aCIsImxlbmd0aHMiLCJkYXRhTGFiZWxGb3JtYXQiLCJpc05vbmVBcmMiLCJpc0FyYyIsImZpbmRTYW1lWE9mVmFsdWVzIiwidGFyZ2V0WCIsInNhbWVzIiwiZmluZENsb3Nlc3RGcm9tVGFyZ2V0cyIsImNhbmRpZGF0ZXMiLCJmaW5kQ2xvc2VzdCIsImNsb3Nlc3QiLCJtaW5EaXN0IiwiaXNCYXJUeXBlIiwiZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgiLCJpc1dpdGhpbkJhciIsImRpc3QiLCJ4SW5kZXgiLCJ5SW5kZXgiLCJjaXJjbGVZIiwic3FydCIsInBvdyIsImNvbnZlcnRWYWx1ZXNUb1N0ZXAiLCJzdGVwVHlwZSIsImNvbnZlcnRlZCIsImNvbnZlcnRWYWx1ZXNUb1JhbmdlIiwicmFuZ2VzIiwidXBkYXRlRGF0YUF0dHJpYnV0ZXMiLCJhdHRycyIsImN1cnJlbnQiLCJ3aXRoTGVnZW5kIiwiZ2V0UmF0aW8iLCJhc1BlcmNlbnQiLCJyYXRpbyIsInNob3duIiwiZGF0YVZhbHVlcyIsInBhZEFuZ2xlIiwiZW5kQW5nbGUiLCJzdGFydEFuZ2xlIiwiaGlkZGVuU3VtIiwiYWNjIiwiY3VyciIsInBhcnNlRmxvYXQiLCJtYXhWYWx1ZSIsInVwZGF0ZURhdGFJbmRleEJ5WCIsInRpY2tWYWx1ZU1hcCIsIm91dCIsInZhbHVlSW5kZXgiLCJsb2FkIiwicmF3VGFyZ2V0cyIsInR5cGVzIiwic3BsaWNlIiwidXBkYXRlVGFyZ2V0cyIsIndpdGhVcGRhdGVPcmdYRG9tYWluIiwid2l0aFVwZGF0ZVhEb21haW4iLCJsb2FkRnJvbUFyZ3MiLCJ1bmxvYWQiLCJyYXdUYXJnZXRJZHMiLCJjdXN0b21Eb25lQ2IiLCJzZWxlY3RvclRhcmdldCIsImVuZGFsbCIsInNldE92ZXJPdXQiLCJpc092ZXIiLCJzZXRPdmVyQ29sb3IiLCJjYWxsZWUiLCJsYXN0IiwiaXNXaXRoaW5TaGFwZSIsImRhdHVtIiwiZXhwYW5kQ2lyY2xlc0JhcnMiLCJjYWxsT3Zlck91dEZvclRvdWNoIiwiZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uIiwiZHJhZyIsImQzRHJhZyIsIm9uIiwiZDNNb3VzZSIsImRyYWdzdGFydCIsImRyYWdlbmQiLCJzZWxlY3RvciIsImdlbmVyYXRlQ2xhc3MiLCJjbGFzc1RleHQiLCJjbGFzc1RleHRzIiwiY2xhc3NTaGFwZSIsImNsYXNzU2hhcGVzIiwiZ2VuZXJhdGVFeHRyYUxpbmVDbGFzcyIsImNsYXNzZXMiLCJjbGFzc0xpbmUiLCJjbGFzc0xpbmVzIiwiY2xhc3NDaXJjbGUiLCJjbGFzc0NpcmNsZXMiLCJjbGFzc0JhciIsImNsYXNzQmFycyIsImNsYXNzQXJjIiwiY2xhc3NBcmNzIiwiY2xhc3NBcmVhIiwiY2xhc3NBcmVhcyIsImNsYXNzUmVnaW9uIiwiY2xhc3MiLCJjbGFzc0V2ZW50IiwiY2xhc3NUYXJnZXQiLCJhZGRpdGlvbmFsQ2xhc3NTdWZmaXgiLCJhZGRpdGlvbmFsQ2xhc3MiLCJjbGFzc0ZvY3VzIiwiY2xhc3NGb2N1c2VkIiwiY2xhc3NEZWZvY3VzZWQiLCJjbGFzc0NoYXJ0VGV4dCIsImNsYXNzQ2hhcnRMaW5lIiwiY2xhc3NDaGFydEJhciIsImNsYXNzQ2hhcnRBcmMiLCJjbGFzc0NoYXJ0UmFkYXIiLCJzZWxlY3RvclRhcmdldHMiLCJpZHNWYWx1ZSIsInNlbGVjdG9yTGVnZW5kIiwic2VsZWN0b3JMZWdlbmRzIiwiY29sb3JpemVQYXR0ZXJuIiwicGF0dGVybiIsImNsb25lTm9kZSIsInNjaGVtZUNhdGVnb3J5MTAiLCJnZXRDb2xvckZyb21Dc3MiLCJib2R5Iiwic3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiYmFja2dyb3VuZEltYWdlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidHJpbSIsIkJvb2xlYW4iLCJnZW5lcmF0ZUNvbG9yIiwiY29sb3JzIiwiZDNTY2FsZU9yZGluYWwiLCJvcmlnaW5hbENvbG9yUGF0dGVybiIsInRpbGVzIiwiY29sb3JpemVkUGF0dGVybnMiLCJwYXR0ZXJucyIsImlzTGluZSIsImlzVHlwZU9mIiwiZ2VuZXJhdGVMZXZlbENvbG9yIiwidGhyZXNob2xkIiwiYXNWYWx1ZSIsInVuaXQiLCJsIiwiZ2V0WURvbWFpbk1pbk1heCIsImlzTWluIiwiZGF0YUdyb3VwcyIsImlkc0luR3JvdXAiLCJiYXNlSWQiLCJiYXNlQXhpc0lkIiwibWVldENvbmRpdGlvbiIsImdldFlEb21haW5NaW4iLCJnZXRZRG9tYWluTWF4IiwidGFyZ2V0c0J5QXhpc0lkIiwieVRhcmdldHMiLCJ5TWluIiwieU1heCIsInlEb21haW5NaW4iLCJ5RG9tYWluTWF4IiwiY2VudGVyIiwiaXNaZXJvQmFzZWQiLCJpc0ludmVydGVkIiwic2hvd0hvcml6b250YWxEYXRhTGFiZWwiLCJzaG93VmVydGljYWxEYXRhTGFiZWwiLCJpc0FsbFBvc2l0aXZlIiwiaXNBbGxOZWdhdGl2ZSIsInlEb21haW5BYnMiLCJnZXRYRG9tYWluTWluTWF4IiwiZ2V0WERvbWFpbk1pbiIsImdldFhEb21haW5NYXgiLCJnZXRYRG9tYWluUGFkZGluZyIsIm1heERhdGFDb3VudCIsInhQYWRkaW5nIiwiZ2V0WERvbWFpbiIsImZpcnN0WCIsImxhc3RYIiwiZ2V0VGltZSIsIndpdGhUcmltIiwib3JnIiwiem9vbUVuYWJsZWQiLCJ1cGRhdGVTY2FsZUV4dGVudCIsImRvbWFpblZhbHVlIiwiaW52ZXJ0IiwidHJpbVhEb21haW4iLCJ6b29tRG9tYWluIiwiZ2V0Wm9vbURvbWFpbiIsImdldEZvcm1hdCIsInR5cGVWYWx1ZSIsImRlZmF1bHRWYWx1ZUZvcm1hdCIsImdldFlGb3JtYXQiLCJmb3JBcmMiLCJ5Rm9ybWF0IiwieTJGb3JtYXQiLCJkZWZhdWx0QXJjVmFsdWVGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0IiwiaW5pdExlZ2VuZCIsInVwZGF0ZUxlZ2VuZCIsIm9wdGlvbnoiLCJ3aXRoVHJhbnNmb3JtIiwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0iLCJ1cGRhdGVMZWdlbmRUZW1wbGF0ZSIsInVwZGF0ZUxlZ2VuZEVsZW1lbnQiLCJjbGFzc2VkIiwidXBkYXRlU2NhbGVzIiwidXBkYXRlU3ZnU2l6ZSIsInRyYW5zZm9ybUFsbCIsIndyYXBwZXIiLCJ0ZW1wbGF0ZSIsIkNPTE9SIiwiVElUTEUiLCJjaGlsZE5vZGVzIiwic2V0TGVnZW5kSXRlbSIsInVwZGF0ZVNpemVGb3JMZWdlbmQiLCJpbnNldExlZ2VuZFBvc2l0aW9uIiwiZ2V0Q3VycmVudFBhZGRpbmdUb3AiLCJnZXRDdXJyZW50UGFkZGluZ0JvdHRvbSIsImdldEN1cnJlbnRQYWRkaW5nTGVmdCIsImdldEN1cnJlbnRQYWRkaW5nUmlnaHQiLCJOYU4iLCJ0cmFuc2Zvcm1MZWdlbmQiLCJ1cGRhdGVMZWdlbmRTdGVwIiwic3RlcCIsInVwZGF0ZUxlZ2VuZEl0ZW1XaWR0aCIsInVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQiLCJ1cGRhdGVMZWdlbmRJdGVtQ29sb3IiLCJnZXRMZWdlbmRXaWR0aCIsImdldExlZ2VuZEhlaWdodCIsIm9wYWNpdHlGb3JMZWdlbmQiLCJvcGFjaXR5Rm9yVW5mb2N1c2VkTGVnZW5kIiwidG9nZ2xlRm9jdXNMZWdlbmQiLCJmb2N1cyIsInRhcmdldElkeiIsInJldmVydExlZ2VuZCIsInNob3dMZWdlbmQiLCJoaWRlTGVnZW5kIiwiZ2V0TGVnZW5kSXRlbVRleHRCb3giLCJ0ZXh0RWxlbWVudCIsImdldFRleHRSZWN0IiwiaXRlbSIsImlzVG91Y2giLCJoYXNHYXVnZSIsIml0ZW1DbGFzcyIsImFsdEtleSIsImhpZGUiLCJzaG93IiwidG9nZ2xlIiwicmV2ZXJ0IiwiaGlkZVRvb2x0aXAiLCJ1bmRvTWFya092ZXJsYXBwZWQiLCJtYXJrT3ZlcmxhcHBlZCIsInhGb3JMZWdlbmQiLCJ5Rm9yTGVnZW5kIiwicG9zTWluIiwidGlsZVdpZHRoIiwibWF4SGVpZ2h0IiwidG90YWxMZW5ndGgiLCJvZmZzZXRzIiwid2lkdGhzIiwiaGVpZ2h0cyIsIm1hcmdpbnMiLCJzdGVwcyIsImlzTGVnZW5kUmlnaHRPckluc2V0IiwidXBkYXRlUG9zaXRpb25zIiwiaXNMYXN0IiwiYm94IiwiaXRlbVdpZHRoIiwiaXRlbUhlaWdodCIsIml0ZW1MZW5ndGgiLCJhcmVhTGVuZ3RoIiwidXBkYXRlVmFsdWVzIiwiaWQyIiwid2l0aG91dFN0ZXAiLCJtYXhMZW5ndGgiLCJ4Rm9yTGVnZW5kVGV4dCIsInhGb3JMZWdlbmRSZWN0IiwieDFGb3JMZWdlbmRUaWxlIiwieDJGb3JMZWdlbmRUaWxlIiwieUZvckxlZ2VuZFRleHQiLCJ5Rm9yTGVnZW5kUmVjdCIsInlGb3JMZWdlbmRUaWxlIiwidXNlUG9pbnQiLCJjcmVhdGVFbGVtZW50TlMiLCJkM05hbWVzcGFjZXMiLCJoYXNWYWxpZFBvaW50VHlwZSIsImlkeCIsIm5vZGVOYW1lIiwicmVjdHMiLCJwb2ludFIiLCJ4T2Zmc2V0IiwieU9mZnNldCIsImxldmVsQ29sb3IiLCJnZXRTY2FsZSIsImZvclRpbWVzZXJpZXMiLCJkM1NjYWxlVGltZSIsImdldFgiLCJvZmZzZXQiLCJnZXRDdXN0b21pemVkU2NhbGUiLCJnZXRZIiwic2NhbGVWYWx1ZSIsIm9mZnNldFZhbHVlIiwicmF3Iiwib3JnU2NhbGUiLCJnZXRZU2NhbGUiLCJnZXRTdWJZU2NhbGUiLCJ4U3ViRG9tYWluIiwidXBkYXRlQXJjIiwic2V0Q29udGFpbmVyU2l6ZSIsImdldEN1cnJlbnRXaWR0aCIsImdldEN1cnJlbnRIZWlnaHQiLCJnZXRQYXJlbnRXaWR0aCIsImdldFBhcmVudEhlaWdodCIsImdldEF4aXNTaXplIiwiZ2V0QXhpc1dpZHRoQnlBeGlzSWQiLCJnZXRIb3Jpem9udGFsQXhpc0hlaWdodCIsImF4ZXNMZW4iLCJnZXRUaXRsZVBhZGRpbmciLCJheGlzV2lkdGgiLCJsZWdlbmRXaWR0aE9uUmlnaHQiLCJnZXRQYXJlbnRSZWN0VmFsdWUiLCJvZmZzZXROYW1lIiwicGFyZW50IiwidGFnTmFtZSIsImJvZHlXaWR0aCIsIm9mZnNldFdpZHRoIiwicGFyc2VJbnQiLCJnZXRTdmdMZWZ0IiwiaGFzTGVmdEF4aXNSZWN0IiwibGVmdEF4aXNDbGFzcyIsImxlZnRBeGlzIiwic3ZnUmVjdCIsImNoYXJ0UmVjdCIsImhhc0FyYyIsInN2Z0xlZnQiLCJjb3MiLCJnZXRFdmVudFJlY3RXaWR0aCIsImluaXRUZXh0IiwidXBkYXRlVGFyZ2V0c0ZvclRleHQiLCJtYWluVGV4dFVwZGF0ZSIsIm1haW5UZXh0RW50ZXIiLCJ1cGRhdGVUZXh0IiwiZHVyYXRpb25Gb3JFeGl0IiwiZGF0YUZuIiwibGFiZWxpc2hEYXRhIiwiaXNSYWRhclR5cGUiLCJ1cGRhdGVUZXh0Q29sb3IiLCJsYWJlbENvbG9ycyIsInJlZHJhd1RleHQiLCJmb3JGbG93Iiwib3BhY2l0eUZvclRleHQiLCJlbGVtZW50IiwiYmFzZSIsInF1ZXJ5U2VsZWN0b3IiLCJ0ZXh0Q29udGVudCIsImdlbmVyYXRlWFlGb3JUZXh0IiwiaW5kaWNlcyIsImZvclgiLCJwb2ludHMiLCJnZXR0ZXIiLCJnZXRYRm9yVGV4dCIsImdldFlGb3JUZXh0IiwiaXNBcmVhVHlwZSIsImdldENlbnRlcmVkVGV4dFBvcyIsImNlbnRlcmVkIiwiaXNQb3NpdGl2ZSIsImdldFRleHRQb3MiLCJ4UG9zIiwieVBvcyIsImJhc2VZIiwiaXNMaW5lVHlwZSIsImlzU2NhdHRlclR5cGUiLCJpc0J1YmJsZVR5cGUiLCJib3hIZWlnaHQiLCJ0ZXh0Tm9kZXMiLCJmaWx0ZXJlZFRleHROb2RlcyIsInRleHROb2RlIiwidHJhbnNsYXRlIiwiY2FsY0h5cG8iLCJjb29yZGluYXRlIiwiZmlsdGVyZWRUZXh0Tm9kZSIsIm5vZGVGb3JXaWR0aCIsIm92ZXJsYXBzWCIsImdldENvbXB1dGVkVGV4dExlbmd0aCIsIm92ZXJsYXBzWSIsImQzU2VsZWN0QWxsIiwicHJldmlvdXNTaWJsaW5nIiwiaXNOdW0iLCJpbml0VGl0bGUiLCJyZWRyYXdUaXRsZSIsInlGb3JUaXRsZSIsInhGb3JUaXRsZSIsInRleHRSZWN0V2lkdGgiLCJpbml0VG9vbHRpcCIsImdldFRvb2x0aXBIVE1MIiwiZ2V0VG9vbHRpcENvbnRlbnQiLCJkZWZhdWx0VGl0bGVGb3JtYXQiLCJ0aXRsZUZvcm1hdCIsIm5hbWVGb3JtYXQiLCJ2YWx1ZUZvcm1hdCIsImdldFJvd1ZhbHVlIiwiZ2V0QmdDb2xvciIsImNvbnRlbnRzIiwidHBsU3RyIiwiaTIiLCJwYXJhbSIsImdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUiLCJDTEFTU19UT09MVElQIiwiaGlnaCIsImxvdyIsImNvbnRlbnRWYWx1ZSIsIkNMQVNTX1RPT0xUSVBfTkFNRSIsIk5BTUUiLCJWQUxVRSIsInRvb2x0aXBQb3NpdGlvbiIsImRhdGFUb1Nob3ciLCJ0V2lkdGgiLCJ0SGVpZ2h0IiwiY2hhcnRSaWdodCIsImRhdGFTY2FsZSIsInNob3dUb29sdGlwIiwic2VsZWN0ZWREYXRhIiwicG9zaXRpb25GdW5jdGlvbiIsImRhdGFTdHIiLCJzdHJpbmdpZnkiLCJwcm9wZXJ0eSIsIl9oYW5kbGVMaW5rZWRDaGFydHMiLCJjaGFydHMiLCJsaW5rZWROYW1lIiwiaW50ZXJuYWwiLCJpc0xpbmtlZCIsImlzSW5Eb20iLCJjb250YWlucyIsImlzTm90U2FtZUluZGV4IiwiVFlQRVMiLCJBcmVhIiwiQXJlYVJhbmdlIiwiQXJjIiwiTGluZSIsIlN0ZXAiLCJTcGxpbmUiLCJoYXNUeXBlT2YiLCJleGNsdWRlIiwiZGF0YVR5cGUiLCJoYXNNdWx0aUFyY0dhdWdlIiwiaXNTdGVwVHlwZSIsImlzU3BsaW5lVHlwZSIsImlzUGllVHlwZSIsImlzR2F1Z2VUeXBlIiwiaXNEb251dFR5cGUiLCJpc0FyY1R5cGUiLCJpc0NpcmNsZVBvaW50IiwibGluZURhdGEiLCJhcmNEYXRhIiwiYmFyRGF0YSIsImJhckxpbmVCdWJibGVEYXRhIiwiaXNJbnRlcnBvbGF0aW9uVHlwZSIsInNldE1pbk1heCIsImNhdGVnb3J5IiwidG8iLCJ0YWlsIiwiaXNUYWJWaXNpYmxlIiwibm90Zm91bmRJZHMiLCJvcmdEYXRhQ291bnQiLCJtaXNzaW5nIiwiYmFzZVRhcmdldCIsImJhc2VWYWx1ZSIsIndpdGhUcmltWERvbWFpbiIsIndpdGhVcGRhdGVYQXhpcyIsImdyaWRzIiwicmVkcmF3V2l0aG91dFJlc2NhbGUiLCJyZW1vdmVHcmlkTGluZXMiLCJodHRwIiwiZ3JvdXBzIiwib3B0aW9uc1ZhbHVlIiwic2VsZWN0ZWQiLCJkYXRhUG9pbnQiLCJyZXNldE90aGVyIiwiZ2V0VG9nZ2xlIiwiaXNUYXJnZXRJZCIsImlzVGFyZ2V0SW5kZXgiLCJpc1NlbGVjdGVkIiwidW5zZWxlY3QiLCJ3aXRoaW5SYW5nZSIsInJlc3VsdERvbWFpbiIsInhTY2FsZSIsImdldFNlbGVjdGlvbiIsIm1vdmUiLCJ3aXRoWSIsIndpdGhEaW1lbnNpb24iLCJzZXRab29tUmVzZXRCdXR0b24iLCJlbmFibGUiLCJlbmFibGVkIiwiZW5hYmxlVHlwZSIsImJpbmRab29tRXZlbnQiLCJpbml0Wm9vbSIsInVwZGF0ZUFuZFJlZHJhdyIsInVuem9vbSIsInVwZGF0ZVRyYW5zZm9ybVNjYWxlIiwiZDNab29tSWRlbnRpdHkiLCJ1cGRhdGVab29tIiwicmVzZXRCdG4iLCJkM1pvb21UcmFuc2Zvcm0iLCJhbHREb21haW4iLCJzeCIsInN5IiwibXgiLCJteSIsIm1pblgiLCJtYXhYIiwibWluWSIsIm1heFkiLCJpc0luY2x1ZGVkIiwiaXNXaXRoaW4iLCJ0b2dnbGVQb2ludCIsInRvZ2dsZVBhdGgiLCJzZXREcmFnU3RhdHVzIiwiaXNEcmFnZ2luZyIsImdlbmVyYXRlRmxvdyIsInRyYW5zbGF0ZVgiLCJkcmF3QmFyIiwiZHJhd0xpbmUiLCJkcmF3QXJlYSIsImN4IiwiY3kiLCJ4Rm9yVGV4dCIsInh2Iiwic2NhbGVYIiwiZmxvd0luZGV4IiwiZmxvd0xlbmd0aCIsImZsb3dTdGFydCIsImZsb3dFbmQiLCJkdXJhdGlvbkZvckZsb3ciLCJ3YWl0IiwiZ2VuZXJhdGVXYWl0IiwibWFpblJlZ2lvbiIsImxpc3QiLCJtYWluVGV4dCIsIm1haW5CYXIiLCJtYWluTGluZSIsIm1haW5BcmVhIiwibWFpbkNpcmNsZSIsInVwZGF0ZVhHcmlkIiwiaGlkZUdyaWRGb2N1cyIsImd0IiwiZDNUcmFuc2l0aW9uIiwiZWFzZSIsImQzRWFzZUxpbmVhciIsImlzUmVnaW9uT25YIiwieEZ1bmMiLCJ5RnVuYyIsInJlZ2lvblgiLCJyZWdpb25XaWR0aCIsInJlZHJhd0V2ZW50UmVjdCIsImluaXRFdmVudFJlY3QiLCJldmVudFJlY3RVcGRhdGUiLCJnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzIiwieEF4aXNUaWNrVmFsdWVzIiwidXBkYXRlUG9pbnRDbGFzcyIsImdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgiLCJ1cGRhdGVFdmVudFJlY3QiLCJiaW5kVG91Y2hPbkV2ZW50UmVjdCIsInN0YXJ0UHgiLCJnZXRFdmVudFJlY3QiLCJlbGVtZW50RnJvbVBvaW50IiwiZ2V0SW5kZXgiLCJzZWxlY3RSZWN0Iiwic2VsZWN0UmVjdEZvck11bHRpcGxlWHMiLCJ1bnNlbGVjdFJlY3QiLCJzZWxlY3RSZWN0Rm9yU2luZ2xlIiwicHJldmVudERlZmF1bHQiLCJpc1ByZXZlbnRlZCIsInByZXZlbnRUaHJlc2hvbGQiLCJwcmV2ZW50RXZlbnQiLCJjdXJyZW50WFkiLCJ0b2dnbGVTaGFwZSIsImV2ZW50UmVjdERhdGEiLCJyZWN0VyIsInJlY3RYIiwiZ2V0UHJldk5leHRYIiwicHJldiIsIm5leHQiLCJ0aGlzWCIsImlzU2VsZWN0aW9uRW5hYmxlZCIsImlzU2VsZWN0aW9uR3JvdXBlZCIsImlzVG9vbHRpcEdyb3VwZWQiLCJzaG93R3JpZEZvY3VzIiwidW5leHBhbmRDaXJjbGVzIiwiZXhwYW5kQ2lyY2xlcyIsImV4cGFuZEJhcnMiLCJzYW1lWERhdGEiLCJ1bmV4cGFuZEJhcnMiLCJldmVudFJlY3RFbnRlciIsImNsaWNrSGFuZGxlckZvclNpbmdsZVgiLCJkMiIsImNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMiLCJpbml0QnJ1c2giLCJkM0JydXNoWSIsImQzQnJ1c2hYIiwibGFzdERvbWFpbiIsInRpbWVvdXQiLCJicnVzaEhhbmRsZXIiLCJyZWRyYXdGb3JCcnVzaCIsImdldEJydXNoU2l6ZSIsImJydXNoU2l6ZSIsInVwZGF0ZVJlc2l6ZSIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJ1cGRhdGUiLCJleHRlbnQiLCJnZXRFeHRlbnQiLCJpbml0U3ViY2hhcnQiLCJkZWZzIiwidmlzaWJpbGl0eSIsImNsaXBJZCIsImdldENsaXBQYXRoIiwiYXBwZW5kQ2xpcCIsInVwZGF0ZVRhcmdldHNGb3JTdWJjaGFydCIsImJhclVwZGF0ZSIsImJhckVudGVyIiwibGluZUVudGVyIiwidXBkYXRlQmFyRm9yU3ViY2hhcnQiLCJpbml0aWFsT3BhY2l0eSIsInJlZHJhd0JhckZvclN1YmNoYXJ0IiwiZHJhd0Jhck9uU3ViIiwidXBkYXRlTGluZUZvclN1YmNoYXJ0IiwicmVkcmF3TGluZUZvclN1YmNoYXJ0IiwiZHJhd0xpbmVPblN1YiIsInVwZGF0ZUFyZWFGb3JTdWJjaGFydCIsInJlZHJhd0FyZWFGb3JTdWJjaGFydCIsImRyYXdBcmVhT25TdWIiLCJyZWRyYXdTdWJjaGFydCIsIndpdGhTdWJjaGFydCIsImRyYXciLCJ0cmFuc2Zvcm1Db250ZXh0Iiwic3ViWEF4aXMiLCJnZW5lcmF0ZVpvb20iLCJpbml0Wm9vbUJlaGF2aW91ciIsImJpbmRab29tT25FdmVudFJlY3QiLCJkM1pvb20iLCJvblpvb21TdGFydCIsIm9uWm9vbSIsIm9uWm9vbUVuZCIsIm9yZ1NjYWxlRXh0ZW50IiwicmVzY2FsZSIsInNvdXJjZUV2ZW50Iiwic3RhcnRFdmVudCIsImlzTW91c2Vtb3ZlIiwiaXNab29tT3V0Iiwid2hlZWxEZWx0YSIsIndpdGhFdmVudFJlY3QiLCJkZWx0YSIsImlzZnVsbHlTaG93biIsImJlaGF2aW91ciIsInpvb21CZWhhdmlvdXIiLCJwcm9wIiwiY2xpY2tEaXN0YW5jZSIsInJlc2V0QnV0dG9uIiwib25jbGljayIsImluaXRDbGlwIiwiaXNJRTkiLCJuYXZpZ2F0b3IiLCJhcHBWZXJzaW9uIiwiVVJMIiwiZ2V0QXhpc0NsaXBYIiwiZ2V0QXhpc0NsaXBZIiwiZ2V0WEF4aXNDbGlwWCIsImdldFhBeGlzQ2xpcFkiLCJnZXRZQXhpc0NsaXBYIiwiZ2V0WUF4aXNDbGlwWSIsImdldEF4aXNDbGlwV2lkdGgiLCJnZXRBeGlzQ2xpcEhlaWdodCIsImdldFhBeGlzQ2xpcFdpZHRoIiwiZ2V0WEF4aXNDbGlwSGVpZ2h0IiwiZ2V0WUF4aXNDbGlwV2lkdGgiLCJnZXRZQXhpc0NsaXBIZWlnaHQiLCJnZXRHcmlkVGV4dEFuY2hvciIsImdldEdyaWRUZXh0RHgiLCJnZXRHcmlkVGV4dFgiLCJpbml0R3JpZCIsImluaXRHcmlkTGluZXMiLCJpbml0Rm9jdXNHcmlkIiwid2l0aG91dFVwZGF0ZSIsInhncmlkRGF0YSIsImdlbmVyYXRlR3JpZERhdGEiLCJ1cGRhdGVZR3JpZCIsImdyaWRWYWx1ZXMiLCJzbW9vdGhMaW5lcyIsInVwZGF0ZUdyaWQiLCJ1cGRhdGVYR3JpZExpbmVzIiwidXBkYXRlWUdyaWRMaW5lcyIsInhMaW5lcyIsInl2IiwicmVkcmF3R3JpZCIsImlzRnJvbnQiLCJmb2N1c0VsIiwiaXNFZGdlIiwieHgiLCJ4eSIsImlzWTIiLCJ1cGRhdGVncmlkRm9jdXMiLCJ0aWNrTnVtIiwiZ3JpZERhdGEiLCJmaXJzdFllYXIiLCJnZXRGdWxsWWVhciIsImxhc3RZZWFyIiwiZ2V0R3JpZEZpbHRlclRvUmVtb3ZlIiwidG9SZW1vdmUiLCJpbml0UmVnaW9uIiwidXBkYXRlUmVnaW9uIiwicmVkcmF3UmVnaW9uIiwicmVnaW9uWSIsInJlZ2lvbkhlaWdodCIsImdldFJlZ2lvblhZIiwiY3VyclNjYWxlIiwiZ2V0UmVnaW9uU2l6ZSIsImlzV2lkdGgiLCJzZWxlY3RQb2ludCIsImNpcmNsZVgiLCJwb2ludFNlbGVjdFIiLCJ1bnNlbGVjdFBvaW50IiwibWV0aG9kIiwic2VsZWN0UGF0aCIsImQzUmdiIiwiYnJpZ2h0ZXIiLCJ1bnNlbGVjdFBhdGgiLCJ0aGF0IiwidG9nZ2xlZFNoYXBlIiwiaW5pdEJhciIsInVwZGF0ZVRhcmdldHNGb3JCYXIiLCJtYWluQmFyVXBkYXRlIiwibWFpbkJhckVudGVyIiwidXBkYXRlQmFyIiwicmVkcmF3QmFyIiwiZ2V0QmFyVyIsImJhclRhcmdldHNOdW0iLCJyZXN1bHQiLCJnZXRXaWR0aCIsImdldEJhcnMiLCJzdWZmaXgiLCJnZW5lcmF0ZURyYXdCYXIiLCJiYXJJbmRpY2VzIiwiaXNTdWIiLCJnZXRQb2ludHMiLCJnZW5lcmF0ZUdldEJhclBvaW50cyIsImJhclJhZGl1cyIsImJhclJhZGl1c1JhdGlvIiwiYmFyX3JhZGl1c19yYXRpbyIsImdldFJhZGl1cyIsImluZGV4WCIsImluZGV4WSIsImlzTmVnYXRpdmUiLCJwYXRoUmFkaXVzIiwiYmFyVyIsImdldEluZGljZXNNYXgiLCJiYXJYIiwiZ2V0U2hhcGVYIiwiYmFyWSIsImdldFNoYXBlWSIsImJhck9mZnNldCIsImdldFNoYXBlT2Zmc2V0IiwieVNjYWxlIiwieTAiLCJwb3NYIiwicG9zWSIsInNlZzAiLCJzZWcxIiwiaW5pdEJ1YmJsZSIsImdldEJhc2VMZW5ndGgiLCJiYXNlTGVuZ3RoIiwiZ2V0QnViYmxlUiIsIm1heFIiLCJtaWQiLCJtYXhBcmVhIiwiaW5pdExpbmUiLCJ1cGRhdGVUYXJnZXRzRm9yTGluZSIsIm1haW5MaW5lVXBkYXRlIiwibWFpbkxpbmVFbnRlciIsInVwZGF0ZUxpbmUiLCJleHRyYUxpbmVDbGFzc2VzIiwicmVkcmF3TGluZSIsImdldEN1cnZlIiwiaXNSb3RhdGVkU3RlcFR5cGUiLCJnZXRJbnRlcnBvbGF0ZSIsIm9yZ1BvaW50IiwicG9pbnRSb3RhdGVkIiwiX3BvaW50IiwiX3kiLCJfdCIsIl9jb250ZXh0IiwibGluZVRvIiwiX3giLCJnZW5lcmF0ZURyYXdMaW5lIiwibGluZUluZGljZXMiLCJsaW5lQ29ubmVjdE51bGwiLCJnZW5lcmF0ZUdldExpbmVQb2ludHMiLCJ5U2NhbGVHZXR0ZXIiLCJ4VmFsdWUiLCJzdWJ4eCIsInlWYWx1ZSIsImQzTGluZSIsImRlZmluZWQiLCJ4MCIsImxpbmVXaXRoUmVnaW9ucyIsImN1cnZlIiwiaXNTdWJWYWx1ZSIsImxpbmVPZmZzZXQiLCJfcmVnaW9ucyIsInhwIiwieXAiLCJkaWZmeDIiLCJkYXNoYXJyYXkiLCJpc1dpdGhpblJlZ2lvbnMiLCJ3aXRoaW5YIiwid2l0aGluUmVnaW9ucyIsInJlZyIsImdldFZhbHVlIiwiZHQiLCJnZW5lcmF0ZU0iLCJzV2l0aFJlZ2lvbiIsImQwIiwiZDEiLCJ0aW1lc2VyaWVzRGlmZiIsInhEaWZmIiwieHYwIiwieHYxIiwib3RoZXJEaWZmIiwicHJldkRhdGEiLCJoYXNQcmV2RGF0YSIsImRkIiwidXBkYXRlQXJlYUdyYWRpZW50Iiwic3RvcHMiLCJsaW5lYXJHcmFkaWVudCIsInN0b3BDb2xvciIsInVwZGF0ZUFyZWFDb2xvciIsInVwZGF0ZUFyZWEiLCJyZWRyYXdBcmVhIiwiZ2VuZXJhdGVEcmF3QXJlYSIsImFyZWFJbmRpY2VzIiwiZ2VuZXJhdGVHZXRBcmVhUG9pbnRzIiwidmFsdWUwIiwidmFsdWUxIiwiZDNBcmVhIiwiYXJlYU9mZnNldCIsImlzV2l0aGluU3RlcCIsInNob3VsZERyYXdQb2ludHNGb3JMaW5lIiwibGluZVBvaW50IiwiaGFzVmFsaWRQb2ludERyYXdNZXRob2RzIiwicG9pbnRUeXBlIiwidXBkYXRlQ2lyY2xlIiwiaW5pdGlhbE9wYWNpdHlGb3JDaXJjbGUiLCJyZWRyYXdDaXJjbGUiLCJtYWluQ2lyY2xlcyIsIm9wYWNpdHlGb3JDaXJjbGUiLCJwb3NBdHRyIiwidXBkYXRlQ2lyY2xlWSIsImdldFNoYXBlSW5kaWNlcyIsImdldENpcmNsZXMiLCJwb2ludEV4cGFuZGVkUiIsInNlbGVjdFIiLCJpc1dpdGhpbkNpcmNsZSIsImluc2VydFBvaW50SW5mb0RlZnMiLCJjb3B5QXR0ciIsImZyb20iLCJhdHRyaWJzIiwiYXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsIkRPTVBhcnNlciIsInBhcnNlRnJvbVN0cmluZyIsImRvY3VtZW50RWxlbWVudCIsImNsb25lIiwiZmlsbCIsInN0cm9rZSIsImlubmVySFRNTCIsInBvaW50RnJvbURlZnMiLCJwb2ludENsYXNzIiwiZ2VuZXJhdGVQb2ludCIsInBvaW50SWQiLCJjdXN0b20iLCJnZXRUcmFuc2l0aW9uTmFtZSIsInNpemVGbiIsImZpbGxTdHlsZUZuIiwieFBvc0ZuIiwieVBvc0ZuIiwib3BhY2l0eVN0eWxlRm4iLCJ4UG9zRm4yIiwidHJhbnNpdGlvbk5hbWUiLCJyZWN0YW5nbGUiLCJyZWN0U2l6ZUZuIiwicmVjdFhQb3NGbiIsInR5cGVGaWx0ZXIiLCJoYXNYcyIsImluZCIsIl9fbWF4X18iLCJnZXRJbmRpY2VzIiwiYmFyUGFkZGluZyIsImhhbGZXaWR0aCIsInRhcmdldHNOdW0iLCJnZXRTaGFwZU9mZnNldERhdGEiLCJzaGFwZU9mZnNldFRhcmdldHMiLCJyb3dWYWx1ZXMiLCJyb3dWYWx1ZU1hcEJ5WFZhbHVlIiwiaW5kZXhNYXBCeVRhcmdldElkIiwiZGF0YVhBc051bWJlciIsInJvd1ZhbHVlIiwiaW50ZXJwb2xhdGlvbiIsImdldEludGVycG9sYXRlVHlwZSIsImQzQ3VydmVCYXNpcyIsImQzQ3VydmVCYXNpc0Nsb3NlZCIsImQzQ3VydmVCYXNpc09wZW4iLCJkM0N1cnZlQnVuZGxlIiwiZDNDdXJ2ZUNhcmRpbmFsIiwiZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkIiwiZDNDdXJ2ZUNhcmRpbmFsT3BlbiIsImQzQ3VydmVDYXRtdWxsUm9tIiwiZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQiLCJkM0N1cnZlQ2F0bXVsbFJvbU9wZW4iLCJkM0N1cnZlTW9ub3RvbmVYIiwiZDNDdXJ2ZU1vbm90b25lWSIsImQzQ3VydmVOYXR1cmFsIiwiZDNDdXJ2ZUxpbmVhckNsb3NlZCIsImQzQ3VydmVMaW5lYXIiLCJkM0N1cnZlU3RlcCIsImQzQ3VydmVTdGVwQWZ0ZXIiLCJkM0N1cnZlU3RlcEJlZm9yZSIsImFwaUF4aXMiLCJhcGlDYXRlZ29yeSIsImFwaUZsb3ciLCJhcGlYR3JpZCIsImFwaVlHcmlkIiwiYXBpR3JvdXAiLCJhcGlSZWdpb24iLCJhcGlTZWxlY3Rpb24iLCJhcGlYIiwiYXBpWm9vbSIsImV2ZW50cmVjdCIsImluaXRQaWUiLCJzdGFydGluZ0FuZ2xlIiwiZDNQaWUiLCJzb3J0VmFsdWVzIiwidXBkYXRlUmFkaXVzIiwiZ2V0SW5uZXJSYWRpdXMiLCJzdmdBcmMiLCJnZXRTdmdBcmMiLCJzdmdBcmNFeHBhbmRlZCIsImdldFN2Z0FyY0V4cGFuZGVkIiwidXBkYXRlQW5nbGUiLCJkVmFsdWUiLCJnU3RhcnQiLCJ0b3RhbFN1bSIsImdFbmQiLCJnTWluIiwiZ01heCIsImdWYWx1ZSIsImlyIiwic2luZ2xlQXJjV2lkdGgiLCJkM0FyYyIsIm91dGVyUmFkaXVzIiwibmV3QXJjIiwidXBkYXRlZCIsImNlbnRyb2lkIiwicmF0ZSIsIm5ld1JhdGUiLCJleHBhbmRXaWR0aCIsImdldEFyYyIsInRyYW5zZm9ybUZvckFyY0xhYmVsIiwiY29udmVydFRvQXJjRGF0YSIsInRleHRGb3JBcmNMYWJlbCIsInNob3VsZFNob3dBcmNMYWJlbCIsImlzVW5kZXJUaHJlc2hvbGQiLCJtZWV0c0FyY0xhYmVsVGhyZXNob2xkIiwiZ2V0QXJjTGFiZWxGb3JtYXQiLCJ0ZXh0Rm9yR2F1Z2VNaW5NYXgiLCJpc01heCIsImdldEdhdWdlTGFiZWxFeHRlbnRzIiwiZXhwYW5kQXJjIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibmV3VGFyZ2V0SWRzIiwic2hvdWxkRXhwYW5kIiwiZXhwYW5kRHVyYXRpb24iLCJnZXRFeHBhbmRDb25maWciLCJzdmdBcmNFeHBhbmRlZFN1YiIsInVuZXhwYW5kQXJjIiwiZ2V0QXJjVGl0bGUiLCJ1cGRhdGVUYXJnZXRzRm9yQXJjIiwibWFpblBpZVVwZGF0ZSIsIm1haW5QaWVFbnRlciIsImluaXRBcmMiLCJzZXRBcmNUaXRsZSIsInJlZHJhd0FyYyIsImhhc0ludGVyYWN0aW9uIiwibWFpbkFyYyIsIl9jdXJyZW50IiwicmVkcmF3TXVsdGlBcmNHYXVnZSIsImF0dHJUd2VlbiIsImludGVycG9sYXRlIiwiZDNJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImJpbmRBcmNFdmVudCIsInJlZHJhd0FyY1RleHQiLCJhcmNMYWJlbExpbmVzIiwibWFpbkFyY0xhYmVsTGluZSIsImxpbmVMZW5ndGgiLCJsaW5lVGhpY2tuZXNzIiwiaW5uZXJMaW5lTGVuZ3RoIiwibGluZUFuZ2xlIiwiYXJjSW5uZXJSYWRpdXMiLCJsaW5lUG9zaXRpb25pbmdBbmdsZSIsInNlbGVjdEFyYyIsIl90aGlzIiwidW5zZWxlY3RBcmMiLCJpc01vdXNlIiwicmFkYXJzIiwiZ2V0RXZlbnRBcmMiLCJldmVudEFyYyIsImhhbmRsZXIiLCJpc0Z1bGxDaXJjbGUiLCJiYWNrZ3JvdW5kQXJjIiwiaW5pdEdhdWdlIiwiYXBwZW5kVGV4dCIsImdldEdhdWdlTGFiZWxIZWlnaHQiLCJnZXRQb3NpdGlvbiIsImlzQ2xvY2t3aXNlIiwiZWRnZSIsImZ1bmMiLCJpbml0UmFkYXIiLCJnZXRSYWRhclNpemUiLCJ1cGRhdGVUYXJnZXRzRm9yUmFkYXIiLCJnZW5lcmF0ZVJhZGFyUG9pbnRzIiwiZ2V0UmFkYXJQb3NpdGlvbiIsIl9zaXplIiwicmVkcmF3UmFkYXIiLCJ1cGRhdGVSYWRhckxldmVsIiwidXBkYXRlUmFkYXJBeGVzIiwidXBkYXRlUmFkYXJTaGFwZSIsImdlbmVyYXRlR2V0UmFkYXJQb2ludHMiLCJkZXB0aCIsInNob3dUZXh0IiwicmFkYXJMZXZlbHMiLCJsZXZlbERhdGEiLCJsZXZlbFJhdGlvIiwibGV2ZWxUZXh0Rm9ybWF0Iiwiam9pbiIsImxldmVsRW50ZXIiLCJheGlzRW50ZXIiLCJmaXJzdENoaWxkIiwiYmluZEV2ZW50Iiwibm9JbmRleCIsImFyZWFzRW50ZXIiLCJyYWRhckNpcmNsZVgiLCJyYWRhckNpcmNsZVkiLCJDaGFydEludGVybmFsIiwiZGF0YVRpbWUiLCJTdG9yZSIsImJlZm9yZUluaXQiLCJjYWxsUGx1Z2luSG9vayIsImFmdGVySW5pdCIsImluaXRQYXJhbXMiLCJjbGFzc25hbWUiLCJpbml0VG9SZW5kZXIiLCJmb3JjZWQiLCJpc0xhenkiLCJsYXp5IiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJtdXRhdGlvbiIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsImF0dHJpYnV0ZUZpbHRlciIsImNvbnZlcnRlZERhdGEiLCJpbml0V2l0aERhdGEiLCJkM1RpbWVQYXJzZSIsImQzVXRjUGFyc2UiLCJkM1RpbWVGb3JtYXQiLCJkM1V0Y0Zvcm1hdCIsImlzRHJhZ1pvb20iLCJpc1pvb21lZCIsInNwZWNpZmllciIsImdldE1pbGxpc2Vjb25kcyIsImdldFNlY29uZHMiLCJnZXRNaW51dGVzIiwiZ2V0SG91cnMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJyb3RhdGVkUGFkZGluZ1JpZ2h0IiwiY29udmVydElucHV0VHlwZSIsInVwZGF0ZVNpemVzIiwiY2xpcFlBeGlzIiwiaW5pdENoYXJ0RWxlbWVudHMiLCJ1cGRhdGVEaW1lbnNpb24iLCJzZXRCYWNrZ3JvdW5kIiwid2l0aFRyYW5zaXRpb25Gb3JBeGlzIiwiaW5pdGlhbGl6aW5nIiwiYmluZFJlc2l6ZSIsInNldENoYXJ0RWxlbWVudHMiLCIkIiwiYmciLCJpbWdVcmwiLCJjdXJyTGVnZW5kIiwibGVnZW5kSGVpZ2h0Rm9yQm90dG9tIiwieEF4aXNIZWlnaHQiLCJzdWJjaGFydFhBeGlzSGVpZ2h0Iiwic3ViY2hhcnRIZWlnaHQiLCJzaG93VGFyZ2V0cyIsImdldFdpdGhPcHRpb24iLCJ3aXRoT3B0aW9ucyIsIlN1YmNoYXJ0IiwiRXZlbnRSZWN0IiwiRGltZW5zaW9uIiwiVHJhbnNmb3JtIiwiTGVnZW5kIiwiVHJhbnNpdGlvbkZvckV4aXQiLCJUcmFuc2l0aW9uRm9yQXhpcyIsImRlZlZhbCIsInRyYW5zaXRpb25zVmFsdWUiLCJkdXJhdGlvbkZvckF4aXMiLCJnZW5lcmF0ZVJlZHJhd0xpc3QiLCJnZXREcmF3U2hhcGUiLCJmbG93Rm4iLCJpc1RyYW5zaXRpb24iLCJyZWRyYXdMaXN0IiwiZ2V0UmVkcmF3TGlzdCIsImFmdGVyUmVkcmF3Iiwid2FpdEZvckRyYXciLCJoYXNSYWRhciIsIndpdGhUcmFuc2l0aW9uRm9yRXhpdCIsInRyYW5zZm9ybU1haW4iLCJ4QXhpcyIsInlBeGlzIiwieTJBeGlzIiwid2l0aG91dEF4aXMiLCJyZXNpemVGdW5jdGlvbiIsImdlbmVyYXRlUmVzaXplIiwicmVzaXplVGltZW91dCIsImZsdXNoIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhbGxSZXNpemVGdW5jdGlvbnMiLCJyZXNpemVGdW5jdGlvbnMiLCJ0cmFuc2l0aW9uc1RvV2FpdCIsImxvb3AiLCJ0aW1lciIsInBhcnNlZERhdGUiLCJoaWRkZW4iLCJpc01vYmlsZSIsInVzZXJBZ2VudCIsImhhc1RvdWNoUG9pbnRzIiwibWF4VG91Y2hQb2ludHMiLCJoYXNUb3VjaCIsIkRvY3VtZW50VG91Y2giLCJoYXNNb3VzZSIsInBoYXNlIiwicHJvdG90eXBlIiwiZGF0YUNvbnZlcnQiLCJkYXRhTG9hZCIsImNsYXNzTW9kdWxlIiwibW9kdWxlQXJjIiwibW9kdWxlQXhpcyIsImxvYWRDb25maWciLCJyZWFkIiwidGhpc0NvbmZpZyIsImZpbmQiLCJyZXNpemUiLCJzb2Z0IiwiX2lzRnJvbVJlc2l6ZSIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZmxhdCIsImRhdGFWYWx1ZSIsIm5hbWVzIiwiYjY0RW5jb2RlVW5pY29kZSIsImJ0b2EiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtYXRjaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm5vZGVUb1N2Z0RhdGFVcmwiLCJzZXJpYWxpemVyIiwiWE1MU2VyaWFsaXplciIsImNzc1RleHQiLCJ4aHRtbCIsIm5vZGVYbWwiLCJzZXJpYWxpemVUb1N0cmluZyIsImNyZWF0ZVRleHROb2RlIiwic3R5bGVYbWwiLCJleHBvcnQiLCJzdmdEYXRhVXJsIiwiaW1nIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9ubG9hZCIsImNhbnZhcyIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJzcmMiLCJ0YXJnZXRJZHNWYWx1ZSIsImRlZm9jdXMiLCJhcmdzVmFsdWUiLCJzaG93SGlkZSIsImV2ZW50TmFtZSIsIkNoYXJ0IiwiYmluZFRoaXMiLCJhcmdUaGlzIiwiaXNGdW5jIiwiaXNDaGlsZCIsImhhc0NoaWxkIiwiYXBpQ2hhcnQiLCJhcGlDb2xvciIsImFwaURhdGEiLCJhcGlFeHBvcnQiLCJhcGlGb2N1cyIsImFwaUxlZ2VuZCIsImFwaUxvYWQiLCJhcGlTaG93IiwiYXBpVG9vbHRpcCIsImRlZmF1bHRzIiwiYmIiLCJ2ZXJzaW9uIiwiZ2VuZXJhdGUiLCJpbnN0Iiwi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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsdUlBQXVJO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLDhYQUE4WDtBQUNqWTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0dBQXdHO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxxRkFBcUY7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLCtJQUErSTtBQUNsSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSxtRkFBbUY7QUFDdEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxRUFBcUU7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsb0NBQW9DO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlGQUF5Rjs7QUFFekY7O0FBRUE7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLHFEQUFxRDtBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLG9GQUFvRjtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxREFBcUQ7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHlHQUF5RztBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFxRCxtQkFBbUIsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsa0lBQWtJO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsd0RBQXdEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsaUNBQWlDO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEMsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUseUJBQXlCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGlDQUFpQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsa0dBQWtHO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsQ0FBQyxFQUFFLCtGQUErRjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQSxDQUFDLEVBQUUsMEVBQTBFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsQ0FBQyxFQUFFLHVHQUF1RztBQUMxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSw2SEFBNkg7QUFDaEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMsRUFBRSxXQUFXO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLGNBQWM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM3RCQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtQkFBbUIsS0FBMEI7QUFDN0M7QUFDQSxrQkFBa0IsS0FBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFB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RUFBZXRwRCxNQUFmLENBRFI7QUFBQSxRQUVWMHBELElBQUksR0FBRyxJQUFJbkIsV0FBSixDQUFVejNELE9BQVYsQ0FGRztBQU9oQixXQUhBNDRELElBQUksQ0FBQ3h4QixRQUFMLENBQWNGLE1BQWQsR0FBdUIsS0FBSzJ4QixRQUc1QixFQUZBLEtBQUtBLFFBQUwsQ0FBY3R5RCxJQUFkLENBQW1CcXlELElBQW5CLENBRUEsRUFBT0EsSUFBUDtBQUNBLEdBNUNTOztBQThDVjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQUosVUFwRVUsb0JBb0VEeDRELE9BcEVDLEVBb0VRO0FBS2pCLFdBSklKLFFBQVEsQ0FBQ0ksT0FBRCxDQUlaLEtBSEN3NEQsU0FBUSxHQUFHeDRELE9BR1osR0FBT3c0RCxTQUFQO0FBQ0EsR0ExRVM7O0FBNEVWOzs7Ozs7Ozs7OztBQVdBSyxVQUFRLEVBQUUsRUF2RkE7O0FBeUZWOzs7Ozs7OztBQVFBQyxRQUFNLEVBQUU7QUFqR0UsQztBQUpYIiwiZmlsZSI6ImJpbGxib2FyZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcImQzLXRpbWUtZm9ybWF0XCIpLCByZXF1aXJlKFwiZDMtc2VsZWN0aW9uXCIpLCByZXF1aXJlKFwiZDMtdHJhbnNpdGlvblwiKSwgcmVxdWlyZShcImQzLWJydXNoXCIpLCByZXF1aXJlKFwiZDMtYXhpc1wiKSwgcmVxdWlyZShcImQzLXNjYWxlXCIpLCByZXF1aXJlKFwiZDMtZHN2XCIpLCByZXF1aXJlKFwiZDMtZHJhZ1wiKSwgcmVxdWlyZShcImQzLXpvb21cIiksIHJlcXVpcmUoXCJkMy1lYXNlXCIpLCByZXF1aXJlKFwiZDMtY29sb3JcIiksIHJlcXVpcmUoXCJkMy1zaGFwZVwiKSwgcmVxdWlyZShcImQzLWludGVycG9sYXRlXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcImQzLXRpbWUtZm9ybWF0XCIsIFwiZDMtc2VsZWN0aW9uXCIsIFwiZDMtdHJhbnNpdGlvblwiLCBcImQzLWJydXNoXCIsIFwiZDMtYXhpc1wiLCBcImQzLXNjYWxlXCIsIFwiZDMtZHN2XCIsIFwiZDMtZHJhZ1wiLCBcImQzLXpvb21cIiwgXCJkMy1lYXNlXCIsIFwiZDMtY29sb3JcIiwgXCJkMy1zaGFwZVwiLCBcImQzLWludGVycG9sYXRlXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSB7XG5cdFx0dmFyIGEgPSB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBmYWN0b3J5KHJlcXVpcmUoXCJkMy10aW1lLWZvcm1hdFwiKSwgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgcmVxdWlyZShcImQzLXRyYW5zaXRpb25cIiksIHJlcXVpcmUoXCJkMy1icnVzaFwiKSwgcmVxdWlyZShcImQzLWF4aXNcIiksIHJlcXVpcmUoXCJkMy1zY2FsZVwiKSwgcmVxdWlyZShcImQzLWRzdlwiKSwgcmVxdWlyZShcImQzLWRyYWdcIiksIHJlcXVpcmUoXCJkMy16b29tXCIpLCByZXF1aXJlKFwiZDMtZWFzZVwiKSwgcmVxdWlyZShcImQzLWNvbG9yXCIpLCByZXF1aXJlKFwiZDMtc2hhcGVcIiksIHJlcXVpcmUoXCJkMy1pbnRlcnBvbGF0ZVwiKSkgOiBmYWN0b3J5KHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSk7XG5cdFx0Zm9yKHZhciBpIGluIGEpICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgPyBleHBvcnRzIDogcm9vdClbaV0gPSBhW2ldO1xuXHR9XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zN19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Ml9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180M19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NF9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NV9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Nl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180N19fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180OF9fKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDEpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG5cbi8qIGVzbGludCBwcmVmZXItZGVzdHJ1Y3R1cmluZzogb2ZmICovXG5cbnZhciBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJyk7XG5cbnZhciBzb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG52YXIgb3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpLFxuICAgIGxvZyA9IF9yZXF1aXJlLmxvZyxcbiAgICBzZXRMb2dMZXZlbCA9IF9yZXF1aXJlLnNldExvZ0xldmVsO1xuXG52YXIgc2VuZE1lc3NhZ2UgPSByZXF1aXJlKCcuL3V0aWxzL3NlbmRNZXNzYWdlJyk7XG5cbnZhciByZWxvYWRBcHAgPSByZXF1aXJlKCcuL3V0aWxzL3JlbG9hZEFwcCcpO1xuXG52YXIgY3JlYXRlU29ja2V0VXJsID0gcmVxdWlyZSgnLi91dGlscy9jcmVhdGVTb2NrZXRVcmwnKTtcblxudmFyIHN0YXR1cyA9IHtcbiAgaXNVbmxvYWRpbmc6IGZhbHNlLFxuICBjdXJyZW50SGFzaDogJydcbn07XG52YXIgb3B0aW9ucyA9IHtcbiAgaG90OiBmYWxzZSxcbiAgaG90UmVsb2FkOiB0cnVlLFxuICBsaXZlUmVsb2FkOiBmYWxzZSxcbiAgaW5pdGlhbDogdHJ1ZSxcbiAgdXNlV2FybmluZ092ZXJsYXk6IGZhbHNlLFxuICB1c2VFcnJvck92ZXJsYXk6IGZhbHNlLFxuICB1c2VQcm9ncmVzczogZmFsc2Vcbn07XG52YXIgc29ja2V0VXJsID0gY3JlYXRlU29ja2V0VXJsKF9fcmVzb3VyY2VRdWVyeSk7XG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgc3RhdHVzLmlzVW5sb2FkaW5nID0gdHJ1ZTtcbn0pO1xuXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgdmFyIHFzID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC50b0xvd2VyQ2FzZSgpO1xuICBvcHRpb25zLmhvdFJlbG9hZCA9IHFzLmluZGV4T2YoJ2hvdHJlbG9hZD1mYWxzZScpID09PSAtMTtcbn1cblxudmFyIG9uU29ja2V0TWVzc2FnZSA9IHtcbiAgaG90OiBmdW5jdGlvbiBob3QoKSB7XG4gICAgb3B0aW9ucy5ob3QgPSB0cnVlO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBIb3QgTW9kdWxlIFJlcGxhY2VtZW50IGVuYWJsZWQuJyk7XG4gIH0sXG4gIGxpdmVSZWxvYWQ6IGZ1bmN0aW9uIGxpdmVSZWxvYWQoKSB7XG4gICAgb3B0aW9ucy5saXZlUmVsb2FkID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gTGl2ZSBSZWxvYWRpbmcgZW5hYmxlZC4nKTtcbiAgfSxcbiAgaW52YWxpZDogZnVuY3Rpb24gaW52YWxpZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlY29tcGlsaW5nLi4uJyk7IC8vIGZpeGVzICMxMDQyLiBvdmVybGF5IGRvZXNuJ3QgY2xlYXIgaWYgZXJyb3JzIGFyZSBmaXhlZCBidXQgd2FybmluZ3MgcmVtYWluLlxuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnSW52YWxpZCcpO1xuICB9LFxuICBoYXNoOiBmdW5jdGlvbiBoYXNoKF9oYXNoKSB7XG4gICAgc3RhdHVzLmN1cnJlbnRIYXNoID0gX2hhc2g7XG4gIH0sXG4gICdzdGlsbC1vayc6IGZ1bmN0aW9uIHN0aWxsT2soKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIE5vdGhpbmcgY2hhbmdlZC4nKTtcblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ1N0aWxsT2snKTtcbiAgfSxcbiAgJ2xvZy1sZXZlbCc6IGZ1bmN0aW9uIGxvZ0xldmVsKGxldmVsKSB7XG4gICAgdmFyIGhvdEN0eCA9IHJlcXVpcmUuY29udGV4dCgnd2VicGFjay9ob3QnLCBmYWxzZSwgL15cXC5cXC9sb2ckLyk7XG5cbiAgICBpZiAoaG90Q3R4LmtleXMoKS5pbmRleE9mKCcuL2xvZycpICE9PSAtMSkge1xuICAgICAgaG90Q3R4KCcuL2xvZycpLnNldExvZ0xldmVsKGxldmVsKTtcbiAgICB9XG5cbiAgICBzZXRMb2dMZXZlbChsZXZlbCk7XG4gIH0sXG4gIG92ZXJsYXk6IGZ1bmN0aW9uIG92ZXJsYXkodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgPSBmYWxzZTtcbiAgICAgICAgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgb3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSA9IHZhbHVlLndhcm5pbmdzO1xuICAgICAgICBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSA9IHZhbHVlLmVycm9ycztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHByb2dyZXNzOiBmdW5jdGlvbiBwcm9ncmVzcyhfcHJvZ3Jlc3MpIHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9ucy51c2VQcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgICB9XG4gIH0sXG4gICdwcm9ncmVzcy11cGRhdGUnOiBmdW5jdGlvbiBwcm9ncmVzc1VwZGF0ZShkYXRhKSB7XG4gICAgaWYgKG9wdGlvbnMudXNlUHJvZ3Jlc3MpIHtcbiAgICAgIGxvZy5pbmZvKFwiW1dEU10gXCIuY29uY2F0KGRhdGEucGVyY2VudCwgXCIlIC0gXCIpLmNvbmNhdChkYXRhLm1zZywgXCIuXCIpKTtcbiAgICB9XG5cbiAgICBzZW5kTWVzc2FnZSgnUHJvZ3Jlc3MnLCBkYXRhKTtcbiAgfSxcbiAgb2s6IGZ1bmN0aW9uIG9rKCkge1xuICAgIHNlbmRNZXNzYWdlKCdPaycpO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgfHwgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbml0aWFsKSB7XG4gICAgICByZXR1cm4gb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJldHVybi1hc3NpZ25cblxuXG4gICAgcmVsb2FkQXBwKG9wdGlvbnMsIHN0YXR1cyk7XG4gIH0sXG4gICdjb250ZW50LWNoYW5nZWQnOiBmdW5jdGlvbiBjb250ZW50Q2hhbmdlZCgpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQ29udGVudCBiYXNlIGNoYW5nZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHNlbGYubG9jYXRpb24ucmVsb2FkKCk7XG4gIH0sXG4gIHdhcm5pbmdzOiBmdW5jdGlvbiB3YXJuaW5ncyhfd2FybmluZ3MpIHtcbiAgICBsb2cud2FybignW1dEU10gV2FybmluZ3Mgd2hpbGUgY29tcGlsaW5nLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkV2FybmluZ3MgPSBfd2FybmluZ3MubWFwKGZ1bmN0aW9uICh3YXJuaW5nKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKHdhcm5pbmcpO1xuICAgIH0pO1xuXG4gICAgc2VuZE1lc3NhZ2UoJ1dhcm5pbmdzJywgc3RyaXBwZWRXYXJuaW5ncyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkV2FybmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxvZy53YXJuKHN0cmlwcGVkV2FybmluZ3NbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LnNob3dNZXNzYWdlKF93YXJuaW5ncyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICBlcnJvcnM6IGZ1bmN0aW9uIGVycm9ycyhfZXJyb3JzKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBFcnJvcnMgd2hpbGUgY29tcGlsaW5nLiBSZWxvYWQgcHJldmVudGVkLicpO1xuXG4gICAgdmFyIHN0cmlwcGVkRXJyb3JzID0gX2Vycm9ycy5tYXAoZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICByZXR1cm4gc3RyaXBBbnNpKGVycm9yKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKCdFcnJvcnMnLCBzdHJpcHBlZEVycm9ycyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmlwcGVkRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cuZXJyb3Ioc3RyaXBwZWRFcnJvcnNbaV0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfZXJyb3JzKTtcbiAgICB9XG5cbiAgICBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgfSxcbiAgZXJyb3I6IGZ1bmN0aW9uIGVycm9yKF9lcnJvcikge1xuICAgIGxvZy5lcnJvcihfZXJyb3IpO1xuICB9LFxuICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgbG9nLmVycm9yKCdbV0RTXSBEaXNjb25uZWN0ZWQhJyk7XG4gICAgc2VuZE1lc3NhZ2UoJ0Nsb3NlJyk7XG4gIH1cbn07XG5zb2NrZXQoc29ja2V0VXJsLCBvblNvY2tldE1lc3NhZ2UpOyIsIid1c2Ugc3RyaWN0JztcbnZhciBhbnNpUmVnZXggPSByZXF1aXJlKCdhbnNpLXJlZ2V4JykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyA/IHN0ci5yZXBsYWNlKGFuc2lSZWdleCwgJycpIDogc3RyO1xufTtcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gL1tcXHUwMDFiXFx1MDA5Yl1bWygpIzs/XSooPzpbMC05XXsxLDR9KD86O1swLTldezAsNH0pKik/WzAtOUEtUFJaY2YtbnFyeT0+PF0vZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gKi9cblxuLyogZXNsaW50LWRpc2FibGVcbiAgY2FtZWxjYXNlXG4qL1xuLy8gdGhpcyBTb2NrSlNDbGllbnQgaXMgaGVyZSBhcyBhIGRlZmF1bHQgZmFsbGJhY2ssIGluIGNhc2UgaW5saW5lIG1vZGVcbi8vIGlzIG9mZiBvciB0aGUgY2xpZW50IGlzIG5vdCBpbmplY3RlZC4gVGhpcyB3aWxsIGJlIHN3aXRjaGVkIHRvXG4vLyBXZWJzb2NrZXRDbGllbnQgd2hlbiBpdCBiZWNvbWVzIHRoZSBkZWZhdWx0XG4vLyBpbXBvcnRhbnQ6IHRoZSBwYXRoIHRvIFNvY2tKU0NsaWVudCBoZXJlIGlzIG1hZGUgdG8gd29yayBpbiB0aGUgJ2NsaWVudCdcbi8vIGRpcmVjdG9yeSwgYnV0IGlzIHVwZGF0ZWQgdmlhIHRoZSB3ZWJwYWNrIGNvbXBpbGF0aW9uIHdoZW4gY29tcGlsZWQgZnJvbVxuLy8gdGhlICdjbGllbnQtc3JjJyBkaXJlY3RvcnlcblxudmFyIENsaWVudCA9IHR5cGVvZiBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfZGV2X3NlcnZlcl9jbGllbnRfXyA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxucmVxdWlyZSgnLi9jbGllbnRzL1NvY2tKU0NsaWVudCcpO1xudmFyIHJldHJpZXMgPSAwO1xudmFyIGNsaWVudCA9IG51bGw7XG5cbnZhciBzb2NrZXQgPSBmdW5jdGlvbiBpbml0U29ja2V0KHVybCwgaGFuZGxlcnMpIHtcbiAgY2xpZW50ID0gbmV3IENsaWVudCh1cmwpO1xuICBjbGllbnQub25PcGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXRyaWVzID0gMDtcbiAgfSk7XG4gIGNsaWVudC5vbkNsb3NlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmV0cmllcyA9PT0gMCkge1xuICAgICAgaGFuZGxlcnMuY2xvc2UoKTtcbiAgICB9IC8vIFRyeSB0byByZWNvbm5lY3QuXG5cblxuICAgIGNsaWVudCA9IG51bGw7IC8vIEFmdGVyIDEwIHJldHJpZXMgc3RvcCB0cnlpbmcsIHRvIHByZXZlbnQgbG9nc3BhbS5cblxuICAgIGlmIChyZXRyaWVzIDw9IDEwKSB7XG4gICAgICAvLyBFeHBvbmVudGlhbGx5IGluY3JlYXNlIHRpbWVvdXQgdG8gcmVjb25uZWN0LlxuICAgICAgLy8gUmVzcGVjdGZ1bGx5IGNvcGllZCBmcm9tIHRoZSBwYWNrYWdlIGBnb3RgLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1peGVkLW9wZXJhdG9ycywgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXG4gICAgICB2YXIgcmV0cnlJbk1zID0gMTAwMCAqIE1hdGgucG93KDIsIHJldHJpZXMpICsgTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgIHJldHJpZXMgKz0gMTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzb2NrZXQodXJsLCBoYW5kbGVycyk7XG4gICAgICB9LCByZXRyeUluTXMpO1xuICAgIH1cbiAgfSk7XG4gIGNsaWVudC5vbk1lc3NhZ2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgbXNnID0gSlNPTi5wYXJzZShkYXRhKTtcblxuICAgIGlmIChoYW5kbGVyc1ttc2cudHlwZV0pIHtcbiAgICAgIGhhbmRsZXJzW21zZy50eXBlXShtc2cuZGF0YSk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc29ja2V0OyIsIid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlXG4gIG5vLXVudXNlZC12YXJzXG4qL1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMnKTtcblxudmFyIEJhc2VDbGllbnQgPSByZXF1aXJlKCcuL0Jhc2VDbGllbnQnKTtcblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlQ2xpZW50KSB7XG4gIF9pbmhlcml0cyhTb2NrSlNDbGllbnQsIF9CYXNlQ2xpZW50KTtcblxuICBmdW5jdGlvbiBTb2NrSlNDbGllbnQodXJsKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvY2tKU0NsaWVudCk7XG5cbiAgICBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTb2NrSlNDbGllbnQpLmNhbGwodGhpcykpO1xuICAgIF90aGlzLnNvY2sgPSBuZXcgU29ja0pTKHVybCk7XG5cbiAgICBfdGhpcy5zb2NrLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7Ly8gVE9ETzogdXNlIGxvZ2dlciB0byBsb2cgdGhlIGVycm9yIGV2ZW50IG9uY2UgY2xpZW50IGFuZCBjbGllbnQtc3JjXG4gICAgICAvLyBhcmUgcmVvcmdhbml6ZWQgdG8gaGF2ZSB0aGUgc2FtZSBkaXJlY3Rvcnkgc3RydWN0dXJlXG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTb2NrSlNDbGllbnQsIFt7XG4gICAga2V5OiBcIm9uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbk9wZW4oZikge1xuICAgICAgdGhpcy5zb2NrLm9ub3BlbiA9IGY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25DbG9zZShmKSB7XG4gICAgICB0aGlzLnNvY2sub25jbG9zZSA9IGY7XG4gICAgfSAvLyBjYWxsIGYgd2l0aCB0aGUgbWVzc2FnZSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG5cbiAgfSwge1xuICAgIGtleTogXCJvbk1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25NZXNzYWdlKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBmKGUuZGF0YSk7XG4gICAgICB9O1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICByZXR1cm4gcmVxdWlyZS5yZXNvbHZlKCcuL1NvY2tKU0NsaWVudCcpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb2NrSlNDbGllbnQ7XG59KEJhc2VDbGllbnQpOyIsIi8qIHNvY2tqcy1jbGllbnQgdjEuNC4wIHwgaHR0cDovL3NvY2tqcy5vcmcgfCBNSVQgbGljZW5zZSAqL1xuKGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuU29ja0pTID0gZigpfX0pKGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9tYWluXCI6MTQsXCIuL3RyYW5zcG9ydC1saXN0XCI6MTZ9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudHRhcmdldCcpXG4gIDtcblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xufVxuXG5pbmhlcml0cyhFdmVudEVtaXR0ZXIsIEV2ZW50VGFyZ2V0KTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0eXBlKSB7XG4gICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5vbih0eXBlLCBnKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXTtcbiAgaWYgKCFsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZXF1aXZhbGVudCBvZiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGwgLSAxKTtcbiAgZm9yICh2YXIgYWkgPSAxOyBhaSA8IGw7IGFpKyspIHtcbiAgICBhcmdzW2FpIC0gMV0gPSBhcmd1bWVudHNbYWldO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0se1wiLi9ldmVudHRhcmdldFwiOjUsXCJpbmhlcml0c1wiOjU3fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIEV2ZW50KGV2ZW50VHlwZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG59XG5cbkV2ZW50LnByb3RvdHlwZS5pbml0RXZlbnQgPSBmdW5jdGlvbihldmVudFR5cGUsIGNhbkJ1YmJsZSwgY2FuY2VsYWJsZSkge1xuICB0aGlzLnR5cGUgPSBldmVudFR5cGU7XG4gIHRoaXMuYnViYmxlcyA9IGNhbkJ1YmJsZTtcbiAgdGhpcy5jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcbiAgdGhpcy50aW1lU3RhbXAgPSArbmV3IERhdGUoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24oKSB7fTtcbkV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG59LHt9XSw1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxuICogICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0XG4gKi9cblxuZnVuY3Rpb24gRXZlbnRUYXJnZXQoKSB7XG4gIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xufVxuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICB9XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgLy8gIzRcbiAgaWYgKGFyci5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgYXJyID0gYXJyLmNvbmNhdChbbGlzdGVuZXJdKTtcbiAgfVxuICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFycjtcbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIGlmICghYXJyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpZHggPSBhcnIuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpZHggIT09IC0xKSB7XG4gICAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBNYWtlIGEgY29weSBzbyBhcyBub3QgdG8gaW50ZXJmZXJlIHdpdGggYSBjdXJyZW50IGRpc3BhdGNoRXZlbnQuXG4gICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdChhcnIuc2xpY2UoaWR4ICsgMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGV2ZW50ID0gYXJndW1lbnRzWzBdO1xuICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxID8gW2V2ZW50XSA6IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgLy8gc2V0LlxuICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIFRyYW5zcG9ydE1lc3NhZ2VFdmVudChkYXRhKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdtZXNzYWdlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuaW5oZXJpdHMoVHJhbnNwb3J0TWVzc2FnZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0TWVzc2FnZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjo0LFwiaW5oZXJpdHNcIjo1N31dLDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gIDtcblxuZnVuY3Rpb24gRmFjYWRlSlModHJhbnNwb3J0KSB7XG4gIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgdHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xufVxuXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdjJywgSlNPTjMuc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xuXG59LHtcIi4vdXRpbHMvaWZyYW1lXCI6NDcsXCJqc29uM1wiOjU4fV0sODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIEZhY2FkZUpTID0gcmVxdWlyZSgnLi9mYWNhZGUnKVxuICAsIEluZm9JZnJhbWVSZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aWZyYW1lLWJvb3RzdHJhcCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB2YXIgdHJhbnNwb3J0TWFwID0ge307XG4gIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbihhdCkge1xuICAgIGlmIChhdC5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydE1hcFthdC5mYWNhZGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV0gPSBhdC5mYWNhZGVUcmFuc3BvcnQ7XG4gICAgfVxuICB9KTtcblxuICAvLyBoYXJkLWNvZGVkIGZvciB0aGUgaW5mbyBpZnJhbWVcbiAgLy8gVE9ETyBzZWUgaWYgd2UgY2FuIG1ha2UgdGhpcyBtb3JlIGR5bmFtaWNcbiAgdHJhbnNwb3J0TWFwW0luZm9JZnJhbWVSZWNlaXZlci50cmFuc3BvcnROYW1lXSA9IEluZm9JZnJhbWVSZWNlaXZlcjtcbiAgdmFyIHBhcmVudE9yaWdpbjtcblxuICAvKiBlc2xpbnQtZGlzYWJsZSBjYW1lbGNhc2UgKi9cbiAgU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIGNhbWVsY2FzZSAqL1xuICAgIHZhciBmYWNhZGU7XG4gICAgaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkID0gbG9jLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChlLnNvdXJjZSAhPT0gcGFyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgcGFyZW50T3JpZ2luID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnRPcmlnaW4gPSBlLm9yaWdpbjtcbiAgICAgIH1cbiAgICAgIGlmIChlLm9yaWdpbiAhPT0gcGFyZW50T3JpZ2luKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWVNZXNzYWdlID0gSlNPTjMucGFyc2UoZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gaWZyYW1lVXRpbHMuY3VycmVudFdpbmRvd0lkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gICAgICBjYXNlICdzJzpcbiAgICAgICAgdmFyIHA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcCA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJzaW9uID0gcFswXTtcbiAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHBbMV07XG4gICAgICAgIHZhciB0cmFuc1VybCA9IHBbMl07XG4gICAgICAgIHZhciBiYXNlVXJsID0gcFszXTtcbiAgICAgICAgZGVidWcodmVyc2lvbiwgdHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCk7XG4gICAgICAgIC8vIGNoYW5nZSB0aGlzIHRvIHNlbXZlciBsb2dpY1xuICAgICAgICBpZiAodmVyc2lvbiAhPT0gU29ja0pTLnZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29tcGF0aWJsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIHZlcnNpb24gKyAnXCIsIHRoZSBpZnJhbWU6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxuICAgICAgICAgICAgIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoYmFzZVVybCwgbG9jLmhyZWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBuZXcgRmFjYWRlSlMobmV3IHRyYW5zcG9ydE1hcFt0cmFuc3BvcnRdKHRyYW5zVXJsLCBiYXNlVXJsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGZhY2FkZS5fc2VuZChpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBpZiAoZmFjYWRlKSB7XG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgIC8vIFN0YXJ0XG4gICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3MnKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL2ZhY2FkZVwiOjcsXCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6MTAsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWFqYXgnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0FqYXgodXJsLCBBamF4T2JqZWN0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHQwID0gK25ldyBEYXRlKCk7XG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIHZhciBpbmZvLCBydHQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBydHQgPSAoK25ldyBEYXRlKCkpIC0gdDA7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluZm8gPSBKU09OMy5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0VXRpbHMuaXNPYmplY3QoaW5mbykpIHtcbiAgICAgICAgaW5mbyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9BamF4LCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvQWpheC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy54by5jbG9zZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vdXRpbHMvb2JqZWN0XCI6NDksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXJJZnJhbWUodHJhbnNVcmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLmlyID0gbmV3IEluZm9BamF4KHRyYW5zVXJsLCBYSFJMb2NhbE9iamVjdCk7XG4gIHRoaXMuaXIub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgc2VsZi5pciA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgSlNPTjMuc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXJJZnJhbWUsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS1pbmZvLXJlY2VpdmVyJztcblxuSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pcikge1xuICAgIHRoaXMuaXIuY2xvc2UoKTtcbiAgICB0aGlzLmlyID0gbnVsbDtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXJJZnJhbWU7XG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi90cmFuc3BvcnQvaWZyYW1lXCI6MjIsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxuICAsIFhIUkNvcnMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXG4gICwgSW5mb0lmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXIoYmFzZVVybCwgdXJsSW5mbykge1xuICBkZWJ1ZyhiYXNlVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZG9YaHIoYmFzZVVybCwgdXJsSW5mbyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgaWdub3JpbmcgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgYW5kIHRoZSB3aGl0ZWxpc3RcblxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xuICAvLyBkZXRlcm1pbmUgbWV0aG9kIG9mIENPUlMgc3VwcG9ydCAoaWYgbmVlZGVkKVxuICBpZiAodXJsSW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcbiAgfVxuICBpZiAoWEhSQ29ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xuICB9XG4gIGlmIChYRFIuZW5hYmxlZCAmJiB1cmxJbmZvLnNhbWVTY2hlbWUpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcbiAgfVxuICBpZiAoSW5mb0lmcmFtZS5lbmFibGVkKCkpIHtcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcbiAgfVxuICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSRmFrZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsSW5mbykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pbmZvJylcbiAgICA7XG4gIGRlYnVnKCdkb1hocicsIHVybCk7XG5cbiAgdGhpcy54byA9IEluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIoYmFzZVVybCwgdXJsLCB1cmxJbmZvKTtcblxuICB0aGlzLnRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgfSwgSW5mb1JlY2VpdmVyLnRpbWVvdXQpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gIH0pO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgdGhpcy50aW1lb3V0UmVmID0gbnVsbDtcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICB9XG4gIHRoaXMueG8gPSBudWxsO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9pbmZvLWFqYXhcIjo5LFwiLi9pbmZvLWlmcmFtZVwiOjExLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjM0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6MzUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjozNixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uIHx8IHtcbiAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCdcbiwgcHJvdG9jb2w6ICdodHRwOidcbiwgaG9zdDogJ2xvY2FsaG9zdCdcbiwgcG9ydDogODBcbiwgaHJlZjogJ2h0dHA6Ly9sb2NhbGhvc3QvJ1xuLCBoYXNoOiAnJ1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG4gIHRoaXMuX3RyYW5zcG9ydE9wdGlvbnMgPSBvcHRpb25zLnRyYW5zcG9ydE9wdGlvbnMgfHwge307XG4gIHRoaXMuX3RpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgMDtcblxuICB2YXIgc2Vzc2lvbklkID0gb3B0aW9ucy5zZXNzaW9uSWQgfHwgODtcbiAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnbnVtYmVyJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmFuZG9tLnN0cmluZyhzZXNzaW9uSWQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gTWF0aC5tYXgodGhpcy5fdGltZW91dCwgKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwKTtcbiAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXQuYmluZCh0aGlzKSwgdGltZW91dE1zKTtcbiAgICBkZWJ1ZygndXNpbmcgdGltZW91dCcsIHRpbWVvdXRNcyk7XG5cbiAgICB2YXIgdHJhbnNwb3J0VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0aGlzLl90cmFuc1VybCwgJy8nICsgdGhpcy5fc2VydmVyICsgJy8nICsgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQoKSk7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl90cmFuc3BvcnRPcHRpb25zW1RyYW5zcG9ydC50cmFuc3BvcnROYW1lXTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCwgb3B0aW9ucyk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQgJiYgdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCk7XG4gICAgICB0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuT1BFTjtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ29wZW4nKSk7XG4gICAgZGVidWcoJ2Nvbm5lY3RlZCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxuICAgIC8vIGNvbm5lY3Rpb24uXG4gICAgdGhpcy5fY2xvc2UoMTAwNiwgJ1NlcnZlciBsb3N0IHNlc3Npb24nKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uLCB3YXNDbGVhbiwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgdmFyIGZvcmNlRmFpbCA9IGZhbHNlO1xuXG4gIGlmICh0aGlzLl9pcikge1xuICAgIGZvcmNlRmFpbCA9IHRydWU7XG4gICAgdGhpcy5faXIuY2xvc2UoKTtcbiAgICB0aGlzLl9pciA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFNvY2tKUyBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCcpO1xuICB9XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NJTkc7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NFRDtcblxuICAgIGlmIChmb3JjZUZhaWwpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2Vycm9yJykpO1xuICAgIH1cblxuICAgIHZhciBlID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJyk7XG4gICAgZS53YXNDbGVhbiA9IHdhc0NsZWFuIHx8IGZhbHNlO1xuICAgIGUuY29kZSA9IGNvZGUgfHwgMTAwMDtcbiAgICBlLnJlYXNvbiA9IHJlYXNvbjtcblxuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcbiAgICB0aGlzLm9ubWVzc2FnZSA9IHRoaXMub25jbG9zZSA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgZGVidWcoJ2Rpc2Nvbm5lY3RlZCcpO1xuICB9LmJpbmQodGhpcyksIDApO1xufTtcblxuLy8gU2VlOiBodHRwOi8vd3d3LmVyZy5hYmRuLmFjLnVrL35nZXJyaXQvZGNjcC9ub3Rlcy9jY2lkMi9ydG9fZXN0aW1hdG9yL1xuLy8gYW5kIFJGQyAyOTg4LlxuU29ja0pTLnByb3RvdHlwZS5jb3VudFJUTyA9IGZ1bmN0aW9uKHJ0dCkge1xuICAvLyBJbiBhIGxvY2FsIGVudmlyb25tZW50LCB3aGVuIHVzaW5nIElFOC85IGFuZCB0aGUgYGpzb25wLXBvbGxpbmdgXG4gIC8vIHRyYW5zcG9ydCB0aGUgdGltZSBuZWVkZWQgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbiAodGhlIHRpbWUgdGhhdCBwYXNzXG4gIC8vIGZyb20gdGhlIG9wZW5pbmcgb2YgdGhlIHRyYW5zcG9ydCB0byB0aGUgY2FsbCBvZiBgX2Rpc3BhdGNoT3BlbmApIGlzXG4gIC8vIGFyb3VuZCAyMDBtc2VjICh0aGUgbG93ZXIgYm91bmQgdXNlZCBpbiB0aGUgYXJ0aWNsZSBhYm92ZSkgYW5kIHRoaXNcbiAgLy8gY2F1c2VzIHNwdXJpb3VzIHRpbWVvdXRzLiBGb3IgdGhpcyByZWFzb24gd2UgY2FsY3VsYXRlIGEgdmFsdWUgc2xpZ2h0bHlcbiAgLy8gbGFyZ2VyIHRoYW4gdGhhdCB1c2VkIGluIHRoZSBhcnRpY2xlLlxuICBpZiAocnR0ID4gMTAwKSB7XG4gICAgcmV0dXJuIDQgKiBydHQ7IC8vIHJ0byA+IDQwMG1zZWNcbiAgfVxuICByZXR1cm4gMzAwICsgcnR0OyAvLyAzMDBtc2VjIDwgcnRvIDw9IDQwMG1zZWNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICB0cmFuc3BvcnRzID0gdHJhbnNwb3J0KGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXF1aXJlKCcuL2lmcmFtZS1ib290c3RyYXAnKShTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpO1xuICByZXR1cm4gU29ja0pTO1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi9ldmVudC9jbG9zZVwiOjIsXCIuL2V2ZW50L2V2ZW50XCI6NCxcIi4vZXZlbnQvZXZlbnR0YXJnZXRcIjo1LFwiLi9ldmVudC90cmFucy1tZXNzYWdlXCI6NixcIi4vaWZyYW1lLWJvb3RzdHJhcFwiOjgsXCIuL2luZm8tcmVjZWl2ZXJcIjoxMixcIi4vbG9jYXRpb25cIjoxMyxcIi4vc2hpbXNcIjoxNSxcIi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi91dGlscy9lc2NhcGVcIjo0NSxcIi4vdXRpbHMvZXZlbnRcIjo0NixcIi4vdXRpbHMvbG9nXCI6NDgsXCIuL3V0aWxzL29iamVjdFwiOjQ5LFwiLi91dGlscy9yYW5kb21cIjo1MCxcIi4vdXRpbHMvdHJhbnNwb3J0XCI6NTEsXCIuL3V0aWxzL3VybFwiOjUyLFwiLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTgsXCJ1cmwtcGFyc2VcIjo2MX1dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qIGVzbGludC1kaXNhYmxlICovXG4vKiBqc2NzOiBkaXNhYmxlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIHB1bGxlZCBzcGVjaWZpYyBzaGltcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBTdHJpbmdQcm90b3R5cGUgPSBTdHJpbmcucHJvdG90eXBlO1xudmFyIGFycmF5X3NsaWNlID0gQXJyYXlQcm90b3R5cGUuc2xpY2U7XG5cbnZhciBfdG9TdHJpbmcgPSBPYmplY3RQcm90b3R5cGUudG9TdHJpbmc7XG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICByZXR1cm4gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn07XG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7XG4gICAgcmV0dXJuIF90b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudmFyIHN1cHBvcnRzRGVzY3JpcHRvcnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICd4Jywge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7IC8qIHRoaXMgaXMgRVMzICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KCkpO1xuXG4vLyBEZWZpbmUgY29uZmlndXJhYmxlLCB3cml0YWJsZSBhbmQgbm9uLWVudW1lcmFibGUgcHJvcHNcbi8vIGlmIHRoZXkgZG9uJ3QgZXhpc3QuXG52YXIgZGVmaW5lUHJvcGVydHk7XG5pZiAoc3VwcG9ydHNEZXNjcmlwdG9ycykge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogbWV0aG9kXG4gICAgICAgIH0pO1xuICAgIH07XG59IGVsc2Uge1xuICAgIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZSwgbWV0aG9kLCBmb3JjZUFzc2lnbikge1xuICAgICAgICBpZiAoIWZvcmNlQXNzaWduICYmIChuYW1lIGluIG9iamVjdCkpIHsgcmV0dXJuOyB9XG4gICAgICAgIG9iamVjdFtuYW1lXSA9IG1ldGhvZDtcbiAgICB9O1xufVxudmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqZWN0LCBtYXAsIGZvcmNlQXNzaWduKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgaWYgKE9iamVjdFByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcCwgbmFtZSkpIHtcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIG1hcFtuYW1lXSwgZm9yY2VBc3NpZ24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIHRvT2JqZWN0ID0gZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAobyA9PSBudWxsKSB7IC8vIHRoaXMgbWF0Y2hlcyBib3RoIG51bGwgYW5kIHVuZGVmaW5lZFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIG8gKyAnIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0KG8pO1xufTtcblxuLy9cbi8vIFV0aWxcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDkuNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OS40XG4vLyBodHRwOi8vanNwZXJmLmNvbS90by1pbnRlZ2VyXG5cbmZ1bmN0aW9uIHRvSW50ZWdlcihudW0pIHtcbiAgICB2YXIgbiA9ICtudW07XG4gICAgaWYgKG4gIT09IG4pIHsgLy8gaXNOYU5cbiAgICAgICAgbiA9IDA7XG4gICAgfSBlbHNlIGlmIChuICE9PSAwICYmIG4gIT09ICgxIC8gMCkgJiYgbiAhPT0gLSgxIC8gMCkpIHtcbiAgICAgICAgbiA9IChuID4gMCB8fCAtMSkgKiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIFRvVWludDMyKHgpIHtcbiAgICByZXR1cm4geCA+Pj4gMDtcbn1cblxuLy9cbi8vIEZ1bmN0aW9uXG4vLyA9PT09PT09PVxuLy9cblxuLy8gRVMtNSAxNS4zLjQuNVxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcblxuZnVuY3Rpb24gRW1wdHkoKSB7fVxuXG5kZWZpbmVQcm9wZXJ0aWVzKEZ1bmN0aW9uUHJvdG90eXBlLCB7XG4gICAgYmluZDogZnVuY3Rpb24gYmluZCh0aGF0KSB7IC8vIC5sZW5ndGggaXMgMVxuICAgICAgICAvLyAxLiBMZXQgVGFyZ2V0IGJlIHRoZSB0aGlzIHZhbHVlLlxuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgLy8gMi4gSWYgSXNDYWxsYWJsZShUYXJnZXQpIGlzIGZhbHNlLCB0aHJvdyBhIFR5cGVFcnJvciBleGNlcHRpb24uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbih0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICcgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIDMuIExldCBBIGJlIGEgbmV3IChwb3NzaWJseSBlbXB0eSkgaW50ZXJuYWwgbGlzdCBvZiBhbGwgb2YgdGhlXG4gICAgICAgIC8vICAgYXJndW1lbnQgdmFsdWVzIHByb3ZpZGVkIGFmdGVyIHRoaXNBcmcgKGFyZzEsIGFyZzIgZXRjKSwgaW4gb3JkZXIuXG4gICAgICAgIC8vIFhYWCBzbGljZWRBcmdzIHdpbGwgc3RhbmQgaW4gZm9yIFwiQVwiIGlmIHVzZWRcbiAgICAgICAgdmFyIGFyZ3MgPSBhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBub3JtYWwgY2FsbFxuICAgICAgICAvLyA0LiBMZXQgRiBiZSBhIG5ldyBuYXRpdmUgRUNNQVNjcmlwdCBvYmplY3QuXG4gICAgICAgIC8vIDExLiBTZXQgdGhlIFtbUHJvdG90eXBlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0aGUgc3RhbmRhcmRcbiAgICAgICAgLy8gICBidWlsdC1pbiBGdW5jdGlvbiBwcm90b3R5cGUgb2JqZWN0IGFzIHNwZWNpZmllZCBpbiAxNS4zLjMuMS5cbiAgICAgICAgLy8gMTIuIFNldCB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4xLlxuICAgICAgICAvLyAxMy4gU2V0IHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMi5cbiAgICAgICAgLy8gMTQuIFNldCB0aGUgW1tIYXNJbnN0YW5jZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMy5cbiAgICAgICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjIgW1tDb25zdHJ1Y3RdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LFxuICAgICAgICAgICAgICAgIC8vIEYgdGhhdCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dXG4gICAgICAgICAgICAgICAgLy8gICBpbnRlcm5hbCBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBJZiB0YXJnZXQgaGFzIG5vIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgbWV0aG9kLCBhXG4gICAgICAgICAgICAgICAgLy8gICBUeXBlRXJyb3IgZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIG1ldGhvZCBvZiB0YXJnZXQgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIDE1LjMuNC41LjEgW1tDYWxsXV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsIEYsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgdmFsdWUgYW5kIGEgbGlzdCBvZiBhcmd1bWVudHMgRXh0cmFBcmdzLCB0aGUgZm9sbG93aW5nXG4gICAgICAgICAgICAgICAgLy8gc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAyLiBMZXQgYm91bmRUaGlzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZFRoaXNdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gNC4gTGV0IGFyZ3MgYmUgYSBuZXcgbGlzdCBjb250YWluaW5nIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgICAgICAgICAgICAvLyAgIGxpc3QgYm91bmRBcmdzIGluIHRoZSBzYW1lIG9yZGVyIGZvbGxvd2VkIGJ5IHRoZSBzYW1lXG4gICAgICAgICAgICAgICAgLy8gICB2YWx1ZXMgYXMgdGhlIGxpc3QgRXh0cmFBcmdzIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIC8vIDUuIFJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vICAgb2YgdGFyZ2V0IHByb3ZpZGluZyBib3VuZFRoaXMgYXMgdGhlIHRoaXMgdmFsdWUgYW5kXG4gICAgICAgICAgICAgICAgLy8gICBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgLy8gZXF1aXY6IHRhcmdldC5jYWxsKHRoaXMsIC4uLmJvdW5kQXJncywgLi4uYXJncylcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gMTUuIElmIHRoZSBbW0NsYXNzXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgVGFyZ2V0IGlzIFwiRnVuY3Rpb25cIiwgdGhlblxuICAgICAgICAvLyAgICAgYS4gTGV0IEwgYmUgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBUYXJnZXQgbWludXMgdGhlIGxlbmd0aCBvZiBBLlxuICAgICAgICAvLyAgICAgYi4gU2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gZWl0aGVyIDAgb3IgTCwgd2hpY2hldmVyIGlzXG4gICAgICAgIC8vICAgICAgIGxhcmdlci5cbiAgICAgICAgLy8gMTYuIEVsc2Ugc2V0IHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gMC5cblxuICAgICAgICB2YXIgYm91bmRMZW5ndGggPSBNYXRoLm1heCgwLCB0YXJnZXQubGVuZ3RoIC0gYXJncy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIDE3LiBTZXQgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byB0aGUgdmFsdWVzXG4gICAgICAgIC8vICAgc3BlY2lmaWVkIGluIDE1LjMuNS4xLlxuICAgICAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm91bmRBcmdzLnB1c2goJyQnICsgaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBYWFggQnVpbGQgYSBkeW5hbWljIGZ1bmN0aW9uIHdpdGggZGVzaXJlZCBhbW91bnQgb2YgYXJndW1lbnRzIGlzIHRoZSBvbmx5XG4gICAgICAgIC8vIHdheSB0byBzZXQgdGhlIGxlbmd0aCBwcm9wZXJ0eSBvZiBhIGZ1bmN0aW9uLlxuICAgICAgICAvLyBJbiBlbnZpcm9ubWVudHMgd2hlcmUgQ29udGVudCBTZWN1cml0eSBQb2xpY2llcyBlbmFibGVkIChDaHJvbWUgZXh0ZW5zaW9ucyxcbiAgICAgICAgLy8gZm9yIGV4LikgYWxsIHVzZSBvZiBldmFsIG9yIEZ1bmN0aW9uIGNvc3RydWN0b3IgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgLy8gSG93ZXZlciBpbiBhbGwgb2YgdGhlc2UgZW52aXJvbm1lbnRzIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGV4aXN0c1xuICAgICAgICAvLyBhbmQgc28gdGhpcyBjb2RlIHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQuXG4gICAgICAgIHZhciBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0nKShiaW5kZXIpO1xuXG4gICAgICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBkYW5nbGluZyByZWZlcmVuY2VzLlxuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTguIFNldCB0aGUgW1tFeHRlbnNpYmxlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiB0byB0cnVlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gMTkuIExldCB0aHJvd2VyIGJlIHRoZSBbW1Rocm93VHlwZUVycm9yXV0gZnVuY3Rpb24gT2JqZWN0ICgxMy4yLjMpLlxuICAgICAgICAvLyAyMC4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJjYWxsZXJcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLCBbW1NldF1dOlxuICAgICAgICAvLyAgIHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LCBhbmRcbiAgICAgICAgLy8gICBmYWxzZS5cbiAgICAgICAgLy8gMjEuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiYXJndW1lbnRzXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlcixcbiAgICAgICAgLy8gICBbW1NldF1dOiB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSxcbiAgICAgICAgLy8gICBhbmQgZmFsc2UuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyBOT1RFIEZ1bmN0aW9uIG9iamVjdHMgY3JlYXRlZCB1c2luZyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBkbyBub3RcbiAgICAgICAgLy8gaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBvciB0aGUgW1tDb2RlXV0sIFtbRm9ybWFsUGFyYW1ldGVyc11dLCBhbmRcbiAgICAgICAgLy8gW1tTY29wZV1dIGludGVybmFsIHByb3BlcnRpZXMuXG4gICAgICAgIC8vIFhYWCBjYW4ndCBkZWxldGUgcHJvdG90eXBlIGluIHB1cmUtanMuXG5cbiAgICAgICAgLy8gMjIuIFJldHVybiBGLlxuICAgICAgICByZXR1cm4gYm91bmQ7XG4gICAgfVxufSk7XG5cbi8vXG4vLyBBcnJheVxuLy8gPT09PT1cbi8vXG5cbi8vIEVTNSAxNS40LjMuMlxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC4zLjJcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2lzQXJyYXlcbmRlZmluZVByb3BlcnRpZXMoQXJyYXksIHsgaXNBcnJheTogaXNBcnJheSB9KTtcblxuXG52YXIgYm94ZWRTdHJpbmcgPSBPYmplY3QoJ2EnKTtcbnZhciBzcGxpdFN0cmluZyA9IGJveGVkU3RyaW5nWzBdICE9PSAnYScgfHwgISgwIGluIGJveGVkU3RyaW5nKTtcblxudmFyIHByb3Blcmx5Qm94ZXNDb250ZXh0ID0gZnVuY3Rpb24gcHJvcGVybHlCb3hlZChtZXRob2QpIHtcbiAgICAvLyBDaGVjayBub2RlIDAuNi4yMSBidWcgd2hlcmUgdGhpcmQgcGFyYW1ldGVyIGlzIG5vdCBib3hlZFxuICAgIHZhciBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gdHJ1ZTtcbiAgICB2YXIgcHJvcGVybHlCb3hlc1N0cmljdCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgICBtZXRob2QuY2FsbCgnZm9vJywgZnVuY3Rpb24gKF8sIF9fLCBjb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRleHQgIT09ICdvYmplY3QnKSB7IHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSBmYWxzZTsgfVxuICAgICAgICB9KTtcblxuICAgICAgICBtZXRob2QuY2FsbChbMV0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0eXBlb2YgdGhpcyA9PT0gJ3N0cmluZyc7XG4gICAgICAgIH0sICd4Jyk7XG4gICAgfVxuICAgIHJldHVybiAhIW1ldGhvZCAmJiBwcm9wZXJseUJveGVzTm9uU3RyaWN0ICYmIHByb3Blcmx5Qm94ZXNTdHJpY3Q7XG59O1xuXG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChmdW4gLyosIHRoaXNwKi8pIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiBvYmplY3QsXG4gICAgICAgICAgICB0aGlzcCA9IGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGkgPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIC8vIElmIG5vIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIGlmIGNhbGxiYWNrIGlzIG5vdCBhIGNhbGxhYmxlIGZ1bmN0aW9uXG4gICAgICAgIGlmICghaXNGdW5jdGlvbihmdW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7IC8vIFRPRE8gbWVzc2FnZVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gd2l0aCBjYWxsLCBwYXNzaW5nIGFyZ3VtZW50czpcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0LCBwcm9wZXJ0eSB2YWx1ZSwgcHJvcGVydHkga2V5LCB0aGlzQXJnIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHRcbiAgICAgICAgICAgICAgICBmdW4uY2FsbCh0aGlzcCwgc2VsZltpXSwgaSwgb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0sICFwcm9wZXJseUJveGVzQ29udGV4dChBcnJheVByb3RvdHlwZS5mb3JFYWNoKSk7XG5cbi8vIEVTNSAxNS40LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuNC4xNFxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaW5kZXhPZlxudmFyIGhhc0ZpcmVmb3gySW5kZXhPZkJ1ZyA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mICYmIFswLCAxXS5pbmRleE9mKDEsIDIpICE9PSAtMTtcbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBpbmRleE9mOiBmdW5jdGlvbiBpbmRleE9mKHNvdWdodCAvKiwgZnJvbUluZGV4ICovICkge1xuICAgICAgICB2YXIgc2VsZiA9IHNwbGl0U3RyaW5nICYmIGlzU3RyaW5nKHRoaXMpID8gdGhpcy5zcGxpdCgnJykgOiB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNlbGYubGVuZ3RoID4+PiAwO1xuXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaSA9IHRvSW50ZWdlcihhcmd1bWVudHNbMV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIG5lZ2F0aXZlIGluZGljZXNcbiAgICAgICAgaSA9IGkgPj0gMCA/IGkgOiBNYXRoLm1heCgwLCBsZW5ndGggKyBpKTtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gc2VsZiAmJiBzZWxmW2ldID09PSBzb3VnaHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxufSwgaGFzRmlyZWZveDJJbmRleE9mQnVnKTtcblxuLy9cbi8vIFN0cmluZ1xuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgMTUuNS40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMTRcblxuLy8gW2J1Z2ZpeCwgSUUgbHQgOSwgZmlyZWZveCA0LCBLb25xdWVyb3IsIE9wZXJhLCBvYnNjdXJlIGJyb3dzZXJzXVxuLy8gTWFueSBicm93c2VycyBkbyBub3Qgc3BsaXQgcHJvcGVybHkgd2l0aCByZWd1bGFyIGV4cHJlc3Npb25zIG9yIHRoZXlcbi8vIGRvIG5vdCBwZXJmb3JtIHRoZSBzcGxpdCBjb3JyZWN0bHkgdW5kZXIgb2JzY3VyZSBjb25kaXRpb25zLlxuLy8gU2VlIGh0dHA6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy9jcm9zcy1icm93c2VyLXNwbGl0XG4vLyBJJ3ZlIHRlc3RlZCBpbiBtYW55IGJyb3dzZXJzIGFuZCB0aGlzIHNlZW1zIHRvIGNvdmVyIHRoZSBkZXZpYW50IG9uZXM6XG4vLyAgICAnYWInLnNwbGl0KC8oPzphYikqLykgc2hvdWxkIGJlIFtcIlwiLCBcIlwiXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pIHNob3VsZCBiZSBbXCJcIiwgXCIuXCIsIFwiXCIsIFwiXCJdLCBub3QgW1wiXCIsIFwiXCJdXG4vLyAgICAndGVzc3QnLnNwbGl0KC8ocykqLykgc2hvdWxkIGJlIFtcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgXCJzXCIsIFwidFwiXSwgbm90XG4vLyAgICAgICBbdW5kZWZpbmVkLCBcInRcIiwgdW5kZWZpbmVkLCBcImVcIiwgLi4uXVxuLy8gICAgJycuc3BsaXQoLy4/Lykgc2hvdWxkIGJlIFtdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLygpKCkvKSBzaG91bGQgYmUgW1wiLlwiXSwgbm90IFtcIlwiLCBcIlwiLCBcIi5cIl1cblxudmFyIHN0cmluZ19zcGxpdCA9IFN0cmluZ1Byb3RvdHlwZS5zcGxpdDtcbmlmIChcbiAgICAnYWInLnNwbGl0KC8oPzphYikqLykubGVuZ3RoICE9PSAyIHx8XG4gICAgJy4nLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aCAhPT0gNCB8fFxuICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKVsxXSA9PT0gJ3QnIHx8XG4gICAgJ3Rlc3QnLnNwbGl0KC8oPzopLywgLTEpLmxlbmd0aCAhPT0gNCB8fFxuICAgICcnLnNwbGl0KC8uPy8pLmxlbmd0aCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDFcbikge1xuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjb21wbGlhbnRFeGVjTnBjZyA9IC8oKT8/Ly5leGVjKCcnKVsxXSA9PT0gdm9pZCAwOyAvLyBOUENHOiBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cFxuXG4gICAgICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcztcbiAgICAgICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYHNlcGFyYXRvcmAgaXMgbm90IGEgcmVnZXgsIHVzZSBuYXRpdmUgc3BsaXRcbiAgICAgICAgICAgIGlmIChfdG9TdHJpbmcuY2FsbChzZXBhcmF0b3IpICE9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IFtdLFxuICAgICAgICAgICAgICAgIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lICA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLmV4dGVuZGVkICAgPyAneCcgOiAnJykgKyAvLyBQcm9wb3NlZCBmb3IgRVM2XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSAgICAgPyAneScgOiAnJyksIC8vIEZpcmVmb3ggMytcbiAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gMCxcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGBnbG9iYWxgIGFuZCBhdm9pZCBgbGFzdEluZGV4YCBpc3N1ZXMgYnkgd29ya2luZyB3aXRoIGEgY29weVxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIsIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBuZXcgUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcbiAgICAgICAgICAgIHN0cmluZyArPSAnJzsgLy8gVHlwZS1jb252ZXJ0XG4gICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9lc24ndCBuZWVkIGZsYWdzIGd5LCBidXQgdGhleSBkb24ndCBodXJ0XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiA9IG5ldyBSZWdFeHAoJ14nICsgc2VwYXJhdG9yLnNvdXJjZSArICckKD8hXFxcXHMpJywgZmxhZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogVmFsdWVzIGZvciBgbGltaXRgLCBwZXIgdGhlIHNwZWM6XG4gICAgICAgICAgICAgKiBJZiB1bmRlZmluZWQ6IDQyOTQ5NjcyOTUgLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICogSWYgMCwgSW5maW5pdHksIG9yIE5hTjogMFxuICAgICAgICAgICAgICogSWYgcG9zaXRpdmUgbnVtYmVyOiBsaW1pdCA9IE1hdGguZmxvb3IobGltaXQpOyBpZiAobGltaXQgPiA0Mjk0OTY3Mjk1KSBsaW1pdCAtPSA0Mjk0OTY3Mjk2O1xuICAgICAgICAgICAgICogSWYgbmVnYXRpdmUgbnVtYmVyOiA0Mjk0OTY3Mjk2IC0gTWF0aC5mbG9vcihNYXRoLmFicyhsaW1pdCkpXG4gICAgICAgICAgICAgKiBJZiBvdGhlcjogVHlwZS1jb252ZXJ0LCB0aGVuIHVzZSB0aGUgYWJvdmUgcnVsZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGltaXQgPSBsaW1pdCA9PT0gdm9pZCAwID9cbiAgICAgICAgICAgICAgICAtMSA+Pj4gMCA6IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAgICBUb1VpbnQzMihsaW1pdCk7XG4gICAgICAgICAgICB3aGlsZSAobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gYHNlcGFyYXRvci5sYXN0SW5kZXhgIGlzIG5vdCByZWxpYWJsZSBjcm9zcy1icm93c2VyXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA+IGxhc3RMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgIGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZyAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5yZXBsYWNlKHNlcGFyYXRvcjIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFtpXSA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXlQcm90b3R5cGUucHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvci5sYXN0SW5kZXggPT09IG1hdGNoLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXgrKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RMZW5ndGggfHwgIXNlcGFyYXRvci50ZXN0KCcnKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC5sZW5ndGggPiBsaW1pdCA/IG91dHB1dC5zbGljZSgwLCBsaW1pdCkgOiBvdXRwdXQ7XG4gICAgICAgIH07XG4gICAgfSgpKTtcblxuLy8gW2J1Z2ZpeCwgY2hyb21lXVxuLy8gSWYgc2VwYXJhdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiB0aGUgcmVzdWx0IGFycmF5IGNvbnRhaW5zIGp1c3Qgb25lIFN0cmluZyxcbi8vIHdoaWNoIGlzIHRoZSB0aGlzIHZhbHVlIChjb252ZXJ0ZWQgdG8gYSBTdHJpbmcpLiBJZiBsaW1pdCBpcyBub3QgdW5kZWZpbmVkLFxuLy8gdGhlbiB0aGUgb3V0cHV0IGFycmF5IGlzIHRydW5jYXRlZCBzbyB0aGF0IGl0IGNvbnRhaW5zIG5vIG1vcmUgdGhhbiBsaW1pdFxuLy8gZWxlbWVudHMuXG4vLyBcIjBcIi5zcGxpdCh1bmRlZmluZWQsIDApIC0+IFtdXG59IGVsc2UgaWYgKCcwJy5zcGxpdCh2b2lkIDAsIDApLmxlbmd0aCkge1xuICAgIFN0cmluZ1Byb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfTtcbn1cblxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbi8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbnZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0IDwgMCA/ICgoc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0KSA8IDAgPyAwIDogc3RhcnQpIDogc3RhcnQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbn0se31dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIC8vIHN0cmVhbWluZyB0cmFuc3BvcnRzXG4gIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3dlYnNvY2tldCcpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpKVxuXG4gIC8vIHBvbGxpbmcgdHJhbnNwb3J0c1xuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nJylcbl07XG5cbn0se1wiLi90cmFuc3BvcnQvZXZlbnRzb3VyY2VcIjoyMCxcIi4vdHJhbnNwb3J0L2h0bWxmaWxlXCI6MjEsXCIuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nXCI6MjMsXCIuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXBcIjoyNixcIi4vdHJhbnNwb3J0L3dlYnNvY2tldFwiOjM4LFwiLi90cmFuc3BvcnQveGRyLXBvbGxpbmdcIjozOSxcIi4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmdcIjo0MCxcIi4vdHJhbnNwb3J0L3hoci1wb2xsaW5nXCI6NDEsXCIuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nXCI6NDJ9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBYSFIgPSBnbG9iYWwuWE1MSHR0cFJlcXVlc3RcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJyb3dzZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIEFic3RyYWN0WEhST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhBYnN0cmFjdFhIUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIHRoaXMueGhyID0gbmV3IFhIUigpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG5cbiAgaWYgKCF0aGlzLnhocikge1xuICAgIGRlYnVnKCdubyB4aHInKTtcbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICdubyB4aHIgc3VwcG9ydCcpO1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzZXZlcmFsIGJyb3dzZXJzIGNhY2hlIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxuICAvLyB0YWIgZ2V0cyBjbG9zZWQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzUyODBcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCBjbGVhbnVwJyk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgdGhpcy54aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKHRoaXMudGltZW91dCAmJiAndGltZW91dCcgaW4gdGhpcy54aHIpIHtcbiAgICAgIHRoaXMueGhyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGVidWcoJ3hociB0aW1lb3V0Jyk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoJ2V4Y2VwdGlvbicsIGUpO1xuICAgIC8vIElFIHJhaXNlcyBhbiBleGNlcHRpb24gb24gd3JvbmcgcG9ydC5cbiAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoKCFvcHRzIHx8ICFvcHRzLm5vQ3JlZGVudGlhbHMpICYmIEFic3RyYWN0WEhST2JqZWN0LnN1cHBvcnRzQ09SUykge1xuICAgIGRlYnVnKCd3aXRoQ3JlZGVudGlhbHMnKTtcbiAgICAvLyBNb3ppbGxhIGRvY3Mgc2F5cyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9YTUxIdHRwUmVxdWVzdCA6XG4gICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG5cbiAgICB0aGlzLnhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICB9XG4gIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICB2YXIgeCA9IHNlbGYueGhyO1xuICAgICAgdmFyIHRleHQsIHN0YXR1cztcbiAgICAgIGRlYnVnKCdyZWFkeVN0YXRlJywgeC5yZWFkeVN0YXRlKTtcbiAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSUUgZG9lcyByZXR1cm4gcmVhZHlzdGF0ZSA9PSAzIGZvciA0MDQgYW5zd2Vycy5cbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwICYmIHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGVidWcoJ2NodW5rJyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdjaHVuaycsIHN0YXR1cywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJRSByZXR1cm5zIHRoaXMgZm9yIGEgYmFkIHBvcnRcbiAgICAgICAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9hYTM4Mzc3MCh2PXZzLjg1KS5hc3B4XG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMDA1IHx8IHN0YXR1cyA9PT0gMTIwMjkpIHtcbiAgICAgICAgICBzdGF0dXMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIHN0YXR1cywgeC5yZXNwb25zZVRleHQpO1xuICAgICAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHRyeSB7XG4gICAgc2VsZi54aHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgLy8gSUUgbmVlZHMgdGhpcyBmaWVsZCB0byBiZSBhIGZ1bmN0aW9uXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge307XG4gIGlmICh0aGlzLnhoci5vbnRpbWVvdXQpIHtcbiAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBudWxsO1xuICB9XG5cbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGhyID0gbnVsbDtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIVhIUjtcbi8vIG92ZXJyaWRlIFhNTEh0dHBSZXF1ZXN0IGZvciBJRTYvN1xuLy8gb2JmdXNjYXRlIHRvIGF2b2lkIGZpcmV3YWxsc1xudmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG5pZiAoIUFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgJiYgKGF4byBpbiBnbG9iYWwpKSB7XG4gIGRlYnVnKCdvdmVycmlkaW5nIHhtbGh0dHByZXF1ZXN0Jyk7XG4gIFhIUiA9IGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IGdsb2JhbFtheG9dKCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhbmV3IFhIUigpO1xufVxuXG52YXIgY29ycyA9IGZhbHNlO1xudHJ5IHtcbiAgY29ycyA9ICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYSFIoKTtcbn0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxufVxuXG5BYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMgPSBjb3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIERyaXZlciA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcbmlmIChEcml2ZXIpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBXZWJTb2NrZXRCcm93c2VyRHJpdmVyKHVybCkge1xuXHRcdHJldHVybiBuZXcgRHJpdmVyKHVybCk7XG5cdH07XG59IGVsc2Uge1xuXHRtb2R1bGUuZXhwb3J0cyA9IHVuZGVmaW5lZDtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9ldmVudHNvdXJjZScsIEV2ZW50U291cmNlUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFFdmVudFNvdXJjZURyaXZlcjtcbn07XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnZXZlbnRzb3VyY2UnO1xuRXZlbnRTb3VyY2VUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci9ldmVudHNvdXJjZVwiOjI5LFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSHRtbGZpbGVSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvaHRtbGZpbGUnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgO1xuXG5mdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgWEhSTG9jYWxPYmplY3QpO1xufVxuXG5pbmhlcml0cyhIdG1sRmlsZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuSHRtbEZpbGVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgcmV0dXJuIEh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW47XG59O1xuXG5IdG1sRmlsZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2h0bWxmaWxlJztcbkh0bWxGaWxlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxGaWxlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvaHRtbGZpbGVcIjozMCxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDIyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JrIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZnJvbSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXG4vLyBjcm9zcyBkb21haW4gaWZyYW1lIHVzaW5nIHBvc3RNZXNzYWdlKCkuIEluIElFIGl0IHdhcyBpbXBsZW1lbnRlZFxuLy8gZnJvbSBJRSA4KywgYnV0IG9mIGNvdXJzZSwgSUUgZ290IHNvbWUgZGV0YWlscyB3cm9uZzpcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4vLyAgICBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvaWZyYW1lJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gIGlmICghSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5vcmlnaW4gPSB1cmxVdGlscy5nZXRPcmlnaW4oYmFzZVVybCk7XG4gIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMud2luZG93SWQgPSByYW5kb20uc3RyaW5nKDgpO1xuXG4gIHZhciBpZnJhbWVVcmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaWZyYW1lLmh0bWwnKSArICcjJyArIHRoaXMud2luZG93SWQ7XG4gIGRlYnVnKHRyYW5zcG9ydCwgdHJhbnNVcmwsIGlmcmFtZVVybCk7XG5cbiAgdGhpcy5pZnJhbWVPYmogPSBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWUoaWZyYW1lVXJsLCBmdW5jdGlvbihyKSB7XG4gICAgZGVidWcoJ2VyciBjYWxsYmFjaycpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcblxuICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG59XG5cbmluaGVyaXRzKElmcmFtZVRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgZXZlbnRVdGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLl9tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XG4gICAgZGVidWcoJ25vdCBzYW1lIG9yaWdpbicsIGUub3JpZ2luLCB0aGlzLm9yaWdpbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSB0aGlzLndpbmRvd0lkKSB7XG4gICAgZGVidWcoJ21pc21hdGNoZWQgd2luZG93IGlkJywgaWZyYW1lTWVzc2FnZS53aW5kb3dJZCwgdGhpcy53aW5kb3dJZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgY2FzZSAncyc6XG4gICAgdGhpcy5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XG4gICAgdGhpcy5wb3N0TWVzc2FnZSgncycsIEpTT04zLnN0cmluZ2lmeShbXG4gICAgICB2ZXJzaW9uXG4gICAgLCB0aGlzLnRyYW5zcG9ydFxuICAgICwgdGhpcy50cmFuc1VybFxuICAgICwgdGhpcy5iYXNlVXJsXG4gICAgXSkpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0JzpcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjJzpcbiAgICB2YXIgY2RhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGNkYXRhID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgY2RhdGFbMF0sIGNkYXRhWzFdKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gIGRlYnVnKCdwb3N0TWVzc2FnZScsIHR5cGUsIGRhdGEpO1xuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04zLnN0cmluZ2lmeSh7XG4gICAgd2luZG93SWQ6IHRoaXMud2luZG93SWRcbiAgLCB0eXBlOiB0eXBlXG4gICwgZGF0YTogZGF0YSB8fCAnJ1xuICB9KSwgdGhpcy5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZSc7XG5JZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi91dGlscy91cmxcIjo1MixcIi4uL3ZlcnNpb25cIjo1MyxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1NyxcImpzb24zXCI6NTh9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4vLyBkb21haW4gaGFjayAtIEpTT05QLiBUaGlzIHRyYW5zcG9ydCBpcyBxdWl0ZSBpbmVmZmljaWVudCAtIG9uZVxuLy8gbWVzc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXG4gICwgSnNvbnBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvanNvbnAnKVxuICAsIGpzb25wU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXIvanNvbnAnKVxuICA7XG5cbmZ1bmN0aW9uIEpzb25QVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcbn1cblxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xuSnNvblBUcmFuc3BvcnQucm91bmRUcmlwcyA9IDE7XG5Kc29uUFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvblBUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vbGliL3NlbmRlci1yZWNlaXZlclwiOjI4LFwiLi9yZWNlaXZlci9qc29ucFwiOjMxLFwiLi9zZW5kZXIvanNvbnBcIjozMyxcImluaGVyaXRzXCI6NTd9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9zZW5kZXItcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YWpheC1iYXNlZCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcbiAgICB2YXIgb3B0ID0ge307XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6ICd0ZXh0L3BsYWluJ307XG4gICAgfVxuICAgIHZhciBhamF4VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh1cmwsICcveGhyX3NlbmQnKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XG4gICAgeG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwICYmIHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICB4by5jbG9zZSgpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIEFqYXhCYXNlZFRyYW5zcG9ydCh0cmFuc1VybCwgdXJsU3VmZml4LCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCB1cmxTdWZmaXgsIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCksIFJlY2VpdmVyLCBBamF4T2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoQWpheEJhc2VkVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQWpheEJhc2VkVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL3NlbmRlci1yZWNlaXZlclwiOjI4LFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTd9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpidWZmZXJlZC1zZW5kZXInKTtcbn1cblxuZnVuY3Rpb24gQnVmZmVyZWRTZW5kZXIodXJsLCBzZW5kZXIpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgdGhpcy51cmwgPSB1cmw7XG59XG5cbmluaGVyaXRzKEJ1ZmZlcmVkU2VuZGVyLCBFdmVudEVtaXR0ZXIpO1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5zZW5kQnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gIGlmICghdGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFNjaGVkdWxlKCk7XG4gIH1cbn07XG5cbi8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcbi8vIG5ldyBtZXNzYWdlIGlzIGJlaW5nIHNlbmQuIElmIHRoZSBzZW5kaW5nIGNvbm5lY3Rpb24gd2FzIHN0YXJ0ZWRcbi8vIGJlZm9yZSByZWNlaXZpbmcgb25lLCBpdCBpcyBwb3NzaWJsZSB0byBzYXR1cmF0ZSB0aGUgbmV0d29yayBhbmRcbi8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcbi8vIHNlbmRpbmcgbWVzc2FnZXMgYnkgc29tZSBzbWFsbCB0aW1lLCBpbiBvcmRlciB0byBsZXQgcmVjZWl2aW5nXG4vLyBjb25uZWN0aW9uIGJlIHN0YXJ0ZWQgYmVmb3JlaGFuZC4gVGhpcyBpcyBvbmx5IGEgaGFsZm1lYXN1cmUgYW5kXG4vLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXG4vLyBzdGFibGUgb24gc2xvdyBuZXR3b3Jrcy5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGVXYWl0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGVXYWl0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRyZWY7XG4gIHRoaXMuc2VuZFN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnc2VuZFN0b3AnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gIH07XG4gIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgc2VsZi5zZW5kU2NoZWR1bGUoKTtcbiAgfSwgMjUpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlJywgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHBheWxvYWQgPSAnWycgKyB0aGlzLnNlbmRCdWZmZXIuam9pbignLCcpICsgJ10nO1xuICAgIHRoaXMuc2VuZFN0b3AgPSB0aGlzLnNlbmRlcih0aGlzLnVybCwgcGF5bG9hZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGVyci5jb2RlIHx8IDEwMDYsICdTZW5kaW5nIGVycm9yOiAnICsgZXJyKTtcbiAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZW5kU2NoZWR1bGVXYWl0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIH1cbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAodGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFN0b3AoKTtcbiAgICB0aGlzLnNlbmRTdG9wID0gbnVsbDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCdWZmZXJlZFNlbmRlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2lmcmFtZScpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cbiAgZnVuY3Rpb24gSWZyYW1lV3JhcFRyYW5zcG9ydCh0cmFuc1VybCwgYmFzZVVybCkge1xuICAgIElmcmFtZVRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0cmFuc1VybCwgYmFzZVVybCk7XG4gIH1cblxuICBpbmhlcml0cyhJZnJhbWVXcmFwVHJhbnNwb3J0LCBJZnJhbWVUcmFuc3BvcnQpO1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKHVybCwgaW5mbykge1xuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlmcmFtZUluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoe30sIGluZm8pO1xuICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XG4gICAgcmV0dXJuIHRyYW5zcG9ydC5lbmFibGVkKGlmcmFtZUluZm8pICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG4gIH07XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS0nICsgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZmFjYWRlVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIHJldHVybiBJZnJhbWVXcmFwVHJhbnNwb3J0O1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvb2JqZWN0XCI6NDksXCIuLi9pZnJhbWVcIjoyMixcImluaGVyaXRzXCI6NTd9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpwb2xsaW5nJyk7XG59XG5cbmZ1bmN0aW9uIFBvbGxpbmcoUmVjZWl2ZXIsIHJlY2VpdmVVcmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcocmVjZWl2ZVVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLlJlY2VpdmVyID0gUmVjZWl2ZXI7XG4gIHRoaXMucmVjZWl2ZVVybCA9IHJlY2VpdmVVcmw7XG4gIHRoaXMuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XG4gIHRoaXMuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbn1cblxuaW5oZXJpdHMoUG9sbGluZywgRXZlbnRFbWl0dGVyKTtcblxuUG9sbGluZy5wcm90b3R5cGUuX3NjaGVkdWxlUmVjZWl2ZXIgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19zY2hlZHVsZVJlY2VpdmVyJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHBvbGwgPSB0aGlzLnBvbGwgPSBuZXcgdGhpcy5SZWNlaXZlcih0aGlzLnJlY2VpdmVVcmwsIHRoaXMuQWpheE9iamVjdCk7XG5cbiAgcG9sbC5vbignbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcblxuICBwb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ2Nsb3NlJywgY29kZSwgcmVhc29uLCBzZWxmLnBvbGxJc0Nsb3NpbmcpO1xuICAgIHNlbGYucG9sbCA9IHBvbGwgPSBudWxsO1xuXG4gICAgaWYgKCFzZWxmLnBvbGxJc0Nsb3NpbmcpIHtcbiAgICAgIGlmIChyZWFzb24gPT09ICduZXR3b3JrJykge1xuICAgICAgICBzZWxmLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgY29kZSB8fCAxMDA2LCByZWFzb24pO1xuICAgICAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5wb2xsSXNDbG9zaW5nID0gdHJ1ZTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEJ1ZmZlcmVkU2VuZGVyID0gcmVxdWlyZSgnLi9idWZmZXJlZC1zZW5kZXInKVxuICAsIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIFNlbmRlclJlY2VpdmVyKHRyYW5zVXJsLCB1cmxTdWZmaXgsIHNlbmRlckZ1bmMsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIHZhciBwb2xsVXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgdXJsU3VmZml4KTtcbiAgZGVidWcocG9sbFVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgQnVmZmVyZWRTZW5kZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgc2VuZGVyRnVuYyk7XG5cbiAgdGhpcy5wb2xsID0gbmV3IFBvbGxpbmcoUmVjZWl2ZXIsIHBvbGxVcmwsIEFqYXhPYmplY3QpO1xuICB0aGlzLnBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygncG9sbCBtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcbiAgdGhpcy5wb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ3BvbGwgY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYucG9sbCA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoU2VuZGVyUmVjZWl2ZXIsIEJ1ZmZlcmVkU2VuZGVyKTtcblxuU2VuZGVyUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIEJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5jbG9zZS5jYWxsKHRoaXMpO1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICAgIHRoaXMucG9sbCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi8uLi91dGlscy91cmxcIjo1MixcIi4vYnVmZmVyZWQtc2VuZGVyXCI6MjUsXCIuL3BvbGxpbmdcIjoyNyxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6ZXZlbnRzb3VyY2UnKTtcbn1cblxuZnVuY3Rpb24gRXZlbnRTb3VyY2VSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZXMgPSB0aGlzLmVzID0gbmV3IEV2ZW50U291cmNlRHJpdmVyKHVybCk7XG4gIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZGVjb2RlVVJJKGUuZGF0YSkpO1xuICB9O1xuICBlcy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvcicsIGVzLnJlYWR5U3RhdGUsIGUpO1xuICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cbiAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgIHZhciByZWFzb24gPSAoZXMucmVhZHlTdGF0ZSAhPT0gMiA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgc2VsZi5fY2xvc2UocmVhc29uKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5fY2xvc2UoJ3VzZXInKTtcbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIHZhciBlcyA9IHRoaXMuZXM7XG4gIGlmIChlcykge1xuICAgIGVzLm9ubWVzc2FnZSA9IGVzLm9uZXJyb3IgPSBudWxsO1xuICAgIGVzLmNsb3NlKCk7XG4gICAgdGhpcy5lcyA9IG51bGw7XG4gIH1cbn07XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIC8vIFNhZmFyaSBhbmQgY2hyb21lIDwgMTUgY3Jhc2ggaWYgd2UgY2xvc2Ugd2luZG93IGJlZm9yZVxuICAvLyB3YWl0aW5nIGZvciBFUyBjbGVhbnVwLiBTZWU6XG4gIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0sIDIwMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImV2ZW50c291cmNlXCI6MTgsXCJpbmhlcml0c1wiOjU3fV0sMzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpodG1sZmlsZScpO1xufVxuXG5mdW5jdGlvbiBIdG1sZmlsZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZnJhbWVVdGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGRlY29kZVVSSUNvbXBvbmVudChpZnJhbWVVdGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGRlYnVnKCd1c2luZyBodG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkKTtcbiAgdmFyIGNvbnN0cnVjdEZ1bmMgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA/XG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0YXJ0Jyk7XG4gICAgICBzZWxmLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICB9XG4gICwgbWVzc2FnZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgIH1cbiAgLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdG9wJyk7XG4gICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICBzZWxmLl9jbG9zZSgnbmV0d29yaycpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5pZnJhbWVPYmogPSBjb25zdHJ1Y3RGdW5jKHVybCwgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKCdwZXJtYW5lbnQnKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gZmFsc2U7XG5cbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKGF4byBpbiBnbG9iYWwpIHtcbiAgdHJ5IHtcbiAgICBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9ICEhbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICB9XG59XG5cbkh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCA9IEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkIHx8IGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbGZpbGVSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvaWZyYW1lXCI6NDcsXCIuLi8uLi91dGlscy9yYW5kb21cIjo1MCxcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6anNvbnAnKTtcbn1cblxuZnVuY3Rpb24gSnNvbnBSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcblxuICAvLyBGYWxsYmFjayBtb3N0bHkgZm9yIEtvbnF1ZXJvciAtIHN0dXBpZCB0aW1lciwgMzUgc2Vjb25kcyBzaGFsbCBiZSBwbGVudHkuXG4gIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5ICh0aW1lb3V0KScpKTtcbiAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmIChnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0pIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdKU09OUCB1c2VyIGFib3J0ZWQgcmVhZCcpO1xuICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICB0aGlzLl9hYm9ydChlcnIpO1xuICB9XG59O1xuXG5Kc29ucFJlY2VpdmVyLnRpbWVvdXQgPSAzNTAwMDtcbkpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0ID0gMTAwMDtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICBkZWJ1ZygnX2NhbGxiYWNrJywgZGF0YSk7XG4gIHRoaXMuX2NsZWFudXAoKTtcblxuICBpZiAodGhpcy5hYm9ydGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ25ldHdvcmsnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKGVycikge1xuICBkZWJ1ZygnX2Fib3J0JywgZXJyKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIGVyci5jb2RlLCBlcnIubWVzc2FnZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgaWYgKHRoaXMuc2NyaXB0Mikge1xuICAgIHRoaXMuc2NyaXB0Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0Mik7XG4gICAgdGhpcy5zY3JpcHQyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgeW91IGNhbid0IHJlYWxseSBhYm9ydCBzY3JpcHQgbG9hZGluZyBvZlxuICAgIC8vIHRoZSBzY3JpcHQuXG4gICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPVxuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NyaXB0RXJyb3InKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5lcnJvclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lcnJvclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYubG9hZGVkT2theSkge1xuICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpJykpO1xuICAgIH1cbiAgfSwgSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uKHVybCkge1xuICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXG5cbiAgc2NyaXB0LmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICBzY3JpcHQub25lcnJvciA9IHRoaXMuX3NjcmlwdEVycm9yLmJpbmQodGhpcyk7XG4gIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZCknKSk7XG4gIH07XG5cbiAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb25yZWFkeXN0YXRlY2hhbmdlIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxuICAvLyBVc2UgbG9hZGVkT2theSB0byBkZXRlcm1pbmUgaWYgYWN0dWFsbHkgZXJyb3JlZFxuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIHNjcmlwdC5yZWFkeVN0YXRlKTtcbiAgICBpZiAoL2xvYWRlZHxjbG9zZWQvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5odG1sRm9yICYmIHNjcmlwdC5vbmNsaWNrKSB7XG4gICAgICAgIHNlbGYubG9hZGVkT2theSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW4gSUUsIGFjdHVhbGx5IGV4ZWN1dGUgdGhlIHNjcmlwdC5cbiAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbnJlYWR5c3RhdGVjaGFuZ2UpJykpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgLy8gSUU6IGV2ZW50L2h0bWxGb3Ivb25jbGljayB0cmljay5cbiAgLy8gT25lIGNhbid0IHJlbHkgb24gcHJvcGVyIG9yZGVyIGZvciBvbnJlYWR5c3RhdGVjaGFuZ2UuIEluIG9yZGVyIHRvXG4gIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcbiAgLy8gc2NyaXB0IGNvZGUgd2lsbCBiZSBpbnN0YWxsZWQgYXMgJ29uY2xpY2snIGhhbmRsZXIgZm9yIHRoZVxuICAvLyBzY3JpcHQgb2JqZWN0LiBMYXRlciwgb25yZWFkeXN0YXRlY2hhbmdlLCBtYW51YWxseSBleGVjdXRlIHRoaXNcbiAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcbiAgLy8gc2V0LiBGb3IgcmVmZXJlbmNlIHNlZTpcbiAgLy8gICBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcbiAgLy8gICBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvRHluYW1pY19TY3JpcHRfRXhlY3V0aW9uX09yZGVyXG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jID09PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAvLyBBY2NvcmRpbmcgdG8gbW96aWxsYSBkb2NzLCBpbiByZWNlbnQgYnJvd3NlcnMgc2NyaXB0LmFzeW5jIGRlZmF1bHRzXG4gICAgLy8gdG8gJ3RydWUnLCBzbyB3ZSBtYXkgdXNlIGl0IHRvIGRldGVjdCBhIGdvb2QgYnJvd3NlcjpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9IVE1ML0VsZW1lbnQvc2NyaXB0XG4gICAgaWYgKCFicm93c2VyLmlzT3BlcmEoKSkge1xuICAgICAgLy8gTmFpdmVseSBhc3N1bWUgd2UncmUgaW4gSUVcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xuICAgICAgICBzY3JpcHQuZXZlbnQgPSAnb25jbGljayc7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9wZXJhLCBzZWNvbmQgc3luYyBzY3JpcHQgaGFja1xuICAgICAgc2NyaXB0MiA9IHRoaXMuc2NyaXB0MiA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiICsgc2NyaXB0LmlkICsgXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcbiAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoZWFkID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgaWYgKHNjcmlwdDIpIHtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQyLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25wUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOnhocicpO1xufVxuXG5mdW5jdGlvbiBYaHJSZWNlaXZlcih1cmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmJ1ZmZlclBvc2l0aW9uID0gMDtcblxuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xuICB0aGlzLnhvLm9uKCdjaHVuaycsIHRoaXMuX2NodW5rSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLl9jaHVua0hhbmRsZXIoc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLnhvID0gbnVsbDtcbiAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcbiAgICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhoclJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICBkZWJ1ZygnX2NodW5rSGFuZGxlcicsIHN0YXR1cyk7XG4gIGlmIChzdGF0dXMgIT09IDIwMCB8fCAhdGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGlkeCA9IC0xOyA7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xuICAgIHZhciBidWYgPSB0ZXh0LnNsaWNlKHRoaXMuYnVmZmVyUG9zaXRpb24pO1xuICAgIGlkeCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcbiAgICBpZiAobXNnKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIH1cbiAgfVxufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAodGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ3VzZXInKTtcbiAgICB0aGlzLnhvID0gbnVsbDtcbiAgfVxuICB0aGlzLl9jbGVhbnVwKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjpqc29ucCcpO1xufVxuXG52YXIgZm9ybSwgYXJlYTtcblxuZnVuY3Rpb24gY3JlYXRlSWZyYW1lKGlkKSB7XG4gIGRlYnVnKCdjcmVhdGVJZnJhbWUnLCBpZCk7XG4gIHRyeSB7XG4gICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgcmV0dXJuIGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8aWZyYW1lIG5hbWU9XCInICsgaWQgKyAnXCI+Jyk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5uYW1lID0gaWQ7XG4gICAgcmV0dXJuIGlmcmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtKCkge1xuICBkZWJ1ZygnY3JlYXRlRm9ybScpO1xuICBmb3JtID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICBmb3JtLmFjY2VwdENoYXJzZXQgPSAnVVRGLTgnO1xuXG4gIGFyZWEgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgYXJlYS5uYW1lID0gJ2QnO1xuICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuXG4gIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgZGVidWcodXJsLCBwYXlsb2FkKTtcbiAgaWYgKCFmb3JtKSB7XG4gICAgY3JlYXRlRm9ybSgpO1xuICB9XG4gIHZhciBpZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIGZvcm0udGFyZ2V0ID0gaWQ7XG4gIGZvcm0uYWN0aW9uID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsVXRpbHMuYWRkUGF0aCh1cmwsICcvanNvbnBfc2VuZCcpLCAnaT0nICsgaWQpO1xuXG4gIHZhciBpZnJhbWUgPSBjcmVhdGVJZnJhbWUoaWQpO1xuICBpZnJhbWUuaWQgPSBpZDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcblxuICB0cnkge1xuICAgIGFyZWEudmFsdWUgPSBwYXlsb2FkO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gc2VyaW91c2x5IGJyb2tlbiBicm93c2VycyBnZXQgaGVyZVxuICB9XG4gIGZvcm0uc3VibWl0KCk7XG5cbiAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uKGVycikge1xuICAgIGRlYnVnKCdjb21wbGV0ZWQnLCBpZCwgZXJyKTtcbiAgICBpZiAoIWlmcmFtZS5vbmVycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgIC8vIE9wZXJhIG1pbmkgZG9lc24ndCBsaWtlIGlmIHdlIEdDIGlmcmFtZVxuICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFuaW5nIHVwJywgaWQpO1xuICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgfSwgNTAwKTtcbiAgICBhcmVhLnZhbHVlID0gJyc7XG4gICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBpZiB0aGUgaWZyYW1lIHN1Y2NlZWRlZCBvclxuICAgIC8vIGZhaWxlZCB0byBzdWJtaXQgb3VyIGZvcm0uXG4gICAgY2FsbGJhY2soZXJyKTtcbiAgfTtcbiAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmxvYWQnLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGlkLCBpZnJhbWUucmVhZHlTdGF0ZSwgZSk7XG4gICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICBjb21wbGV0ZWQoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnYWJvcnRlZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTV9XSwzNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjp4ZHInKTtcbn1cblxuLy8gUmVmZXJlbmNlczpcbi8vICAgaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzLzEwMC1saW5lLWFqYXgtd3JhcHBlclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxuXG5mdW5jdGlvbiBYRFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKCdfc3RhcnQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGRyID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpO1xuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnRpbWVvdXQnKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICB9O1xuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2xvYWQnKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH07XG4gIHRoaXMueGRyID0geGRyO1xuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIC8vIEZhaWxzIHdpdGggQWNjZXNzRGVuaWVkIGlmIHBvcnQgbnVtYmVyIGlzIGJvZ3VzXG4gICAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy54ZHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICB9XG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHRoaXMuX2Vycm9yKCk7XG4gIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcbiAgaWYgKCF0aGlzLnhkcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBldmVudFV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgdGhpcy54ZHIub250aW1lb3V0ID0gdGhpcy54ZHIub25lcnJvciA9IHRoaXMueGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLnhkci5vbmxvYWQgPSBudWxsO1xuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbi8vIElFIDgvOSBpZiB0aGUgcmVxdWVzdCB0YXJnZXQgdXNlcyB0aGUgc2FtZSBzY2hlbWUgLSAjNzlcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhEUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjQ0LFwiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSQ29yc09iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG59XG5cbmluaGVyaXRzKFhIUkNvcnNPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkNvcnNPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkICYmIFhockRyaXZlci5zdXBwb3J0c0NPUlM7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSQ29yc09iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gIDtcblxuZnVuY3Rpb24gWEhSRmFrZSgvKiBtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyAqLykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMudG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCAne30nKTtcbiAgfSwgWEhSRmFrZS50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoWEhSRmFrZSwgRXZlbnRFbWl0dGVyKTtcblxuWEhSRmFrZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudG8pO1xufTtcblxuWEhSRmFrZS50aW1lb3V0ID0gMjAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJGYWtlO1xuXG59LHtcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSTG9jYWxPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQgLyosIG9wdHMgKi8pIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIHtcbiAgICBub0NyZWRlbnRpYWxzOiB0cnVlXG4gIH0pO1xufVxuXG5pbmhlcml0cyhYSFJMb2NhbE9iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSTG9jYWxPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvY2FsT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjoxNyxcImluaGVyaXRzXCI6NTd9XSwzODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIFdlYnNvY2tldERyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVyL3dlYnNvY2tldCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp3ZWJzb2NrZXQnKTtcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KHRyYW5zVXJsLCBpZ25vcmUsIG9wdGlvbnMpIHtcbiAgaWYgKCFXZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2NvbnN0cnVjdG9yJywgdHJhbnNVcmwpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsICcvd2Vic29ja2V0Jyk7XG4gIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICB1cmwgPSAnd3NzJyArIHVybC5zbGljZSg1KTtcbiAgfSBlbHNlIHtcbiAgICB1cmwgPSAnd3MnICsgdXJsLnNsaWNlKDQpO1xuICB9XG4gIHRoaXMudXJsID0gdXJsO1xuXG4gIHRoaXMud3MgPSBuZXcgV2Vic29ja2V0RHJpdmVyKHRoaXMudXJsLCBbXSwgb3B0aW9ucyk7XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlIGV2ZW50JywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICB9O1xuICAvLyBGaXJlZm94IGhhcyBhbiBpbnRlcmVzdGluZyBidWcuIElmIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgLy8gY3JlYXRlZCBhZnRlciBvbnVubG9hZCwgaXQgc3RheXMgYWxpdmUgZXZlbiB3aGVuIHVzZXJcbiAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgLy8gbGV0J3Mgbm90IG9wZW4gdGhlIHdzIGNvbm5lY3Rpb24gYXQgYWxsLiBTZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NranMvc29ja2pzLWNsaWVudC9pc3N1ZXMvMjhcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQnKTtcbiAgICBzZWxmLndzLmNsb3NlKCk7XG4gIH0pO1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Nsb3NlIGV2ZW50JywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvciBldmVudCcsIGUpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xufVxuXG5pbmhlcml0cyhXZWJTb2NrZXRUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIG1zZyA9ICdbJyArIGRhdGEgKyAnXSc7XG4gIGRlYnVnKCdzZW5kJywgbXNnKTtcbiAgdGhpcy53cy5zZW5kKG1zZyk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh3cykge1xuICAgIHdzLmNsb3NlKCk7XG4gIH1cbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIGlmICh3cykge1xuICAgIHdzLm9ubWVzc2FnZSA9IHdzLm9uY2xvc2UgPSB3cy5vbmVycm9yID0gbnVsbDtcbiAgfVxuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMud3MgPSBudWxsO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2VuYWJsZWQnKTtcbiAgcmV0dXJuICEhV2Vic29ja2V0RHJpdmVyO1xufTtcbldlYlNvY2tldFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXG4vLyBub3QgdmVyeSBzdGFibGUgb3ZlciBTU0wuIE1vc3QgbGlrZWx5IGEgd3MgY29ubmVjdGlvbiByZXF1aXJlcyBhXG4vLyBzZXBhcmF0ZSBTU0wgY29ubmVjdGlvbiwgaW4gd2hpY2ggY2FzZSAyIHJvdW5kIHRyaXBzIGFyZSBhblxuLy8gYWJzb2x1dGUgbWludW11bS5cbldlYlNvY2tldFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuLi91dGlscy9ldmVudFwiOjQ2LFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2RyaXZlci93ZWJzb2NrZXRcIjoxOSxcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG5mdW5jdGlvbiBYZHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCIuL3hkci1zdHJlYW1pbmdcIjo0MCxcImluaGVyaXRzXCI6NTd9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbi8vIEFjY29yZGluZyB0bzpcbi8vICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxNTA3L2RldGVjdC1icm93c2VyLXN1cHBvcnQtZm9yLWNyb3NzLWRvbWFpbi14bWxodHRwcmVxdWVzdHNcbi8vICAgaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG5cbmZ1bmN0aW9uIFhkclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5jb29raWVfbmVlZGVkIHx8IGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gWERST2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lU2NoZW1lO1xufTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXN0cmVhbWluZyc7XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGRyXCI6MzQsXCJpbmhlcml0c1wiOjU3fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gIDtcblxuZnVuY3Rpb24gWGhyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG5YaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKVxuICA7XG5cbmZ1bmN0aW9uIFhoclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXG4gIC8vIEJ1dCBpdCBtaWdodCBiZSBhYmxlIHRvICM5MlxuICBpZiAoYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG4vLyBPbmx5IHJlcXVpcmUgYm9keSB3aGVuIHVzZWQgaW4gYSBicm93c2VyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIveGhyXCI6MzIsXCIuL3NlbmRlci94aHItY29yc1wiOjM1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCJpbmhlcml0c1wiOjU3fV0sNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09wZXJhOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL29wZXJhL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuLCBpc0tvbnF1ZXJvcjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9rb25xdWVyb3IvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4gIC8vICMxODcgd3JhcCBkb2N1bWVudC5kb21haW4gaW4gdHJ5L2NhdGNoIGJlY2F1c2Ugb2YgV1A4IGZyb20gZmlsZTovLy9cbiwgaGFzRG9tYWluOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbm9uLWJyb3dzZXIgY2xpZW50IGFsd2F5cyBoYXMgYSBkb21haW5cbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudC5kb21haW47XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se31dLDQ1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKTtcblxuLy8gU29tZSBleHRyYSBjaGFyYWN0ZXJzIHRoYXQgQ2hyb21lIGdldHMgd3JvbmcsIGFuZCBzdWJzdGl0dXRlcyB3aXRoXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgZXh0cmFFc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZ1xuICAsIGV4dHJhTG9va3VwO1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbExvb2t1cCA9IGZ1bmN0aW9uKGVzY2FwYWJsZSkge1xuICB2YXIgaTtcbiAgdmFyIHVucm9sbGVkID0ge307XG4gIHZhciBjID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCA2NTUzNjsgaSsrKSB7XG4gICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gIH1cbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICB1bnJvbGxlZFsgYSBdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbiAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBxdW90ZTogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT04zLnN0cmluZ2lmeShzdHJpbmcpO1xuXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgIGV4dHJhRXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKCFleHRyYUVzY2FwYWJsZS50ZXN0KHF1b3RlZCkpIHtcbiAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFleHRyYUxvb2t1cCkge1xuICAgICAgZXh0cmFMb29rdXAgPSB1bnJvbGxMb29rdXAoZXh0cmFFc2NhcGFibGUpO1xuICAgIH1cblxuICAgIHJldHVybiBxdW90ZWQucmVwbGFjZShleHRyYUVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgcmV0dXJuIGV4dHJhTG9va3VwW2FdO1xuICAgIH0pO1xuICB9XG59O1xuXG59LHtcImpzb24zXCI6NTh9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByYW5kb20gPSByZXF1aXJlKCcuL3JhbmRvbScpO1xuXG52YXIgb25VbmxvYWQgPSB7fVxuICAsIGFmdGVyVW5sb2FkID0gZmFsc2VcbiAgICAvLyBkZXRlY3QgZ29vZ2xlIGNocm9tZSBwYWNrYWdlZCBhcHBzIGJlY2F1c2UgdGhleSBkb24ndCBhbGxvdyB0aGUgJ3VubG9hZCcgZXZlbnRcbiAgLCBpc0Nocm9tZVBhY2thZ2VkQXBwID0gZ2xvYmFsLmNocm9tZSAmJiBnbG9iYWwuY2hyb21lLmFwcCAmJiBnbG9iYWwuY2hyb21lLmFwcC5ydW50aW1lXG4gIDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGF0dGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgICAvLyBJRSBxdWlya3MuXG4gICAgICAvLyBBY2NvcmRpbmcgdG86IGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcbiAgICAgIC8vIHRoZSBtZXNzYWdlIGdldHMgZGVsaXZlcmVkIG9ubHkgdG8gJ2RvY3VtZW50Jywgbm90ICd3aW5kb3cnLlxuICAgICAgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgLy8gSSBnZXQgJ3dpbmRvdycgZm9yIGllOC5cbiAgICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCBkZXRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5kZXRhY2hFdmVudCkge1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgZ2xvYmFsLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIHVubG9hZEFkZDogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBpZiAoaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHJlZiA9IHJhbmRvbS5zdHJpbmcoOCk7XG4gICAgb25VbmxvYWRbcmVmXSA9IGxpc3RlbmVyO1xuICAgIGlmIChhZnRlclVubG9hZCkge1xuICAgICAgc2V0VGltZW91dCh0aGlzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MsIDApO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xuICB9XG5cbiwgdW5sb2FkRGVsOiBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAocmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cblxuLCB0cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciByZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIG9uVW5sb2FkW3JlZl0oKTtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHVubG9hZFRyaWdnZXJlZCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWZ0ZXJVbmxvYWQgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzKCk7XG59O1xuXG4vLyAndW5sb2FkJyBhbG9uZSBpcyBub3QgcmVsaWFibGUgaW4gb3BlcmEgd2l0aGluIGFuIGlmcmFtZSwgYnV0IHdlXG4vLyBjYW4ndCB1c2UgYGJlZm9yZXVubG9hZGAgYXMgSUUgZmlyZXMgaXQgb24gamF2YXNjcmlwdDogbGlua3MuXG5pZiAoIWlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgbW9kdWxlLmV4cG9ydHMuYXR0YWNoRXZlbnQoJ3VubG9hZCcsIHVubG9hZFRyaWdnZXJlZCk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vcmFuZG9tXCI6NTB9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOmlmcmFtZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV1ByZWZpeDogJ19qcCdcbiwgY3VycmVudFdpbmRvd0lkOiBudWxsXG5cbiwgcG9sbHV0ZUdsb2JhbE5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEobW9kdWxlLmV4cG9ydHMuV1ByZWZpeCBpbiBnbG9iYWwpKSB7XG4gICAgICBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSB7fTtcbiAgICB9XG4gIH1cblxuLCBwb3N0TWVzc2FnZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIGlmIChnbG9iYWwucGFyZW50ICE9PSBnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5wYXJlbnQucG9zdE1lc3NhZ2UoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICAgICAgd2luZG93SWQ6IG1vZHVsZS5leHBvcnRzLmN1cnJlbnRXaW5kb3dJZFxuICAgICAgLCB0eXBlOiB0eXBlXG4gICAgICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgICAgIH0pLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4sIGNyZWF0ZUlmcmFtZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3VuYXR0YWNoJyk7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAvLyBFeHBsb3JlciBoYWQgcHJvYmxlbXMgd2l0aCB0aGF0LlxuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgbWFrZXMgY2hyb21lIGZpcmUgb25iZWZvcmV1bmxvYWQgZXZlbnRcbiAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgIC8vIG9udW5sb2FkLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgZXJyKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICBkZWJ1ZygncG9zdCcsIG1zZywgb3JpZ2luKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfSwgMCk7XG4gICAgfTtcblxuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ29ubG9hZCcpO1xuICAgICAgLy8gYG9ubG9hZGAgaXMgdHJpZ2dlcmVkIGJlZm9yZSBzY3JpcHRzIG9uIHRoZSBpZnJhbWUgYXJlXG4gICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9uZXJyb3IoJ29ubG9hZCB0aW1lb3V0Jyk7XG4gICAgICB9LCAyMDAwKTtcbiAgICB9O1xuICAgIGdsb2JhbC5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxuXG4vKiBlc2xpbnQgbm8tdW5kZWY6IFwib2ZmXCIsIG5ldy1jYXA6IFwib2ZmXCIgKi9cbiwgY3JlYXRlSHRtbGZpbGU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuICAgIHZhciBkb2MgPSBuZXcgZ2xvYmFsW2F4b10oJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgaWZyYW1lO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgQ29sbGVjdEdhcmJhZ2UoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCByKTtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKHIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBnbG9iYWwuZG9jdW1lbnQuZG9tYWluICsgJ1wiOycgK1xuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgZG9jLnBhcmVudFdpbmRvd1ttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVVcmw7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSBmYWxzZTtcbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gIC8vIGh1Z2UgZGVsYXksIG9yIG5vdCBhdCBhbGwuXG4gIG1vZHVsZS5leHBvcnRzLmlmcmFtZUVuYWJsZWQgPSAodHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyB8fFxuICAgIHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdvYmplY3QnKSAmJiAoIWJyb3dzZXIuaXNLb25xdWVyb3IoKSk7XG59XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vYnJvd3NlclwiOjQ0LFwiLi9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImpzb24zXCI6NTh9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2dPYmplY3QgPSB7fTtcblsnbG9nJywgJ2RlYnVnJywgJ3dhcm4nXS5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICB2YXIgbGV2ZWxFeGlzdHM7XG5cbiAgdHJ5IHtcbiAgICBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XG4gIH0gY2F0Y2goZSkge1xuICAgIC8vIGRvIG5vdGhpbmdcbiAgfVxuXG4gIGxvZ09iamVjdFtsZXZlbF0gPSBsZXZlbEV4aXN0cyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xuICB9IDogKGxldmVsID09PSAnbG9nJyA/IGZ1bmN0aW9uICgpIHt9IDogbG9nT2JqZWN0LmxvZyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2dPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9XG5cbiwgZXh0ZW5kOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMuaXNPYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9XG59O1xuXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIGdsb2JhbCBjcnlwdG86dHJ1ZSAqL1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vLyBUaGlzIHN0cmluZyBoYXMgbGVuZ3RoIDMyLCBhIHBvd2VyIG9mIDIsIHNvIHRoZSBtb2R1bHVzIGRvZXNuJ3QgaW50cm9kdWNlIGFcbi8vIGJpYXMuXG52YXIgX3JhbmRvbVN0cmluZ0NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Jztcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzdHJpbmc6IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBtYXggPSBfcmFuZG9tU3RyaW5nQ2hhcnMubGVuZ3RoO1xuICAgIHZhciBieXRlcyA9IGNyeXB0by5yYW5kb21CeXRlcyhsZW5ndGgpO1xuICAgIHZhciByZXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXQucHVzaChfcmFuZG9tU3RyaW5nQ2hhcnMuc3Vic3RyKGJ5dGVzW2ldICUgbWF4LCAxKSk7XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG4gIH1cblxuLCBudW1iZXI6IGZ1bmN0aW9uKG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xuICB9XG5cbiwgbnVtYmVyU3RyaW5nOiBmdW5jdGlvbihtYXgpIHtcbiAgICB2YXIgdCA9ICgnJyArIChtYXggLSAxKSkubGVuZ3RoO1xuICAgIHZhciBwID0gbmV3IEFycmF5KHQgKyAxKS5qb2luKCcwJyk7XG4gICAgcmV0dXJuIChwICsgdGhpcy5udW1iZXIobWF4KSkuc2xpY2UoLXQpO1xuICB9XG59O1xuXG59LHtcImNyeXB0b1wiOjQzfV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp0cmFuc3BvcnQnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHJldHVybiB7XG4gICAgZmlsdGVyVG9FbmFibGVkOiBmdW5jdGlvbih0cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKSB7XG4gICAgICB2YXIgdHJhbnNwb3J0cyA9IHtcbiAgICAgICAgbWFpbjogW11cbiAgICAgICwgZmFjYWRlOiBbXVxuICAgICAgfTtcbiAgICAgIGlmICghdHJhbnNwb3J0c1doaXRlbGlzdCkge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW107XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0cmFuc3BvcnRzV2hpdGVsaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0ID0gW3RyYW5zcG9ydHNXaGl0ZWxpc3RdO1xuICAgICAgfVxuXG4gICAgICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24odHJhbnMpIHtcbiAgICAgICAgaWYgKCF0cmFucykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy50cmFuc3BvcnROYW1lID09PSAnd2Vic29ja2V0JyAmJiBpbmZvLndlYnNvY2tldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQgZnJvbSBzZXJ2ZXInLCAnd2Vic29ja2V0Jyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zcG9ydHNXaGl0ZWxpc3QubGVuZ3RoICYmXG4gICAgICAgICAgICB0cmFuc3BvcnRzV2hpdGVsaXN0LmluZGV4T2YodHJhbnMudHJhbnNwb3J0TmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgZGVidWcoJ25vdCBpbiB3aGl0ZWxpc3QnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMuZW5hYmxlZChpbmZvKSkge1xuICAgICAgICAgIGRlYnVnKCdlbmFibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgdHJhbnNwb3J0cy5tYWluLnB1c2godHJhbnMpO1xuICAgICAgICAgIGlmICh0cmFucy5mYWNhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydHMuZmFjYWRlLnB1c2godHJhbnMuZmFjYWRlVHJhbnNwb3J0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkJywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRyYW5zcG9ydHM7XG4gICAgfVxuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTV9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJyk7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dXJsJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRPcmlnaW46IGZ1bmN0aW9uKHVybCkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAocC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBvcnQgPSBwLnBvcnQ7XG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gKHAucHJvdG9jb2wgPT09ICdodHRwczonKSA/ICc0NDMnIDogJzgwJztcbiAgICB9XG5cbiAgICByZXR1cm4gcC5wcm90b2NvbCArICcvLycgKyBwLmhvc3RuYW1lICsgJzonICsgcG9ydDtcbiAgfVxuXG4sIGlzT3JpZ2luRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5nZXRPcmlnaW4oYSkgPT09IHRoaXMuZ2V0T3JpZ2luKGIpO1xuICAgIGRlYnVnKCdzYW1lJywgYSwgYiwgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiwgaXNTY2hlbWVFcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiAoYS5zcGxpdCgnOicpWzBdID09PSBiLnNwbGl0KCc6JylbMF0pO1xuICB9XG5cbiwgYWRkUGF0aDogZnVuY3Rpb24gKHVybCwgcGF0aCkge1xuICAgIHZhciBxcyA9IHVybC5zcGxpdCgnPycpO1xuICAgIHJldHVybiBxc1swXSArIHBhdGggKyAocXNbMV0gPyAnPycgKyBxc1sxXSA6ICcnKTtcbiAgfVxuXG4sIGFkZFF1ZXJ5OiBmdW5jdGlvbiAodXJsLCBxKSB7XG4gICAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICgnPycgKyBxKSA6ICgnJicgKyBxKSk7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwidXJsLXBhcnNlXCI6NjF9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9ICcxLjQuMCc7XG5cbn0se31dLDU0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwtP1xcZD9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cblxufSx7fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWycjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJywgJyMwMDk5RkYnLCAnIzAwQ0MwMCcsICcjMDBDQzMzJywgJyMwMENDNjYnLCAnIzAwQ0M5OScsICcjMDBDQ0NDJywgJyMwMENDRkYnLCAnIzMzMDBDQycsICcjMzMwMEZGJywgJyMzMzMzQ0MnLCAnIzMzMzNGRicsICcjMzM2NkNDJywgJyMzMzY2RkYnLCAnIzMzOTlDQycsICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJywgJyM2NjAwQ0MnLCAnIzY2MDBGRicsICcjNjYzM0NDJywgJyM2NjMzRkYnLCAnIzY2Q0MwMCcsICcjNjZDQzMzJywgJyM5OTAwQ0MnLCAnIzk5MDBGRicsICcjOTkzM0NDJywgJyM5OTMzRkYnLCAnIzk5Q0MwMCcsICcjOTlDQzMzJywgJyNDQzAwMDAnLCAnI0NDMDAzMycsICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JywgJyNDQzMzOTknLCAnI0NDMzNDQycsICcjQ0MzM0ZGJywgJyNDQzY2MDAnLCAnI0NDNjYzMycsICcjQ0M5OTAwJywgJyNDQzk5MzMnLCAnI0NDQ0MwMCcsICcjQ0NDQzMzJywgJyNGRjAwMDAnLCAnI0ZGMDAzMycsICcjRkYwMDY2JywgJyNGRjAwOTknLCAnI0ZGMDBDQycsICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJywgJyNGRjY2MDAnLCAnI0ZGNjYzMycsICcjRkY5OTAwJywgJyNGRjk5MzMnLCAnI0ZGQ0MwMCcsICcjRkZDQzMzJ107XG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcbiAgLy8gZXhwbGljaXRseVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblxuXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICAvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXG5cbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSB8fCAvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8IHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkgfHwgLy8gSXMgZmlyZWZveCA+PSB2MzE/XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxIHx8IC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLyk7XG59XG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgKyBhcmdzWzBdICsgKHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICsgJysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTsgLy8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblxuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgaWYgKG1hdGNoID09PSAnJSUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5kZXgrKztcblxuICAgIGlmIChtYXRjaCA9PT0gJyVjJykge1xuICAgICAgLy8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gbG9nKCkge1xuICB2YXIgX2NvbnNvbGU7XG5cbiAgLy8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICh0eXBlb2YgY29uc29sZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGNvbnNvbGUpKSA9PT0gJ29iamVjdCcgJiYgY29uc29sZS5sb2cgJiYgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBhcmd1bWVudHMpO1xufVxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcblxuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9IC8vIFN3YWxsb3dcbiAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblxuXG4gIGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuICAgIHIgPSBwcm9jZXNzLmVudi5ERUJVRztcbiAgfVxuXG4gIHJldHVybiByO1xufVxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcbiAgdHJ5IHtcbiAgICAvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG4gICAgLy8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG52YXIgZm9ybWF0dGVycyA9IG1vZHVsZS5leHBvcnRzLmZvcm1hdHRlcnM7XG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcbiAgfVxufTtcblxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9jb21tb25cIjo1Nn1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuICBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG4gIGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcbiAgY3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcbiAgY3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gIGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcbiAgT2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG4gIH0pO1xuICAvKipcbiAgKiBBY3RpdmUgYGRlYnVnYCBpbnN0YW5jZXMuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG4gIC8qKlxuICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gIC8qKlxuICAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAgKlxuICAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG4gIC8qKlxuICAqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2VcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG4gICogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cbiAgZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG4gICAgdmFyIGhhc2ggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcbiAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcbiAgLyoqXG4gICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gICogQHJldHVybiB7RnVuY3Rpb259XG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuICBmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcbiAgICB2YXIgcHJldlRpbWU7XG5cbiAgICBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXNhYmxlZD9cbiAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gZGVidWc7IC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cbiAgICAgIHZhciBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuICAgICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgICAgcHJldlRpbWUgPSBjdXJyO1xuICAgICAgYXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuICAgICAgICBhcmdzLnVuc2hpZnQoJyVPJyk7XG4gICAgICB9IC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cblxuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCBmdW5jdGlvbiAobWF0Y2gsIGZvcm1hdCkge1xuICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIHZhciBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpOyAvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cbiAgICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pOyAvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXG4gICAgICBjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG4gICAgICB2YXIgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG4gICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG5cbiAgICBkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG4gICAgZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcbiAgICBkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcbiAgICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG4gICAgZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgZGVidWcuZXh0ZW5kID0gZXh0ZW5kOyAvLyBEZWJ1Zy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbiAgICAvLyBkZWJ1Zy5yYXdMb2cgPSByYXdMb2c7XG4gICAgLy8gZW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblxuICAgIGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG4gICAgfVxuXG4gICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnB1c2goZGVidWcpO1xuICAgIHJldHVybiBkZWJ1ZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuICAgIHJldHVybiBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuICB9XG4gIC8qKlxuICAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAgKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgICBjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuICAgIGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG4gICAgY3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICAgIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghc3BsaXRbaV0pIHtcbiAgICAgICAgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG4gICAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgY3JlYXRlRGVidWcuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG4gICAgICBpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAgKlxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgIGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG4gIH1cbiAgLyoqXG4gICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cblxuICBmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgICBpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogQ29lcmNlIGB2YWxgLlxuICAqXG4gICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gICogQHJldHVybiB7TWl4ZWR9XG4gICogQGFwaSBwcml2YXRlXG4gICovXG5cblxuICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcbiAgcmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuXG5cbn0se1wibXNcIjo1NH1dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIERlY29kZSBhIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFVSSSBlbmNvZGVkIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChpbnB1dC5yZXBsYWNlKC9cXCsvZywgJyAnKSk7XG59XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9PyhbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgd2hpbGUgKHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSkpIHtcbiAgICB2YXIga2V5ID0gZGVjb2RlKHBhcnRbMV0pXG4gICAgICAsIHZhbHVlID0gZGVjb2RlKHBhcnRbMl0pO1xuXG4gICAgLy9cbiAgICAvLyBQcmV2ZW50IG92ZXJyaWRpbmcgb2YgZXhpc3RpbmcgcHJvcGVydGllcy4gVGhpcyBlbnN1cmVzIHRoYXQgYnVpbGQtaW5cbiAgICAvLyBtZXRob2RzIGxpa2UgYHRvU3RyaW5nYCBvciBfX3Byb3RvX18gYXJlIG5vdCBvdmVycmlkZW4gYnkgbWFsaWNpb3VzXG4gICAgLy8gcXVlcnlzdHJpbmdzLlxuICAgIC8vXG4gICAgaWYgKGtleSBpbiByZXN1bHQpIGNvbnRpbnVlO1xuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW107XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcblxufSx7fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIxO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG5cbn0se31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgcHJvdG9jb2xyZSA9IC9eKFthLXpdW2EtejAtOS4rLV0qOik/KFxcL1xcLyk/KFtcXFNcXHNdKikvaVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy87XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MpIHsgICAgICAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGFkZHJlc3MucmVwbGFjZSgnXFxcXCcsICcvJyk7XG4gIH0sXG4gIFsnLycsICdwYXRobmFtZSddLCAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJ0AnLCAnYXV0aCcsIDFdLCAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgZnJvbnQuXG4gIFtOYU4sICdob3N0JywgdW5kZWZpbmVkLCAxLCAxXSwgICAgICAgLy8gU2V0IGxlZnQgb3ZlciB2YWx1ZS5cbiAgWy86KFxcZCspJC8sICdwb3J0JywgdW5kZWZpbmVkLCAxXSwgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfTtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICB2YXIgbG9jYXRpb24gPSBnbG9iYWwgJiYgZ2xvYmFsLmxvY2F0aW9uIHx8IHt9O1xuICBsb2MgPSBsb2MgfHwgbG9jYXRpb247XG5cbiAgdmFyIGZpbmFsZGVzdGluYXRpb24gPSB7fVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NcbiAgICAsIGtleTtcblxuICBpZiAoJ2Jsb2I6JyA9PT0gbG9jLnByb3RvY29sKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwodW5lc2NhcGUobG9jLnBhdGhuYW1lKSwge30pO1xuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlKSB7XG4gICAgZmluYWxkZXN0aW5hdGlvbiA9IG5ldyBVcmwobG9jLCB7fSk7XG4gICAgZm9yIChrZXkgaW4gaWdub3JlKSBkZWxldGUgZmluYWxkZXN0aW5hdGlvbltrZXldO1xuICB9IGVsc2UgaWYgKCdvYmplY3QnID09PSB0eXBlKSB7XG4gICAgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgICBpZiAoa2V5IGluIGlnbm9yZSkgY29udGludWU7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZmluYWxkZXN0aW5hdGlvbi5zbGFzaGVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9IHNsYXNoZXMudGVzdChsb2MuaHJlZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59XG5cbi8qKlxuICogQHR5cGVkZWYgUHJvdG9jb2xFeHRyYWN0XG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCBtYXRjaGVkIGluIHRoZSBVUkwsIGluIGxvd2VyY2FzZS5cbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xhc2hlcyBgdHJ1ZWAgaWYgcHJvdG9jb2wgaXMgZm9sbG93ZWQgYnkgXCIvL1wiLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcmVzdCBSZXN0IG9mIHRoZSBVUkwgdGhhdCBpcyBub3QgcGFydCBvZiB0aGUgcHJvdG9jb2wuXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGZyb20gYSBVUkwgd2l0aC93aXRob3V0IGRvdWJsZSBzbGFzaCAoXCIvL1wiKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBleHRyYWN0IGZyb20uXG4gKiBAcmV0dXJuIHtQcm90b2NvbEV4dHJhY3R9IEV4dHJhY3RlZCBpbmZvcm1hdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQcm90b2NvbChhZGRyZXNzKSB7XG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcblxuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsxXSA/IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiAnJyxcbiAgICBzbGFzaGVzOiAhIW1hdGNoWzJdLFxuICAgIHJlc3Q6IG1hdGNoWzNdXG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbG9jYXRpb24gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBwYXJzZXIgUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycpO1xuICByZWxhdGl2ZSA9ICFleHRyYWN0ZWQucHJvdG9jb2wgJiYgIWV4dHJhY3RlZC5zbGFzaGVzO1xuICB1cmwuc2xhc2hlcyA9IGV4dHJhY3RlZC5zbGFzaGVzIHx8IHJlbGF0aXZlICYmIGxvY2F0aW9uLnNsYXNoZXM7XG4gIHVybC5wcm90b2NvbCA9IGV4dHJhY3RlZC5wcm90b2NvbCB8fCBsb2NhdGlvbi5wcm90b2NvbCB8fCAnJztcbiAgYWRkcmVzcyA9IGV4dHJhY3RlZC5yZXN0O1xuXG4gIC8vXG4gIC8vIFdoZW4gdGhlIGF1dGhvcml0eSBjb21wb25lbnQgaXMgYWJzZW50IHRoZSBVUkwgc3RhcnRzIHdpdGggYSBwYXRoXG4gIC8vIGNvbXBvbmVudC5cbiAgLy9cbiAgaWYgKCFleHRyYWN0ZWQuc2xhc2hlcykgaW5zdHJ1Y3Rpb25zWzNdID0gWy8oLiopLywgJ3BhdGhuYW1lJ107XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcnNlID0gaW5zdHJ1Y3Rpb25bMF07XG4gICAga2V5ID0gaW5zdHJ1Y3Rpb25bMV07XG5cbiAgICBpZiAocGFyc2UgIT09IHBhcnNlKSB7XG4gICAgICB1cmxba2V5XSA9IGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHBhcnNlKSB7XG4gICAgICBpZiAofihpbmRleCA9IGFkZHJlc3MuaW5kZXhPZihwYXJzZSkpKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyA9PT0gdHlwZW9mIGluc3RydWN0aW9uWzJdKSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZShpbmRleCArIGluc3RydWN0aW9uWzJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleC5pbmRleCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoXG4gICAgICByZWxhdGl2ZSAmJiBpbnN0cnVjdGlvblszXSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJ1xuICAgICk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gSWYgdGhlIFVSTCBpcyByZWxhdGl2ZSwgcmVzb2x2ZSB0aGUgcGF0aG5hbWUgYWdhaW5zdCB0aGUgYmFzZSBVUkwuXG4gIC8vXG4gIGlmIChcbiAgICAgIHJlbGF0aXZlXG4gICAgJiYgbG9jYXRpb24uc2xhc2hlc1xuICAgICYmIHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJ1xuICAgICYmICh1cmwucGF0aG5hbWUgIT09ICcnIHx8IGxvY2F0aW9uLnBhdGhuYW1lICE9PSAnJylcbiAgKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gcmVzb2x2ZSh1cmwucGF0aG5hbWUsIGxvY2F0aW9uLnBhdGhuYW1lKTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAoLzpcXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgICB1cmwucG9ydCA9IHZhbHVlLnBvcCgpO1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZS5qb2luKCc6Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmwuaG9zdG5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdXJsLnBvcnQgPSAnJztcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcm90b2NvbCc6XG4gICAgICB1cmwucHJvdG9jb2wgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdXJsLnNsYXNoZXMgPSAhZm47XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BhdGhuYW1lJzpcbiAgICBjYXNlICdoYXNoJzpcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgY2hhciA9IHBhcnQgPT09ICdwYXRobmFtZScgPyAnLycgOiAnIyc7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlLmNoYXJBdCgwKSAhPT0gY2hhciA/IGNoYXIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaW5zID0gcnVsZXNbaV07XG5cbiAgICBpZiAoaW5zWzRdKSB1cmxbaW5zWzFdXSA9IHVybFtpbnNbMV1dLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICYmIHVybC5ob3N0ICYmIHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6J1xuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG5cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IENvbXBpbGVkIHZlcnNpb24gb2YgdGhlIFVSTC5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHByb3RvY29sID0gdXJsLnByb3RvY29sO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5jaGFyQXQocHJvdG9jb2wubGVuZ3RoIC0gMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIHZhciByZXN1bHQgPSBwcm90b2NvbCArICh1cmwuc2xhc2hlcyA/ICcvLycgOiAnJyk7XG5cbiAgaWYgKHVybC51c2VybmFtZSkge1xuICAgIHJlc3VsdCArPSB1cmwudXNlcm5hbWU7XG4gICAgaWYgKHVybC5wYXNzd29yZCkgcmVzdWx0ICs9ICc6JysgdXJsLnBhc3N3b3JkO1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICByZXN1bHQgKz0gdXJsLmhvc3QgKyB1cmwucGF0aG5hbWU7XG5cbiAgcXVlcnkgPSAnb2JqZWN0JyA9PT0gdHlwZW9mIHVybC5xdWVyeSA/IHN0cmluZ2lmeSh1cmwucXVlcnkpIDogdXJsLnF1ZXJ5O1xuICBpZiAocXVlcnkpIHJlc3VsdCArPSAnPycgIT09IHF1ZXJ5LmNoYXJBdCgwKSA/ICc/JysgcXVlcnkgOiBxdWVyeTtcblxuICBpZiAodXJsLmhhc2gpIHJlc3VsdCArPSB1cmwuaGFzaDtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5VcmwucHJvdG90eXBlID0geyBzZXQ6IHNldCwgdG9TdHJpbmc6IHRvU3RyaW5nIH07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzIG9yIHRlc3RpbmcuXG4vL1xuVXJsLmV4dHJhY3RQcm90b2NvbCA9IGV4dHJhY3RQcm90b2NvbDtcblVybC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wicXVlcnlzdHJpbmdpZnlcIjo1OSxcInJlcXVpcmVzLXBvcnRcIjo2MH1dfSx7fSxbMV0pKDEpXG59KTtcblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2NranMuanMubWFwXG4iLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZVxuICBuby11bnVzZWQtdmFyc1xuKi9cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VDbGllbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VDbGllbnQpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VDbGllbnQsIG51bGwsIFt7XG4gICAga2V5OiBcImdldENsaWVudFBhdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2xpZW50UGF0aChvcHRpb25zKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsaWVudCBuZWVkcyBpbXBsZW1lbnRhdGlvbicpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlQ2xpZW50O1xufSgpOyIsIid1c2Ugc3RyaWN0JzsgLy8gVGhlIGVycm9yIG92ZXJsYXkgaXMgaW5zcGlyZWQgKGFuZCBtb3N0bHkgY29waWVkKSBmcm9tIENyZWF0ZSBSZWFjdCBBcHAgKGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2luY3ViYXRvci9jcmVhdGUtcmVhY3QtYXBwKVxuLy8gVGhleSwgaW4gdHVybiwgZ290IGluc3BpcmVkIGJ5IHdlYnBhY2staG90LW1pZGRsZXdhcmUgKGh0dHBzOi8vZ2l0aHViLmNvbS9nbGVuamFtaW4vd2VicGFjay1ob3QtbWlkZGxld2FyZSkuXG5cbnZhciBhbnNpSFRNTCA9IHJlcXVpcmUoJ2Fuc2ktaHRtbCcpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdodG1sLWVudGl0aWVzJyksXG4gICAgQWxsSHRtbEVudGl0aWVzID0gX3JlcXVpcmUuQWxsSHRtbEVudGl0aWVzO1xuXG52YXIgZW50aXRpZXMgPSBuZXcgQWxsSHRtbEVudGl0aWVzKCk7XG52YXIgY29sb3JzID0ge1xuICByZXNldDogWyd0cmFuc3BhcmVudCcsICd0cmFuc3BhcmVudCddLFxuICBibGFjazogJzE4MTgxOCcsXG4gIHJlZDogJ0UzNjA0OScsXG4gIGdyZWVuOiAnQjNDQjc0JyxcbiAgeWVsbG93OiAnRkZEMDgwJyxcbiAgYmx1ZTogJzdDQUZDMicsXG4gIG1hZ2VudGE6ICc3RkFDQ0EnLFxuICBjeWFuOiAnQzNDMkVGJyxcbiAgbGlnaHRncmV5OiAnRUJFN0UzJyxcbiAgZGFya2dyZXk6ICc2RDc4OTEnXG59O1xudmFyIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xudmFyIG92ZXJsYXlEaXYgPSBudWxsO1xudmFyIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG5hbnNpSFRNTC5zZXRDb2xvcnMoY29sb3JzKTtcblxuZnVuY3Rpb24gY3JlYXRlT3ZlcmxheUlmcmFtZShvbklmcmFtZUxvYWQpIHtcbiAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICBpZnJhbWUuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5JztcbiAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGlmcmFtZS5zdHlsZS5sZWZ0ID0gMDtcbiAgaWZyYW1lLnN0eWxlLnRvcCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5yaWdodCA9IDA7XG4gIGlmcmFtZS5zdHlsZS5ib3R0b20gPSAwO1xuICBpZnJhbWUuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBpZnJhbWUuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgaWZyYW1lLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgaWZyYW1lLnN0eWxlLnpJbmRleCA9IDk5OTk5OTk5OTk7XG4gIGlmcmFtZS5vbmxvYWQgPSBvbklmcmFtZUxvYWQ7XG4gIHJldHVybiBpZnJhbWU7XG59XG5cbmZ1bmN0aW9uIGFkZE92ZXJsYXlEaXZUbyhpZnJhbWUpIHtcbiAgdmFyIGRpdiA9IGlmcmFtZS5jb250ZW50RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pZCA9ICd3ZWJwYWNrLWRldi1zZXJ2ZXItY2xpZW50LW92ZXJsYXktZGl2JztcbiAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgZGl2LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgZGl2LnN0eWxlLmxlZnQgPSAwO1xuICBkaXYuc3R5bGUudG9wID0gMDtcbiAgZGl2LnN0eWxlLnJpZ2h0ID0gMDtcbiAgZGl2LnN0eWxlLmJvdHRvbSA9IDA7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcxMDB2dyc7XG4gIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwdmgnO1xuICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwgMCwgMCwgMC44NSknO1xuICBkaXYuc3R5bGUuY29sb3IgPSAnI0U4RThFOCc7XG4gIGRpdi5zdHlsZS5mb250RmFtaWx5ID0gJ01lbmxvLCBDb25zb2xhcywgbW9ub3NwYWNlJztcbiAgZGl2LnN0eWxlLmZvbnRTaXplID0gJ2xhcmdlJztcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMnJlbSc7XG4gIGRpdi5zdHlsZS5saW5lSGVpZ2h0ID0gJzEuMic7XG4gIGRpdi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgZGl2LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICBpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgcmV0dXJuIGRpdjtcbn1cblxuZnVuY3Rpb24gZW5zdXJlT3ZlcmxheURpdkV4aXN0cyhvbk92ZXJsYXlEaXZSZWFkeSkge1xuICBpZiAob3ZlcmxheURpdikge1xuICAgIC8vIEV2ZXJ5dGhpbmcgaXMgcmVhZHksIGNhbGwgdGhlIGNhbGxiYWNrIHJpZ2h0IGF3YXkuXG4gICAgb25PdmVybGF5RGl2UmVhZHkob3ZlcmxheURpdik7XG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0aW5nIGFuIGlmcmFtZSBtYXkgYmUgYXN5bmNocm9ub3VzIHNvIHdlJ2xsIHNjaGVkdWxlIHRoZSBjYWxsYmFjay5cbiAgLy8gSW4gY2FzZSBvZiBtdWx0aXBsZSBjYWxscywgbGFzdCBjYWxsYmFjayB3aW5zLlxuXG5cbiAgbGFzdE9uT3ZlcmxheURpdlJlYWR5ID0gb25PdmVybGF5RGl2UmVhZHk7XG5cbiAgaWYgKG92ZXJsYXlJZnJhbWUpIHtcbiAgICAvLyBXZSd2ZSBhbHJlYWR5IGNyZWF0ZWQgaXQuXG4gICAgcmV0dXJuO1xuICB9IC8vIENyZWF0ZSBpZnJhbWUgYW5kLCB3aGVuIGl0IGlzIHJlYWR5LCBhIGRpdiBpbnNpZGUgaXQuXG5cblxuICBvdmVybGF5SWZyYW1lID0gY3JlYXRlT3ZlcmxheUlmcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgb3ZlcmxheURpdiA9IGFkZE92ZXJsYXlEaXZUbyhvdmVybGF5SWZyYW1lKTsgLy8gTm93IHdlIGNhbiB0YWxrIVxuXG4gICAgbGFzdE9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICB9KTsgLy8gWmFsZ28gYWxlcnQ6IG9uSWZyYW1lTG9hZCgpIHdpbGwgYmUgY2FsbGVkIGVpdGhlciBzeW5jaHJvbm91c2x5XG4gIC8vIG9yIGFzeW5jaHJvbm91c2x5IGRlcGVuZGluZyBvbiB0aGUgYnJvd3Nlci5cbiAgLy8gV2UgZGVsYXkgYWRkaW5nIGl0IHNvIGBvdmVybGF5SWZyYW1lYCBpcyBzZXQgd2hlbiBgb25JZnJhbWVMb2FkYCBmaXJlcy5cblxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG92ZXJsYXlJZnJhbWUpO1xufSAvLyBTdWNjZXNzZnVsIGNvbXBpbGF0aW9uLlxuXG5cbmZ1bmN0aW9uIGNsZWFyKCkge1xuICBpZiAoIW92ZXJsYXlEaXYpIHtcbiAgICAvLyBJdCBpcyBub3QgdGhlcmUgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgIHJldHVybjtcbiAgfSAvLyBDbGVhbiB1cCBhbmQgcmVzZXQgaW50ZXJuYWwgc3RhdGUuXG5cblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG92ZXJsYXlJZnJhbWUpO1xuICBvdmVybGF5RGl2ID0gbnVsbDtcbiAgb3ZlcmxheUlmcmFtZSA9IG51bGw7XG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG51bGw7XG59IC8vIENvbXBpbGF0aW9uIHdpdGggZXJyb3JzIChlLmcuIHN5bnRheCBlcnJvciBvciBtaXNzaW5nIG1vZHVsZXMpLlxuXG5cbmZ1bmN0aW9uIHNob3dNZXNzYWdlKG1lc3NhZ2VzKSB7XG4gIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMoZnVuY3Rpb24gKGRpdikge1xuICAgIC8vIE1ha2UgaXQgbG9vayBzaW1pbGFyIHRvIG91ciB0ZXJtaW5hbC5cbiAgICBkaXYuaW5uZXJIVE1MID0gXCI8c3BhbiBzdHlsZT1cXFwiY29sb3I6ICNcIi5jb25jYXQoY29sb3JzLnJlZCwgXCJcXFwiPkZhaWxlZCB0byBjb21waWxlLjwvc3Bhbj48YnI+PGJyPlwiKS5jb25jYXQoYW5zaUhUTUwoZW50aXRpZXMuZW5jb2RlKG1lc3NhZ2VzWzBdKSkpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNsZWFyOiBjbGVhcixcbiAgc2hvd01lc3NhZ2U6IHNob3dNZXNzYWdlXG59OyIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFuc2lIVE1MXG5cbi8vIFJlZmVyZW5jZSB0byBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2Fuc2ktcmVnZXhcbnZhciBfcmVnQU5TSSA9IC8oPzooPzpcXHUwMDFiXFxbKXxcXHUwMDliKSg/Oig/OlswLTldezEsM30pPyg/Oig/OjtbMC05XXswLDN9KSopP1tBLU18Zi1tXSl8XFx1MDAxYltBLU1dL1xuXG52YXIgX2RlZkNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsnZmZmJywgJzAwMCddLCAvLyBbRk9SRUdST1VEX0NPTE9SLCBCQUNLR1JPVU5EX0NPTE9SXVxuICBibGFjazogJzAwMCcsXG4gIHJlZDogJ2ZmMDAwMCcsXG4gIGdyZWVuOiAnMjA5ODA1JyxcbiAgeWVsbG93OiAnZThiZjAzJyxcbiAgYmx1ZTogJzAwMDBmZicsXG4gIG1hZ2VudGE6ICdmZjAwZmYnLFxuICBjeWFuOiAnMDBmZmVlJyxcbiAgbGlnaHRncmV5OiAnZjBmMGYwJyxcbiAgZGFya2dyZXk6ICc4ODgnXG59XG52YXIgX3N0eWxlcyA9IHtcbiAgMzA6ICdibGFjaycsXG4gIDMxOiAncmVkJyxcbiAgMzI6ICdncmVlbicsXG4gIDMzOiAneWVsbG93JyxcbiAgMzQ6ICdibHVlJyxcbiAgMzU6ICdtYWdlbnRhJyxcbiAgMzY6ICdjeWFuJyxcbiAgMzc6ICdsaWdodGdyZXknXG59XG52YXIgX29wZW5UYWdzID0ge1xuICAnMSc6ICdmb250LXdlaWdodDpib2xkJywgLy8gYm9sZFxuICAnMic6ICdvcGFjaXR5OjAuNScsIC8vIGRpbVxuICAnMyc6ICc8aT4nLCAvLyBpdGFsaWNcbiAgJzQnOiAnPHU+JywgLy8gdW5kZXJzY29yZVxuICAnOCc6ICdkaXNwbGF5Om5vbmUnLCAvLyBoaWRkZW5cbiAgJzknOiAnPGRlbD4nIC8vIGRlbGV0ZVxufVxudmFyIF9jbG9zZVRhZ3MgPSB7XG4gICcyMyc6ICc8L2k+JywgLy8gcmVzZXQgaXRhbGljXG4gICcyNCc6ICc8L3U+JywgLy8gcmVzZXQgdW5kZXJzY29yZVxuICAnMjknOiAnPC9kZWw+JyAvLyByZXNldCBkZWxldGVcbn1cblxuO1swLCAyMSwgMjIsIDI3LCAyOCwgMzksIDQ5XS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gIF9jbG9zZVRhZ3Nbbl0gPSAnPC9zcGFuPidcbn0pXG5cbi8qKlxuICogQ29udmVydHMgdGV4dCB3aXRoIEFOU0kgY29sb3IgY29kZXMgdG8gSFRNTCBtYXJrdXAuXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dFxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGFuc2lIVE1MICh0ZXh0KSB7XG4gIC8vIFJldHVybnMgdGhlIHRleHQgaWYgdGhlIHN0cmluZyBoYXMgbm8gQU5TSSBlc2NhcGUgY29kZS5cbiAgaWYgKCFfcmVnQU5TSS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuIHRleHRcbiAgfVxuXG4gIC8vIENhY2hlIG9wZW5lZCBzZXF1ZW5jZS5cbiAgdmFyIGFuc2lDb2RlcyA9IFtdXG4gIC8vIFJlcGxhY2Ugd2l0aCBtYXJrdXAuXG4gIHZhciByZXQgPSB0ZXh0LnJlcGxhY2UoL1xcMDMzXFxbKFxcZCspKm0vZywgZnVuY3Rpb24gKG1hdGNoLCBzZXEpIHtcbiAgICB2YXIgb3QgPSBfb3BlblRhZ3Nbc2VxXVxuICAgIGlmIChvdCkge1xuICAgICAgLy8gSWYgY3VycmVudCBzZXF1ZW5jZSBoYXMgYmVlbiBvcGVuZWQsIGNsb3NlIGl0LlxuICAgICAgaWYgKCEhfmFuc2lDb2Rlcy5pbmRleE9mKHNlcSkpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1leHRyYS1ib29sZWFuLWNhc3RcbiAgICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICAgIHJldHVybiAnPC9zcGFuPidcbiAgICAgIH1cbiAgICAgIC8vIE9wZW4gdGFnLlxuICAgICAgYW5zaUNvZGVzLnB1c2goc2VxKVxuICAgICAgcmV0dXJuIG90WzBdID09PSAnPCcgPyBvdCA6ICc8c3BhbiBzdHlsZT1cIicgKyBvdCArICc7XCI+J1xuICAgIH1cblxuICAgIHZhciBjdCA9IF9jbG9zZVRhZ3Nbc2VxXVxuICAgIGlmIChjdCkge1xuICAgICAgLy8gUG9wIHNlcXVlbmNlXG4gICAgICBhbnNpQ29kZXMucG9wKClcbiAgICAgIHJldHVybiBjdFxuICAgIH1cbiAgICByZXR1cm4gJydcbiAgfSlcblxuICAvLyBNYWtlIHN1cmUgdGFncyBhcmUgY2xvc2VkLlxuICB2YXIgbCA9IGFuc2lDb2Rlcy5sZW5ndGhcbiAgOyhsID4gMCkgJiYgKHJldCArPSBBcnJheShsICsgMSkuam9pbignPC9zcGFuPicpKVxuXG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBDdXN0b21pemUgY29sb3JzLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyByZWZlcmVuY2UgdG8gX2RlZkNvbG9yc1xuICovXG5hbnNpSFRNTC5zZXRDb2xvcnMgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gIGlmICh0eXBlb2YgY29sb3JzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignYGNvbG9yc2AgcGFyYW1ldGVyIG11c3QgYmUgYW4gT2JqZWN0LicpXG4gIH1cblxuICB2YXIgX2ZpbmFsQ29sb3JzID0ge31cbiAgZm9yICh2YXIga2V5IGluIF9kZWZDb2xvcnMpIHtcbiAgICB2YXIgaGV4ID0gY29sb3JzLmhhc093blByb3BlcnR5KGtleSkgPyBjb2xvcnNba2V5XSA6IG51bGxcbiAgICBpZiAoIWhleCkge1xuICAgICAgX2ZpbmFsQ29sb3JzW2tleV0gPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICgncmVzZXQnID09PSBrZXkpIHtcbiAgICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICBoZXggPSBbaGV4XVxuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGhleCkgfHwgaGV4Lmxlbmd0aCA9PT0gMCB8fCBoZXguc29tZShmdW5jdGlvbiAoaCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGggIT09ICdzdHJpbmcnXG4gICAgICB9KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYW4gQXJyYXkgYW5kIGVhY2ggaXRlbSBjb3VsZCBvbmx5IGJlIGEgaGV4IHN0cmluZywgZS5nLjogRkYwMDAwJylcbiAgICAgIH1cbiAgICAgIHZhciBkZWZIZXhDb2xvciA9IF9kZWZDb2xvcnNba2V5XVxuICAgICAgaWYgKCFoZXhbMF0pIHtcbiAgICAgICAgaGV4WzBdID0gZGVmSGV4Q29sb3JbMF1cbiAgICAgIH1cbiAgICAgIGlmIChoZXgubGVuZ3RoID09PSAxIHx8ICFoZXhbMV0pIHtcbiAgICAgICAgaGV4ID0gW2hleFswXV1cbiAgICAgICAgaGV4LnB1c2goZGVmSGV4Q29sb3JbMV0pXG4gICAgICB9XG5cbiAgICAgIGhleCA9IGhleC5zbGljZSgwLCAyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHZhbHVlIG9mIGAnICsga2V5ICsgJ2AgcHJvcGVydHkgbXVzdCBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgfVxuICAgIF9maW5hbENvbG9yc1trZXldID0gaGV4XG4gIH1cbiAgX3NldFRhZ3MoX2ZpbmFsQ29sb3JzKVxufVxuXG4vKipcbiAqIFJlc2V0IGNvbG9ycy5cbiAqL1xuYW5zaUhUTUwucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIF9zZXRUYWdzKF9kZWZDb2xvcnMpXG59XG5cbi8qKlxuICogRXhwb3NlIHRhZ3MsIGluY2x1ZGluZyBvcGVuIGFuZCBjbG9zZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmFuc2lIVE1MLnRhZ3MgPSB7fVxuXG5pZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnb3BlbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9vcGVuVGFncyB9XG4gIH0pXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbnNpSFRNTC50YWdzLCAnY2xvc2UnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfY2xvc2VUYWdzIH1cbiAgfSlcbn0gZWxzZSB7XG4gIGFuc2lIVE1MLnRhZ3Mub3BlbiA9IF9vcGVuVGFnc1xuICBhbnNpSFRNTC50YWdzLmNsb3NlID0gX2Nsb3NlVGFnc1xufVxuXG5mdW5jdGlvbiBfc2V0VGFncyAoY29sb3JzKSB7XG4gIC8vIHJlc2V0IGFsbFxuICBfb3BlblRhZ3NbJzAnXSA9ICdmb250LXdlaWdodDpub3JtYWw7b3BhY2l0eToxO2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzBdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzFdXG4gIC8vIGludmVyc2VcbiAgX29wZW5UYWdzWyc3J10gPSAnY29sb3I6IycgKyBjb2xvcnMucmVzZXRbMV0gKyAnO2JhY2tncm91bmQ6IycgKyBjb2xvcnMucmVzZXRbMF1cbiAgLy8gZGFyayBncmV5XG4gIF9vcGVuVGFnc1snOTAnXSA9ICdjb2xvcjojJyArIGNvbG9ycy5kYXJrZ3JleVxuXG4gIGZvciAodmFyIGNvZGUgaW4gX3N0eWxlcykge1xuICAgIHZhciBjb2xvciA9IF9zdHlsZXNbY29kZV1cbiAgICB2YXIgb3JpQ29sb3IgPSBjb2xvcnNbY29sb3JdIHx8ICcwMDAnXG4gICAgX29wZW5UYWdzW2NvZGVdID0gJ2NvbG9yOiMnICsgb3JpQ29sb3JcbiAgICBjb2RlID0gcGFyc2VJbnQoY29kZSlcbiAgICBfb3BlblRhZ3NbKGNvZGUgKyAxMCkudG9TdHJpbmcoKV0gPSAnYmFja2dyb3VuZDojJyArIG9yaUNvbG9yXG4gIH1cbn1cblxuYW5zaUhUTUwucmVzZXQoKVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIFhtbEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi94bWwtZW50aXRpZXMuanMnKSxcbiAgSHRtbDRFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDQtZW50aXRpZXMuanMnKSxcbiAgSHRtbDVFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKSxcbiAgQWxsSHRtbEVudGl0aWVzOiByZXF1aXJlKCcuL2xpYi9odG1sNS1lbnRpdGllcy5qcycpXG59O1xuIiwidmFyIEFMUEhBX0lOREVYID0ge1xuICAgICcmbHQnOiAnPCcsXG4gICAgJyZndCc6ICc+JyxcbiAgICAnJnF1b3QnOiAnXCInLFxuICAgICcmYXBvcyc6ICdcXCcnLFxuICAgICcmYW1wJzogJyYnLFxuICAgICcmbHQ7JzogJzwnLFxuICAgICcmZ3Q7JzogJz4nLFxuICAgICcmcXVvdDsnOiAnXCInLFxuICAgICcmYXBvczsnOiAnXFwnJyxcbiAgICAnJmFtcDsnOiAnJidcbn07XG5cbnZhciBDSEFSX0lOREVYID0ge1xuICAgIDYwOiAnbHQnLFxuICAgIDYyOiAnZ3QnLFxuICAgIDM0OiAncXVvdCcsXG4gICAgMzk6ICdhcG9zJyxcbiAgICAzODogJ2FtcCdcbn07XG5cbnZhciBDSEFSX1NfSU5ERVggPSB7XG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgJ1xcJyc6ICcmYXBvczsnLFxuICAgICcmJzogJyZhbXA7J1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gWG1sRW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvPHw+fFwifCd8Ji9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBDSEFSX1NfSU5ERVhbc107XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYjP1swLTlhLXpBLVpdKzs/L2csIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgaWYgKHMuY2hhckF0KDEpID09PSAnIycpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcy5jaGFyQXQoMikudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigzKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChzLnN1YnN0cigyKSk7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBTFBIQV9JTkRFWFtzXSB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgYWxwaGEgPSBDSEFSX0lOREVYW2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5lbmNvZGVOb25VVEYoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmdodCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmdodCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhtbEVudGl0aWVzO1xuIiwidmFyIEhUTUxfQUxQSEEgPSBbJ2Fwb3MnLCAnbmJzcCcsICdpZXhjbCcsICdjZW50JywgJ3BvdW5kJywgJ2N1cnJlbicsICd5ZW4nLCAnYnJ2YmFyJywgJ3NlY3QnLCAndW1sJywgJ2NvcHknLCAnb3JkZicsICdsYXF1bycsICdub3QnLCAnc2h5JywgJ3JlZycsICdtYWNyJywgJ2RlZycsICdwbHVzbW4nLCAnc3VwMicsICdzdXAzJywgJ2FjdXRlJywgJ21pY3JvJywgJ3BhcmEnLCAnbWlkZG90JywgJ2NlZGlsJywgJ3N1cDEnLCAnb3JkbScsICdyYXF1bycsICdmcmFjMTQnLCAnZnJhYzEyJywgJ2ZyYWMzNCcsICdpcXVlc3QnLCAnQWdyYXZlJywgJ0FhY3V0ZScsICdBY2lyYycsICdBdGlsZGUnLCAnQXVtbCcsICdBcmluZycsICdBZWxpZycsICdDY2VkaWwnLCAnRWdyYXZlJywgJ0VhY3V0ZScsICdFY2lyYycsICdFdW1sJywgJ0lncmF2ZScsICdJYWN1dGUnLCAnSWNpcmMnLCAnSXVtbCcsICdFVEgnLCAnTnRpbGRlJywgJ09ncmF2ZScsICdPYWN1dGUnLCAnT2NpcmMnLCAnT3RpbGRlJywgJ091bWwnLCAndGltZXMnLCAnT3NsYXNoJywgJ1VncmF2ZScsICdVYWN1dGUnLCAnVWNpcmMnLCAnVXVtbCcsICdZYWN1dGUnLCAnVEhPUk4nLCAnc3psaWcnLCAnYWdyYXZlJywgJ2FhY3V0ZScsICdhY2lyYycsICdhdGlsZGUnLCAnYXVtbCcsICdhcmluZycsICdhZWxpZycsICdjY2VkaWwnLCAnZWdyYXZlJywgJ2VhY3V0ZScsICdlY2lyYycsICdldW1sJywgJ2lncmF2ZScsICdpYWN1dGUnLCAnaWNpcmMnLCAnaXVtbCcsICdldGgnLCAnbnRpbGRlJywgJ29ncmF2ZScsICdvYWN1dGUnLCAnb2NpcmMnLCAnb3RpbGRlJywgJ291bWwnLCAnZGl2aWRlJywgJ29zbGFzaCcsICd1Z3JhdmUnLCAndWFjdXRlJywgJ3VjaXJjJywgJ3V1bWwnLCAneWFjdXRlJywgJ3Rob3JuJywgJ3l1bWwnLCAncXVvdCcsICdhbXAnLCAnbHQnLCAnZ3QnLCAnT0VsaWcnLCAnb2VsaWcnLCAnU2Nhcm9uJywgJ3NjYXJvbicsICdZdW1sJywgJ2NpcmMnLCAndGlsZGUnLCAnZW5zcCcsICdlbXNwJywgJ3RoaW5zcCcsICd6d25qJywgJ3p3aicsICdscm0nLCAncmxtJywgJ25kYXNoJywgJ21kYXNoJywgJ2xzcXVvJywgJ3JzcXVvJywgJ3NicXVvJywgJ2xkcXVvJywgJ3JkcXVvJywgJ2JkcXVvJywgJ2RhZ2dlcicsICdEYWdnZXInLCAncGVybWlsJywgJ2xzYXF1bycsICdyc2FxdW8nLCAnZXVybycsICdmbm9mJywgJ0FscGhhJywgJ0JldGEnLCAnR2FtbWEnLCAnRGVsdGEnLCAnRXBzaWxvbicsICdaZXRhJywgJ0V0YScsICdUaGV0YScsICdJb3RhJywgJ0thcHBhJywgJ0xhbWJkYScsICdNdScsICdOdScsICdYaScsICdPbWljcm9uJywgJ1BpJywgJ1JobycsICdTaWdtYScsICdUYXUnLCAnVXBzaWxvbicsICdQaGknLCAnQ2hpJywgJ1BzaScsICdPbWVnYScsICdhbHBoYScsICdiZXRhJywgJ2dhbW1hJywgJ2RlbHRhJywgJ2Vwc2lsb24nLCAnemV0YScsICdldGEnLCAndGhldGEnLCAnaW90YScsICdrYXBwYScsICdsYW1iZGEnLCAnbXUnLCAnbnUnLCAneGknLCAnb21pY3JvbicsICdwaScsICdyaG8nLCAnc2lnbWFmJywgJ3NpZ21hJywgJ3RhdScsICd1cHNpbG9uJywgJ3BoaScsICdjaGknLCAncHNpJywgJ29tZWdhJywgJ3RoZXRhc3ltJywgJ3Vwc2loJywgJ3BpdicsICdidWxsJywgJ2hlbGxpcCcsICdwcmltZScsICdQcmltZScsICdvbGluZScsICdmcmFzbCcsICd3ZWllcnAnLCAnaW1hZ2UnLCAncmVhbCcsICd0cmFkZScsICdhbGVmc3ltJywgJ2xhcnInLCAndWFycicsICdyYXJyJywgJ2RhcnInLCAnaGFycicsICdjcmFycicsICdsQXJyJywgJ3VBcnInLCAnckFycicsICdkQXJyJywgJ2hBcnInLCAnZm9yYWxsJywgJ3BhcnQnLCAnZXhpc3QnLCAnZW1wdHknLCAnbmFibGEnLCAnaXNpbicsICdub3RpbicsICduaScsICdwcm9kJywgJ3N1bScsICdtaW51cycsICdsb3dhc3QnLCAncmFkaWMnLCAncHJvcCcsICdpbmZpbicsICdhbmcnLCAnYW5kJywgJ29yJywgJ2NhcCcsICdjdXAnLCAnaW50JywgJ3RoZXJlNCcsICdzaW0nLCAnY29uZycsICdhc3ltcCcsICduZScsICdlcXVpdicsICdsZScsICdnZScsICdzdWInLCAnc3VwJywgJ25zdWInLCAnc3ViZScsICdzdXBlJywgJ29wbHVzJywgJ290aW1lcycsICdwZXJwJywgJ3Nkb3QnLCAnbGNlaWwnLCAncmNlaWwnLCAnbGZsb29yJywgJ3JmbG9vcicsICdsYW5nJywgJ3JhbmcnLCAnbG96JywgJ3NwYWRlcycsICdjbHVicycsICdoZWFydHMnLCAnZGlhbXMnXTtcbnZhciBIVE1MX0NPREVTID0gWzM5LCAxNjAsIDE2MSwgMTYyLCAxNjMsIDE2NCwgMTY1LCAxNjYsIDE2NywgMTY4LCAxNjksIDE3MCwgMTcxLCAxNzIsIDE3MywgMTc0LCAxNzUsIDE3NiwgMTc3LCAxNzgsIDE3OSwgMTgwLCAxODEsIDE4MiwgMTgzLCAxODQsIDE4NSwgMTg2LCAxODcsIDE4OCwgMTg5LCAxOTAsIDE5MSwgMTkyLCAxOTMsIDE5NCwgMTk1LCAxOTYsIDE5NywgMTk4LCAxOTksIDIwMCwgMjAxLCAyMDIsIDIwMywgMjA0LCAyMDUsIDIwNiwgMjA3LCAyMDgsIDIwOSwgMjEwLCAyMTEsIDIxMiwgMjEzLCAyMTQsIDIxNSwgMjE2LCAyMTcsIDIxOCwgMjE5LCAyMjAsIDIyMSwgMjIyLCAyMjMsIDIyNCwgMjI1LCAyMjYsIDIyNywgMjI4LCAyMjksIDIzMCwgMjMxLCAyMzIsIDIzMywgMjM0LCAyMzUsIDIzNiwgMjM3LCAyMzgsIDIzOSwgMjQwLCAyNDEsIDI0MiwgMjQzLCAyNDQsIDI0NSwgMjQ2LCAyNDcsIDI0OCwgMjQ5LCAyNTAsIDI1MSwgMjUyLCAyNTMsIDI1NCwgMjU1LCAzNCwgMzgsIDYwLCA2MiwgMzM4LCAzMzksIDM1MiwgMzUzLCAzNzYsIDcxMCwgNzMyLCA4MTk0LCA4MTk1LCA4MjAxLCA4MjA0LCA4MjA1LCA4MjA2LCA4MjA3LCA4MjExLCA4MjEyLCA4MjE2LCA4MjE3LCA4MjE4LCA4MjIwLCA4MjIxLCA4MjIyLCA4MjI0LCA4MjI1LCA4MjQwLCA4MjQ5LCA4MjUwLCA4MzY0LCA0MDIsIDkxMywgOTE0LCA5MTUsIDkxNiwgOTE3LCA5MTgsIDkxOSwgOTIwLCA5MjEsIDkyMiwgOTIzLCA5MjQsIDkyNSwgOTI2LCA5MjcsIDkyOCwgOTI5LCA5MzEsIDkzMiwgOTMzLCA5MzQsIDkzNSwgOTM2LCA5MzcsIDk0NSwgOTQ2LCA5NDcsIDk0OCwgOTQ5LCA5NTAsIDk1MSwgOTUyLCA5NTMsIDk1NCwgOTU1LCA5NTYsIDk1NywgOTU4LCA5NTksIDk2MCwgOTYxLCA5NjIsIDk2MywgOTY0LCA5NjUsIDk2NiwgOTY3LCA5NjgsIDk2OSwgOTc3LCA5NzgsIDk4MiwgODIyNiwgODIzMCwgODI0MiwgODI0MywgODI1NCwgODI2MCwgODQ3MiwgODQ2NSwgODQ3NiwgODQ4MiwgODUwMSwgODU5MiwgODU5MywgODU5NCwgODU5NSwgODU5NiwgODYyOSwgODY1NiwgODY1NywgODY1OCwgODY1OSwgODY2MCwgODcwNCwgODcwNiwgODcwNywgODcwOSwgODcxMSwgODcxMiwgODcxMywgODcxNSwgODcxOSwgODcyMSwgODcyMiwgODcyNywgODczMCwgODczMywgODczNCwgODczNiwgODc0MywgODc0NCwgODc0NSwgODc0NiwgODc0NywgODc1NiwgODc2NCwgODc3MywgODc3NiwgODgwMCwgODgwMSwgODgwNCwgODgwNSwgODgzNCwgODgzNSwgODgzNiwgODgzOCwgODgzOSwgODg1MywgODg1NSwgODg2OSwgODkwMSwgODk2OCwgODk2OSwgODk3MCwgODk3MSwgOTAwMSwgOTAwMiwgOTY3NCwgOTgyNCwgOTgyNywgOTgyOSwgOTgzMF07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgbnVtSW5kZXggPSB7fTtcblxudmFyIGkgPSAwO1xudmFyIGxlbmd0aCA9IEhUTUxfQUxQSEEubGVuZ3RoO1xud2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICB2YXIgYSA9IEhUTUxfQUxQSEFbaV07XG4gICAgdmFyIGMgPSBIVE1MX0NPREVTW2ldO1xuICAgIGFscGhhSW5kZXhbYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgIG51bUluZGV4W2NdID0gYTtcbiAgICBpKys7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw0RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKS50b0xvd2VyQ2FzZSgpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMiksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmRlY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICByZXN1bHQgKz0gYWxwaGEgPyBcIiZcIiArIGFscGhhICsgXCI7XCIgOiBzdHIuY2hhckF0KGkpO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2MgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gbnVtSW5kZXhbY2NdO1xuICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiZcIiArIGFscGhhICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2MgPCAzMiB8fCBjYyA+IDEyNikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiJiNcIiArIGNjICsgXCI7XCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjIDw9IDI1NSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0cltpKytdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9ICcmIycgKyBjICsgJzsnO1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw0RW50aXRpZXMuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5lbmNvZGVOb25BU0NJSShzdHIpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNEVudGl0aWVzO1xuIiwidmFyIEVOVElUSUVTID0gW1snQWFjdXRlJywgWzE5M11dLCBbJ2FhY3V0ZScsIFsyMjVdXSwgWydBYnJldmUnLCBbMjU4XV0sIFsnYWJyZXZlJywgWzI1OV1dLCBbJ2FjJywgWzg3NjZdXSwgWydhY2QnLCBbODc2N11dLCBbJ2FjRScsIFs4NzY2LCA4MTldXSwgWydBY2lyYycsIFsxOTRdXSwgWydhY2lyYycsIFsyMjZdXSwgWydhY3V0ZScsIFsxODBdXSwgWydBY3knLCBbMTA0MF1dLCBbJ2FjeScsIFsxMDcyXV0sIFsnQUVsaWcnLCBbMTk4XV0sIFsnYWVsaWcnLCBbMjMwXV0sIFsnYWYnLCBbODI4OV1dLCBbJ0FmcicsIFsxMjAwNjhdXSwgWydhZnInLCBbMTIwMDk0XV0sIFsnQWdyYXZlJywgWzE5Ml1dLCBbJ2FncmF2ZScsIFsyMjRdXSwgWydhbGVmc3ltJywgWzg1MDFdXSwgWydhbGVwaCcsIFs4NTAxXV0sIFsnQWxwaGEnLCBbOTEzXV0sIFsnYWxwaGEnLCBbOTQ1XV0sIFsnQW1hY3InLCBbMjU2XV0sIFsnYW1hY3InLCBbMjU3XV0sIFsnYW1hbGcnLCBbMTA4MTVdXSwgWydhbXAnLCBbMzhdXSwgWydBTVAnLCBbMzhdXSwgWydhbmRhbmQnLCBbMTA4MzddXSwgWydBbmQnLCBbMTA4MzVdXSwgWydhbmQnLCBbODc0M11dLCBbJ2FuZGQnLCBbMTA4NDRdXSwgWydhbmRzbG9wZScsIFsxMDg0MF1dLCBbJ2FuZHYnLCBbMTA4NDJdXSwgWydhbmcnLCBbODczNl1dLCBbJ2FuZ2UnLCBbMTA2NjBdXSwgWydhbmdsZScsIFs4NzM2XV0sIFsnYW5nbXNkYWEnLCBbMTA2NjRdXSwgWydhbmdtc2RhYicsIFsxMDY2NV1dLCBbJ2FuZ21zZGFjJywgWzEwNjY2XV0sIFsnYW5nbXNkYWQnLCBbMTA2NjddXSwgWydhbmdtc2RhZScsIFsxMDY2OF1dLCBbJ2FuZ21zZGFmJywgWzEwNjY5XV0sIFsnYW5nbXNkYWcnLCBbMTA2NzBdXSwgWydhbmdtc2RhaCcsIFsxMDY3MV1dLCBbJ2FuZ21zZCcsIFs4NzM3XV0sIFsnYW5ncnQnLCBbODczNV1dLCBbJ2FuZ3J0dmInLCBbODg5NF1dLCBbJ2FuZ3J0dmJkJywgWzEwNjUzXV0sIFsnYW5nc3BoJywgWzg3MzhdXSwgWydhbmdzdCcsIFsxOTddXSwgWydhbmd6YXJyJywgWzkwODRdXSwgWydBb2dvbicsIFsyNjBdXSwgWydhb2dvbicsIFsyNjFdXSwgWydBb3BmJywgWzEyMDEyMF1dLCBbJ2FvcGYnLCBbMTIwMTQ2XV0sIFsnYXBhY2lyJywgWzEwODYzXV0sIFsnYXAnLCBbODc3Nl1dLCBbJ2FwRScsIFsxMDg2NF1dLCBbJ2FwZScsIFs4Nzc4XV0sIFsnYXBpZCcsIFs4Nzc5XV0sIFsnYXBvcycsIFszOV1dLCBbJ0FwcGx5RnVuY3Rpb24nLCBbODI4OV1dLCBbJ2FwcHJveCcsIFs4Nzc2XV0sIFsnYXBwcm94ZXEnLCBbODc3OF1dLCBbJ0FyaW5nJywgWzE5N11dLCBbJ2FyaW5nJywgWzIyOV1dLCBbJ0FzY3InLCBbMTE5OTY0XV0sIFsnYXNjcicsIFsxMTk5OTBdXSwgWydBc3NpZ24nLCBbODc4OF1dLCBbJ2FzdCcsIFs0Ml1dLCBbJ2FzeW1wJywgWzg3NzZdXSwgWydhc3ltcGVxJywgWzg3ODFdXSwgWydBdGlsZGUnLCBbMTk1XV0sIFsnYXRpbGRlJywgWzIyN11dLCBbJ0F1bWwnLCBbMTk2XV0sIFsnYXVtbCcsIFsyMjhdXSwgWydhd2NvbmludCcsIFs4NzU1XV0sIFsnYXdpbnQnLCBbMTA3NjldXSwgWydiYWNrY29uZycsIFs4NzgwXV0sIFsnYmFja2Vwc2lsb24nLCBbMTAxNF1dLCBbJ2JhY2twcmltZScsIFs4MjQ1XV0sIFsnYmFja3NpbScsIFs4NzY1XV0sIFsnYmFja3NpbWVxJywgWzg5MDldXSwgWydCYWNrc2xhc2gnLCBbODcyNl1dLCBbJ0JhcnYnLCBbMTA5ODNdXSwgWydiYXJ2ZWUnLCBbODg5M11dLCBbJ2JhcndlZCcsIFs4OTY1XV0sIFsnQmFyd2VkJywgWzg5NjZdXSwgWydiYXJ3ZWRnZScsIFs4OTY1XV0sIFsnYmJyaycsIFs5MTQxXV0sIFsnYmJya3RicmsnLCBbOTE0Ml1dLCBbJ2Jjb25nJywgWzg3ODBdXSwgWydCY3knLCBbMTA0MV1dLCBbJ2JjeScsIFsxMDczXV0sIFsnYmRxdW8nLCBbODIyMl1dLCBbJ2JlY2F1cycsIFs4NzU3XV0sIFsnYmVjYXVzZScsIFs4NzU3XV0sIFsnQmVjYXVzZScsIFs4NzU3XV0sIFsnYmVtcHR5dicsIFsxMDY3Ml1dLCBbJ2JlcHNpJywgWzEwMTRdXSwgWydiZXJub3UnLCBbODQ5Ml1dLCBbJ0Jlcm5vdWxsaXMnLCBbODQ5Ml1dLCBbJ0JldGEnLCBbOTE0XV0sIFsnYmV0YScsIFs5NDZdXSwgWydiZXRoJywgWzg1MDJdXSwgWydiZXR3ZWVuJywgWzg4MTJdXSwgWydCZnInLCBbMTIwMDY5XV0sIFsnYmZyJywgWzEyMDA5NV1dLCBbJ2JpZ2NhcCcsIFs4ODk4XV0sIFsnYmlnY2lyYycsIFs5NzExXV0sIFsnYmlnY3VwJywgWzg4OTldXSwgWydiaWdvZG90JywgWzEwNzUyXV0sIFsnYmlnb3BsdXMnLCBbMTA3NTNdXSwgWydiaWdvdGltZXMnLCBbMTA3NTRdXSwgWydiaWdzcWN1cCcsIFsxMDc1OF1dLCBbJ2JpZ3N0YXInLCBbOTczM11dLCBbJ2JpZ3RyaWFuZ2xlZG93bicsIFs5NjYxXV0sIFsnYmlndHJpYW5nbGV1cCcsIFs5NjUxXV0sIFsnYmlndXBsdXMnLCBbMTA3NTZdXSwgWydiaWd2ZWUnLCBbODg5N11dLCBbJ2JpZ3dlZGdlJywgWzg4OTZdXSwgWydia2Fyb3cnLCBbMTA1MDldXSwgWydibGFja2xvemVuZ2UnLCBbMTA3MzFdXSwgWydibGFja3NxdWFyZScsIFs5NjQyXV0sIFsnYmxhY2t0cmlhbmdsZScsIFs5NjUyXV0sIFsnYmxhY2t0cmlhbmdsZWRvd24nLCBbOTY2Ml1dLCBbJ2JsYWNrdHJpYW5nbGVsZWZ0JywgWzk2NjZdXSwgWydibGFja3RyaWFuZ2xlcmlnaHQnLCBbOTY1Nl1dLCBbJ2JsYW5rJywgWzkyNTFdXSwgWydibGsxMicsIFs5NjE4XV0sIFsnYmxrMTQnLCBbOTYxN11dLCBbJ2JsazM0JywgWzk2MTldXSwgWydibG9jaycsIFs5NjA4XV0sIFsnYm5lJywgWzYxLCA4NDIxXV0sIFsnYm5lcXVpdicsIFs4ODAxLCA4NDIxXV0sIFsnYk5vdCcsIFsxMDk4OV1dLCBbJ2Jub3QnLCBbODk3Nl1dLCBbJ0JvcGYnLCBbMTIwMTIxXV0sIFsnYm9wZicsIFsxMjAxNDddXSwgWydib3QnLCBbODg2OV1dLCBbJ2JvdHRvbScsIFs4ODY5XV0sIFsnYm93dGllJywgWzg5MDRdXSwgWydib3hib3gnLCBbMTA2OTddXSwgWydib3hkbCcsIFs5NDg4XV0sIFsnYm94ZEwnLCBbOTU1N11dLCBbJ2JveERsJywgWzk1NThdXSwgWydib3hETCcsIFs5NTU5XV0sIFsnYm94ZHInLCBbOTQ4NF1dLCBbJ2JveGRSJywgWzk1NTRdXSwgWydib3hEcicsIFs5NTU1XV0sIFsnYm94RFInLCBbOTU1Nl1dLCBbJ2JveGgnLCBbOTQ3Ml1dLCBbJ2JveEgnLCBbOTU1Ml1dLCBbJ2JveGhkJywgWzk1MTZdXSwgWydib3hIZCcsIFs5NTcyXV0sIFsnYm94aEQnLCBbOTU3M11dLCBbJ2JveEhEJywgWzk1NzRdXSwgWydib3hodScsIFs5NTI0XV0sIFsnYm94SHUnLCBbOTU3NV1dLCBbJ2JveGhVJywgWzk1NzZdXSwgWydib3hIVScsIFs5NTc3XV0sIFsnYm94bWludXMnLCBbODg2M11dLCBbJ2JveHBsdXMnLCBbODg2Ml1dLCBbJ2JveHRpbWVzJywgWzg4NjRdXSwgWydib3h1bCcsIFs5NDk2XV0sIFsnYm94dUwnLCBbOTU2M11dLCBbJ2JveFVsJywgWzk1NjRdXSwgWydib3hVTCcsIFs5NTY1XV0sIFsnYm94dXInLCBbOTQ5Ml1dLCBbJ2JveHVSJywgWzk1NjBdXSwgWydib3hVcicsIFs5NTYxXV0sIFsnYm94VVInLCBbOTU2Ml1dLCBbJ2JveHYnLCBbOTQ3NF1dLCBbJ2JveFYnLCBbOTU1M11dLCBbJ2JveHZoJywgWzk1MzJdXSwgWydib3h2SCcsIFs5NTc4XV0sIFsnYm94VmgnLCBbOTU3OV1dLCBbJ2JveFZIJywgWzk1ODBdXSwgWydib3h2bCcsIFs5NTA4XV0sIFsnYm94dkwnLCBbOTU2OV1dLCBbJ2JveFZsJywgWzk1NzBdXSwgWydib3hWTCcsIFs5NTcxXV0sIFsnYm94dnInLCBbOTUwMF1dLCBbJ2JveHZSJywgWzk1NjZdXSwgWydib3hWcicsIFs5NTY3XV0sIFsnYm94VlInLCBbOTU2OF1dLCBbJ2JwcmltZScsIFs4MjQ1XV0sIFsnYnJldmUnLCBbNzI4XV0sIFsnQnJldmUnLCBbNzI4XV0sIFsnYnJ2YmFyJywgWzE2Nl1dLCBbJ2JzY3InLCBbMTE5OTkxXV0sIFsnQnNjcicsIFs4NDkyXV0sIFsnYnNlbWknLCBbODI3MV1dLCBbJ2JzaW0nLCBbODc2NV1dLCBbJ2JzaW1lJywgWzg5MDldXSwgWydic29sYicsIFsxMDY5M11dLCBbJ2Jzb2wnLCBbOTJdXSwgWydic29saHN1YicsIFsxMDE4NF1dLCBbJ2J1bGwnLCBbODIyNl1dLCBbJ2J1bGxldCcsIFs4MjI2XV0sIFsnYnVtcCcsIFs4NzgyXV0sIFsnYnVtcEUnLCBbMTA5MjZdXSwgWydidW1wZScsIFs4NzgzXV0sIFsnQnVtcGVxJywgWzg3ODJdXSwgWydidW1wZXEnLCBbODc4M11dLCBbJ0NhY3V0ZScsIFsyNjJdXSwgWydjYWN1dGUnLCBbMjYzXV0sIFsnY2FwYW5kJywgWzEwODIwXV0sIFsnY2FwYnJjdXAnLCBbMTA4MjVdXSwgWydjYXBjYXAnLCBbMTA4MjddXSwgWydjYXAnLCBbODc0NV1dLCBbJ0NhcCcsIFs4OTE0XV0sIFsnY2FwY3VwJywgWzEwODIzXV0sIFsnY2FwZG90JywgWzEwODE2XV0sIFsnQ2FwaXRhbERpZmZlcmVudGlhbEQnLCBbODUxN11dLCBbJ2NhcHMnLCBbODc0NSwgNjUwMjRdXSwgWydjYXJldCcsIFs4MjU3XV0sIFsnY2Fyb24nLCBbNzExXV0sIFsnQ2F5bGV5cycsIFs4NDkzXV0sIFsnY2NhcHMnLCBbMTA4MjldXSwgWydDY2Fyb24nLCBbMjY4XV0sIFsnY2Nhcm9uJywgWzI2OV1dLCBbJ0NjZWRpbCcsIFsxOTldXSwgWydjY2VkaWwnLCBbMjMxXV0sIFsnQ2NpcmMnLCBbMjY0XV0sIFsnY2NpcmMnLCBbMjY1XV0sIFsnQ2NvbmludCcsIFs4NzUyXV0sIFsnY2N1cHMnLCBbMTA4MjhdXSwgWydjY3Vwc3NtJywgWzEwODMyXV0sIFsnQ2RvdCcsIFsyNjZdXSwgWydjZG90JywgWzI2N11dLCBbJ2NlZGlsJywgWzE4NF1dLCBbJ0NlZGlsbGEnLCBbMTg0XV0sIFsnY2VtcHR5dicsIFsxMDY3NF1dLCBbJ2NlbnQnLCBbMTYyXV0sIFsnY2VudGVyZG90JywgWzE4M11dLCBbJ0NlbnRlckRvdCcsIFsxODNdXSwgWydjZnInLCBbMTIwMDk2XV0sIFsnQ2ZyJywgWzg0OTNdXSwgWydDSGN5JywgWzEwNjNdXSwgWydjaGN5JywgWzEwOTVdXSwgWydjaGVjaycsIFsxMDAwM11dLCBbJ2NoZWNrbWFyaycsIFsxMDAwM11dLCBbJ0NoaScsIFs5MzVdXSwgWydjaGknLCBbOTY3XV0sIFsnY2lyYycsIFs3MTBdXSwgWydjaXJjZXEnLCBbODc5MV1dLCBbJ2NpcmNsZWFycm93bGVmdCcsIFs4NjM0XV0sIFsnY2lyY2xlYXJyb3dyaWdodCcsIFs4NjM1XV0sIFsnY2lyY2xlZGFzdCcsIFs4ODU5XV0sIFsnY2lyY2xlZGNpcmMnLCBbODg1OF1dLCBbJ2NpcmNsZWRkYXNoJywgWzg4NjFdXSwgWydDaXJjbGVEb3QnLCBbODg1N11dLCBbJ2NpcmNsZWRSJywgWzE3NF1dLCBbJ2NpcmNsZWRTJywgWzk0MTZdXSwgWydDaXJjbGVNaW51cycsIFs4ODU0XV0sIFsnQ2lyY2xlUGx1cycsIFs4ODUzXV0sIFsnQ2lyY2xlVGltZXMnLCBbODg1NV1dLCBbJ2NpcicsIFs5Njc1XV0sIFsnY2lyRScsIFsxMDY5MV1dLCBbJ2NpcmUnLCBbODc5MV1dLCBbJ2NpcmZuaW50JywgWzEwNzY4XV0sIFsnY2lybWlkJywgWzEwOTkxXV0sIFsnY2lyc2NpcicsIFsxMDY5MF1dLCBbJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzU0XV0sIFsnY2x1YnMnLCBbOTgyN11dLCBbJ2NsdWJzdWl0JywgWzk4MjddXSwgWydjb2xvbicsIFs1OF1dLCBbJ0NvbG9uJywgWzg3NTldXSwgWydDb2xvbmUnLCBbMTA4NjhdXSwgWydjb2xvbmUnLCBbODc4OF1dLCBbJ2NvbG9uZXEnLCBbODc4OF1dLCBbJ2NvbW1hJywgWzQ0XV0sIFsnY29tbWF0JywgWzY0XV0sIFsnY29tcCcsIFs4NzA1XV0sIFsnY29tcGZuJywgWzg3MjhdXSwgWydjb21wbGVtZW50JywgWzg3MDVdXSwgWydjb21wbGV4ZXMnLCBbODQ1MF1dLCBbJ2NvbmcnLCBbODc3M11dLCBbJ2Nvbmdkb3QnLCBbMTA4NjFdXSwgWydDb25ncnVlbnQnLCBbODgwMV1dLCBbJ2NvbmludCcsIFs4NzUwXV0sIFsnQ29uaW50JywgWzg3NTFdXSwgWydDb250b3VySW50ZWdyYWwnLCBbODc1MF1dLCBbJ2NvcGYnLCBbMTIwMTQ4XV0sIFsnQ29wZicsIFs4NDUwXV0sIFsnY29wcm9kJywgWzg3MjBdXSwgWydDb3Byb2R1Y3QnLCBbODcyMF1dLCBbJ2NvcHknLCBbMTY5XV0sIFsnQ09QWScsIFsxNjldXSwgWydjb3B5c3InLCBbODQ3MV1dLCBbJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NV1dLCBbJ2NyYXJyJywgWzg2MjldXSwgWydjcm9zcycsIFsxMDAwN11dLCBbJ0Nyb3NzJywgWzEwNzk5XV0sIFsnQ3NjcicsIFsxMTk5NjZdXSwgWydjc2NyJywgWzExOTk5Ml1dLCBbJ2NzdWInLCBbMTA5NTldXSwgWydjc3ViZScsIFsxMDk2MV1dLCBbJ2NzdXAnLCBbMTA5NjBdXSwgWydjc3VwZScsIFsxMDk2Ml1dLCBbJ2N0ZG90JywgWzg5NDNdXSwgWydjdWRhcnJsJywgWzEwNTUyXV0sIFsnY3VkYXJycicsIFsxMDU0OV1dLCBbJ2N1ZXByJywgWzg5MjZdXSwgWydjdWVzYycsIFs4OTI3XV0sIFsnY3VsYXJyJywgWzg2MzBdXSwgWydjdWxhcnJwJywgWzEwNTU3XV0sIFsnY3VwYnJjYXAnLCBbMTA4MjRdXSwgWydjdXBjYXAnLCBbMTA4MjJdXSwgWydDdXBDYXAnLCBbODc4MV1dLCBbJ2N1cCcsIFs4NzQ2XV0sIFsnQ3VwJywgWzg5MTVdXSwgWydjdXBjdXAnLCBbMTA4MjZdXSwgWydjdXBkb3QnLCBbODg0NV1dLCBbJ2N1cG9yJywgWzEwODIxXV0sIFsnY3VwcycsIFs4NzQ2LCA2NTAyNF1dLCBbJ2N1cmFycicsIFs4NjMxXV0sIFsnY3VyYXJybScsIFsxMDU1Nl1dLCBbJ2N1cmx5ZXFwcmVjJywgWzg5MjZdXSwgWydjdXJseWVxc3VjYycsIFs4OTI3XV0sIFsnY3VybHl2ZWUnLCBbODkxMF1dLCBbJ2N1cmx5d2VkZ2UnLCBbODkxMV1dLCBbJ2N1cnJlbicsIFsxNjRdXSwgWydjdXJ2ZWFycm93bGVmdCcsIFs4NjMwXV0sIFsnY3VydmVhcnJvd3JpZ2h0JywgWzg2MzFdXSwgWydjdXZlZScsIFs4OTEwXV0sIFsnY3V3ZWQnLCBbODkxMV1dLCBbJ2N3Y29uaW50JywgWzg3NTRdXSwgWydjd2ludCcsIFs4NzUzXV0sIFsnY3lsY3R5JywgWzkwMDVdXSwgWydkYWdnZXInLCBbODIyNF1dLCBbJ0RhZ2dlcicsIFs4MjI1XV0sIFsnZGFsZXRoJywgWzg1MDRdXSwgWydkYXJyJywgWzg1OTVdXSwgWydEYXJyJywgWzg2MDldXSwgWydkQXJyJywgWzg2NTldXSwgWydkYXNoJywgWzgyMDhdXSwgWydEYXNodicsIFsxMDk4MF1dLCBbJ2Rhc2h2JywgWzg4NjddXSwgWydkYmthcm93JywgWzEwNTExXV0sIFsnZGJsYWMnLCBbNzMzXV0sIFsnRGNhcm9uJywgWzI3MF1dLCBbJ2RjYXJvbicsIFsyNzFdXSwgWydEY3knLCBbMTA0NF1dLCBbJ2RjeScsIFsxMDc2XV0sIFsnZGRhZ2dlcicsIFs4MjI1XV0sIFsnZGRhcnInLCBbODY1MF1dLCBbJ0REJywgWzg1MTddXSwgWydkZCcsIFs4NTE4XV0sIFsnRERvdHJhaGQnLCBbMTA1MTNdXSwgWydkZG90c2VxJywgWzEwODcxXV0sIFsnZGVnJywgWzE3Nl1dLCBbJ0RlbCcsIFs4NzExXV0sIFsnRGVsdGEnLCBbOTE2XV0sIFsnZGVsdGEnLCBbOTQ4XV0sIFsnZGVtcHR5dicsIFsxMDY3M11dLCBbJ2RmaXNodCcsIFsxMDYyM11dLCBbJ0RmcicsIFsxMjAwNzFdXSwgWydkZnInLCBbMTIwMDk3XV0sIFsnZEhhcicsIFsxMDU5N11dLCBbJ2RoYXJsJywgWzg2NDNdXSwgWydkaGFycicsIFs4NjQyXV0sIFsnRGlhY3JpdGljYWxBY3V0ZScsIFsxODBdXSwgWydEaWFjcml0aWNhbERvdCcsIFs3MjldXSwgWydEaWFjcml0aWNhbERvdWJsZUFjdXRlJywgWzczM11dLCBbJ0RpYWNyaXRpY2FsR3JhdmUnLCBbOTZdXSwgWydEaWFjcml0aWNhbFRpbGRlJywgWzczMl1dLCBbJ2RpYW0nLCBbODkwMF1dLCBbJ2RpYW1vbmQnLCBbODkwMF1dLCBbJ0RpYW1vbmQnLCBbODkwMF1dLCBbJ2RpYW1vbmRzdWl0JywgWzk4MzBdXSwgWydkaWFtcycsIFs5ODMwXV0sIFsnZGllJywgWzE2OF1dLCBbJ0RpZmZlcmVudGlhbEQnLCBbODUxOF1dLCBbJ2RpZ2FtbWEnLCBbOTg5XV0sIFsnZGlzaW4nLCBbODk0Nl1dLCBbJ2RpdicsIFsyNDddXSwgWydkaXZpZGUnLCBbMjQ3XV0sIFsnZGl2aWRlb250aW1lcycsIFs4OTAzXV0sIFsnZGl2b254JywgWzg5MDNdXSwgWydESmN5JywgWzEwMjZdXSwgWydkamN5JywgWzExMDZdXSwgWydkbGNvcm4nLCBbODk5MF1dLCBbJ2RsY3JvcCcsIFs4OTczXV0sIFsnZG9sbGFyJywgWzM2XV0sIFsnRG9wZicsIFsxMjAxMjNdXSwgWydkb3BmJywgWzEyMDE0OV1dLCBbJ0RvdCcsIFsxNjhdXSwgWydkb3QnLCBbNzI5XV0sIFsnRG90RG90JywgWzg0MTJdXSwgWydkb3RlcScsIFs4Nzg0XV0sIFsnZG90ZXFkb3QnLCBbODc4NV1dLCBbJ0RvdEVxdWFsJywgWzg3ODRdXSwgWydkb3RtaW51cycsIFs4NzYwXV0sIFsnZG90cGx1cycsIFs4NzI0XV0sIFsnZG90c3F1YXJlJywgWzg4NjVdXSwgWydkb3VibGViYXJ3ZWRnZScsIFs4OTY2XV0sIFsnRG91YmxlQ29udG91ckludGVncmFsJywgWzg3NTFdXSwgWydEb3VibGVEb3QnLCBbMTY4XV0sIFsnRG91YmxlRG93bkFycm93JywgWzg2NTldXSwgWydEb3VibGVMZWZ0QXJyb3cnLCBbODY1Nl1dLCBbJ0RvdWJsZUxlZnRSaWdodEFycm93JywgWzg2NjBdXSwgWydEb3VibGVMZWZ0VGVlJywgWzEwOTgwXV0sIFsnRG91YmxlTG9uZ0xlZnRBcnJvdycsIFsxMDIzMl1dLCBbJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdycsIFsxMDIzNF1dLCBbJ0RvdWJsZUxvbmdSaWdodEFycm93JywgWzEwMjMzXV0sIFsnRG91YmxlUmlnaHRBcnJvdycsIFs4NjU4XV0sIFsnRG91YmxlUmlnaHRUZWUnLCBbODg3Ml1dLCBbJ0RvdWJsZVVwQXJyb3cnLCBbODY1N11dLCBbJ0RvdWJsZVVwRG93bkFycm93JywgWzg2NjFdXSwgWydEb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQxXV0sIFsnRG93bkFycm93QmFyJywgWzEwNTE1XV0sIFsnZG93bmFycm93JywgWzg1OTVdXSwgWydEb3duQXJyb3cnLCBbODU5NV1dLCBbJ0Rvd25hcnJvdycsIFs4NjU5XV0sIFsnRG93bkFycm93VXBBcnJvdycsIFs4NjkzXV0sIFsnRG93bkJyZXZlJywgWzc4NV1dLCBbJ2Rvd25kb3duYXJyb3dzJywgWzg2NTBdXSwgWydkb3duaGFycG9vbmxlZnQnLCBbODY0M11dLCBbJ2Rvd25oYXJwb29ucmlnaHQnLCBbODY0Ml1dLCBbJ0Rvd25MZWZ0UmlnaHRWZWN0b3InLCBbMTA1NzZdXSwgWydEb3duTGVmdFRlZVZlY3RvcicsIFsxMDU5MF1dLCBbJ0Rvd25MZWZ0VmVjdG9yQmFyJywgWzEwNTgyXV0sIFsnRG93bkxlZnRWZWN0b3InLCBbODYzN11dLCBbJ0Rvd25SaWdodFRlZVZlY3RvcicsIFsxMDU5MV1dLCBbJ0Rvd25SaWdodFZlY3RvckJhcicsIFsxMDU4M11dLCBbJ0Rvd25SaWdodFZlY3RvcicsIFs4NjQxXV0sIFsnRG93blRlZUFycm93JywgWzg2MTVdXSwgWydEb3duVGVlJywgWzg4NjhdXSwgWydkcmJrYXJvdycsIFsxMDUxMl1dLCBbJ2RyY29ybicsIFs4OTkxXV0sIFsnZHJjcm9wJywgWzg5NzJdXSwgWydEc2NyJywgWzExOTk2N11dLCBbJ2RzY3InLCBbMTE5OTkzXV0sIFsnRFNjeScsIFsxMDI5XV0sIFsnZHNjeScsIFsxMTA5XV0sIFsnZHNvbCcsIFsxMDc0Ml1dLCBbJ0RzdHJvaycsIFsyNzJdXSwgWydkc3Ryb2snLCBbMjczXV0sIFsnZHRkb3QnLCBbODk0NV1dLCBbJ2R0cmknLCBbOTY2M11dLCBbJ2R0cmlmJywgWzk2NjJdXSwgWydkdWFycicsIFs4NjkzXV0sIFsnZHVoYXInLCBbMTA2MDddXSwgWydkd2FuZ2xlJywgWzEwNjYyXV0sIFsnRFpjeScsIFsxMDM5XV0sIFsnZHpjeScsIFsxMTE5XV0sIFsnZHppZ3JhcnInLCBbMTAyMzldXSwgWydFYWN1dGUnLCBbMjAxXV0sIFsnZWFjdXRlJywgWzIzM11dLCBbJ2Vhc3RlcicsIFsxMDg2Ml1dLCBbJ0VjYXJvbicsIFsyODJdXSwgWydlY2Fyb24nLCBbMjgzXV0sIFsnRWNpcmMnLCBbMjAyXV0sIFsnZWNpcmMnLCBbMjM0XV0sIFsnZWNpcicsIFs4NzkwXV0sIFsnZWNvbG9uJywgWzg3ODldXSwgWydFY3knLCBbMTA2OV1dLCBbJ2VjeScsIFsxMTAxXV0sIFsnZUREb3QnLCBbMTA4NzFdXSwgWydFZG90JywgWzI3OF1dLCBbJ2Vkb3QnLCBbMjc5XV0sIFsnZURvdCcsIFs4Nzg1XV0sIFsnZWUnLCBbODUxOV1dLCBbJ2VmRG90JywgWzg3ODZdXSwgWydFZnInLCBbMTIwMDcyXV0sIFsnZWZyJywgWzEyMDA5OF1dLCBbJ2VnJywgWzEwOTA2XV0sIFsnRWdyYXZlJywgWzIwMF1dLCBbJ2VncmF2ZScsIFsyMzJdXSwgWydlZ3MnLCBbMTA5MDJdXSwgWydlZ3Nkb3QnLCBbMTA5MDRdXSwgWydlbCcsIFsxMDkwNV1dLCBbJ0VsZW1lbnQnLCBbODcxMl1dLCBbJ2VsaW50ZXJzJywgWzkxOTFdXSwgWydlbGwnLCBbODQ2N11dLCBbJ2VscycsIFsxMDkwMV1dLCBbJ2Vsc2RvdCcsIFsxMDkwM11dLCBbJ0VtYWNyJywgWzI3NF1dLCBbJ2VtYWNyJywgWzI3NV1dLCBbJ2VtcHR5JywgWzg3MDldXSwgWydlbXB0eXNldCcsIFs4NzA5XV0sIFsnRW1wdHlTbWFsbFNxdWFyZScsIFs5NzIzXV0sIFsnZW1wdHl2JywgWzg3MDldXSwgWydFbXB0eVZlcnlTbWFsbFNxdWFyZScsIFs5NjQzXV0sIFsnZW1zcDEzJywgWzgxOTZdXSwgWydlbXNwMTQnLCBbODE5N11dLCBbJ2Vtc3AnLCBbODE5NV1dLCBbJ0VORycsIFszMzBdXSwgWydlbmcnLCBbMzMxXV0sIFsnZW5zcCcsIFs4MTk0XV0sIFsnRW9nb24nLCBbMjgwXV0sIFsnZW9nb24nLCBbMjgxXV0sIFsnRW9wZicsIFsxMjAxMjRdXSwgWydlb3BmJywgWzEyMDE1MF1dLCBbJ2VwYXInLCBbODkxN11dLCBbJ2VwYXJzbCcsIFsxMDcyM11dLCBbJ2VwbHVzJywgWzEwODY1XV0sIFsnZXBzaScsIFs5NDldXSwgWydFcHNpbG9uJywgWzkxN11dLCBbJ2Vwc2lsb24nLCBbOTQ5XV0sIFsnZXBzaXYnLCBbMTAxM11dLCBbJ2VxY2lyYycsIFs4NzkwXV0sIFsnZXFjb2xvbicsIFs4Nzg5XV0sIFsnZXFzaW0nLCBbODc3MF1dLCBbJ2Vxc2xhbnRndHInLCBbMTA5MDJdXSwgWydlcXNsYW50bGVzcycsIFsxMDkwMV1dLCBbJ0VxdWFsJywgWzEwODY5XV0sIFsnZXF1YWxzJywgWzYxXV0sIFsnRXF1YWxUaWxkZScsIFs4NzcwXV0sIFsnZXF1ZXN0JywgWzg3OTldXSwgWydFcXVpbGlicml1bScsIFs4NjUyXV0sIFsnZXF1aXYnLCBbODgwMV1dLCBbJ2VxdWl2REQnLCBbMTA4NzJdXSwgWydlcXZwYXJzbCcsIFsxMDcyNV1dLCBbJ2VyYXJyJywgWzEwNjA5XV0sIFsnZXJEb3QnLCBbODc4N11dLCBbJ2VzY3InLCBbODQ5NV1dLCBbJ0VzY3InLCBbODQ5Nl1dLCBbJ2VzZG90JywgWzg3ODRdXSwgWydFc2ltJywgWzEwODY3XV0sIFsnZXNpbScsIFs4NzcwXV0sIFsnRXRhJywgWzkxOV1dLCBbJ2V0YScsIFs5NTFdXSwgWydFVEgnLCBbMjA4XV0sIFsnZXRoJywgWzI0MF1dLCBbJ0V1bWwnLCBbMjAzXV0sIFsnZXVtbCcsIFsyMzVdXSwgWydldXJvJywgWzgzNjRdXSwgWydleGNsJywgWzMzXV0sIFsnZXhpc3QnLCBbODcwN11dLCBbJ0V4aXN0cycsIFs4NzA3XV0sIFsnZXhwZWN0YXRpb24nLCBbODQ5Nl1dLCBbJ2V4cG9uZW50aWFsZScsIFs4NTE5XV0sIFsnRXhwb25lbnRpYWxFJywgWzg1MTldXSwgWydmYWxsaW5nZG90c2VxJywgWzg3ODZdXSwgWydGY3knLCBbMTA2MF1dLCBbJ2ZjeScsIFsxMDkyXV0sIFsnZmVtYWxlJywgWzk3OTJdXSwgWydmZmlsaWcnLCBbNjQyNTldXSwgWydmZmxpZycsIFs2NDI1Nl1dLCBbJ2ZmbGxpZycsIFs2NDI2MF1dLCBbJ0ZmcicsIFsxMjAwNzNdXSwgWydmZnInLCBbMTIwMDk5XV0sIFsnZmlsaWcnLCBbNjQyNTddXSwgWydGaWxsZWRTbWFsbFNxdWFyZScsIFs5NzI0XV0sIFsnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJywgWzk2NDJdXSwgWydmamxpZycsIFsxMDIsIDEwNl1dLCBbJ2ZsYXQnLCBbOTgzN11dLCBbJ2ZsbGlnJywgWzY0MjU4XV0sIFsnZmx0bnMnLCBbOTY0OV1dLCBbJ2Zub2YnLCBbNDAyXV0sIFsnRm9wZicsIFsxMjAxMjVdXSwgWydmb3BmJywgWzEyMDE1MV1dLCBbJ2ZvcmFsbCcsIFs4NzA0XV0sIFsnRm9yQWxsJywgWzg3MDRdXSwgWydmb3JrJywgWzg5MTZdXSwgWydmb3JrdicsIFsxMDk2OV1dLCBbJ0ZvdXJpZXJ0cmYnLCBbODQ5N11dLCBbJ2ZwYXJ0aW50JywgWzEwNzY1XV0sIFsnZnJhYzEyJywgWzE4OV1dLCBbJ2ZyYWMxMycsIFs4NTMxXV0sIFsnZnJhYzE0JywgWzE4OF1dLCBbJ2ZyYWMxNScsIFs4NTMzXV0sIFsnZnJhYzE2JywgWzg1MzddXSwgWydmcmFjMTgnLCBbODUzOV1dLCBbJ2ZyYWMyMycsIFs4NTMyXV0sIFsnZnJhYzI1JywgWzg1MzRdXSwgWydmcmFjMzQnLCBbMTkwXV0sIFsnZnJhYzM1JywgWzg1MzVdXSwgWydmcmFjMzgnLCBbODU0MF1dLCBbJ2ZyYWM0NScsIFs4NTM2XV0sIFsnZnJhYzU2JywgWzg1MzhdXSwgWydmcmFjNTgnLCBbODU0MV1dLCBbJ2ZyYWM3OCcsIFs4NTQyXV0sIFsnZnJhc2wnLCBbODI2MF1dLCBbJ2Zyb3duJywgWzg5OTRdXSwgWydmc2NyJywgWzExOTk5NV1dLCBbJ0ZzY3InLCBbODQ5N11dLCBbJ2dhY3V0ZScsIFs1MDFdXSwgWydHYW1tYScsIFs5MTVdXSwgWydnYW1tYScsIFs5NDddXSwgWydHYW1tYWQnLCBbOTg4XV0sIFsnZ2FtbWFkJywgWzk4OV1dLCBbJ2dhcCcsIFsxMDg4Nl1dLCBbJ0dicmV2ZScsIFsyODZdXSwgWydnYnJldmUnLCBbMjg3XV0sIFsnR2NlZGlsJywgWzI5MF1dLCBbJ0djaXJjJywgWzI4NF1dLCBbJ2djaXJjJywgWzI4NV1dLCBbJ0djeScsIFsxMDQzXV0sIFsnZ2N5JywgWzEwNzVdXSwgWydHZG90JywgWzI4OF1dLCBbJ2dkb3QnLCBbMjg5XV0sIFsnZ2UnLCBbODgwNV1dLCBbJ2dFJywgWzg4MDddXSwgWydnRWwnLCBbMTA4OTJdXSwgWydnZWwnLCBbODkyM11dLCBbJ2dlcScsIFs4ODA1XV0sIFsnZ2VxcScsIFs4ODA3XV0sIFsnZ2Vxc2xhbnQnLCBbMTA4NzhdXSwgWydnZXNjYycsIFsxMDkyMV1dLCBbJ2dlcycsIFsxMDg3OF1dLCBbJ2dlc2RvdCcsIFsxMDg4MF1dLCBbJ2dlc2RvdG8nLCBbMTA4ODJdXSwgWydnZXNkb3RvbCcsIFsxMDg4NF1dLCBbJ2dlc2wnLCBbODkyMywgNjUwMjRdXSwgWydnZXNsZXMnLCBbMTA5MDBdXSwgWydHZnInLCBbMTIwMDc0XV0sIFsnZ2ZyJywgWzEyMDEwMF1dLCBbJ2dnJywgWzg4MTFdXSwgWydHZycsIFs4OTIxXV0sIFsnZ2dnJywgWzg5MjFdXSwgWydnaW1lbCcsIFs4NTAzXV0sIFsnR0pjeScsIFsxMDI3XV0sIFsnZ2pjeScsIFsxMTA3XV0sIFsnZ2xhJywgWzEwOTE3XV0sIFsnZ2wnLCBbODgyM11dLCBbJ2dsRScsIFsxMDg5OF1dLCBbJ2dsaicsIFsxMDkxNl1dLCBbJ2duYXAnLCBbMTA4OTBdXSwgWydnbmFwcHJveCcsIFsxMDg5MF1dLCBbJ2duZScsIFsxMDg4OF1dLCBbJ2duRScsIFs4ODA5XV0sIFsnZ25lcScsIFsxMDg4OF1dLCBbJ2duZXFxJywgWzg4MDldXSwgWydnbnNpbScsIFs4OTM1XV0sIFsnR29wZicsIFsxMjAxMjZdXSwgWydnb3BmJywgWzEyMDE1Ml1dLCBbJ2dyYXZlJywgWzk2XV0sIFsnR3JlYXRlckVxdWFsJywgWzg4MDVdXSwgWydHcmVhdGVyRXF1YWxMZXNzJywgWzg5MjNdXSwgWydHcmVhdGVyRnVsbEVxdWFsJywgWzg4MDddXSwgWydHcmVhdGVyR3JlYXRlcicsIFsxMDkxNF1dLCBbJ0dyZWF0ZXJMZXNzJywgWzg4MjNdXSwgWydHcmVhdGVyU2xhbnRFcXVhbCcsIFsxMDg3OF1dLCBbJ0dyZWF0ZXJUaWxkZScsIFs4ODE5XV0sIFsnR3NjcicsIFsxMTk5NzBdXSwgWydnc2NyJywgWzg0NThdXSwgWydnc2ltJywgWzg4MTldXSwgWydnc2ltZScsIFsxMDg5NF1dLCBbJ2dzaW1sJywgWzEwODk2XV0sIFsnZ3RjYycsIFsxMDkxOV1dLCBbJ2d0Y2lyJywgWzEwODc0XV0sIFsnZ3QnLCBbNjJdXSwgWydHVCcsIFs2Ml1dLCBbJ0d0JywgWzg4MTFdXSwgWydndGRvdCcsIFs4OTE5XV0sIFsnZ3RsUGFyJywgWzEwNjQ1XV0sIFsnZ3RxdWVzdCcsIFsxMDg3Nl1dLCBbJ2d0cmFwcHJveCcsIFsxMDg4Nl1dLCBbJ2d0cmFycicsIFsxMDYxNl1dLCBbJ2d0cmRvdCcsIFs4OTE5XV0sIFsnZ3RyZXFsZXNzJywgWzg5MjNdXSwgWydndHJlcXFsZXNzJywgWzEwODkyXV0sIFsnZ3RybGVzcycsIFs4ODIzXV0sIFsnZ3Ryc2ltJywgWzg4MTldXSwgWydndmVydG5lcXEnLCBbODgwOSwgNjUwMjRdXSwgWydndm5FJywgWzg4MDksIDY1MDI0XV0sIFsnSGFjZWsnLCBbNzExXV0sIFsnaGFpcnNwJywgWzgyMDJdXSwgWydoYWxmJywgWzE4OV1dLCBbJ2hhbWlsdCcsIFs4NDU5XV0sIFsnSEFSRGN5JywgWzEwNjZdXSwgWydoYXJkY3knLCBbMTA5OF1dLCBbJ2hhcnJjaXInLCBbMTA1NjhdXSwgWydoYXJyJywgWzg1OTZdXSwgWydoQXJyJywgWzg2NjBdXSwgWydoYXJydycsIFs4NjIxXV0sIFsnSGF0JywgWzk0XV0sIFsnaGJhcicsIFs4NDYzXV0sIFsnSGNpcmMnLCBbMjkyXV0sIFsnaGNpcmMnLCBbMjkzXV0sIFsnaGVhcnRzJywgWzk4MjldXSwgWydoZWFydHN1aXQnLCBbOTgyOV1dLCBbJ2hlbGxpcCcsIFs4MjMwXV0sIFsnaGVyY29uJywgWzg4ODldXSwgWydoZnInLCBbMTIwMTAxXV0sIFsnSGZyJywgWzg0NjBdXSwgWydIaWxiZXJ0U3BhY2UnLCBbODQ1OV1dLCBbJ2hrc2Vhcm93JywgWzEwNTMzXV0sIFsnaGtzd2Fyb3cnLCBbMTA1MzRdXSwgWydob2FycicsIFs4NzAzXV0sIFsnaG9tdGh0JywgWzg3NjNdXSwgWydob29rbGVmdGFycm93JywgWzg2MTddXSwgWydob29rcmlnaHRhcnJvdycsIFs4NjE4XV0sIFsnaG9wZicsIFsxMjAxNTNdXSwgWydIb3BmJywgWzg0NjFdXSwgWydob3JiYXInLCBbODIxM11dLCBbJ0hvcml6b250YWxMaW5lJywgWzk0NzJdXSwgWydoc2NyJywgWzExOTk5N11dLCBbJ0hzY3InLCBbODQ1OV1dLCBbJ2hzbGFzaCcsIFs4NDYzXV0sIFsnSHN0cm9rJywgWzI5NF1dLCBbJ2hzdHJvaycsIFsyOTVdXSwgWydIdW1wRG93bkh1bXAnLCBbODc4Ml1dLCBbJ0h1bXBFcXVhbCcsIFs4NzgzXV0sIFsnaHlidWxsJywgWzgyNTldXSwgWydoeXBoZW4nLCBbODIwOF1dLCBbJ0lhY3V0ZScsIFsyMDVdXSwgWydpYWN1dGUnLCBbMjM3XV0sIFsnaWMnLCBbODI5MV1dLCBbJ0ljaXJjJywgWzIwNl1dLCBbJ2ljaXJjJywgWzIzOF1dLCBbJ0ljeScsIFsxMDQ4XV0sIFsnaWN5JywgWzEwODBdXSwgWydJZG90JywgWzMwNF1dLCBbJ0lFY3knLCBbMTA0NV1dLCBbJ2llY3knLCBbMTA3N11dLCBbJ2lleGNsJywgWzE2MV1dLCBbJ2lmZicsIFs4NjYwXV0sIFsnaWZyJywgWzEyMDEwMl1dLCBbJ0lmcicsIFs4NDY1XV0sIFsnSWdyYXZlJywgWzIwNF1dLCBbJ2lncmF2ZScsIFsyMzZdXSwgWydpaScsIFs4NTIwXV0sIFsnaWlpaW50JywgWzEwNzY0XV0sIFsnaWlpbnQnLCBbODc0OV1dLCBbJ2lpbmZpbicsIFsxMDcxNl1dLCBbJ2lpb3RhJywgWzg0ODldXSwgWydJSmxpZycsIFszMDZdXSwgWydpamxpZycsIFszMDddXSwgWydJbWFjcicsIFsyOThdXSwgWydpbWFjcicsIFsyOTldXSwgWydpbWFnZScsIFs4NDY1XV0sIFsnSW1hZ2luYXJ5SScsIFs4NTIwXV0sIFsnaW1hZ2xpbmUnLCBbODQ2NF1dLCBbJ2ltYWdwYXJ0JywgWzg0NjVdXSwgWydpbWF0aCcsIFszMDVdXSwgWydJbScsIFs4NDY1XV0sIFsnaW1vZicsIFs4ODg3XV0sIFsnaW1wZWQnLCBbNDM3XV0sIFsnSW1wbGllcycsIFs4NjU4XV0sIFsnaW5jYXJlJywgWzg0NTNdXSwgWydpbicsIFs4NzEyXV0sIFsnaW5maW4nLCBbODczNF1dLCBbJ2luZmludGllJywgWzEwNzE3XV0sIFsnaW5vZG90JywgWzMwNV1dLCBbJ2ludGNhbCcsIFs4ODkwXV0sIFsnaW50JywgWzg3NDddXSwgWydJbnQnLCBbODc0OF1dLCBbJ2ludGVnZXJzJywgWzg0ODRdXSwgWydJbnRlZ3JhbCcsIFs4NzQ3XV0sIFsnaW50ZXJjYWwnLCBbODg5MF1dLCBbJ0ludGVyc2VjdGlvbicsIFs4ODk4XV0sIFsnaW50bGFyaGsnLCBbMTA3NzVdXSwgWydpbnRwcm9kJywgWzEwODEyXV0sIFsnSW52aXNpYmxlQ29tbWEnLCBbODI5MV1dLCBbJ0ludmlzaWJsZVRpbWVzJywgWzgyOTBdXSwgWydJT2N5JywgWzEwMjVdXSwgWydpb2N5JywgWzExMDVdXSwgWydJb2dvbicsIFszMDJdXSwgWydpb2dvbicsIFszMDNdXSwgWydJb3BmJywgWzEyMDEyOF1dLCBbJ2lvcGYnLCBbMTIwMTU0XV0sIFsnSW90YScsIFs5MjFdXSwgWydpb3RhJywgWzk1M11dLCBbJ2lwcm9kJywgWzEwODEyXV0sIFsnaXF1ZXN0JywgWzE5MV1dLCBbJ2lzY3InLCBbMTE5OTk4XV0sIFsnSXNjcicsIFs4NDY0XV0sIFsnaXNpbicsIFs4NzEyXV0sIFsnaXNpbmRvdCcsIFs4OTQ5XV0sIFsnaXNpbkUnLCBbODk1M11dLCBbJ2lzaW5zJywgWzg5NDhdXSwgWydpc2luc3YnLCBbODk0N11dLCBbJ2lzaW52JywgWzg3MTJdXSwgWydpdCcsIFs4MjkwXV0sIFsnSXRpbGRlJywgWzI5Nl1dLCBbJ2l0aWxkZScsIFsyOTddXSwgWydJdWtjeScsIFsxMDMwXV0sIFsnaXVrY3knLCBbMTExMF1dLCBbJ0l1bWwnLCBbMjA3XV0sIFsnaXVtbCcsIFsyMzldXSwgWydKY2lyYycsIFszMDhdXSwgWydqY2lyYycsIFszMDldXSwgWydKY3knLCBbMTA0OV1dLCBbJ2pjeScsIFsxMDgxXV0sIFsnSmZyJywgWzEyMDA3N11dLCBbJ2pmcicsIFsxMjAxMDNdXSwgWydqbWF0aCcsIFs1NjddXSwgWydKb3BmJywgWzEyMDEyOV1dLCBbJ2pvcGYnLCBbMTIwMTU1XV0sIFsnSnNjcicsIFsxMTk5NzNdXSwgWydqc2NyJywgWzExOTk5OV1dLCBbJ0pzZXJjeScsIFsxMDMyXV0sIFsnanNlcmN5JywgWzExMTJdXSwgWydKdWtjeScsIFsxMDI4XV0sIFsnanVrY3knLCBbMTEwOF1dLCBbJ0thcHBhJywgWzkyMl1dLCBbJ2thcHBhJywgWzk1NF1dLCBbJ2thcHBhdicsIFsxMDA4XV0sIFsnS2NlZGlsJywgWzMxMF1dLCBbJ2tjZWRpbCcsIFszMTFdXSwgWydLY3knLCBbMTA1MF1dLCBbJ2tjeScsIFsxMDgyXV0sIFsnS2ZyJywgWzEyMDA3OF1dLCBbJ2tmcicsIFsxMjAxMDRdXSwgWydrZ3JlZW4nLCBbMzEyXV0sIFsnS0hjeScsIFsxMDYxXV0sIFsna2hjeScsIFsxMDkzXV0sIFsnS0pjeScsIFsxMDM2XV0sIFsna2pjeScsIFsxMTE2XV0sIFsnS29wZicsIFsxMjAxMzBdXSwgWydrb3BmJywgWzEyMDE1Nl1dLCBbJ0tzY3InLCBbMTE5OTc0XV0sIFsna3NjcicsIFsxMjAwMDBdXSwgWydsQWFycicsIFs4NjY2XV0sIFsnTGFjdXRlJywgWzMxM11dLCBbJ2xhY3V0ZScsIFszMTRdXSwgWydsYWVtcHR5dicsIFsxMDY3Nl1dLCBbJ2xhZ3JhbicsIFs4NDY2XV0sIFsnTGFtYmRhJywgWzkyM11dLCBbJ2xhbWJkYScsIFs5NTVdXSwgWydsYW5nJywgWzEwMjE2XV0sIFsnTGFuZycsIFsxMDIxOF1dLCBbJ2xhbmdkJywgWzEwNjQxXV0sIFsnbGFuZ2xlJywgWzEwMjE2XV0sIFsnbGFwJywgWzEwODg1XV0sIFsnTGFwbGFjZXRyZicsIFs4NDY2XV0sIFsnbGFxdW8nLCBbMTcxXV0sIFsnbGFycmInLCBbODY3Nl1dLCBbJ2xhcnJiZnMnLCBbMTA1MjddXSwgWydsYXJyJywgWzg1OTJdXSwgWydMYXJyJywgWzg2MDZdXSwgWydsQXJyJywgWzg2NTZdXSwgWydsYXJyZnMnLCBbMTA1MjVdXSwgWydsYXJyaGsnLCBbODYxN11dLCBbJ2xhcnJscCcsIFs4NjE5XV0sIFsnbGFycnBsJywgWzEwNTUzXV0sIFsnbGFycnNpbScsIFsxMDYxMV1dLCBbJ2xhcnJ0bCcsIFs4NjEwXV0sIFsnbGF0YWlsJywgWzEwNTIxXV0sIFsnbEF0YWlsJywgWzEwNTIzXV0sIFsnbGF0JywgWzEwOTIzXV0sIFsnbGF0ZScsIFsxMDkyNV1dLCBbJ2xhdGVzJywgWzEwOTI1LCA2NTAyNF1dLCBbJ2xiYXJyJywgWzEwNTA4XV0sIFsnbEJhcnInLCBbMTA1MTBdXSwgWydsYmJyaycsIFsxMDA5OF1dLCBbJ2xicmFjZScsIFsxMjNdXSwgWydsYnJhY2snLCBbOTFdXSwgWydsYnJrZScsIFsxMDYzNV1dLCBbJ2xicmtzbGQnLCBbMTA2MzldXSwgWydsYnJrc2x1JywgWzEwNjM3XV0sIFsnTGNhcm9uJywgWzMxN11dLCBbJ2xjYXJvbicsIFszMThdXSwgWydMY2VkaWwnLCBbMzE1XV0sIFsnbGNlZGlsJywgWzMxNl1dLCBbJ2xjZWlsJywgWzg5NjhdXSwgWydsY3ViJywgWzEyM11dLCBbJ0xjeScsIFsxMDUxXV0sIFsnbGN5JywgWzEwODNdXSwgWydsZGNhJywgWzEwNTUwXV0sIFsnbGRxdW8nLCBbODIyMF1dLCBbJ2xkcXVvcicsIFs4MjIyXV0sIFsnbGRyZGhhcicsIFsxMDU5OV1dLCBbJ2xkcnVzaGFyJywgWzEwNTcxXV0sIFsnbGRzaCcsIFs4NjI2XV0sIFsnbGUnLCBbODgwNF1dLCBbJ2xFJywgWzg4MDZdXSwgWydMZWZ0QW5nbGVCcmFja2V0JywgWzEwMjE2XV0sIFsnTGVmdEFycm93QmFyJywgWzg2NzZdXSwgWydsZWZ0YXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRBcnJvdycsIFs4NTkyXV0sIFsnTGVmdGFycm93JywgWzg2NTZdXSwgWydMZWZ0QXJyb3dSaWdodEFycm93JywgWzg2NDZdXSwgWydsZWZ0YXJyb3d0YWlsJywgWzg2MTBdXSwgWydMZWZ0Q2VpbGluZycsIFs4OTY4XV0sIFsnTGVmdERvdWJsZUJyYWNrZXQnLCBbMTAyMTRdXSwgWydMZWZ0RG93blRlZVZlY3RvcicsIFsxMDU5M11dLCBbJ0xlZnREb3duVmVjdG9yQmFyJywgWzEwNTg1XV0sIFsnTGVmdERvd25WZWN0b3InLCBbODY0M11dLCBbJ0xlZnRGbG9vcicsIFs4OTcwXV0sIFsnbGVmdGhhcnBvb25kb3duJywgWzg2MzddXSwgWydsZWZ0aGFycG9vbnVwJywgWzg2MzZdXSwgWydsZWZ0bGVmdGFycm93cycsIFs4NjQ3XV0sIFsnbGVmdHJpZ2h0YXJyb3cnLCBbODU5Nl1dLCBbJ0xlZnRSaWdodEFycm93JywgWzg1OTZdXSwgWydMZWZ0cmlnaHRhcnJvdycsIFs4NjYwXV0sIFsnbGVmdHJpZ2h0YXJyb3dzJywgWzg2NDZdXSwgWydsZWZ0cmlnaHRoYXJwb29ucycsIFs4NjUxXV0sIFsnbGVmdHJpZ2h0c3F1aWdhcnJvdycsIFs4NjIxXV0sIFsnTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc0XV0sIFsnTGVmdFRlZUFycm93JywgWzg2MTJdXSwgWydMZWZ0VGVlJywgWzg4NjddXSwgWydMZWZ0VGVlVmVjdG9yJywgWzEwNTg2XV0sIFsnbGVmdHRocmVldGltZXMnLCBbODkwN11dLCBbJ0xlZnRUcmlhbmdsZUJhcicsIFsxMDcwM11dLCBbJ0xlZnRUcmlhbmdsZScsIFs4ODgyXV0sIFsnTGVmdFRyaWFuZ2xlRXF1YWwnLCBbODg4NF1dLCBbJ0xlZnRVcERvd25WZWN0b3InLCBbMTA1NzddXSwgWydMZWZ0VXBUZWVWZWN0b3InLCBbMTA1OTJdXSwgWydMZWZ0VXBWZWN0b3JCYXInLCBbMTA1ODRdXSwgWydMZWZ0VXBWZWN0b3InLCBbODYzOV1dLCBbJ0xlZnRWZWN0b3JCYXInLCBbMTA1NzhdXSwgWydMZWZ0VmVjdG9yJywgWzg2MzZdXSwgWydsRWcnLCBbMTA4OTFdXSwgWydsZWcnLCBbODkyMl1dLCBbJ2xlcScsIFs4ODA0XV0sIFsnbGVxcScsIFs4ODA2XV0sIFsnbGVxc2xhbnQnLCBbMTA4NzddXSwgWydsZXNjYycsIFsxMDkyMF1dLCBbJ2xlcycsIFsxMDg3N11dLCBbJ2xlc2RvdCcsIFsxMDg3OV1dLCBbJ2xlc2RvdG8nLCBbMTA4ODFdXSwgWydsZXNkb3RvcicsIFsxMDg4M11dLCBbJ2xlc2cnLCBbODkyMiwgNjUwMjRdXSwgWydsZXNnZXMnLCBbMTA4OTldXSwgWydsZXNzYXBwcm94JywgWzEwODg1XV0sIFsnbGVzc2RvdCcsIFs4OTE4XV0sIFsnbGVzc2VxZ3RyJywgWzg5MjJdXSwgWydsZXNzZXFxZ3RyJywgWzEwODkxXV0sIFsnTGVzc0VxdWFsR3JlYXRlcicsIFs4OTIyXV0sIFsnTGVzc0Z1bGxFcXVhbCcsIFs4ODA2XV0sIFsnTGVzc0dyZWF0ZXInLCBbODgyMl1dLCBbJ2xlc3NndHInLCBbODgyMl1dLCBbJ0xlc3NMZXNzJywgWzEwOTEzXV0sIFsnbGVzc3NpbScsIFs4ODE4XV0sIFsnTGVzc1NsYW50RXF1YWwnLCBbMTA4NzddXSwgWydMZXNzVGlsZGUnLCBbODgxOF1dLCBbJ2xmaXNodCcsIFsxMDYyMF1dLCBbJ2xmbG9vcicsIFs4OTcwXV0sIFsnTGZyJywgWzEyMDA3OV1dLCBbJ2xmcicsIFsxMjAxMDVdXSwgWydsZycsIFs4ODIyXV0sIFsnbGdFJywgWzEwODk3XV0sIFsnbEhhcicsIFsxMDU5NF1dLCBbJ2xoYXJkJywgWzg2MzddXSwgWydsaGFydScsIFs4NjM2XV0sIFsnbGhhcnVsJywgWzEwNjAyXV0sIFsnbGhibGsnLCBbOTYwNF1dLCBbJ0xKY3knLCBbMTAzM11dLCBbJ2xqY3knLCBbMTExM11dLCBbJ2xsYXJyJywgWzg2NDddXSwgWydsbCcsIFs4ODEwXV0sIFsnTGwnLCBbODkyMF1dLCBbJ2xsY29ybmVyJywgWzg5OTBdXSwgWydMbGVmdGFycm93JywgWzg2NjZdXSwgWydsbGhhcmQnLCBbMTA2MDNdXSwgWydsbHRyaScsIFs5NzIyXV0sIFsnTG1pZG90JywgWzMxOV1dLCBbJ2xtaWRvdCcsIFszMjBdXSwgWydsbW91c3RhY2hlJywgWzkxMzZdXSwgWydsbW91c3QnLCBbOTEzNl1dLCBbJ2xuYXAnLCBbMTA4ODldXSwgWydsbmFwcHJveCcsIFsxMDg4OV1dLCBbJ2xuZScsIFsxMDg4N11dLCBbJ2xuRScsIFs4ODA4XV0sIFsnbG5lcScsIFsxMDg4N11dLCBbJ2xuZXFxJywgWzg4MDhdXSwgWydsbnNpbScsIFs4OTM0XV0sIFsnbG9hbmcnLCBbMTAyMjBdXSwgWydsb2FycicsIFs4NzAxXV0sIFsnbG9icmsnLCBbMTAyMTRdXSwgWydsb25nbGVmdGFycm93JywgWzEwMjI5XV0sIFsnTG9uZ0xlZnRBcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdsZWZ0YXJyb3cnLCBbMTAyMzJdXSwgWydsb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzFdXSwgWydMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzFdXSwgWydMb25nbGVmdHJpZ2h0YXJyb3cnLCBbMTAyMzRdXSwgWydsb25nbWFwc3RvJywgWzEwMjM2XV0sIFsnbG9uZ3JpZ2h0YXJyb3cnLCBbMTAyMzBdXSwgWydMb25nUmlnaHRBcnJvdycsIFsxMDIzMF1dLCBbJ0xvbmdyaWdodGFycm93JywgWzEwMjMzXV0sIFsnbG9vcGFycm93bGVmdCcsIFs4NjE5XV0sIFsnbG9vcGFycm93cmlnaHQnLCBbODYyMF1dLCBbJ2xvcGFyJywgWzEwNjI5XV0sIFsnTG9wZicsIFsxMjAxMzFdXSwgWydsb3BmJywgWzEyMDE1N11dLCBbJ2xvcGx1cycsIFsxMDc5N11dLCBbJ2xvdGltZXMnLCBbMTA4MDRdXSwgWydsb3dhc3QnLCBbODcyN11dLCBbJ2xvd2JhcicsIFs5NV1dLCBbJ0xvd2VyTGVmdEFycm93JywgWzg2MDFdXSwgWydMb3dlclJpZ2h0QXJyb3cnLCBbODYwMF1dLCBbJ2xveicsIFs5Njc0XV0sIFsnbG96ZW5nZScsIFs5Njc0XV0sIFsnbG96ZicsIFsxMDczMV1dLCBbJ2xwYXInLCBbNDBdXSwgWydscGFybHQnLCBbMTA2NDNdXSwgWydscmFycicsIFs4NjQ2XV0sIFsnbHJjb3JuZXInLCBbODk5MV1dLCBbJ2xyaGFyJywgWzg2NTFdXSwgWydscmhhcmQnLCBbMTA2MDVdXSwgWydscm0nLCBbODIwNl1dLCBbJ2xydHJpJywgWzg4OTVdXSwgWydsc2FxdW8nLCBbODI0OV1dLCBbJ2xzY3InLCBbMTIwMDAxXV0sIFsnTHNjcicsIFs4NDY2XV0sIFsnbHNoJywgWzg2MjRdXSwgWydMc2gnLCBbODYyNF1dLCBbJ2xzaW0nLCBbODgxOF1dLCBbJ2xzaW1lJywgWzEwODkzXV0sIFsnbHNpbWcnLCBbMTA4OTVdXSwgWydsc3FiJywgWzkxXV0sIFsnbHNxdW8nLCBbODIxNl1dLCBbJ2xzcXVvcicsIFs4MjE4XV0sIFsnTHN0cm9rJywgWzMyMV1dLCBbJ2xzdHJvaycsIFszMjJdXSwgWydsdGNjJywgWzEwOTE4XV0sIFsnbHRjaXInLCBbMTA4NzNdXSwgWydsdCcsIFs2MF1dLCBbJ0xUJywgWzYwXV0sIFsnTHQnLCBbODgxMF1dLCBbJ2x0ZG90JywgWzg5MThdXSwgWydsdGhyZWUnLCBbODkwN11dLCBbJ2x0aW1lcycsIFs4OTA1XV0sIFsnbHRsYXJyJywgWzEwNjE0XV0sIFsnbHRxdWVzdCcsIFsxMDg3NV1dLCBbJ2x0cmknLCBbOTY2N11dLCBbJ2x0cmllJywgWzg4ODRdXSwgWydsdHJpZicsIFs5NjY2XV0sIFsnbHRyUGFyJywgWzEwNjQ2XV0sIFsnbHVyZHNoYXInLCBbMTA1NzBdXSwgWydsdXJ1aGFyJywgWzEwNTk4XV0sIFsnbHZlcnRuZXFxJywgWzg4MDgsIDY1MDI0XV0sIFsnbHZuRScsIFs4ODA4LCA2NTAyNF1dLCBbJ21hY3InLCBbMTc1XV0sIFsnbWFsZScsIFs5Nzk0XV0sIFsnbWFsdCcsIFsxMDAxNl1dLCBbJ21hbHRlc2UnLCBbMTAwMTZdXSwgWydNYXAnLCBbMTA1MDFdXSwgWydtYXAnLCBbODYxNF1dLCBbJ21hcHN0bycsIFs4NjE0XV0sIFsnbWFwc3RvZG93bicsIFs4NjE1XV0sIFsnbWFwc3RvbGVmdCcsIFs4NjEyXV0sIFsnbWFwc3RvdXAnLCBbODYxM11dLCBbJ21hcmtlcicsIFs5NjQ2XV0sIFsnbWNvbW1hJywgWzEwNzkzXV0sIFsnTWN5JywgWzEwNTJdXSwgWydtY3knLCBbMTA4NF1dLCBbJ21kYXNoJywgWzgyMTJdXSwgWydtRERvdCcsIFs4NzYyXV0sIFsnbWVhc3VyZWRhbmdsZScsIFs4NzM3XV0sIFsnTWVkaXVtU3BhY2UnLCBbODI4N11dLCBbJ01lbGxpbnRyZicsIFs4NDk5XV0sIFsnTWZyJywgWzEyMDA4MF1dLCBbJ21mcicsIFsxMjAxMDZdXSwgWydtaG8nLCBbODQ4N11dLCBbJ21pY3JvJywgWzE4MV1dLCBbJ21pZGFzdCcsIFs0Ml1dLCBbJ21pZGNpcicsIFsxMDk5Ml1dLCBbJ21pZCcsIFs4NzM5XV0sIFsnbWlkZG90JywgWzE4M11dLCBbJ21pbnVzYicsIFs4ODYzXV0sIFsnbWludXMnLCBbODcyMl1dLCBbJ21pbnVzZCcsIFs4NzYwXV0sIFsnbWludXNkdScsIFsxMDc5NF1dLCBbJ01pbnVzUGx1cycsIFs4NzIzXV0sIFsnbWxjcCcsIFsxMDk3MV1dLCBbJ21sZHInLCBbODIzMF1dLCBbJ21ucGx1cycsIFs4NzIzXV0sIFsnbW9kZWxzJywgWzg4NzFdXSwgWydNb3BmJywgWzEyMDEzMl1dLCBbJ21vcGYnLCBbMTIwMTU4XV0sIFsnbXAnLCBbODcyM11dLCBbJ21zY3InLCBbMTIwMDAyXV0sIFsnTXNjcicsIFs4NDk5XV0sIFsnbXN0cG9zJywgWzg3NjZdXSwgWydNdScsIFs5MjRdXSwgWydtdScsIFs5NTZdXSwgWydtdWx0aW1hcCcsIFs4ODg4XV0sIFsnbXVtYXAnLCBbODg4OF1dLCBbJ25hYmxhJywgWzg3MTFdXSwgWydOYWN1dGUnLCBbMzIzXV0sIFsnbmFjdXRlJywgWzMyNF1dLCBbJ25hbmcnLCBbODczNiwgODQwMl1dLCBbJ25hcCcsIFs4Nzc3XV0sIFsnbmFwRScsIFsxMDg2NCwgODI0XV0sIFsnbmFwaWQnLCBbODc3OSwgODI0XV0sIFsnbmFwb3MnLCBbMzI5XV0sIFsnbmFwcHJveCcsIFs4Nzc3XV0sIFsnbmF0dXJhbCcsIFs5ODM4XV0sIFsnbmF0dXJhbHMnLCBbODQ2OV1dLCBbJ25hdHVyJywgWzk4MzhdXSwgWyduYnNwJywgWzE2MF1dLCBbJ25idW1wJywgWzg3ODIsIDgyNF1dLCBbJ25idW1wZScsIFs4NzgzLCA4MjRdXSwgWyduY2FwJywgWzEwODE5XV0sIFsnTmNhcm9uJywgWzMyN11dLCBbJ25jYXJvbicsIFszMjhdXSwgWydOY2VkaWwnLCBbMzI1XV0sIFsnbmNlZGlsJywgWzMyNl1dLCBbJ25jb25nJywgWzg3NzVdXSwgWyduY29uZ2RvdCcsIFsxMDg2MSwgODI0XV0sIFsnbmN1cCcsIFsxMDgxOF1dLCBbJ05jeScsIFsxMDUzXV0sIFsnbmN5JywgWzEwODVdXSwgWyduZGFzaCcsIFs4MjExXV0sIFsnbmVhcmhrJywgWzEwNTMyXV0sIFsnbmVhcnInLCBbODU5OV1dLCBbJ25lQXJyJywgWzg2NjNdXSwgWyduZWFycm93JywgWzg1OTldXSwgWyduZScsIFs4ODAwXV0sIFsnbmVkb3QnLCBbODc4NCwgODI0XV0sIFsnTmVnYXRpdmVNZWRpdW1TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGlja1NwYWNlJywgWzgyMDNdXSwgWydOZWdhdGl2ZVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJywgWzgyMDNdXSwgWyduZXF1aXYnLCBbODgwMl1dLCBbJ25lc2VhcicsIFsxMDUzNl1dLCBbJ25lc2ltJywgWzg3NzAsIDgyNF1dLCBbJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzg4MTFdXSwgWydOZXN0ZWRMZXNzTGVzcycsIFs4ODEwXV0sIFsnbmV4aXN0JywgWzg3MDhdXSwgWyduZXhpc3RzJywgWzg3MDhdXSwgWydOZnInLCBbMTIwMDgxXV0sIFsnbmZyJywgWzEyMDEwN11dLCBbJ25nRScsIFs4ODA3LCA4MjRdXSwgWyduZ2UnLCBbODgxN11dLCBbJ25nZXEnLCBbODgxN11dLCBbJ25nZXFxJywgWzg4MDcsIDgyNF1dLCBbJ25nZXFzbGFudCcsIFsxMDg3OCwgODI0XV0sIFsnbmdlcycsIFsxMDg3OCwgODI0XV0sIFsnbkdnJywgWzg5MjEsIDgyNF1dLCBbJ25nc2ltJywgWzg4MjFdXSwgWyduR3QnLCBbODgxMSwgODQwMl1dLCBbJ25ndCcsIFs4ODE1XV0sIFsnbmd0cicsIFs4ODE1XV0sIFsnbkd0dicsIFs4ODExLCA4MjRdXSwgWyduaGFycicsIFs4NjIyXV0sIFsnbmhBcnInLCBbODY1NF1dLCBbJ25ocGFyJywgWzEwOTk0XV0sIFsnbmknLCBbODcxNV1dLCBbJ25pcycsIFs4OTU2XV0sIFsnbmlzZCcsIFs4OTU0XV0sIFsnbml2JywgWzg3MTVdXSwgWydOSmN5JywgWzEwMzRdXSwgWyduamN5JywgWzExMTRdXSwgWydubGFycicsIFs4NjAyXV0sIFsnbmxBcnInLCBbODY1M11dLCBbJ25sZHInLCBbODIyOV1dLCBbJ25sRScsIFs4ODA2LCA4MjRdXSwgWydubGUnLCBbODgxNl1dLCBbJ25sZWZ0YXJyb3cnLCBbODYwMl1dLCBbJ25MZWZ0YXJyb3cnLCBbODY1M11dLCBbJ25sZWZ0cmlnaHRhcnJvdycsIFs4NjIyXV0sIFsnbkxlZnRyaWdodGFycm93JywgWzg2NTRdXSwgWydubGVxJywgWzg4MTZdXSwgWydubGVxcScsIFs4ODA2LCA4MjRdXSwgWydubGVxc2xhbnQnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXMnLCBbMTA4NzcsIDgyNF1dLCBbJ25sZXNzJywgWzg4MTRdXSwgWyduTGwnLCBbODkyMCwgODI0XV0sIFsnbmxzaW0nLCBbODgyMF1dLCBbJ25MdCcsIFs4ODEwLCA4NDAyXV0sIFsnbmx0JywgWzg4MTRdXSwgWydubHRyaScsIFs4OTM4XV0sIFsnbmx0cmllJywgWzg5NDBdXSwgWyduTHR2JywgWzg4MTAsIDgyNF1dLCBbJ25taWQnLCBbODc0MF1dLCBbJ05vQnJlYWsnLCBbODI4OF1dLCBbJ05vbkJyZWFraW5nU3BhY2UnLCBbMTYwXV0sIFsnbm9wZicsIFsxMjAxNTldXSwgWydOb3BmJywgWzg0NjldXSwgWydOb3QnLCBbMTA5ODhdXSwgWydub3QnLCBbMTcyXV0sIFsnTm90Q29uZ3J1ZW50JywgWzg4MDJdXSwgWydOb3RDdXBDYXAnLCBbODgxM11dLCBbJ05vdERvdWJsZVZlcnRpY2FsQmFyJywgWzg3NDJdXSwgWydOb3RFbGVtZW50JywgWzg3MTNdXSwgWydOb3RFcXVhbCcsIFs4ODAwXV0sIFsnTm90RXF1YWxUaWxkZScsIFs4NzcwLCA4MjRdXSwgWydOb3RFeGlzdHMnLCBbODcwOF1dLCBbJ05vdEdyZWF0ZXInLCBbODgxNV1dLCBbJ05vdEdyZWF0ZXJFcXVhbCcsIFs4ODE3XV0sIFsnTm90R3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3LCA4MjRdXSwgWydOb3RHcmVhdGVyR3JlYXRlcicsIFs4ODExLCA4MjRdXSwgWydOb3RHcmVhdGVyTGVzcycsIFs4ODI1XV0sIFsnTm90R3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzgsIDgyNF1dLCBbJ05vdEdyZWF0ZXJUaWxkZScsIFs4ODIxXV0sIFsnTm90SHVtcERvd25IdW1wJywgWzg3ODIsIDgyNF1dLCBbJ05vdEh1bXBFcXVhbCcsIFs4NzgzLCA4MjRdXSwgWydub3RpbicsIFs4NzEzXV0sIFsnbm90aW5kb3QnLCBbODk0OSwgODI0XV0sIFsnbm90aW5FJywgWzg5NTMsIDgyNF1dLCBbJ25vdGludmEnLCBbODcxM11dLCBbJ25vdGludmInLCBbODk1MV1dLCBbJ25vdGludmMnLCBbODk1MF1dLCBbJ05vdExlZnRUcmlhbmdsZUJhcicsIFsxMDcwMywgODI0XV0sIFsnTm90TGVmdFRyaWFuZ2xlJywgWzg5MzhdXSwgWydOb3RMZWZ0VHJpYW5nbGVFcXVhbCcsIFs4OTQwXV0sIFsnTm90TGVzcycsIFs4ODE0XV0sIFsnTm90TGVzc0VxdWFsJywgWzg4MTZdXSwgWydOb3RMZXNzR3JlYXRlcicsIFs4ODI0XV0sIFsnTm90TGVzc0xlc3MnLCBbODgxMCwgODI0XV0sIFsnTm90TGVzc1NsYW50RXF1YWwnLCBbMTA4NzcsIDgyNF1dLCBbJ05vdExlc3NUaWxkZScsIFs4ODIwXV0sIFsnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInLCBbMTA5MTQsIDgyNF1dLCBbJ05vdE5lc3RlZExlc3NMZXNzJywgWzEwOTEzLCA4MjRdXSwgWydub3RuaScsIFs4NzE2XV0sIFsnbm90bml2YScsIFs4NzE2XV0sIFsnbm90bml2YicsIFs4OTU4XV0sIFsnbm90bml2YycsIFs4OTU3XV0sIFsnTm90UHJlY2VkZXMnLCBbODgzMl1dLCBbJ05vdFByZWNlZGVzRXF1YWwnLCBbMTA5MjcsIDgyNF1dLCBbJ05vdFByZWNlZGVzU2xhbnRFcXVhbCcsIFs4OTI4XV0sIFsnTm90UmV2ZXJzZUVsZW1lbnQnLCBbODcxNl1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDQsIDgyNF1dLCBbJ05vdFJpZ2h0VHJpYW5nbGUnLCBbODkzOV1dLCBbJ05vdFJpZ2h0VHJpYW5nbGVFcXVhbCcsIFs4OTQxXV0sIFsnTm90U3F1YXJlU3Vic2V0JywgWzg4NDcsIDgyNF1dLCBbJ05vdFNxdWFyZVN1YnNldEVxdWFsJywgWzg5MzBdXSwgWydOb3RTcXVhcmVTdXBlcnNldCcsIFs4ODQ4LCA4MjRdXSwgWydOb3RTcXVhcmVTdXBlcnNldEVxdWFsJywgWzg5MzFdXSwgWydOb3RTdWJzZXQnLCBbODgzNCwgODQwMl1dLCBbJ05vdFN1YnNldEVxdWFsJywgWzg4NDBdXSwgWydOb3RTdWNjZWVkcycsIFs4ODMzXV0sIFsnTm90U3VjY2VlZHNFcXVhbCcsIFsxMDkyOCwgODI0XV0sIFsnTm90U3VjY2VlZHNTbGFudEVxdWFsJywgWzg5MjldXSwgWydOb3RTdWNjZWVkc1RpbGRlJywgWzg4MzEsIDgyNF1dLCBbJ05vdFN1cGVyc2V0JywgWzg4MzUsIDg0MDJdXSwgWydOb3RTdXBlcnNldEVxdWFsJywgWzg4NDFdXSwgWydOb3RUaWxkZScsIFs4NzY5XV0sIFsnTm90VGlsZGVFcXVhbCcsIFs4NzcyXV0sIFsnTm90VGlsZGVGdWxsRXF1YWwnLCBbODc3NV1dLCBbJ05vdFRpbGRlVGlsZGUnLCBbODc3N11dLCBbJ05vdFZlcnRpY2FsQmFyJywgWzg3NDBdXSwgWyducGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25wYXInLCBbODc0Ml1dLCBbJ25wYXJzbCcsIFsxMTAwNSwgODQyMV1dLCBbJ25wYXJ0JywgWzg3MDYsIDgyNF1dLCBbJ25wb2xpbnQnLCBbMTA3NzJdXSwgWyducHInLCBbODgzMl1dLCBbJ25wcmN1ZScsIFs4OTI4XV0sIFsnbnByZWMnLCBbODgzMl1dLCBbJ25wcmVjZXEnLCBbMTA5MjcsIDgyNF1dLCBbJ25wcmUnLCBbMTA5MjcsIDgyNF1dLCBbJ25yYXJyYycsIFsxMDU0NywgODI0XV0sIFsnbnJhcnInLCBbODYwM11dLCBbJ25yQXJyJywgWzg2NTVdXSwgWyducmFycncnLCBbODYwNSwgODI0XV0sIFsnbnJpZ2h0YXJyb3cnLCBbODYwM11dLCBbJ25SaWdodGFycm93JywgWzg2NTVdXSwgWyducnRyaScsIFs4OTM5XV0sIFsnbnJ0cmllJywgWzg5NDFdXSwgWyduc2MnLCBbODgzM11dLCBbJ25zY2N1ZScsIFs4OTI5XV0sIFsnbnNjZScsIFsxMDkyOCwgODI0XV0sIFsnTnNjcicsIFsxMTk5NzddXSwgWyduc2NyJywgWzEyMDAwM11dLCBbJ25zaG9ydG1pZCcsIFs4NzQwXV0sIFsnbnNob3J0cGFyYWxsZWwnLCBbODc0Ml1dLCBbJ25zaW0nLCBbODc2OV1dLCBbJ25zaW1lJywgWzg3NzJdXSwgWyduc2ltZXEnLCBbODc3Ml1dLCBbJ25zbWlkJywgWzg3NDBdXSwgWyduc3BhcicsIFs4NzQyXV0sIFsnbnNxc3ViZScsIFs4OTMwXV0sIFsnbnNxc3VwZScsIFs4OTMxXV0sIFsnbnN1YicsIFs4ODM2XV0sIFsnbnN1YkUnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWJlJywgWzg4NDBdXSwgWyduc3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWyduc3Vic2V0ZXEnLCBbODg0MF1dLCBbJ25zdWJzZXRlcXEnLCBbMTA5NDksIDgyNF1dLCBbJ25zdWNjJywgWzg4MzNdXSwgWyduc3VjY2VxJywgWzEwOTI4LCA4MjRdXSwgWyduc3VwJywgWzg4MzddXSwgWyduc3VwRScsIFsxMDk1MCwgODI0XV0sIFsnbnN1cGUnLCBbODg0MV1dLCBbJ25zdXBzZXQnLCBbODgzNSwgODQwMl1dLCBbJ25zdXBzZXRlcScsIFs4ODQxXV0sIFsnbnN1cHNldGVxcScsIFsxMDk1MCwgODI0XV0sIFsnbnRnbCcsIFs4ODI1XV0sIFsnTnRpbGRlJywgWzIwOV1dLCBbJ250aWxkZScsIFsyNDFdXSwgWydudGxnJywgWzg4MjRdXSwgWydudHJpYW5nbGVsZWZ0JywgWzg5MzhdXSwgWydudHJpYW5nbGVsZWZ0ZXEnLCBbODk0MF1dLCBbJ250cmlhbmdsZXJpZ2h0JywgWzg5MzldXSwgWydudHJpYW5nbGVyaWdodGVxJywgWzg5NDFdXSwgWydOdScsIFs5MjVdXSwgWydudScsIFs5NTddXSwgWydudW0nLCBbMzVdXSwgWydudW1lcm8nLCBbODQ3MF1dLCBbJ251bXNwJywgWzgxOTldXSwgWydudmFwJywgWzg3ODEsIDg0MDJdXSwgWydudmRhc2gnLCBbODg3Nl1dLCBbJ252RGFzaCcsIFs4ODc3XV0sIFsnblZkYXNoJywgWzg4NzhdXSwgWyduVkRhc2gnLCBbODg3OV1dLCBbJ252Z2UnLCBbODgwNSwgODQwMl1dLCBbJ252Z3QnLCBbNjIsIDg0MDJdXSwgWydudkhhcnInLCBbMTA1MDBdXSwgWydudmluZmluJywgWzEwNzE4XV0sIFsnbnZsQXJyJywgWzEwNDk4XV0sIFsnbnZsZScsIFs4ODA0LCA4NDAyXV0sIFsnbnZsdCcsIFs2MCwgODQwMl1dLCBbJ252bHRyaWUnLCBbODg4NCwgODQwMl1dLCBbJ252ckFycicsIFsxMDQ5OV1dLCBbJ252cnRyaWUnLCBbODg4NSwgODQwMl1dLCBbJ252c2ltJywgWzg3NjQsIDg0MDJdXSwgWydud2FyaGsnLCBbMTA1MzFdXSwgWydud2FycicsIFs4NTk4XV0sIFsnbndBcnInLCBbODY2Ml1dLCBbJ253YXJyb3cnLCBbODU5OF1dLCBbJ253bmVhcicsIFsxMDUzNV1dLCBbJ09hY3V0ZScsIFsyMTFdXSwgWydvYWN1dGUnLCBbMjQzXV0sIFsnb2FzdCcsIFs4ODU5XV0sIFsnT2NpcmMnLCBbMjEyXV0sIFsnb2NpcmMnLCBbMjQ0XV0sIFsnb2NpcicsIFs4ODU4XV0sIFsnT2N5JywgWzEwNTRdXSwgWydvY3knLCBbMTA4Nl1dLCBbJ29kYXNoJywgWzg4NjFdXSwgWydPZGJsYWMnLCBbMzM2XV0sIFsnb2RibGFjJywgWzMzN11dLCBbJ29kaXYnLCBbMTA4MDhdXSwgWydvZG90JywgWzg4NTddXSwgWydvZHNvbGQnLCBbMTA2ODRdXSwgWydPRWxpZycsIFszMzhdXSwgWydvZWxpZycsIFszMzldXSwgWydvZmNpcicsIFsxMDY4N11dLCBbJ09mcicsIFsxMjAwODJdXSwgWydvZnInLCBbMTIwMTA4XV0sIFsnb2dvbicsIFs3MzFdXSwgWydPZ3JhdmUnLCBbMjEwXV0sIFsnb2dyYXZlJywgWzI0Ml1dLCBbJ29ndCcsIFsxMDY4OV1dLCBbJ29oYmFyJywgWzEwNjc3XV0sIFsnb2htJywgWzkzN11dLCBbJ29pbnQnLCBbODc1MF1dLCBbJ29sYXJyJywgWzg2MzRdXSwgWydvbGNpcicsIFsxMDY4Nl1dLCBbJ29sY3Jvc3MnLCBbMTA2ODNdXSwgWydvbGluZScsIFs4MjU0XV0sIFsnb2x0JywgWzEwNjg4XV0sIFsnT21hY3InLCBbMzMyXV0sIFsnb21hY3InLCBbMzMzXV0sIFsnT21lZ2EnLCBbOTM3XV0sIFsnb21lZ2EnLCBbOTY5XV0sIFsnT21pY3JvbicsIFs5MjddXSwgWydvbWljcm9uJywgWzk1OV1dLCBbJ29taWQnLCBbMTA2NzhdXSwgWydvbWludXMnLCBbODg1NF1dLCBbJ09vcGYnLCBbMTIwMTM0XV0sIFsnb29wZicsIFsxMjAxNjBdXSwgWydvcGFyJywgWzEwNjc5XV0sIFsnT3BlbkN1cmx5RG91YmxlUXVvdGUnLCBbODIyMF1dLCBbJ09wZW5DdXJseVF1b3RlJywgWzgyMTZdXSwgWydvcGVycCcsIFsxMDY4MV1dLCBbJ29wbHVzJywgWzg4NTNdXSwgWydvcmFycicsIFs4NjM1XV0sIFsnT3InLCBbMTA4MzZdXSwgWydvcicsIFs4NzQ0XV0sIFsnb3JkJywgWzEwODQ1XV0sIFsnb3JkZXInLCBbODUwMF1dLCBbJ29yZGVyb2YnLCBbODUwMF1dLCBbJ29yZGYnLCBbMTcwXV0sIFsnb3JkbScsIFsxODZdXSwgWydvcmlnb2YnLCBbODg4Nl1dLCBbJ29yb3InLCBbMTA4MzhdXSwgWydvcnNsb3BlJywgWzEwODM5XV0sIFsnb3J2JywgWzEwODQzXV0sIFsnb1MnLCBbOTQxNl1dLCBbJ09zY3InLCBbMTE5OTc4XV0sIFsnb3NjcicsIFs4NTAwXV0sIFsnT3NsYXNoJywgWzIxNl1dLCBbJ29zbGFzaCcsIFsyNDhdXSwgWydvc29sJywgWzg4NTZdXSwgWydPdGlsZGUnLCBbMjEzXV0sIFsnb3RpbGRlJywgWzI0NV1dLCBbJ290aW1lc2FzJywgWzEwODA2XV0sIFsnT3RpbWVzJywgWzEwODA3XV0sIFsnb3RpbWVzJywgWzg4NTVdXSwgWydPdW1sJywgWzIxNF1dLCBbJ291bWwnLCBbMjQ2XV0sIFsnb3ZiYXInLCBbOTAyMV1dLCBbJ092ZXJCYXInLCBbODI1NF1dLCBbJ092ZXJCcmFjZScsIFs5MTgyXV0sIFsnT3ZlckJyYWNrZXQnLCBbOTE0MF1dLCBbJ092ZXJQYXJlbnRoZXNpcycsIFs5MTgwXV0sIFsncGFyYScsIFsxODJdXSwgWydwYXJhbGxlbCcsIFs4NzQxXV0sIFsncGFyJywgWzg3NDFdXSwgWydwYXJzaW0nLCBbMTA5OTVdXSwgWydwYXJzbCcsIFsxMTAwNV1dLCBbJ3BhcnQnLCBbODcwNl1dLCBbJ1BhcnRpYWxEJywgWzg3MDZdXSwgWydQY3knLCBbMTA1NV1dLCBbJ3BjeScsIFsxMDg3XV0sIFsncGVyY250JywgWzM3XV0sIFsncGVyaW9kJywgWzQ2XV0sIFsncGVybWlsJywgWzgyNDBdXSwgWydwZXJwJywgWzg4NjldXSwgWydwZXJ0ZW5rJywgWzgyNDFdXSwgWydQZnInLCBbMTIwMDgzXV0sIFsncGZyJywgWzEyMDEwOV1dLCBbJ1BoaScsIFs5MzRdXSwgWydwaGknLCBbOTY2XV0sIFsncGhpdicsIFs5ODFdXSwgWydwaG1tYXQnLCBbODQ5OV1dLCBbJ3Bob25lJywgWzk3NDJdXSwgWydQaScsIFs5MjhdXSwgWydwaScsIFs5NjBdXSwgWydwaXRjaGZvcmsnLCBbODkxNl1dLCBbJ3BpdicsIFs5ODJdXSwgWydwbGFuY2snLCBbODQ2M11dLCBbJ3BsYW5ja2gnLCBbODQ2Ml1dLCBbJ3BsYW5rdicsIFs4NDYzXV0sIFsncGx1c2FjaXInLCBbMTA3ODddXSwgWydwbHVzYicsIFs4ODYyXV0sIFsncGx1c2NpcicsIFsxMDc4Nl1dLCBbJ3BsdXMnLCBbNDNdXSwgWydwbHVzZG8nLCBbODcyNF1dLCBbJ3BsdXNkdScsIFsxMDc4OV1dLCBbJ3BsdXNlJywgWzEwODY2XV0sIFsnUGx1c01pbnVzJywgWzE3N11dLCBbJ3BsdXNtbicsIFsxNzddXSwgWydwbHVzc2ltJywgWzEwNzkwXV0sIFsncGx1c3R3bycsIFsxMDc5MV1dLCBbJ3BtJywgWzE3N11dLCBbJ1BvaW5jYXJlcGxhbmUnLCBbODQ2MF1dLCBbJ3BvaW50aW50JywgWzEwNzczXV0sIFsncG9wZicsIFsxMjAxNjFdXSwgWydQb3BmJywgWzg0NzNdXSwgWydwb3VuZCcsIFsxNjNdXSwgWydwcmFwJywgWzEwOTM1XV0sIFsnUHInLCBbMTA5MzldXSwgWydwcicsIFs4ODI2XV0sIFsncHJjdWUnLCBbODgyOF1dLCBbJ3ByZWNhcHByb3gnLCBbMTA5MzVdXSwgWydwcmVjJywgWzg4MjZdXSwgWydwcmVjY3VybHllcScsIFs4ODI4XV0sIFsnUHJlY2VkZXMnLCBbODgyNl1dLCBbJ1ByZWNlZGVzRXF1YWwnLCBbMTA5MjddXSwgWydQcmVjZWRlc1NsYW50RXF1YWwnLCBbODgyOF1dLCBbJ1ByZWNlZGVzVGlsZGUnLCBbODgzMF1dLCBbJ3ByZWNlcScsIFsxMDkyN11dLCBbJ3ByZWNuYXBwcm94JywgWzEwOTM3XV0sIFsncHJlY25lcXEnLCBbMTA5MzNdXSwgWydwcmVjbnNpbScsIFs4OTM2XV0sIFsncHJlJywgWzEwOTI3XV0sIFsncHJFJywgWzEwOTMxXV0sIFsncHJlY3NpbScsIFs4ODMwXV0sIFsncHJpbWUnLCBbODI0Ml1dLCBbJ1ByaW1lJywgWzgyNDNdXSwgWydwcmltZXMnLCBbODQ3M11dLCBbJ3BybmFwJywgWzEwOTM3XV0sIFsncHJuRScsIFsxMDkzM11dLCBbJ3BybnNpbScsIFs4OTM2XV0sIFsncHJvZCcsIFs4NzE5XV0sIFsnUHJvZHVjdCcsIFs4NzE5XV0sIFsncHJvZmFsYXInLCBbOTAwNl1dLCBbJ3Byb2ZsaW5lJywgWzg5NzhdXSwgWydwcm9mc3VyZicsIFs4OTc5XV0sIFsncHJvcCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbmFsJywgWzg3MzNdXSwgWydQcm9wb3J0aW9uJywgWzg3NTldXSwgWydwcm9wdG8nLCBbODczM11dLCBbJ3Byc2ltJywgWzg4MzBdXSwgWydwcnVyZWwnLCBbODg4MF1dLCBbJ1BzY3InLCBbMTE5OTc5XV0sIFsncHNjcicsIFsxMjAwMDVdXSwgWydQc2knLCBbOTM2XV0sIFsncHNpJywgWzk2OF1dLCBbJ3B1bmNzcCcsIFs4MjAwXV0sIFsnUWZyJywgWzEyMDA4NF1dLCBbJ3FmcicsIFsxMjAxMTBdXSwgWydxaW50JywgWzEwNzY0XV0sIFsncW9wZicsIFsxMjAxNjJdXSwgWydRb3BmJywgWzg0NzRdXSwgWydxcHJpbWUnLCBbODI3OV1dLCBbJ1FzY3InLCBbMTE5OTgwXV0sIFsncXNjcicsIFsxMjAwMDZdXSwgWydxdWF0ZXJuaW9ucycsIFs4NDYxXV0sIFsncXVhdGludCcsIFsxMDc3NF1dLCBbJ3F1ZXN0JywgWzYzXV0sIFsncXVlc3RlcScsIFs4Nzk5XV0sIFsncXVvdCcsIFszNF1dLCBbJ1FVT1QnLCBbMzRdXSwgWydyQWFycicsIFs4NjY3XV0sIFsncmFjZScsIFs4NzY1LCA4MTddXSwgWydSYWN1dGUnLCBbMzQwXV0sIFsncmFjdXRlJywgWzM0MV1dLCBbJ3JhZGljJywgWzg3MzBdXSwgWydyYWVtcHR5dicsIFsxMDY3NV1dLCBbJ3JhbmcnLCBbMTAyMTddXSwgWydSYW5nJywgWzEwMjE5XV0sIFsncmFuZ2QnLCBbMTA2NDJdXSwgWydyYW5nZScsIFsxMDY2MV1dLCBbJ3JhbmdsZScsIFsxMDIxN11dLCBbJ3JhcXVvJywgWzE4N11dLCBbJ3JhcnJhcCcsIFsxMDYxM11dLCBbJ3JhcnJiJywgWzg2NzddXSwgWydyYXJyYmZzJywgWzEwNTI4XV0sIFsncmFycmMnLCBbMTA1NDddXSwgWydyYXJyJywgWzg1OTRdXSwgWydSYXJyJywgWzg2MDhdXSwgWydyQXJyJywgWzg2NThdXSwgWydyYXJyZnMnLCBbMTA1MjZdXSwgWydyYXJyaGsnLCBbODYxOF1dLCBbJ3JhcnJscCcsIFs4NjIwXV0sIFsncmFycnBsJywgWzEwNTY1XV0sIFsncmFycnNpbScsIFsxMDYxMl1dLCBbJ1JhcnJ0bCcsIFsxMDUxOF1dLCBbJ3JhcnJ0bCcsIFs4NjExXV0sIFsncmFycncnLCBbODYwNV1dLCBbJ3JhdGFpbCcsIFsxMDUyMl1dLCBbJ3JBdGFpbCcsIFsxMDUyNF1dLCBbJ3JhdGlvJywgWzg3NThdXSwgWydyYXRpb25hbHMnLCBbODQ3NF1dLCBbJ3JiYXJyJywgWzEwNTA5XV0sIFsnckJhcnInLCBbMTA1MTFdXSwgWydSQmFycicsIFsxMDUxMl1dLCBbJ3JiYnJrJywgWzEwMDk5XV0sIFsncmJyYWNlJywgWzEyNV1dLCBbJ3JicmFjaycsIFs5M11dLCBbJ3JicmtlJywgWzEwNjM2XV0sIFsncmJya3NsZCcsIFsxMDYzOF1dLCBbJ3JicmtzbHUnLCBbMTA2NDBdXSwgWydSY2Fyb24nLCBbMzQ0XV0sIFsncmNhcm9uJywgWzM0NV1dLCBbJ1JjZWRpbCcsIFszNDJdXSwgWydyY2VkaWwnLCBbMzQzXV0sIFsncmNlaWwnLCBbODk2OV1dLCBbJ3JjdWInLCBbMTI1XV0sIFsnUmN5JywgWzEwNTZdXSwgWydyY3knLCBbMTA4OF1dLCBbJ3JkY2EnLCBbMTA1NTFdXSwgWydyZGxkaGFyJywgWzEwNjAxXV0sIFsncmRxdW8nLCBbODIyMV1dLCBbJ3JkcXVvcicsIFs4MjIxXV0sIFsnQ2xvc2VDdXJseURvdWJsZVF1b3RlJywgWzgyMjFdXSwgWydyZHNoJywgWzg2MjddXSwgWydyZWFsJywgWzg0NzZdXSwgWydyZWFsaW5lJywgWzg0NzVdXSwgWydyZWFscGFydCcsIFs4NDc2XV0sIFsncmVhbHMnLCBbODQ3N11dLCBbJ1JlJywgWzg0NzZdXSwgWydyZWN0JywgWzk2NDVdXSwgWydyZWcnLCBbMTc0XV0sIFsnUkVHJywgWzE3NF1dLCBbJ1JldmVyc2VFbGVtZW50JywgWzg3MTVdXSwgWydSZXZlcnNlRXF1aWxpYnJpdW0nLCBbODY1MV1dLCBbJ1JldmVyc2VVcEVxdWlsaWJyaXVtJywgWzEwNjA3XV0sIFsncmZpc2h0JywgWzEwNjIxXV0sIFsncmZsb29yJywgWzg5NzFdXSwgWydyZnInLCBbMTIwMTExXV0sIFsnUmZyJywgWzg0NzZdXSwgWydySGFyJywgWzEwNTk2XV0sIFsncmhhcmQnLCBbODY0MV1dLCBbJ3JoYXJ1JywgWzg2NDBdXSwgWydyaGFydWwnLCBbMTA2MDRdXSwgWydSaG8nLCBbOTI5XV0sIFsncmhvJywgWzk2MV1dLCBbJ3Job3YnLCBbMTAwOV1dLCBbJ1JpZ2h0QW5nbGVCcmFja2V0JywgWzEwMjE3XV0sIFsnUmlnaHRBcnJvd0JhcicsIFs4Njc3XV0sIFsncmlnaHRhcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnUmlnaHRhcnJvdycsIFs4NjU4XV0sIFsnUmlnaHRBcnJvd0xlZnRBcnJvdycsIFs4NjQ0XV0sIFsncmlnaHRhcnJvd3RhaWwnLCBbODYxMV1dLCBbJ1JpZ2h0Q2VpbGluZycsIFs4OTY5XV0sIFsnUmlnaHREb3VibGVCcmFja2V0JywgWzEwMjE1XV0sIFsnUmlnaHREb3duVGVlVmVjdG9yJywgWzEwNTg5XV0sIFsnUmlnaHREb3duVmVjdG9yQmFyJywgWzEwNTgxXV0sIFsnUmlnaHREb3duVmVjdG9yJywgWzg2NDJdXSwgWydSaWdodEZsb29yJywgWzg5NzFdXSwgWydyaWdodGhhcnBvb25kb3duJywgWzg2NDFdXSwgWydyaWdodGhhcnBvb251cCcsIFs4NjQwXV0sIFsncmlnaHRsZWZ0YXJyb3dzJywgWzg2NDRdXSwgWydyaWdodGxlZnRoYXJwb29ucycsIFs4NjUyXV0sIFsncmlnaHRyaWdodGFycm93cycsIFs4NjQ5XV0sIFsncmlnaHRzcXVpZ2Fycm93JywgWzg2MDVdXSwgWydSaWdodFRlZUFycm93JywgWzg2MTRdXSwgWydSaWdodFRlZScsIFs4ODY2XV0sIFsnUmlnaHRUZWVWZWN0b3InLCBbMTA1ODddXSwgWydyaWdodHRocmVldGltZXMnLCBbODkwOF1dLCBbJ1JpZ2h0VHJpYW5nbGVCYXInLCBbMTA3MDRdXSwgWydSaWdodFRyaWFuZ2xlJywgWzg4ODNdXSwgWydSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODg4NV1dLCBbJ1JpZ2h0VXBEb3duVmVjdG9yJywgWzEwNTc1XV0sIFsnUmlnaHRVcFRlZVZlY3RvcicsIFsxMDU4OF1dLCBbJ1JpZ2h0VXBWZWN0b3JCYXInLCBbMTA1ODBdXSwgWydSaWdodFVwVmVjdG9yJywgWzg2MzhdXSwgWydSaWdodFZlY3RvckJhcicsIFsxMDU3OV1dLCBbJ1JpZ2h0VmVjdG9yJywgWzg2NDBdXSwgWydyaW5nJywgWzczMF1dLCBbJ3Jpc2luZ2RvdHNlcScsIFs4Nzg3XV0sIFsncmxhcnInLCBbODY0NF1dLCBbJ3JsaGFyJywgWzg2NTJdXSwgWydybG0nLCBbODIwN11dLCBbJ3Jtb3VzdGFjaGUnLCBbOTEzN11dLCBbJ3Jtb3VzdCcsIFs5MTM3XV0sIFsncm5taWQnLCBbMTA5OTBdXSwgWydyb2FuZycsIFsxMDIyMV1dLCBbJ3JvYXJyJywgWzg3MDJdXSwgWydyb2JyaycsIFsxMDIxNV1dLCBbJ3JvcGFyJywgWzEwNjMwXV0sIFsncm9wZicsIFsxMjAxNjNdXSwgWydSb3BmJywgWzg0NzddXSwgWydyb3BsdXMnLCBbMTA3OThdXSwgWydyb3RpbWVzJywgWzEwODA1XV0sIFsnUm91bmRJbXBsaWVzJywgWzEwNjA4XV0sIFsncnBhcicsIFs0MV1dLCBbJ3JwYXJndCcsIFsxMDY0NF1dLCBbJ3JwcG9saW50JywgWzEwNzcwXV0sIFsncnJhcnInLCBbODY0OV1dLCBbJ1JyaWdodGFycm93JywgWzg2NjddXSwgWydyc2FxdW8nLCBbODI1MF1dLCBbJ3JzY3InLCBbMTIwMDA3XV0sIFsnUnNjcicsIFs4NDc1XV0sIFsncnNoJywgWzg2MjVdXSwgWydSc2gnLCBbODYyNV1dLCBbJ3JzcWInLCBbOTNdXSwgWydyc3F1bycsIFs4MjE3XV0sIFsncnNxdW9yJywgWzgyMTddXSwgWydDbG9zZUN1cmx5UXVvdGUnLCBbODIxN11dLCBbJ3J0aHJlZScsIFs4OTA4XV0sIFsncnRpbWVzJywgWzg5MDZdXSwgWydydHJpJywgWzk2NTddXSwgWydydHJpZScsIFs4ODg1XV0sIFsncnRyaWYnLCBbOTY1Nl1dLCBbJ3J0cmlsdHJpJywgWzEwNzAyXV0sIFsnUnVsZURlbGF5ZWQnLCBbMTA3NDBdXSwgWydydWx1aGFyJywgWzEwNjAwXV0sIFsncngnLCBbODQ3OF1dLCBbJ1NhY3V0ZScsIFszNDZdXSwgWydzYWN1dGUnLCBbMzQ3XV0sIFsnc2JxdW8nLCBbODIxOF1dLCBbJ3NjYXAnLCBbMTA5MzZdXSwgWydTY2Fyb24nLCBbMzUyXV0sIFsnc2Nhcm9uJywgWzM1M11dLCBbJ1NjJywgWzEwOTQwXV0sIFsnc2MnLCBbODgyN11dLCBbJ3NjY3VlJywgWzg4MjldXSwgWydzY2UnLCBbMTA5MjhdXSwgWydzY0UnLCBbMTA5MzJdXSwgWydTY2VkaWwnLCBbMzUwXV0sIFsnc2NlZGlsJywgWzM1MV1dLCBbJ1NjaXJjJywgWzM0OF1dLCBbJ3NjaXJjJywgWzM0OV1dLCBbJ3NjbmFwJywgWzEwOTM4XV0sIFsnc2NuRScsIFsxMDkzNF1dLCBbJ3NjbnNpbScsIFs4OTM3XV0sIFsnc2Nwb2xpbnQnLCBbMTA3NzFdXSwgWydzY3NpbScsIFs4ODMxXV0sIFsnU2N5JywgWzEwNTddXSwgWydzY3knLCBbMTA4OV1dLCBbJ3Nkb3RiJywgWzg4NjVdXSwgWydzZG90JywgWzg5MDFdXSwgWydzZG90ZScsIFsxMDg1NF1dLCBbJ3NlYXJoaycsIFsxMDUzM11dLCBbJ3NlYXJyJywgWzg2MDBdXSwgWydzZUFycicsIFs4NjY0XV0sIFsnc2VhcnJvdycsIFs4NjAwXV0sIFsnc2VjdCcsIFsxNjddXSwgWydzZW1pJywgWzU5XV0sIFsnc2Vzd2FyJywgWzEwNTM3XV0sIFsnc2V0bWludXMnLCBbODcyNl1dLCBbJ3NldG1uJywgWzg3MjZdXSwgWydzZXh0JywgWzEwMDM4XV0sIFsnU2ZyJywgWzEyMDA4Nl1dLCBbJ3NmcicsIFsxMjAxMTJdXSwgWydzZnJvd24nLCBbODk5NF1dLCBbJ3NoYXJwJywgWzk4MzldXSwgWydTSENIY3knLCBbMTA2NV1dLCBbJ3NoY2hjeScsIFsxMDk3XV0sIFsnU0hjeScsIFsxMDY0XV0sIFsnc2hjeScsIFsxMDk2XV0sIFsnU2hvcnREb3duQXJyb3cnLCBbODU5NV1dLCBbJ1Nob3J0TGVmdEFycm93JywgWzg1OTJdXSwgWydzaG9ydG1pZCcsIFs4NzM5XV0sIFsnc2hvcnRwYXJhbGxlbCcsIFs4NzQxXV0sIFsnU2hvcnRSaWdodEFycm93JywgWzg1OTRdXSwgWydTaG9ydFVwQXJyb3cnLCBbODU5M11dLCBbJ3NoeScsIFsxNzNdXSwgWydTaWdtYScsIFs5MzFdXSwgWydzaWdtYScsIFs5NjNdXSwgWydzaWdtYWYnLCBbOTYyXV0sIFsnc2lnbWF2JywgWzk2Ml1dLCBbJ3NpbScsIFs4NzY0XV0sIFsnc2ltZG90JywgWzEwODU4XV0sIFsnc2ltZScsIFs4NzcxXV0sIFsnc2ltZXEnLCBbODc3MV1dLCBbJ3NpbWcnLCBbMTA5MTBdXSwgWydzaW1nRScsIFsxMDkxMl1dLCBbJ3NpbWwnLCBbMTA5MDldXSwgWydzaW1sRScsIFsxMDkxMV1dLCBbJ3NpbW5lJywgWzg3NzRdXSwgWydzaW1wbHVzJywgWzEwNzg4XV0sIFsnc2ltcmFycicsIFsxMDYxMF1dLCBbJ3NsYXJyJywgWzg1OTJdXSwgWydTbWFsbENpcmNsZScsIFs4NzI4XV0sIFsnc21hbGxzZXRtaW51cycsIFs4NzI2XV0sIFsnc21hc2hwJywgWzEwODAzXV0sIFsnc21lcGFyc2wnLCBbMTA3MjRdXSwgWydzbWlkJywgWzg3MzldXSwgWydzbWlsZScsIFs4OTk1XV0sIFsnc210JywgWzEwOTIyXV0sIFsnc210ZScsIFsxMDkyNF1dLCBbJ3NtdGVzJywgWzEwOTI0LCA2NTAyNF1dLCBbJ1NPRlRjeScsIFsxMDY4XV0sIFsnc29mdGN5JywgWzExMDBdXSwgWydzb2xiYXInLCBbOTAyM11dLCBbJ3NvbGInLCBbMTA2OTJdXSwgWydzb2wnLCBbNDddXSwgWydTb3BmJywgWzEyMDEzOF1dLCBbJ3NvcGYnLCBbMTIwMTY0XV0sIFsnc3BhZGVzJywgWzk4MjRdXSwgWydzcGFkZXN1aXQnLCBbOTgyNF1dLCBbJ3NwYXInLCBbODc0MV1dLCBbJ3NxY2FwJywgWzg4NTFdXSwgWydzcWNhcHMnLCBbODg1MSwgNjUwMjRdXSwgWydzcWN1cCcsIFs4ODUyXV0sIFsnc3FjdXBzJywgWzg4NTIsIDY1MDI0XV0sIFsnU3FydCcsIFs4NzMwXV0sIFsnc3FzdWInLCBbODg0N11dLCBbJ3Nxc3ViZScsIFs4ODQ5XV0sIFsnc3FzdWJzZXQnLCBbODg0N11dLCBbJ3Nxc3Vic2V0ZXEnLCBbODg0OV1dLCBbJ3Nxc3VwJywgWzg4NDhdXSwgWydzcXN1cGUnLCBbODg1MF1dLCBbJ3Nxc3Vwc2V0JywgWzg4NDhdXSwgWydzcXN1cHNldGVxJywgWzg4NTBdXSwgWydzcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZScsIFs5NjMzXV0sIFsnU3F1YXJlSW50ZXJzZWN0aW9uJywgWzg4NTFdXSwgWydTcXVhcmVTdWJzZXQnLCBbODg0N11dLCBbJ1NxdWFyZVN1YnNldEVxdWFsJywgWzg4NDldXSwgWydTcXVhcmVTdXBlcnNldCcsIFs4ODQ4XV0sIFsnU3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4ODUwXV0sIFsnU3F1YXJlVW5pb24nLCBbODg1Ml1dLCBbJ3NxdWFyZicsIFs5NjQyXV0sIFsnc3F1JywgWzk2MzNdXSwgWydzcXVmJywgWzk2NDJdXSwgWydzcmFycicsIFs4NTk0XV0sIFsnU3NjcicsIFsxMTk5ODJdXSwgWydzc2NyJywgWzEyMDAwOF1dLCBbJ3NzZXRtbicsIFs4NzI2XV0sIFsnc3NtaWxlJywgWzg5OTVdXSwgWydzc3RhcmYnLCBbODkwMl1dLCBbJ1N0YXInLCBbODkwMl1dLCBbJ3N0YXInLCBbOTczNF1dLCBbJ3N0YXJmJywgWzk3MzNdXSwgWydzdHJhaWdodGVwc2lsb24nLCBbMTAxM11dLCBbJ3N0cmFpZ2h0cGhpJywgWzk4MV1dLCBbJ3N0cm5zJywgWzE3NV1dLCBbJ3N1YicsIFs4ODM0XV0sIFsnU3ViJywgWzg5MTJdXSwgWydzdWJkb3QnLCBbMTA5NDFdXSwgWydzdWJFJywgWzEwOTQ5XV0sIFsnc3ViZScsIFs4ODM4XV0sIFsnc3ViZWRvdCcsIFsxMDk0N11dLCBbJ3N1Ym11bHQnLCBbMTA5NDVdXSwgWydzdWJuRScsIFsxMDk1NV1dLCBbJ3N1Ym5lJywgWzg4NDJdXSwgWydzdWJwbHVzJywgWzEwOTQzXV0sIFsnc3VicmFycicsIFsxMDYxN11dLCBbJ3N1YnNldCcsIFs4ODM0XV0sIFsnU3Vic2V0JywgWzg5MTJdXSwgWydzdWJzZXRlcScsIFs4ODM4XV0sIFsnc3Vic2V0ZXFxJywgWzEwOTQ5XV0sIFsnU3Vic2V0RXF1YWwnLCBbODgzOF1dLCBbJ3N1YnNldG5lcScsIFs4ODQyXV0sIFsnc3Vic2V0bmVxcScsIFsxMDk1NV1dLCBbJ3N1YnNpbScsIFsxMDk1MV1dLCBbJ3N1YnN1YicsIFsxMDk2NV1dLCBbJ3N1YnN1cCcsIFsxMDk2M11dLCBbJ3N1Y2NhcHByb3gnLCBbMTA5MzZdXSwgWydzdWNjJywgWzg4MjddXSwgWydzdWNjY3VybHllcScsIFs4ODI5XV0sIFsnU3VjY2VlZHMnLCBbODgyN11dLCBbJ1N1Y2NlZWRzRXF1YWwnLCBbMTA5MjhdXSwgWydTdWNjZWVkc1NsYW50RXF1YWwnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzVGlsZGUnLCBbODgzMV1dLCBbJ3N1Y2NlcScsIFsxMDkyOF1dLCBbJ3N1Y2NuYXBwcm94JywgWzEwOTM4XV0sIFsnc3VjY25lcXEnLCBbMTA5MzRdXSwgWydzdWNjbnNpbScsIFs4OTM3XV0sIFsnc3VjY3NpbScsIFs4ODMxXV0sIFsnU3VjaFRoYXQnLCBbODcxNV1dLCBbJ3N1bScsIFs4NzIxXV0sIFsnU3VtJywgWzg3MjFdXSwgWydzdW5nJywgWzk4MzRdXSwgWydzdXAxJywgWzE4NV1dLCBbJ3N1cDInLCBbMTc4XV0sIFsnc3VwMycsIFsxNzldXSwgWydzdXAnLCBbODgzNV1dLCBbJ1N1cCcsIFs4OTEzXV0sIFsnc3VwZG90JywgWzEwOTQyXV0sIFsnc3VwZHN1YicsIFsxMDk2OF1dLCBbJ3N1cEUnLCBbMTA5NTBdXSwgWydzdXBlJywgWzg4MzldXSwgWydzdXBlZG90JywgWzEwOTQ4XV0sIFsnU3VwZXJzZXQnLCBbODgzNV1dLCBbJ1N1cGVyc2V0RXF1YWwnLCBbODgzOV1dLCBbJ3N1cGhzb2wnLCBbMTAxODVdXSwgWydzdXBoc3ViJywgWzEwOTY3XV0sIFsnc3VwbGFycicsIFsxMDYxOV1dLCBbJ3N1cG11bHQnLCBbMTA5NDZdXSwgWydzdXBuRScsIFsxMDk1Nl1dLCBbJ3N1cG5lJywgWzg4NDNdXSwgWydzdXBwbHVzJywgWzEwOTQ0XV0sIFsnc3Vwc2V0JywgWzg4MzVdXSwgWydTdXBzZXQnLCBbODkxM11dLCBbJ3N1cHNldGVxJywgWzg4MzldXSwgWydzdXBzZXRlcXEnLCBbMTA5NTBdXSwgWydzdXBzZXRuZXEnLCBbODg0M11dLCBbJ3N1cHNldG5lcXEnLCBbMTA5NTZdXSwgWydzdXBzaW0nLCBbMTA5NTJdXSwgWydzdXBzdWInLCBbMTA5NjRdXSwgWydzdXBzdXAnLCBbMTA5NjZdXSwgWydzd2FyaGsnLCBbMTA1MzRdXSwgWydzd2FycicsIFs4NjAxXV0sIFsnc3dBcnInLCBbODY2NV1dLCBbJ3N3YXJyb3cnLCBbODYwMV1dLCBbJ3N3bndhcicsIFsxMDUzOF1dLCBbJ3N6bGlnJywgWzIyM11dLCBbJ1RhYicsIFs5XV0sIFsndGFyZ2V0JywgWzg5ODJdXSwgWydUYXUnLCBbOTMyXV0sIFsndGF1JywgWzk2NF1dLCBbJ3RicmsnLCBbOTE0MF1dLCBbJ1RjYXJvbicsIFszNTZdXSwgWyd0Y2Fyb24nLCBbMzU3XV0sIFsnVGNlZGlsJywgWzM1NF1dLCBbJ3RjZWRpbCcsIFszNTVdXSwgWydUY3knLCBbMTA1OF1dLCBbJ3RjeScsIFsxMDkwXV0sIFsndGRvdCcsIFs4NDExXV0sIFsndGVscmVjJywgWzg5ODFdXSwgWydUZnInLCBbMTIwMDg3XV0sIFsndGZyJywgWzEyMDExM11dLCBbJ3RoZXJlNCcsIFs4NzU2XV0sIFsndGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGVyZWZvcmUnLCBbODc1Nl1dLCBbJ1RoZXRhJywgWzkyMF1dLCBbJ3RoZXRhJywgWzk1Ml1dLCBbJ3RoZXRhc3ltJywgWzk3N11dLCBbJ3RoZXRhdicsIFs5NzddXSwgWyd0aGlja2FwcHJveCcsIFs4Nzc2XV0sIFsndGhpY2tzaW0nLCBbODc2NF1dLCBbJ1RoaWNrU3BhY2UnLCBbODI4NywgODIwMl1dLCBbJ1RoaW5TcGFjZScsIFs4MjAxXV0sIFsndGhpbnNwJywgWzgyMDFdXSwgWyd0aGthcCcsIFs4Nzc2XV0sIFsndGhrc2ltJywgWzg3NjRdXSwgWydUSE9STicsIFsyMjJdXSwgWyd0aG9ybicsIFsyNTRdXSwgWyd0aWxkZScsIFs3MzJdXSwgWydUaWxkZScsIFs4NzY0XV0sIFsnVGlsZGVFcXVhbCcsIFs4NzcxXV0sIFsnVGlsZGVGdWxsRXF1YWwnLCBbODc3M11dLCBbJ1RpbGRlVGlsZGUnLCBbODc3Nl1dLCBbJ3RpbWVzYmFyJywgWzEwODAxXV0sIFsndGltZXNiJywgWzg4NjRdXSwgWyd0aW1lcycsIFsyMTVdXSwgWyd0aW1lc2QnLCBbMTA4MDBdXSwgWyd0aW50JywgWzg3NDldXSwgWyd0b2VhJywgWzEwNTM2XV0sIFsndG9wYm90JywgWzkwMTRdXSwgWyd0b3BjaXInLCBbMTA5OTNdXSwgWyd0b3AnLCBbODg2OF1dLCBbJ1RvcGYnLCBbMTIwMTM5XV0sIFsndG9wZicsIFsxMjAxNjVdXSwgWyd0b3Bmb3JrJywgWzEwOTcwXV0sIFsndG9zYScsIFsxMDUzN11dLCBbJ3RwcmltZScsIFs4MjQ0XV0sIFsndHJhZGUnLCBbODQ4Ml1dLCBbJ1RSQURFJywgWzg0ODJdXSwgWyd0cmlhbmdsZScsIFs5NjUzXV0sIFsndHJpYW5nbGVkb3duJywgWzk2NjNdXSwgWyd0cmlhbmdsZWxlZnQnLCBbOTY2N11dLCBbJ3RyaWFuZ2xlbGVmdGVxJywgWzg4ODRdXSwgWyd0cmlhbmdsZXEnLCBbODc5Nl1dLCBbJ3RyaWFuZ2xlcmlnaHQnLCBbOTY1N11dLCBbJ3RyaWFuZ2xlcmlnaHRlcScsIFs4ODg1XV0sIFsndHJpZG90JywgWzk3MDhdXSwgWyd0cmllJywgWzg3OTZdXSwgWyd0cmltaW51cycsIFsxMDgxMF1dLCBbJ1RyaXBsZURvdCcsIFs4NDExXV0sIFsndHJpcGx1cycsIFsxMDgwOV1dLCBbJ3RyaXNiJywgWzEwNzAxXV0sIFsndHJpdGltZScsIFsxMDgxMV1dLCBbJ3RycGV6aXVtJywgWzkxODZdXSwgWydUc2NyJywgWzExOTk4M11dLCBbJ3RzY3InLCBbMTIwMDA5XV0sIFsnVFNjeScsIFsxMDYyXV0sIFsndHNjeScsIFsxMDk0XV0sIFsnVFNIY3knLCBbMTAzNV1dLCBbJ3RzaGN5JywgWzExMTVdXSwgWydUc3Ryb2snLCBbMzU4XV0sIFsndHN0cm9rJywgWzM1OV1dLCBbJ3R3aXh0JywgWzg4MTJdXSwgWyd0d29oZWFkbGVmdGFycm93JywgWzg2MDZdXSwgWyd0d29oZWFkcmlnaHRhcnJvdycsIFs4NjA4XV0sIFsnVWFjdXRlJywgWzIxOF1dLCBbJ3VhY3V0ZScsIFsyNTBdXSwgWyd1YXJyJywgWzg1OTNdXSwgWydVYXJyJywgWzg2MDddXSwgWyd1QXJyJywgWzg2NTddXSwgWydVYXJyb2NpcicsIFsxMDU2OV1dLCBbJ1VicmN5JywgWzEwMzhdXSwgWyd1YnJjeScsIFsxMTE4XV0sIFsnVWJyZXZlJywgWzM2NF1dLCBbJ3VicmV2ZScsIFszNjVdXSwgWydVY2lyYycsIFsyMTldXSwgWyd1Y2lyYycsIFsyNTFdXSwgWydVY3knLCBbMTA1OV1dLCBbJ3VjeScsIFsxMDkxXV0sIFsndWRhcnInLCBbODY0NV1dLCBbJ1VkYmxhYycsIFszNjhdXSwgWyd1ZGJsYWMnLCBbMzY5XV0sIFsndWRoYXInLCBbMTA2MDZdXSwgWyd1ZmlzaHQnLCBbMTA2MjJdXSwgWydVZnInLCBbMTIwMDg4XV0sIFsndWZyJywgWzEyMDExNF1dLCBbJ1VncmF2ZScsIFsyMTddXSwgWyd1Z3JhdmUnLCBbMjQ5XV0sIFsndUhhcicsIFsxMDU5NV1dLCBbJ3VoYXJsJywgWzg2MzldXSwgWyd1aGFycicsIFs4NjM4XV0sIFsndWhibGsnLCBbOTYwMF1dLCBbJ3VsY29ybicsIFs4OTg4XV0sIFsndWxjb3JuZXInLCBbODk4OF1dLCBbJ3VsY3JvcCcsIFs4OTc1XV0sIFsndWx0cmknLCBbOTcyMF1dLCBbJ1VtYWNyJywgWzM2Ml1dLCBbJ3VtYWNyJywgWzM2M11dLCBbJ3VtbCcsIFsxNjhdXSwgWydVbmRlckJhcicsIFs5NV1dLCBbJ1VuZGVyQnJhY2UnLCBbOTE4M11dLCBbJ1VuZGVyQnJhY2tldCcsIFs5MTQxXV0sIFsnVW5kZXJQYXJlbnRoZXNpcycsIFs5MTgxXV0sIFsnVW5pb24nLCBbODg5OV1dLCBbJ1VuaW9uUGx1cycsIFs4ODQ2XV0sIFsnVW9nb24nLCBbMzcwXV0sIFsndW9nb24nLCBbMzcxXV0sIFsnVW9wZicsIFsxMjAxNDBdXSwgWyd1b3BmJywgWzEyMDE2Nl1dLCBbJ1VwQXJyb3dCYXInLCBbMTA1MTRdXSwgWyd1cGFycm93JywgWzg1OTNdXSwgWydVcEFycm93JywgWzg1OTNdXSwgWydVcGFycm93JywgWzg2NTddXSwgWydVcEFycm93RG93bkFycm93JywgWzg2NDVdXSwgWyd1cGRvd25hcnJvdycsIFs4NTk3XV0sIFsnVXBEb3duQXJyb3cnLCBbODU5N11dLCBbJ1VwZG93bmFycm93JywgWzg2NjFdXSwgWydVcEVxdWlsaWJyaXVtJywgWzEwNjA2XV0sIFsndXBoYXJwb29ubGVmdCcsIFs4NjM5XV0sIFsndXBoYXJwb29ucmlnaHQnLCBbODYzOF1dLCBbJ3VwbHVzJywgWzg4NDZdXSwgWydVcHBlckxlZnRBcnJvdycsIFs4NTk4XV0sIFsnVXBwZXJSaWdodEFycm93JywgWzg1OTldXSwgWyd1cHNpJywgWzk2NV1dLCBbJ1Vwc2knLCBbOTc4XV0sIFsndXBzaWgnLCBbOTc4XV0sIFsnVXBzaWxvbicsIFs5MzNdXSwgWyd1cHNpbG9uJywgWzk2NV1dLCBbJ1VwVGVlQXJyb3cnLCBbODYxM11dLCBbJ1VwVGVlJywgWzg4NjldXSwgWyd1cHVwYXJyb3dzJywgWzg2NDhdXSwgWyd1cmNvcm4nLCBbODk4OV1dLCBbJ3VyY29ybmVyJywgWzg5ODldXSwgWyd1cmNyb3AnLCBbODk3NF1dLCBbJ1VyaW5nJywgWzM2Nl1dLCBbJ3VyaW5nJywgWzM2N11dLCBbJ3VydHJpJywgWzk3MjFdXSwgWydVc2NyJywgWzExOTk4NF1dLCBbJ3VzY3InLCBbMTIwMDEwXV0sIFsndXRkb3QnLCBbODk0NF1dLCBbJ1V0aWxkZScsIFszNjBdXSwgWyd1dGlsZGUnLCBbMzYxXV0sIFsndXRyaScsIFs5NjUzXV0sIFsndXRyaWYnLCBbOTY1Ml1dLCBbJ3V1YXJyJywgWzg2NDhdXSwgWydVdW1sJywgWzIyMF1dLCBbJ3V1bWwnLCBbMjUyXV0sIFsndXdhbmdsZScsIFsxMDY2M11dLCBbJ3ZhbmdydCcsIFsxMDY1Ml1dLCBbJ3ZhcmVwc2lsb24nLCBbMTAxM11dLCBbJ3ZhcmthcHBhJywgWzEwMDhdXSwgWyd2YXJub3RoaW5nJywgWzg3MDldXSwgWyd2YXJwaGknLCBbOTgxXV0sIFsndmFycGknLCBbOTgyXV0sIFsndmFycHJvcHRvJywgWzg3MzNdXSwgWyd2YXJyJywgWzg1OTddXSwgWyd2QXJyJywgWzg2NjFdXSwgWyd2YXJyaG8nLCBbMTAwOV1dLCBbJ3ZhcnNpZ21hJywgWzk2Ml1dLCBbJ3ZhcnN1YnNldG5lcScsIFs4ODQyLCA2NTAyNF1dLCBbJ3ZhcnN1YnNldG5lcXEnLCBbMTA5NTUsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxJywgWzg4NDMsIDY1MDI0XV0sIFsndmFyc3Vwc2V0bmVxcScsIFsxMDk1NiwgNjUwMjRdXSwgWyd2YXJ0aGV0YScsIFs5NzddXSwgWyd2YXJ0cmlhbmdsZWxlZnQnLCBbODg4Ml1dLCBbJ3ZhcnRyaWFuZ2xlcmlnaHQnLCBbODg4M11dLCBbJ3ZCYXInLCBbMTA5ODRdXSwgWydWYmFyJywgWzEwOTg3XV0sIFsndkJhcnYnLCBbMTA5ODVdXSwgWydWY3knLCBbMTA0Ml1dLCBbJ3ZjeScsIFsxMDc0XV0sIFsndmRhc2gnLCBbODg2Nl1dLCBbJ3ZEYXNoJywgWzg4NzJdXSwgWydWZGFzaCcsIFs4ODczXV0sIFsnVkRhc2gnLCBbODg3NV1dLCBbJ1ZkYXNobCcsIFsxMDk4Ml1dLCBbJ3ZlZWJhcicsIFs4ODkxXV0sIFsndmVlJywgWzg3NDRdXSwgWydWZWUnLCBbODg5N11dLCBbJ3ZlZWVxJywgWzg3OTRdXSwgWyd2ZWxsaXAnLCBbODk0Ml1dLCBbJ3ZlcmJhcicsIFsxMjRdXSwgWydWZXJiYXInLCBbODIxNF1dLCBbJ3ZlcnQnLCBbMTI0XV0sIFsnVmVydCcsIFs4MjE0XV0sIFsnVmVydGljYWxCYXInLCBbODczOV1dLCBbJ1ZlcnRpY2FsTGluZScsIFsxMjRdXSwgWydWZXJ0aWNhbFNlcGFyYXRvcicsIFsxMDA3Ml1dLCBbJ1ZlcnRpY2FsVGlsZGUnLCBbODc2OF1dLCBbJ1ZlcnlUaGluU3BhY2UnLCBbODIwMl1dLCBbJ1ZmcicsIFsxMjAwODldXSwgWyd2ZnInLCBbMTIwMTE1XV0sIFsndmx0cmknLCBbODg4Ml1dLCBbJ3Zuc3ViJywgWzg4MzQsIDg0MDJdXSwgWyd2bnN1cCcsIFs4ODM1LCA4NDAyXV0sIFsnVm9wZicsIFsxMjAxNDFdXSwgWyd2b3BmJywgWzEyMDE2N11dLCBbJ3Zwcm9wJywgWzg3MzNdXSwgWyd2cnRyaScsIFs4ODgzXV0sIFsnVnNjcicsIFsxMTk5ODVdXSwgWyd2c2NyJywgWzEyMDAxMV1dLCBbJ3ZzdWJuRScsIFsxMDk1NSwgNjUwMjRdXSwgWyd2c3VibmUnLCBbODg0MiwgNjUwMjRdXSwgWyd2c3VwbkUnLCBbMTA5NTYsIDY1MDI0XV0sIFsndnN1cG5lJywgWzg4NDMsIDY1MDI0XV0sIFsnVnZkYXNoJywgWzg4NzRdXSwgWyd2emlnemFnJywgWzEwNjUwXV0sIFsnV2NpcmMnLCBbMzcyXV0sIFsnd2NpcmMnLCBbMzczXV0sIFsnd2VkYmFyJywgWzEwODQ3XV0sIFsnd2VkZ2UnLCBbODc0M11dLCBbJ1dlZGdlJywgWzg4OTZdXSwgWyd3ZWRnZXEnLCBbODc5M11dLCBbJ3dlaWVycCcsIFs4NDcyXV0sIFsnV2ZyJywgWzEyMDA5MF1dLCBbJ3dmcicsIFsxMjAxMTZdXSwgWydXb3BmJywgWzEyMDE0Ml1dLCBbJ3dvcGYnLCBbMTIwMTY4XV0sIFsnd3AnLCBbODQ3Ml1dLCBbJ3dyJywgWzg3NjhdXSwgWyd3cmVhdGgnLCBbODc2OF1dLCBbJ1dzY3InLCBbMTE5OTg2XV0sIFsnd3NjcicsIFsxMjAwMTJdXSwgWyd4Y2FwJywgWzg4OThdXSwgWyd4Y2lyYycsIFs5NzExXV0sIFsneGN1cCcsIFs4ODk5XV0sIFsneGR0cmknLCBbOTY2MV1dLCBbJ1hmcicsIFsxMjAwOTFdXSwgWyd4ZnInLCBbMTIwMTE3XV0sIFsneGhhcnInLCBbMTAyMzFdXSwgWyd4aEFycicsIFsxMDIzNF1dLCBbJ1hpJywgWzkyNl1dLCBbJ3hpJywgWzk1OF1dLCBbJ3hsYXJyJywgWzEwMjI5XV0sIFsneGxBcnInLCBbMTAyMzJdXSwgWyd4bWFwJywgWzEwMjM2XV0sIFsneG5pcycsIFs4OTU1XV0sIFsneG9kb3QnLCBbMTA3NTJdXSwgWydYb3BmJywgWzEyMDE0M11dLCBbJ3hvcGYnLCBbMTIwMTY5XV0sIFsneG9wbHVzJywgWzEwNzUzXV0sIFsneG90aW1lJywgWzEwNzU0XV0sIFsneHJhcnInLCBbMTAyMzBdXSwgWyd4ckFycicsIFsxMDIzM11dLCBbJ1hzY3InLCBbMTE5OTg3XV0sIFsneHNjcicsIFsxMjAwMTNdXSwgWyd4c3FjdXAnLCBbMTA3NThdXSwgWyd4dXBsdXMnLCBbMTA3NTZdXSwgWyd4dXRyaScsIFs5NjUxXV0sIFsneHZlZScsIFs4ODk3XV0sIFsneHdlZGdlJywgWzg4OTZdXSwgWydZYWN1dGUnLCBbMjIxXV0sIFsneWFjdXRlJywgWzI1M11dLCBbJ1lBY3knLCBbMTA3MV1dLCBbJ3lhY3knLCBbMTEwM11dLCBbJ1ljaXJjJywgWzM3NF1dLCBbJ3ljaXJjJywgWzM3NV1dLCBbJ1ljeScsIFsxMDY3XV0sIFsneWN5JywgWzEwOTldXSwgWyd5ZW4nLCBbMTY1XV0sIFsnWWZyJywgWzEyMDA5Ml1dLCBbJ3lmcicsIFsxMjAxMThdXSwgWydZSWN5JywgWzEwMzFdXSwgWyd5aWN5JywgWzExMTFdXSwgWydZb3BmJywgWzEyMDE0NF1dLCBbJ3lvcGYnLCBbMTIwMTcwXV0sIFsnWXNjcicsIFsxMTk5ODhdXSwgWyd5c2NyJywgWzEyMDAxNF1dLCBbJ1lVY3knLCBbMTA3MF1dLCBbJ3l1Y3knLCBbMTEwMl1dLCBbJ3l1bWwnLCBbMjU1XV0sIFsnWXVtbCcsIFszNzZdXSwgWydaYWN1dGUnLCBbMzc3XV0sIFsnemFjdXRlJywgWzM3OF1dLCBbJ1pjYXJvbicsIFszODFdXSwgWyd6Y2Fyb24nLCBbMzgyXV0sIFsnWmN5JywgWzEwNDddXSwgWyd6Y3knLCBbMTA3OV1dLCBbJ1pkb3QnLCBbMzc5XV0sIFsnemRvdCcsIFszODBdXSwgWyd6ZWV0cmYnLCBbODQ4OF1dLCBbJ1plcm9XaWR0aFNwYWNlJywgWzgyMDNdXSwgWydaZXRhJywgWzkxOF1dLCBbJ3pldGEnLCBbOTUwXV0sIFsnemZyJywgWzEyMDExOV1dLCBbJ1pmcicsIFs4NDg4XV0sIFsnWkhjeScsIFsxMDQ2XV0sIFsnemhjeScsIFsxMDc4XV0sIFsnemlncmFycicsIFs4NjY5XV0sIFsnem9wZicsIFsxMjAxNzFdXSwgWydab3BmJywgWzg0ODRdXSwgWydac2NyJywgWzExOTk4OV1dLCBbJ3pzY3InLCBbMTIwMDE1XV0sIFsnendqJywgWzgyMDVdXSwgWyd6d25qJywgWzgyMDRdXV07XG5cbnZhciBhbHBoYUluZGV4ID0ge307XG52YXIgY2hhckluZGV4ID0ge307XG5cbmNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHRtbDVFbnRpdGllcygpIHt9XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyYoIz9bXFx3XFxkXSspOz8vZywgZnVuY3Rpb24ocywgZW50aXR5KSB7XG4gICAgICAgIHZhciBjaHI7XG4gICAgICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBlbnRpdHkuY2hhckF0KDEpID09PSAneCcgP1xuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSwgMTYpIDpcbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDEpKTtcblxuICAgICAgICAgICAgaWYgKCEoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpKSB7XG4gICAgICAgICAgICAgICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNociA9IGFscGhhSW5kZXhbZW50aXR5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hyIHx8IHM7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmRlY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGFySW5mbyA9IGNoYXJJbmRleFtzdHIuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5lbmNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbY107XG4gICAgICAgIGlmIChjaGFySW5mbykge1xuICAgICAgICAgICAgdmFyIGFscGhhID0gY2hhckluZm9bc3RyLmNoYXJDb2RlQXQoaSArIDEpXTtcbiAgICAgICAgICAgIGlmIChhbHBoYSkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWxwaGEgPSBjaGFySW5mb1snJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IDMyIHx8IGMgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlTm9uVVRGID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrXG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbHBoYUluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY2hhckluZGV4IFBhc3NlZCBieSByZWZlcmVuY2UuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZXMoYWxwaGFJbmRleCwgY2hhckluZGV4KSB7XG4gICAgdmFyIGkgPSBFTlRJVElFUy5sZW5ndGg7XG4gICAgdmFyIF9yZXN1bHRzID0gW107XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB2YXIgZSA9IEVOVElUSUVTW2ldO1xuICAgICAgICB2YXIgYWxwaGEgPSBlWzBdO1xuICAgICAgICB2YXIgY2hhcnMgPSBlWzFdO1xuICAgICAgICB2YXIgY2hyID0gY2hhcnNbMF07XG4gICAgICAgIHZhciBhZGRDaGFyID0gKGNociA8IDMyIHx8IGNociA+IDEyNikgfHwgY2hyID09PSA2MiB8fCBjaHIgPT09IDYwIHx8IGNociA9PT0gMzggfHwgY2hyID09PSAzNCB8fCBjaHIgPT09IDM5O1xuICAgICAgICB2YXIgY2hhckluZm87XG4gICAgICAgIGlmIChhZGRDaGFyKSB7XG4gICAgICAgICAgICBjaGFySW5mbyA9IGNoYXJJbmRleFtjaHJdID0gY2hhckluZGV4W2Nocl0gfHwge307XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJzWzFdKSB7XG4gICAgICAgICAgICB2YXIgY2hyMiA9IGNoYXJzWzFdO1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocikgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjIpO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChhZGRDaGFyICYmIChjaGFySW5mb1tjaHIyXSA9IGFscGhhKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbHBoYUluZGV4W2FscGhhXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bJyddID0gYWxwaGEpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sNUVudGl0aWVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nID0gcmVxdWlyZSgnbG9nbGV2ZWwnKS5nZXRMb2dnZXIoJ3dlYnBhY2stZGV2LXNlcnZlcicpO1xuXG52YXIgSU5GTyA9ICdpbmZvJztcbnZhciBXQVJOID0gJ3dhcm4nO1xudmFyIEVSUk9SID0gJ2Vycm9yJztcbnZhciBERUJVRyA9ICdkZWJ1Zyc7XG52YXIgVFJBQ0UgPSAndHJhY2UnO1xudmFyIFNJTEVOVCA9ICdzaWxlbnQnOyAvLyBkZXByZWNhdGVkXG4vLyBUT0RPOiByZW1vdmUgdGhlc2UgYXQgbWFqb3IgcmVsZWFzZWRcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9wdWxsLzE4MjVcblxudmFyIFdBUk5JTkcgPSAnd2FybmluZyc7XG52YXIgTk9ORSA9ICdub25lJzsgLy8gU2V0IHRoZSBkZWZhdWx0IGxvZyBsZXZlbFxuXG5sb2cuc2V0RGVmYXVsdExldmVsKElORk8pO1xuXG5mdW5jdGlvbiBzZXRMb2dMZXZlbChsZXZlbCkge1xuICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgY2FzZSBJTkZPOlxuICAgIGNhc2UgV0FSTjpcbiAgICBjYXNlIEVSUk9SOlxuICAgIGNhc2UgREVCVUc6XG4gICAgY2FzZSBUUkFDRTpcbiAgICAgIGxvZy5zZXRMZXZlbChsZXZlbCk7XG4gICAgICBicmVhaztcbiAgICAvLyBkZXByZWNhdGVkXG5cbiAgICBjYXNlIFdBUk5JTkc6XG4gICAgICAvLyBsb2dsZXZlbCdzIHdhcm5pbmcgbmFtZSBpcyBkaWZmZXJlbnQgZnJvbSB3ZWJwYWNrJ3NcbiAgICAgIGxvZy5zZXRMZXZlbCgnd2FybicpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gZGVwcmVjYXRlZFxuXG4gICAgY2FzZSBOT05FOlxuICAgIGNhc2UgU0lMRU5UOlxuICAgICAgbG9nLmRpc2FibGVBbGwoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGxvZy5lcnJvcihcIltXRFNdIFVua25vd24gY2xpZW50TG9nTGV2ZWwgJ1wiLmNvbmNhdChsZXZlbCwgXCInXCIpKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nOiBsb2csXG4gIHNldExvZ0xldmVsOiBzZXRMb2dMZXZlbFxufTsiLCIvKlxuKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbFxuKlxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVGltIFBlcnJ5XG4qIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiovXG4oZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShkZWZpbml0aW9uKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QubG9nID0gZGVmaW5pdGlvbigpO1xuICAgIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB2YXIgdW5kZWZpbmVkVHlwZSA9IFwidW5kZWZpbmVkXCI7XG4gICAgdmFyIGlzSUUgPSAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSkgJiYgKFxuICAgICAgICAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcbiAgICApO1xuXG4gICAgdmFyIGxvZ01ldGhvZHMgPSBbXG4gICAgICAgIFwidHJhY2VcIixcbiAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICBcImluZm9cIixcbiAgICAgICAgXCJ3YXJuXCIsXG4gICAgICAgIFwiZXJyb3JcIlxuICAgIF07XG5cbiAgICAvLyBDcm9zcy1icm93c2VyIGJpbmQgZXF1aXZhbGVudCB0aGF0IHdvcmtzIGF0IGxlYXN0IGJhY2sgdG8gSUU2XG4gICAgZnVuY3Rpb24gYmluZE1ldGhvZChvYmosIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5iaW5kKG9iaik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKG1ldGhvZCwgb2JqKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBNaXNzaW5nIGJpbmQgc2hpbSBvciBJRTggKyBNb2Rlcm5penIsIGZhbGxiYWNrIHRvIHdyYXBwaW5nXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICBmdW5jdGlvbiB0cmFjZUZvcklFKCkge1xuICAgICAgICBpZiAoY29uc29sZS5sb2cpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIG9sZCBJRSwgbmF0aXZlIGNvbnNvbGUgbWV0aG9kcyB0aGVtc2VsdmVzIGRvbid0IGhhdmUgYXBwbHkoKS5cbiAgICAgICAgICAgICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkoY29uc29sZS5sb2csIFtjb25zb2xlLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZS50cmFjZSkgY29uc29sZS50cmFjZSgpO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgIC8vIFdoZXJldmVyIHBvc3NpYmxlIHdlIHdhbnQgdG8gYmluZCwgbm90IHdyYXAsIHRvIHByZXNlcnZlIHN0YWNrIHRyYWNlc1xuICAgIGZ1bmN0aW9uIHJlYWxNZXRob2QobWV0aG9kTmFtZSkge1xuICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgbWV0aG9kTmFtZSA9ICdsb2cnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIE5vIG1ldGhvZCBwb3NzaWJsZSwgZm9yIG5vdyAtIGZpeGVkIGxhdGVyIGJ5IGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXNcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2ROYW1lID09PSAndHJhY2UnICYmIGlzSUUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFjZUZvcklFO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGVbbWV0aG9kTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgJ2xvZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlTG9nZ2luZ01ldGhvZHMobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgICB0aGlzW21ldGhvZE5hbWVdID0gKGkgPCBsZXZlbCkgP1xuICAgICAgICAgICAgICAgIG5vb3AgOlxuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcbiAgICB9XG5cbiAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHNcbiAgICBmdW5jdGlvbiBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzKG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzLCBsZXZlbCwgbG9nZ2VyTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdhaXQgZm9yIGEgY29uc29sZSB0byBhcHBlYXIsIGFuZCB0aGVuIHRyeSBhZ2Fpbi5cbiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fFxuICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjdXJyZW50TGV2ZWw7XG4gICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgKz0gXCI6XCIgKyBuYW1lO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7XG4gICAgICAgICAgdmFyIGxldmVsTmFtZSA9IChsb2dNZXRob2RzW2xldmVsTnVtXSB8fCAnc2lsZW50JykudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV0gPSBsZXZlbE5hbWU7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBVc2Ugc2Vzc2lvbiBjb29raWUgYXMgZmFsbGJhY2tcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID1cbiAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIiArIGxldmVsTmFtZSArIFwiO1wiO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUpIHJldHVybjtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoXG4gICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIpO1xuICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbikpWzFdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN0b3JlZExldmVsO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcbiAgICAgIH1cbiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKlxuICAgICAqIFRvcC1sZXZlbCBBUElcbiAgICAgKlxuICAgICAqL1xuXG4gICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG5cbiAgICB2YXIgX2xvZ2dlcnNCeU5hbWUgPSB7fTtcbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV07XG4gICAgICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICAgICAgbG9nZ2VyID0gX2xvZ2dlcnNCeU5hbWVbbmFtZV0gPSBuZXcgTG9nZ2VyKFxuICAgICAgICAgICAgbmFtZSwgZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgfTtcblxuICAgIC8vIEdyYWIgdGhlIGN1cnJlbnQgZ2xvYmFsIGxvZyB2YXJpYWJsZSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfbG9nID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpID8gd2luZG93LmxvZyA6IHVuZGVmaW5lZDtcbiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUgJiZcbiAgICAgICAgICAgICAgIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfTtcblxuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7XG4gICAgICAgIHJldHVybiBfbG9nZ2Vyc0J5TmFtZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgX19yZXNvdXJjZVF1ZXJ5IFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cbi8vIFNlbmQgbWVzc2FnZXMgdG8gdGhlIG91dHNpZGUsIHNvIHBsdWdpbnMgY2FuIGNvbnN1bWUgaXQuXG5cbmZ1bmN0aW9uIHNlbmRNc2codHlwZSwgZGF0YSkge1xuICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnIHx8ICEoc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlKSkpIHtcbiAgICBzZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IFwid2VicGFja1wiLmNvbmNhdCh0eXBlKSxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9LCAnKicpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VuZE1zZzsiLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2xvZycpLFxuICAgIGxvZyA9IF9yZXF1aXJlLmxvZztcblxuZnVuY3Rpb24gcmVsb2FkQXBwKF9yZWYsIF9yZWYyKSB7XG4gIHZhciBob3RSZWxvYWQgPSBfcmVmLmhvdFJlbG9hZCxcbiAgICAgIGhvdCA9IF9yZWYuaG90LFxuICAgICAgbGl2ZVJlbG9hZCA9IF9yZWYubGl2ZVJlbG9hZDtcbiAgdmFyIGlzVW5sb2FkaW5nID0gX3JlZjIuaXNVbmxvYWRpbmcsXG4gICAgICBjdXJyZW50SGFzaCA9IF9yZWYyLmN1cnJlbnRIYXNoO1xuXG4gIGlmIChpc1VubG9hZGluZyB8fCAhaG90UmVsb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGhvdCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgaG90IHVwZGF0ZS4uLicpO1xuXG4gICAgdmFyIGhvdEVtaXR0ZXIgPSByZXF1aXJlKCd3ZWJwYWNrL2hvdC9lbWl0dGVyJyk7XG5cbiAgICBob3RFbWl0dGVyLmVtaXQoJ3dlYnBhY2tIb3RVcGRhdGUnLCBjdXJyZW50SGFzaCk7XG5cbiAgICBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYud2luZG93KSB7XG4gICAgICAvLyBicm9hZGNhc3QgdXBkYXRlIHRvIHdpbmRvd1xuICAgICAgc2VsZi5wb3N0TWVzc2FnZShcIndlYnBhY2tIb3RVcGRhdGVcIi5jb25jYXQoY3VycmVudEhhc2gpLCAnKicpO1xuICAgIH1cbiAgfSAvLyBhbGxvdyByZWZyZXNoaW5nIHRoZSBwYWdlIG9ubHkgaWYgbGl2ZVJlbG9hZCBpc24ndCBkaXNhYmxlZFxuICBlbHNlIGlmIChsaXZlUmVsb2FkKSB7XG4gICAgICB2YXIgcm9vdFdpbmRvdyA9IHNlbGY7IC8vIHVzZSBwYXJlbnQgd2luZG93IGZvciByZWxvYWQgKGluIGNhc2Ugd2UncmUgaW4gYW4gaWZyYW1lIHdpdGggbm8gdmFsaWQgc3JjKVxuXG4gICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNlbGYuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocm9vdFdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCAhPT0gJ2Fib3V0OicpIHtcbiAgICAgICAgICAvLyByZWxvYWQgaW1tZWRpYXRlbHkgaWYgcHJvdG9jb2wgaXMgdmFsaWRcbiAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290V2luZG93ID0gcm9vdFdpbmRvdy5wYXJlbnQ7XG5cbiAgICAgICAgICBpZiAocm9vdFdpbmRvdy5wYXJlbnQgPT09IHJvb3RXaW5kb3cpIHtcbiAgICAgICAgICAgIC8vIGlmIHBhcmVudCBlcXVhbHMgY3VycmVudCB3aW5kb3cgd2UndmUgcmVhY2hlZCB0aGUgcm9vdCB3aGljaCB3b3VsZCBjb250aW51ZSBmb3JldmVyLCBzbyB0cmlnZ2VyIGEgcmVsb2FkIGFueXdheXNcbiAgICAgICAgICAgIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5UmVsb2FkKHJvb3RXaW5kb3csIGludGVydmFsSWQpIHtcbiAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgIGxvZy5pbmZvKCdbV0RTXSBBcHAgdXBkYXRlZC4gUmVsb2FkaW5nLi4uJyk7XG4gICAgcm9vdFdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlbG9hZEFwcDsiLCJ2YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG4vKiBnbG9iYWwgc2VsZiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBnZXRDdXJyZW50U2NyaXB0U291cmNlID0gcmVxdWlyZSgnLi9nZXRDdXJyZW50U2NyaXB0U291cmNlJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNvY2tldFVybChyZXNvdXJjZVF1ZXJ5LCBjdXJyZW50TG9jYXRpb24pIHtcbiAgdmFyIHVybFBhcnRzO1xuXG4gIGlmICh0eXBlb2YgcmVzb3VyY2VRdWVyeSA9PT0gJ3N0cmluZycgJiYgcmVzb3VyY2VRdWVyeSAhPT0gJycpIHtcbiAgICAvLyBJZiB0aGlzIGJ1bmRsZSBpcyBpbmxpbmVkLCB1c2UgdGhlIHJlc291cmNlIHF1ZXJ5IHRvIGdldCB0aGUgY29ycmVjdCB1cmwuXG4gICAgLy8gZm9ybWF0IGlzIGxpa2UgYD9odHRwOi8vMC4wLjAuMDo4MDk2JnNvY2tQb3J0PTgwOTcmc29ja0hvc3Q9bG9jYWxob3N0YFxuICAgIHVybFBhcnRzID0gdXJsLnBhcnNlKHJlc291cmNlUXVlcnkgLy8gc3RyaXAgbGVhZGluZyBgP2AgZnJvbSBxdWVyeSBzdHJpbmcgdG8gZ2V0IGEgdmFsaWQgVVJMXG4gICAgLnN1YnN0cigxKSAvLyByZXBsYWNlIGZpcnN0IGAmYCB3aXRoIGA/YCB0byBoYXZlIGEgdmFsaWQgcXVlcnkgc3RyaW5nXG4gICAgLnJlcGxhY2UoJyYnLCAnPycpLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFbHNlLCBnZXQgdGhlIHVybCBmcm9tIHRoZSA8c2NyaXB0PiB0aGlzIGZpbGUgd2FzIGNhbGxlZCB3aXRoLlxuICAgIHZhciBzY3JpcHRIb3N0ID0gZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSgpO1xuICAgIHVybFBhcnRzID0gdXJsLnBhcnNlKHNjcmlwdEhvc3QgfHwgJy8nLCB0cnVlLCB0cnVlKTtcbiAgfSAvLyBVc2UgcGFyYW1ldGVyIHRvIGFsbG93IHBhc3NpbmcgbG9jYXRpb24gaW4gdW5pdCB0ZXN0c1xuXG5cbiAgaWYgKHR5cGVvZiBjdXJyZW50TG9jYXRpb24gPT09ICdzdHJpbmcnICYmIGN1cnJlbnRMb2NhdGlvbiAhPT0gJycpIHtcbiAgICBjdXJyZW50TG9jYXRpb24gPSB1cmwucGFyc2UoY3VycmVudExvY2F0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50TG9jYXRpb24gPSBzZWxmLmxvY2F0aW9uO1xuICB9XG5cbiAgcmV0dXJuIGdldFNvY2tldFVybCh1cmxQYXJ0cywgY3VycmVudExvY2F0aW9uKTtcbn1cbi8qXG4gKiBHZXRzIHNvY2tldCBVUkwgYmFzZWQgb24gU2NyaXB0IFNvdXJjZS9Mb2NhdGlvblxuICogKHNjcmlwdFNyYzogVVJMLCBsb2NhdGlvbjogVVJMKSAtPiBVUkxcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFNvY2tldFVybCh1cmxQYXJ0cywgbG9jKSB7XG4gIHZhciBhdXRoID0gdXJsUGFydHMuYXV0aCxcbiAgICAgIHF1ZXJ5ID0gdXJsUGFydHMucXVlcnk7XG4gIHZhciBob3N0bmFtZSA9IHVybFBhcnRzLmhvc3RuYW1lLFxuICAgICAgcHJvdG9jb2wgPSB1cmxQYXJ0cy5wcm90b2NvbCxcbiAgICAgIHBvcnQgPSB1cmxQYXJ0cy5wb3J0O1xuXG4gIGlmICghcG9ydCB8fCBwb3J0ID09PSAnMCcpIHtcbiAgICBwb3J0ID0gbG9jLnBvcnQ7XG4gIH0gLy8gY2hlY2sgaXB2NCBhbmQgaXB2NiBgYWxsIGhvc3RuYW1lYFxuICAvLyB3aHkgZG8gd2UgbmVlZCB0aGlzIGNoZWNrP1xuICAvLyBob3N0bmFtZSBuL2EgZm9yIGZpbGUgcHJvdG9jb2wgKGV4YW1wbGUsIHdoZW4gdXNpbmcgZWxlY3Ryb24sIGlvbmljKVxuICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL3dlYnBhY2stZGV2LXNlcnZlci9wdWxsLzM4NFxuXG5cbiAgaWYgKChob3N0bmFtZSA9PT0gJzAuMC4wLjAnIHx8IGhvc3RuYW1lID09PSAnOjonKSAmJiBsb2MuaG9zdG5hbWUgJiYgbG9jLnByb3RvY29sLmluZGV4T2YoJ2h0dHAnKSA9PT0gMCkge1xuICAgIGhvc3RuYW1lID0gbG9jLmhvc3RuYW1lO1xuICB9IC8vIGBob3N0bmFtZWAgY2FuIGJlIGVtcHR5IHdoZW4gdGhlIHNjcmlwdCBwYXRoIGlzIHJlbGF0aXZlLiBJbiB0aGF0IGNhc2UsIHNwZWNpZnlpbmdcbiAgLy8gYSBwcm90b2NvbCB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZCBVUkwuXG4gIC8vIFdoZW4gaHR0cHMgaXMgdXNlZCBpbiB0aGUgYXBwLCBzZWN1cmUgd2Vic29ja2V0cyBhcmUgYWx3YXlzIG5lY2Vzc2FyeVxuICAvLyBiZWNhdXNlIHRoZSBicm93c2VyIGRvZXNuJ3QgYWNjZXB0IG5vbi1zZWN1cmUgd2Vic29ja2V0cy5cblxuXG4gIGlmIChob3N0bmFtZSAmJiBob3N0bmFtZSAhPT0gJzEyNy4wLjAuMScgJiYgKGxvYy5wcm90b2NvbCA9PT0gJ2h0dHBzOicgfHwgdXJsUGFydHMuaG9zdG5hbWUgPT09ICcwLjAuMC4wJykpIHtcbiAgICBwcm90b2NvbCA9IGxvYy5wcm90b2NvbDtcbiAgfSAvLyBhbGwgb2YgdGhlc2Ugc29jayB1cmwgcGFyYW1zIGFyZSBvcHRpb25hbGx5IHBhc3NlZCBpbiB0aHJvdWdoXG4gIC8vIHJlc291cmNlUXVlcnksIHNvIHdlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIHRoZSBkZWZhdWx0IGlmXG4gIC8vIHRoZXkgYXJlIG5vdCBwcm92aWRlZFxuXG5cbiAgdmFyIHNvY2tIb3N0ID0gcXVlcnkuc29ja0hvc3QgfHwgaG9zdG5hbWU7XG4gIHZhciBzb2NrUGF0aCA9IHF1ZXJ5LnNvY2tQYXRoIHx8ICcvc29ja2pzLW5vZGUnO1xuICB2YXIgc29ja1BvcnQgPSBxdWVyeS5zb2NrUG9ydCB8fCBwb3J0O1xuXG4gIGlmIChzb2NrUG9ydCA9PT0gJ2xvY2F0aW9uJykge1xuICAgIHNvY2tQb3J0ID0gbG9jLnBvcnQ7XG4gIH1cblxuICByZXR1cm4gdXJsLmZvcm1hdCh7XG4gICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgIGF1dGg6IGF1dGgsXG4gICAgaG9zdG5hbWU6IHNvY2tIb3N0LFxuICAgIHBvcnQ6IHNvY2tQb3J0LFxuICAgIC8vIElmIHNvY2tQYXRoIGlzIHByb3ZpZGVkIGl0J2xsIGJlIHBhc3NlZCBpbiB2aWEgdGhlIHJlc291cmNlUXVlcnkgYXMgYVxuICAgIC8vIHF1ZXJ5IHBhcmFtIHNvIGl0IGhhcyB0byBiZSBwYXJzZWQgb3V0IG9mIHRoZSBxdWVyeXN0cmluZyBpbiBvcmRlciBmb3IgdGhlXG4gICAgLy8gY2xpZW50IHRvIG9wZW4gdGhlIHNvY2tldCB0byB0aGUgY29ycmVjdCBsb2NhdGlvbi5cbiAgICBwYXRobmFtZTogc29ja1BhdGhcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU29ja2V0VXJsOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS4zLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMy4yJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKSB7XG4gIC8vIGBkb2N1bWVudC5jdXJyZW50U2NyaXB0YCBpcyB0aGUgbW9zdCBhY2N1cmF0ZSB3YXkgdG8gZmluZCB0aGUgY3VycmVudCBzY3JpcHQsXG4gIC8vIGJ1dCBpcyBub3Qgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vycy5cbiAgaWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICB9IC8vIEZhbGwgYmFjayB0byBnZXR0aW5nIGFsbCBzY3JpcHRzIGluIHRoZSBkb2N1bWVudC5cblxuXG4gIHZhciBzY3JpcHRFbGVtZW50cyA9IGRvY3VtZW50LnNjcmlwdHMgfHwgW107XG4gIHZhciBjdXJyZW50U2NyaXB0ID0gc2NyaXB0RWxlbWVudHNbc2NyaXB0RWxlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgaWYgKGN1cnJlbnRTY3JpcHQpIHtcbiAgICByZXR1cm4gY3VycmVudFNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICB9IC8vIEZhaWwgYXMgdGhlcmUgd2FzIG5vIHNjcmlwdCB0byB1c2UuXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1tXRFNdIEZhaWxlZCB0byBnZXQgY3VycmVudCBzY3JpcHQgc291cmNlLicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2U7IiwidmFyIG1hcCA9IHtcblx0XCIuL2xvZ1wiOiAzMVxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDMwOyIsInZhciBsb2dMZXZlbCA9IFwiaW5mb1wiO1xuXG5mdW5jdGlvbiBkdW1teSgpIHt9XG5cbmZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbCkge1xuXHR2YXIgc2hvdWxkTG9nID1cblx0XHQobG9nTGV2ZWwgPT09IFwiaW5mb1wiICYmIGxldmVsID09PSBcImluZm9cIikgfHxcblx0XHQoW1wiaW5mb1wiLCBcIndhcm5pbmdcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCIsIFwiZXJyb3JcIl0uaW5kZXhPZihsb2dMZXZlbCkgPj0gMCAmJiBsZXZlbCA9PT0gXCJlcnJvclwiKTtcblx0cmV0dXJuIHNob3VsZExvZztcbn1cblxuZnVuY3Rpb24gbG9nR3JvdXAobG9nRm4pIHtcblx0cmV0dXJuIGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0XHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdFx0bG9nRm4obXNnKTtcblx0XHR9XG5cdH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGV2ZWwsIG1zZykge1xuXHRpZiAoc2hvdWxkTG9nKGxldmVsKSkge1xuXHRcdGlmIChsZXZlbCA9PT0gXCJpbmZvXCIpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1zZyk7XG5cdFx0fSBlbHNlIGlmIChsZXZlbCA9PT0gXCJ3YXJuaW5nXCIpIHtcblx0XHRcdGNvbnNvbGUud2Fybihtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwiZXJyb3JcIikge1xuXHRcdFx0Y29uc29sZS5lcnJvcihtc2cpO1xuXHRcdH1cblx0fVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby11bnN1cHBvcnRlZC1mZWF0dXJlcy9ub2RlLWJ1aWx0aW5zICovXG52YXIgZ3JvdXAgPSBjb25zb2xlLmdyb3VwIHx8IGR1bW15O1xudmFyIGdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZCB8fCBkdW1teTtcbnZhciBncm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQgfHwgZHVtbXk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cCA9IGxvZ0dyb3VwKGdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMuZ3JvdXBDb2xsYXBzZWQgPSBsb2dHcm91cChncm91cENvbGxhcHNlZCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwRW5kID0gbG9nR3JvdXAoZ3JvdXBFbmQpO1xuXG5tb2R1bGUuZXhwb3J0cy5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uKGxldmVsKSB7XG5cdGxvZ0xldmVsID0gbGV2ZWw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHR2YXIgbWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuXHR2YXIgc3RhY2sgPSBlcnIuc3RhY2s7XG5cdGlmICghc3RhY2spIHtcblx0XHRyZXR1cm4gbWVzc2FnZTtcblx0fSBlbHNlIGlmIChzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDwgMCkge1xuXHRcdHJldHVybiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiBzdGFjaztcblx0fVxufTtcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYmlsbGJvYXJkLnNjc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cbnZhciBleHBvcnRlZCA9IGNvbnRlbnQubG9jYWxzID8gY29udGVudC5sb2NhbHMgOiB7fTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0ZWQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgdmFyIG1lbW87XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSgpIHtcbiAgICBpZiAodHlwZW9mIG1lbW8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuICAgICAgLy8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuICAgICAgLy8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuICAgICAgLy8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG4gICAgICAvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcbiAgICAgIG1lbW8gPSBCb29sZWFuKHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfTtcbn0oKTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uIGdldFRhcmdldCgpIHtcbiAgdmFyIG1lbW8gPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgIGlmICh0eXBlb2YgbWVtb1t0YXJnZXRdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpOyAvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXG4gICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtb1t0YXJnZXRdO1xuICB9O1xufSgpO1xuXG52YXIgc3R5bGVzSW5Eb20gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdXG4gICAgfTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXNJbkRvbS5wdXNoKHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogYWRkU3R5bGUob2JqLCBvcHRpb25zKSxcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgdmFyIGF0dHJpYnV0ZXMgPSBvcHRpb25zLmF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLm5vbmNlID09PSAndW5kZWZpbmVkJykge1xuICAgIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gJ3VuZGVmaW5lZCcgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG5cbiAgICBpZiAobm9uY2UpIHtcbiAgICAgIGF0dHJpYnV0ZXMubm9uY2UgPSBub25jZTtcbiAgICB9XG4gIH1cblxuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyaWJ1dGVzW2tleV0pO1xuICB9KTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb3B0aW9ucy5pbnNlcnQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0YXJnZXQgPSBnZXRUYXJnZXQob3B0aW9ucy5pbnNlcnQgfHwgJ2hlYWQnKTtcblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydCcgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuICAgIH1cblxuICAgIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbnZhciByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICB2YXIgdGV4dFN0b3JlID0gW107XG4gIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgIHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcbiAgICByZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcbiAgfTtcbn0oKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyhzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG4gIHZhciBjc3MgPSByZW1vdmUgPyAnJyA6IG9iai5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChvYmoubWVkaWEsIFwiIHtcIikuY29uY2F0KG9iai5jc3MsIFwifVwiKSA6IG9iai5jc3M7IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG4gICAgaWYgKGNoaWxkTm9kZXNbaW5kZXhdKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZSwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzO1xuICB2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCBtZWRpYSk7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKCdtZWRpYScpO1xuICB9XG5cbiAgaWYgKHNvdXJjZU1hcCAmJiBidG9hKSB7XG4gICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIi5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSwgXCIgKi9cIik7XG4gIH0gLy8gRm9yIG9sZCBJRVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi9cblxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZS5maXJzdENoaWxkKSB7XG4gICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhciBzaW5nbGV0b25Db3VudGVyID0gMDtcblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBzdHlsZTtcbiAgdmFyIHVwZGF0ZTtcbiAgdmFyIHJlbW92ZTtcblxuICBpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcbiAgICB2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcbiAgICBzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICByZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlID0gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICAgIHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cbiAgICByZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgIH07XG4gIH1cblxuICB1cGRhdGUob2JqKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlKCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbiAgLy8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXG4gIGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcbiAgfVxuXG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcblxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3TGlzdCkgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRG9tW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5Eb21bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRG9tW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpO1xuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qLS0gQ2hhcnQgLS0qL1xcbi5iYiBzdmcge1xcbiAgZm9udDogMTBweCBzYW5zLXNlcmlmO1xcbiAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApOyB9XFxuXFxuLmJiIHBhdGgsIC5iYiBsaW5lIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICMwMDA7IH1cXG5cXG4uYmIgdGV4dCwgLmJiIC5iYi1idXR0b24ge1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi1sZWdlbmQtaXRlbS10aWxlLFxcbi5iYi14Z3JpZC1mb2N1cyxcXG4uYmIteWdyaWQtZm9jdXMsXFxuLmJiLXlncmlkLFxcbi5iYi1ldmVudC1yZWN0LFxcbi5iYi1iYXJzIHBhdGgge1xcbiAgc2hhcGUtcmVuZGVyaW5nOiBjcmlzcEVkZ2VzOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyAuYmItZ2F1Z2UtdmFsdWUge1xcbiAgZmlsbDogIzAwMDsgfVxcblxcbi5iYi1jaGFydC1hcmMgcGF0aCB7XFxuICBzdHJva2U6ICNmZmY7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHJlY3Qge1xcbiAgc3Ryb2tlOiAjZmZmO1xcbiAgc3Ryb2tlLXdpZHRoOiAxOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyB0ZXh0IHtcXG4gIGZpbGw6ICNmZmY7XFxuICBmb250LXNpemU6IDEzcHg7IH1cXG5cXG4vKi0tIEF4aXMgLS0qL1xcbi5iYi1heGlzIHtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlczsgfVxcblxcbi8qLS0gR3JpZCAtLSovXFxuLmJiLWdyaWQgbGluZSB7XFxuICBzdHJva2U6ICNhYWE7IH1cXG5cXG4uYmItZ3JpZCB0ZXh0IHtcXG4gIGZpbGw6ICNhYWE7IH1cXG5cXG4uYmIteGdyaWQsIC5iYi15Z3JpZCB7XFxuICBzdHJva2UtZGFzaGFycmF5OiAzIDM7IH1cXG5cXG4vKi0tIFRleHQgb24gQ2hhcnQgLS0qL1xcbi5iYi10ZXh0LmJiLWVtcHR5IHtcXG4gIGZpbGw6ICM4MDgwODA7XFxuICBmb250LXNpemU6IDJlbTsgfVxcblxcbi8qLS0gTGluZSAtLSovXFxuLmJiLWxpbmUge1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7IH1cXG5cXG4vKi0tIFBvaW50IC0tKi9cXG4uYmItY2lyY2xlLl9leHBhbmRlZF8ge1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7XFxuICBzdHJva2U6IHdoaXRlOyB9XFxuXFxuLmJiLXNlbGVjdGVkLWNpcmNsZSB7XFxuICBmaWxsOiB3aGl0ZTtcXG4gIHN0cm9rZS13aWR0aDogMnB4OyB9XFxuXFxuLyotLSBCYXIgLS0qL1xcbi5iYi1iYXIge1xcbiAgc3Ryb2tlLXdpZHRoOiAwOyB9XFxuICAuYmItYmFyLl9leHBhbmRlZF8ge1xcbiAgICBmaWxsLW9wYWNpdHk6IDAuNzU7IH1cXG5cXG4vKi0tIEZvY3VzIC0tKi9cXG4uYmItdGFyZ2V0LmJiLWZvY3VzZWQge1xcbiAgb3BhY2l0eTogMTsgfVxcblxcbi5iYi10YXJnZXQuYmItZm9jdXNlZCBwYXRoLmJiLWxpbmUsIC5iYi10YXJnZXQuYmItZm9jdXNlZCBwYXRoLmJiLXN0ZXAge1xcbiAgc3Ryb2tlLXdpZHRoOiAycHg7IH1cXG5cXG4uYmItdGFyZ2V0LmJiLWRlZm9jdXNlZCB7XFxuICBvcGFjaXR5OiAwLjMgIWltcG9ydGFudDsgfVxcbiAgLmJiLXRhcmdldC5iYi1kZWZvY3VzZWQgLnRleHQtb3ZlcmxhcHBpbmcge1xcbiAgICBvcGFjaXR5OiAuMDUgIWltcG9ydGFudDsgfVxcblxcbi8qLS0gUmVnaW9uIC0tKi9cXG4uYmItcmVnaW9uIHtcXG4gIGZpbGw6IHN0ZWVsYmx1ZTtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIFpvb20gcmVnaW9uIC0tKi9cXG4uYmItem9vbS1icnVzaCB7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBCcnVzaCAtLSovXFxuLmJiLWJydXNoIC5leHRlbnQge1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gU2VsZWN0IC0gRHJhZyAtLSovXFxuLyotLSBMZWdlbmQgLS0qL1xcbi5iYi1sZWdlbmQtaXRlbSB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi1sZWdlbmQtaXRlbS1oaWRkZW4ge1xcbiAgb3BhY2l0eTogMC4xNTsgfVxcblxcbi5iYi1sZWdlbmQtYmFja2dyb3VuZCB7XFxuICBvcGFjaXR5OiAwLjc1O1xcbiAgZmlsbDogd2hpdGU7XFxuICBzdHJva2U6IGxpZ2h0Z3JheTtcXG4gIHN0cm9rZS13aWR0aDogMTsgfVxcblxcbi8qLS0gVGl0bGUgLS0qL1xcbi5iYi10aXRsZSB7XFxuICBmb250OiAxNHB4IHNhbnMtc2VyaWY7IH1cXG5cXG4vKi0tIFRvb2x0aXAgLS0qL1xcbi5iYi10b29sdGlwLWNvbnRhaW5lciB7XFxuICB6LWluZGV4OiAxMDtcXG4gIHVzZXItc2VsZWN0OiBub25lOyB9XFxuXFxuLmJiLXRvb2x0aXAge1xcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcXG4gIGJvcmRlci1zcGFjaW5nOiAwO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gIGVtcHR5LWNlbGxzOiBzaG93O1xcbiAgb3BhY2l0eTogMC45O1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3O1xcbiAgLW1vei1ib3gtc2hhZG93OiA3cHggN3B4IDEycHggLTlweCAjNzc3Nzc3O1xcbiAgYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NzsgfVxcbiAgLmJiLXRvb2x0aXAgdHIge1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCAjQ0NDOyB9XFxuICAuYmItdG9vbHRpcCB0aCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNhYWE7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgcGFkZGluZzogMnB4IDVweDtcXG4gICAgdGV4dC1hbGlnbjogbGVmdDtcXG4gICAgY29sb3I6ICNGRkY7IH1cXG4gIC5iYi10b29sdGlwIHRkIHtcXG4gICAgZm9udC1zaXplOiAxM3B4O1xcbiAgICBwYWRkaW5nOiAzcHggNnB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBib3JkZXItbGVmdDogMXB4IGRvdHRlZCAjOTk5OyB9XFxuICAgIC5iYi10b29sdGlwIHRkID4gc3BhbiwgLmJiLXRvb2x0aXAgdGQgPiBzdmcge1xcbiAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gICAgICB3aWR0aDogMTBweDtcXG4gICAgICBoZWlnaHQ6IDEwcHg7XFxuICAgICAgbWFyZ2luLXJpZ2h0OiA2cHg7IH1cXG4gIC5iYi10b29sdGlwLnZhbHVlIHtcXG4gICAgdGV4dC1hbGlnbjogcmlnaHQ7IH1cXG5cXG4vKi0tIEFyZWEgLS0qL1xcbi5iYi1hcmVhIHtcXG4gIHN0cm9rZS13aWR0aDogMDtcXG4gIG9wYWNpdHk6IDAuMjsgfVxcblxcbi8qLS0gQXJjIC0tKi9cXG4uYmItY2hhcnQtYXJjcy10aXRsZSB7XFxuICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xcbiAgZm9udC1zaXplOiAxLjNlbTsgfVxcblxcbi5iYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlIHtcXG4gIGRvbWluYW50LWJhc2VsaW5lOiBtaWRkbGU7XFxuICBmb250LXNpemU6IDIuN2VtOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtYmFja2dyb3VuZCB7XFxuICBmaWxsOiAjZTBlMGUwO1xcbiAgc3Ryb2tlOiAjZmZmOyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdW5pdCB7XFxuICBmaWxsOiAjMDAwO1xcbiAgZm9udC1zaXplOiAxNnB4OyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWF4IHtcXG4gIGZpbGw6ICM3Nzc7IH1cXG5cXG4uYmItY2hhcnQtYXJjcyAuYmItY2hhcnQtYXJjcy1nYXVnZS1taW4ge1xcbiAgZmlsbDogIzc3NzsgfVxcblxcbi8qLS0gUmFkYXIgLS0qL1xcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWxldmVscyBwb2x5Z29uIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICM4NDgyODI7XFxuICBzdHJva2Utd2lkdGg6IC41cHg7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1sZXZlbHMgdGV4dCB7XFxuICBmaWxsOiAjODQ4MjgyOyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItYXhpcyBsaW5lIHtcXG4gIHN0cm9rZTogIzg0ODI4MjtcXG4gIHN0cm9rZS13aWR0aDogLjVweDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWF4aXMgdGV4dCB7XFxuICBmb250LXNpemU6IDEuMTVlbTtcXG4gIGN1cnNvcjogZGVmYXVsdDsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLXNoYXBlcyBwb2x5Z29uIHtcXG4gIGZpbGwtb3BhY2l0eTogLjI7XFxuICBzdHJva2Utd2lkdGg6IDFweDsgfVxcblxcbi8qLS0gQnV0dG9uIC0tKi9cXG4uYmItYnV0dG9uIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMTBweDtcXG4gIHJpZ2h0OiAxMHB4OyB9XFxuICAuYmItYnV0dG9uIC5iYi16b29tLXJlc2V0IHtcXG4gICAgZm9udC1zaXplOiAxMXB4O1xcbiAgICBib3JkZXI6IHNvbGlkIDFweCAjY2NjO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZmZmO1xcbiAgICBwYWRkaW5nOiA1cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gICAgY3Vyc29yOiBwb2ludGVyOyB9XFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICByZXR1cm4gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGNvbnRlbnQsIFwifVwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbignJyk7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiAobW9kdWxlcywgbWVkaWFRdWVyeSwgZGVkdXBlKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbW9kdWxlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250aW51ZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuXG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIFwiLyojIHNvdXJjZVVSTD1cIi5jb25jYXQoY3NzTWFwcGluZy5zb3VyY2VSb290IHx8ICcnKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICByZXR1cm4gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xufSIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzZfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM3X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zOF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzlfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQwX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MV9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDJfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQzX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180NF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDVfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ2X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180N19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDhfXzsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBDU1MgY2xhc3MgbmFtZXMgZGVmaW5pdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGFyYzogXCJiYi1hcmNcIixcclxuXHRhcmNMYWJlbExpbmU6IFwiYmItYXJjLWxhYmVsLWxpbmVcIixcclxuXHRhcmNzOiBcImJiLWFyY3NcIixcclxuXHRhcmVhOiBcImJiLWFyZWFcIixcclxuXHRhcmVhczogXCJiYi1hcmVhc1wiLFxyXG5cdGF4aXM6IFwiYmItYXhpc1wiLFxyXG5cdGF4aXNYOiBcImJiLWF4aXMteFwiLFxyXG5cdGF4aXNYTGFiZWw6IFwiYmItYXhpcy14LWxhYmVsXCIsXHJcblx0YXhpc1k6IFwiYmItYXhpcy15XCIsXHJcblx0YXhpc1kyOiBcImJiLWF4aXMteTJcIixcclxuXHRheGlzWTJMYWJlbDogXCJiYi1heGlzLXkyLWxhYmVsXCIsXHJcblx0YXhpc1lMYWJlbDogXCJiYi1heGlzLXktbGFiZWxcIixcclxuXHRiYXI6IFwiYmItYmFyXCIsXHJcblx0YmFyczogXCJiYi1iYXJzXCIsXHJcblx0YnJ1c2g6IFwiYmItYnJ1c2hcIixcclxuXHRidXR0b246IFwiYmItYnV0dG9uXCIsXHJcblx0YnV0dG9uWm9vbVJlc2V0OiBcImJiLXpvb20tcmVzZXRcIixcclxuXHRjaGFydDogXCJiYi1jaGFydFwiLFxyXG5cdGNoYXJ0QXJjOiBcImJiLWNoYXJ0LWFyY1wiLFxyXG5cdGNoYXJ0QXJjczogXCJiYi1jaGFydC1hcmNzXCIsXHJcblx0Y2hhcnRBcmNzQmFja2dyb3VuZDogXCJiYi1jaGFydC1hcmNzLWJhY2tncm91bmRcIixcclxuXHRjaGFydEFyY3NHYXVnZU1heDogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1heFwiLFxyXG5cdGNoYXJ0QXJjc0dhdWdlTWluOiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWluXCIsXHJcblx0Y2hhcnRBcmNzR2F1Z2VVbml0OiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdW5pdFwiLFxyXG5cdGNoYXJ0QXJjc1RpdGxlOiBcImJiLWNoYXJ0LWFyY3MtdGl0bGVcIixcclxuXHRjaGFydEFyY3NHYXVnZVRpdGxlOiBcImJiLWNoYXJ0LWFyY3MtZ2F1Z2UtdGl0bGVcIixcclxuXHRjaGFydEJhcjogXCJiYi1jaGFydC1iYXJcIixcclxuXHRjaGFydEJhcnM6IFwiYmItY2hhcnQtYmFyc1wiLFxyXG5cdGNoYXJ0TGluZTogXCJiYi1jaGFydC1saW5lXCIsXHJcblx0Y2hhcnRMaW5lczogXCJiYi1jaGFydC1saW5lc1wiLFxyXG5cdGNoYXJ0UmFkYXI6IFwiYmItY2hhcnQtcmFkYXJcIixcclxuXHRjaGFydFJhZGFyczogXCJiYi1jaGFydC1yYWRhcnNcIixcclxuXHRjaGFydFRleHQ6IFwiYmItY2hhcnQtdGV4dFwiLFxyXG5cdGNoYXJ0VGV4dHM6IFwiYmItY2hhcnQtdGV4dHNcIixcclxuXHRjaXJjbGU6IFwiYmItY2lyY2xlXCIsXHJcblx0Y2lyY2xlczogXCJiYi1jaXJjbGVzXCIsXHJcblx0Y29sb3JQYXR0ZXJuOiBcImJiLWNvbG9yLXBhdHRlcm5cIixcclxuXHRjb2xvclNjYWxlOiBcImJiLWNvbG9yc2NhbGVcIixcclxuXHRkZWZvY3VzZWQ6IFwiYmItZGVmb2N1c2VkXCIsXHJcblx0ZHJhZ2FyZWE6IFwiYmItZHJhZ2FyZWFcIixcclxuXHRlbXB0eTogXCJiYi1lbXB0eVwiLFxyXG5cdGV2ZW50UmVjdDogXCJiYi1ldmVudC1yZWN0XCIsXHJcblx0ZXZlbnRSZWN0czogXCJiYi1ldmVudC1yZWN0c1wiLFxyXG5cdGV2ZW50UmVjdHNNdWx0aXBsZTogXCJiYi1ldmVudC1yZWN0cy1tdWx0aXBsZVwiLFxyXG5cdGV2ZW50UmVjdHNTaW5nbGU6IFwiYmItZXZlbnQtcmVjdHMtc2luZ2xlXCIsXHJcblx0Zm9jdXNlZDogXCJiYi1mb2N1c2VkXCIsXHJcblx0Z2F1Z2VWYWx1ZTogXCJiYi1nYXVnZS12YWx1ZVwiLFxyXG5cdGdyaWQ6IFwiYmItZ3JpZFwiLFxyXG5cdGdyaWRMaW5lczogXCJiYi1ncmlkLWxpbmVzXCIsXHJcblx0bGVnZW5kQmFja2dyb3VuZDogXCJiYi1sZWdlbmQtYmFja2dyb3VuZFwiLFxyXG5cdGxlZ2VuZEl0ZW06IFwiYmItbGVnZW5kLWl0ZW1cIixcclxuXHRsZWdlbmRJdGVtRXZlbnQ6IFwiYmItbGVnZW5kLWl0ZW0tZXZlbnRcIixcclxuXHRsZWdlbmRJdGVtRm9jdXNlZDogXCJiYi1sZWdlbmQtaXRlbS1mb2N1c2VkXCIsXHJcblx0bGVnZW5kSXRlbUhpZGRlbjogXCJiYi1sZWdlbmQtaXRlbS1oaWRkZW5cIixcclxuXHRsZWdlbmRJdGVtUG9pbnQ6IFwiYmItbGVnZW5kLWl0ZW0tcG9pbnRcIixcclxuXHRsZWdlbmRJdGVtVGlsZTogXCJiYi1sZWdlbmQtaXRlbS10aWxlXCIsXHJcblx0bGV2ZWw6IFwiYmItbGV2ZWxcIixcclxuXHRsZXZlbHM6IFwiYmItbGV2ZWxzXCIsXHJcblx0bGluZTogXCJiYi1saW5lXCIsXHJcblx0bGluZXM6IFwiYmItbGluZXNcIixcclxuXHRyZWdpb246IFwiYmItcmVnaW9uXCIsXHJcblx0cmVnaW9uczogXCJiYi1yZWdpb25zXCIsXHJcblx0c2VsZWN0ZWRDaXJjbGU6IFwiYmItc2VsZWN0ZWQtY2lyY2xlXCIsXHJcblx0c2VsZWN0ZWRDaXJjbGVzOiBcImJiLXNlbGVjdGVkLWNpcmNsZXNcIixcclxuXHRzaGFwZTogXCJiYi1zaGFwZVwiLFxyXG5cdHNoYXBlczogXCJiYi1zaGFwZXNcIixcclxuXHRzdGFuZm9yZEVsZW1lbnRzOiBcImJiLXN0YW5mb3JkLWVsZW1lbnRzXCIsXHJcblx0c3RhbmZvcmRMaW5lOiBcImJiLXN0YW5mb3JkLWxpbmVcIixcclxuXHRzdGFuZm9yZExpbmVzOiBcImJiLXN0YW5mb3JkLWxpbmVzXCIsXHJcblx0c3RhbmZvcmRSZWdpb246IFwiYmItc3RhbmZvcmQtcmVnaW9uXCIsXHJcblx0c3RhbmZvcmRSZWdpb25zOiBcImJiLXN0YW5mb3JkLXJlZ2lvbnNcIixcclxuXHR0YXJnZXQ6IFwiYmItdGFyZ2V0XCIsXHJcblx0dGV4dDogXCJiYi10ZXh0XCIsXHJcblx0dGV4dHM6IFwiYmItdGV4dHNcIixcclxuXHR0aXRsZTogXCJiYi10aXRsZVwiLFxyXG5cdHRvb2x0aXA6IFwiYmItdG9vbHRpcFwiLFxyXG5cdHRvb2x0aXBDb250YWluZXI6IFwiYmItdG9vbHRpcC1jb250YWluZXJcIixcclxuXHR0b29sdGlwTmFtZTogXCJiYi10b29sdGlwLW5hbWVcIixcclxuXHR4Z3JpZDogXCJiYi14Z3JpZFwiLFxyXG5cdHhncmlkRm9jdXM6IFwiYmIteGdyaWQtZm9jdXNcIixcclxuXHR4Z3JpZExpbmU6IFwiYmIteGdyaWQtbGluZVwiLFxyXG5cdHhncmlkTGluZXM6IFwiYmIteGdyaWQtbGluZXNcIixcclxuXHR4Z3JpZHM6IFwiYmIteGdyaWRzXCIsXHJcblx0eWdyaWQ6IFwiYmIteWdyaWRcIixcclxuXHR5Z3JpZEZvY3VzOiBcImJiLXlncmlkLWZvY3VzXCIsXHJcblx0eWdyaWRMaW5lOiBcImJiLXlncmlkLWxpbmVcIixcclxuXHR5Z3JpZExpbmVzOiBcImJiLXlncmlkLWxpbmVzXCIsXHJcblx0eWdyaWRzOiBcImJiLXlncmlkc1wiLFxyXG5cdHpvb21CcnVzaDogXCJiYi16b29tLWJydXNoXCIsXHJcblx0em9vbVJlY3Q6IFwiYmItem9vbS1yZWN0XCIsXHJcblx0RVhQQU5ERUQ6IFwiX2V4cGFuZGVkX1wiLFxyXG5cdFNFTEVDVEVEOiBcIl9zZWxlY3RlZF9cIixcclxuXHRJTkNMVURFRDogXCJfaW5jbHVkZWRfXCIsXHJcblx0VGV4dE92ZXJsYXBwaW5nOiBcInRleHQtb3ZlcmxhcHBpbmdcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHN0YXRlIHtcclxuXHRjb25zdHJ1Y3RvcigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHdpZHRoOiAwLFxyXG5cdFx0XHR3aWR0aDI6IDAsXHJcblx0XHRcdGhlaWdodDogMCxcclxuXHRcdFx0aGVpZ2h0MjogMCxcclxuXHRcdFx0bWFyZ2luOiB7XHJcblx0XHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwXHJcblx0XHRcdH0sXHJcblx0XHRcdG1hcmdpbjI6IHtcclxuXHRcdFx0XHR0b3A6IDAsXHJcblx0XHRcdFx0Ym90dG9tOiAwLFxyXG5cdFx0XHRcdGxlZnQ6IDAsXHJcblx0XHRcdFx0cmlnaHQ6IDBcclxuXHRcdFx0fSxcclxuXHRcdFx0bWFyZ2luMzoge1xyXG5cdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRib3R0b206IDAsXHJcblx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRyaWdodDogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRhcmNXaWR0aDogMCxcclxuXHRcdFx0YXJjSGVpZ2h0OiAwLFxyXG5cdFx0XHRjdXJyZW50V2lkdGg6IDAsXHJcblx0XHRcdGN1cnJlbnRIZWlnaHQ6IDAsXHJcblxyXG5cdFx0XHQvLyBsZWdlbmRcclxuXHRcdFx0aXNMZWdlbmRSaWdodDogZmFsc2UsXHJcblx0XHRcdGlzTGVnZW5kSW5zZXQ6IGZhbHNlLFxyXG5cdFx0XHRpc0xlZ2VuZFRvcDogZmFsc2UsXHJcblx0XHRcdGlzTGVnZW5kTGVmdDogZmFsc2UsXHJcblx0XHRcdGxlZ2VuZFN0ZXA6IDAsXHJcblx0XHRcdGxlZ2VuZEl0ZW1XaWR0aDogMCxcclxuXHRcdFx0bGVnZW5kSXRlbUhlaWdodDogMCxcclxuXHRcdFx0bGVnZW5kSGFzUmVuZGVyZWQ6IGZhbHNlLFxyXG5cclxuXHRcdFx0Y3VycmVudE1heFRpY2tXaWR0aHM6IHtcclxuXHRcdFx0XHR4OiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifSxcclxuXHRcdFx0XHR5OiB7c2l6ZTogMCwgZG9tYWluOiBcIlwifSxcclxuXHRcdFx0XHR5Mjoge3NpemU6IDAsIGRvbWFpbjogXCJcIn1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHJvdGF0ZWRQYWRkaW5nOiB7XHJcblx0XHRcdFx0bGVmdDogMzAsXHJcblx0XHRcdFx0cmlnaHQ6IDAsXHJcblx0XHRcdFx0dG9wOiA1XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHR3aXRob3V0RmFkZUluOiB7fSxcclxuXHRcdFx0aW5wdXRUeXBlOiBcIlwiLFxyXG5cclxuXHRcdFx0ZGF0ZXRpbWVJZDogXCJcIixcclxuXHJcblx0XHRcdC8vIGNsaXAgaWQgc3RyaW5nXHJcblx0XHRcdGNsaXA6IHtcclxuXHRcdFx0XHRpZDogXCJcIixcclxuXHRcdFx0XHRpZFhBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdGlkWUF4aXM6IFwiXCIsXHJcblx0XHRcdFx0aWRHcmlkOiBcIlwiLFxyXG5cdFx0XHRcdGlkU3ViY2hhcnQ6IFwiXCIsIC8vIGNsaXBJZEZvclN1YmNoYXJ0XHJcblx0XHRcdFx0cGF0aDogXCJcIixcclxuXHRcdFx0XHRwYXRoWEF4aXM6IFwiXCIsXHJcblx0XHRcdFx0cGF0aFlBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdHBhdGhHcmlkOiBcIlwiXHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHQvLyBzdGF0dXNcclxuXHRcdFx0ZHJhZ1N0YXJ0OiBudWxsLFxyXG5cdFx0XHRkcmFnZ2luZzogZmFsc2UsXHJcblx0XHRcdGZsb3dpbmc6IGZhbHNlLFxyXG5cdFx0XHRjYW5jZWxDbGljazogZmFsc2UsXHJcblx0XHRcdG1vdXNlb3ZlcjogZmFsc2UsXHJcblx0XHRcdHJlbmRlcmVkOiBmYWxzZSxcclxuXHRcdFx0dHJhbnNpdGluZzogZmFsc2UsXHJcblx0XHRcdGhhc05lZ2F0aXZlVmFsdWU6IGZhbHNlLFxyXG5cdFx0XHRoYXNQb3NpdGl2ZVZhbHVlOiB0cnVlLFxyXG5cclxuXHRcdFx0b3JnQXJlYU9wYWNpdHk6IFwiMC4yXCIsXHJcblxyXG5cdFx0XHQvLyBJRCBzdHJpbmdzXHJcblx0XHRcdGhpZGRlblRhcmdldElkczogW10sXHJcblx0XHRcdGhpZGRlbkxlZ2VuZElkczogW10sXHJcblx0XHRcdGZvY3VzZWRUYXJnZXRJZHM6IFtdLFxyXG5cdFx0XHRkZWZvY3VzZWRUYXJnZXRJZHM6IFtdLFxyXG5cclxuXHRcdFx0Ly8gdmFsdWUgZm9yIEFyY1xyXG5cdFx0XHRyYWRpdXM6IDAsXHJcblx0XHRcdGlubmVyUmFkaXVzOiAwLFxyXG5cdFx0XHRpbm5lclJhZGl1c1JhdGlvOiAwLFxyXG5cdFx0XHRnYXVnZUFyY1dpZHRoOiAwLFxyXG5cdFx0XHRyYWRpdXNFeHBhbmRlZDogMCxcclxuXHJcblx0XHRcdC8vIHhncmlkIGF0dHJpYnV0ZVxyXG5cdFx0XHR4Z3JpZEF0dHI6IHtcclxuXHRcdFx0XHR4MTogbnVsbCxcclxuXHRcdFx0XHR4MjogbnVsbCxcclxuXHRcdFx0XHR5MTogbnVsbCxcclxuXHRcdFx0XHR5MjogbnVsbFxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7Q2hhcnRUeXBlc30gZnJvbSBcIi4uLy4uLy4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcblxyXG4vKipcclxuICogZGF0YSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBkYXRhIGlkIHZhbHVlXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkaWRDb252ZXJ0ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBmdW5jdGlvbihpZCkgeyByZXR1cm4gaWQ7IH1cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICBpZENvbnZlcnRlcjogZnVuY3Rpb24oaWQpIHtcclxuICAgICAqICAgICAgIC8vIHdoZW4gaWQgaXMgJ2RhdGExJywgY29udmVydHMgdG8gYmUgJ2RhdGEyJ1xyXG4gICAgICogICAgICAgLy8gJ2RhdGEyJyBzaG91bGQgYmUgZ2l2ZW4gYXMgdGhlIGluaXRpYWwgZGF0YSB2YWx1ZVxyXG4gICAgICogICAgICAgaWYgKGlkID09PSBcImRhdGExXCIpIHtcclxuICAgICAqICAgICAgICAgIHJldHVybiBcImRhdGEyXCI7XHJcbiAgICAgKiAgICAgICB9IGVsc2Uge1xyXG4gICAgICogICAgICAgICAgcmV0dXJuIGlkO1xyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2lkQ29udmVydGVyOiBpZCA9PiBpZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjdXN0b20gZGF0YSBuYW1lLlxyXG4gICAgICogQG5hbWUgZGF0YeKApG5hbWVzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTmFtZSlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIG5hbWVzOiB7XHJcbiAgICAgKiAgICAgZGF0YTE6IFwiRGF0YSBOYW1lIDFcIixcclxuICAgICAqICAgICBkYXRhMjogXCJEYXRhIE5hbWUgMlwiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9uYW1lczogPHtba2V5OiBzdHJpbmddOiBzdHJpbmd9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjdXN0b20gZGF0YSBjbGFzcy48YnI+PGJyPlxyXG4gICAgICogSWYgdGhpcyBvcHRpb24gaXMgc3BlY2lmaWVkLCB0aGUgZWxlbWVudCBnIGZvciB0aGUgZGF0YSBoYXMgYW4gYWRkaXRpb25hbCBjbGFzcyB0aGF0IGhhcyB0aGUgcHJlZml4ICdiYi10YXJnZXQtJyAoZWcuIGJiLXRhcmdldC1hZGRpdGlvbmFsLWRhdGExLWNsYXNzKS5cclxuICAgICAqIEBuYW1lIGRhdGHigKRjbGFzc2VzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjbGFzc2VzOiB7XHJcbiAgICAgKiAgICAgZGF0YTE6IFwiYWRkaXRpb25hbC1kYXRhMS1jbGFzc1wiLFxyXG4gICAgICogICAgIGRhdGEyOiBcImFkZGl0aW9uYWwtZGF0YTItY2xhc3NcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfY2xhc3NlczogPHtba2V5OiBzdHJpbmddOiBzdHJpbmd9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjaGFydCB0eXBlIGF0IG9uY2UuPGJyPjxicj5cclxuICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHNwZWNpZmllZCwgdGhlIHR5cGUgd2lsbCBiZSBhcHBsaWVkIHRvIGV2ZXJ5IGRhdGEuIFRoaXMgc2V0dGluZyBjYW4gYmUgb3ZlcndyaXR0ZW4gYnkgZGF0YS50eXBlcy48YnI+PGJyPlxyXG4gICAgICogKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAtIGFyZWFcclxuICAgICAqIC0gYXJlYS1saW5lLXJhbmdlXHJcbiAgICAgKiAtIGFyZWEtc3BsaW5lXHJcbiAgICAgKiAtIGFyZWEtc3BsaW5lLXJhbmdlXHJcbiAgICAgKiAtIGFyZWEtc3RlcFxyXG4gICAgICogLSBiYXJcclxuICAgICAqIC0gYnViYmxlXHJcbiAgICAgKiAtIGRvbnV0XHJcbiAgICAgKiAtIGdhdWdlXHJcbiAgICAgKiAtIGxpbmVcclxuICAgICAqIC0gcGllXHJcbiAgICAgKiAtIHJhZGFyXHJcbiAgICAgKiAtIHNjYXR0ZXJcclxuICAgICAqIC0gc3BsaW5lXHJcbiAgICAgKiAtIHN0ZXBcclxuICAgICAqIEBuYW1lIGRhdGHigKR0eXBlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IGxpbmVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICB0eXBlOiBcImJhclwiXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfdHlwZTogPENoYXJ0VHlwZXN8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY2hhcnQgdHlwZSBmb3IgZWFjaCBkYXRhLjxicj5cclxuICAgICAqIFRoaXMgc2V0dGluZyBvdmVyd3JpdGVzIGRhdGEudHlwZSBzZXR0aW5nLlxyXG4gICAgICogLSAqKk5PVEU6KiogYHJhZGFyYCB0eXBlIGNhbid0IGJlIGNvbWJpbmVkIHdpdGggb3RoZXIgdHlwZXMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkdHlwZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHR5cGVzOiB7XHJcbiAgICAgKiAgICAgZGF0YTE6IFwiYmFyXCIsXHJcbiAgICAgKiAgICAgZGF0YTI6IFwic3BsaW5lXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3R5cGVzOiA8e1trZXk6IHN0cmluZ106IENoYXJ0VHlwZXN9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqICBUaGlzIG9wdGlvbiBjaGFuZ2VzIHRoZSBvcmRlciBvZiBzdGFja2luZyBkYXRhIGFuZCBwaWVjZXMgb2YgcGllL2RvbnV0LlxyXG4gICAgICogIC0gSWYgYG51bGxgIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB0aGUgb3JkZXIgdGhlIGRhdGEgbG9hZGVkLlxyXG4gICAgICogIC0gSWYgZnVuY3Rpb24gc3BlY2lmaWVkLCBpdCB3aWxsIGJlIHVzZWQgYXMgW0FycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0I1BhcmFtZXRlcnMpPGJyPjxicj5cclxuICAgICAqXHJcbiAgICAgKiAgKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAgLSBgZGVzY2A6IEluIGRlc2NlbmRpbmcgb3JkZXJcclxuICAgICAqICAtIGBhc2NgOiBJbiBhc2NlbmRpbmcgb3JkZXJcclxuICAgICAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgbG9hZCBvcmRlclxyXG4gICAgICogIC0gYGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyAuLi4gfWA6IEFycmF5LnNvcnQgY29tcGFyZUZ1bmN0aW9uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkb3JkZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfEZ1bmN0aW9ufG51bGx9XHJcbiAgICAgKiBAZGVmYXVsdCBkZXNjXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhT3JkZXIpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAvLyBpbiBkZXNjZW5kaW5nIG9yZGVyIChkZWZhdWx0KVxyXG4gICAgICogICBvcmRlcjogXCJkZXNjXCJcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIGluIGFzY2VuZGluZyBvcmRlclxyXG4gICAgICogICBvcmRlcjogXCJhc2NcIlxyXG4gICAgICpcclxuICAgICAqICAgLy8ga2VlcHMgZGF0YSBpbnB1dCBvcmRlclxyXG4gICAgICogICBvcmRlcjogbnVsbFxyXG4gICAgICpcclxuICAgICAqICAgLy8gc3BlY2lmeWluZyBzb3J0IGZ1bmN0aW9uXHJcbiAgICAgKiAgIG9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XHJcbiAgICAgKiAgICAgICAvLyBwYXJhbSBkYXRhIHBhc3NlZCBmb3JtYXRcclxuICAgICAqICAgICAgIHtcclxuICAgICAqICAgICAgICAgIGlkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IFtcclxuICAgICAqICAgICAgICAgICAgICB7eDogNSwgdmFsdWU6IDI1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDUsIG5hbWU6IFwiZGF0YTFcIn0sXHJcbiAgICAgKiAgICAgICAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgICAgICBdXHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9vcmRlcjogPFwiZGVzY1wifFwiYXNjXCJ8RnVuY3Rpb258bnVsbD4gXCJkZXNjXCIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY29sb3IgY29udmVydGVyIGZ1bmN0aW9uLjxicj48YnI+XHJcbiAgICAgKiBUaGlzIG9wdGlvbiBzaG91bGQgYSBmdW5jdGlvbiBhbmQgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBjb2xvciAoZS5nLiAnI2ZmMDAwMCcpIGFuZCBkIHRoYXQgaGFzIGRhdGEgcGFyYW1ldGVycyBsaWtlIGlkLCB2YWx1ZSwgaW5kZXgsIGV0Yy4gQW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBjb2xvciAoZS5nLiAnIzAwZmYwMCcpLlxyXG4gICAgICogQG5hbWUgZGF0YeKApGNvbG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhQ29sb3IpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2xvcjogZnVuY3Rpb24oY29sb3IsIGQpIHsgLi4uIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9jb2xvcjogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNvbG9yIGZvciBlYWNoIGRhdGEuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkY29sb3JzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2xvcnM6IHtcclxuICAgICAqICAgICBkYXRhMTogXCIjZmYwMDAwXCIsXHJcbiAgICAgKiAgICAgZGF0YTI6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAqICAgICAgICByZXR1cm4gXCIjMDAwXCI7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgIC4uLlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfY29sb3JzOiA8e1trZXk6IHN0cmluZ106IHN0cmluZ3woKCkgPT4gc3RyaW5nKTt9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGUgZWFjaCBkYXRhIHdoZW4gdGhlIGNoYXJ0IGFwcGVhcnMuPGJyPjxicj5cclxuICAgICAqIElmIHRydWUgc3BlY2lmaWVkLCBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlbi4gSWYgbXVsdGlwbGUgaWRzIHNwZWNpZmllZCBhcyBhbiBhcnJheSwgdGhvc2Ugd2lsbCBiZSBoaWRkZW4uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkaGlkZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufEFycmF5fVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIC8vIGFsbCBvZiBkYXRhIHdpbGwgYmUgaGlkZGVuXHJcbiAgICAgKiAgIGhpZGU6IHRydWVcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIHNwZWNpZmllZCBkYXRhIHdpbGwgYmUgaGlkZGVuXHJcbiAgICAgKiAgIGhpZGU6IFtcImRhdGExXCIsIC4uLl1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9oaWRlOiA8c3RyaW5nW118Ym9vbGVhbj4gZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWx0ZXIgdmFsdWVzIHRvIGJlIHNob3duXHJcbiAgICAgKiBUaGUgZGF0YSB2YWx1ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcmV0dXJuZWQgYnkgYC5kYXRhKClgLlxyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9maWx0ZXJcclxuICAgICAqIEBuYW1lIGRhdGHigKRmaWx0ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIC8vIGZpbHRlciBmb3IgaWQgdmFsdWVcclxuICAgICAqICAgZmlsdGVyOiBmdW5jdGlvbih2KSB7XHJcbiAgICAgKiAgICAgIC8vIHY6IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogW1xyXG4gICAgICogICAgICAvLyAgICAgIHt4OiAwLCB2YWx1ZTogMTMwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogMH0sIC4uLl1cclxuICAgICAqICAgICAgLy8gICAgfSwgLi4uXVxyXG4gICAgICogICAgICByZXR1cm4gdi5pZCAhPT0gXCJkYXRhMVwiO1xyXG4gICAgICogICB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfZmlsdGVyOiA8KCgpID0+IGJvb2xlYW4pfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIGNsaWNrIGV2ZW50IG9uIGVhY2ggZGF0YSBwb2ludC48YnI+PGJyPlxyXG4gICAgICogVGhpcyBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIGVhY2ggZGF0YSBwb2ludCBjbGlja2VkIGFuZCB3aWxsIHJlY2VpdmUgYGRgIGFuZCBlbGVtZW50IGFzIHRoZSBhcmd1bWVudHMuXHJcbiAgICAgKiAtIGBkYCBpcyB0aGUgZGF0YSBjbGlja2VkIGFuZCBlbGVtZW50IGlzIHRoZSBlbGVtZW50IGNsaWNrZWQuXHJcbiAgICAgKiAtIGBlbGVtZW50YCBpcyB0aGUgY3VycmVudCBpbnRlcmFjdGluZyBzdmcgZWxlbWVudC5cclxuICAgICAqIC0gSW4gdGhpcyBjYWxsYmFjaywgYHRoaXNgIHdpbGwgYmUgdGhlIENoYXJ0IG9iamVjdC5cclxuICAgICAqIEBuYW1lIGRhdGHigKRvbmNsaWNrXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBvbmNsaWNrOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcbiAgICAgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTFcIn1cclxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb25jbGljazogKCkgPT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBjYWxsYmFjayBmb3IgbW91c2UvdG91Y2ggb3ZlciBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuICAgICAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBtb3VzZSBjdXJzb3Igb3IgdmlhIHRvdWNoIG1vdmVzIG9udG8gZWFjaCBkYXRhIHBvaW50IGFuZCB3aWxsIHJlY2VpdmUgYGRgIGFuZCBgZWxlbWVudGAgYXMgdGhlIGFyZ3VtZW50LlxyXG4gICAgICogLSBgZGAgaXMgdGhlIGRhdGEgd2hlcmUgbW91c2UgY3Vyc29yIG1vdmVzIG9udG8uXHJcbiAgICAgKiAtIGBlbGVtZW50YCBpcyB0aGUgY3VycmVudCBpbnRlcmFjdGluZyBzdmcgZWxlbWVudC5cclxuICAgICAqIC0gSW4gdGhpcyBjYWxsYmFjaywgYHRoaXNgIHdpbGwgYmUgdGhlIENoYXJ0IG9iamVjdC5cclxuICAgICAqIEBuYW1lIGRhdGHigKRvbm92ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgIG9ub3ZlcjogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0fVxyXG4gICAgICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG4gICAgICogICAgICAgIC4uLlxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9vbm92ZXI6ICgpID0+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1vdXNlL3RvdWNoIG91dCBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuICAgICAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBtb3VzZSBjdXJzb3Igb3IgdmlhIHRvdWNoIG1vdmVzIG91dCBlYWNoIGRhdGEgcG9pbnQgYW5kIHdpbGwgcmVjZWl2ZSBgZGAgYXMgdGhlIGFyZ3VtZW50LlxyXG4gICAgICogLSBgZGAgaXMgdGhlIGRhdGEgd2hlcmUgbW91c2UgY3Vyc29yIG1vdmVzIG91dC5cclxuICAgICAqIC0gYGVsZW1lbnRgIGlzIHRoZSBjdXJyZW50IGludGVyYWN0aW5nIHN2ZyBlbGVtZW50LlxyXG4gICAgICogLSBJbiB0aGlzIGNhbGxiYWNrLCBgdGhpc2Agd2lsbCBiZSB0aGUgQ2hhcnQgb2JqZWN0LlxyXG4gICAgICogQG5hbWUgZGF0YeKApG9ub3V0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBvbm91dDogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0fVxyXG4gICAgICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG4gICAgICogICAgICAgIC4uLlxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9vbm91dDogKCkgPT4ge30sXHJcblxyXG4gICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1pbmltdW0gZGF0YVxyXG4gICAgICogLSAqKk5PVEU6KiogRm9yICdhcmVhLWxpbmUtcmFuZ2UnIGFuZCAnYXJlYS1zcGxpbmUtcmFuZ2UnLCBgbWlkYCBkYXRhIHdpbGwgYmUgdGFrZW4gZm9yIHRoZSBjb21wYXJpc29uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkb25taW5cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIG9ubWluOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxyXG4gICAgICogICAgLi4uXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBkYXRhX29ubWluOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBjYWxsYmFjayBmb3IgbWF4aW11bSBkYXRhXHJcbiAgICAgKiAtICoqTk9URToqKiBGb3IgJ2FyZWEtbGluZS1yYW5nZScgYW5kICdhcmVhLXNwbGluZS1yYW5nZScsIGBtaWRgIGRhdGEgd2lsbCBiZSB0YWtlbiBmb3IgdGhlIGNvbXBhcmlzb25cclxuICAgICAqIEBuYW1lIGRhdGHigKRvbm1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuT25NaW5NYXhDYWxsYmFjaylcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgb25tYXg6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAqICAgIC8vIGRhdGEgLSBleCkgW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLiBdXHJcbiAgICAgKiAgICAuLi5cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb25tYXg6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBDU1Ygb3IgSlNPTiBmaWxlIGZyb20gYSBVUkwuIE5PVEUgdGhhdCB0aGlzIHdpbGwgbm90IHdvcmsgaWYgbG9hZGluZyB2aWEgdGhlIFwiZmlsZTovL1wiIHByb3RvY29sIGFzIHRoZSBtb3N0IGJyb3dzZXJzIHdpbGwgYmxvY2sgWE1MSFRUUFJlcXVlc3RzLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHVybFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkxvYWREYXRhKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIlxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3VybDogPHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFhIUiBoZWFkZXIgdmFsdWVcclxuICAgICAqIC0gKipOT1RFOioqIFNob3VsZCBiZSB1c2VkIHdpdGggYGRhdGEudXJsYCBvcHRpb25cclxuICAgICAqIEBuYW1lIGRhdGHigKRoZWFkZXJzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvWE1MSHR0cFJlcXVlc3Qvc2V0UmVxdWVzdEhlYWRlclxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIixcclxuICAgICAqICAgICBoZWFkZXJzOiB7XHJcbiAgICAgKiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3htbFwiLFxyXG4gICAgICogICAgICAgIC4uLlxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9oZWFkZXJzOiA8b2JqZWN0fHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgYSBKU09OIG9iamVjdCBmb3IgZGF0YS4gU2VlIGFsc28gZGF0YS5rZXlzLlxyXG4gICAgICogQG5hbWUgZGF0YeKApGpzb25cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgW2RhdGHigKRrZXlzXSgjLmRhdGElMjVFMiUyNTgwJTI1QTRrZXlzKVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuSlNPTkRhdGEpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgIGpzb246IFtcclxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMS5jb21cIiwgdXBsb2FkOiAyMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA0MDB9LFxyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUyLmNvbVwiLCB1cGxvYWQ6IDEwMCwgZG93bmxvYWQ6IDMwMCwgdG90YWw6IDQwMH0sXHJcbiAgICAgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTMuY29tXCIsIHVwbG9hZDogMzAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNTAwfSxcclxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlNC5jb21cIiwgdXBsb2FkOiA0MDAsIGRvd25sb2FkOiAxMDAsIHRvdGFsOiA1MDB9XHJcbiAgICAgKiAgICAgXSxcclxuICAgICAqICAgICBrZXlzOiB7XHJcbiAgICAgKiAgICAgICAvLyB4OiBcIm5hbWVcIiwgLy8gaXQncyBwb3NzaWJsZSB0byBzcGVjaWZ5ICd4JyB3aGVuIGNhdGVnb3J5IGF4aXNcclxuICAgICAqICAgICAgIHZhbHVlOiBbXCJ1cGxvYWRcIiwgXCJkb3dubG9hZFwiXVxyXG4gICAgICogICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9qc29uOiA8b2JqZWN0W118dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGRhdGEgZnJvbSBhIG11bHRpZGltZW5zaW9uYWwgYXJyYXksIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQgY29udGFpbmluZyB0aGUgZGF0YSBuYW1lcywgdGhlIGZvbGxvd2luZyBjb250YWluaW5nIHJlbGF0ZWQgZGF0YSBpbiB0aGF0IG9yZGVyLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHJvd3NcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLlJvd09yaWVudGVkRGF0YSlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHJvd3M6IFtcclxuICAgICAqICAgICBbXCJBXCIsIFwiQlwiLCBcIkNcIl0sXHJcbiAgICAgKiAgICAgWzkwLCAxMjAsIDMwMF0sXHJcbiAgICAgKiAgICAgWzQwLCAxNjAsIDI0MF0sXHJcbiAgICAgKiAgICAgWzUwLCAyMDAsIDI5MF0sXHJcbiAgICAgKiAgICAgWzEyMCwgMTYwLCAyMzBdLFxyXG4gICAgICogICAgIFs4MCwgMTMwLCAzMDBdLFxyXG4gICAgICogICAgIFs5MCwgMjIwLCAzMjBdXHJcbiAgICAgKiAgIF1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBmb3IgJ3JhbmdlJyB0eXBlcygnYXJlYS1saW5lLXJhbmdlJyBvciAnYXJlYS1zcGxpbmUtcmFuZ2UnKSwgZGF0YSBzaG91bGQgY29udGFpbjpcclxuICAgICAqIC8vIC0gYW4gYXJyYXkgb2YgW2hpZ2gsIG1pZCwgbG93XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuICAgICAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ2hpZ2gnLCAnbWlkJyBhbmQgJ2xvdycga2V5IHZhbHVlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHJvd3M6IFtcclxuICAgICAqICAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuICAgICAqICAgICAgW1xyXG4gICAgICogICAgICAgIC8vIG9yIHtoaWdoOjE1MCwgbWlkOiAxNDAsIGxvdzogMTEwfSwgMTIwXHJcbiAgICAgKiAgICAgICAgWzE1MCwgMTQwLCAxMTBdLCAxMjBcclxuICAgICAqICAgICAgXSxcclxuICAgICAqICAgICAgW1sxNTUsIDEzMCwgMTE1XSwgNTVdLFxyXG4gICAgICogICAgICBbWzE2MCwgMTM1LCAxMjBdLCA2MF1cclxuICAgICAqICAgXSxcclxuICAgICAqICAgdHlwZXM6IHtcclxuICAgICAqICAgICAgIGRhdGExOiBcImFyZWEtbGluZS1yYW5nZVwiLFxyXG4gICAgICogICAgICAgZGF0YTI6IFwibGluZVwiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBmb3IgJ2J1YmJsZScgdHlwZSwgZGF0YSBjYW4gY29udGFpbiBkaW1lbnNpb24gdmFsdWU6XHJcbiAgICAgKiAvLyAtIGFuIGFycmF5IG9mIFt5LCB6XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuICAgICAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ3knIGFuZCAneicga2V5IHZhbHVlXHJcbiAgICAgKiAvLyAneScgaXMgZm9yIHkgYXhpcyBjb29yZGluYXRpb24gYW5kICd6JyBpcyB0aGUgYnViYmxlIHJhZGl1cyB2YWx1ZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICByb3dzOiBbXHJcbiAgICAgKiAgICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl0sXHJcbiAgICAgKiAgICAgIFtcclxuICAgICAqICAgICAgICAvLyBvciB7eToxMCwgejogMTQwfSwgMTIwXHJcbiAgICAgKiAgICAgICAgWzEwLCAxNDBdLCAxMjBcclxuICAgICAqICAgICAgXSxcclxuICAgICAqICAgICAgW1sxMDAsIDMwXSwgNTVdLFxyXG4gICAgICogICAgICBbWzUwLCAxMDBdLCA2MF1cclxuICAgICAqICAgXSxcclxuICAgICAqICAgdHlwZXM6IHtcclxuICAgICAqICAgICAgIGRhdGExOiBcImJ1YmJsZVwiLFxyXG4gICAgICogICAgICAgZGF0YTI6IFwibGluZVwiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9yb3dzOiA8KHN0cmluZ3xudW1iZXIpW11bXXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgZGF0YSBmcm9tIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSwgd2l0aCBlYWNoIGVsZW1lbnQgY29udGFpbmluZyBhbiBhcnJheSBjb25zaXN0aW5nIG9mIGEgZGF0dW0gbmFtZSBhbmQgYXNzb2NpYXRlZCBkYXRhIHZhbHVlcy5cclxuICAgICAqIEBuYW1lIGRhdGHigKRjb2x1bW5zXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Db2x1bW5PcmllbnRlZERhdGEpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgIFtcImRhdGExXCIsIDMwLCAyMCwgNTAsIDQwLCA2MCwgNTBdLFxyXG4gICAgICogICAgICBbXCJkYXRhMlwiLCAyMDAsIDEzMCwgOTAsIDI0MCwgMTMwLCAyMjBdLFxyXG4gICAgICogICAgICBbXCJkYXRhM1wiLCAzMDAsIDIwMCwgMTYwLCA0MDAsIDI1MCwgMjUwXVxyXG4gICAgICogICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gZm9yICdyYW5nZScgdHlwZXMoJ2FyZWEtbGluZS1yYW5nZScgb3IgJ2FyZWEtc3BsaW5lLXJhbmdlJyksIGRhdGEgc2hvdWxkIGNvbnRhaW46XHJcbiAgICAgKiAvLyAtIGFuIGFycmF5IG9mIFtoaWdoLCBtaWQsIGxvd10gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXHJcbiAgICAgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICdoaWdoJywgJ21pZCcgYW5kICdsb3cnIGtleSB2YWx1ZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgIFtcImRhdGExXCIsXHJcbiAgICAgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sICAvLyBvciB7aGlnaDoxNTAsIG1pZDogMTQwLCBsb3c6IDExMH1cclxuICAgICAqICAgICAgICAgIFsxNTAsIDE0MCwgMTEwXSxcclxuICAgICAqICAgICAgICAgIFsxNTAsIDE0MCwgMTEwXVxyXG4gICAgICogICAgICBdXHJcbiAgICAgKiAgIF0sXHJcbiAgICAgKiAgIHR5cGU6IFwiYXJlYS1saW5lLXJhbmdlXCJcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBmb3IgJ2J1YmJsZScgdHlwZSwgZGF0YSBjYW4gY29udGFpbiBkaW1lbnNpb24gdmFsdWU6XHJcbiAgICAgKiAvLyAtIGFuIGFycmF5IG9mIFt5LCB6XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuICAgICAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ3knIGFuZCAneicga2V5IHZhbHVlXHJcbiAgICAgKiAvLyAneScgaXMgZm9yIHkgYXhpcyBjb29yZGluYXRpb24gYW5kICd6JyBpcyB0aGUgYnViYmxlIHJhZGl1cyB2YWx1ZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgIFtcImRhdGExXCIsXHJcbiAgICAgKiAgICAgICAgICBbMTAsIDE0MF0sICAvLyBvciB7eToxMCwgejogMTQwfVxyXG4gICAgICogICAgICAgICAgWzEwMCwgMzBdLFxyXG4gICAgICogICAgICAgICAgWzUwLCAxMDBdXHJcbiAgICAgKiAgICAgIF1cclxuICAgICAqICAgXSxcclxuICAgICAqICAgdHlwZTogXCJidWJibGVcIlxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2NvbHVtbnM6IDwoc3RyaW5nfG51bWJlcilbXVtdfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVXNlZCBpZiBsb2FkaW5nIEpTT04gdmlhIGRhdGEudXJsLlxyXG4gICAgICogLSAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuICAgICAqICAgLSBqc29uXHJcbiAgICAgKiAgIC0gY3N2XHJcbiAgICAgKiAgIC0gdHN2XHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkbWltZVR5cGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgY3N2XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgIG1pbWVUeXBlOiBcImpzb25cIlxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX21pbWVUeXBlOiA8XCJjc3ZcInxcImpzb25cInxcInRzdlwiPiBcImNzdlwiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2hvb3NlIHdoaWNoIEpTT04gb2JqZWN0IGtleXMgY29ycmVzcG9uZCB0byBkZXNpcmVkIGRhdGEuXHJcbiAgICAgKiAtICoqTk9URToqKiBPbmx5IGZvciBKU09OIG9iamVjdCBnaXZlbiBhcyBhcnJheS5cclxuICAgICAqIEBuYW1lIGRhdGHigKRrZXlzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBqc29uOiBbXHJcbiAgICAgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTEuY29tXCIsIHVwbG9hZDogMjAwLCBkb3dubG9hZDogMjAwLCB0b3RhbDogNDAwfSxcclxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMi5jb21cIiwgdXBsb2FkOiAxMDAsIGRvd25sb2FkOiAzMDAsIHRvdGFsOiA0MDB9LFxyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUzLmNvbVwiLCB1cGxvYWQ6IDMwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDUwMH0sXHJcbiAgICAgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTQuY29tXCIsIHVwbG9hZDogNDAwLCBkb3dubG9hZDogMTAwLCB0b3RhbDogNTAwfVxyXG4gICAgICogICAgIF0sXHJcbiAgICAgKiAgICAga2V5czoge1xyXG4gICAgICogICAgICAgLy8geDogXCJuYW1lXCIsIC8vIGl0J3MgcG9zc2libGUgdG8gc3BlY2lmeSAneCcgd2hlbiBjYXRlZ29yeSBheGlzXHJcbiAgICAgKiAgICAgICB2YWx1ZTogW1widXBsb2FkXCIsIFwiZG93bmxvYWRcIl1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfa2V5czogPHt4Pzogc3RyaW5nOyB2YWx1ZT86IHN0cmluZ1tdfXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0ZXh0IGxhYmVsIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZXJlJ3Mgbm8gZGF0YSB0byBzaG93LlxyXG4gICAgICogLSBleC4gVG9nZ2xpbmcgYWxsIHZpc2libGUgZGF0YSB0byBub3QgYmUgc2hvd24sIHVubG9hZGluZyBhbGwgY3VycmVudCBkYXRhLCBldGMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkZW1wdHnigKRsYWJlbOKApHRleHRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgXCJcIlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgZW1wdHk6IHtcclxuICAgICAqICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgdGV4dDogXCJObyBEYXRhXCJcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9lbXB0eV9sYWJlbF90ZXh0OiBcIlwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGNvbG9yIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBjb2xvciBvZiB0aGUgZGF0YSB2YWx1ZXNcclxuICAgICAqIEBuYW1lIGNvbG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfE9iamVjdHxGdW5jdGlvbn0gW2NvbG9yLm9ub3Zlcl0gU2V0IHRoZSBjb2xvciB2YWx1ZSBmb3IgZWFjaCBkYXRhIHBvaW50IHdoZW4gbW91c2UvdG91Y2ggb25vdmVyIGV2ZW50IG9jY3Vycy5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtjb2xvci5wYXR0ZXJuPVtdXSBjdXN0b20gY29sb3IgcGF0dGVyblxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2NvbG9yLnRpbGVzXSBpZiBkZWZpbmVkLCBhbGxvd3MgdXNlIHN2ZydzIHBhdHRlcm5zIHRvIGZpbGwgZGF0YSBhcmVhLiBJdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIFtTVkdQYXR0ZXJuRWxlbWVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1NWR1BhdHRlcm5FbGVtZW50KS5cclxuICAgICAqICAtICoqTk9URToqKiBUaGUgcGF0dGVybiBlbGVtZW50J3MgaWQgd2lsbCBiZSBkZWZpbmVkIGFzIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLSRDT0xPUi1WQUxVRWAuPGJyPlxyXG4gICAgICogICAgZXguIFdoZW4gY29sb3IgcGF0dGVybiB2YWx1ZSBpcyBgWydyZWQnLCAnI2ZmZiddYCBhbmQgZGVmaW5lZCAyIHBhdHRlcm5zLHRoZW4gaWRzIGZvciBwYXR0ZXJuIGVsZW1lbnRzIGFyZTo8YnI+XHJcbiAgICAgKiAgICAtIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLXJlZGBcclxuICAgICAqICAgIC0gYGJiLWNvbG9yaXplLXBhdHRlcm4tZmZmYFxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IFtjb2xvci50aHJlc2hvbGRdIGNvbG9yIHRocmVzaG9sZCBmb3IgZ2F1Z2UgYW5kIHRvb2x0aXAgY29sb3JcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbY29sb3IudGhyZXNob2xkLnVuaXRdIElmIHNldCB0byBgdmFsdWVgLCB0aGUgdGhyZXNob2xkIHdpbGwgYmUgYmFzZWQgb24gdGhlIGRhdGEgdmFsdWUuIE90aGVyd2lzZSBpdCdsbCBiZSBiYXNlZCBvbiBlcXVhdGlvbiBvZiB0aGUgYHRocmVzaG9sZC5tYXhgIG9wdGlvbiB2YWx1ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFtjb2xvci50aHJlc2hvbGQudmFsdWVzXSBUaHJlc2hvbGQgdmFsdWVzIGZvciBlYWNoIHN0ZXBzXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2NvbG9yLnRocmVzaG9sZC5tYXg9MTAwXSBUaGUgYmFzZSB2YWx1ZSB0byBkZXRlcm1pbmUgdGhyZXNob2xkIHN0ZXAgdmFsdWUgY29uZGl0aW9uLiBXaGVuIHRoZSBnaXZlbiB2YWx1ZSBpcyAxNSBhbmQgbWF4IDEwLCB0aGVuIHRoZSB2YWx1ZSBmb3IgdGhyZXNob2xkIGlzIGAxNSoxMDAvMTBgLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBjb2xvcjoge1xyXG4gICAgICogICAgICBwYXR0ZXJuOiBbXCIjMWY3N2I0XCIsIFwiI2FlYzdlOFwiLCAuLi5dLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gU2V0IGNvbG9ycycgcGF0dGVybnNcclxuICAgICAqICAgICAgLy8gaXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBTVkdQYXR0ZXJuRWxlbWVudFxyXG4gICAgICogICAgICB0aWxlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgICAgICAgIHZhciBwYXR0ZXJuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXR0ZXJuXCIpO1xyXG4gICAgICogICAgICAgICB2YXIgZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiZ1wiKTtcclxuICAgICAqICAgICAgICAgdmFyIGNpcmNsZTEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwicGF0dGVyblVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XHJcbiAgICAgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgXCIzMlwiKTtcclxuICAgICAqICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgXCIzMlwiKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIGcuc3R5bGUuZmlsbCA9IFwiIzAwMFwiO1xyXG4gICAgICogICAgICAgICBnLnN0eWxlLm9wYWNpdHkgPSBcIjAuMlwiO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCBcIjNcIik7XHJcbiAgICAgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiY3lcIiwgXCIzXCIpO1xyXG4gICAgICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcInJcIiwgXCIzXCIpO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgZy5hcHBlbmRDaGlsZChjaXJjbGUxKTtcclxuICAgICAqICAgICAgICAgcGF0dGVybi5hcHBlbmRDaGlsZChnKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIHJldHVybiBbcGF0dGVybl07XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBmb3IgdGhyZXNob2xkIHVzYWdlLCBwYXR0ZXJuIHZhbHVlcyBzaG91bGQgYmUgc2V0IGZvciBlYWNoIHN0ZXBzXHJcbiAgICAgKiAgICAgIHBhdHRlcm46IFtcImdyZXlcIiwgXCJncmVlblwiLCBcInllbGxvd1wiLCBcIm9yYW5nZVwiLCBcInJlZFwiXSxcclxuICAgICAqICAgICAgdGhyZXNob2xkOiB7XHJcbiAgICAgKiAgICAgICAgICB1bml0OiBcInZhbHVlXCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgLy8gd2hlbiB2YWx1ZSBpcyAyMCA9PiAnZ3JlZW4nLCB2YWx1ZSBpcyA0MCA9PiAnb3JhbmdlJyB3aWxsIGJlIHNldC5cclxuICAgICAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzAsIDQwLCA1MF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgLy8gdGhlIGVxdWF0aW9uIGZvciBtYXg6XHJcbiAgICAgKiAgICAgICAgICAvLyAtIHVuaXQgPT0gJ3ZhbHVlJzogbWF4ID0+IDMwXHJcbiAgICAgKiAgICAgICAgICAvLyAtIHVuaXQgIT0gJ3ZhbHVlJzogbWF4ID0+IHZhbHVlKjEwMC8zMFxyXG4gICAgICogICAgICAgICAgbWF4OiAzMFxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc2V0IGFsbCBkYXRhIHRvICdyZWQnXHJcbiAgICAgKiAgICAgIG9ub3ZlcjogXCJyZWRcIixcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNldCBkaWZmZXJlbnQgY29sb3IgZm9yIGRhdGFcclxuICAgICAqICAgICAgb25vdmVyOiB7XHJcbiAgICAgKiAgICAgICAgICBkYXRhMTogXCJyZWRcIixcclxuICAgICAqICAgICAgICAgIGRhdGEyOiBcInllbGxvd1wiXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyB3aWxsIHBhc3MgZGF0YSBvYmplY3QgdG8gdGhlIGNhbGxiYWNrXHJcbiAgICAgKiAgICAgIG9ub3ZlcjogZnVuY3Rpb24oZCkge1xyXG4gICAgICogICAgICAgICAgcmV0dXJuIGQuaWQgPT09IFwiZGF0YTFcIiA/IFwicmVkXCIgOiBcImdyZWVuXCI7XHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGNvbG9yX3BhdHRlcm46IDxzdHJpbmdbXT4gW10sXHJcbiAgICBjb2xvcl90aWxlczogPCgoKSA9PiBbXSl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBjb2xvcl90aHJlc2hvbGQ6IDx7dW5pdD86IHN0cmluZzsgdmFsdWVzPzogbnVtYmVyW107IG1heDogbnVtYmVyO30+IHt9LFxyXG4gICAgY29sb3Jfb25vdmVyOiA8c3RyaW5nfG9iamVjdHx1bmRlZmluZWQ+IHVuZGVmaW5lZFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBpbnRlcmFjdGlvbiBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcmFjdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBpbnRlcmFjdGlvblxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5lbmFibGVkPXRydWVdIEluZGljYXRlIGlmIHRoZSBjaGFydCBzaG91bGQgaGF2ZSBpbnRlcmFjdGlvbnMuPGJyPlxyXG4gICAgICogICAgIElmIGBmYWxzZWAgaXMgc2V0LCBhbGwgb2YgaW50ZXJhY3Rpb25zIChzaG93aW5nL2hpZGluZyB0b29sdGlwLCBzZWxlY3Rpb24sIG1vdXNlIGV2ZW50cywgZXRjKSB3aWxsIGJlIGRpc2FibGVkLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbaW50ZXJhY3Rpb24uYnJpZ2h0ZW49dHJ1ZV0gTWFrZSBicmlnaHRlciBmb3IgdGhlIHNlbGVjdGVkIGFyZWEgKGV4LiAncGllJyB0eXBlIGRhdGEgc2VsZWN0ZWQgYXJlYSlcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS5tb3VzZT10cnVlXSBlbmFibGUgb3IgZGlzYWJsZSBtb3VzZSBpbnRlcmFjdGlvblxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoPXRydWVdIGVuYWJsZSBvciBkaXNhYmxlICB0b3VjaCBpbnRlcmFjdGlvblxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE51bWJlcn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaC5wcmV2ZW50RGVmYXVsdD1mYWxzZV0gZW5hYmxlIG9yIGRpc2FibGUgdG8gY2FsbCBldmVudC5wcmV2ZW50RGVmYXVsdCBvbiB0b3VjaHN0YXJ0ICYgdG91Y2htb3ZlIGV2ZW50LiBJdCdzIHVzdWFsbHkgdXNlZCB0byBwcmV2ZW50IGRvY3VtZW50IHNjcm9sbGluZy5cclxuICAgICAqIEBzZWUgW0RlbW86IHRvdWNoLnByZXZlbnREZWZhdWx0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uUHJldmVudFNjcm9sbE9uVG91Y2gpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogaW50ZXJhY3Rpb246IHtcclxuICAgICAqICAgIGVuYWJsZWQ6IGZhbHNlLFxyXG4gICAgICogICAgYnJpZ2h0ZW46IGZhbHNlLFxyXG4gICAgICogICAgaW5wdXRUeXBlOiB7XHJcbiAgICAgKiAgICAgICAgbW91c2U6IHRydWUsXHJcbiAgICAgKiAgICAgICAgdG91Y2g6IGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgIC8vIG9yIGRlY2xhcmUgcHJldmVudERlZmF1bHQgZXhwbGljaXRseS5cclxuICAgICAqICAgICAgICAvLyBJbiB0aGlzIGNhc2UgdG91Y2ggaW5wdXRUeXBlIGlzIGVuYWJsZWQgYnkgZGVmYXVsdFxyXG4gICAgICogICAgICAgIHRvdWNoOiB7XHJcbiAgICAgKiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgICAvLyBvciB0aHJlc2hvbGQgcGl4ZWwgdmFsdWUgKHBpeGVsIG1vdmVkIGZyb20gdG91Y2hzdGFydCB0byB0b3VjaG1vdmUpXHJcbiAgICAgKiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiA1XHJcbiAgICAgKiAgICAgICAgfVxyXG4gICAgICogICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBpbnRlcmFjdGlvbl9lbmFibGVkOiB0cnVlLFxyXG4gICAgaW50ZXJhY3Rpb25fYnJpZ2h0ZW46IHRydWUsXHJcbiAgICBpbnRlcmFjdGlvbl9pbnB1dFR5cGVfbW91c2U6IHRydWUsXHJcbiAgICBpbnRlcmFjdGlvbl9pbnB1dFR5cGVfdG91Y2g6IDxib29sZWFufHtwcmV2ZW50RGVmYXVsdD86IGJvb2xlYW58bnVtYmVyfT4ge31cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogbGVnZW5kIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIExlZ2VuZCBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBsZWdlbmRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxlZ2VuZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5oaWRlPWZhbHNlXSBIaWRlIGxlZ2VuZFxyXG4gICAgICogIElmIHRydWUgZ2l2ZW4sIGFsbCBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uIElmIHN0cmluZyBvciBhcnJheSBnaXZlbiwgb25seSB0aGUgbGVnZW5kIHRoYXQgaGFzIHRoZSBpZCB3aWxsIGJlIGhpZGRlbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfEhUTUxFbGVtZW50fSBbbGVnZW5kLmNvbnRlbnRzLmJpbmR0bz11bmRlZmluZWRdIFNldCBDU1Mgc2VsZWN0b3Igb3IgZWxlbWVudCByZWZlcmVuY2UgdG8gYmluZCBsZWdlbmQgaXRlbXMuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xGdW5jdGlvbn0gW2xlZ2VuZC5jb250ZW50cy50ZW1wbGF0ZT11bmRlZmluZWRdIFNldCBpdGVtJ3MgdGVtcGxhdGUuPGJyPlxyXG4gICAgICogIC0gSWYgc2V0IGBzdHJpbmdgIHZhbHVlLCB3aXRoaW4gdGVtcGxhdGUgdGhlICdjb2xvcicgYW5kICd0aXRsZScgY2FuIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcclxuICAgICAqICAgIC0gez1DT0xPUn06IGRhdGEgY29sb3IgdmFsdWVcclxuICAgICAqICAgIC0gez1USVRMRX06IGRhdGEgdGl0bGUgdmFsdWVcclxuICAgICAqICAtIElmIHNldCBgZnVuY3Rpb25gIHZhbHVlLCB3aWxsIHBhc3MgZm9sbG93aW5nIGFyZ3VtZW50cyB0byB0aGUgZ2l2ZW4gZnVuY3Rpb246XHJcbiAgICAgKiAgIC0gdGl0bGUge1N0cmluZ306IGRhdGEncyBpZCB2YWx1ZVxyXG4gICAgICogICAtIGNvbG9yIHtTdHJpbmd9OiBjb2xvciBzdHJpbmdcclxuICAgICAqICAgLSBkYXRhIHtBcnJheX06IGRhdGEgYXJyYXlcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbbGVnZW5kLnBvc2l0aW9uPWJvdHRvbV0gQ2hhbmdlIHRoZSBwb3NpdGlvbiBvZiBsZWdlbmQuPGJyPlxyXG4gICAgICogIEF2YWlsYWJsZSB2YWx1ZXMgYXJlOiBgYm90dG9tYCwgYHJpZ2h0YCBhbmQgYGluc2V0YCBhcmUgc3VwcG9ydGVkLlxyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IFtsZWdlbmQuaW5zZXQ9e2FuY2hvcjogJ3RvcC1sZWZ0Jyx4OiAxMCx5OiAwLHN0ZXA6IHVuZGVmaW5lZH1dIENoYW5nZSBpbnNldCBsZWdlbmQgYXR0cmlidXRlcy48YnI+XHJcbiAgICAgKiAgVGhpcyBvcHRpb24gYWNjZXB0cyBvYmplY3QgdGhhdCBoYXMgdGhlIGtleXMgYGFuY2hvcmAsIGB4YCwgYHlgIGFuZCBgc3RlcGAuXHJcbiAgICAgKiAgLSAqKmFuY2hvcioqIGRlY2lkZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsZWdlbmQ6XHJcbiAgICAgKiAgIC0gdG9wLWxlZnRcclxuICAgICAqICAgLSB0b3AtcmlnaHRcclxuICAgICAqICAgLSBib3R0b20tbGVmdFxyXG4gICAgICogICAtIGJvdHRvbS1yaWdodFxyXG4gICAgICogIC0gKip4KiogYW5kICoqeSoqOlxyXG4gICAgICogICAtIHNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZCBiYXNlZCBvbiB0aGUgYW5jaG9yLlxyXG4gICAgICogIC0gKipzdGVwKio6XHJcbiAgICAgKiAgIC0gZGVmaW5lcyB0aGUgbWF4IHN0ZXAgdGhlIGxlZ2VuZCBoYXMgKGUuZy4gSWYgMiBzZXQgYW5kIGxlZ2VuZCBoYXMgMyBsZWdlbmQgaXRlbSwgdGhlIGxlZ2VuZCAyIGNvbHVtbnMpLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLmVxdWFsbHk9ZmFsc2VdIFNldCB0byBhbGwgaXRlbXMgaGF2ZSBzYW1lIHdpZHRoIHNpemUuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQucGFkZGluZz0wXSBTZXQgcGFkZGluZyB2YWx1ZVxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2xlZ2VuZC5pdGVtLm9uY2xpY2s9dW5kZWZpbmVkXSBTZXQgY2xpY2sgZXZlbnQgaGFuZGxlciB0byB0aGUgbGVnZW5kIGl0ZW0uXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25vdmVyPXVuZGVmaW5lZF0gU2V0IG1vdXNlL3RvdWNoIG92ZXIgZXZlbnQgaGFuZGxlciB0byB0aGUgbGVnZW5kIGl0ZW0uXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25vdXQ9dW5kZWZpbmVkXSBTZXQgbW91c2UvdG91Y2ggb3V0IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGxlZ2VuZCBpdGVtLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsZWdlbmQuaXRlbS50aWxlLndpZHRoPTEwXSBTZXQgd2lkdGggb2YgaXRlbSB0aWxlIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbGVnZW5kLml0ZW0udGlsZS5oZWlnaHQ9MTBdIFNldCBoZWlnaHQgb2YgaXRlbSB0aWxlIGVsZW1lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC51c2VQb2ludD1mYWxzZV0gV2hldGhlciB0byB1c2UgY3VzdG9tIHBvaW50cyBpbiBsZWdlbmQuXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBwb3NpdGlvbl0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0xlZ2VuZC5MZWdlbmRQb3NpdGlvbilcclxuICAgICAqIEBzZWUgW0RlbW86IGNvbnRlbnRzLnRlbXBsYXRlXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLkxlZ2VuZFRlbXBsYXRlMSlcclxuICAgICAqIEBzZWUgW0RlbW86IHVzZVBvaW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLnVzZVBvaW50KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBsZWdlbmQ6IHtcclxuICAgICAqICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAqICAgICAgaGlkZTogdHJ1ZSxcclxuICAgICAqICAgICAgLy9vciBoaWRlOiBcImRhdGExXCJcclxuICAgICAqICAgICAgLy9vciBoaWRlOiBbXCJkYXRhMVwiLCBcImRhdGEyXCJdXHJcbiAgICAgKiAgICAgIGNvbnRlbnRzOiB7XHJcbiAgICAgKiAgICAgICAgICBiaW5kdG86IFwiI2xlZ2VuZFwiLCAgIC8vIDx1bCBpZD0nbGVnZW5kJz48L3VsPlxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIHdpbGwgYmUgYXM6IDxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjojMWY3N2I0Jz5kYXRhMTwvbGk+XHJcbiAgICAgKiAgICAgICAgICB0ZW1wbGF0ZTogXCI8bGkgc3R5bGU9J2JhY2tncm91bmQtY29sb3I6ez1DT0xPUn0nPns9VElUTEV9PC9saT5cIlxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIG9yIHVzaW5nIGZ1bmN0aW9uXHJcbiAgICAgKiAgICAgICAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oaWQsIGNvbG9yLCBkYXRhKSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgIC8vIGlmIHlvdSB3YW50IG9taXQgc29tZSBsZWdlbmQsIHJldHVybiBmYWxzeSB2YWx1ZVxyXG4gICAgICogICAgICAgICAgICAgICBpZiAodGl0bGUgIT09IFwiZGF0YTFcIikge1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjpcIisgY29sb3IgK1wiPlwiKyB0aXRsZSArXCI8L2xpPlwiO1xyXG4gICAgICogICAgICAgICAgICAgICB9XHJcbiAgICAgKiAgICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiLCAgLy8gYm90dG9tLCByaWdodCwgaW5zZXRcclxuICAgICAqICAgICAgaW5zZXQ6IHtcclxuICAgICAqICAgICAgICAgIGFuY2hvcjogXCJ0b3AtcmlnaHRcIiAgLy8gdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodFxyXG4gICAgICogICAgICAgICAgeDogMjAsXHJcbiAgICAgKiAgICAgICAgICB5OiAxMCxcclxuICAgICAqICAgICAgICAgIHN0ZXA6IDJcclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgZXF1YWxseTogZmFsc2UsXHJcbiAgICAgKiAgICAgIHBhZGRpbmc6IDEwLFxyXG4gICAgICogICAgICBpdGVtOiB7XHJcbiAgICAgKiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbihpZCkgeyAuLi4gfSxcclxuICAgICAqICAgICAgICAgIG9ub3ZlcjogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXHJcbiAgICAgKiAgICAgICAgICBvbm91dDogZnVuY3Rpb24oaWQpIHsgLi4uIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgLy8gc2V0IHRpbGUncyBzaXplXHJcbiAgICAgKiAgICAgICAgICB0aWxlOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgd2lkdGg6IDIwLFxyXG4gICAgICogICAgICAgICAgICAgIGhlaWdodDogMTVcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgdXNlUG9pbnQ6IHRydWVcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGxlZ2VuZF9zaG93OiB0cnVlLFxyXG4gICAgbGVnZW5kX2hpZGU6IGZhbHNlLFxyXG4gICAgbGVnZW5kX2NvbnRlbnRzX2JpbmR0bzogPHN0cmluZ3xIVE1MRWxlbWVudHx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZTogPHN0cmluZ3woKCkgPT4gc3RyaW5nKXx1bmRlZmluZWQ+dW5kZWZpbmVkLFxyXG4gICAgbGVnZW5kX3Bvc2l0aW9uOiA8XCJib3R0b21cInxcInJpZ2h0XCJ8XCJpbnNldFwiPiBcImJvdHRvbVwiLFxyXG4gICAgbGVnZW5kX2luc2V0X2FuY2hvcjogPFwidG9wLWxlZnRcInxcInRvcC1yaWdodFwifFwiYm90dG9tLWxlZnRcInxcImJvdHRvbS1yaWdodFwiPiBcInRvcC1sZWZ0XCIsXHJcbiAgICBsZWdlbmRfaW5zZXRfeDogMTAsXHJcbiAgICBsZWdlbmRfaW5zZXRfeTogMCxcclxuICAgIGxlZ2VuZF9pbnNldF9zdGVwOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgbGVnZW5kX2l0ZW1fb25jbGljazogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgbGVnZW5kX2l0ZW1fb25vdmVyOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBsZWdlbmRfaXRlbV9vbm91dDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgbGVnZW5kX2VxdWFsbHk6IGZhbHNlLFxyXG4gICAgbGVnZW5kX3BhZGRpbmc6IDAsXHJcbiAgICBsZWdlbmRfaXRlbV90aWxlX3dpZHRoOiAxMCxcclxuICAgIGxlZ2VuZF9pdGVtX3RpbGVfaGVpZ2h0OiAxMCxcclxuICAgIGxlZ2VuZF91c2VQb2ludDogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogdGl0bGUgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRpdGxlIG9wdGlvbnNcclxuICAgICAqIEBuYW1lIHRpdGxlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdGl0bGUudGV4dF0gVGl0bGUgdGV4dC4gSWYgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrIGFsbG93aW5nIG11bHRpbGluZSB0aXRsZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGl0bGUucGFkZGluZy50b3A9MF0gVG9wIHBhZGRpbmcgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcucmlnaHQ9MF0gUmlnaHQgcGFkZGluZyB2YWx1ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGl0bGUucGFkZGluZy5ib3R0b209MF0gQm90dG9tIHBhZGRpbmcgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcubGVmdD0wXSBMZWZ0IHBhZGRpbmcgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3RpdGxlLnBvc2l0aW9uPWNlbnRlcl0gQXZhaWxhYmxlIHZhbHVlcyBhcmU6ICdjZW50ZXInLCAncmlnaHQnIGFuZCAnbGVmdCcuXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVGl0bGUuTXVsdGlsaW5lZFRpdGxlKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICB0aXRsZToge1xyXG4gICAgICogICAgICB0ZXh0OiBcIlRpdGxlIFRleHRcIixcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yIE11bHRpbGluZSB0aXRsZSB0ZXh0XHJcbiAgICAgKiAgICAgIHRleHQ6IFwiTWFpbiB0aXRsZSB0ZXh0XFxuU3ViIHRpdGxlIHRleHRcIixcclxuICAgICAqXHJcbiAgICAgKiAgICAgIHBhZGRpbmc6IHtcclxuICAgICAqICAgICAgICAgIHRvcDogMTAsXHJcbiAgICAgKiAgICAgICAgICByaWdodDogMTAsXHJcbiAgICAgKiAgICAgICAgICBib3R0b206IDEwLFxyXG4gICAgICogICAgICAgICAgbGVmdDogMTBcclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgcG9zaXRpb246IFwiY2VudGVyXCJcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHRpdGxlX3RleHQ6IDxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB0aXRsZV9wYWRkaW5nOiB7XHJcbiAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgIHJpZ2h0OiAwLFxyXG4gICAgICAgIGJvdHRvbTogMCxcclxuICAgICAgICBsZWZ0OiAwXHJcbiAgICB9LFxyXG4gICAgdGl0bGVfcG9zaXRpb246IDxcImNlbnRlclwifFwicmlnaHRcInxcImxlZnRcIj4gXCJjZW50ZXJcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB0b29sdGlwIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFRvb2x0aXAgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgdG9vbHRpcFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHRvb2x0aXAuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmRvTm90SGlkZT1mYWxzZV0gTWFrZSB0b29sdGlwIGtlZXAgc2hvd2luZyBub3QgaGlkaW5nIG9uIGludGVyYWN0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5ncm91cGVkPXRydWVdIFNldCBpZiB0b29sdGlwIGlzIGdyb3VwZWQgb3Igbm90IGZvciB0aGUgZGF0YSBwb2ludHMuXHJcbiAgICAgKiAgIC0gKipOT1RFOioqIFRoZSBvdmVybGFwcGVkIGRhdGEgcG9pbnRzIHdpbGwgYmUgZGlzcGxheWVkIGFzIGdyb3VwZWQgZXZlbiBpZiBzZXQgZmFsc2UuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmxpbmtlZD1mYWxzZV0gU2V0IGlmIHRvb2x0aXBzIG9uIGFsbCB2aXNpYmxlIGNoYXJ0cyB3aXRoIGxpa2UgeCBwb2ludHMgYXJlIHNob3duIHRvZ2V0aGVyIHdoZW4gb25lIGlzIHNob3duLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0b29sdGlwLmxpbmtlZC5uYW1lPVwiXCJdIEdyb3BpbmcgbmFtZSBmb3IgbGlua2VkIHRvb2x0aXAuPGJyPklmIHNwZWNpZmllZCwgbGlua2VkIHRvb2x0aXAgd2lsbCBiZSBncm9wZWQgaW50ZXJhY3RpbmcgdG8gYmUgd29ya2VkIG9ubHkgd2l0aCB0aGUgc2FtZSBuYW1lLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAuZm9ybWF0LnRpdGxlXSBTZXQgZm9ybWF0IGZvciB0aGUgdGl0bGUgb2YgdG9vbHRpcC48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC5uYW1lXSBTZXQgZm9ybWF0IGZvciB0aGUgbmFtZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQudmFsdWVdIFNldCBmb3JtYXQgZm9yIHRoZSB2YWx1ZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXHJcbiAgICAgKiAgSWYgdW5kZWZpbmVkIHJldHVybmVkLCB0aGUgcm93IG9mIHRoYXQgdmFsdWUgd2lsbCBiZSBza2lwcGVkLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAucG9zaXRpb25dIFNldCBjdXN0b20gcG9zaXRpb24gZm9yIHRoZSB0b29sdGlwLjxicj5cclxuICAgICAqICBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgcG9zaXRpb24gYnkgcmV0dXJuaW5nIG9iamVjdCB0aGF0IGhhcyB0b3AgYW5kIGxlZnQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufE9iamVjdH0gW3Rvb2x0aXAuY29udGVudHNdIFNldCBjdXN0b20gSFRNTCBmb3IgdGhlIHRvb2x0aXAuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBkYXRhLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCBhbmQgY29sb3Igb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gSWYgdG9vbHRpcC5ncm91cGVkIGlzIHRydWUsIGRhdGEgaW5jbHVkZXMgbXVsdGlwbGUgZGF0YSBwb2ludHMuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudH0gW3Rvb2x0aXAuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIHRvb2x0aXAuXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogV2hlbiBpcyBzcGVjaWZpZWQsIHdpbGwgbm90IGJlIHVwZGF0aW5nIHRvb2x0aXAncyBwb3NpdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdG9vbHRpcC5jb250ZW50cy50ZW1wbGF0ZT11bmRlZmluZWRdIFNldCB0b29sdGlwJ3MgdGVtcGxhdGUuPGJyPjxicj5cclxuICAgICAqICBXaXRoaW4gdGVtcGxhdGUsIGJlbG93IHN5bnRheCB3aWxsIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcclxuICAgICAqICAgIC0gKip7eyAuLi4gfX0qKjogdGhlIGRvdWJseSBjdXJseSBicmFja2V0cyBpbmRpY2F0ZSBsb29wIGJsb2NrIGZvciBkYXRhIHJvd3MuXHJcbiAgICAgKiAgICAtICoqez1DTEFTU19UT09MVElQfSoqOiBkZWZhdWx0IHRvb2x0aXAgY2xhc3MgbmFtZSBgYmItdG9vbHRpcGAuXHJcbiAgICAgKiAgICAtICoqez1DTEFTU19UT09MVElQX05BTUV9Kio6IGRlZmF1bHQgdG9vbHRpcCBkYXRhIGNsYXNzIG5hbWUgKGV4LiBgYmItdG9vbHRpcC1uYW1lLWRhdGExYClcclxuICAgICAqICAgIC0gKip7PVRJVExFfSoqOiB0aXRsZSB2YWx1ZS5cclxuICAgICAqICAgIC0gKip7PUNPTE9SfSoqOiBkYXRhIGNvbG9yLlxyXG4gICAgICogICAgLSAqKns9VkFMVUV9Kio6IGRhdGEgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW3Rvb2x0aXAuY29udGVudHMudGV4dD11bmRlZmluZWRdIFNldCBhZGRpdGlvbmFsIHRleHQgY29udGVudCB3aXRoaW4gZGF0YSBsb29wLCB1c2luZyB0ZW1wbGF0ZSBzeW50YXguXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogSXQgc2hvdWxkIGNvbnRhaW4gYHsga2V5OiBBcnJheSwgLi4uIH1gIHZhbHVlXHJcbiAgICAgKiAgICAtICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXHJcbiAgICAgKiAgICAtIFRoZSB2YWx1ZSBhcnJheSBsZW5ndGggc2hvdWxkIG1hdGNoIHdpdGggdGhlIGRhdGEgbGVuZ3RoXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmluaXQuc2hvdz1mYWxzZV0gU2hvdyB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdG9vbHRpcC5pbml0Lng9MF0gU2V0IHggQXhpcyBpbmRleCB0byBiZSBzaG93biBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW3Rvb2x0aXAuaW5pdC5wb3NpdGlvbj17dG9wOiBcIjBweFwiLGxlZnQ6IFwiNTBweFwifV0gU2V0IHRoZSBwb3NpdGlvbiBvZiB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd10gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYmVmb3JlIHRoZSB0b29sdGlwIGlzIHNob3duLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRlXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25zaG93bl0gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHRvb2x0aXAgaXMgc2hvd25cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uaGlkZGVuXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xGdW5jdGlvbnxudWxsfSBbdG9vbHRpcC5vcmRlcj1udWxsXSBTZXQgdG9vbHRpcCBkYXRhIGRpc3BsYXkgb3JkZXIuPGJyPjxicj5cclxuICAgICAqICAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuICAgICAqICAtIGBkZXNjYDogSW4gZGVzY2VuZGluZyBkYXRhIHZhbHVlIG9yZGVyXHJcbiAgICAgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcclxuICAgICAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgZGlzcGxheSBvcmRlcjxicj5cclxuICAgICAqICAgICAqKk5PVEU6KiogV2hlbiBgZGF0YS5ncm91cHNgIGlzIHNldCwgdGhlIG9yZGVyIHdpbGwgZm9sbG93IGFzIHRoZSBzdGFja2VkIGdyYXBoIG9yZGVyLjxicj5cclxuICAgICAqICAgICAgSWYgd2FudCB0byBvcmRlciBhcyBkYXRhIGJvdW5kLCBzZXQgYW55IHZhbHVlIHJhdGhlciB0aGFuIGFzYywgZGVzYyBvciBudWxsLiAoZXguIGVtcHR5IHN0cmluZyBcIlwiKVxyXG4gICAgICogIC0gYGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyAuLi4gfWA6IFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKVxyXG4gICAgICogQHNlZSBbRGVtbzogSGlkZSBUb29sdGlwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5IaWRlVG9vbHRpcClcclxuICAgICAqIEBzZWUgW0RlbW86IFRvb2x0aXAgR3JvdXBpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBHcm91cGluZylcclxuICAgICAqIEBzZWUgW0RlbW86IFRvb2x0aXAgRm9ybWF0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5Ub29sdGlwRm9ybWF0KVxyXG4gICAgICogQHNlZSBbRGVtbzogTGlua2VkIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkxpbmtlZFRvb2x0aXBzKVxyXG4gICAgICogQHNlZSBbRGVtbzogVG9vbHRpcCBUZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcFRlbXBsYXRlKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICB0b29sdGlwOiB7XHJcbiAgICAgKiAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgIGRvTm90SGlkZTogdHJ1ZSxcclxuICAgICAqICAgICAgZ3JvdXBlZDogZmFsc2UsXHJcbiAgICAgKiAgICAgIGZvcm1hdDoge1xyXG4gICAgICogICAgICAgICAgdGl0bGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFwiRGF0YSBcIiArIHg7IH0sXHJcbiAgICAgKiAgICAgICAgICBuYW1lOiBmdW5jdGlvbihuYW1lLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiBuYW1lOyB9LFxyXG4gICAgICogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiByYXRpbzsgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZGF0YSwgd2lkdGgsIGhlaWdodCwgZWxlbWVudCkge1xyXG4gICAgICogICAgICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IDB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBjb250ZW50czogZnVuY3Rpb24oZCwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQsIGNvbG9yKSB7XHJcbiAgICAgKiAgICAgICAgICByZXR1cm4gLi4uIC8vIGZvcm1hdHRlZCBodG1sIGFzIHlvdSB3YW50XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gc3BlY2lmeSB0b29sdGlwIGNvbnRlbnRzIHVzaW5nIHRlbXBsYXRlXHJcbiAgICAgKiAgICAgICAvLyAtIGV4YW1wbGUgb2YgSFRNTCByZXR1cm5lZDpcclxuICAgICAqICAgICAgIC8vIDx1bCBjbGFzcz1cImJiLXRvb2x0aXBcIj5cclxuICAgICAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGExXCI+PHNwYW4+MjUwPC9zcGFuPjxicj48c3BhbiBzdHlsZT1cImNvbG9yOiMwMGM3M2NcIj5kYXRhMTwvc3Bhbj48L2xpPlxyXG4gICAgICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTJcIj48c3Bhbj41MDwvc3Bhbj48YnI+PHNwYW4gc3R5bGU9XCJjb2xvcjojZmE3MTcxXCI+ZGF0YTI8L3NwYW4+PC9saT5cclxuICAgICAqICAgICAgIC8vIDwvdWw+XHJcbiAgICAgKiAgICAgICBjb250ZW50czoge1xyXG4gICAgICogICAgICBcdGJpbmR0bzogXCIjdG9vbHRpcFwiLFxyXG4gICAgICogICAgICBcdHRlbXBsYXRlOiAnPHVsIGNsYXNzPXs9Q0xBU1NfVE9PTFRJUH0+e3snICtcclxuICAgICAqICAgICAgXHRcdFx0JzxsaSBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUF9OQU1FfVwiPjxzcGFuPns9VkFMVUV9PC9zcGFuPjxicj4nICtcclxuICAgICAqICAgICAgXHRcdFx0JzxzcGFuIHN0eWxlPWNvbG9yOns9Q09MT1J9Pns9TkFNRX08L3NwYW4+PC9saT4nICtcclxuICAgICAqICAgICAgXHRcdCd9fTwvdWw+J1xyXG4gICAgICogICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gd2l0aCBhZGRpdGlvbmFsIHRleHQgdmFsdWVcclxuICAgICAqICAgICAgIC8vIC0gZXhhbXBsZSBvZiBIVE1MIHJldHVybmVkOlxyXG4gICAgICogICAgICAgLy8gPHVsIGNsYXNzPVwiYmItdG9vbHRpcFwiPlxyXG4gICAgICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTFcIj48c3Bhbj4yNTA8L3NwYW4+PGJyPmNvbW1lbnQxPHNwYW4gc3R5bGU9XCJjb2xvcjojMDBjNzNjXCI+ZGF0YTE8L3NwYW4+dGV4dDE8L2xpPlxyXG4gICAgICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTJcIj48c3Bhbj41MDwvc3Bhbj48YnI+Y29tbWVudDI8c3BhbiBzdHlsZT1cImNvbG9yOiNmYTcxNzFcIj5kYXRhMjwvc3Bhbj50ZXh0MjwvbGk+XHJcbiAgICAgKiAgICAgICAvLyA8L3VsPlxyXG4gICAgICogICAgICAgY29udGVudHM6IHtcclxuICAgICAqICAgICAgXHRiaW5kdG86IFwiI3Rvb2x0aXBcIixcclxuICAgICAqICAgICAgXHR0ZXh0OiB7XHJcbiAgICAgKiAgICAgIFx0XHQvLyBhKSAna2V5JyBuYW1lIGlzIHVzZWQgYXMgc3Vic3RpdHV0aW9uIHdpdGhpbiB0ZW1wbGF0ZSBhcyAnez1LRVl9J1xyXG4gICAgICogICAgICBcdFx0Ly8gYikgdGhlIGxlbmd0aCBzaG91bGQgbWF0Y2ggd2l0aCB0aGUgZGF0YSBsZW5ndGhcclxuICAgICAqICAgICAgXHRcdFZBUjE6IFtcInRleHQxXCIsIFwidGV4dDJcIl0sXHJcbiAgICAgKiAgICAgIFx0XHRWQVIyOiBbXCJjb21tZW50MVwiLCBcImNvbW1lbnQyXCJdLFxyXG4gICAgICogICAgICBcdH0sXHJcbiAgICAgKiAgICAgIFx0dGVtcGxhdGU6ICc8dWwgY2xhc3M9ez1DTEFTU19UT09MVElQfT57eycgK1xyXG4gICAgICogICAgICBcdFx0XHQnPGxpIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+PHNwYW4+ez1WQUxVRX08L3NwYW4+ez1WQVIyfTxicj4nICtcclxuICAgICAqICAgICAgXHRcdFx0JzxzcGFuIHN0eWxlPWNvbG9yOns9Q09MT1J9Pns9TkFNRX08L3NwYW4+ez1WQVIxfTwvbGk+JyArXHJcbiAgICAgKiAgICAgIFx0XHQnfX08L3VsPidcclxuICAgICAqICAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc29ydCB0b29sdGlwIGRhdGEgdmFsdWUgZGlzcGxheSBpbiBhc2NlbmRpbmcgb3JkZXJcclxuICAgICAqICAgICAgb3JkZXI6IFwiYXNjXCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBzcGVjaWZ5aW5nIHNvcnQgZnVuY3Rpb25cclxuICAgICAqICAgICAgb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAqICAgICAgICAgLy8gcGFyYW0gZGF0YSBwYXNzZWQgZm9ybWF0XHJcbiAgICAgKiAgICAgICAgIHt4OiA1LCB2YWx1ZTogMjUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNSwgbmFtZTogXCJkYXRhMVwifVxyXG4gICAgICogICAgICAgICAgIC4uLlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc2hvdyBhdCB0aGUgaW5pdGlhbGl6YXRpb25cclxuICAgICAqICAgICAgaW5pdDoge1xyXG4gICAgICogICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAqICAgICAgICAgIHg6IDIsXHJcbiAgICAgKiAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgICAgICAgIHRvcDogXCIxNTBweFwiLFxyXG4gICAgICogICAgICAgICAgICAgIGxlZnQ6IFwiMjUwcHhcIlxyXG4gICAgICogICAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZmlyZXMgcHJpb3IgdG9vbHRpcCBpcyBzaG93blxyXG4gICAgICogICAgICBvbnNob3c6IGZ1bmN0aW9uKGN0eCwgc2VsZWN0ZWREYXRhKSB7XHJcbiAgICAgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdC8vIGN1cnJlbnQgZGF0YXNldCBzZWxlY3RlZFxyXG4gICAgICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXHJcbiAgICAgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZmlyZXMgcHJpb3IgdG9vbHRpcCBpcyBoaWRkZW5cclxuICAgICAqICAgICAgb25oaWRlOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xyXG4gICAgICogICAgICBcdGN0eDsgLy8gY3VycmVudCBjaGFydCBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcclxuICAgICAqICAgICAgXHQvLyA9PT4gW3t4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMlwifSwgLi4uXVxyXG4gICAgICogICAgICBcdHNlbGVjdGVkRGF0YTtcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGZpcmVzIGFmdGVyIHRvb2x0aXAgaXMgc2hvd25cclxuICAgICAqICAgICAgb25zaG93bjogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuICAgICAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcbiAgICAgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuICAgICAqICAgICAgXHRzZWxlY3RlZERhdGE7XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBmaXJlcyBhZnRlciB0b29sdGlwIGlzIGhpZGRlblxyXG4gICAgICogICAgICBvbmhpZGRlbjogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuICAgICAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcbiAgICAgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuICAgICAqICAgICAgXHRzZWxlY3RlZERhdGE7XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBMaW5rIGFueSB0b29sdGlwcyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBhcmUgb24gdGhlIHNjcmVlbiB3aGVyZSBzYW1lIHggY29vcmRpbmF0ZXMgYXJlIGF2YWlsYWJsZVxyXG4gICAgICogICAgICAvLyBVc2VmdWwgZm9yIHRpbWVzZXJpZXMgY29ycmVsYXRpb25cclxuICAgICAqICAgICAgbGlua2VkOiB0cnVlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gU3BlY2lmeSBuYW1lIHRvIGludGVyYWN0IHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBvbmx5LlxyXG4gICAgICogICAgICBsaW5rZWQ6IHtcclxuICAgICAqICAgICAgICAgIG5hbWU6IFwic29tZS1ncm91cFwiXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHRvb2x0aXBfc2hvdzogdHJ1ZSxcclxuICAgIHRvb2x0aXBfZG9Ob3RIaWRlOiBmYWxzZSxcclxuICAgIHRvb2x0aXBfZ3JvdXBlZDogdHJ1ZSxcclxuICAgIHRvb2x0aXBfZm9ybWF0X3RpdGxlOiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB0b29sdGlwX2Zvcm1hdF9uYW1lOiA8KCgpID0+IHN0cmluZyl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB0b29sdGlwX2Zvcm1hdF92YWx1ZTogPCgoKSA9PiBudW1iZXIpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgdG9vbHRpcF9wb3NpdGlvbjogPCgoKSA9PiB7dG9wOiBudW1iZXI7IGxlZnQ6IG51bWJlcjt9KXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIHRvb2x0aXBfY29udGVudHM6IDwoKCkgPT4gc3RyaW5nKXx7YmluZHRvOiBzdHJpbmc7IHRlbXBsYXRlOiBzdHJpbmc7IHRleHQ/OiB7W2tleTogc3RyaW5nXTogc3RyaW5nW119fT4ge30sXHJcbiAgICB0b29sdGlwX2luaXRfc2hvdzogZmFsc2UsXHJcbiAgICB0b29sdGlwX2luaXRfeDogMCxcclxuICAgIHRvb2x0aXBfaW5pdF9wb3NpdGlvbjoge1xyXG4gICAgICAgIHRvcDogXCIwcHhcIixcclxuICAgICAgICBsZWZ0OiBcIjUwcHhcIlxyXG4gICAgfSxcclxuICAgIHRvb2x0aXBfbGlua2VkOiBmYWxzZSxcclxuICAgIHRvb2x0aXBfbGlua2VkX25hbWU6IFwiXCIsXHJcbiAgICB0b29sdGlwX29uc2hvdzogKCkgPT4ge30sXHJcbiAgICB0b29sdGlwX29uaGlkZTogKCkgPT4ge30sXHJcbiAgICB0b29sdGlwX29uc2hvd246ICgpID0+IHt9LFxyXG4gICAgdG9vbHRpcF9vbmhpZGRlbjogKCkgPT4ge30sXHJcbiAgICB0b29sdGlwX29yZGVyOiA8c3RyaW5nfEZ1bmN0aW9ufG51bGw+IG51bGxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQXhpcyBiYXNlZCBjaGFydCBkYXRhIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgdGhlIGtleSBvZiB4IHZhbHVlcyBpbiB0aGUgZGF0YS48YnI+PGJyPlxyXG4gICAgICogV2UgY2FuIHNob3cgdGhlIGRhdGEgd2l0aCBub24taW5kZXggeCB2YWx1ZXMgYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gdGhlIHR5cGUgb2YgeCBheGlzIGlzIHRpbWVzZXJpZXMuIElmIHRoaXMgb3B0aW9uIGlzIHNldCBvbiBjYXRlZ29yeSBheGlzLCB0aGUgdmFsdWVzIG9mIHRoZSBkYXRhIG9uIHRoZSBrZXkgd2lsbCBiZSB1c2VkIGZvciBjYXRlZ29yeSBuYW1lcy5cclxuICAgICAqIEBuYW1lIGRhdGHigKR4XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgeDogXCJkYXRlXCJcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV94OiA8c3RyaW5nfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmeSB0aGUga2V5cyBvZiB0aGUgeCB2YWx1ZXMgZm9yIGVhY2ggZGF0YS48YnI+PGJyPlxyXG4gICAgICogVGhpcyBvcHRpb24gY2FuIGJlIHVzZWQgaWYgd2Ugd2FudCB0byBzaG93IHRoZSBkYXRhIHRoYXQgaGFzIGRpZmZlcmVudCB4IHZhbHVlcy5cclxuICAgICAqIEBuYW1lIGRhdGHigKR4c1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgeHM6IHtcclxuICAgICAqICAgICAgZGF0YTE6IFwieDFcIixcclxuICAgICAqICAgICAgZGF0YTI6IFwieDJcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfeHM6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgZm9ybWF0IHNwZWNpZmllciB0byBwYXJzZSBzdHJpbmcgc3BlY2lmZWQgYXMgeC5cclxuICAgICAqIEBuYW1lIGRhdGHigKR4Rm9ybWF0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0ICVZLSVtLSVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgeDogXCJ4XCIsXHJcbiAgICAgKiAgICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgICAgW1wieFwiLCBcIjAxMDEyMDE5XCIsIFwiMDIwMTIwMTlcIiwgXCIwMzAxMjAxOVwiXSxcclxuICAgICAqICAgICAgICBbXCJkYXRhMVwiLCAzMCwgMjAwLCAxMDBdXHJcbiAgICAgKiAgICBdLFxyXG4gICAgICogICAgLy8gRm9ybWF0IHNwZWNpZmllciB0byBwYXJzZSBhcyBkYXRldGltZSBmb3IgZ2l2ZW4gJ3gnIHN0cmluZyB2YWx1ZVxyXG4gICAgICogICAgeEZvcm1hdDogXCIlbSVkJVlcIlxyXG4gICAgICogfSxcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgIHg6IHtcclxuICAgICAqICAgICAgICB0eXBlOiBcInRpbWVzZXJpZXNcIlxyXG4gICAgICogICAgfVxyXG4gICAgICogfVxyXG4gICAgICogQHNlZSBbRDMncyB0aW1lIHNwZWNpZmllcl0oaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUtZm9ybWF0I2xvY2FsZV9mb3JtYXQpXHJcbiAgICAgKi9cclxuICAgIGRhdGFfeEZvcm1hdDogXCIlWS0lbS0lZFwiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxvY2FsdGltZSBmb3JtYXQgdG8gcGFyc2UgeCBheGlzLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHhMb2NhbHRpbWVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHhMb2NhbHRpbWU6IGZhbHNlXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfeExvY2FsdGltZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNvcnQgb24geCBheGlzLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHhTb3J0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICB4U29ydDogZmFsc2VcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV94U29ydDogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBncm91cHMgZm9yIHRoZSBkYXRhIGZvciBzdGFja2luZy5cclxuICAgICAqIEBuYW1lIGRhdGHigKRncm91cHNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCBbXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgZ3JvdXBzOiBbXHJcbiAgICAgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuICAgICAqICAgICBbXCJkYXRhM1wiXVxyXG4gICAgICogICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfZ3JvdXBzOiA8c3RyaW5nW11bXT4gW10sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgeSBheGlzIHRoZSBkYXRhIHJlbGF0ZWQgdG8uIHkgYW5kIHkyIGNhbiBiZSB1c2VkLlxyXG5cdCAqIC0gKipOT1RFOioqIElmIGFsbCBkYXRhIGlzIHJlbGF0ZWQgdG8gb25lIG9mIHRoZSBheGVzLCB0aGUgZG9tYWluIG9mIGF4aXMgd2l0aG91dCByZWxhdGVkIGRhdGEgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZG9tYWluIGZyb20gdGhlIGF4aXMgd2l0aCByZWxhdGVkIGRhdGFcclxuICAgICAqIEBuYW1lIGRhdGHigKRheGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBheGVzOiB7XHJcbiAgICAgKiAgICAgZGF0YTE6IFwieVwiLFxyXG4gICAgICogICAgIGRhdGEyOiBcInkyXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2F4ZXM6IDx7W2tleTogc3RyaW5nXTogc3RyaW5nfT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbGFiZWxzIG9wdGlvbnNcclxuICAgICAqIEBuYW1lIGRhdGHigKRsYWJlbHNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZGF0YS5sYWJlbHM9ZmFsc2VdIFNob3cgb3IgaGlkZSBsYWJlbHMgb24gZWFjaCBkYXRhIHBvaW50c1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZGF0YS5sYWJlbHMuY2VudGVyZWQ9ZmFsc2VdIENlbnRlcml6ZSBsYWJlbHMgb24gYGJhcmAgc2hhcGUuICgqKk5PVEU6Kiogd29ya3Mgb25seSBmb3IgJ2JhcicgdHlwZSlcclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkYXRhLmxhYmVscy5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZnVuY3Rpb24gZm9yIGRhdGEgbGFiZWxzLjxicj5cclxuICAgICAqIFRoZSBmb3JtYXR0ZXIgZnVuY3Rpb24gcmVjZWl2ZXMgNCBhcmd1bWVudHMgc3VjaCBhcyB2LCBpZCwgaSwgaiBhbmQgaXQgbXVzdCByZXR1cm4gYSBzdHJpbmcgdGhhdCB3aWxsIGJlIHNob3duIGFzIHRoZSBsYWJlbC4gVGhlIGFyZ3VtZW50cyBhcmU6PGJyPlxyXG4gICAgICogIC0gYHZgIGlzIHRoZSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcbiAgICAgKiAgLSBgaWRgIGlzIHRoZSBpZCBvZiB0aGUgZGF0YSB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcbiAgICAgKiAgLSBgaWAgaXMgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHdoZXJlIHRoZSBsYWJlbCBpcyBzaG93bi5cclxuICAgICAqICAtIGBqYCBpcyB0aGUgc3ViIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50IHdoZXJlIHRoZSBsYWJlbCBpcyBzaG93bi48YnI+PGJyPlxyXG4gICAgICogRm9ybWF0dGVyIGZ1bmN0aW9uIGNhbiBiZSBkZWZpbmVkIGZvciBlYWNoIGRhdGEgYnkgc3BlY2lmeWluZyBhcyBhbiBvYmplY3QgYW5kIEQzIGZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgc2V0IChleC4gZDMuZm9ybWF0KCckJykpXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xPYmplY3R9IFtkYXRhLmxhYmVscy5jb2xvcnNdIFNldCBsYWJlbCB0ZXh0IGNvbG9ycy5cclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbZGF0YS5sYWJlbHMucG9zaXRpb25dIFNldCBlYWNoIGRhdGFzZXQgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGF0YS5sYWJlbHMucG9zaXRpb24ueD0wXSB4IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZGF0YS5sYWJlbHMucG9zaXRpb24ueT0wXSB5IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbClcclxuICAgICAqIEBzZWUgW0RlbW86IGxhYmVsIGNvbG9yc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsQ29sb3JzKVxyXG4gICAgICogQHNlZSBbRGVtbzogbGFiZWwgZm9ybWF0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxGb3JtYXQpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBsYWJlbCBvdmVybGFwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxPdmVybGFwKVxyXG4gICAgICogQHNlZSBbRGVtbzogbGFiZWwgcG9zaXRpb25dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbFBvc2l0aW9uKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgbGFiZWxzOiB0cnVlLFxyXG4gICAgICpcclxuICAgICAqICAgLy8gb3Igc2V0IHNwZWNpZmljIG9wdGlvbnNcclxuICAgICAqICAgbGFiZWxzOiB7XHJcbiAgICAgKiAgICAgZm9ybWF0OiBmdW5jdGlvbih2LCBpZCwgaSwgaikgeyAuLi4gfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gaXQncyBwb3NzaWJsZSB0byBzZXQgZm9yIGVhY2ggZGF0YVxyXG4gICAgICogICAgIGZvcm1hdDoge1xyXG4gICAgICogICAgICAgICBkYXRhMTogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXHJcbiAgICAgKiAgICAgICAgIC4uLlxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIGFsaWduIHRleHQgdG8gY2VudGVyIG9mIHRoZSAnYmFyJyBzaGFwZSAod29ya3Mgb25seSBmb3IgJ2JhcicgdHlwZSlcclxuICAgICAqICAgICBjZW50ZXJlZDogdHJ1ZSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gYXBwbHkgZm9yIGFsbCBsYWJlbCB0ZXh0c1xyXG4gICAgICogICAgIGNvbG9yczogXCJyZWRcIixcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gb3Igc2V0IGRpZmZlcmVudCBjb2xvcnMgcGVyIGRhdGFzZXRcclxuICAgICAqICAgICAvLyBmb3Igbm90IHNwZWNpZmllZCBkYXRhc2V0LCB3aWxsIGhhdmUgdGhlIGRlZmF1bHQgY29sb3IgdmFsdWVcclxuICAgICAqICAgICBjb2xvcnM6IHtcclxuICAgICAqICAgICAgICBkYXRhMTogXCJ5ZWxsb3dcIixcclxuICAgICAqICAgICAgICBkYXRhMzogXCJncmVlblwiXHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gc2V0IHgsIHkgY29vcmRpbmF0ZSBwb3NpdGlvblxyXG4gICAgICogICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgeDogLTEwLFxyXG4gICAgICogICAgICAgIHk6IDEwXHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gb3Igc2V0IHgsIHkgY29vcmRpbmF0ZSBwb3NpdGlvbiBieSBlYWNoIGRhdGFzZXRcclxuICAgICAqICAgICBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgIGRhdGExOiB7eDogNSwgeTogNX0sXHJcbiAgICAgKiAgICAgICAgZGF0YTI6IHt4OiAxMCwgeTogLTIwfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2xhYmVsczpcclxuICAgICAgICA8Ym9vbGVhbiB8IHtcclxuICAgICAgICAgICAgY2VudGVyZWQ/OiBib29sZWFuO1xyXG4gICAgICAgICAgICBmb3JtYXQ/OiBGdW5jdGlvbjtcclxuICAgICAgICAgICAgY29sb3JzPzogc3RyaW5nfHtba2V5OiBzdHJpbmddOiBzdHJpbmd9O1xyXG4gICAgICAgICAgICBwb3NpdGlvbj86IHtba2V5OiBzdHJpbmddOiBudW1iZXJ9fHtba2V5OiBzdHJpbmddOiB7eD86IG51bWJlcjsgeT86IG51bWJlcjt9fVxyXG4gICAgICAgIH0+IHt9LFxyXG4gICAgZGF0YV9sYWJlbHNfY29sb3JzOiA8c3RyaW5nfG9iamVjdHx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGRhdGFfbGFiZWxzX3Bvc2l0aW9uOiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIERlZmluZSByZWdpb25zIGZvciBlYWNoIGRhdGEuPGJyPlxyXG4gICAgICogVGhlIHZhbHVlcyBtdXN0IGJlIGFuIGFycmF5IGZvciBlYWNoIGRhdGEgYW5kIGl0IHNob3VsZCBpbmNsdWRlIGFuIG9iamVjdCB0aGF0IGhhcyBgc3RhcnRgLCBgZW5kYCBhbmQgYHN0eWxlYC5cclxuICAgICAqIC0gVGhlIG9iamVjdCB0eXBlIHNob3VsZCBiZSBhczpcclxuICAgICAqICAgLSBzdGFydCB7TnVtYmVyfTogU3RhcnQgZGF0YSBwb2ludCBudW1iZXIuIElmIG5vdCBzZXQsIHRoZSBzdGFydCB3aWxsIGJlIHRoZSBmaXJzdCBkYXRhIHBvaW50LlxyXG4gICAgICogICAtIFtlbmRdIHtOdW1iZXJ9OiBFbmQgZGF0YSBwb2ludCBudW1iZXIuIElmIG5vdCBzZXQsIHRoZSBlbmQgd2lsbCBiZSB0aGUgbGFzdCBkYXRhIHBvaW50LlxyXG4gICAgICogICAtIFtzdHlsZS5kYXNoYXJyYXk9XCIyIDJcIl0ge09iamVjdH06IFRoZSBmaXJzdCBudW1iZXIgc3BlY2lmaWVzIGEgZGlzdGFuY2UgZm9yIHRoZSBmaWxsZWQgYXJlYSwgYW5kIHRoZSBzZWNvbmQgYSBkaXN0YW5jZSBmb3IgdGhlIHVuZmlsbGVkIGFyZWEuXHJcbiAgICAgKiAtICoqTk9URToqKiBDdXJyZW50bHkgdGhpcyBvcHRpb24gc3VwcG9ydHMgb25seSBsaW5lIGNoYXJ0IGFuZCBkYXNoZWQgc3R5bGUuIElmIHRoaXMgb3B0aW9uIHNwZWNpZmllZCwgdGhlIGxpbmUgd2lsbCBiZSBkYXNoZWQgb25seSBpbiB0aGUgcmVnaW9ucy5cclxuICAgICAqIEBuYW1lIGRhdGHigKRyZWdpb25zXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICByZWdpb25zOiB7XHJcbiAgICAgKiAgICAgZGF0YTE6IFt7XHJcbiAgICAgKiAgICAgICAgIHN0YXJ0OiAxLFxyXG4gICAgICogICAgICAgICBlbmQ6IDIsXHJcbiAgICAgKiAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgKiAgICAgICAgICAgICBkYXNoYXJyYXk6IFwiNSAyXCJcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgIH0sIHtcclxuICAgICAqICAgICAgICAgc3RhcnQ6IDNcclxuICAgICAqICAgICB9XSxcclxuICAgICAqICAgICAuLi5cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3JlZ2lvbnM6IDx7c3RhcnQ/OiBudW1iZXI7IGVuZD86IG51bWJlcjsgc3R5bGU/OiB7ZGFzaGFycmF5OiBzdHJpbmc7fX1bXT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHN0YWNraW5nIHRvIGJlIG5vcm1hbGl6ZWRcclxuICAgICAqIC0gKipOT1RFOioqXHJcbiAgICAgKiAgIC0gRm9yIHN0YWNraW5nLCAnW2RhdGEuZ3JvdXBzXSgjLmRhdGElMjVFMiUyNTgwJTI1QTRncm91cHMpJyBvcHRpb24gc2hvdWxkIGJlIHNldFxyXG4gICAgICogICAtIHkgQXhpcyB3aWxsIGJlIHNldCBpbiBwZXJjZW50YWdlIHZhbHVlICgwIH4gMTAwJSlcclxuICAgICAqICAgLSBNdXN0IGhhdmUgcG9zdGl2ZSB2YWx1ZXNcclxuICAgICAqIEBuYW1lIGRhdGHigKRzdGFja+KApG5vcm1hbGl6ZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFTdGFja05vcm1hbGl6ZWQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBzdGFjazoge1xyXG4gICAgICogICAgICBub3JtYWxpemU6IHRydWVcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3N0YWNrX25vcm1hbGl6ZTogZmFsc2VcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZGF0YS5zZWxlY3Rpb24gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGRhdGEgc2VsZWN0aW9uIGVuYWJsZWQ8YnI+PGJyPlxyXG4gICAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRydWUsIHdlIGNhbiBzZWxlY3QgdGhlIGRhdGEgcG9pbnRzIGFuZCBnZXQvc2V0IGl0cyBzdGF0ZSBvZiBzZWxlY3Rpb24gYnkgQVBJIChlLmcuIHNlbGVjdCwgdW5zZWxlY3QsIHNlbGVjdGVkKS5cclxuICAgICAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRlbmFibGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YVNlbGVjdGlvbilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICBzZWxlY3Rpb246IHtcclxuICAgICAqICAgICAgIGVuYWJsZWQ6IHRydWVcclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9zZWxlY3Rpb25fZW5hYmxlZDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZ3JvdXBlZCBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxyXG4gICAgICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpcGxlIGRhdGEgcG9pbnRzIHRoYXQgaGF2ZSBzYW1lIHggdmFsdWUgd2lsbCBiZSBzZWxlY3RlZCBieSBvbmUgc2VsZWN0aW9uLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGdyb3VwZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgc2VsZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICBncm91cGVkOiB0cnVlXHJcbiAgICAgKiAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIGVhY2ggZGF0YSBwb2ludCB0byBkZXRlcm1pbmUgaWYgaXQncyBzZWxlY3RhYmxlIG9yIG5vdC48YnI+PGJyPlxyXG4gICAgICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSBkIGFzIGFuIGFyZ3VtZW50IGFuZCBpdCBoYXMgc29tZSBwYXJhbWV0ZXJzIGxpa2UgaWQsIHZhbHVlLCBpbmRleC4gVGhpcyBjYWxsYmFjayBzaG91bGQgcmV0dXJuIGJvb2xlYW4uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkaXNzZWxlY3RhYmxlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgc2VsZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICBpc3NlbGVjdGFibGU6IGZ1bmN0aW9uKGQpIHsgLi4uIH1cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlOiAoKSA9PiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG11bHRpcGxlIGRhdGEgcG9pbnRzIHNlbGVjdGlvbiBlbmFibGVkLjxicj48YnI+XHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgbXVsdGlsZSBkYXRhIHBvaW50cyBjYW4gaGF2ZSB0aGUgc2VsZWN0ZWQgc3RhdGUgYXQgdGhlIHNhbWUgdGltZS4gSWYgZmFsc2Ugc2V0LCBvbmx5IG9uZSBkYXRhIHBvaW50IGNhbiBoYXZlIHRoZSBzZWxlY3RlZCBzdGF0ZSBhbmQgdGhlIG90aGVycyB3aWxsIGJlIHVuc2VsZWN0ZWQgd2hlbiB0aGUgbmV3IGRhdGEgcG9pbnQgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkbXVsdGlwbGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICBzZWxlY3Rpb246IHtcclxuICAgICAqICAgICAgIG11bHRpcGxlOiBmYWxzZVxyXG4gICAgICogICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3NlbGVjdGlvbl9tdWx0aXBsZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSB0byBzZWxlY3QgZGF0YSBwb2ludHMgYnkgZHJhZ2dpbmcuXHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgZGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkIGJ5IGRyYWdnaW5nLlxyXG4gICAgICogLSAqKk5PVEU6KiogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIHNjcm9sbGluZyBvbiB0aGUgY2hhcnQgd2lsbCBiZSBkaXNhYmxlZCBiZWNhdXNlIGRyYWdnaW5nIGV2ZW50IHdpbGwgaGFuZGxlIHRoZSBldmVudC5cclxuICAgICAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRkcmFnZ2FibGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgc2VsZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGU6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG9uIGRhdGEgc2VsZWN0aW9uLlxyXG4gICAgICogQG5hbWUgZGF0YeKApG9uc2VsZWN0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgIG9uc2VsZWN0ZWQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuICAgICAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMVwifVxyXG4gICAgICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG4gICAgICogICAgICAgIC4uLlxyXG4gICAgICogICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX29uc2VsZWN0ZWQ6ICgpID0+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG9uIGRhdGEgdW4tc2VsZWN0aW9uLlxyXG4gICAgICogQG5hbWUgZGF0YeKApG9udW5zZWxlY3RlZFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAgb251bnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcbiAgICAgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTFcIn1cclxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9vbnVuc2VsZWN0ZWQ6ICgpID0+IHt9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY2xpcC1wYXRoIGF0dHJpYnV0ZSBmb3IgeCBheGlzIGVsZW1lbnRcclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkY2xpcFBhdGhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUgW0RlbW9dKClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXHJcbiAgICAgKiBjbGlwUGF0aDogZmFsc2VcclxuICAgICAqL1xyXG4gICAgYXhpc194X2NsaXBQYXRoOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHggYXhpcy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHNob3c6IGZhbHNlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3Nob3c6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdHlwZSBvZiB4IGF4aXMuPGJyPjxicj5cclxuICAgICAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogLSB0aW1lc2VyaWVzXHJcbiAgICAgKiAtIGNhdGVnb3J5XHJcbiAgICAgKiAtIGluZGV4ZWRcclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdHlwZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCBpbmRleGVkXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBpbmRleGVkXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuQXJlYUNoYXJ0KVxyXG4gICAgICogQHNlZSBbRGVtbzogdGltZXNlcmllc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlRpbWVzZXJpZXNDaGFydClcclxuICAgICAqIEBzZWUgW0RlbW86IGNhdGVnb3J5XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5DYXRlZ29yeURhdGEpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdHlwZTogXCJ0aW1lc2VyaWVzXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdHlwZTogPFwiaW5kZXhlZFwifFwidGltZXNlcmllc1wifFwiY2F0ZWdvcnlcIj4gXCJpbmRleGVkXCIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgaG93IHRvIHRyZWF0IHRoZSB0aW1lem9uZSBvZiB4IHZhbHVlcy48YnI+XHJcbiAgICAgKiBJZiB0cnVlLCB0cmVhdCB4IHZhbHVlIGFzIGxvY2FsdGltZS4gSWYgZmFsc2UsIGNvbnZlcnQgdG8gVVRDIGludGVybmFsbHkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGxvY2FsdGltZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIGxvY2FsdGltZTogZmFsc2VcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfbG9jYWx0aW1lOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNhdGVnb3J5IG5hbWVzIG9uIGNhdGVnb3J5IGF4aXMuXHJcbiAgICAgKiBUaGlzIG11c3QgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBjYXRlZ29yeSBuYW1lcyBpbiBzdHJpbmcuIElmIGNhdGVnb3J5IG5hbWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBieSBkYXRhLnggb3B0aW9uLCB0aGlzIGlzIG5vdCByZXF1aXJlZC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkY2F0ZWdvcmllc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IFtdXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgY2F0ZWdvcmllczogW1wiQ2F0ZWdvcnkgMVwiLCBcIkNhdGVnb3J5IDJcIiwgLi4uXVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9jYXRlZ29yaWVzOiA8c3RyaW5nW10+IFtdLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogY2VudGVyaXplIHRpY2tzIG9uIGNhdGVnb3J5IGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjZW50ZXJlZFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjZW50ZXJlZDogdHJ1ZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19jZW50ZXJlZDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZ1bmN0aW9uIHRvIGZvcm1hdCB0aWNrIHZhbHVlLiBGb3JtYXQgc3RyaW5nIGlzIGFsc28gYXZhaWxhYmxlIGZvciB0aW1lc2VyaWVzIGRhdGEuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRmb3JtYXRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb258U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEMydzIHRpbWUgc3BlY2lmaWVyXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS1mb3JtYXQjbG9jYWxlX2Zvcm1hdClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICAgLy8gZm9yIHRpbWVzZXJpZXMsIGEgJ2RhdGV0aW1lJyBvYmplY3QgaXMgZ2l2ZW4gYXMgcGFyYW1ldGVyXHJcbiAgICAgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xyXG4gICAgICogICAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIGZvciBjYXRlZ29yeSwgaW5kZXgoTnVtYmVyKSBhbmQgY2F0ZWdvcnlOYW1lKFN0cmluZykgYXJlIGdpdmVuIGFzIHBhcmFtZXRlclxyXG4gICAgICogICAgICAgZm9ybWF0OiBmdW5jdGlvbihpbmRleCwgY2F0ZWdvcnlOYW1lKSB7XHJcbiAgICAgKiAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5TmFtZS5zdWJzdHIoMCwgMTApO1xyXG4gICAgICogICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgLy8gZm9yIHRpbWVzZXJpZXMgZm9ybWF0IHNwZWNpZmllclxyXG4gICAgICogICAgICAgIGZvcm1hdDogXCIlWS0lbS0lZCAlSDolTTolU1wiXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX2Zvcm1hdDogPEZ1bmN0aW9ufHN0cmluZ3x1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cclxuICAgICAqIElmIHRydWUgaXMgc2V0LCB0aGUgdGlja3Mgd2lsbCBiZSBjdWxsZWQsIHRoZW4gb25seSBsaW1pdHRlZCB0aWNrIHRleHQgd2lsbCBiZSBzaG93bi4gVGhpcyBvcHRpb24gZG9lcyBub3QgaGlkZSB0aGUgdGljayBsaW5lcy4gSWYgZmFsc2UgaXMgc2V0LCBhbGwgb2YgdGlja3Mgd2lsbCBiZSBzaG93bi48YnI+PGJyPlxyXG4gICAgICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueC50aWNrLmN1bGxpbmcubWF4LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY3VsbGluZ1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHRcclxuICAgICAqIC0gdHJ1ZSBmb3IgaW5kZXhlZCBheGlzIGFuZCB0aW1lc2VyaWVzIGF4aXNcclxuICAgICAqIC0gZmFsc2UgZm9yIGNhdGVnb3J5IGF4aXNcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjdWxsaW5nOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19jdWxsaW5nOiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY3VsbGluZ+KApG1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxMFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIGN1bGxpbmc6IHtcclxuICAgICAqICAgICAgICAgICBtYXg6IDVcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfY3VsbGluZ19tYXg6IDEwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB4IGF4aXMgdGlja3MgdG8gc2hvdy48YnI+PGJyPlxyXG4gICAgICogVGhpcyBvcHRpb24gaGlkZXMgdGljayBsaW5lcyB0b2dldGhlciB3aXRoIHRpY2sgdGV4dC4gSWYgdGhpcyBvcHRpb24gaXMgdXNlZCBvbiB0aW1lc2VyaWVzIGF4aXMsIHRoZSB0aWNrcyBwb3NpdGlvbiB3aWxsIGJlIGRldGVybWluZWQgcHJlY2lzZWx5IGFuZCBub3QgbmljZWx5IHBvc2l0aW9uZWQgKGUuZy4gaXQgd2lsbCBoYXZlIHJvdWdoIHNlY29uZCB2YWx1ZSkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRjb3VudFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjb3VudDogNVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19jb3VudDogPG51bWJlcnx1bmRlZmluZWQ+dW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIGxpbmUuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHNob3c6IGZhbHNlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX3Nob3c6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgdGV4dC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRleHTigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHggQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgICAgIHg6IDEwLFxyXG4gICAgICogICAgICAgICAgIHk6IDEwXHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRml0IHggYXhpcyB0aWNrcy5cclxuICAgICAqIC0gKip0cnVlKio6IHRpY2tzIHdpbGwgYmUgcG9zaXRpb25lZCBuaWNlbHkgdG8gaGF2ZSBzYW1lIGludGVydmFscy5cclxuICAgICAqIC0gKipmYWxzZSoqOiB0aWNrcyB3aWxsIGJlIHBvc2l0aW9uZWQgYWNjb3JkaW5nIHRvIHggdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnRzLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkZml0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tGaXR0aW5nKVxyXG4gICAgICogQHNlZSBbRGVtbzogZm9yIHRpbWVzZXJpZXMgem9vbV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrVGltZXNlcmllcylcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBmaXQ6IGZhbHNlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX2ZpdDogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgeCB2YWx1ZXMgb2YgdGlja3MgbWFudWFsbHkuPGJyPjxicj5cclxuICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHByb3ZpZGVkLCB0aGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgZGV0ZXJtaW5lZCBiYXNlZCBvbiB0aG9zZSB2YWx1ZXMuPGJyPlxyXG4gICAgICogVGhpcyBvcHRpb24gd29ya3Mgd2l0aCBgdGltZXNlcmllc2AgZGF0YSBhbmQgdGhlIHggdmFsdWVzIHdpbGwgYmUgcGFyc2VkIGFjY29kaW5nIHRvIHRoZSB0eXBlIG9mIHRoZSB2YWx1ZSBhbmQgZGF0YS54Rm9ybWF0IG9wdGlvbi5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHZhbHVlc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB2YWx1ZXM6IFsxLCAyLCA0LCA4LCAxNiwgMzIsIC4uLl0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gYW4gQXJyYXkgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXHJcbiAgICAgKiAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICogICAgICAgXHRyZXR1cm4gWyAuLi4gXTtcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfdmFsdWVzOiA8KHN0cmluZ3xEYXRlfG51bWJlcilbXXwoKCk9PiBudW1iZXJbXSl8bnVsbD4gbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSB4IGF4aXMgdGljayB0ZXh0LlxyXG4gICAgICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcbiAgICAgKiAtIEFwcGxpZWQgd2hlbiBbYGF4aXMucm90YXRlZGBdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHJvdGF0ZWQpIG9wdGlvbiBpcyBgZmFsc2VgLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkcm90YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlJvdGF0ZVhBeGlzVGlja1RleHQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgcm90YXRlOiA2MFxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19yb3RhdGU6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHggYXhpcyBvdXRlciB0aWNrLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkb3V0ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBvdXRlcjogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfb3V0ZXI6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGljayB0ZXh0IHRvIGJlIG11bHRpbGluZVxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrIGFuZCAnYXhpcy54LnRpY2sud2lkdGgnIG9wdGlvbiBpcyBpZ25vcmVkLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkbXVsdGlsaW5lXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tNdWx0aWxpbmUpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgbXVsdGlsaW5lOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGV4YW1wbGUgb2YgbGluZSBicmVhayB3aXRoICdcXG4nXHJcbiAgICAgKiAvLyBJbiB0aGlzIGNhc2UsICdheGlzLngudGljay53aWR0aCcgaXMgaWdub3JlZFxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgeDogXCJ4XCIsXHJcbiAgICAgKiAgICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgICAgW1wieFwiLCBcImxvbmdcXG50ZXh0XCIsIFwiQW5vdGhlclxcbkxvbmdcXG5UZXh0XCJdLFxyXG4gICAgICogICAgICAgIC4uLlxyXG4gICAgICogICAgXSxcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfbXVsdGlsaW5lOiB0cnVlLFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aWNrIHdpZHRoXHJcbiAgICAgKiAtICoqTk9URToqKlxyXG4gICAgICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgdGhpcyBvcHRpb24gaXMgaWdub3JlZC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHdpZHRoXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB3aWR0aDogNTBcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfd2lkdGg6IDxudW1iZXJ8bnVsbD4gbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0byBkaXNwbGF5IHN5c3RlbSB0b29sdGlwKHZpYSAndGl0bGUnIGF0dHJpYnV0ZSkgZm9yIHRpY2sgdGV4dFxyXG4gICAgICogLSAqKk5PVEU6KiogT25seSBhdmFpbGFibGUgZm9yIGNhdGVnb3J5IGF4aXMgdHlwZSAoYGF4aXMueC50eXBlPSdjYXRlZ29yeSdgKVxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkdG9vbHRpcFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0b29sdGlwOiB0cnVlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX3Rvb2x0aXA6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG1heCB2YWx1ZSBvZiB4IGF4aXMgcmFuZ2UuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApG1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBtYXg6IDEwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9tYXg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbWluIHZhbHVlIG9mIHggYXhpcyByYW5nZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkbWluXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIG1pbjogLTEwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9taW46IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcGFkZGluZyBmb3IgeCBheGlzLjxicj48YnI+XHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBzZXQsIHRoZSByYW5nZSBvZiB4IGF4aXMgd2lsbCBpbmNyZWFzZS9kZWNyZWFzZSBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlcy5cclxuICAgICAqIElmIG5vIHBhZGRpbmcgaXMgbmVlZGVkIGluIHRoZSByYWdlIG9mIHggYXhpcywgMCBzaG91bGQgYmUgc2V0LlxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICAgVGhlIHBhZGRpbmcgdmFsdWVzIGFyZW4ndCBiYXNlZCBvbiBwaXhlbHMuIEl0IGRpZmZlcnMgYWNjb3JkaW5nIGF4aXMgdHlwZXM8YnI+XHJcbiAgICAgKiAgIC0gKipjYXRlZ29yeToqKiBUaGUgdW5pdCBvZiB0aWNrIHZhbHVlXHJcbiAgICAgKiAgICAgZXguIHRoZSBnaXZlbiB2YWx1ZSBgMWAsIGlzIHNhbWUgYXMgdGhlIHdpZHRoIG9mIDEgdGljayB3aWR0aFxyXG4gICAgICogICAtICoqdGltZXNlcmllczoqKiBOdW1lcmljIHRpbWUgdmFsdWVcclxuICAgICAqICAgICBleC4gdGhlIGdpdmVuIHZhbHVlIGAxMDAwKjYwKjYwKjI0YCwgd2hpY2ggaXMgbnVtZXJpYyB0aW1lIGVxdWl2YWxlbnQgb2YgYSBkYXksIGlzIHNhbWUgYXMgdGhlIHdpZHRoIG9mIDEgdGljayB3aWR0aFxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRwYWRkaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdHxOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHBhZGRpbmc6IHtcclxuICAgICAqICAgICAgIC8vIHdoZW4gYXhpcyB0eXBlIGlzICdjYXRlZ29yeSdcclxuICAgICAqICAgICAgIGxlZnQ6IDEsICAvLyBzZXQgbGVmdCBwYWRkaW5nIHdpZHRoIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgYSB0aWNrJ3Mgd2lkdGhcclxuICAgICAqICAgICAgIHJpZ2h0OiAwLjUgIC8vIHNldCByaWdodCBwYWRkaW5nIHdpZHRoIGFzIGhhbGYgb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiB0aWNrJ3Mgd2lkdGhcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAvLyB3aGVuIGF4aXMgdHlwZSBpcyAndGltZXNlcmllcydcclxuICAgICAqICAgICAgIGxlZnQ6IDEwMDAqNjAqNjAqMjQsICAvLyBzZXQgbGVmdCBwYWRkaW5nIHdpZHRoIG9mIGVxdWl2YWxlbnQgdmFsdWUgb2YgYSBkYXkgdGljaydzIHdpZHRoXHJcbiAgICAgKiAgICAgICByaWdodDogMTAwMCo2MCo2MCoxMiAgIC8vIHNldCByaWdodCBwYWRkaW5nIHdpZHRoIGFzIGhhbGYgb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcclxuICAgICAqICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cclxuICAgICAqICAgICBwYWRkaW5nOiAxMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9wYWRkaW5nOiA8bnVtYmVyfHtsZWZ0PzogbnVtYmVyOyByaWdodD86IG51bWJlcjt9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBoZWlnaHQgb2YgeCBheGlzLjxicj48YnI+XHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHggYXhpcyBjYW4gYmUgc2V0IG1hbnVhbGx5IGJ5IHRoaXMgb3B0aW9uLiBJZiB5b3UgbmVlZCBtb3JlIHNwYWNlIGZvciB4IGF4aXMsIHBsZWFzZSB1c2UgdGhpcyBvcHRpb24gZm9yIHRoYXQuIFRoZSB1bml0IGlzIHBpeGVsLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRoZWlnaHRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgaGVpZ2h0OiAyMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9oZWlnaHQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZGVmYXVsdCBleHRlbnQgZm9yIHN1YmNoYXJ0IGFuZCB6b29tLiBUaGlzIGNhbiBiZSBhbiBhcnJheSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGV4dGVudFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIC8vIGV4dGVudCByYW5nZSBhcyBhIHBpeGVsIHZhbHVlXHJcbiAgICAgKiAgICAgZXh0ZW50OiBbMCwgMjAwXSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gd2hlbiBheGlzIGlzICd0aW1lc2VyaWVzJywgcGFyc2FibGUgZGF0ZXRpbWUgc3RyaW5nXHJcbiAgICAgKiAgICAgZXh0ZW50OiBbXCIyMDE5LTAzLTAxXCIsIFwiMjAxOS0wMy0wNVwiXSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gcmV0dXJuIGV4dGVudCB2YWx1ZVxyXG4gICAgICogICAgIGV4dGVudDogZnVuY3Rpb24oZG9tYWluLCBzY2FsZSkge1xyXG4gICAgICogICAgXHQgdmFyIGV4dGVudCA9IGRvbWFpbi5tYXAoZnVuY3Rpb24odikge1xyXG4gICAgICogICAgIFx0ICAgIHJldHVybiBzY2FsZSh2KTtcclxuICAgICAqICAgICBcdCB9KTtcclxuICAgICAqXHJcbiAgICAgKiAgIFx0IC8vIGl0IHNob3VsZCByZXR1cm4gYSBmb3JtYXQgb2YgYXJyYXlcclxuICAgICAqICAgXHQgLy8gZXgpIFswLCA1ODRdXHJcbiAgICAgKiAgICAgXHQgcmV0dXJuIGV4dGVudDtcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X2V4dGVudDogPChudW1iZXJ8c3RyaW5nKVtdfEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxhYmVsIG9uIHggYXhpcy48YnI+PGJyPlxyXG4gICAgICogWW91IGNhbiBzZXQgeCBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLlxyXG4gICAgICogYHN0cmluZ2AgYW5kIGBvYmplY3RgIGNhbiBiZSBwYXNzZWQgYW5kIHdlIGNhbiBjaGFuZ2UgdGhlIHBvaXNpdG9uIGJ5IHBhc3Npbmcgb2JqZWN0IHRoYXQgaGFzIHBvc2l0aW9uIGtleS48YnI+XHJcbiAgICAgKiBBdmFpbGFibGUgcG9zaXRpb24gZGlmZmVycyBhY2NvcmRpbmcgdG8gdGhlIGF4aXMgZGlyZWN0aW9uICh2ZXJ0aWNhbCBvciBob3Jpem9udGFsKS5cclxuICAgICAqIElmIHN0cmluZyBzZXQsIHRoZSBwb3NpdGlvbiB3aWxsIGJlIHRoZSBkZWZhdWx0LlxyXG4gICAgICpcclxuICAgICAqICAtICoqSWYgaXQncyBob3Jpem9udGFsIGF4aXM6KipcclxuICAgICAqICAgIC0gaW5uZXItcmlnaHQgW2RlZmF1bHRdXHJcbiAgICAgKiAgICAtIGlubmVyLWNlbnRlclxyXG4gICAgICogICAgLSBpbm5lci1sZWZ0XHJcbiAgICAgKiAgICAtIG91dGVyLXJpZ2h0XHJcbiAgICAgKiAgICAtIG91dGVyLWNlbnRlclxyXG4gICAgICogICAgLSBvdXRlci1sZWZ0XHJcbiAgICAgKiAgLSAqKklmIGl0J3MgdmVydGljYWwgYXhpczoqKlxyXG4gICAgICogICAgLSBpbm5lci10b3AgW2RlZmF1bHRdXHJcbiAgICAgKiAgICAtIGlubmVyLW1pZGRsZVxyXG4gICAgICogICAgLSBpbm5lci1ib3R0b21cclxuICAgICAqICAgIC0gb3V0ZXItdG9wXHJcbiAgICAgKiAgICAtIG91dGVyLW1pZGRsZVxyXG4gICAgICogICAgLSBvdXRlci1ib3R0b21cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkbGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIGxhYmVsOiBcIllvdXIgWCBBeGlzXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIGxhYmVsOiB7XHJcbiAgICAgKiAgICAgICAgdGV4dDogXCJZb3VyIFggQXhpc1wiLFxyXG4gICAgICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLWNlbnRlclwiXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9sYWJlbDoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB4IEF4aXMuXHJcbiAgICAgKiAtICoqTk9URToqKiBBeGlzJyBzY2FsZSBpcyBiYXNlZCBvbiB4IEF4aXMgdmFsdWUgaWYgZG9tYWluIG9wdGlvbiBpc24ndCBzZXQuXHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBheGlzIG9iamVjdCBzaG91bGQgY29uc2lzdCB3aXRoIGZvbGxvd2luZyBvcHRpb25zOlxyXG4gICAgICpcclxuICAgICAqIHwgTmFtZSB8IFR5cGUgfCBEZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG4gICAgICogfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG4gICAgICogfCBkb21haW4gfCBBcnJheSB8IC0gfCBTZXQgdGhlIGRvbWFpbiB2YWx1ZSB8XHJcbiAgICAgKiB8IHRpY2sub3V0ZXIgfCBCb29sZWFuIHwgdHJ1ZSB8IFNob3cgb3V0ZXIgdGljayB8XHJcbiAgICAgKiB8IHRpY2suZm9ybWF0IHwgRnVuY3Rpb24gfCAtIHwgU2V0IGZvcm1hdHRlciBmb3IgdGljayB0ZXh0IHxcclxuICAgICAqIHwgdGljay5jb3VudCB8IE51bWJlciB8IC0gfCBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MgfFxyXG4gICAgICogfCB0aWNrLnZhbHVlcyB8IEFycmF5IHwgLSB8IFNldCB0aWNrIHZhbHVlcyBtYW51YWxseSB8XHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGF4ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBEb21haW5dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlc0RvbWFpbilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB4OiB7XHJcbiAgICAgKiAgICBheGVzOiBbXHJcbiAgICAgKiAgICAgIHtcclxuICAgICAqICAgICAgICAvLyBpZiBzZXQsIHdpbGwgbm90IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGUgbWFpbiB4IEF4aXMgZG9tYWluIHZhbHVlXHJcbiAgICAgKiAgICAgICAgZG9tYWluOiBbMCwgMTAwMF0sXHJcbiAgICAgKiAgICAgICAgdGljazoge1xyXG4gICAgICogICAgICAgICAgb3V0ZXI6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih4KSB7XHJcbiAgICAgKiAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIGNvdW50OiAyLFxyXG4gICAgICogICAgICAgICAgdmFsdWVzOiBbMTAsIDIwLCAzMF1cclxuICAgICAqICAgICAgICB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIC4uLlxyXG4gICAgICogICAgXVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfYXhlczogPG9iamVjdFtdPltdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHkgQXhpcyAgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNsaXAtcGF0aCBhdHRyaWJ1dGUgZm9yIHkgYXhpcyBlbGVtZW50XHJcbiAgICAgKiAtICoqTk9URSoqOiBgY2xpcC1wYXRoYCBhdHRyaWJ1dGUgZm9yIHkgQXhpcyBpcyBzZXQgb25seSB3aGVuIGBheGlzLnkuaW5uZXJgIG9wdGlvbiBpcyB0cnVlLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRjbGlwUGF0aFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuICAgICAqIGNsaXBQYXRoOiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfY2xpcFBhdGg6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG9yIGhpZGUgeSBheGlzLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0eXBlIG9mIHkgYXhpcy48YnI+PGJyPlxyXG4gICAgICogKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAgIC0gdGltZXNlcmllc1xyXG4gICAgICogICAtIGNhdGVnb3J5XHJcbiAgICAgKiAgIC0gaW5kZXhlZFxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0eXBlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHR5cGU6IFwidGltZXNlcmllc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3R5cGU6IDxcImluZGV4ZWRcInxcImNhdGVnb3J5XCJ8XCJpbmRleGVkXCJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbWF4IHZhbHVlIG9mIHkgYXhpcy5cclxuICAgICAqIC0gKipOT1RFOioqIFBhZGRpbmcgd2lsbCBiZSBhZGRlZCBiYXNlZCBvbiB0aGlzIHZhbHVlLCBzbyBpZiB5b3UgZG9uJ3QgbmVlZCB0aGUgcGFkZGluZywgcGxlYXNlIHNldCBheGlzLnkucGFkZGluZyB0byBkaXNhYmxlIGl0IChlLmcuIGF4aXMueS5wYWRkaW5nID0gMCkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApG1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICBtYXg6IDEwMDBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfbWF4OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG1pbiB2YWx1ZSBvZiB5IGF4aXMuXHJcbiAgICAgKiAtICoqTk9URToqKlxyXG4gICAgICogICBQYWRkaW5nIHdpbGwgYmUgYWRkZWQgYmFzZWQgb24gdGhpcyB2YWx1ZSwgc28gaWYgeW91IGRvbid0IG5lZWQgdGhlIHBhZGRpbmcsIHBsZWFzZSBzZXQgYXhpcy55LnBhZGRpbmcgdG8gZGlzYWJsZSBpdCAoZS5nLiBheGlzLnkucGFkZGluZyA9IDApLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRtaW5cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgbWluOiAxMDAwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X21pbjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSB0aGUgZGlyZWN0aW9uIG9mIHkgYXhpcy48YnI+PGJyPlxyXG4gICAgICogSWYgdHJ1ZSBzZXQsIHRoZSBkaXJlY3Rpb24gd2lsbCBiZSBmcm9tIHRoZSB0b3AgdG8gdGhlIGJvdHRvbS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkaW52ZXJ0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgaW52ZXJ0ZWQ6IHRydWVcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfaW52ZXJ0ZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNlbnRlciB2YWx1ZSBvZiB5IGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGNlbnRlclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICBjZW50ZXI6IDBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfY2VudGVyOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB5IGF4aXMgaW5zaWRlIG9mIHRoZSBjaGFydC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkaW5uZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgaW5uZXI6IHRydWVcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfaW5uZXI6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxhYmVsIG9uIHkgYXhpcy48YnI+PGJyPlxyXG4gICAgICogWW91IGNhbiBzZXQgeSBheGlzIGxhYmVsIGFuZCBjaGFuZ2UgaXRzIHBvc2l0aW9uIGJ5IHRoaXMgb3B0aW9uLiBUaGlzIG9wdGlvbiB3b3JrcyBpbiB0aGUgc2FtZSB3YXkgYXMgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkbGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAc2VlIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkgZm9yIHBvc2l0aW9uIHN0cmluZyB2YWx1ZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICBsYWJlbDogXCJZb3VyIFkgQXhpc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgIHRleHQ6IFwiWW91ciBZIEF4aXNcIixcclxuICAgICAqICAgICAgICBwb3NpdGlvbjogXCJvdXRlci1taWRkbGVcIlxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfbGFiZWw6IDxzdHJpbmd8b2JqZWN0PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBmb3JtYXR0ZXIgZm9yIHkgYXhpcyB0aWNrIHRleHQuPGJyPjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgZDMuZm9ybWF0IG9iamVjdCBhcyB3ZWxsIGFzIGEgZnVuY3Rpb24geW91IGRlZmluZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGZvcm1hdFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG4gICAgICogICAgICAgICAgIHJldHVybiB4LmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90aWNrX2Zvcm1hdDogPEZ1bmN0aW9ufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0dGluZyBmb3IgY3VsbGluZyB0aWNrcy48YnI+PGJyPlxyXG4gICAgICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XHJcbiAgICAgKiBXZSBjYW4gY2hhbmdlIHRoZSBudW1iZXIgb2YgdGlja3MgdG8gYmUgc2hvd24gYnkgYXhpcy55LnRpY2suY3VsbGluZy5tYXguXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRjdWxsaW5nXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIGN1bGxpbmc6IGZhbHNlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90aWNrX2N1bGxpbmc6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0aWNrIHRleHRzIHdpbGwgYmUgYWRqdXN0ZWQgdG8gbGVzcyB0aGFuIHRoaXMgdmFsdWUuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRjdWxsaW5n4oCkbWF4XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjdWxsaW5nOiB7XHJcbiAgICAgKiAgICAgICAgICAgbWF4OiA1XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90aWNrX2N1bGxpbmdfbWF4OiA1LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyB5IGF4aXMgb3V0ZXIgdGljay5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApG91dGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgb3V0ZXI6IGZhbHNlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90aWNrX291dGVyOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHkgYXhpcyB0aWNrIHZhbHVlcyBtYW51YWxseS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHZhbHVlc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB2YWx1ZXM6IFsxMDAsIDEwMDAsIDEwMDAwXSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAvLyBhbiBBcnJheSB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWRcclxuICAgICAqICAgICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgICAgICBcdHJldHVybiBbIC4uLiBdO1xyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja192YWx1ZXM6IDxudW1iZXJbXXwoKCk9PiBudW1iZXJbXSl8bnVsbD4gbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSB5IGF4aXMgdGljayB0ZXh0LlxyXG4gICAgICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcbiAgICAgKiAtIEFwcGxpZWQgd2hlbiBbYGF4aXMucm90YXRlZGBdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHJvdGF0ZWQpIG9wdGlvbiBpcyBgdHJ1ZWAuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRyb3RhdGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHJvdGF0ZTogNjBcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3RpY2tfcm90YXRlOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzLjxicj48YnI+XHJcbiAgICAgKiAtICoqTk9URToqKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgY2FsY3VsYXRlZCBwcmVjaXNlbHksIHNvIHRoZSB2YWx1ZXMgb24gdGhlIHRpY2tzIHdpbGwgbm90IGJlIHJvdW5kZWQgbmljZWx5LiBJbiB0aGUgY2FzZSwgYXhpcy55LnRpY2suZm9ybWF0IG9yIGF4aXMueS50aWNrLnZhbHVlcyB3aWxsIGJlIGhlbHBmdWwuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRjb3VudFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjb3VudDogNVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19jb3VudDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB5IGF4aXMgdGljayBsaW5lLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGF4aXMgdGljayBzdGVwKGludGVydmFsKSBzaXplLlxyXG4gICAgICogLSAqKk5PVEU6KiogV2lsbCBiZSBpZ25vcmVkIGlmIGBheGlzLnkudGljay5jb3VudGAgb3IgYGF4aXMueS50aWNrLnZhbHVlc2Agb3B0aW9ucyBhcmUgc2V0LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkc3RlcFNpemVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuU3RlcFNpemVGb3JZQXhpcylcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICAvLyB0aWNrIHZhbHVlIHdpbGwgc3RlcCBhcyBpbmRpY2F0ZWQgaW50ZXJ2YWwgdmFsdWUuXHJcbiAgICAgKiAgICAgICAvLyBleCkgJ3N0ZXBTaXplPTE1JyA9PT4gWzAsIDE1LCAzMCwgNDUsIDYwXVxyXG4gICAgICogICAgICAgc3RlcFNpemU6IDE1XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90aWNrX3N0ZXBTaXplOiA8bnVtYmVyfG51bGw+IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNob3cgb3IgaGlkZSB5IGF4aXMgdGljayB0ZXh0LlxyXG4gICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKR0ZXh04oCkc2hvd1xyXG4gICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG4gICAgKiBAZXhhbXBsZVxyXG4gICAgKiBheGlzOiB7XHJcbiAgICAqICAgeToge1xyXG4gICAgKiAgICAgdGljazoge1xyXG4gICAgKiAgICAgICB0ZXh0OiB7XHJcbiAgICAqICAgICAgICAgICBzaG93OiBmYWxzZVxyXG4gICAgKiAgICAgICB9XHJcbiAgICAqICAgICB9XHJcbiAgICAqICAgfVxyXG4gICAgKiB9XHJcbiAgICAqL1xyXG4gICAgYXhpc195X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB5IEF4aXMgdGljayB0ZXh0J3MgcG9zaXRpb24gcmVsYXRpdmVseSBpdHMgb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAqICAgICAgICAgICB4OiAxMCxcclxuICAgICAqICAgICAgICAgICB5OiAxMFxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcy48YnI+PGJyPlxyXG4gICAgICogLSAqKk5PVEU6KiogVGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGNhbGN1bGF0ZWQgcHJlY2lzZWx5LCBzbyB0aGUgdmFsdWVzIG9uIHRoZSB0aWNrcyB3aWxsIG5vdCBiZSByb3VuZGVkIG5pY2VseS4gSW4gdGhlIGNhc2UsIGF4aXMueS50aWNrLmZvcm1hdCBvciBheGlzLnkudGljay52YWx1ZXMgd2lsbCBiZSBoZWxwZnVsLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGltZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3RpbWUudmFsdWVdIEQzJ3MgdGltZSBpbnRlcnZhbCBmdW5jdGlvbiAoaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXRpbWUjaW50ZXJ2YWxzKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHRpbWU6IHtcclxuICAgICAqICAgICAgICAgIC8vIHRpY2tzIGF0IDE1LW1pbnV0ZSBpbnRlcnZhbHNcclxuICAgICAqICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zY2FsZS9ibG9iL21hc3Rlci9SRUFETUUubWQjdGltZV90aWNrc1xyXG4gICAgICogICAgICAgICAgdmFsdWU6IGQzLnRpbWVNaW51dGUuZXZlcnkoMTUpXHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIC8vIEBUT0RPOiBub3QgZnVsbHkgaW1wbGVtZW50ZWQgeWV0XHJcbiAgICBheGlzX3lfdGlja190aW1lX3ZhbHVlOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcGFkZGluZyBmb3IgeSBheGlzLjxicj48YnI+XHJcbiAgICAgKiBZb3UgY2FuIHNldCBwYWRkaW5nIGZvciB5IGF4aXMgdG8gY3JlYXRlIG1vcmUgc3BhY2Ugb24gdGhlIGVkZ2Ugb2YgdGhlIGF4aXMuXHJcbiAgICAgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIG9iamVjdCBhbmQgaXQgY2FuIGluY2x1ZGUgdG9wIGFuZCBib3R0b20uIHRvcCwgYm90dG9tIHdpbGwgYmUgdHJlYXRlZCBhcyBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogLSAqKk5PVEU6KiogRm9yIGFyZWEgYW5kIGJhciB0eXBlIGNoYXJ0cywgW2FyZWEuemVyb2Jhc2VkXSgjLmFyZWEpIG9yIFtiYXIuemVyb2Jhc2VkXSgjLmJhcikgb3B0aW9ucyBzaG91bGQgYmUgc2V0IHRvICdmYWxzZWAgdG8gZ2V0IHBhZGRlZCBib3R0b20uXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHBhZGRpbmdcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fE51bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgcGFkZGluZzoge1xyXG4gICAgICogICAgICAgdG9wOiAwLFxyXG4gICAgICogICAgICAgYm90dG9tOiAwXHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gb3Igc2V0IGJvdGggdmFsdWVzIGF0IG9uY2UuXHJcbiAgICAgKiAgICAgcGFkZGluZzogMTBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfcGFkZGluZzogPG51bWJlcnx7dG9wPzogbnVtYmVyOyBib3R0b20/OiBudW1iZXI7fT4ge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZGVmYXVsdCByYW5nZSBvZiB5IGF4aXMuPGJyPjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeSBheGlzIHdoZW4gdGhlcmUgaXMgbm8gZGF0YSBvbiBpbml0LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRkZWZhdWx0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X2RlZmF1bHQ6IDxudW1iZXJbXXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhZGRpdGlvbmFsIGF4ZXMgZm9yIHkgQXhpcy5cclxuICAgICAqIC0gKipOT1RFOioqIEF4aXMnIHNjYWxlIGlzIGJhc2VkIG9uIHkgQXhpcyB2YWx1ZSBpZiBkb21haW4gb3B0aW9uIGlzbid0IHNldC5cclxuICAgICAqXHJcbiAgICAgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcbiAgICAgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcbiAgICAgKiB8IGRvbWFpbiB8IEFycmF5IHwgLSB8IFNldCB0aGUgZG9tYWluIHZhbHVlIHxcclxuICAgICAqIHwgdGljay5vdXRlciB8IEJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcclxuICAgICAqIHwgdGljay5mb3JtYXQgfCBGdW5jdGlvbiB8IC0gfCBTZXQgZm9ybWF0dGVyIGZvciB0aWNrIHRleHQgfFxyXG4gICAgICogfCB0aWNrLmNvdW50IHwgTnVtYmVyIHwgLSB8IFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcyB8XHJcbiAgICAgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkYXhlc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlcylcclxuICAgICAqIEBzZWUgW0RlbW86IERvbWFpbl0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzRG9tYWluKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIHk6IHtcclxuICAgICAqICAgIGF4ZXM6IFtcclxuICAgICAqICAgICAge1xyXG4gICAgICogICAgICAgIC8vIGlmIHNldCwgd2lsbCBub3QgYmUgY29ycmVsYXRlZCB3aXRoIHRoZSBtYWluIHkgQXhpcyBkb21haW4gdmFsdWVcclxuICAgICAqICAgICAgICBkb21haW46IFswLCAxMDAwXSxcclxuICAgICAqICAgICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXHJcbiAgICAgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgY291bnQ6IDIsXHJcbiAgICAgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxyXG4gICAgICogICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgLi4uXHJcbiAgICAgKiAgICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV9heGVzOiA8b2JqZWN0W10+IFtdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHkyIEF4aXMgIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB5MiBheGlzLlxyXG4gICAgICogLSAqKk5PVEUqKjpcclxuICAgICAqICAgLSBXaGVuIHNldCB0byBgZmFsc2VgIHdpbGwgbm90IGdlbmVyYXRlIHkyIGF4aXMgbm9kZS4gSW4gdGhpcyBjYXNlLCBhbGwgJ3kyJyBheGlzIHJlbGF0ZWQgZnVuY3Rpb25hbGl0eSB3b24ndCB3b3JrIHByb3Blcmx5LlxyXG4gICAgICogICAtIElmIG5lZWQgdG8gdXNlICd5MicgcmVsYXRlZCBvcHRpb25zIHdoaWxlIHkyIGlzbid0IHZpc2libGUsIHNldCB0aGUgdmFsdWUgYHRydWVgIGFuZCBjb250cm9sIHZpc2liaWxpdHkgYnkgY3NzIGRpc3BsYXkgcHJvcGVydHkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICBzaG93OiB0cnVlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9zaG93OiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtYXggdmFsdWUgb2YgeTIgYXhpcy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApG1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgbWF4OiAxMDAwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9tYXg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbWluIHZhbHVlIG9mIHkyIGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRtaW5cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIG1pbjogLTEwMDBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX21pbjogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSB0aGUgZGlyZWN0aW9uIG9mIHkyIGF4aXMuPGJyPjxicj5cclxuICAgICAqIElmIHRydWUgc2V0LCB0aGUgZGlyZWN0aW9uIHdpbGwgYmUgZnJvbSB0aGUgdG9wIHRvIHRoZSBib3R0b20uXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRpbnZlcnRlZFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgaW52ZXJ0ZWQ6IHRydWVcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX2ludmVydGVkOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjZW50ZXIgdmFsdWUgb2YgeTIgYXhpcy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGNlbnRlclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgY2VudGVyOiAwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9jZW50ZXI6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHkyIGF4aXMgaW5zaWRlIG9mIHRoZSBjaGFydC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGlubmVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICBpbm5lcjogdHJ1ZVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfaW5uZXI6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxhYmVsIG9uIHkyIGF4aXMuPGJyPjxicj5cclxuICAgICAqIFlvdSBjYW4gc2V0IHkyIGF4aXMgbGFiZWwgYW5kIGNoYW5nZSBpdHMgcG9zaXRpb24gYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkbGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAc2VlIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkgZm9yIHBvc2l0aW9uIHN0cmluZyB2YWx1ZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgbGFiZWw6IFwiWW91ciBZMiBBeGlzXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgIHRleHQ6IFwiWW91ciBZMiBBeGlzXCIsXHJcbiAgICAgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9sYWJlbDogPHN0cmluZ3xvYmplY3Q+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGZvcm1hdHRlciBmb3IgeTIgYXhpcyB0aWNrIHRleHQuPGJyPjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBheGlzLnkuZm9ybWF0LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGZvcm1hdFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBmb3JtYXQ6IGQzLmZvcm1hdChcIiQsXCIpXHJcbiAgICAgKiAgICAgICAvL29yIGZvcm1hdDogZnVuY3Rpb24oZCkgeyByZXR1cm4gXCIkXCIgKyBkOyB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfdGlja19mb3JtYXQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cclxuICAgICAqIElmIHRydWUgaXMgc2V0LCB0aGUgdGlja3Mgd2lsbCBiZSBjdWxsZWQsIHRoZW4gb25seSBsaW1pdHRlZCB0aWNrIHRleHQgd2lsbCBiZSBzaG93bi4gVGhpcyBvcHRpb24gZG9lcyBub3QgaGlkZSB0aGUgdGljayBsaW5lcy4gSWYgZmFsc2UgaXMgc2V0LCBhbGwgb2YgdGlja3Mgd2lsbCBiZSBzaG93bi48YnI+PGJyPlxyXG4gICAgICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueS50aWNrLmN1bGxpbmcubWF4LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGN1bGxpbmdcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIGN1bGxpbmc6IGZhbHNlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfdGlja19jdWxsaW5nOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGN1bGxpbmfigKRtYXhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgNVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjdWxsaW5nOiB7XHJcbiAgICAgKiAgICAgICAgICAgbWF4OiA1XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfdGlja19jdWxsaW5nX21heDogNSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB5MiBheGlzIG91dGVyIHRpY2suXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkb3V0ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgb3V0ZXI6IGZhbHNlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfdGlja19vdXRlcjogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB5MiBheGlzIHRpY2sgdmFsdWVzIG1hbnVhbGx5LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHZhbHVlc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheXxGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdmFsdWVzOiBbMTAwLCAxMDAwLCAxMDAwMF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gYW4gQXJyYXkgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXHJcbiAgICAgKiAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICogICAgICAgXHRyZXR1cm4gWyAuLi4gXTtcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX3ZhbHVlczogPG51bWJlcltdfCgoKT0+IG51bWJlcltdKXxudWxsPiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIHkyIGF4aXMgdGljayB0ZXh0LlxyXG4gICAgICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcbiAgICAgKiAtIEFwcGxpZWQgd2hlbiBbYGF4aXMucm90YXRlZGBdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHJvdGF0ZWQpIG9wdGlvbiBpcyBgdHJ1ZWAuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkcm90YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgcm90YXRlOiA2MFxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfcm90YXRlOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgeTIgYXhpcyB0aWNrcy5cclxuICAgICAqIC0gKipOT1RFOioqIFRoaXMgd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS50aWNrLmNvdW50LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGNvdW50XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjb3VudDogNVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfY291bnQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG9yIGhpZGUgeTIgYXhpcyB0aWNrIGxpbmUuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX3Nob3c6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYXhpcyB0aWNrIHN0ZXAoaW50ZXJ2YWwpIHNpemUuXHJcbiAgICAgKiAtICoqTk9URToqKiBXaWxsIGJlIGlnbm9yZWQgaWYgYGF4aXMueTIudGljay5jb3VudGAgb3IgYGF4aXMueTIudGljay52YWx1ZXNgIG9wdGlvbnMgYXJlIHNldC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRzdGVwU2l6ZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5TdGVwU2l6ZUZvcllBeGlzKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICAvLyB0aWNrIHZhbHVlIHdpbGwgc3RlcCBhcyBpbmRpY2F0ZWQgaW50ZXJ2YWwgdmFsdWUuXHJcbiAgICAgKiAgICAgICAvLyBleCkgJ3N0ZXBTaXplPTE1JyA9PT4gWzAsIDE1LCAzMCwgNDUsIDYwXVxyXG4gICAgICogICAgICAgc3RlcFNpemU6IDE1XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfdGlja19zdGVwU2l6ZTogPG51bWJlcnxudWxsPiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHkyIGF4aXMgdGljayB0ZXh0LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX3RleHRfc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgeTIgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICAgeDogMTAsXHJcbiAgICAgKiAgICAgICAgICAgeTogMTBcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgeTIgYXhpcyB0aWNrcy5cclxuICAgICAqIC0gKipOT1RFOioqIFRoaXMgd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS50aWNrLmNvdW50LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkcGFkZGluZ1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R8TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgcGFkZGluZzoge1xyXG4gICAgICogICAgICAgdG9wOiAxMDAsXHJcbiAgICAgKiAgICAgICBib3R0b206IDEwMFxyXG4gICAgICogICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gb3Igc2V0IGJvdGggdmFsdWVzIGF0IG9uY2UuXHJcbiAgICAgKiAgICAgcGFkZGluZzogMTBcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9wYWRkaW5nOiA8bnVtYmVyfHt0b3A/OiBudW1iZXI7IGJvdHRvbT86IG51bWJlcjt9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBkZWZhdWx0IHJhbmdlIG9mIHkyIGF4aXMuPGJyPjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeTIgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGRlZmF1bHRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9kZWZhdWx0OiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5MiBBeGlzLlxyXG4gICAgICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geTIgQXhpcyB2YWx1ZSBpZiBkb21haW4gb3B0aW9uIGlzbid0IHNldC5cclxuICAgICAqXHJcbiAgICAgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcbiAgICAgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcbiAgICAgKiB8IGRvbWFpbiB8IEFycmF5IHwgLSB8IFNldCB0aGUgZG9tYWluIHZhbHVlIHxcclxuICAgICAqIHwgdGljay5vdXRlciB8IEJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcclxuICAgICAqIHwgdGljay5mb3JtYXQgfCBGdW5jdGlvbiB8IC0gfCBTZXQgZm9ybWF0dGVyIGZvciB0aWNrIHRleHQgfFxyXG4gICAgICogfCB0aWNrLmNvdW50IHwgTnVtYmVyIHwgLSB8IFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcyB8XHJcbiAgICAgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGF4ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBEb21haW5dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlc0RvbWFpbilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB5Mjoge1xyXG4gICAgICogICAgYXhlczogW1xyXG4gICAgICogICAgICB7XHJcbiAgICAgKiAgICAgICAgLy8gaWYgc2V0LCB3aWxsIG5vdCBiZSBjb3JyZWxhdGVkIHdpdGggdGhlIG1haW4geTIgQXhpcyBkb21haW4gdmFsdWVcclxuICAgICAqICAgICAgICBkb21haW46IFswLCAxMDAwXSxcclxuICAgICAqICAgICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXHJcbiAgICAgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgY291bnQ6IDIsXHJcbiAgICAgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxyXG4gICAgICogICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgLi4uXHJcbiAgICAgKiAgICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfYXhlczogW11cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogV2luZG93IG9iamVjdFxyXG4gKiBAbW9kdWxlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLW5ldy1mdW5jLCBuby11bmRlZiAqL1xyXG5leHBvcnQge3dpbiBhcyB3aW5kb3csIGRvYyBhcyBkb2N1bWVudH07XHJcblxyXG5jb25zdCB3aW4gPSAoKCkgPT4ge1xyXG5cdGNvbnN0IGRlZiA9IG8gPT4gdHlwZW9mIG8gIT09IFwidW5kZWZpbmVkXCIgJiYgbztcclxuXHJcblx0cmV0dXJuIGRlZihzZWxmKSB8fCBkZWYod2luZG93KSB8fCBkZWYoZ2xvYmFsKSB8fCBkZWYoZ2xvYmFsVGhpcykgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xyXG59KSgpO1xyXG4vKiBlc2xpbnQtZW5hYmxlIG5vLW5ldy1mdW5jLCBuby11bmRlZiAqL1xyXG5cclxuY29uc3QgZG9jID0gd2luICYmIHdpbi5kb2N1bWVudDtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7ZXZlbnQgYXMgZDNFdmVudH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2JydXNoU2VsZWN0aW9uIGFzIGQzQnJ1c2hTZWxlY3Rpb259IGZyb20gXCJkMy1icnVzaFwiO1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwidHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCB7XHJcblx0YXNIYWxmUGl4ZWwsXHJcblx0YnJ1c2hFbXB0eSxcclxuXHRjYWxsRm4sXHJcblx0Y2FwaXRhbGl6ZSxcclxuXHRjZWlsMTAsXHJcblx0ZGlmZkRvbWFpbixcclxuXHRlbXVsYXRlRXZlbnQsXHJcblx0ZXh0ZW5kLFxyXG5cdGdldEJydXNoU2VsZWN0aW9uLFxyXG5cdGdldEJvdW5kaW5nUmVjdCxcclxuXHRnZXRDc3NSdWxlcyxcclxuXHRnZXRNaW5NYXgsXHJcblx0Z2V0T3B0aW9uLFxyXG5cdGdldFBhdGhCb3gsXHJcblx0Z2V0UmFuZG9tLFxyXG5cdGdldFJhbmdlLFxyXG5cdGdldFJlY3RTZWdMaXN0LFxyXG5cdGdldFRyYW5zbGF0aW9uLFxyXG5cdGdldFVuaXF1ZSxcclxuXHRoYXNWYWx1ZSxcclxuXHRpc0FycmF5LFxyXG5cdGlzQm9vbGVhbixcclxuXHRpc0RlZmluZWQsXHJcblx0aXNFbXB0eSxcclxuXHRpc0Z1bmN0aW9uLFxyXG5cdGlzTnVtYmVyLFxyXG5cdGlzT2JqZWN0LFxyXG5cdGlzT2JqZWN0VHlwZSxcclxuXHRpc1N0cmluZyxcclxuXHRpc1VuZGVmaW5lZCxcclxuXHRpc1ZhbHVlLFxyXG5cdG1lcmdlQXJyYXksXHJcblx0bWVyZ2VPYmosXHJcblx0bm90RW1wdHksXHJcblx0c2FuaXRpc2UsXHJcblx0c2V0VGV4dFZhbHVlLFxyXG5cdHNvcnRWYWx1ZSxcclxuXHR0b0FycmF5LFxyXG5cdHRwbFByb2Nlc3NcclxufTtcclxuXHJcbmNvbnN0IGlzVmFsdWUgPSAodjogYW55KTogYm9vbGVhbiA9PiB2IHx8IHYgPT09IDA7XHJcbmNvbnN0IGlzRnVuY3Rpb24gPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiO1xyXG5jb25zdCBpc1N0cmluZyA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiO1xyXG5jb25zdCBpc051bWJlciA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiO1xyXG5jb25zdCBpc1VuZGVmaW5lZCA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiO1xyXG5jb25zdCBpc0RlZmluZWQgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiAhPT0gXCJ1bmRlZmluZWRcIjtcclxuY29uc3QgaXNCb29sZWFuID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiO1xyXG5jb25zdCBjZWlsMTAgPSAodjogYW55KTogbnVtYmVyID0+IE1hdGguY2VpbCh2IC8gMTApICogMTA7XHJcbmNvbnN0IGFzSGFsZlBpeGVsID0gKG46IGFueSk6IG51bWJlciA9PiBNYXRoLmNlaWwobikgKyAwLjU7XHJcbmNvbnN0IGRpZmZEb21haW4gPSAoZDogbnVtYmVyW10pOiBudW1iZXIgPT4gZFsxXSAtIGRbMF07XHJcbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcIm9iamVjdFwiO1xyXG5jb25zdCBpc0VtcHR5ID0gKG86IGFueSk6IGJvb2xlYW4gPT4gKFxyXG5cdGlzVW5kZWZpbmVkKG8pIHx8IG8gPT09IG51bGwgfHxcclxuXHQoaXNTdHJpbmcobykgJiYgby5sZW5ndGggPT09IDApIHx8XHJcblx0KGlzT2JqZWN0VHlwZShvKSAmJiAhKG8gaW5zdGFuY2VvZiBEYXRlKSAmJiBPYmplY3Qua2V5cyhvKS5sZW5ndGggPT09IDApIHx8XHJcblx0KGlzTnVtYmVyKG8pICYmIGlzTmFOKG8pKVxyXG4pO1xyXG5jb25zdCBub3RFbXB0eSA9IChvOiBhbnkpOiBib29sZWFuID0+ICFpc0VtcHR5KG8pO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIGlzIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGlzQXJyYXkgPSAoYXJyOiBhbnkpOiBib29sZWFuID0+IEFycmF5LmlzQXJyYXkoYXJyKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBpcyBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGlzT2JqZWN0ID0gKG9iajogYW55KTogYm9vbGVhbiA9PiBvYmogJiYgIW9iai5ub2RlVHlwZSAmJiBpc09iamVjdFR5cGUob2JqKSAmJiAhaXNBcnJheShvYmopO1xyXG5cclxuZnVuY3Rpb24gZ2V0T3B0aW9uKG9wdGlvbnM6IG9iamVjdCwga2V5OiBzdHJpbmcsIGRlZmF1bHRWYWx1ZSk6IGFueSB7XHJcblx0cmV0dXJuIGlzRGVmaW5lZChvcHRpb25zW2tleV0pID8gb3B0aW9uc1trZXldIDogZGVmYXVsdFZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBoYXNWYWx1ZShkaWN0OiBvYmplY3QsIHZhbHVlOiBhbnkpOiBib29sZWFuIHtcclxuXHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0T2JqZWN0LmtleXMoZGljdCkuZm9yRWFjaChrZXkgPT4gKGRpY3Rba2V5XSA9PT0gdmFsdWUpICYmIChmb3VuZCA9IHRydWUpKTtcclxuXHJcblx0cmV0dXJuIGZvdW5kO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsbCBmdW5jdGlvbiB3aXRoIGFyZ3VtZW50c1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcclxuICogQHBhcmFtIHsqfSBhcmdzIEFyZ3VtZW50c1xyXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlOiBmbiBpcyBmdW5jdGlvbiwgZmFsc2U6IGZuIGlzIG5vdCBmdW5jdGlvblxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2FsbEZuKGZuLCAuLi5hcmdzKTogYm9vbGVhbiB7XHJcblx0Y29uc3QgaXNGbiA9IGlzRnVuY3Rpb24oZm4pO1xyXG5cclxuXHRpc0ZuICYmIGZuLmNhbGwoLi4uYXJncyk7XHJcblx0cmV0dXJuIGlzRm47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXBsYWNlIHRhZyBzaWduIHRvIGh0bWwgZW50aXR5XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2FuaXRpc2Uoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xyXG5cdHJldHVybiBpc1N0cmluZyhzdHIpID9cclxuXHRcdHN0ci5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC8+L2csIFwiJmd0O1wiKSA6IHN0cjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0ZXh0IHZhbHVlLiBJZiB0aGVyZSdzIG11bHRpbGluZSBhZGQgbm9kZXMuXHJcbiAqIEBwYXJhbSB7ZDNTZWxlY3Rpb259IG5vZGUgVGV4dCBub2RlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IFRleHQgdmFsdWUgc3RyaW5nXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGR5IGR5IHZhbHVlIGZvciBtdWx0aWxpbmVkIHRleHRcclxuICogQHBhcmFtIHtCb29sZWFufSB0b01pZGRsZSBUbyBiZSBhbGluZ25lZCB2ZXJ0aWNhbGx5IG1pZGRsZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0VGV4dFZhbHVlKG5vZGU6IGQzU2VsZWN0aW9uLCB0ZXh0OiBzdHJpbmcsIGR5OiBudW1iZXJbXSA9IFstMSwgMV0sIHRvTWlkZGxlOiBib29sZWFuID0gZmFsc2UpIHtcclxuXHRpZiAoIW5vZGUgfHwgIWlzU3RyaW5nKHRleHQpKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHRpZiAodGV4dC5pbmRleE9mKFwiXFxuXCIpID09PSAtMSkge1xyXG5cdFx0bm9kZS50ZXh0KHRleHQpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRjb25zdCBkaWZmID0gW25vZGUudGV4dCgpLCB0ZXh0XS5tYXAodiA9PiB2LnJlcGxhY2UoL1tcXHNcXG5dL2csIFwiXCIpKTtcclxuXHJcblx0XHRpZiAoZGlmZlswXSAhPT0gZGlmZlsxXSkge1xyXG5cdFx0XHRjb25zdCBtdWx0aWxpbmUgPSB0ZXh0LnNwbGl0KFwiXFxuXCIpO1xyXG5cdFx0XHRjb25zdCBsZW4gPSB0b01pZGRsZSA/IG11bHRpbGluZS5sZW5ndGggLSAxIDogMTtcclxuXHJcblx0XHRcdC8vIHJlc2V0IHBvc3NpYmxlIHRleHRcclxuXHRcdFx0bm9kZS5odG1sKFwiXCIpO1xyXG5cclxuXHRcdFx0bXVsdGlsaW5lLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRub2RlLmFwcGVuZChcInRzcGFuXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgMClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgYCR7aSA9PT0gMCA/IGR5WzBdICogbGVuIDogZHlbMV19ZW1gKVxyXG5cdFx0XHRcdFx0LnRleHQodik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuLy8gc3Vic3RpdHV0aW9uIG9mIFNWR1BhdGhTZWcgQVBJIHBvbHlmaWxsXHJcbmZ1bmN0aW9uIGdldFJlY3RTZWdMaXN0KHBhdGg6IFNWR0dyYXBoaWNzRWxlbWVudCk6IHt4OiBudW1iZXIsIHk6IG51bWJlcn1bXSB7XHJcblx0LypcclxuXHQgKiBzZWcxIC0tLS0tLS0tLS0gc2VnMlxyXG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcclxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XHJcblx0ICogICB8ICAgICAgICAgICAgICAgfFxyXG5cdCAqIHNlZzAgLS0tLS0tLS0tLSBzZWczXHJcblx0ICogKi9cclxuXHRjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSBwYXRoLmdldEJCb3goKTtcclxuXHJcblx0cmV0dXJuIFtcclxuXHRcdHt4LCB5OiB5ICsgaGVpZ2h0fSwgLy8gc2VnMFxyXG5cdFx0e3gsIHl9LCAvLyBzZWcxXHJcblx0XHR7eDogeCArIHdpZHRoLCB5fSwgLy8gc2VnMlxyXG5cdFx0e3g6IHggKyB3aWR0aCwgeTogeSArIGhlaWdodH0gLy8gc2VnM1xyXG5cdF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFBhdGhCb3gocGF0aDogU1ZHR3JhcGhpY3NFbGVtZW50KToge3g6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcn0ge1xyXG5cdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0Y29uc3QgaXRlbXMgPSBnZXRSZWN0U2VnTGlzdChwYXRoKTtcclxuXHRjb25zdCB4ID0gaXRlbXNbMF0ueDtcclxuXHRjb25zdCB5ID0gTWF0aC5taW4oaXRlbXNbMF0ueSwgaXRlbXNbMV0ueSk7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4LCB5LCB3aWR0aCwgaGVpZ2h0XHJcblx0fTtcclxufVxyXG5cclxuLy8gcmV0dXJuIGJydXNoIHNlbGVjdGlvbiBhcnJheVxyXG5mdW5jdGlvbiBnZXRCcnVzaFNlbGVjdGlvbih7JGVsfSkge1xyXG5cdGNvbnN0IGV2ZW50ID0gZDNFdmVudDtcclxuXHRjb25zdCBtYWluID0gJGVsLmNvbnRleHQgfHwgJGVsLm1haW47XHJcblx0bGV0IHNlbGVjdGlvbjtcclxuXHJcblx0Ly8gY2hlY2sgZnJvbSBldmVudFxyXG5cdGlmIChldmVudCAmJiBldmVudC50eXBlID09PSBcImJydXNoXCIpIHtcclxuXHRcdHNlbGVjdGlvbiA9IGV2ZW50LnNlbGVjdGlvbjtcclxuXHQvLyBjaGVjayBmcm9tIGJydXNoIGFyZWEgc2VsZWN0aW9uXHJcblx0fSBlbHNlIGlmIChtYWluICYmIChzZWxlY3Rpb24gPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9YCkubm9kZSgpKSkge1xyXG5cdFx0c2VsZWN0aW9uID0gZDNCcnVzaFNlbGVjdGlvbihzZWxlY3Rpb24pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHNlbGVjdGlvbjtcclxufVxyXG5cclxuLy8gR2V0IGJvdW5kaW5nQ2xpZW50UmVjdC4gY2FjaGUgdGhlIGV2YWx1YXRlZCB2YWx1ZSBvbmNlIGl0IHdhcyBjYWxsZWQuXHJcbmNvbnN0IGdldEJvdW5kaW5nUmVjdCA9IG5vZGUgPT4gbm9kZS5yZWN0IHx8IChub2RlLnJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcclxuXHJcbi8vIHJldHJ1biByYW5kb20gbnVtYmVyXHJcbmZ1bmN0aW9uIGdldFJhbmRvbShhc1N0cjogYm9vbGVhbiA9IHRydWUpOiBudW1iZXIgfCBzdHJpbmcge1xyXG5cdGNvbnN0IHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xyXG5cclxuXHRyZXR1cm4gYXNTdHIgPyBTdHJpbmcocmFuZCkgOiByYW5kO1xyXG59XHJcblxyXG5mdW5jdGlvbiBicnVzaEVtcHR5KGN0eCkge1xyXG5cdGNvbnN0IHNlbGVjdGlvbiA9IGdldEJydXNoU2VsZWN0aW9uKGN0eCk7XHJcblxyXG5cdGlmIChzZWxlY3Rpb24pIHtcclxuXHRcdC8vIGJydXNoIHNlbGVjdGVkIGFyZWFcclxuXHRcdC8vIHR3by1kaW1lbnNpb25hbDogW1t4MCwgeTBdLCBbeDEsIHkxXV1cclxuXHRcdC8vIG9uZS1kaW1lbnNpb25hbDogW3gwLCB4MV0gb3IgW3kwLCB5MV1cclxuXHRcdHJldHVybiBzZWxlY3Rpb25bMF0gPT09IHNlbGVjdGlvblsxXTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0cnVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0ID0ge30sIHNvdXJjZSk6IG9iamVjdCB7XHJcblx0aWYgKGlzQXJyYXkoc291cmNlKSkge1xyXG5cdFx0c291cmNlLmZvckVhY2godiA9PiBleHRlbmQodGFyZ2V0LCB2KSk7XHJcblx0fVxyXG5cclxuXHQvLyBleGNsdWRlIG5hbWUgd2l0aCBvbmx5IG51bWJlcnNcclxuXHRmb3IgKGNvbnN0IHAgaW4gc291cmNlKSB7XHJcblx0XHRpZiAoL15cXGQrJC8udGVzdChwKSkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0YXJnZXRbcF0gPSBzb3VyY2VbcF07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJuIGZpcnN0IGxldHRlciBjYXBpdGFsaXplZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge1N0cmluZ30gY2FwaXRhbGl6ZWQgc3RyaW5nXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBjYXBpdGFsaXplID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHRvIGFycmF5XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB2XHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IHRvQXJyYXkgPSAodjogQ1NTU3R5bGVEZWNsYXJhdGlvbiB8IGFueSk6IGFueSA9PiBbXS5zbGljZS5jYWxsKHYpO1xyXG5cclxuLyoqXHJcbiAqIEdldCBjc3MgcnVsZXMgZm9yIHNwZWNpZmllZCBzdHlsZXNoZWV0c1xyXG4gKiBAcGFyYW0ge0FycmF5fSBzdHlsZVNoZWV0cyBUaGUgc3R5bGVzaGVldHMgdG8gZ2V0IHRoZSBydWxlcyBmcm9tXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldENzc1J1bGVzKHN0eWxlU2hlZXRzOiBhbnlbXSkge1xyXG5cdGxldCBydWxlcyA9IFtdO1xyXG5cclxuXHRzdHlsZVNoZWV0cy5mb3JFYWNoKHNoZWV0ID0+IHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGlmIChzaGVldC5jc3NSdWxlcyAmJiBzaGVldC5jc3NSdWxlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRydWxlcyA9IHJ1bGVzLmNvbmNhdCh0b0FycmF5KHNoZWV0LmNzc1J1bGVzKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0Y29uc29sZS5lcnJvcihgRXJyb3Igd2hpbGUgcmVhZGluZyBydWxlcyBmcm9tICR7c2hlZXQuaHJlZn06ICR7ZS50b1N0cmluZygpfWApO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHRyZXR1cm4gcnVsZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBTVkdNYXRyaXggb2YgYW4gU1ZHRWxlbWVudFxyXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnRcclxuICogQHJldHVybiB7U1ZHTWF0cml4fSBtYXRyaXhcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG5vZGUpIHtcclxuXHRjb25zdCB0cmFuc2Zvcm0gPSBub2RlID8gbm9kZS50cmFuc2Zvcm0gOiBudWxsO1xyXG5cdGNvbnN0IGJhc2VWYWwgPSB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0uYmFzZVZhbCA6IFtdO1xyXG5cclxuXHRyZXR1cm4gYmFzZVZhbC5sZW5ndGggPyBiYXNlVmFsLmdldEl0ZW0oMCkubWF0cml4IDoge2E6IDAsIGI6IDAsIGM6IDAsIGQ6IDAsIGU6IDAsIGY6IDB9O1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHVuaXF1ZSB2YWx1ZSBmcm9tIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGFcclxuICogQHJldHVybiB7QXJyYXl9IFVuaXF1ZSBhcnJheSB2YWx1ZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VW5pcXVlKGRhdGE6IGFueVtdKTogYW55W10ge1xyXG5cdGNvbnN0IGlzRGF0ZSA9IGRhdGFbMF0gaW5zdGFuY2VvZiBEYXRlO1xyXG5cdGNvbnN0IGQgPSAoaXNEYXRlID8gZGF0YS5tYXAoTnVtYmVyKSA6IGRhdGEpXHJcblx0XHQuZmlsdGVyKCh2LCBpLCBzZWxmKSA9PiBzZWxmLmluZGV4T2YodikgPT09IGkpO1xyXG5cclxuXHRyZXR1cm4gaXNEYXRlID8gZC5tYXAodiA9PiBuZXcgRGF0ZSh2KSkgOiBkO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2UgYXJyYXlcclxuICogQHBhcmFtIHtBcnJheX0gYXJyXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VBcnJheShhcnI6IGFueVtdKTogYW55W10ge1xyXG5cdHJldHVybiBhcnIgJiYgYXJyLmxlbmd0aCA/IGFyci5yZWR1Y2UoKHAsIGMpID0+IHAuY29uY2F0KGMpKSA6IFtdO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2Ugb2JqZWN0IHJldHVybmluZyBuZXcgb2JqZWN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdE5cclxuICogQHJldHVybnMge09iamVjdH0gbWVyZ2VkIHRhcmdldCBvYmplY3RcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlT2JqKHRhcmdldDogb2JqZWN0LCAuLi5vYmplY3ROKTogYW55IHtcclxuXHRpZiAoIW9iamVjdE4ubGVuZ3RoIHx8IChvYmplY3ROLmxlbmd0aCA9PT0gMSAmJiAhb2JqZWN0TlswXSkpIHtcclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fVxyXG5cclxuXHRjb25zdCBzb3VyY2UgPSBvYmplY3ROLnNoaWZ0KCk7XHJcblxyXG5cdGlmIChpc09iamVjdCh0YXJnZXQpICYmIGlzT2JqZWN0KHNvdXJjZSkpIHtcclxuXHRcdE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xyXG5cclxuXHRcdFx0aWYgKGlzT2JqZWN0KHZhbHVlKSkge1xyXG5cdFx0XHRcdCF0YXJnZXRba2V5XSAmJiAodGFyZ2V0W2tleV0gPSB7fSk7XHJcblx0XHRcdFx0dGFyZ2V0W2tleV0gPSBtZXJnZU9iaih0YXJnZXRba2V5XSwgdmFsdWUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRhcmdldFtrZXldID0gaXNBcnJheSh2YWx1ZSkgP1xyXG5cdFx0XHRcdFx0dmFsdWUuY29uY2F0KCkgOiB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbWVyZ2VPYmoodGFyZ2V0LCAuLi5vYmplY3ROKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNvcnQgdmFsdWVcclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSB2YWx1ZSB0byBiZSBzb3J0ZWRcclxuICogQHBhcmFtIHtCb29sZWFufSBpc0FzYyB0cnVlOiBhc2MsIGZhbHNlOiBkZXNjXHJcbiAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd8RGF0ZX0gc29ydGVkIGRhdGVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNvcnRWYWx1ZShkYXRhOiBhbnlbXSwgaXNBc2MgPSB0cnVlKTogYW55W10ge1xyXG5cdGxldCBmbjtcclxuXHJcblx0aWYgKGRhdGFbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRmbiA9IGlzQXNjID8gKGEsIGIpID0+IGEgLSBiIDogKGEsIGIpID0+IGIgLSBhO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRpZiAoaXNBc2MgJiYgIWRhdGEuZXZlcnkoaXNOYU4pKSB7XHJcblx0XHRcdGZuID0gKGEsIGIpID0+IGEgLSBiO1xyXG5cdFx0fSBlbHNlIGlmICghaXNBc2MpIHtcclxuXHRcdFx0Zm4gPSAoYSwgYikgPT4gKGEgPiBiICYmIC0xKSB8fCAoYSA8IGIgJiYgMSkgfHwgKGEgPT09IGIgJiYgMCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGF0YS5jb25jYXQoKS5zb3J0KGZuKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBtaW4vbWF4IHZhbHVlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlICdtaW4nIG9yICdtYXgnXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgQXJyYXkgZGF0YSB2YWx1ZVxyXG4gKiBAcmV0dW4ge051bWJlcnxEYXRlfHVuZGVmaW5lZH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldE1pbk1heCh0eXBlOiBcIm1pblwiIHwgXCJtYXhcIiwgZGF0YTogbnVtYmVyW10gfCBEYXRlW10gfCBhbnkpIHtcclxuXHRsZXQgcmVzID0gZGF0YS5maWx0ZXIodiA9PiBub3RFbXB0eSh2KSk7XHJcblxyXG5cdGlmIChyZXMubGVuZ3RoKSB7XHJcblx0XHRpZiAoaXNOdW1iZXIocmVzWzBdKSkge1xyXG5cdFx0XHRyZXMgPSBNYXRoW3R5cGVdKC4uLnJlcyk7XHJcblx0XHR9IGVsc2UgaWYgKHJlc1swXSBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdFx0cmVzID0gc29ydFZhbHVlKHJlcywgdHlwZSA9PT0gXCJtaW5cIilbMF07XHJcblx0XHR9XHJcblx0fSBlbHNlIHtcclxuXHRcdHJlcyA9IHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgcmFuZ2VcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0IFN0YXJ0IG51bWJlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gZW5kIEVuZCBudW1iZXJcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlcltdIHtcclxuXHRjb25zdCByZXM6IG51bWJlcltdID0gW107XHJcblxyXG5cdGZvciAobGV0IGk6IG51bWJlciA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcclxuXHRcdHJlcy5wdXNoKGkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlcztcclxufVxyXG5cclxuLy8gZW11bGF0ZSBldmVudFxyXG5jb25zdCBlbXVsYXRlRXZlbnQgPSB7XHJcblx0bW91c2U6ICgoKSA9PiB7XHJcblx0XHRjb25zdCBnZXRQYXJhbXMgPSAoKSA9PiAoe1xyXG5cdFx0XHRidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIHNjcmVlblg6IDAsIHNjcmVlblk6IDAsIGNsaWVudFg6IDAsIGNsaWVudFk6IDBcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcclxuXHRcdFx0bmV3IE1vdXNlRXZlbnQoXCJ0XCIpO1xyXG5cclxuXHRcdFx0cmV0dXJuIChlbDogU1ZHRWxlbWVudCB8IEhUTUxFbGVtZW50LCBldmVudFR5cGU6IHN0cmluZywgcGFyYW1zID0gZ2V0UGFyYW1zKCkpID0+IHtcclxuXHRcdFx0XHRlbC5kaXNwYXRjaEV2ZW50KG5ldyBNb3VzZUV2ZW50KGV2ZW50VHlwZSwgcGFyYW1zKSk7XHJcblx0XHRcdH07XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdC8vIFBvbHlmaWxscyBET000IE1vdXNlRXZlbnRcclxuXHRcdFx0cmV0dXJuIChlbDogU1ZHRWxlbWVudCB8IEhUTUxFbGVtZW50LCBldmVudFR5cGU6IHN0cmluZywgcGFyYW1zID0gZ2V0UGFyYW1zKCkpID0+IHtcclxuXHRcdFx0XHRjb25zdCBtb3VzZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50XCIpO1xyXG5cclxuXHRcdFx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9pbml0TW91c2VFdmVudFxyXG5cdFx0XHRcdG1vdXNlRXZlbnQuaW5pdE1vdXNlRXZlbnQoXHJcblx0XHRcdFx0XHRldmVudFR5cGUsXHJcblx0XHRcdFx0XHRwYXJhbXMuYnViYmxlcyxcclxuXHRcdFx0XHRcdHBhcmFtcy5jYW5jZWxhYmxlLFxyXG5cdFx0XHRcdFx0d2luZG93LFxyXG5cdFx0XHRcdFx0MCwgLy8gdGhlIGV2ZW50J3MgbW91c2UgY2xpY2sgY291bnRcclxuXHRcdFx0XHRcdHBhcmFtcy5zY3JlZW5YLCBwYXJhbXMuc2NyZWVuWSxcclxuXHRcdFx0XHRcdHBhcmFtcy5jbGllbnRYLCBwYXJhbXMuY2xpZW50WSxcclxuXHRcdFx0XHRcdGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCAwLCBudWxsXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChtb3VzZUV2ZW50KTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9KSgpLFxyXG5cdHRvdWNoOiAoZWw6IFNWR0VsZW1lbnQgfCBIVE1MRWxlbWVudCwgZXZlbnRUeXBlOiBzdHJpbmcsIHBhcmFtczogYW55KSA9PiB7XHJcblx0XHRjb25zdCB0b3VjaE9iaiA9IG5ldyBUb3VjaChtZXJnZU9iaih7XHJcblx0XHRcdGlkZW50aWZpZXI6IERhdGUubm93KCksXHJcblx0XHRcdHRhcmdldDogZWwsXHJcblx0XHRcdHJhZGl1c1g6IDIuNSxcclxuXHRcdFx0cmFkaXVzWTogMi41LFxyXG5cdFx0XHRyb3RhdGlvbkFuZ2xlOiAxMCxcclxuXHRcdFx0Zm9yY2U6IDAuNVxyXG5cdFx0fSwgcGFyYW1zKSk7XHJcblxyXG5cdFx0ZWwuZGlzcGF0Y2hFdmVudChuZXcgVG91Y2hFdmVudChldmVudFR5cGUsIHtcclxuXHRcdFx0Y2FuY2VsYWJsZTogdHJ1ZSxcclxuXHRcdFx0YnViYmxlczogdHJ1ZSxcclxuXHRcdFx0c2hpZnRLZXk6IHRydWUsXHJcblx0XHRcdHRvdWNoZXM6IFt0b3VjaE9ial0sXHJcblx0XHRcdHRhcmdldFRvdWNoZXM6IFtdLFxyXG5cdFx0XHRjaGFuZ2VkVG91Y2hlczogW3RvdWNoT2JqXVxyXG5cdFx0fSkpO1xyXG5cdH1cclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm9jZXNzIHRoZSB0ZW1wbGF0ZSAgJiByZXR1cm4gYm91bmQgc3RyaW5nXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cGwgVGVtcGxhdGUgc3RyaW5nXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIERhdGEgdmFsdWUgdG8gYmUgcmVwbGFjZWRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gdHBsUHJvY2Vzcyh0cGw6IHN0cmluZywgZGF0YTogb2JqZWN0KTogc3RyaW5nIHtcclxuXHRsZXQgcmVzID0gdHBsO1xyXG5cclxuXHRmb3IgKGNvbnN0IHggaW4gZGF0YSkge1xyXG5cdFx0cmVzID0gcmVzLnJlcGxhY2UobmV3IFJlZ0V4cChgez0ke3h9fWAsIFwiZ1wiKSwgZGF0YVt4XSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHggZnJvbSBcIi4veFwiO1xyXG5pbXBvcnQgeSBmcm9tIFwiLi95XCI7XHJcbmltcG9ydCB5MiBmcm9tIFwiLi95MlwiO1xyXG5cclxuaW1wb3J0IHttZXJnZU9ian0gZnJvbSBcIi4uLy4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4gLyoqXHJcbiAqIHkgQXhpcyAgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IG1lcmdlT2JqKHtcclxuICAgIC8qKlxyXG4gICAgICogU3dpdGNoIHggYW5kIHkgYXhpcyBwb3NpdGlvbi5cclxuICAgICAqIEBuYW1lIGF4aXPigKRyb3RhdGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgcm90YXRlZDogdHJ1ZVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3JvdGF0ZWQ6IGZhbHNlXHJcbn0sIHgsIHksIHkyKTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZ3JpZCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxudHlwZSBMaW5lcyA9IHt2YWx1ZT86IG51bWJlcjsgdGV4dD86IHN0cmluZzsgY2xhc3M/OiBzdHJpbmc7IHBvc2l0aW9uPzogc3RyaW5nfVtdO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcmVsYXRlZCBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBncmlkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2Zyb250PWZhbHNlXSBTZXQgJ2dyaWQgJiBmb2N1cyBsaW5lcycgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGdyaWQgbGluZXMgYW5kIGNoYXJ0IGVsZW1lbnRzLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbeC5zaG93PWZhbHNlXSBTaG93IGdyaWRzIGFsb25nIHggYXhpcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt4LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB4IGF4aXMuPGJyPlxyXG4gICAgICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyB2YWx1ZSwgdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzLiB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLiBGb3IgcG9zaXRpb24sIHN0YXJ0LCBtaWRkbGUgYW5kIGVuZCAoZGVmYXVsdCkgYXJlIGF2YWlsYWJsZS5cclxuICAgICAqICBJZiB4IGF4aXMgaXMgY2F0ZWdvcnkgYXhpcywgdmFsdWUgY2FuIGJlIGNhdGVnb3J5IG5hbWUuIElmIHggYXhpcyBpcyB0aW1lc2VyaWVzIGF4aXMsIHZhbHVlIGNhbiBiZSBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3QgYW5kIHVuaXh0aW1lIGludGVnZXIuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt5LnNob3c9ZmFsc2VdIFNob3cgZ3JpZHMgYWxvbmcgeCBheGlzLlxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gW3kubGluZXM9W11dIFNob3cgYWRkaXRpb25hbCBncmlkIGxpbmVzIGFsb25nIHkgYXhpcy48YnI+XHJcbiAgICAgKiAgVGhpcyBvcHRpb24gYWNjZXB0cyBhcnJheSBpbmNsdWRpbmcgb2JqZWN0IHRoYXQgaGFzIHZhbHVlLCB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3kudGlja3M9MTBdIE51bWJlciBvZiB5IGdyaWRzIHRvIGJlIHNob3duLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZm9jdXMuZWRnZT1mYWxzZV0gU2hvdyBlZGdlZCBmb2N1cyBncmlkIGxpbmUuPGJyPioqTk9URToqKiBBdmFpbGFibGUgd2hlbiBbYHRvb2x0aXAuZ3JvdXBlZD1mYWxzZWBdKCMudG9vbHRpcCkgb3B0aW9uIGlzIHNldC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLnNob3c9dHJ1ZV0gU2hvdyBncmlkIGxpbmUgd2hlbiBmb2N1cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLnk9ZmFsc2VdIFNob3cgeSBjb29yZGluYXRlIGZvY3VzIGdyaWQgbGluZS48YnI+KipOT1RFOioqIEF2YWlsYWJsZSB3aGVuIFtgdG9vbHRpcC5ncm91cGVkPWZhbHNlYF0oIy50b29sdGlwKSBvcHRpb24gaXMgc2V0LlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZXMuZnJvbnQ9dHJ1ZV0gU2V0IGdyaWQgbGluZXMgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGNoYXJ0IGVsZW1lbnRzLlxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5HcmlkTGluZXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBYIEdyaWQgTGluZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNHcmlkLk9wdGlvbmFsWEdyaWRMaW5lcylcclxuICAgICAqIEBzZWUgW0RlbW86IFkgR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxZR3JpZExpbmVzKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGdyaWQ6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgbGluZXM6IFtcclxuICAgICAqICAgICAgIHt2YWx1ZTogMiwgdGV4dDogXCJMYWJlbCBvbiAyXCJ9LFxyXG4gICAgICogICAgICAge3ZhbHVlOiA1LCB0ZXh0OiBcIkxhYmVsIG9uIDVcIiwgY2xhc3M6IFwibGFiZWwtNVwifSxcclxuICAgICAqICAgICAgIHt2YWx1ZTogNiwgdGV4dDogXCJMYWJlbCBvbiA2XCIsIHBvc2l0aW9uOiBcInN0YXJ0XCJ9XHJcbiAgICAgKiAgICAgXVxyXG4gICAgICogICB9LFxyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAqICAgICBsaW5lczogW1xyXG4gICAgICogICAgICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgb24gMTAwXCJ9LFxyXG4gICAgICogICAgICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgb24gMjAwXCIsIGNsYXNzOiBcImxhYmVsLTIwMFwifSxcclxuICAgICAqICAgICAgIHt2YWx1ZTogMzAwLCB0ZXh0OiBcIkxhYmVsIG9uIDMwMFwiLCBwb3NpdGlvbjogJ21pZGRsZSd9XHJcbiAgICAgKiAgICAgXSxcclxuICAgICAqICAgICB0aWNrczogNVxyXG4gICAgICogICB9LFxyXG4gICAgICogICBmcm9udDogdHJ1ZSxcclxuICAgICAqICAgZm9jdXM6IHtcclxuICAgICAqICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBCZWxvdyBvcHRpb25zIGFyZSBhdmFpbGFibGUgd2hlbiAndG9vbHRpcC5ncm91cGVkPWZhbHNlJyBvcHRpb24gaXMgc2V0XHJcbiAgICAgKiAgICAgIGVkZ2U6IHRydWUsXHJcbiAgICAgKiAgICAgIHk6IHRydWVcclxuICAgICAqICAgfSxcclxuICAgICAqICAgbGluZXM6IHtcclxuICAgICAqICAgICAgZnJvbnQ6IGZhbHNlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZ3JpZF94X3Nob3c6IGZhbHNlLFxyXG4gICAgZ3JpZF94X3R5cGU6IFwidGlja1wiLFxyXG4gICAgZ3JpZF94X2xpbmVzOiA8TGluZXM+IFtdLFxyXG4gICAgZ3JpZF95X3Nob3c6IGZhbHNlLFxyXG4gICAgZ3JpZF95X2xpbmVzOiA8TGluZXM+IFtdLFxyXG4gICAgZ3JpZF95X3RpY2tzOiAxMCxcclxuICAgIGdyaWRfZm9jdXNfZWRnZTogZmFsc2UsXHJcbiAgICBncmlkX2ZvY3VzX3Nob3c6IHRydWUsXHJcbiAgICBncmlkX2ZvY3VzX3k6IGZhbHNlLFxyXG4gICAgZ3JpZF9mcm9udDogZmFsc2UsXHJcbiAgICBncmlkX2xpbmVzX2Zyb250OiB0cnVlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHBvaW50IGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBwb2ludCBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBwb2ludFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwb2ludC5zaG93PXRydWVdIFdoZXRoZXIgdG8gc2hvdyBlYWNoIHBvaW50IGluIGxpbmUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW3BvaW50LnI9Mi41XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludC5cclxuICAgICAqICAtICoqTk9URToqKiBEaXNhYmxlZCBmb3IgJ2J1YmJsZScgdHlwZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcG9pbnQuZm9jdXMuZXhwYW5kLmVuYWJsZWQ9dHJ1ZV0gV2hldGhlciB0byBleHBhbmQgZWFjaCBwb2ludCBvbiBmb2N1cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuZm9jdXMuZXhwYW5kLnI9cG9pbnQucioxLjc1XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBmb2N1cy5cclxuICAgICAqICAtICoqTk9URToqKiBGb3IgJ2J1YmJsZScgdHlwZSwgdGhlIGRlZmF1bHQgaXMgYGJ1YmJsZVNpemUqMS4xNWBcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuc2Vuc2l0aXZpdHk9MTBdIFRoZSBzZW5zdGl2aXR5IHZhbHVlIGZvciBpbnRlcmFjdGlvbiBib3VuZGFyeS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuc2VsZWN0LnI9cG9pbnQucio0XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBzZWxlY3RlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcG9pbnQudHlwZT1cImNpcmNsZVwiXSBUaGUgdHlwZSBvZiBwb2ludCB0byBiZSBkcmF3blxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICAgLSBJZiBjaGFydCBoYXMgJ2J1YmJsZScgdHlwZSwgb25seSBjaXJjbGUgY2FuIGJlIHVzZWQuXHJcbiAgICAgKiAgIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXHJcbiAgICAgKiAtICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogICAtIGNpcmNsZVxyXG4gICAgICogICAtIHJlY3RhbmdsZVxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gW3BvaW50LnBhdHRlcm49W11dIFRoZSB0eXBlIG9mIHBvaW50IG9yIHN2ZyBzaGFwZSBhcyBzdHJpbmcsIHRvIGJlIGRyYXduIGZvciBlYWNoIGxpbmVcclxuICAgICAqIC0gKipOT1RFOioqXHJcbiAgICAgKiAgIC0gVGhpcyBpcyBhbiBgZXhwZXJpbWVudGFsYCBmZWF0dXJlIGFuZCBjYW4gaGF2ZSBzb21lIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxyXG4gICAgICogICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cclxuICAgICAqICAgLSBGb3IgSUUsIG5vbiBjaXJjbGUgcG9pbnQgZXhwYW5zaW9ucyBhcmUgbm90IHN1cHBvcnRlZCBkdWUgdG8gbGFjayBvZiB0cmFuc2Zvcm0gc3VwcG9ydC5cclxuICAgICAqIC0gKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAgIC0gY2lyY2xlXHJcbiAgICAgKiAgIC0gcmVjdGFuZ2xlXHJcbiAgICAgKiAgIC0gc3ZnIHNoYXBlIHRhZyBpbnRlcnByZXRlZCBhcyBzdHJpbmc8YnI+XHJcbiAgICAgKiAgICAgKGV4LiBgPHBvbHlnb24gcG9pbnRzPScyLjUgMCAwIDUgNSA1Jz48L3BvbHlnb24+YClcclxuICAgICAqIEBzZWUgW0RlbW86IHBvaW50IHR5cGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNQb2ludC5SZWN0YW5nbGVQb2ludHMpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIHBvaW50OiB7XHJcbiAgICAgKiAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICogICAgICByOiA1LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gb3IgY3VzdG9taXplIHRoZSByYWRpdXNcclxuICAgICAqICAgICAgcjogZnVuY3Rpb24oZCkge1xyXG4gICAgICogICAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIGZvY3VzOiB7XHJcbiAgICAgKiAgICAgICAgICBleHBhbmQ6IHtcclxuICAgICAqICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICogICAgICAgICAgICAgIHI6IDFcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgc2VsZWN0OiB7XHJcbiAgICAgKiAgICAgICAgICByOiAzXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBoYXZpbmcgbG93ZXIgdmFsdWUsIG1lYW5zIGhvdyBjbG9zZXIgdG8gYmUgZm9yIGludGVyYWN0aW9uXHJcbiAgICAgKiAgICAgIHNlbnNpdGl2aXR5OiAzLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gdmFsaWQgdmFsdWVzIGFyZSBcImNpcmNsZVwiIG9yIFwicmVjdGFuZ2xlXCJcclxuICAgICAqICAgICAgdHlwZTogXCJyZWN0YW5nbGVcIixcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yIGluZGljYXRlIGFzIHBhdHRlcm5cclxuICAgICAqICAgICAgcGF0dGVybjogW1xyXG4gICAgICogICAgICAgIFwiY2lyY2xlXCIsXHJcbiAgICAgKiAgICAgICAgXCJyZWN0YW5nbGVcIixcclxuICAgICAqICAgICAgICBcIjxwb2x5Z29uIHBvaW50cz0nMCA2IDQgMCAtNCAwJz48L3BvbHlnb24+XCJcclxuICAgICAqICAgICBdLFxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgcG9pbnRfc2hvdzogdHJ1ZSxcclxuICAgIHBvaW50X3I6IDIuNSxcclxuICAgIHBvaW50X3NlbnNpdGl2aXR5OiAxMCxcclxuICAgIHBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkOiB0cnVlLFxyXG4gICAgcG9pbnRfZm9jdXNfZXhwYW5kX3I6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBwb2ludF9wYXR0ZXJuOiA8c3RyaW5nW10+IFtdLFxyXG4gICAgcG9pbnRfc2VsZWN0X3I6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBwb2ludF90eXBlOiBcImNpcmNsZVwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgc3ViY2hhcnQgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgc3ViY2hhcnRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuc2hvdz1mYWxzZV0gU2hvdyBzdWIgY2hhcnQgb24gdGhlIGJvdHRvbSBvZiB0aGUgY2hhcnQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5heGlzLnguc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnRpY2suc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgbGluZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC50aWNrLnRleHQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgeCBheGlzIHRpY2sgdGV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc3ViY2hhcnQuc2l6ZS5oZWlnaHRdIENoYW5nZSB0aGUgaGVpZ2h0IG9mIHRoZSBzdWJjaGFydC5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtzdWJjaGFydC5vbmJydXNoXSBTZXQgY2FsbGJhY2sgZm9yIGJydXNoIGV2ZW50Ljxicj5cclxuICAgICAqICBTcGVjaWZpZWQgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIGN1cnJlbnQgem9vbWVkIHggZG9tYWluLlxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlN1YkNoYXJ0KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBzdWJjaGFydDoge1xyXG4gICAgICogICAgICBheGlzOiB7XHJcbiAgICAgKiAgICAgIFx0eDoge1xyXG4gICAgICogICAgICBcdCAgc2hvdzogdHJ1ZSxcclxuICAgICAqICAgICAgXHQgICAgdGljazoge1xyXG4gICAgICogICAgICBcdCAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgIFx0ICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICBcdCAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICAgXHQgICAgICB9XHJcbiAgICAgKiAgICAgIFx0ICAgIH1cclxuICAgICAqICAgICAgXHR9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgIHNpemU6IHtcclxuICAgICAqICAgICAgICAgIGhlaWdodDogMjBcclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgb25icnVzaDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9XHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBzdWJjaGFydF9zaG93OiBmYWxzZSxcclxuICAgIHN1YmNoYXJ0X3NpemVfaGVpZ2h0OiA2MCxcclxuICAgIHN1YmNoYXJ0X2F4aXNfeF9zaG93OiB0cnVlLFxyXG4gICAgc3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdzogdHJ1ZSxcclxuICAgIHN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdzogdHJ1ZSxcclxuICAgIHN1YmNoYXJ0X29uYnJ1c2g6ICgpID0+IHt9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHpvb20gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHpvb20gb3B0aW9uc1xyXG4gICAgICogQG5hbWUgem9vbVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt6b29tLmVuYWJsZWQ9ZmFsc2VdIEVuYWJsZSB6b29taW5nLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt6b29tLmVuYWJsZWQudHlwZT0nd2hlZWwnXSBTZXQgem9vbSBpbnRlcmFjdGlvbiB0eXBlLlxyXG4gICAgICogIC0gKipBdmFpbGFibGUgdHlwZXM6KipcclxuICAgICAqICAgIC0gd2hlZWxcclxuICAgICAqICAgIC0gZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbem9vbS5yZXNjYWxlPWZhbHNlXSBFbmFibGUgdG8gcmVzY2FsZSBhZnRlciB6b29taW5nLjxicj5cclxuICAgICAqICBJZiB0cnVlIHNldCwgeSBkb21haW4gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZyB0byB0aGUgem9vbWVkIHJlZ2lvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt6b29tLmV4dGVudD1bMSwgMTBdXSBDaGFuZ2Ugem9vbSBleHRlbnQuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxEYXRlfSBbem9vbS54Lm1pbl0gU2V0IHggQXhpcyBtaW5pbXVtIHpvb20gcmFuZ2VcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfERhdGV9IFt6b29tLngubWF4XSBTZXQgeCBBeGlzIG1heGltdW0gem9vbSByYW5nZVxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tc3RhcnQ9dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB6b29taW5nIHN0YXJ0cy48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tIGV2ZW50LlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tPXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHpvb21pbmcuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbWVkIGRvbWFpbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbWVuZD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgZW5kcy48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tZWQgZG9tYWluLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW3pvb20ucmVzZXRCdXR0b249dHJ1ZV0gU2V0IHRvIGRpc3BsYXkgem9vbSByZXNldCBidXR0b24gZm9yICdkcmFnJyB0eXBlIHpvb21cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLnJlc2V0QnV0dG9uLm9uY2xpY2tdIFNldCBjYWxsYmFjayB3aGVuIGNsaWNrcyB0aGUgcmVzZXQgYnV0dG9uLiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHJlc2V0IGJ1dHRvbiBlbGVtZW50IHJlZmVyZW5jZSBhcyBhcmd1bWVudC5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbem9vbS5yZXNldEJ1dHRvbi50ZXh0PSdSZXNldCBab29tJ10gVGV4dCB2YWx1ZSBmb3Igem9vbSByZXNldCBidXR0b24uXHJcbiAgICAgKiBAc2VlIFtEZW1vOnpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5ab29tKVxyXG4gICAgICogQHNlZSBbRGVtbzpkcmFnIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5EcmFnWm9vbSlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgem9vbToge1xyXG4gICAgICogICAgICBlbmFibGVkOiB7XHJcbiAgICAgKiAgICAgICAgICB0eXBlOiBcImRyYWdcIlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICByZXNjYWxlOiB0cnVlLFxyXG4gICAgICogICAgICBleHRlbnQ6IFsxLCAxMDBdICAvLyBlbmFibGUgbW9yZSB6b29taW5nXHJcbiAgICAgKiAgICAgIHg6IHtcclxuICAgICAqICAgICAgICAgIG1pbjogLTEsICAvLyBzZXQgbWluIHJhbmdlXHJcbiAgICAgKiAgICAgICAgICBtYXg6IDEwICAvLyBzZXQgbWF4IHJhbmdlXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIG9uem9vbXN0YXJ0OiBmdW5jdGlvbihldmVudCkgeyAuLi4gfSxcclxuICAgICAqICAgICAgb256b29tOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH0sXHJcbiAgICAgKiAgICAgIG9uem9vbWVuZDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc2hvdyByZXNldCBidXR0b24gd2hlbiBpcyB6b29tZWQtaW5cclxuICAgICAqICAgICAgcmVzZXRCdXR0b246IHRydWUsXHJcbiAgICAgKlxyXG4gICAgICogICAgICByZXNldEJ1dHRvbjoge1xyXG4gICAgICogICAgICAgICAgLy8gb25jbGljayBjYWxsYmFjayB3aGVuIHJlc2V0IGJ1dHRvbiBpcyBjbGlja2VkXHJcbiAgICAgKiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbihidXR0b24pIHtcclxuICAgICAqICAgICAgICAgICAgYnV0dG9uOyAvLyBSZXNldCBidXR0b24gZWxlbWVudCByZWZlcmVuY2VcclxuICAgICAqICAgICAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIGN1c3RvbWl6ZWQgdGV4dCB2YWx1ZSBmb3IgcmVzZXQgem9vbSBidXR0b25cclxuICAgICAqICAgICAgICAgIHRleHQ6IFwiVW56b29tXCJcclxuICAgICAqICAgICAgfVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgem9vbV9lbmFibGVkOiA8e3R5cGU6IFwid2hlZWxcIiB8IFwiZHJhZ1wifXxib29sZWFufHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgem9vbV9leHRlbnQ6IDxudW1iZXJbXXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIHpvb21fcHJpdmlsZWdlZDogZmFsc2UsXHJcbiAgICB6b29tX3Jlc2NhbGU6IGZhbHNlLFxyXG4gICAgem9vbV9vbnpvb206IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIHpvb21fb256b29tc3RhcnQ6IDxGdW5jdGlvbnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIHpvb21fb256b29tZW5kOiA8RnVuY3Rpb258dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB6b29tX3Jlc2V0QnV0dG9uOiA8e3RleHQ6IHN0cmluZzt9fGJvb2xlYW4+IHRydWUsXHJcbiAgICB6b29tX3hfbWluOiA8TnVtYmVyfERhdGV8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICB6b29tX3hfbWF4OiA8TnVtYmVyfERhdGV8dW5kZWZpbmVkPiB1bmRlZmluZWRcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogYXJlYSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYXJlYSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBhcmVhXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FyZWEuemVyb2Jhc2VkPXRydWVdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBhcmVhIGNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbYXJlYS5hYm92ZT1mYWxzZV0gU2V0IGJhY2tncm91bmQgYXJlYSBhYm92ZSB0aGUgZGF0YSBjaGFydCBsaW5lLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW2FyZWEubGluZWFyR3JhZGllbnQ9ZmFsc2VdIFNldCB0aGUgbGluZWFyIGdyYWRpZW50IG9uIGFyZWEuPGJyPjxicj5cclxuICAgICAqIE9yIGN1c3RvbWl6ZSBieSBnaXZpbmcgYmVsb3cgb2JqZWN0IHZhbHVlOlxyXG4gICAgICogIC0geCB7QXJyYXl9OiBgeDFgLCBgeDJgIHZhbHVlXHJcbiAgICAgKiAgLSB5IHtBcnJheX06IGB5MWAsIGB5MmAgdmFsdWVcclxuICAgICAqICAtIHN0b3BzIHtBcnJheX06IEVhY2ggaXRlbSBzaG91bGQgYmUgaGF2aW5nIGBbb2Zmc2V0LCBzdG9wLWNvbG9yLCBzdG9wLW9wYWNpdHldYCB2YWx1ZXMuXHJcbiAgICAgKiBAc2VlIFtNRE4ncyAmbHQ7bGluZWFyR3JhZGllbnQ+XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC9saW5lYXJHcmFkaWVudCksIFsmbHQ7c3RvcD5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N0b3ApXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuQXJlYUNoYXJ0KVxyXG4gICAgICogQHNlZSBbRGVtbzogYWJvdmVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBcmVhQ2hhcnRPcHRpb25zLkFib3ZlKVxyXG4gICAgICogQHNlZSBbRGVtbzogbGluZWFyR3JhZGllbnRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBcmVhQ2hhcnRPcHRpb25zLkxpbmVhckdyYWRpZW50KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBhcmVhOiB7XHJcbiAgICAgKiAgICAgIHplcm9iYXNlZDogZmFsc2UsXHJcbiAgICAgKiAgICAgIGFib3ZlOiB0cnVlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gd2lsbCBnZW5lcmF0ZSBmb2xsd2luZyBsaW5lYXJHcmFkaWVudDpcclxuICAgICAqICAgICAgLy8gPGxpbmVhckdyYWRpZW50IHgxPVwiMFwiIHgyPVwiMFwiIHkxPVwiMFwiIHkyPVwiMVwiPlxyXG4gICAgICogICAgICAvLyAgICA8c3RvcCBvZmZzZXQ9XCIwXCIgc3RvcC1jb2xvcj1cIiREQVRBX0NPTE9SXCIgc3RvcC1vcGFjaXR5PVwiMVwiPjwvc3RvcD5cclxuICAgICAqICAgICAgLy8gICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0b3AtY29sb3I9XCIkREFUQV9DT0xPUlwiIHN0b3Atb3BhY2l0eT1cIjBcIj48L3N0b3A+XHJcbiAgICAgKiAgICAgIC8vIDwvbGluZWFyR3JhZGllbnQ+XHJcbiAgICAgKiAgICAgIGxpbmVhckdyYWRpZW50OiB0cnVlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gT3IgY3VzdG9taXplZCBncmFkaWVudFxyXG4gICAgICogICAgICBsaW5lYXJHcmFkaWVudDoge1xyXG4gICAgICogICAgICBcdHg6IFswLCAwXSwgIC8vIHgxLCB4MiBhdHRyaWJ1dGVzXHJcbiAgICAgKiAgICAgIFx0eTogWzAsIDBdLCAgLy8geTEsIHkyIGF0dHJpYnV0ZXNcclxuICAgICAqICAgICAgXHRzdG9wczogW1xyXG4gICAgICogICAgICBcdCAgLy8gb2Zmc2V0LCBzdG9wLWNvbG9yLCBzdG9wLW9wYWNpdHlcclxuICAgICAqICAgICAgXHQgIFswLCBcIiM3Y2I1ZWNcIiwgMV0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdCAgLy8gc2V0dGluZyAnbnVsbCcgZm9yIHN0b3AtY29sb3IsIHdpbGwgc2V0IGl0cyBvcmlnaW5hbCBkYXRhIGNvbG9yXHJcbiAgICAgKiAgICAgIFx0ICBbMC41LCBudWxsLCAwXSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0ICAvLyBzZXR0aW5nICdmdW5jdGlvbicgZm9yIHN0b3AtY29sb3IsIHdpbGwgcGFzcyBkYXRhIGlkIGFzIGFyZ3VtZW50LlxyXG4gICAgICogICAgICBcdCAgLy8gSXQgc2hvdWxkIHJldHVybiBjb2xvciBzdHJpbmcgb3IgbnVsbCB2YWx1ZVxyXG4gICAgICogICAgICBcdCAgWzEsIGZ1bmN0aW9uKGlkKSB7IHJldHVybiBpZCA9PT0gXCJkYXRhMVwiID8gXCJyZWRcIiA6IFwiYmx1ZVwiOyB9LCAwXSxcclxuICAgICAqICAgICAgXHRdXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGFyZWFfemVyb2Jhc2VkOiB0cnVlLFxyXG4gICAgYXJlYV9hYm92ZTogZmFsc2UsXHJcbiAgICBhcmVhX2xpbmVhckdyYWRpZW50OiA8Ym9vbGVhbnx7eD86IG51bWJlcltdOyB5PzogbnVtYmVyW107IHN0b3BzPzogW251bWJlciwgc3RyaW5nfEZ1bmN0aW9ufG51bGwsIG51bWJlcl19PiBmYWxzZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBiYXIgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGJhciBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBiYXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIucGFkZGluZz0wXSBUaGUgcGFkZGluZyBwaXhlbCB2YWx1ZSBiZXR3ZWVuIGVhY2ggYmFyLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIucmFkaXVzXSBTZXQgdGhlIHJhZGl1cyBvZiBiYXIgZWRnZSBpbiBwaXhlbC5cclxuICAgICAqIC0gKipOT1RFOioqIFdvcmtzIG9ubHkgZm9yIG5vbi1zdGFja2VkIGJhclxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIucmFkaXVzLnJhdGlvXSBTZXQgdGhlIHJhZGl1cyByYXRpbyBvZiBiYXIgZWRnZSBpbiByZWxhdGl2ZSB0aGUgYmFyJ3Mgd2lkdGguXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5zZW5zaXRpdml0eT0yXSBUaGUgc2Vuc3Rpdml0eSBvZmZzZXQgdmFsdWUgZm9yIGludGVyYWN0aW9uIGJvdW5kYXJ5LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGhdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGgucmF0aW89MC42XSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydCBieSByYXRpby5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLm1heF0gVGhlIG1heGltdW0gd2lkdGggdmFsdWUgZm9yIHJhdGlvLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWVdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGZvciBpbmRpY2F0ZWQgZGF0YXNldCBvbmx5LlxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICAgLSBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcclxuICAgICAqICAgLSBCYXJzIGFyZSBjZW50ZXJlZCBhY2NvZGluZyBpdHMgdG90YWwgd2lkdGggdmFsdWVcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lLnJhdGlvPTAuNl0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQgYnkgcmF0aW8uXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZS5tYXhdIFRoZSBtYXhpbXVtIHdpZHRoIHZhbHVlIGZvciByYXRpby5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2Jhci56ZXJvYmFzZWQ9dHJ1ZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGJhciBjaGFydC5cclxuICAgICAqIEBzZWUgW0RlbW86IGJhciBwYWRkaW5nXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclBhZGRpbmcpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBiYXIgcmFkaXVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclJhZGl1cylcclxuICAgICAqIEBzZWUgW0RlbW86IGJhciB3aWR0aF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJXaWR0aClcclxuICAgICAqIEBzZWUgW0RlbW86IGJhciB3aWR0aCB2YXJpYW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhcldpZHRoVmFyaWFudClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgYmFyOiB7XHJcbiAgICAgKiAgICAgIHBhZGRpbmc6IDEsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyB0aGUgJ3JhZGl1cycgb3B0aW9uIGNhbiBiZSB1c2VkIG9ubHkgZm9yIG5vbi1zdGFja2luZyBiYXJzXHJcbiAgICAgKiAgICAgIHJhZGl1czogMTAsXHJcbiAgICAgKiAgICAgIC8vIG9yXHJcbiAgICAgKiAgICAgIHJhZGl1czoge1xyXG4gICAgICogICAgICAgICAgcmF0aW86IDAuNVxyXG4gICAgICogICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyB3aWxsIG5vdCBoYXZlIG9mZnNldCBiZXR3ZWVuIGVhY2ggYmFyIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxyXG4gICAgICogICAgICBzZW5zaXRpdml0eTogMCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIHdpZHRoOiAxMCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yXHJcbiAgICAgKiAgICAgIHdpZHRoOiB7XHJcbiAgICAgKiAgICAgICAgICByYXRpbzogMC4yLFxyXG4gICAgICogICAgICAgICAgbWF4OiAyMFxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gb3Igc3BlY2lmeSB3aWR0aCBwZXIgZGF0YXNldFxyXG4gICAgICogICAgICB3aWR0aDoge1xyXG4gICAgICogICAgICAgICAgZGF0YTE6IDIwLFxyXG4gICAgICogICAgICAgICAgZGF0YTI6IHtcclxuICAgICAqICAgICAgICAgICAgICByYXRpbzogMC4yLFxyXG4gICAgICogICAgICAgICAgICAgIG1heDogMjBcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIHplcm9iYXNlZDogZmFsc2VcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGJhcl9wYWRkaW5nOiAwLFxyXG4gICAgYmFyX3JhZGl1czogPG51bWJlcnx7cmF0aW86IG51bWJlcn18dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBiYXJfc2Vuc2l0aXZpdHk6IDIsXHJcbiAgICBiYXJfd2lkdGg6IDxudW1iZXJ8e3JhdGlvPzogbnVtYmVyOyBtYXg/OiBudW1iZXI7fXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGJhcl93aWR0aF9yYXRpbzogMC42LFxyXG4gICAgYmFyX3dpZHRoX21heDogdW5kZWZpbmVkLFxyXG4gICAgYmFyX3plcm9iYXNlZDogdHJ1ZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBidWJibGUgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGJ1YmJsZSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBidWJibGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtidWJibGUubWF4Uj0zNV0gU2V0IHRoZSBtYXggYnViYmxlIHJhZGl1cyB2YWx1ZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbYnViYmxlLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGJ1YmJsZSBjaGFydC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgYnViYmxlOiB7XHJcbiAgICAgKiAgICAgIC8vIGV4KSBJZiAxMDAgaXMgdGhlIGhpZ2hlc3QgdmFsdWUgYW1vbmcgZGF0YSBib3VuZCwgdGhlIHJlcHJlc2VudGF0aW9uIGJ1YmJsZSBvZiAxMDAgd2lsbCBoYXZlIHJhZGl1cyBvZiA1MC5cclxuICAgICAqICAgICAgLy8gQW5kIHRoZSBsZXNzZXIgd2lsbCBoYXZlIHJhZGl1cyByZWxhdGl2ZWx5IGZyb20gdGhhIG1heCB2YWx1ZS5cclxuICAgICAqICAgICAgbWF4UjogNTAsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBvciBzZXQgcmFkaXVzIGNhbGxiYWNrXHJcbiAgICAgKiAgICAgIG1heFI6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAqICAgICAgICAgIC8vIGV4LiBvZiBkIHBhcmFtIC0ge3g6IEZyaSBPY3QgMDYgMjAxNyAwMDowMDowMCBHTVQrMDkwMCwgdmFsdWU6IDgwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNX1cclxuICAgICAqICAgICAgICAgIC4uLlxyXG4gICAgICogICAgICAgICAgcmV0dXJuIE1hdGguc3FydChkLnZhbHVlICogMik7XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIHplcm9iYXNlZDogZmFsc2VcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGJ1YmJsZV9tYXhSOiA8bnVtYmVyfCgoKSA9PiBudW1iZXIpPiAzNSxcclxuICAgIGJ1YmJsZV96ZXJvYmFzZWQ6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGxpbmUgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxpbmUgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgbGluZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsaW5lLmNvbm5lY3ROdWxsPWZhbHNlXSBTZXQgaWYgbnVsbCBkYXRhIHBvaW50IHdpbGwgYmUgY29ubmVjdGVkIG9yIG5vdC48YnI+XHJcbiAgICAgKiAgSWYgdHJ1ZSBzZXQsIHRoZSByZWdpb24gb2YgbnVsbCBkYXRhIHdpbGwgYmUgY29ubmVjdGVkIHdpdGhvdXQgYW55IGRhdGEgcG9pbnQuIElmIGZhbHNlIHNldCwgdGhlIHJlZ2lvbiBvZiBudWxsIGRhdGEgd2lsbCBub3QgYmUgY29ubmVjdGVkIGFuZCBnZXQgZW1wdHkuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSAgIFtsaW5lLmNsYXNzZXM9dW5kZWZpbmVkXSBJZiBzZXQsIHVzZWQgdG8gc2V0IGEgY3NzIGNsYXNzIG9uIGVhY2ggbGluZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmUuc3RlcC50eXBlPXN0ZXBdIENoYW5nZSBzdGVwIHR5cGUgZm9yIHN0ZXAgY2hhcnQuPGJyPlxyXG4gICAgICogKipBdmFpbGFibGUgdmFsdWVzOioqXHJcbiAgICAgKiAtIHN0ZXBcclxuICAgICAqIC0gc3RlcC1iZWZvcmVcclxuICAgICAqIC0gc3RlcC1hZnRlclxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufEFycmF5fSBbbGluZS5wb2ludD10cnVlXSBTZXQgdG8gZmFsc2UgdG8gbm90IGRyYXcgcG9pbnRzIG9uIGxpbmVjaGFydHMuIE9yIHBhc3MgYW4gYXJyYXkgb2YgbGluZSBpZHMgdG8gZHJhdyBwb2ludHMgZm9yLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZS56ZXJvYmFzZWQ9ZmFsc2VdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBsaW5lIGNoYXJ0LlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBsaW5lOiB7XHJcbiAgICAgKiAgICAgIGNvbm5lY3ROdWxsOiB0cnVlLFxyXG4gICAgICogICAgICBjbGFzc2VzOiBbXHJcbiAgICAgKiAgICAgICAgICBcImxpbmUtY2xhc3MxXCIsXHJcbiAgICAgKiAgICAgICAgICBcImxpbmUtY2xhc3MyXCJcclxuICAgICAqICAgICAgXSxcclxuICAgICAqICAgICAgc3RlcDoge1xyXG4gICAgICogICAgICAgICAgdHlwZTogXCJzdGVwLWFmdGVyXCJcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGhpZGUgYWxsIGRhdGEgcG9pbnRzICgncG9pbnQuc2hvdz1mYWxzZScgYWxzbyBoYXMgc2ltaWxhciBlZmZlY3QpXHJcbiAgICAgKiAgICAgIHBvaW50OiBmYWxzZSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNob3cgZGF0YSBwb2ludHMgZm9yIG9ubHkgaW5kaWNhdGVkIGRhdGFzXHJcbiAgICAgKiAgICAgIHBvaW50OiBbXHJcbiAgICAgKiAgICAgICAgICBcImRhdGExXCIsIFwiZGF0YTNcIlxyXG4gICAgICogICAgICBdLFxyXG4gICAgICpcclxuICAgICAqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgbGluZV9jb25uZWN0TnVsbDogZmFsc2UsXHJcbiAgICBsaW5lX3N0ZXBfdHlwZTogPFwic3RlcFwifFwic3RlcC1iZWZvcmVcInxcInN0ZXAtYWZ0ZXJcIj4gXCJzdGVwXCIsXHJcbiAgICBsaW5lX3plcm9iYXNlZDogZmFsc2UsXHJcbiAgICBsaW5lX2NsYXNzZXM6IDxzdHJpbmdbXXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGxpbmVfcG9pbnQ6IDxzdHJpbmdbXXxib29sZWFuPiB0cnVlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtTcGxpbmVUeXBlc30gZnJvbSBcIi4uLy4uLy4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNwbGluZSBvcHRpb25zXHJcbiAgICAgKiAtICoqQXZhaWxhYmxlIGludGVycG9sYXRpb24gdHlwZSB2YWx1ZXM6KipcclxuICAgICAqICAtIGJhc2lzIChkMy5jdXJ2ZUJhc2lzKVxyXG4gICAgICogIC0gYmFzaXMtY2xvc2VkIChkMy5jdXJ2ZUJhc2lzQ2xvc2VkKVxyXG4gICAgICogIC0gYmFzaXMtb3BlbiAoZDMuY3VydmVCYXNpc09wZW4pXHJcbiAgICAgKiAgLSBidW5kbGUgKGQzLmN1cnZlQnVuZGxlKVxyXG4gICAgICogIC0gY2FyZGluYWwgKGQzLmN1cnZlQ2FyZGluYWwpXHJcbiAgICAgKiAgLSBjYXJkaW5hbC1jbG9zZWQgKGQzLmN1cnZlQ2FyZGluYWxDbG9zZWQpXHJcbiAgICAgKiAgLSBjYXJkaW5hbC1vcGVuIChkMy5jdXJ2ZUNhcmRpbmFsT3BlbilcclxuICAgICAqICAtIGNhdG11bGwtcm9tIChkMy5jdXJ2ZUNhdG11bGxSb20pXHJcbiAgICAgKiAgLSBjYXRtdWxsLXJvbS1jbG9zZWQgKGQzLmN1cnZlQ2F0bXVsbFJvbUNsb3NlZClcclxuICAgICAqICAtIGNhdG11bGwtcm9tLW9wZW4gKGQzLmN1cnZlQ2F0bXVsbFJvbU9wZW4pXHJcbiAgICAgKiAgLSBtb25vdG9uZS14IChkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAqICAtIG1vbm90b25lLXkgKGQzLmN1cnZlTW9ub3RvbmVZKVxyXG4gICAgICogIC0gbmF0dXJhbCAoZDMuY3VydmVOYXR1cmFsKVxyXG4gICAgICogIC0gbGluZWFyLWNsb3NlZCAoZDMuY3VydmVMaW5lYXJDbG9zZWQpXHJcbiAgICAgKiAgLSBsaW5lYXIgKGQzLmN1cnZlTGluZWFyKVxyXG4gICAgICogIC0gc3RlcCAoZDMuY3VydmVTdGVwKVxyXG4gICAgICogIC0gc3RlcC1hZnRlciAoZDMuY3VydmVTdGVwQWZ0ZXIpXHJcbiAgICAgKiAgLSBzdGVwLWJlZm9yZSAoZDMuY3VydmVTdGVwQmVmb3JlKVxyXG4gICAgICogQG5hbWUgc3BsaW5lXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3BsaW5lLmludGVycG9sYXRpb24udHlwZT1cImNhcmRpbmFsXCJdXHJcbiAgICAgKiBAc2VlIFtJbnRlcnBvbGF0aW9uIChkMyB2NCldKGh0dHA6Ly9ibC5vY2tzLm9yZy9lbW1hc2F1bmRlcnMvYzI1YTE0Nzk3MGRlZjJiMDJkOGM3YzI3MTlkYzc1MDIpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIHNwbGluZToge1xyXG4gICAgICogICAgICBpbnRlcnBvbGF0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICB0eXBlOiBcImNhcmRpbmFsXCJcclxuICAgICAqICAgICAgfVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgc3BsaW5lX2ludGVycG9sYXRpb25fdHlwZTogPFNwbGluZVR5cGVzPiBcImNhcmRpbmFsXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZG9udXQgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGRvbnV0IG9wdGlvbnNcclxuICAgICAqIEBuYW1lIGRvbnV0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RvbnV0LmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGVhY2ggZG9udXQgcGllY2UuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZG9udXQubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZWFjaCBkb251dCBwaWVjZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQubGFiZWwudGhyZXNob2xkPTAuMDVdIFNldCB0aHJlc2hvbGQgdG8gc2hvdy9oaWRlIGxhYmVscy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9ufSBbZG9udXQubGFiZWwucmF0aW89dW5kZWZpbmVkXSBTZXQgcmF0aW8gb2YgbGFiZWxzIHBvc2l0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZG9udXQuZXhwYW5kPXRydWVdIEVuYWJsZSBvciBkaXNhYmxlIGV4cGFuZGluZyBkb251dCBwaWVjZXMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2RvbnV0LmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQuZXhwYW5kLmR1cmF0aW9uPTUwXSBTZXQgZXhwYW5kIHRyYW5zaXRpb24gdGltZSBpbiBtcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQud2lkdGhdIFNldCB3aWR0aCBvZiBkb251dCBjaGFydC5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZG9udXQudGl0bGU9XCJcIl0gU2V0IHRpdGxlIG9mIGRvbnV0IGNoYXJ0LiBVc2UgYFxcbmAgY2hhcmFjdGVyIHRvIGVudGVyIGxpbmUgYnJlYWsuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2RvbnV0LnBhZEFuZ2xlPTBdIFNldCBwYWRkaW5nIGJldHdlZW4gZGF0YS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQuc3RhcnRpbmdBbmdsZT0wXSBTZXQgc3RhcnRpbmcgYW5nbGUgd2hlcmUgZGF0YSBkcmF3cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgZG9udXQ6IHtcclxuICAgICAqICAgICAgbGFiZWw6IHtcclxuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkKSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdChcIiRcIikodmFsdWUpO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxyXG4gICAgICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICB0aHJlc2hvbGQ6IDAuMSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcclxuICAgICAqICAgICAgICAgIHJhdGlvOiBmdW5jdGlvbihkLCByYWRpdXMsIGgpIHtcclxuICAgICAqICAgICAgICAgIFx0Li4uXHJcbiAgICAgKiAgICAgICAgICBcdHJldHVybiByYXRpbztcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAvLyBvciBzZXQgcmF0aW8gbnVtYmVyXHJcbiAgICAgKiAgICAgICAgICByYXRpbzogMC41XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBkaXNhYmxlIGV4cGFuZCB0cmFuc2l0aW9uIGZvciBpbnRlcmFjdGlvblxyXG4gICAgICogICAgICBleHBhbmQ6IGZhbHNlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgZXhwYW5kOiB7XHJcbiAgICAgKiAgICAgIFx0Ly8gc2V0IGR1cmF0aW9uIG9mIGV4cGFuZCB0cmFuc2l0aW9uIHRvIDUwMG1zLlxyXG4gICAgICogICAgICAgICAgZHVyYXRpb246IDUwMCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0Ly8gc2V0IGV4cGFuZCBhcmVhIHJhdGVcclxuICAgICAqICAgICAgICAgIHJhdGU6IDFcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIHdpZHRoOiAxMCxcclxuICAgICAqICAgICAgcGFkQW5nbGU6IDAuMixcclxuICAgICAqICAgICAgc3RhcnRpbmdBbmdsZTogMSxcclxuICAgICAqICAgICAgdGl0bGU6IFwiRG9udXQgVGl0bGVcIlxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gdGl0bGUgd2l0aCBsaW5lIGJyZWFrXHJcbiAgICAgKiAgICAgIHRpdGxlOiBcIlRpdGxlMVxcblRpdGxlMlwiXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBkb251dF9sYWJlbF9zaG93OiB0cnVlLFxyXG4gICAgZG9udXRfbGFiZWxfZm9ybWF0OiA8KCgpID0+IG51bWJlcnxzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgZG9udXRfbGFiZWxfdGhyZXNob2xkOiAwLjA1LFxyXG4gICAgZG9udXRfbGFiZWxfcmF0aW86IDxudW1iZXJ8KCgpID0+IG51bWJlcil8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBkb251dF93aWR0aDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGRvbnV0X3RpdGxlOiBcIlwiLFxyXG4gICAgZG9udXRfZXhwYW5kOiA8Ym9vbGVhbnx7cmF0ZT86IG51bWJlcjsgZHVyYXRpb24/OiBudW1iZXI7fT4ge30sXHJcbiAgICBkb251dF9leHBhbmRfcmF0ZTogMC45OCxcclxuICAgIGRvbnV0X2V4cGFuZF9kdXJhdGlvbjogNTAsXHJcbiAgICBkb251dF9wYWRBbmdsZTogMCxcclxuICAgIGRvbnV0X3N0YXJ0aW5nQW5nbGU6IDBcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZ2F1Z2UgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGdhdWdlIG9wdGlvbnNcclxuICAgICAqIEBuYW1lIGdhdWdlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmZ1bGxDaXJjbGU9ZmFsc2VdIFNob3cgZnVsbCBjaXJjbGUgYXMgZG9udXQuIFdoZW4gc2V0IHRvICd0cnVlJywgdGhlIG1heCBsYWJlbCB3aWxsIG5vdCBiZSBzaG93ZWQgZHVlIHRvIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFyZSBzYW1lIGxvY2F0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2F1Z2UubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZ2F1Z2UuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZ2F1Z2UubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZ2F1Z2UuIExhYmVsIHRleHQgY2FuIGJlIG11bHRpbGluZWQgd2l0aCBgXFxuYCBjaGFyYWN0ZXIuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZ2F1Z2UubGFiZWwuZXh0ZW50c10gU2V0IGN1c3RvbWl6ZWQgbWluL21heCBsYWJlbCB0ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZ2F1Z2UuZXhwYW5kPXRydWVdIEVuYWJsZSBvciBkaXNhYmxlIGV4cGFuZGluZyBnYXVnZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2UuZXhwYW5kLnJhdGU9MC45OF0gU2V0IGV4cGFuZCByYXRlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5leHBhbmQuZHVyYXRpb249NTBdIFNldCB0aGUgZXhwYW5kIHRyYW5zaXRpb24gdGltZSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLm1pbj0wXSBTZXQgbWluIHZhbHVlIG9mIHRoZSBnYXVnZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2UubWF4PTEwMF0gU2V0IG1heCB2YWx1ZSBvZiB0aGUgZ2F1Z2UuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLnN0YXJ0aW5nQW5nbGU9LTEgKiBNYXRoLlBJIC8gMl0gU2V0IHN0YXJ0aW5nIGFuZ2xlIHdoZXJlIGRhdGEgZHJhd3MuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2dhdWdlLnRpdGxlPVwiXCJdIFNldCB0aXRsZSBvZiBnYXVnZSBjaGFydC4gVXNlIGBcXG5gIGNoYXJhY3RlciB0byBlbnRlciBsaW5lIGJyZWFrLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtnYXVnZS51bml0c10gU2V0IHVuaXRzIG9mIHRoZSBnYXVnZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2Uud2lkdGhdIFNldCB3aWR0aCBvZiBnYXVnZSBjaGFydC5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2F1Z2UudHlwZT1cInNpbmdsZVwiXSBTZXQgdHlwZSBvZiBnYXVnZSB0byBiZSBkaXNwbGF5ZWQuPGJyPjxicj5cclxuICAgICAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogLSBzaW5nbGVcclxuICAgICAqIC0gbXVsdGlcclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2F1Z2UuYXJjcy5taW5XaWR0aD01XSBTZXQgbWluaW1hbCB3aWR0aCBvZiBnYXVnZSBhcmNzIHVudGlsIHRoZSBpbm5lclJhZGl1cyBkaXNhcHBlYXJzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBnYXVnZToge1xyXG4gICAgICogICAgICBmdWxsQ2lyY2xlOiBmYWxzZSxcclxuICAgICAqICAgICAgbGFiZWw6IHtcclxuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8pIHtcclxuICAgICAqICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgICAgIC8vIHRvIG11bHRpbGluZSwgcmV0dXJuIHdpdGggJ1xcbicgY2hhcmFjdGVyXHJcbiAgICAgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlICtcIiVcXG5MaW5lMVxcbjJMaW5lMlwiO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIGV4dGVudHM6IGZ1bmN0aW9uKHZhbHVlLCBpc01heCkge1xyXG4gICAgICogICAgICAgICAgICAgIHJldHVybiAoaXNNYXggPyBcIk1heDpcIiA6IFwiTWluOlwiKSArIHZhbHVlO1xyXG4gICAgICogICAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZGlzYWJsZSBleHBhbmQgdHJhbnNpdGlvbiBmb3IgaW50ZXJhY3Rpb25cclxuICAgICAqICAgICAgZXhwYW5kOiBmYWxzZSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIGV4cGFuZDoge1xyXG4gICAgICogICAgICBcdC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cclxuICAgICAqICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdC8vIHNldCBleHBhbmQgYXJlYSByYXRlXHJcbiAgICAgKiAgICAgICAgICByYXRlOiAxXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBtaW46IC0xMDAsXHJcbiAgICAgKiAgICAgIG1heDogMjAwLFxyXG4gICAgICogICAgICB0eXBlOiBcInNpbmdsZVwiICAvLyBvciAnbXVsdGknXHJcbiAgICAgKiAgICAgIHRpdGxlOiBcIlRpdGxlIFRleHRcIixcclxuICAgICAqICAgICAgdW5pdHM6IFwiJVwiLFxyXG4gICAgICogICAgICB3aWR0aDogMTAsXHJcbiAgICAgKiAgICAgIGFyY3M6IHtcclxuICAgICAqICAgICAgICAgIG1pbldpZHRoOiA1XHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGdhdWdlX2Z1bGxDaXJjbGU6IGZhbHNlLFxyXG4gICAgZ2F1Z2VfbGFiZWxfc2hvdzogdHJ1ZSxcclxuICAgIGdhdWdlX2xhYmVsX2Zvcm1hdDogPCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgZ2F1Z2VfbGFiZWxfZXh0ZW50czogPCgoKSA9PiBzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgZ2F1Z2VfbWluOiAwLFxyXG4gICAgZ2F1Z2VfbWF4OiAxMDAsXHJcbiAgICBnYXVnZV90eXBlOiBcInNpbmdsZVwiLFxyXG4gICAgZ2F1Z2Vfc3RhcnRpbmdBbmdsZTogLTEgKiBNYXRoLlBJIC8gMixcclxuICAgIGdhdWdlX3RpdGxlOiBcIlwiLFxyXG4gICAgZ2F1Z2VfdW5pdHM6IDxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcbiAgICBnYXVnZV93aWR0aDogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuICAgIGdhdWdlX2FyY3NfbWluV2lkdGg6IDUsXHJcbiAgICBnYXVnZV9leHBhbmQ6IDxib29sZWFufHtkdXJhdGlvbjogbnVtYmVyfT4ge30sXHJcbiAgICBnYXVnZV9leHBhbmRfcmF0ZTogMC45OCxcclxuICAgIGdhdWdlX2V4cGFuZF9kdXJhdGlvbjogNTBcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogeCBBeGlzIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBwaWUgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgcGllXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3BpZS5sYWJlbC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtwaWUubGFiZWwuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZvciB0aGUgbGFiZWwgb24gZWFjaCBwaWUgcGllY2UuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtwaWUubGFiZWwucmF0aW89dW5kZWZpbmVkXSBTZXQgcmF0aW8gb2YgbGFiZWxzIHBvc2l0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW3BpZS5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIHBpZSBwaWVjZXMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5leHBhbmQucmF0ZT0wLjk4XSBTZXQgZXhwYW5kIHJhdGUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5leHBhbmQuZHVyYXRpb249NTBdIFNldCBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1zLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8T2JqZWN0fSBbcGllLmlubmVyUmFkaXVzPTBdIFNldHMgdGhlIGlubmVyIHJhZGl1cyBvZiBwaWUgYXJjLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaWUucGFkQW5nbGU9MF0gU2V0IHBhZGRpbmcgYmV0d2VlbiBkYXRhLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwaWUucGFkZGluZz0wXSBTZXRzIHRoZSBnYXAgYmV0d2VlbiBwaWUgYXJjcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQuc3RhcnRpbmdBbmdsZT0wXSBTZXQgc3RhcnRpbmcgYW5nbGUgd2hlcmUgZGF0YSBkcmF3cy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgcGllOiB7XHJcbiAgICAgKiAgICAgIGxhYmVsOiB7XHJcbiAgICAgKiAgICAgICAgICBzaG93OiBmYWxzZSxcclxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvLCBpZCkge1xyXG4gICAgICogICAgICAgICAgICAgIHJldHVybiBkMy5mb3JtYXQoXCIkXCIpKHZhbHVlKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAgICAgLy8gdG8gbXVsdGlsaW5lLCByZXR1cm4gd2l0aCAnXFxuJyBjaGFyYWN0ZXJcclxuICAgICAqICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgK1wiJVxcbkxpbmUxXFxuMkxpbmUyXCI7XHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgdGhyZXNob2xkOiAwLjEsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgLy8gc2V0IHJhdGlvIGNhbGxiYWNrLiBTaG91bGQgcmV0dXJuIHJhdGlvIHZhbHVlXHJcbiAgICAgKiAgICAgICAgICByYXRpbzogZnVuY3Rpb24oZCwgcmFkaXVzLCBoKSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHJhdGlvO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIC8vIG9yIHNldCByYXRpbyBudW1iZXJcclxuICAgICAqICAgICAgICAgIHJhdGlvOiAwLjVcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXHJcbiAgICAgKiAgICAgIGV4cGFuZDogZmFsc2UsXHJcbiAgICAgKlxyXG4gICAgICogICAgICBleHBhbmQ6IHtcclxuICAgICAqICAgICAgXHQvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXHJcbiAgICAgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxyXG4gICAgICpcclxuICAgICAqICAgICAgXHQvLyBzZXQgZXhwYW5kIGFyZWEgcmF0ZVxyXG4gICAgICogICAgICAgICAgcmF0ZTogMVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgaW5uZXJSYWRpdXM6IDAsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBzZXQgZGlmZmVyZW50IGlubmVyUmFkaXVzIGZvciBlYWNoIGRhdGFcclxuICAgICAqICAgICAgaW5uZXJSYWRpdXM6IHtcclxuICAgICAqICAgICAgXHRkYXRhMTogMTAsXHJcbiAgICAgKiAgICAgIFx0ZGF0YTI6IDBcclxuICAgICAqICAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAgcGFkQW5nbGU6IDAuMSxcclxuICAgICAqICAgICAgcGFkZGluZzogMCxcclxuICAgICAqICAgICAgc3RhcnRpbmdBbmdsZTogMVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgcGllX2xhYmVsX3Nob3c6IHRydWUsXHJcbiAgICBwaWVfbGFiZWxfZm9ybWF0OiA8KCgpID0+IG51bWJlcnxzdHJpbmcpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgcGllX2xhYmVsX3RocmVzaG9sZDogMC4wNSxcclxuICAgIHBpZV9sYWJlbF9yYXRpbzogPCgoKSA9PiBudW1iZXIpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgcGllX2V4cGFuZDogPGJvb2xlYW58e3JhdGU/OiBudW1iZXI7IGR1cmF0aW9uPzogbnVtYmVyO30+IHt9LFxyXG4gICAgcGllX2V4cGFuZF9yYXRlOiAwLjk4LFxyXG4gICAgcGllX2V4cGFuZF9kdXJhdGlvbjogNTAsXHJcbiAgICBwaWVfaW5uZXJSYWRpdXM6IDxudW1iZXJ8e1trZXk6IHN0cmluZ106IG51bWJlcn0+IDAsXHJcbiAgICBwaWVfcGFkQW5nbGU6IDAsXHJcbiAgICBwaWVfcGFkZGluZzogMCxcclxuICAgIHBpZV9zdGFydGluZ0FuZ2xlOiAwXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcmFkYXIgb3B0aW9uc1xyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrLlxyXG4gICAgICogQG5hbWUgcmFkYXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5heGlzLm1heD11bmRlZmluZWRdIFRoZSBtYXggdmFsdWUgb2YgYXhpcy4gSWYgbm90IGdpdmVuLCBpdCdsbCB0YWtlIHRoZSBtYXggdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gZGF0YS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmF4aXMubGluZS5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBheGlzIGxpbmUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3JhZGFyLmF4aXMudGV4dC5wb3NpdGlvbi54PTBdIHggY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxyXG4gICAgICogQHByb3BlcnR5IHtOVW1iZXJ9IFtyYWRhci5heGlzLnRleHQucG9zaXRpb24ueT0wXSB5IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmF4aXMudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBheGlzIHRleHQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5kaXJlY3Rpb24uY2xvY2t3aXNlPWZhbHNlXSBTZXQgdGhlIGRpcmVjdGlvbiB0byBiZSBkcmF3bi5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIubGV2ZWwuZGVwdGg9M10gU2V0IHRoZSBsZXZlbCBkZXB0aC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmxldmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxldmVsLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3JhZGFyLmxldmVsLnRleHQuZm9ybWF0PSh4KSA9PiAoeCAlIDEgPT09IDAgPyB4IDogeC50b0ZpeGVkKDIpKV0gU2V0IGZvcm1hdCBmdW5jdGlvbiBmb3IgdGhlIGxldmVsIHZhbHVlLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIubGV2ZWwudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZXZlbCB0ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5zaXplLnJhdGlvPTAuODddIFNldCBzaXplIHJhdGlvLlxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlJhZGFyQ2hhcnQpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiByYWRhciBheGlzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzKVxyXG4gICAgICogQHNlZSBbRGVtbzogcmFkYXIgbGV2ZWxdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckxldmVsKVxyXG4gICAgICogQHNlZSBbRGVtbzogcmFkYXIgc2l6ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyU2l6ZSlcclxuICAgICAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXMgbXVsdGlsaW5lXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzTXVsdGlsaW5lKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICByYWRhcjoge1xyXG4gICAgICogICAgICBheGlzOiB7XHJcbiAgICAgKiAgICAgICAgICBtYXg6IDUwLFxyXG4gICAgICogICAgICAgICAgbGluZToge1xyXG4gICAgICogICAgICAgICAgICAgIHNob3c6IGZhbHNlXHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgXHR4OiAwLFxyXG4gICAgICogICAgICAgICAgICAgIFx0eTogMFxyXG4gICAgICogICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgZGlyZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgbGV2ZWw6IHtcclxuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG4gICAgICogICAgICAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG4gICAgICogICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxyXG4gICAgICogICAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBzaXplOiB7XHJcbiAgICAgKiAgICAgICAgICByYXRpbzogMC43XHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHJhZGFyX2F4aXNfbWF4OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG4gICAgcmFkYXJfYXhpc19saW5lX3Nob3c6IHRydWUsXHJcbiAgICByYWRhcl9heGlzX3RleHRfc2hvdzogdHJ1ZSxcclxuICAgIHJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbjogPHt4PzogbnVtYmVyOyB5PzogbnVtYmVyO30+IHt9LFxyXG4gICAgcmFkYXJfbGV2ZWxfZGVwdGg6IDMsXHJcbiAgICByYWRhcl9sZXZlbF9zaG93OiB0cnVlLFxyXG4gICAgcmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQ6ICh4OiBudW1iZXIpID0+ICh4ICUgMSA9PT0gMCA/IHggOiB4LnRvRml4ZWQoMikpLFxyXG4gICAgcmFkYXJfbGV2ZWxfdGV4dF9zaG93OiB0cnVlLFxyXG4gICAgcmFkYXJfc2l6ZV9yYXRpbzogMC44NyxcclxuICAgIHJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLy8gY29tbW9uXHJcbmltcG9ydCBkYXRhIGZyb20gXCIuL2RhdGEvZGF0YVwiO1xyXG5pbXBvcnQgY29sb3IgZnJvbSBcIi4vY29tbW9uL2NvbG9yXCI7XHJcbmltcG9ydCBpbnRlcmFjdGlvbiBmcm9tIFwiLi9jb21tb24vaW50ZXJhY3Rpb25cIjtcclxuaW1wb3J0IGxlZ2VuZCBmcm9tIFwiLi9jb21tb24vbGVnZW5kXCI7XHJcbmltcG9ydCB0aXRsZSBmcm9tIFwiLi9jb21tb24vdGl0bGVcIjtcclxuaW1wb3J0IHRvb2x0aXAgZnJvbSBcIi4vY29tbW9uL3Rvb2x0aXBcIjtcclxuXHJcbi8vIEF4aXMgYmFzZWRcclxuaW1wb3J0IGRhdGFBeGlzIGZyb20gXCIuL2RhdGEvYXhpc1wiO1xyXG5pbXBvcnQgZGF0YVNlbGVjdGlvbiBmcm9tIFwiLi9kYXRhL3NlbGVjdGlvblwiO1xyXG5pbXBvcnQgYXhpcyBmcm9tIFwiLi9heGlzL2F4aXNcIjtcclxuaW1wb3J0IGdyaWQgZnJvbSBcIi4vY29tbW9uL2dyaWRcIjtcclxuaW1wb3J0IHBvaW50IGZyb20gXCIuL2NvbW1vbi9wb2ludFwiO1xyXG5pbXBvcnQgc3ViY2hhcnQgZnJvbSBcIi4vY29tbW9uL3N1YmNoYXJ0XCI7XHJcbmltcG9ydCB6b29tIGZyb20gXCIuL2NvbW1vbi96b29tXCI7XHJcblxyXG5pbXBvcnQgYXJlYSBmcm9tIFwiLi9zaGFwZS9hcmVhXCI7XHJcbmltcG9ydCBiYXIgZnJvbSBcIi4vc2hhcGUvYmFyXCI7XHJcbmltcG9ydCBidWJibGUgZnJvbSBcIi4vc2hhcGUvYnViYmxlXCI7XHJcbmltcG9ydCBsaW5lIGZyb20gXCIuL3NoYXBlL2xpbmVcIjtcclxuaW1wb3J0IHNwbGluZSBmcm9tIFwiLi9zaGFwZS9zcGxpbmVcIjtcclxuXHJcbi8vIE5vbi1BeGlzIGJhc2VkXHJcbmltcG9ydCBkb251dCBmcm9tIFwiLi9zaGFwZS9kb251dFwiO1xyXG5pbXBvcnQgZ2F1Z2UgZnJvbSBcIi4vc2hhcGUvZ2F1Z2VcIjtcclxuaW1wb3J0IHBpZSBmcm9tIFwiLi9zaGFwZS9waWVcIjtcclxuaW1wb3J0IHJhZGFyIGZyb20gXCIuL3NoYXBlL3JhZGFyXCI7XHJcblxyXG5pbXBvcnQge21lcmdlT2JqfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0byBzZXQgb3B0aW9ucyBvbiBnZW5lcmF0aW5nIGNoYXJ0LlxyXG4gKiAtIEl0J3MgaW5zdGFudGlhdGVkIGludGVybmFsbHksIG5vdCBleHBvc2VkIGZvciBwdWJsaWMuXHJcbiAqIEBjbGFzcyBPcHRpb25zXHJcbiAqIEBzZWUge0BsaW5rIGJiLmdlbmVyYXRlfSB0byB1c2UgdGhlc2Ugb3B0aW9ucyBvbiBnZW5lcmF0aW5nIHRoZSBjaGFydFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3B0aW9ucyB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRjb25zdCBhcmNTaGFwZUNvbmZpZyA9IFtkb251dCwgZ2F1Z2UsIHBpZSwgcmFkYXJdO1xyXG5cclxuXHRcdGNvbnN0IGF4aXNDb25maWcgPSBbZGF0YUF4aXMsIGRhdGFTZWxlY3Rpb24sIGF4aXMsIGdyaWQsIHBvaW50LCBzdWJjaGFydCwgem9vbV07XHJcblx0XHRjb25zdCBheGlzU2hhcGVDb25maWcgPSBbYXJlYSwgYmFyLCBidWJibGUsIGxpbmUsIHNwbGluZV07XHJcblxyXG5cdFx0Y29uc3QgY29uZmlnID0gW1xyXG5cdFx0XHRkYXRhLFxyXG5cdFx0XHRjb2xvcixcclxuXHRcdFx0aW50ZXJhY3Rpb24sXHJcblx0XHRcdGxlZ2VuZCxcclxuXHRcdFx0dGl0bGUsXHJcblx0XHRcdHRvb2x0aXAsXHJcblx0XHRcdC4uLmFyY1NoYXBlQ29uZmlnLFxyXG5cdFx0XHQuLi5heGlzQ29uZmlnLFxyXG5cdFx0XHQuLi5heGlzU2hhcGVDb25maWdcclxuXHRcdF07XHJcblxyXG5cdFx0cmV0dXJuIG1lcmdlT2JqKHtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNwZWNpZnkgdGhlIENTUyBzZWxlY3RvciBvciB0aGUgZWxlbWVudCB3aGljaCB0aGUgY2hhcnQgd2lsbCBiZSBzZXQgdG8uIEQzIHNlbGVjdGlvbiBvYmplY3QgY2FuIGJlIHNwZWNpZmllZCBhbHNvLjxicj5cclxuXHRcdFx0ICogSWYgb3RoZXIgY2hhcnQgaXMgc2V0IGFscmVhZHksIGl0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IG9uZSAob25seSBvbmUgY2hhcnQgY2FuIGJlIHNldCBpbiBvbmUgZWxlbWVudCkuXHJcblx0XHRcdCAqIC0gKipOT1RFOioqIEluIGNhc2Ugb2YgZWxlbWVudCBkb2Vzbid0IGV4aXN0IG9yIG5vdCBzcGVjaWZpZWQsIHdpbGwgYWRkIGEgYDxkaXY+YCBlbGVtZW50IHRvIHRoZSBib2R5LlxyXG5cdFx0XHQgKiBAbmFtZSBiaW5kdG9cclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBiaW5kdG89I2NoYXJ0IFNwZWNpZnkgdGhlIGVsZW1lbnQgd2hlcmUgY2hhcnQgd2lsbCBiZSBkcmF3bi5cclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBiaW5kdG8uZWxlbWVudD0jY2hhcnQgU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW2JpbmR0by5jbGFzc25hbWU9YmJdIFNwZWNpZnkgdGhlIGNsYXNzIG5hbWUgb2YgYmluZCBlbGVtZW50Ljxicj5cclxuXHRcdFx0ICogICAgICoqTk9URToqKiBXaGVuIGNsYXNzIG5hbWUgaXNuJ3QgYGJiYCwgdGhlbiB5b3UgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgZGVmYXVsdCBDU1MgdG8gYmUgcmVuZGVyZWQgY29ycmVjdGx5LlxyXG5cdFx0XHQgKiBAZGVmYXVsdCAjY2hhcnRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogYmluZHRvOiBcIiNteUNvbnRhaW5lclwiXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIC8vIG9yIEhUTUxFbGVtZW50XHJcblx0XHRcdCAqIGJpbmR0bzogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUNvbnRhaW5lclwiKVxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAvLyBvciBEMyBzZWxlY3Rpb24gb2JqZWN0XHJcblx0XHRcdCAqIGJpbmR0bzogZDMuc2VsZWN0KFwiI215Q29udGFpbmVyXCIpXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIC8vIG9yIHRvIGNoYW5nZSBkZWZhdWx0IGNsYXNzbmFtZVxyXG5cdFx0XHQgKiBiaW5kdG86IHtcclxuXHRcdFx0ICogICAgZWxlbWVudDogXCIjY2hhcnRcIixcclxuXHRcdFx0ICogICAgY2xhc3NuYW1lOiBcImJpbGwtYm9hcmRcIiAgLy8gZXgpIDxkaXYgaWQ9J2NoYXJ0JyBjbGFzcz0nYmlsbC1ib2FyZCc+XHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdGJpbmR0bzogPHN0cmluZ3x7ZWxlbWVudDogc3RyaW5nOyBjbGFzc25hbWU/OiBzdHJpbmd9PiBcIiNjaGFydFwiLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBjaGFydCBiYWNrZ3JvdW5kLlxyXG5cdFx0XHQgKiBAbmFtZSBiYWNrZ3JvdW5kXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBiYWNrZ3JvdW5kLmNsYXNzIFNwZWNpZnkgdGhlIGNsYXNzIG5hbWUgZm9yIGJhY2tncm91bmQgZWxlbWVudC5cclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IGJhY2tncm91bmQuY29sb3IgU3BlY2lmeSB0aGUgZmlsbCBjb2xvciBmb3IgYmFja2dyb3VuZCBlbGVtZW50Ljxicj4qKk5PVEU6KiogV2lsbCBiZSBpZ25vcmVkIGlmIGBpbWdVcmxgIG9wdGlvbiBpcyBzZXQuXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBiYWNrZ3JvdW5kLmltZ1VybCBTcGVjaWZ5IHRoZSBpbWFnZSB1cmwgc3RyaW5nIGZvciBiYWNrZ3JvdW5kLlxyXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkJhY2tncm91bmQpXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIGJhY2tncm91bmQ6IHtcclxuXHRcdFx0ICogICAgY2xhc3M6IFwibXlDbGFzc1wiLFxyXG5cdFx0XHQgKiAgICBjb2xvcjogXCJyZWRcIixcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogICAgLy8gU2V0IGltYWdlIHVybCBmb3IgYmFja2dyb3VuZC5cclxuXHRcdFx0ICogICAgLy8gSWYgc3BlY2lmaWVkLCAnY29sb3InIG9wdGlvbiB3aWxsIGJlIGlnbm9yZWQuXHJcblx0XHRcdCAqICAgIGltZ1VybDogXCJodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvaW1nL2xvZ28vYmlsbGJvYXJkLmpzLnN2Z1wiLFxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRiYWNrZ3JvdW5kOiA8e2NsYXNzPzogc3RyaW5nOyBjb2xvcj86IHN0cmluZzsgaW1nVXJsPzogc3RyaW5nO30+IHt9LFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGUgZm9yIGNoYXJ0IGVsZW1lbnRcclxuXHRcdFx0ICogLSAqKk5PVEU6KipcclxuXHRcdFx0ICogID4gV2hlbiBpcyBmYWxzZSwgY2hhcnQgbm9kZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQgYWZ0ZXIgdGhlIGF4aXMgbm9kZSBpbiBET00gdHJlZSBoaWVyYXJjaHkuXHJcblx0XHRcdCAqICA+IElzIHRvIG1ha2UgY2hhcnQgZWxlbWVudCBwb3NpdGlvbmVkIG92ZXIgYXhpcyBlbGVtZW50LlxyXG5cdFx0XHQgKiBAbmFtZSBjbGlwUGF0aFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7Qm9vbGVhbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdHJ1ZVxyXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLmNsaXBQYXRoKVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBkb24ndCBzZXQgJ2NsaXAtcGF0aCcgYXR0cmlidXRlXHJcblx0XHRcdCAqIGNsaXBQYXRoOiBmYWxzZVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0Y2xpcFBhdGg6IHRydWUsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IHN2ZyBlbGVtZW50J3MgY2xhc3MgbmFtZVxyXG5cdFx0XHQgKiBAbmFtZSBzdmdcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd9IFtzdmcuY2xhc3NuYW1lXSBjbGFzcyBuYW1lIGZvciBzdmcgZWxlbWVudFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBzdmc6IHtcclxuICAgICAgICAgICAgICogICBjbGFzc25hbWU6IFwidGVzdF9jbGFzc1wiXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHN2Z19jbGFzc25hbWU6IDxzdHJpbmd8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogVGhlIGRlc2lyZWQgc2l6ZSBvZiB0aGUgY2hhcnQgZWxlbWVudC5cclxuXHRcdFx0ICogSWYgdmFsdWUgaXMgbm90IHNwZWNpZmllZCwgdGhlIHdpZHRoIG9mIHRoZSBjaGFydCB3aWxsIGJlIGNhbGN1bGF0ZWQgYnkgdGhlIHNpemUgb2YgdGhlIHBhcmVudCBlbGVtZW50IGl0J3MgYXBwZW5kZWQgdG8uXHJcblx0XHRcdCAqIEBuYW1lIHNpemVcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzaXplLndpZHRoXSB3aWR0aCBvZiB0aGUgY2hhcnQgZWxlbWVudFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3NpemUuaGVpZ2h0XSBoZWlnaHQgb2YgdGhlIGNoYXJ0IGVsZW1lbnRcclxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5DaGFydFNpemUpXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHNpemU6IHtcclxuICAgICAgICAgICAgICogICB3aWR0aDogNjQwLFxyXG4gICAgICAgICAgICAgKiAgIGhlaWdodDogNDgwXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHNpemVfd2lkdGg6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0XHRcdHNpemVfaGVpZ2h0OiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFRoZSBwYWRkaW5nIG9mIHRoZSBjaGFydCBlbGVtZW50LlxyXG5cdFx0XHQgKiBAbmFtZSBwYWRkaW5nXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy50b3BdIHBhZGRpbmcgb24gdGhlIHRvcCBvZiBjaGFydFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BhZGRpbmcucmlnaHRdIHBhZGRpbmcgb24gdGhlIHJpZ2h0IG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5ib3R0b21dIHBhZGRpbmcgb24gdGhlIGJvdHRvbSBvZiBjaGFydFxyXG5cdFx0XHQgKiBAcHJvcGVydHkge051bWJlcn0gW3BhZGRpbmcubGVmdF0gcGFkZGluZyBvbiB0aGUgbGVmdCBvZiBjaGFydFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBwYWRkaW5nOiB7XHJcbiAgICAgICAgICAgICAqICAgdG9wOiAyMCxcclxuICAgICAgICAgICAgICogICByaWdodDogMjAsXHJcbiAgICAgICAgICAgICAqICAgYm90dG9tOiAyMCxcclxuICAgICAgICAgICAgICogICBsZWZ0OiAyMFxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRwYWRkaW5nX2xlZnQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0XHRcdHBhZGRpbmdfcmlnaHQ6IDxudW1iZXJ8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblx0XHRcdHBhZGRpbmdfdG9wOiA8bnVtYmVyfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cdFx0XHRwYWRkaW5nX2JvdHRvbTogPG51bWJlcnx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgY2hhcnQgcmVzaXplIG9wdGlvbnNcclxuXHRcdFx0ICogQG5hbWUgcmVzaXplXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3Jlc2l6ZS5hdXRvPXRydWVdIFNldCBjaGFydCByZXNpemUgYXV0b21hdGljYWxseSBvbiB2aWV3cG9ydCBjaGFuZ2VzLlxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAgcmVzaXplOiB7XHJcblx0XHRcdCAqICAgICAgYXV0bzogZmFsc2VcclxuXHRcdFx0ICogIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHJlc2l6ZV9hdXRvOiB0cnVlLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiBtb3VzZS90b3VjaCBlbnRlcnMgdGhlIGNoYXJ0LlxyXG5cdFx0XHQgKiBAbmFtZSBvbm92ZXJcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ub3ZlcjogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9ub3ZlcjogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggbGVhdmVzIHRoZSBjaGFydC5cclxuXHRcdFx0ICogQG5hbWUgb25vdXRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ub3V0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25vdXQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHVzZXIgcmVzaXplcyB0aGUgc2NyZWVuLlxyXG5cdFx0XHQgKiBAbmFtZSBvbnJlc2l6ZVxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25yZXNpemU6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbnJlc2l6ZTogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gc2NyZWVuIHJlc2l6ZSBmaW5pc2hlZC5cclxuXHRcdFx0ICogQG5hbWUgb25yZXNpemVkXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbnJlc2l6ZWQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbnJlc2l6ZWQ6IDwoKCkgPT4gdm9pZCl8dW5kZWZpbmVkPiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXHJcblx0XHRcdCAqIEBuYW1lIG9uYmVmb3JlaW5pdFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25iZWZvcmVpbml0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25iZWZvcmVpbml0OiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgY2hhcnQgaXMgaW5pdGlhbGl6ZWQuXHJcblx0XHRcdCAqIEBuYW1lIG9uaW5pdFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25pbml0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25pbml0OiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHRvIGV4ZWN1dGUgYWZ0ZXIgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXHJcblx0XHRcdCAqIEBuYW1lIG9uYWZ0ZXJpbml0XHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbmFmdGVyaW5pdDogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9uYWZ0ZXJpbml0OiA8KCgpID0+IHZvaWQpfHVuZGVmaW5lZD4gdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHJlbmRlcmVkLiBCYXNpY2FsbHksIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaW4gZWFjaCB0aW1lIHdoZW4gdGhlIGNoYXJ0IGlzIHJlZHJhd2VkLlxyXG5cdFx0XHQgKiBAbmFtZSBvbnJlbmRlcmVkXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbnJlbmRlcmVkOiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25yZW5kZXJlZDogPCgoKSA9PiB2b2lkKXx1bmRlZmluZWQ+IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgZHVyYXRpb24gb2YgdHJhbnNpdGlvbiAoaW4gbWlsbGlzZWNvbmRzKSBmb3IgY2hhcnQgYW5pbWF0aW9uLjxicj48YnI+XHJcblx0XHRcdCAqIC0gKipOT1RFOioqIElmIGAwIGBvciBgbnVsbGAgc2V0LCB0cmFuc2l0aW9uIHdpbGwgYmUgc2tpcHBlZC4gU28sIHRoaXMgbWFrZXMgaW5pdGlhbCByZW5kZXJpbmcgZmFzdGVyIGVzcGVjaWFsbHkgaW4gY2FzZSB5b3UgaGF2ZSBhIGxvdCBvZiBkYXRhLlxyXG5cdFx0XHQgKiBAbmFtZSB0cmFuc2l0aW9uXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdHJhbnNpdGlvbi5kdXJhdGlvbj0zNTBdIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kc1xyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiB0cmFuc2l0aW9uOiB7XHJcblx0XHRcdCAqICAgIGR1cmF0aW9uOiA1MDBcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dHJhbnNpdGlvbl9kdXJhdGlvbjogMzUwLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBzY2F0dGVyIG9wdGlvbnNcclxuXHRcdFx0ICogQG5hbWUgc2NhdHRlclxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzY2F0dGVyLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIHNjYXR0ZXIgY2hhcnQuXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICBzY2F0dGVyOiB7XHJcblx0XHRcdCAqICAgICAgY29ubmVjdE51bGw6IHRydWUsXHJcblx0XHRcdCAqICAgICAgc3RlcDoge1xyXG5cdFx0XHQgKiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxyXG5cdFx0XHQgKiAgICAgIH0sXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcclxuXHRcdFx0ICogICAgICBwb2ludDogZmFsc2UsXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcclxuXHRcdFx0ICogICAgICBwb2ludDogW1xyXG5cdFx0XHQgKiAgICAgICAgICBcImRhdGExXCIsIFwiZGF0YTNcIlxyXG5cdFx0XHQgKiAgICAgIF0sXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAgICAgemVyb2Jhc2VkOiBmYWxzZVxyXG5cdFx0XHQgKiAgfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0c2NhdHRlcl96ZXJvYmFzZWQ6IGZhbHNlLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBwbHVnaW5zXHJcblx0XHRcdCAqIEBuYW1lIHBsdWdpbnNcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0FycmF5fVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAgcGx1Z2luczogW1xyXG5cdFx0XHQgKiAgICBuZXcgYmIucGx1Z2luLnN0YW5mb3JkKHsgLi4uIH0pLFxyXG5cdFx0XHQgKiAgICBuZXcgUGx1Z2luQSgpLFxyXG5cdFx0XHQgKiAgICAuLi5cclxuXHRcdFx0ICogXVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0cGx1Z2luczogW10sXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogQ29udHJvbCB0aGUgcmVuZGVyIHRpbWluZ1xyXG5cdFx0XHQgKiBAbmFtZSByZW5kZXJcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtCb29sZWFufSBbcmVuZGVyLmxhenk9dHJ1ZV0gTWFrZSB0byBub3QgcmVuZGVyIGF0IGluaXRpYWxpemF0aW9uIChlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBiaW5kIGVsZW1lbnQncyB2aXNpYmlsaXR5IGlzIGhpZGRlbikuXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlbmRlci5vYnNlcnZlPXRydWVdIE9ic2VydmUgYmluZCBlbGVtZW50J3MgdmlzaWJpbGl0eShgZGlzcGxheWAgb3IgYHZpc2libGl0eWAgaW5saW5lIGNzcyBwcm9wZXJ0eSBvciBjbGFzcyB2YWx1ZSkgJiByZW5kZXIgd2hlbiBpcyB2aXNpYmxlIGF1dG9tYXRpY2FsbHkgKGZvciBJRXMsIG9ubHkgd29ya3MgSUUxMSspLiBXaGVuIHNldCB0byAqKmZhbHNlKiosIGNhbGwgW2AuZmx1c2goKWBdKC4vQ2hhcnQuaHRtbCNmbHVzaCkgdG8gcmVuZGVyLlxyXG5cdFx0XHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnRPcHRpb25zLkxhenlSZW5kZXIpXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICByZW5kZXI6IHtcclxuXHRcdFx0ICogICAgbGF6eTogdHJ1ZSxcclxuXHRcdFx0ICogICAgb2JzZXJ2ZTogdHJ1ZVxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqXHQvLyA8IS0tIHJlbmRlci5sYXp5IHdpbGwgZGV0ZWN0IHZpc2liaWxpdHkgZGVmaW5lZCAtLT5cclxuXHRcdFx0ICogIC8vIChhKSA8ZGl2IGlkPSdjaGFydCcgY2xhc3M9J2hpZGUnPjwvZGl2PlxyXG5cdFx0XHQgKiAgLy8gKGIpIDxkaXYgaWQ9J2NoYXJ0JyBzdHlsZT0nZGlzcGxheTpub25lJz48L2Rpdj5cclxuXHRcdFx0ICpcclxuXHRcdFx0ICogIC8vIHJlbmRlci5sYXp5IGVuYWJsZWQgYnkgZGVmYXVsdCB3aGVuIGVsZW1lbnQgaXMgaGlkZGVuXHJcblx0XHRcdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7IC4uLiB9KTtcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogIC8vIGNoYXJ0IHdpbGwgYmUgcmVuZGVyZWQgYXV0b21hdGljYWxseSB3aGVuIGVsZW1lbnQncyB2aXNpYmlsaXR5IGNoYW5nZXNcclxuXHRcdFx0ICogIC8vIE5vdGU6IHdvcmtzIG9ubHkgZm9yIGlubGluZWQgY3NzIHByb3BlcnR5IG9yIGNsYXNzIGF0dHJpYnV0ZSBjaGFuZ2VzXHJcblx0XHRcdCAqICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2hhcnQnKS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlJykgIC8vIChhKVxyXG5cdFx0XHQgKiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0Jykuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7ICAvLyAoYilcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICpcdC8vIGNoYXJ0IHdvbid0IGJlIHJlbmRlcmVkIGFuZCBub3Qgb2JzZXJ2aW5nIGJpbmQgZWxlbWVudCdzIHZpc2libGl0eSBjaGFuZ2VzXHJcblx0XHRcdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XHJcblx0XHRcdCAqICAgICByZW5kZXI6IHtcclxuXHRcdFx0ICogICAgICAgICAgbGF6eTogdHJ1ZSxcclxuXHRcdFx0ICogICAgICAgICAgb2JzZXJ2ZTogZmFsc2VcclxuXHRcdFx0ICogICAgIH1cclxuXHRcdFx0ICogIH0pO1xyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAgLy8gY2FsbCBhdCBhbnkgcG9pbnQgd2hlbiB5b3Ugd2FudCB0byByZW5kZXJcclxuXHRcdFx0ICogIGNoYXJ0LmZsdXNoKCk7XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRyZW5kZXI6IDx7bGF6eT86IGJvb2xlYW47IG9ic2VydmU/OiBib29sZWFuO30+IHt9LFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNob3cgcmVjdGFuZ2xlcyBpbnNpZGUgdGhlIGNoYXJ0Ljxicj48YnI+XHJcblx0XHRcdCAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyBheGlzLCBzdGFydCwgZW5kIGFuZCBjbGFzcy5cclxuXHRcdFx0ICogVGhlIGtleXMgc3RhcnQsIGVuZCBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLlxyXG5cdFx0XHQgKiBheGlzIG11c3QgYmUgeCwgeSBvciB5Mi4gc3RhcnQgYW5kIGVuZCBzaG91bGQgYmUgdGhlIHZhbHVlIHdoZXJlIHJlZ2lvbnMgc3RhcnQgYW5kIGVuZC5cclxuXHRcdFx0ICogSWYgbm90IHNwZWNpZmllZCwgdGhlIGVkZ2UgdmFsdWVzIHdpbGwgYmUgdXNlZC5cclxuXHRcdFx0ICogSWYgdGltZXNlcmllcyB4IGF4aXMsIGRhdGUgc3RyaW5nLCBEYXRlIG9iamVjdCBhbmQgdW5peHRpbWUgaW50ZWdlciBjYW4gYmUgdXNlZC5cclxuXHRcdFx0ICogSWYgY2xhc3MgaXMgc2V0LCB0aGUgcmVnaW9uIGVsZW1lbnQgd2lsbCBoYXZlIGl0IGFzIGNsYXNzLlxyXG5cdFx0XHQgKiBAbmFtZSByZWdpb25zXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cclxuXHRcdFx0ICogQGRlZmF1bHQgW11cclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogIHJlZ2lvbnM6IFtcclxuXHRcdFx0ICogICAge1xyXG5cdFx0XHQgKiAgICAgIGF4aXM6IFwieFwiLFxyXG5cdFx0XHQgKiAgICAgIHN0YXJ0OiAxLFxyXG5cdFx0XHQgKiAgICAgIGVuZDogNCxcclxuXHRcdFx0ICogICAgICBjbGFzczogXCJyZWdpb24tMS00XCJcclxuXHRcdFx0ICogICAgfVxyXG5cdFx0XHQgKiAgXVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0cmVnaW9uczogPHtheGlzPzogc3RyaW5nOyBzdGFydD86IG51bWJlcjsgZW5kPzogbnVtYmVyOyBjbGFzcz86IHN0cmluZzt9W10+IFtdXHJcblx0XHR9LCAuLi5jb25maWcpO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7dG9BcnJheX0gZnJvbSBcIi4vdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2FjaGUge1xyXG5cdHByaXZhdGUgY2FjaGUgPSB7fTtcclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGNhY2hlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGtleVxyXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzRGF0YVR5cGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGFkZChrZXk6IHN0cmluZywgdmFsdWUsIGlzRGF0YVR5cGUgPSBmYWxzZSkge1xyXG5cdFx0dGhpcy5jYWNoZVtrZXldID0gaXNEYXRhVHlwZSA/IHRoaXMuY2xvbmVUYXJnZXQodmFsdWUpIDogdmFsdWU7XHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZVtrZXldO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGNhY2hlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVtb3ZlKGtleTogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdHRvQXJyYXkoa2V5KS5mb3JFYWNoKHYgPT4gZGVsZXRlIHRoaXMuY2FjaGVbdl0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGNhaGNlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEYXRhVHlwZVxyXG5cdCAqIEByZXR1cm4geyp9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXQoa2V5LCBpc0RhdGFUeXBlID0gZmFsc2UpIHtcclxuXHRcdGlmIChpc0RhdGFUeXBlKSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWQ7IChpZCA9IGtleVtpXSk7IGkrKykge1xyXG5cdFx0XHRcdGlmIChpZCBpbiB0aGlzLmNhY2hlKSB7XHJcblx0XHRcdFx0XHR0YXJnZXRzLnB1c2godGhpcy5jbG9uZVRhcmdldCh0aGlzLmNhY2hlW2lkXSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZVtrZXldIHx8IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiByZXNldCBjYWNoZWQgZGF0YVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsIHRydWU6IHJlc2V0IGFsbCBkYXRhLCBmYWxzZTogcmVzZXQgb25seSAnJCcgcHJlZml4ZWQga2V5IGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG4gXHQgKi9cclxuXHRyZXNldChhbGw/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Zm9yIChjb25zdCB4IGluICQkLmNhY2hlKSB7XHJcblx0XHRcdC8vIHJlc2V0IHRoZSBwcmVmaXhlZCAnJCcga2V5KHdoaWNoIGlzIGludGVybmFsIHVzZSBkYXRhKSBvbmx5LlxyXG5cdFx0XHRpZiAoYWxsIHx8IC9eXFwkLy50ZXN0KHgpKSB7XHJcblx0XHRcdFx0JCQuY2FjaGVbeF0gPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRjbG9uZVRhcmdldCh0YXJnZXQpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGlkOiB0YXJnZXQuaWQsXHJcblx0XHRcdGlkX29yZzogdGFyZ2V0LmlkX29yZyxcclxuXHRcdFx0dmFsdWVzOiB0YXJnZXQudmFsdWVzLm1hcChkID0+ICh7eDogZC54LCB2YWx1ZTogZC52YWx1ZSwgaWQ6IGQuaWR9KSlcclxuXHRcdH07XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge3NjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJ9IGZyb20gXCJkMy1zY2FsZVwiO1xyXG5pbXBvcnQge2lzRGVmaW5lZCwgaXNOdW1iZXIsIGlzU3RyaW5nfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNSZW5kZXJlckhlbHBlciB7XHJcblx0cHJpdmF0ZSBvd25lcjtcclxuXHRwcml2YXRlIGNvbmZpZztcclxuXHRwcml2YXRlIHNjYWxlO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihvd25lcikge1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSBkM1NjYWxlTGluZWFyKCk7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBwYXJhbXN9ID0gb3duZXI7XHJcblxyXG5cdFx0dGhpcy5vd25lciA9IG93bmVyO1xyXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWc7XHJcblx0XHR0aGlzLnNjYWxlID0gc2NhbGU7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5ub1RyYW5zaXRpb24gfHwgIXBhcmFtcy5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbikge1xyXG5cdFx0XHRjb25maWcud2l0aG91dFRyYW5zaXRpb24gPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCByYW5nZVxyXG5cdFx0Y29uZmlnLnJhbmdlID0gdGhpcy5zY2FsZUV4dGVudCgocGFyYW1zLm9yZ1hTY2FsZSB8fCBzY2FsZSkucmFuZ2UoKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIGEgY2hhcmFjdGVyIGRpbWVuc2lvblxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBub2RlXHJcblx0ICogQHJldHVybiB7e3c6IG51bWJlciwgaDogbnVtYmVyfX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRTaXplRm9yMUNoYXIobm9kZSkge1xyXG5cdFx0Ly8gZGVmYXVsdCBzaXplIGZvciBvbmUgY2hhcmFjdGVyXHJcblx0XHRjb25zdCBzaXplID0ge1xyXG5cdFx0XHR3OiA1LjUsXHJcblx0XHRcdGg6IDExLjVcclxuXHRcdH07XHJcblxyXG5cdFx0IW5vZGUuZW1wdHkoKSAmJiBub2RlLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LnRleHQoXCIwXCIpXHJcblx0XHRcdC5jYWxsKGVsID0+IHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWwubm9kZSgpLmdldEJCb3goKTtcclxuXHJcblx0XHRcdFx0XHRpZiAod2lkdGggJiYgaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdHNpemUudyA9IHdpZHRoO1xyXG5cdFx0XHRcdFx0XHRzaXplLmggPSBoZWlnaHQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZWwudGV4dChcIlwiKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmdldFNpemVGb3IxQ2hhciA9ICgpID0+IHNpemU7XHJcblxyXG5cdFx0cmV0dXJuIHNpemU7XHJcblx0fVxyXG5cclxuXHRheGlzWChzZWxlY3Rpb24sIHgpIHtcclxuXHRcdHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgke01hdGguY2VpbCh4KGQpICsgdGhpcy5jb25maWcudGlja09mZnNldCl9LDApYCk7XHJcblx0fVxyXG5cclxuXHRheGlzWShzZWxlY3Rpb24sIHkpIHtcclxuXHRcdHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgwLCR7TWF0aC5jZWlsKHkoZCkpfSlgKTtcclxuXHR9XHJcblxyXG5cdHNjYWxlRXh0ZW50KGRvbWFpbikge1xyXG5cdFx0Y29uc3Qgc3RhcnQgPSBkb21haW5bMF07XHJcblx0XHRjb25zdCBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcclxuXHJcblx0XHRyZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRpY2tzKHNjYWxlLCBpc1lBeGVzKSB7XHJcblx0XHRjb25zdCB7dGlja1N0ZXBTaXplfSA9IHRoaXMub3duZXIucGFyYW1zO1xyXG5cdFx0bGV0IHRpY2tzID0gW107XHJcblxyXG5cdFx0Ly8gV2hlbiAnYXhpc1t5fHkyXS50aWNrLnN0ZXBTaXplJyBvcHRpb24gaXMgc2V0XHJcblx0XHRpZiAoaXNZQXhlcyAmJiB0aWNrU3RlcFNpemUpIHtcclxuXHRcdFx0Y29uc3QgW3N0YXJ0LCBlbmRdID0gc2NhbGUuZG9tYWluKCk7XHJcblx0XHRcdGxldCBpbnRlcnZhbCA9IHN0YXJ0O1xyXG5cclxuXHRcdFx0d2hpbGUgKGludGVydmFsIDw9IGVuZCkge1xyXG5cdFx0XHRcdHRpY2tzLnB1c2goaW50ZXJ2YWwpO1xyXG5cdFx0XHRcdGludGVydmFsICs9IHRpY2tTdGVwU2l6ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChzY2FsZS50aWNrcykge1xyXG5cdFx0XHR0aWNrcyA9IHNjYWxlLnRpY2tzKFxyXG5cdFx0XHRcdC4uLih0aGlzLmNvbmZpZy50aWNrQXJndW1lbnRzIHx8IFtdKVxyXG5cdFx0XHQpLm1hcCh2ID0+IChcclxuXHRcdFx0XHQvLyByb3VuZCB0aGUgdGljayB2YWx1ZSBpZiBpcyBudW1iZXJcclxuXHRcdFx0XHQoaXNTdHJpbmcodikgJiYgaXNOdW1iZXIodikgJiYgIWlzTmFOKHYpICYmXHJcblx0XHRcdFx0XHRNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMFxyXG5cdFx0XHRcdCkgfHwgdlxyXG5cdFx0XHQpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IE1hdGguY2VpbChkb21haW5bMF0pOyBpIDwgZG9tYWluWzFdOyBpKyspIHtcclxuXHRcdFx0XHR0aWNrcy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID4gMCAmJiB0aWNrc1swXSA+IDApIHtcclxuXHRcdFx0XHR0aWNrcy51bnNoaWZ0KHRpY2tzWzBdIC0gKHRpY2tzWzFdIC0gdGlja3NbMF0pKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWNrcztcclxuXHR9XHJcblxyXG5cdGNvcHlTY2FsZSgpIHtcclxuXHRcdGNvbnN0IG5ld1NjYWxlID0gdGhpcy5zY2FsZS5jb3B5KCk7XHJcblxyXG5cdFx0aWYgKCFuZXdTY2FsZS5kb21haW4oKS5sZW5ndGgpIHtcclxuXHRcdFx0bmV3U2NhbGUuZG9tYWluKHRoaXMuc2NhbGUuZG9tYWluKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdTY2FsZTtcclxuXHR9XHJcblxyXG5cdHRleHRGb3JtYXR0ZWQodikge1xyXG5cdFx0Y29uc3QgdGlja0Zvcm1hdCA9IHRoaXMuY29uZmlnLnRpY2tGb3JtYXQ7XHJcblxyXG5cdFx0Ly8gdG8gcm91bmQgZmxvYXQgbnVtYmVycyBmcm9tICdiaW5hcnkgZmxvYXRpbmcgcG9pbnQnXHJcblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibGUtcHJlY2lzaW9uX2Zsb2F0aW5nLXBvaW50X2Zvcm1hdFxyXG5cdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4NDkxMDEvbGF5bWFucy1leHBsYW5hdGlvbi1mb3Itd2h5LWphdmFzY3JpcHQtaGFzLXdlaXJkLWZsb2F0aW5nLW1hdGgtaWVlZS03NTQtc3RhbmRcclxuXHRcdGNvbnN0IHZhbHVlID0gL1xcZCtcXC5cXGQrMHs1LH1cXGQkLy50ZXN0KHYpID8gK1N0cmluZyh2KS5yZXBsYWNlKC8wK1xcZCQvLCBcIlwiKSA6IHY7XHJcblx0XHRjb25zdCBmb3JtYXR0ZWQgPSB0aWNrRm9ybWF0ID8gdGlja0Zvcm1hdCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKGZvcm1hdHRlZCkgPyBmb3JtYXR0ZWQgOiBcIlwiO1xyXG5cdH1cclxuXHJcblx0dHJhbnNpdGlvbmlzZShzZWxlY3Rpb24pIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLndpdGhvdXRUcmFuc2l0aW9uID9cclxuXHRcdFx0c2VsZWN0aW9uLmludGVycnVwdCgpIDogc2VsZWN0aW9uLnRyYW5zaXRpb24oY29uZmlnLnRyYW5zaXRpb24pO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IEhlbHBlciBmcm9tIFwiLi9BeGlzUmVuZGVyZXJIZWxwZXJcIjtcclxuaW1wb3J0IHtpc0FycmF5LCB0b0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXJ9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwidHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNSZW5kZXJlciB7XHJcblx0aGVscGVyO1xyXG5cdGNvbmZpZztcclxuXHRwYXJhbXM7XHJcblx0ZztcclxuXHJcblx0Y29uc3RydWN0b3IocGFyYW1zOiBhbnkgPSB7fSkge1xyXG5cdFx0Y29uc3QgY29uZmlnID0ge1xyXG5cdFx0XHRpbm5lclRpY2tTaXplOiA2LFxyXG5cdFx0XHRvdXRlclRpY2tTaXplOiBwYXJhbXMub3V0ZXJUaWNrID8gNiA6IDAsXHJcblx0XHRcdG9yaWVudDogXCJib3R0b21cIixcclxuXHRcdFx0cmFuZ2U6IFtdLFxyXG5cdFx0XHR0aWNrQXJndW1lbnRzOiBudWxsLFxyXG5cdFx0XHR0aWNrQ2VudGVyZWQ6IG51bGwsXHJcblx0XHRcdHRpY2tDdWxsaW5nOiB0cnVlLFxyXG5cdFx0XHR0aWNrRm9ybWF0OiBudWxsLFxyXG5cdFx0XHR0aWNrTGVuZ3RoOiA5LFxyXG5cdFx0XHR0aWNrT2Zmc2V0OiAwLFxyXG5cdFx0XHR0aWNrUGFkZGluZzogMyxcclxuXHRcdFx0dGlja1ZhbHVlczogbnVsbCxcclxuXHRcdFx0dHJhbnNpdGlvbjogbnVsbCxcclxuXHRcdFx0bm9UcmFuc2l0aW9uOiBwYXJhbXMubm9UcmFuc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbmZpZy50aWNrTGVuZ3RoID0gTWF0aC5tYXgoY29uZmlnLmlubmVyVGlja1NpemUsIDApICsgY29uZmlnLnRpY2tQYWRkaW5nO1xyXG5cclxuXHRcdHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cdFx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0XHR0aGlzLmhlbHBlciA9IG5ldyBIZWxwZXIodGhpcyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgYXhpcyBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNyZWF0ZShnOiBkM1NlbGVjdGlvbikge1xyXG5cdFx0Y29uc3QgY3R4ID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHBhcmFtcywgaGVscGVyOiBoZWxwZXJJbnN0fSA9IHRoaXM7XHJcblx0XHRjb25zdCBzY2FsZSA9IGhlbHBlckluc3Quc2NhbGU7XHJcblx0XHRjb25zdCBvcmllbnQgPSBjb25maWcub3JpZW50O1xyXG5cdFx0Y29uc3Qgc3BsaXRUaWNrVGV4dCA9IHRoaXMuc3BsaXRUaWNrVGV4dC5iaW5kKHRoaXMpO1xyXG5cdFx0Y29uc3QgaXNMZWZ0UmlnaHQgPSAvXihsZWZ0fHJpZ2h0KSQvLnRlc3Qob3JpZW50KTtcclxuXHRcdGNvbnN0IGlzVG9wQm90dG9tID0gL14odG9wfGJvdHRvbSkkLy50ZXN0KG9yaWVudCk7XHJcblxyXG5cdFx0Ly8gbGluZS90ZXh0IGVudGVyIGFuZCBwYXRoIHVwZGF0ZVxyXG5cdFx0Y29uc3QgdGlja1RyYW5zZm9ybSA9IGhlbHBlckluc3RbaXNUb3BCb3R0b20gPyBcImF4aXNYXCIgOiBcImF4aXNZXCJdO1xyXG5cdFx0Y29uc3QgYXhpc1B4ID0gdGlja1RyYW5zZm9ybSA9PT0gaGVscGVySW5zdC5heGlzWCA/IFwieVwiIDogXCJ4XCI7XHJcblx0XHRjb25zdCBzaWduID0gL14odG9wfGxlZnQpJC8udGVzdChvcmllbnQpID8gLTEgOiAxO1xyXG5cclxuXHRcdC8vIHRpY2sgdGV4dCBoZWxwZXJzXHJcblx0XHRjb25zdCByb3RhdGUgPSBwYXJhbXMudGlja1RleHRSb3RhdGU7XHJcblxyXG5cdFx0dGhpcy5jb25maWcucmFuZ2UgPSBzY2FsZS5yYW5nZUV4dGVudCA/XHJcblx0XHRcdHNjYWxlLnJhbmdlRXh0ZW50KCkgOlxyXG5cdFx0XHRoZWxwZXJJbnN0LnNjYWxlRXh0ZW50KChwYXJhbXMub3JnWFNjYWxlIHx8IHNjYWxlKS5yYW5nZSgpKTtcclxuXHJcblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgdGlja0xlbmd0aCwgcmFuZ2V9ID0gY29uZmlnO1xyXG5cclxuXHRcdC8vIC8vIGdldCB0aGUgYXhpcycgdGljayBwb3NpdGlvbiBjb25maWd1cmF0aW9uXHJcblx0XHRjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XHJcblx0XHRjb25zdCB0aWNrVGV4dFBvcyA9IG5hbWUgJiYgL14oeHx5fHkyKSQvLnRlc3QobmFtZSkgP1xyXG5cdFx0XHRwYXJhbXMuY29uZmlnW2BheGlzXyR7bmFtZX1fdGlja190ZXh0X3Bvc2l0aW9uYF0gOiB7eDogMCwgeTogMH07XHJcblxyXG5cdFx0Ly8gdGljayB2aXNpYmxpdHlcclxuXHRcdGNvbnN0IHByZWZpeCA9IG5hbWUgPT09IFwic3ViWFwiID8gYHN1YmNoYXJ0X2F4aXNfeGAgOiBgYXhpc18ke25hbWV9YDtcclxuXHRcdGNvbnN0IGF4aXNTaG93ID0gcGFyYW1zLmNvbmZpZ1tgJHtwcmVmaXh9X3Nob3dgXTtcclxuXHRcdGNvbnN0IHRpY2tTaG93ID0ge1xyXG5cdFx0XHR0aWNrOiBheGlzU2hvdyA/IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV90aWNrX3Nob3dgXSA6IGZhbHNlLFxyXG5cdFx0XHR0ZXh0OiBheGlzU2hvdyA/IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV90aWNrX3RleHRfc2hvd2BdIDogZmFsc2VcclxuXHRcdH07XHJcblxyXG5cdFx0bGV0ICRnO1xyXG5cclxuXHRcdGcuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgZyA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRsZXQgc2NhbGUwID0gdGhpcy5fX2NoYXJ0X18gfHwgc2NhbGU7XHJcblx0XHRcdGxldCBzY2FsZTEgPSBoZWxwZXJJbnN0LmNvcHlTY2FsZSgpO1xyXG5cclxuXHRcdFx0JGcgPSBnO1xyXG5cdFx0XHR0aGlzLl9fY2hhcnRfXyA9IHNjYWxlMTtcclxuXHJcblx0XHRcdGNvbmZpZy50aWNrT2Zmc2V0ID0gcGFyYW1zLmlzQ2F0ZWdvcnkgP1xyXG5cdFx0XHRcdE1hdGguY2VpbCgoc2NhbGUxKDEpIC0gc2NhbGUxKDApKSAvIDIpIDogMDtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb24gLSBkYXRhIGpvaW5cclxuXHRcdFx0Y29uc3QgcGF0aCA9IGcuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFswXSk7XHJcblxyXG5cdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cclxuXHRcdFx0cGF0aC5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpXHJcblx0XHRcdFx0Lm1lcmdlKGhlbHBlckluc3QudHJhbnNpdGlvbmlzZShwYXRoKSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3Qgb3V0ZXJUaWNrU2l6ZWQgPSBjb25maWcub3V0ZXJUaWNrU2l6ZSAqIHNpZ247XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGlzVG9wQm90dG9tID9cclxuXHRcdFx0XHRcdFx0YE0ke3JhbmdlWzBdfSwke291dGVyVGlja1NpemVkfVYwSCR7cmFuZ2VbMV19ViR7b3V0ZXJUaWNrU2l6ZWR9YCA6XHJcblx0XHRcdFx0XHRcdGBNJHtvdXRlclRpY2tTaXplZH0sJHtyYW5nZVswXX1IMFYke3JhbmdlWzFdfUgke291dGVyVGlja1NpemVkfWA7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAodGlja1Nob3cudGljayB8fCB0aWNrU2hvdy50ZXh0KSB7XHJcblx0XHRcdFx0Ly8gY291bnQgb2YgdGljayBkYXRhIGluIGFycmF5XHJcblx0XHRcdFx0Y29uc3QgdGlja3MgPSBjb25maWcudGlja1ZhbHVlcyB8fCBoZWxwZXJJbnN0LmdlbmVyYXRlVGlja3Moc2NhbGUxLCBpc0xlZnRSaWdodCk7XHJcblxyXG5cdFx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb25cclxuXHRcdFx0XHRsZXQgdGljazogZDNTZWxlY3Rpb24gPSBnLnNlbGVjdEFsbChcIi50aWNrXCIpXHJcblx0XHRcdFx0XHQuZGF0YSh0aWNrcywgc2NhbGUxKTtcclxuXHJcblx0XHRcdFx0Ly8gZW50ZXIgc2VsZWN0aW9uXHJcblx0XHRcdFx0Y29uc3QgdGlja0VudGVyID0gdGlja1xyXG5cdFx0XHRcdFx0LmVudGVyKClcclxuXHRcdFx0XHRcdC5pbnNlcnQoXCJnXCIsIFwiLmRvbWFpblwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIilcclxuXHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cclxuXHRcdFx0XHQvLyBNRU1POiBObyBleGl0IHRyYW5zaXRpb24uIFRoZSByZWFzb24gaXMgdGhpcyB0cmFuc2l0aW9uIGFmZmVjdHMgbWF4IHRpY2sgd2lkdGggY2FsY3VsYXRpb24gYmVjYXVzZSBvbGQgdGljayB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSB0aWNrcy5cclxuXHRcdFx0XHRjb25zdCB0aWNrRXhpdCA9IHRpY2suZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cclxuXHRcdFx0XHR0aWNrID0gdGlja0VudGVyLm1lcmdlKHRpY2spO1xyXG5cclxuXHRcdFx0XHR0aWNrU2hvdy50aWNrICYmIHRpY2tFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xyXG5cdFx0XHRcdHRpY2tTaG93LnRleHQgJiYgdGlja0VudGVyLmFwcGVuZChcInRleHRcIik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNpemVGb3IxQ2hhciA9IEhlbHBlci5nZXRTaXplRm9yMUNoYXIodGljayk7XHJcblx0XHRcdFx0Y29uc3QgY291bnRzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRsZXQgdHNwYW46IGQzU2VsZWN0aW9uID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKFwidHNwYW5cIilcclxuXHRcdFx0XHRcdC5kYXRhKChkLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzcGxpdCA9IHBhcmFtcy50aWNrTXVsdGlsaW5lID9cclxuXHRcdFx0XHRcdFx0XHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlMSwgdGlja3MsIGlzTGVmdFJpZ2h0LCBzaXplRm9yMUNoYXIudykgOiAoXHJcblx0XHRcdFx0XHRcdFx0XHRpc0FycmF5KGhlbHBlckluc3QudGV4dEZvcm1hdHRlZChkKSkgP1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWxwZXJJbnN0LnRleHRGb3JtYXR0ZWQoZCkuY29uY2F0KCkgOiBbaGVscGVySW5zdC50ZXh0Rm9ybWF0dGVkKGQpXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRjb3VudHNbaW5kZXhdID0gc3BsaXQubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHNwbGl0Lm1hcChzcGxpdHRlZCA9PiAoe2luZGV4LCBzcGxpdHRlZH0pKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0c3Bhbi5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRcdHRzcGFuID0gdHNwYW5cclxuXHRcdFx0XHRcdC5lbnRlcigpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwidHNwYW5cIilcclxuXHRcdFx0XHRcdC5tZXJnZSh0c3BhbilcclxuXHRcdFx0XHRcdC50ZXh0KGQgPT4gZC5zcGxpdHRlZCk7XHJcblxyXG5cdFx0XHRcdC8vIHNldCA8dHNwYW4+J3MgcG9zaXRpb25cclxuXHRcdFx0XHR0c3BhblxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIGlzVG9wQm90dG9tID8gMCA6IHRpY2tMZW5ndGggKiBzaWduKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCAoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgZHggPSAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKC8odG9wfGJvdHRvbSkvLnRlc3Qob3JpZW50KSAmJiByb3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0XHRkeCA9IDggKiBNYXRoLnNpbihNYXRoLlBJICogKHJvdGF0ZSAvIDE4MCkpICogKG9yaWVudCA9PT0gXCJ0b3BcIiA/IC0xIDogMSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBkeCArICh0aWNrVGV4dFBvcy54IHx8IDApO1xyXG5cdFx0XHRcdFx0fSkoKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgKGQsIGkpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZGVmVmFsdWUgPSBcIi43MWVtXCI7XHJcblx0XHRcdFx0XHRcdGxldCBkeTogbnVtYmVyIHwgc3RyaW5nID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChvcmllbnQgIT09IFwidG9wXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRkeSA9IHNpemVGb3IxQ2hhci5oO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZHkgPSBpc0xlZnRSaWdodCA/IC0oKGNvdW50c1tkLmluZGV4XSAtIDEpICogKHNpemVGb3IxQ2hhci5oIC8gMikgLSAzKSA6XHJcblx0XHRcdFx0XHRcdFx0XHRcdCh0aWNrVGV4dFBvcy55ID09PSAwID8gZGVmVmFsdWUgOiAwKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBpc051bWJlcihkeSkgJiYgdGlja1RleHRQb3MueSA/XHJcblx0XHRcdFx0XHRcdFx0ZHkgKyB0aWNrVGV4dFBvcy55IDogZHkgfHwgZGVmVmFsdWU7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Y29uc3QgbGluZVVwZGF0ZSA9IHRpY2suc2VsZWN0KFwibGluZVwiKTtcclxuXHRcdFx0XHRjb25zdCB0ZXh0VXBkYXRlID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpO1xyXG5cclxuXHRcdFx0XHR0aWNrRW50ZXIuc2VsZWN0KFwibGluZVwiKS5hdHRyKGAke2F4aXNQeH0yYCwgaW5uZXJUaWNrU2l6ZSAqIHNpZ24pO1xyXG5cdFx0XHRcdHRpY2tFbnRlci5zZWxlY3QoXCJ0ZXh0XCIpLmF0dHIoYCR7YXhpc1B4fWAsIHRpY2tMZW5ndGggKiBzaWduKTtcclxuXHJcblx0XHRcdFx0Y3R4LnNldFRpY2tMaW5lVGV4dFBvc2l0aW9uKGxpbmVVcGRhdGUsIHRleHRVcGRhdGUpO1xyXG5cclxuXHRcdFx0XHQvLyBBcHBlbmQgPHRpdGxlPiBmb3IgdG9vbHRpcCBkaXNwbGF5XHJcblx0XHRcdFx0cGFyYW1zLnRpY2tUaXRsZSAmJiB0ZXh0VXBkYXRlLmFwcGVuZCAmJiB0ZXh0VXBkYXRlLmFwcGVuZChcInRpdGxlXCIpXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS50ZXh0KHBhcmFtcy50aWNrVGl0bGVbaW5kZXhdKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAoc2NhbGUxLmJhbmR3aWR0aCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHNjYWxlMTtcclxuXHRcdFx0XHRcdGNvbnN0IGR4ID0geC5iYW5kd2lkdGgoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0c2NhbGUwID0gZCA9PiB4KGQpICsgZHg7XHJcblx0XHRcdFx0XHRzY2FsZTEgPSBzY2FsZTA7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChzY2FsZTAuYmFuZHdpZHRoKSB7XHJcblx0XHRcdFx0XHRzY2FsZTAgPSBzY2FsZTE7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCB0aWNrRXhpdCwgc2NhbGUxKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCB0aWNrRW50ZXIsIHNjYWxlMCk7XHJcblx0XHRcdFx0dGlja1RyYW5zZm9ybS5jYWxsKGhlbHBlckluc3QsIGhlbHBlckluc3QudHJhbnNpdGlvbmlzZSh0aWNrKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpLCBzY2FsZTEpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmcgPSAkZztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aWNrIHgveSBjb29yZGluYXRlXHJcblx0ICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRpY2tYWSgpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IHBvcyA9IHt4OiAwLCB5OiAwfTtcclxuXHJcblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRwb3MueCA9IGNvbmZpZy50aWNrQ2VudGVyZWQgPyAwIDogY29uZmlnLnRpY2tPZmZzZXQ7XHJcblx0XHRcdHBvcy55ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IGNvbmZpZy50aWNrT2Zmc2V0IDogMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9zO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgc2l6ZVxyXG5cdCAqIEBwYXJhbSBkXHJcblx0ICogQHJldHVybiB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VGlja1NpemUoZCkge1xyXG5cdFx0Y29uc3Qge3NjYWxlfSA9IHRoaXMuaGVscGVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2lubmVyVGlja1NpemUsIHJhbmdlfSA9IGNvbmZpZztcclxuXHJcblx0XHRjb25zdCB0aWNrUG9zaXRpb24gPSBzY2FsZShkKSArXHJcblx0XHRcdChjb25maWcudGlja0NlbnRlcmVkID8gMCA6IGNvbmZpZy50aWNrT2Zmc2V0KTtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2VbMF0gPCB0aWNrUG9zaXRpb24gJiYgdGlja1Bvc2l0aW9uIDwgcmFuZ2VbMV0gPyBpbm5lclRpY2tTaXplIDogMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aWNrJ3MgbGluZSAmIHRleHQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gbGluZVVwZGF0ZVxyXG5cdCAqIEBwYXJhbSB0ZXh0VXBkYXRlXHJcblx0ICogQHBhcmFtIHNjYWxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRUaWNrTGluZVRleHRQb3NpdGlvbihsaW5lVXBkYXRlLCB0ZXh0VXBkYXRlKSB7XHJcblx0XHRjb25zdCB0aWNrUG9zID0gdGhpcy5nZXRUaWNrWFkoKTtcclxuXHRcdGNvbnN0IHtpbm5lclRpY2tTaXplLCBvcmllbnQsIHRpY2tMZW5ndGgsIHRpY2tPZmZzZXR9ID0gdGhpcy5jb25maWc7XHJcblx0XHRjb25zdCByb3RhdGUgPSB0aGlzLnBhcmFtcy50aWNrVGV4dFJvdGF0ZTtcclxuXHJcblx0XHRjb25zdCB0ZXh0QW5jaG9yRm9yVGV4dCA9IHIgPT4ge1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IFtcInN0YXJ0XCIsIFwiZW5kXCJdO1xyXG5cclxuXHRcdFx0b3JpZW50ID09PSBcInRvcFwiICYmIHZhbHVlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdHJldHVybiAhciA/IFwibWlkZGxlXCIgOiAociA+IDAgPyB2YWx1ZVswXSA6IHZhbHVlWzFdKTtcclxuXHRcdH07XHJcblx0XHRjb25zdCB0ZXh0VHJhbnNmb3JtID0gciA9PiAociA/IGByb3RhdGUoJHtyfSlgIDogbnVsbCk7XHJcblx0XHRjb25zdCB5Rm9yVGV4dCA9IHIgPT4ge1xyXG5cdFx0XHRjb25zdCByMiA9IHIgLyAob3JpZW50ID09PSBcImJvdHRvbVwiID8gMTUgOiAyMyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gciA/IDExLjUgLSAyLjUgKiByMiAqIChyID4gMCA/IDEgOiAtMSkgOiB0aWNrTGVuZ3RoO1xyXG5cdFx0fTtcclxuXHJcblx0XHRzd2l0Y2ggKG9yaWVudCkge1xyXG5cdFx0XHRjYXNlIFwiYm90dG9tXCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB0aWNrUG9zLngpXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIHRpY2tQb3MueClcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGhpcy5nZXRUaWNrU2l6ZS5iaW5kKHRoaXMpKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIDApXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZvclRleHQocm90YXRlKSlcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwidG9wXCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAtaW5uZXJUaWNrU2l6ZSk7XHJcblxyXG5cdFx0XHRcdHRleHRVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIC15Rm9yVGV4dChyb3RhdGUpICogMilcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwibGVmdFwiOlxyXG5cdFx0XHRcdGxpbmVVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgLWlubmVyVGlja1NpemUpXHJcblx0XHRcdFx0XHQuYXR0cihcInkxXCIsIHRpY2tQb3MueSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGlja1Bvcy55KTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIC10aWNrTGVuZ3RoKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHRpY2tPZmZzZXQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInJpZ2h0XCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpbm5lclRpY2tTaXplKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAwKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHRpY2tMZW5ndGgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgMClcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwic3RhcnRcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyB0aGlzIHNob3VsZCBiZSBjYWxsZWQgb25seSB3aGVuIGNhdGVnb3J5IGF4aXNcclxuXHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlLCB0aWNrcywgaXNMZWZ0UmlnaHQsIGNoYXJXaWR0aCkge1xyXG5cdFx0Y29uc3Qge3BhcmFtc30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGlja1RleHQgPSB0aGlzLmhlbHBlci50ZXh0Rm9ybWF0dGVkKGQpO1xyXG5cdFx0Y29uc3Qgc3BsaXR0ZWQgPSBpc1N0cmluZyh0aWNrVGV4dCkgJiYgdGlja1RleHQuaW5kZXhPZihcIlxcblwiKSA+IC0xID9cclxuXHRcdFx0dGlja1RleHQuc3BsaXQoXCJcXG5cIikgOiBbXTtcclxuXHJcblx0XHRpZiAoc3BsaXR0ZWQubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBzcGxpdHRlZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNBcnJheSh0aWNrVGV4dCkpIHtcclxuXHRcdFx0cmV0dXJuIHRpY2tUZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0aWNrV2lkdGggPSBwYXJhbXMudGlja1dpZHRoO1xyXG5cclxuXHRcdGlmICghdGlja1dpZHRoIHx8IHRpY2tXaWR0aCA8PSAwKSB7XHJcblx0XHRcdHRpY2tXaWR0aCA9IGlzTGVmdFJpZ2h0ID8gOTUgOiAoXHJcblx0XHRcdFx0cGFyYW1zLmlzQ2F0ZWdvcnkgP1xyXG5cdFx0XHRcdFx0KE1hdGguY2VpbChzY2FsZSh0aWNrc1sxXSkgLSBzY2FsZSh0aWNrc1swXSkpIC0gMTIpIDogMTEwXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3BsaXQoc3BsaXR0ZWQsIHRleHQpIHtcclxuXHRcdFx0bGV0IHN1YnRleHQ7XHJcblx0XHRcdGxldCBzcGFjZUluZGV4O1xyXG5cdFx0XHRsZXQgdGV4dFdpZHRoO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHRleHQuY2hhckF0KGkpID09PSBcIiBcIikge1xyXG5cdFx0XHRcdFx0c3BhY2VJbmRleCA9IGk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdWJ0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaSArIDEpO1xyXG5cdFx0XHRcdHRleHRXaWR0aCA9IGNoYXJXaWR0aCAqIHN1YnRleHQubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0ZXh0IHdpZHRoIGdldHMgb3ZlciB0aWNrIHdpZHRoLCBzcGxpdCBieSBzcGFjZSBpbmRleCBvciBjdXJyZW50IGluZGV4XHJcblx0XHRcdFx0aWYgKHRpY2tXaWR0aCA8IHRleHRXaWR0aCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNwbGl0KFxyXG5cdFx0XHRcdFx0XHRzcGxpdHRlZC5jb25jYXQodGV4dC5zdWJzdHIoMCwgc3BhY2VJbmRleCB8fCBpKSksXHJcblx0XHRcdFx0XHRcdHRleHQuc2xpY2Uoc3BhY2VJbmRleCA/IHNwYWNlSW5kZXggKyAxIDogaSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQuY29uY2F0KHRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzcGxpdChzcGxpdHRlZCwgU3RyaW5nKHRpY2tUZXh0KSk7XHJcblx0fVxyXG5cclxuXHRzY2FsZSh4KSB7XHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaGVscGVyLnNjYWxlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuaGVscGVyLnNjYWxlID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdG9yaWVudCh4KSB7XHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLm9yaWVudDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNvbmZpZy5vcmllbnQgPSB4IGluIHtcclxuXHRcdFx0dG9wOiAxLFxyXG5cdFx0XHRyaWdodDogMSxcclxuXHRcdFx0Ym90dG9tOiAxLFxyXG5cdFx0XHRsZWZ0OiAxXHJcblx0XHR9ID8gU3RyaW5nKHgpIDogXCJib3R0b21cIjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tGb3JtYXQoZm9ybWF0KSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0Zvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcudGlja0Zvcm1hdCA9IGZvcm1hdDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tDZW50ZXJlZChpc0NlbnRlcmVkKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0NlbnRlcmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy50aWNrQ2VudGVyZWQgPSBpc0NlbnRlcmVkO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRpY2sncyBvZmZzZXQgdmFsdWUuXHJcblx0ICogVGhlIHZhbHVlIHdpbGwgYmUgc2V0IGZvciAnY2F0ZWdvcnknIGF4aXMgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0aWNrT2Zmc2V0KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLnRpY2tPZmZzZXQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGljayBpbnRlcnZhbCBjb3VudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVG90YWwgZGF0YSBzaXplXHJcblx0ICogQHJldHVybiB7bnVtYmVyfVxyXG5cdCAqL1xyXG5cdHRpY2tJbnRlcnZhbChzaXplKSB7XHJcblx0XHRsZXQgaW50ZXJ2YWw7XHJcblxyXG5cdFx0aWYgKHRoaXMucGFyYW1zLmlzQ2F0ZWdvcnkpIHtcclxuXHRcdFx0aW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy50aWNrT2Zmc2V0ICogMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMuZy5zZWxlY3QoXCJwYXRoLmRvbWFpblwiKVxyXG5cdFx0XHRcdC5ub2RlKClcclxuXHRcdFx0XHQuZ2V0VG90YWxMZW5ndGgoKSAtIHRoaXMuY29uZmlnLm91dGVyVGlja1NpemUgKiAyO1xyXG5cclxuXHRcdFx0aW50ZXJ2YWwgPSBsZW5ndGggLyAoc2l6ZSB8fCB0aGlzLmcuc2VsZWN0QWxsKFwibGluZVwiKS5zaXplKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnRlcnZhbCA9PT0gSW5maW5pdHkgPyAwIDogaW50ZXJ2YWw7XHJcblx0fVxyXG5cclxuXHR0aWNrcyguLi5hcmdzKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmdzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tBcmd1bWVudHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tBcmd1bWVudHMgPSB0b0FycmF5KGFyZ3MpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0dGlja0N1bGxpbmcoY3VsbGluZykge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tDdWxsaW5nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy50aWNrQ3VsbGluZyA9IGN1bGxpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHR0aWNrVmFsdWVzKHgpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoaXNGdW5jdGlvbih4KSkge1xyXG5cdFx0XHRjb25maWcudGlja1ZhbHVlcyA9ICgpID0+IHgodGhpcy5oZWxwZXIuc2NhbGUuZG9tYWluKCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrVmFsdWVzO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25maWcudGlja1ZhbHVlcyA9IHg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRzZXRUcmFuc2l0aW9uKHQpIHtcclxuXHRcdHRoaXMuY29uZmlnLnRyYW5zaXRpb24gPSB0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0YXhpc1RvcCBhcyBkM0F4aXNUb3AsXHJcblx0YXhpc0JvdHRvbSBhcyBkM0F4aXNCb3R0b20sXHJcblx0YXhpc0xlZnQgYXMgZDNBeGlzTGVmdCxcclxuXHRheGlzUmlnaHQgYXMgZDNBeGlzUmlnaHRcclxufSBmcm9tIFwiZDMtYXhpc1wiO1xyXG5pbXBvcnQgQXhpc1JlbmRlcmVyIGZyb20gXCIuL0F4aXNSZW5kZXJlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVmFsdWUsIGlzRW1wdHksIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIG1lcmdlT2JqLCBzb3J0VmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vQ2hhcnRJbnRlcm5hbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpcyB7XHJcblx0cHVibGljIG93bmVyOiBDaGFydEludGVybmFsO1xyXG5cdHByaXZhdGUgYXhlc0xpc3QgPSB7fTtcclxuXHRwdWJsaWMgdGljayA9IHtcclxuXHRcdHg6IG51bGwsIHk6IG51bGwsIHkyOiBudWxsXHJcblx0fTtcclxuXHRwdWJsaWMgeHMgPSBbXTtcclxuXHRwcml2YXRlIG9yaWVudCA9IHtcclxuXHRcdHg6IFwiYm90dG9tXCIsXHJcblx0XHR5OiBcImxlZnRcIixcclxuXHRcdHkyOiBcInJpZ2h0XCIsXHJcblx0XHRzdWJYOiBcImJvdHRvbVwiXHJcblx0fTtcclxuXHJcblx0Y29uc3RydWN0b3Iob3duZXIpIHtcclxuXHRcdHRoaXMub3duZXIgPSBvd25lcjtcclxuXHRcdHRoaXMuc2V0T3JpZW50KCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdldEF4aXNDbGFzc05hbWUoaWQpIHtcclxuXHRcdHJldHVybiBgJHtDTEFTUy5heGlzfSAke0NMQVNTW2BheGlzJHtjYXBpdGFsaXplKGlkKX1gXX1gXHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGlzSG9yaXpvbnRhbCgkJCwgZm9ySG9yaXpvbnRhbCkge1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQ7XHJcblx0fVxyXG5cclxuXHRpbml0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbiwgYXhpc30sIHN0YXRlOiB7Y2xpcH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gW1wieFwiLCBcInlcIl07XHJcblxyXG5cdFx0Y29uZmlnLmF4aXNfeTJfc2hvdyAmJiB0YXJnZXQucHVzaChcInkyXCIpO1xyXG5cclxuXHRcdHRhcmdldC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRjb25zdCBjbGFzc0F4aXMgPSB0aGlzLmdldEF4aXNDbGFzc05hbWUodik7XHJcblx0XHRcdGNvbnN0IGF4aXNJZCA9IHYudG9VcHBlckNhc2UoKTtcclxuXHRcdFx0Y29uc3QgY2xhc3NMYWJlbCA9IENMQVNTW2BheGlzJHtheGlzSWR9TGFiZWxgXTtcclxuXHJcblx0XHRcdGF4aXNbdl0gPSBtYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXhpcylcclxuXHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRsZXQgcmVzID0gbnVsbDtcclxuXHJcblx0XHRcdFx0XHRpZiAodiA9PT0gXCJ4XCIpIHtcclxuXHRcdFx0XHRcdFx0cmVzID0gY2xpcC5wYXRoWEF4aXM7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwieVwiICYmIGNvbmZpZy5heGlzX3lfaW5uZXIpIHtcclxuXHRcdFx0XHRcdFx0cmVzID0gY2xpcC5wYXRoWUF4aXM7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZSh2KSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZ1tgYXhpc18ke3Z9X3Nob3dgXSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIik7XHJcblxyXG5cdFx0XHRheGlzW3ZdLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTGFiZWwpXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgW1wicm90YXRlKC05MClcIiwgbnVsbF1bXHJcblx0XHRcdFx0XHR2ID09PSBcInhcIiA/ICshaXNSb3RhdGVkIDogK2lzUm90YXRlZFxyXG5cdFx0XHRcdF0pXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGhpc1tgdGV4dEFuY2hvckZvciR7YXhpc0lkfUF4aXNMYWJlbGBdLmJpbmQodGhpcykpO1xyXG5cclxuXHRcdFx0dGhpcy5nZW5lcmF0ZUF4ZXModik7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBheGlzIG9yaWVudCBhY2NvcmRpbmcgb3B0aW9uIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRPcmllbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGF4aXNfcm90YXRlZDogaXNSb3RhdGVkLFxyXG5cdFx0XHRheGlzX3lfaW5uZXI6IHlJbm5lcixcclxuXHRcdFx0YXhpc195Ml9pbm5lcjogeTJJbm5lclxyXG5cdFx0fSA9ICQkLmNvbmZpZztcclxuXHJcblx0XHR0aGlzLm9yaWVudCA9IHtcclxuXHRcdFx0eDogaXNSb3RhdGVkID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiLFxyXG5cdFx0XHR5OiBpc1JvdGF0ZWQgPyAoeUlubmVyID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIpIDogKHlJbm5lciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKSxcclxuXHRcdFx0eTI6IGlzUm90YXRlZCA/ICh5MklubmVyID8gXCJib3R0b21cIiA6IFwidG9wXCIpIDogKHkySW5uZXIgPyBcImxlZnRcIiA6IFwicmlnaHRcIiksXHJcblx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IFwibGVmdFwiIDogXCJib3R0b21cIlxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGF4ZXNcclxuXHQgKiBJdCdzIHVzZWQgd2hlbiBheGlzJyBheGVzIG9wdGlvbiBpcyBzZXRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgQXhpcyBpZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVBeGVzKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBheGVzOiBhbnlbXSA9IFtdO1xyXG5cdFx0Y29uc3QgYXhlc0NvbmZpZyA9IGNvbmZpZ1tgYXhpc18ke2lkfV9heGVzYF07XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IGQzQXhpcztcclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc0xlZnQgOiBkM0F4aXNCb3R0b207XHJcblx0XHR9IGVsc2UgaWYgKGlkID09PSBcInlcIikge1xyXG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNCb3R0b20gOiBkM0F4aXNMZWZ0O1xyXG5cdFx0fSBlbHNlIGlmIChpZCA9PT0gXCJ5MlwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc1RvcCA6IGQzQXhpc1JpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGVzQ29uZmlnLmxlbmd0aCkge1xyXG5cdFx0XHRheGVzQ29uZmlnLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdGljayA9IHYudGljayB8fCB7fTtcclxuXHRcdFx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlW2lkXS5jb3B5KCk7XHJcblxyXG5cdFx0XHRcdHYuZG9tYWluICYmIHNjYWxlLmRvbWFpbih2LmRvbWFpbik7XHJcblxyXG5cdFx0XHRcdGF4ZXMucHVzaChcclxuXHRcdFx0XHRcdGQzQXhpcyhzY2FsZSlcclxuXHRcdFx0XHRcdFx0LnRpY2tzKHRpY2suY291bnQpXHJcblx0XHRcdFx0XHRcdC50aWNrRm9ybWF0KHRpY2suZm9ybWF0IHx8ICgoeDogYW55KSA9PiB4KSlcclxuXHRcdFx0XHRcdFx0LnRpY2tWYWx1ZXModGljay52YWx1ZXMpXHJcblx0XHRcdFx0XHRcdC50aWNrU2l6ZU91dGVyKHRpY2sub3V0ZXIgPT09IGZhbHNlID8gMCA6IDYpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5heGVzTGlzdFtpZF0gPSBheGVzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGF4ZXMgbm9kZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUF4ZXMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLmF4ZXNMaXN0KS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uc3QgYXhlc0NvbmZpZyA9IGNvbmZpZ1tgYXhpc18ke2lkfV9heGVzYF07XHJcblx0XHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGVbaWRdLmNvcHkoKTtcclxuXHRcdFx0Y29uc3QgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5heGVzTGlzdFtpZF0uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGF4aXNSYW5nZSA9IHYuc2NhbGUoKS5yYW5nZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBhZGp1c3QgcmFuZ2UgdmFsdWUgd2l0aCB0aGUgY3VycmVudFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzg1OVxyXG5cdFx0XHRcdGlmICghcmFuZ2UuZXZlcnkoKHYsIGkpID0+IHYgPT09IGF4aXNSYW5nZVtpXSkpIHtcclxuXHRcdFx0XHRcdHYuc2NhbGUoKS5yYW5nZShyYW5nZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBjbGFzc05hbWUgPSBgJHt0aGlzLmdldEF4aXNDbGFzc05hbWUoaWQpfS0ke2kgKyAxfWA7XHJcblx0XHRcdFx0bGV0IGcgPSBtYWluLnNlbGVjdChgLiR7Y2xhc3NOYW1lLnJlcGxhY2UoL1xccy8sIFwiLlwiKX1gKTtcclxuXHJcblx0XHRcdFx0aWYgKGcuZW1wdHkoKSkge1xyXG5cdFx0XHRcdFx0ZyA9IG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcclxuXHRcdFx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKVxyXG5cdFx0XHRcdFx0XHQuY2FsbCh2KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YXhlc0NvbmZpZ1tpXS5kb21haW4gJiYgc2NhbGUuZG9tYWluKGF4ZXNDb25maWdbaV0uZG9tYWluKTtcclxuXHJcblx0XHRcdFx0XHQkJC5heGlzLnguaGVscGVyLnRyYW5zaXRpb25pc2UoZylcclxuXHRcdFx0XHRcdFx0LmNhbGwodi5zY2FsZShzY2FsZSkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShpZCwgaSArIDEpKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIGNhbGxlZCBmcm9tIDogdXBkYXRlU2NhbGVzKCkgJiBnZXRNYXhUaWNrV2lkdGgoKVxyXG5cdGdldEF4aXMobmFtZSwgc2NhbGUsIG91dGVyVGljaywgbm9UcmFuc2l0aW9uLCBub1RpY2tUZXh0Um90YXRlKTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1ggPSAvXih4fHN1YlgpJC8udGVzdChuYW1lKTtcclxuXHRcdGNvbnN0IHR5cGUgPSBpc1ggPyBcInhcIiA6IG5hbWU7XHJcblxyXG5cdFx0Y29uc3QgaXNDYXRlZ29yeSA9IGlzWCAmJiAkJC5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRjb25zdCBvcmllbnQgPSB0aGlzLm9yaWVudFtuYW1lXTtcclxuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSBpc1ggPyAkJC5mb3JtYXQueEF4aXNUaWNrIDogY29uZmlnW2BheGlzXyR7bmFtZX1fdGlja19mb3JtYXRgXTtcclxuXHRcdGxldCB0aWNrVmFsdWVzID0gJCQuYXhpcy50aWNrW3R5cGVdO1xyXG5cclxuXHRcdGNvbnN0IGF4aXNQYXJhbXMgPSBtZXJnZU9iaih7XHJcblx0XHRcdG91dGVyVGljayxcclxuXHRcdFx0bm9UcmFuc2l0aW9uLFxyXG5cdFx0XHRjb25maWcsXHJcblx0XHRcdG5hbWUsXHJcblx0XHRcdHRpY2tUZXh0Um90YXRlOiBub1RpY2tUZXh0Um90YXRlID8gMCA6IGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfcm90YXRlYF1cclxuXHRcdH0sIGlzWCAmJiB7XHJcblx0XHRcdGlzQ2F0ZWdvcnksXHJcblx0XHRcdHRpY2tNdWx0aWxpbmU6IGNvbmZpZy5heGlzX3hfdGlja19tdWx0aWxpbmUsXHJcblx0XHRcdHRpY2tXaWR0aDogY29uZmlnLmF4aXNfeF90aWNrX3dpZHRoLFxyXG5cdFx0XHR0aWNrVGl0bGU6IGlzQ2F0ZWdvcnkgJiYgY29uZmlnLmF4aXNfeF90aWNrX3Rvb2x0aXAgJiYgJCQuYXBpLmNhdGVnb3JpZXMoKSxcclxuXHRcdFx0b3JnWFNjYWxlOiAkJC5zY2FsZS54XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWlzWCkge1xyXG5cdFx0XHRheGlzUGFyYW1zLnRpY2tTdGVwU2l6ZSA9IGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfc3RlcFNpemVgXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBheGlzID0gbmV3IEF4aXNSZW5kZXJlcihheGlzUGFyYW1zKVxyXG5cdFx0XHQuc2NhbGUoKGlzWCAmJiAkJC5zY2FsZS56b29tKSB8fCBzY2FsZSlcclxuXHRcdFx0Lm9yaWVudChvcmllbnQpO1xyXG5cclxuXHRcdGlmIChpc1ggJiYgJCQuaXNUaW1lU2VyaWVzKCkgJiYgdGlja1ZhbHVlcyAmJiAhaXNGdW5jdGlvbih0aWNrVmFsdWVzKSkge1xyXG5cdFx0XHR0aWNrVmFsdWVzID0gdGlja1ZhbHVlcy5tYXAodiA9PiAkJC5wYXJzZURhdGUodikpO1xyXG5cdFx0fSBlbHNlIGlmICghaXNYICYmICQkLmlzVGltZVNlcmllc1koKSkge1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMvYmxvYi9tYXN0ZXIvQ0hBTkdFUy5tZCN0aW1lLWludGVydmFscy1kMy10aW1lXHJcblx0XHRcdGF4aXMudGlja3MoY29uZmlnLmF4aXNfeV90aWNrX3RpbWVfdmFsdWUpO1xyXG5cdFx0XHR0aWNrVmFsdWVzID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR0aWNrVmFsdWVzICYmIGF4aXMudGlja1ZhbHVlcyh0aWNrVmFsdWVzKTtcclxuXHJcblx0XHQvLyBTZXQgdGlja1xyXG5cdFx0YXhpcy50aWNrRm9ybWF0KFxyXG5cdFx0XHR0aWNrRm9ybWF0IHx8IChcclxuXHRcdFx0XHQhaXNYICYmICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpICYmICh4ID0+IGAke3h9JWApKVxyXG5cdFx0XHQpXHJcblx0XHQpO1xyXG5cclxuXHRcdGlmIChpc0NhdGVnb3J5KSB7XHJcblx0XHRcdGF4aXMudGlja0NlbnRlcmVkKGNvbmZpZy5heGlzX3hfdGlja19jZW50ZXJlZCk7XHJcblxyXG5cdFx0XHRpZiAoaXNFbXB0eShjb25maWcuYXhpc194X3RpY2tfY3VsbGluZykpIHtcclxuXHRcdFx0XHRjb25maWcuYXhpc194X3RpY2tfY3VsbGluZyA9IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnW2BheGlzXyR7dHlwZX1fdGlja19jb3VudGBdICYmIGF4aXMudGlja3MoY29uZmlnW2BheGlzXyR7dHlwZX1fdGlja19jb3VudGBdKTtcclxuXHJcblx0XHRyZXR1cm4gYXhpcztcclxuXHR9XHJcblxyXG5cdHVwZGF0ZVhBeGlzVGlja1ZhbHVlcyh0YXJnZXRzLCBheGlzPyk6IHN0cmluZ1tdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBmaXQgPSBjb25maWcuYXhpc194X3RpY2tfZml0O1xyXG5cdFx0Y29uc3QgY291bnQgPSBjb25maWcuYXhpc194X3RpY2tfY291bnQ7XHJcblx0XHRsZXQgdmFsdWVzO1xyXG5cclxuXHRcdGlmIChmaXQgfHwgKGNvdW50ICYmIGZpdCkpIHtcclxuXHRcdFx0dmFsdWVzID0gdGhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXMoXHJcblx0XHRcdFx0JCQubWFwVGFyZ2V0c1RvVW5pcXVlWHModGFyZ2V0cyksXHJcblx0XHRcdFx0Y291bnQsXHJcblx0XHRcdFx0JCQuaXNUaW1lU2VyaWVzKClcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYXhpcykge1xyXG5cdFx0XHRheGlzLnRpY2tWYWx1ZXModmFsdWVzKTtcclxuXHRcdH0gZWxzZSBpZiAoJCQuYXhpcy54KSB7XHJcblx0XHRcdCQkLmF4aXMueC50aWNrVmFsdWVzKHZhbHVlcyk7XHJcblx0XHRcdCQkLmF4aXMuc3ViWCAmJiAkJC5heGlzLnN1YlgudGlja1ZhbHVlcyh2YWx1ZXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fVxyXG5cclxuXHRnZXRJZChpZCkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gdGhpcy5vd25lcjtcclxuXHRcdGxldCBheGlzID0gY29uZmlnLmRhdGFfYXhlc1tpZF07XHJcblxyXG5cdFx0Ly8gd2hlbiBkYXRhLmF4ZXMgb3B0aW9uIGhhcyAneTInLCBidXQgJ2F4aXMueTIuc2hvdz10cnVlJyBpc24ndCBzZXQgd2lsbCByZXR1cm4gJ3knXHJcblx0XHRpZiAoIWF4aXMgfHwgIXNjYWxlW2F4aXNdKSB7XHJcblx0XHRcdGF4aXMgPSBcInlcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYXhpcztcclxuXHR9XHJcblxyXG5cdGdldFhBeGlzVGlja0Zvcm1hdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIGZvcm1hdH0gPSAkJDtcclxuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSBjb25maWcuYXhpc194X3RpY2tfZm9ybWF0O1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDYXRlZ29yaXplZCgpO1xyXG5cdFx0bGV0IGN1cnJGb3JtYXQ7XHJcblxyXG5cdFx0aWYgKHRpY2tGb3JtYXQpIHtcclxuXHRcdFx0aWYgKGlzRnVuY3Rpb24odGlja0Zvcm1hdCkpIHtcclxuXHRcdFx0XHRjdXJyRm9ybWF0ID0gdGlja0Zvcm1hdDtcclxuXHRcdFx0fSBlbHNlIGlmIChpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHRjdXJyRm9ybWF0ID0gZGF0ZSA9PiAoZGF0ZSA/IGZvcm1hdC5heGlzVGltZSh0aWNrRm9ybWF0KShkYXRlKSA6IFwiXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdXJyRm9ybWF0ID0gaXNUaW1lU2VyaWVzID8gZm9ybWF0LmRlZmF1bHRBeGlzVGltZSA6IChcclxuXHRcdFx0XHRpc0NhdGVnb3JpemVkID9cclxuXHRcdFx0XHRcdCQkLmNhdGVnb3J5TmFtZSA6IHYgPT4gKHYgPCAwID8gdi50b0ZpeGVkKDApIDogdilcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihjdXJyRm9ybWF0KSA/IHYgPT5cclxuXHRcdFx0Y3VyckZvcm1hdC5hcHBseSgkJCwgaXNDYXRlZ29yaXplZCA/XHJcblx0XHRcdFx0W3YsICQkLmNhdGVnb3J5TmFtZSh2KV0gOiBbdl1cclxuXHRcdFx0KSA6IGN1cnJGb3JtYXQ7XHJcblx0fVxyXG5cclxuXHRnZXRUaWNrVmFsdWVzKGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB0aWNrVmFsdWVzID0gJCQuY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfdmFsdWVzYF07XHJcblx0XHRjb25zdCBheGlzID0gJCRbYCR7aWR9QXhpc2BdO1xyXG5cclxuXHRcdHJldHVybiAoaXNGdW5jdGlvbih0aWNrVmFsdWVzKSA/IHRpY2tWYWx1ZXMoKSA6IHRpY2tWYWx1ZXMpIHx8XHJcblx0XHRcdChheGlzID8gYXhpcy50aWNrVmFsdWVzKCkgOiB1bmRlZmluZWQpO1xyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3duZXIuY29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF07XHJcblx0fVxyXG5cclxuXHRnZXRMYWJlbFRleHQoaWQpIHtcclxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XHJcblxyXG5cdFx0cmV0dXJuIGlzU3RyaW5nKG9wdGlvbikgPyBvcHRpb24gOiAoXHJcblx0XHRcdG9wdGlvbiA/IG9wdGlvbi50ZXh0IDogbnVsbFxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdHNldExhYmVsVGV4dChpZCwgdGV4dCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XHJcblxyXG5cdFx0aWYgKGlzU3RyaW5nKG9wdGlvbikpIHtcclxuXHRcdFx0Y29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF0gPSB0ZXh0O1xyXG5cdFx0fSBlbHNlIGlmIChvcHRpb24pIHtcclxuXHRcdFx0b3B0aW9uLnRleHQgPSB0ZXh0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxQb3NpdGlvbihpZCwgZGVmYXVsdFBvc2l0aW9uKSB7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLm93bmVyLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSAoaXNPYmplY3RUeXBlKG9wdGlvbikgJiYgb3B0aW9uLnBvc2l0aW9uKSA/XHJcblx0XHRcdG9wdGlvbi5wb3NpdGlvbiA6IGRlZmF1bHRQb3NpdGlvblsrIWlzUm90YXRlZF07XHJcblxyXG5cdFx0Y29uc3QgaGFzID0gdiA9PiAhIX5wb3NpdGlvbi5pbmRleE9mKHYpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGlzSW5uZXI6IGhhcyhcImlubmVyXCIpLFxyXG5cdFx0XHRpc091dGVyOiBoYXMoXCJvdXRlclwiKSxcclxuXHRcdFx0aXNMZWZ0OiBoYXMoXCJsZWZ0XCIpLFxyXG5cdFx0XHRpc0NlbnRlcjogaGFzKFwiY2VudGVyXCIpLFxyXG5cdFx0XHRpc1JpZ2h0OiBoYXMoXCJyaWdodFwiKSxcclxuXHRcdFx0aXNUb3A6IGhhcyhcInRvcFwiKSxcclxuXHRcdFx0aXNNaWRkbGU6IGhhcyhcIm1pZGRsZVwiKSxcclxuXHRcdFx0aXNCb3R0b206IGhhcyhcImJvdHRvbVwiKVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdGdldFhBeGlzTGFiZWxQb3NpdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldExhYmVsUG9zaXRpb24oXCJ4XCIsIFtcImlubmVyLXRvcFwiLCBcImlubmVyLXJpZ2h0XCJdKTtcclxuXHR9XHJcblxyXG5cdGdldFlBeGlzTGFiZWxQb3NpdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldExhYmVsUG9zaXRpb24oXCJ5XCIsIFtcImlubmVyLXJpZ2h0XCIsIFwiaW5uZXItdG9wXCJdKTtcclxuXHR9XHJcblxyXG5cdGdldFkyQXhpc0xhYmVsUG9zaXRpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKFwieTJcIiwgW1wiaW5uZXItcmlnaHRcIiwgXCJpbm5lci10b3BcIl0pO1xyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzW2BnZXQke2lkLnRvVXBwZXJDYXNlKCl9QXhpc0xhYmVsUG9zaXRpb25gXSgpO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvclhBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ4XCIpO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvcllBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ5XCIpO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvclkyQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxUZXh0KFwieTJcIik7XHJcblx0fVxyXG5cclxuXHR4Rm9yQXhpc0xhYmVsKHBvc2l0aW9uLCBmb3JIb3Jpem9udGFsID0gdHJ1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gJCQuc3RhdGU7XHJcblx0XHRsZXQgeCA9IHBvc2l0aW9uLmlzTWlkZGxlID8gLWhlaWdodCAvIDIgOiAwO1xyXG5cclxuXHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgkJCwgZm9ySG9yaXpvbnRhbCkpIHtcclxuXHRcdFx0eCA9IHBvc2l0aW9uLmlzTGVmdCA/IDAgOiAoXHJcblx0XHRcdFx0cG9zaXRpb24uaXNDZW50ZXIgPyB3aWR0aCAvIDIgOiB3aWR0aFxyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc0JvdHRvbSkge1xyXG5cdFx0XHR4ID0gLSQkLnN0YXRlLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblxyXG5cdGR4Rm9yQXhpc0xhYmVsKHBvc2l0aW9uLCBmb3JIb3Jpem9udGFsID0gdHJ1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0bGV0IGR4ID0gcG9zaXRpb24uaXNCb3R0b20gPyBcIjAuNWVtXCIgOiBcIjBcIjtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XHJcblx0XHRcdGR4ID0gcG9zaXRpb24uaXNMZWZ0ID8gXCIwLjVlbVwiIDogKFxyXG5cdFx0XHRcdHBvc2l0aW9uLmlzUmlnaHQgPyBcIi0wLjVlbVwiIDogXCIwXCJcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNUb3ApIHtcclxuXHRcdFx0ZHggPSBcIi0wLjVlbVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkeDtcclxuXHR9XHJcblxyXG5cdHRleHRBbmNob3JGb3JBeGlzTGFiZWwocG9zaXRpb24sIGZvckhvcml6b250YWwgPSB0cnVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRsZXQgYW5jaG9yID0gcG9zaXRpb24uaXNNaWRkbGUgPyBcIm1pZGRsZVwiIDogXCJlbmRcIjtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XHJcblx0XHRcdGFuY2hvciA9IHBvc2l0aW9uLmlzTGVmdCA/IFwic3RhcnRcIiA6IChcclxuXHRcdFx0XHRwb3NpdGlvbi5pc0NlbnRlciA/IFwibWlkZGxlXCIgOiBcImVuZFwiXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzQm90dG9tKSB7XHJcblx0XHRcdGFuY2hvciA9IFwic3RhcnRcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYW5jaG9yO1xyXG5cdH1cclxuXHJcblx0eEZvclhBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy54Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCksIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHhGb3JZQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMueEZvckF4aXNMYWJlbCh0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcclxuXHR9XHJcblxyXG5cdHhGb3JZMkF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnhGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xyXG5cdH1cclxuXHJcblx0ZHhGb3JYQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKSwgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0ZHhGb3JZQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRZQXhpc0xhYmVsUG9zaXRpb24oKSk7XHJcblx0fVxyXG5cclxuXHRkeEZvclkyQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xyXG5cdH1cclxuXHJcblx0ZHlGb3JYQXhpc0xhYmVsKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzSW5uZXIgPSB0aGlzLmdldFhBeGlzTGFiZWxQb3NpdGlvbigpLmlzSW5uZXI7XHJcblx0XHRjb25zdCB4SGVpZ2h0ID0gY29uZmlnLmF4aXNfeF9oZWlnaHQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIjEuMmVtXCIgOiAtMjUgLSB0aGlzLmdldE1heFRpY2tXaWR0aChcInhcIik7XHJcblx0XHR9IGVsc2UgaWYgKGlzSW5uZXIpIHtcclxuXHRcdFx0cmV0dXJuIFwiLTAuNWVtXCI7XHJcblx0XHR9IGVsc2UgaWYgKHhIZWlnaHQpIHtcclxuXHRcdFx0cmV0dXJuIHhIZWlnaHQgLSAxMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBcIjNlbVwiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZHlGb3JZQXhpc0xhYmVsKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3QgaXNJbm5lciA9IHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNJbm5lcjtcclxuXHJcblx0XHRpZiAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiLTAuNWVtXCIgOiBcIjNlbVwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIjEuMmVtXCIgOiAtMTAgLSAoJCQuY29uZmlnLmF4aXNfeV9pbm5lciA/IDAgOiAodGhpcy5nZXRNYXhUaWNrV2lkdGgoXCJ5XCIpICsgMTApKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGR5Rm9yWTJBeGlzTGFiZWwoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCBpc0lubmVyID0gdGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkuaXNJbm5lcjtcclxuXHJcblx0XHRpZiAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiMS4yZW1cIiA6IFwiLTIuMmVtXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiLTAuNWVtXCIgOiAxNSArICgkJC5jb25maWcuYXhpc195Ml9pbm5lciA/IDAgOiAodGhpcy5nZXRNYXhUaWNrV2lkdGgoXCJ5MlwiKSArIDE1KSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0ZXh0QW5jaG9yRm9yWEF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnRleHRBbmNob3JGb3JBeGlzTGFiZWwodGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKSwgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0dGV4dEFuY2hvckZvcllBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkpO1xyXG5cdH1cclxuXHJcblx0dGV4dEFuY2hvckZvclkyQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCh0aGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKSk7XHJcblx0fVxyXG5cclxuXHRnZXRNYXhUaWNrV2lkdGgoaWQ6IHN0cmluZywgd2l0aG91dFJlY29tcHV0ZT86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7c3ZnLCBjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyZW50VGlja01heCA9ICQkLnN0YXRlLmN1cnJlbnRNYXhUaWNrV2lkdGhzW2lkXTtcclxuXHRcdGxldCBtYXhXaWR0aCA9IDA7XHJcblxyXG5cdFx0aWYgKHdpdGhvdXRSZWNvbXB1dGUgfHwgIWNvbmZpZ1tgYXhpc18ke2lkfV9zaG93YF0pIHtcclxuXHRcdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRjb25zdCBpc1lBeGlzID0gL155Mj8kLy50ZXN0KGlkKTtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZVtpZF0uY29weSgpLmRvbWFpbigkJFtgZ2V0JHtpc1lBeGlzID8gXCJZXCIgOiBcIlhcIn1Eb21haW5gXSh0YXJnZXRzVG9TaG93LCBpZCkpO1xyXG5cdFx0XHRjb25zdCBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcclxuXHJcblx0XHRcdC8vIGRvIG5vdCBjb21wdXRlIGlmIGRvbWFpbiBpcyBzYW1lXHJcblx0XHRcdGlmIChpc0FycmF5KGN1cnJlbnRUaWNrTWF4LmRvbWFpbikgJiYgY3VycmVudFRpY2tNYXguZG9tYWluLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBkb21haW5baV0pKSB7XHJcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3VycmVudFRpY2tNYXguZG9tYWluID0gZG9tYWluO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBheGlzID0gdGhpcy5nZXRBeGlzKGlkLCBzY2FsZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcclxuXHRcdFx0Y29uc3QgdGlja0NvdW50ID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY291bnRgXTtcclxuXHJcblx0XHRcdC8vIE1ha2UgdG8gZ2VuZXJhdGUgdGhlIGZpbmFsIHRpY2sgdGV4dCB0byBiZSByZW5kZXJlZFxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy85MjBcclxuXHRcdFx0aWYgKHRpY2tDb3VudCkge1xyXG5cdFx0XHRcdGF4aXMudGlja1ZhbHVlcyhcclxuXHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0XHRkb21haW4sXHJcblx0XHRcdFx0XHRcdHRpY2tDb3VudCxcclxuXHRcdFx0XHRcdFx0aXNZQXhpcyA/ICQkLmlzVGltZVNlcmllc1koKSA6ICQkLmlzVGltZVNlcmllcygpXHJcblx0XHRcdFx0XHQpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0IWlzWUF4aXMgJiYgdGhpcy51cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0c1RvU2hvdywgYXhpcyk7XHJcblxyXG5cdFx0XHRjb25zdCBkdW1teSA9IGNoYXJ0LmFwcGVuZChcInN2Z1wiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0XHQuc3R5bGUoXCJwb3NpdGlvblwiLCBcImZpeGVkXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidG9wXCIsIFwiMHB4XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwibGVmdFwiLCBcIjBweFwiKTtcclxuXHJcblx0XHRcdGF4aXMuY3JlYXRlKGR1bW15KTtcclxuXHJcblx0XHRcdGR1bW15LnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZHVtbXkucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFdpZHRoID4gMCkge1xyXG5cdFx0XHRjdXJyZW50VGlja01heC5zaXplID0gbWF4V2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0fVxyXG5cclxuXHR1cGRhdGVMYWJlbHMod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHJcblx0XHRjb25zdCBsYWJlbHMgPSB7XHJcblx0XHRcdFg6IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH0gLiR7Q0xBU1MuYXhpc1hMYWJlbH1gKSxcclxuXHRcdFx0WTogbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZfSAuJHtDTEFTUy5heGlzWUxhYmVsfWApLFxyXG5cdFx0XHRZMjogbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZMn0gLiR7Q0xBU1MuYXhpc1kyTGFiZWx9YClcclxuXHRcdH07XHJcblxyXG5cdFx0T2JqZWN0LmtleXMobGFiZWxzKS5maWx0ZXIoaWQgPT4gIWxhYmVsc1tpZF0uZW1wdHkoKSlcclxuXHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGxhYmVsc1t2XTtcclxuXHRcdFx0XHRjb25zdCBheGlzTGFiZWwgPSBgJHt2fUF4aXNMYWJlbGA7XHJcblxyXG5cdFx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IG5vZGUudHJhbnNpdGlvbigpIDogbm9kZSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCB0aGlzW2B4Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgdGhpc1tgZHhGb3Ike2F4aXNMYWJlbH1gXS5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCB0aGlzW2BkeUZvciR7YXhpc0xhYmVsfWBdLmJpbmQodGhpcykpXHJcblx0XHRcdFx0XHQudGV4dCh0aGlzW2B0ZXh0Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Z2V0UGFkZGluZyhwYWRkaW5nLCBrZXksIGRlZmF1bHRWYWx1ZSwgZG9tYWluTGVuZ3RoKSB7XHJcblx0XHRjb25zdCBwID0gaXNOdW1iZXIocGFkZGluZykgPyBwYWRkaW5nIDogcGFkZGluZ1trZXldO1xyXG5cclxuXHRcdGlmICghaXNWYWx1ZShwKSkge1xyXG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKHAsIGRvbWFpbkxlbmd0aCk7XHJcblx0fVxyXG5cclxuXHRjb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhwaXhlbHMsIGRvbWFpbkxlbmd0aCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aWR0aCwgaGVpZ2h0fX0gPSAkJDtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyB3aWR0aCA6IGhlaWdodDtcclxuXHJcblx0XHRyZXR1cm4gZG9tYWluTGVuZ3RoICogKHBpeGVscyAvIGxlbmd0aCk7XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRpY2tWYWx1ZXModmFsdWVzLCB0aWNrQ291bnQsIGZvclRpbWVTZXJpZXMpIHtcclxuXHRcdGxldCB0aWNrVmFsdWVzID0gdmFsdWVzO1xyXG5cdFx0bGV0IHN0YXJ0O1xyXG5cdFx0bGV0IGVuZDtcclxuXHRcdGxldCBjb3VudDtcclxuXHRcdGxldCBpbnRlcnZhbDtcclxuXHRcdGxldCBpO1xyXG5cdFx0bGV0IHRpY2tWYWx1ZTtcclxuXHJcblx0XHRpZiAodGlja0NvdW50KSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldENvdW50ID0gaXNGdW5jdGlvbih0aWNrQ291bnQpID8gdGlja0NvdW50KCkgOiB0aWNrQ291bnQ7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHRpY2tzIGFjY29yZGluZyB0byB0aWNrQ291bnRcclxuXHRcdFx0aWYgKHRhcmdldENvdW50ID09PSAxKSB7XHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID09PSAyKSB7XHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF0sIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID4gMikge1xyXG5cdFx0XHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSB0aGlzLm93bmVyLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHJcblx0XHRcdFx0Y291bnQgPSB0YXJnZXRDb3VudCAtIDI7XHJcblx0XHRcdFx0c3RhcnQgPSB2YWx1ZXNbMF07XHJcblx0XHRcdFx0ZW5kID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRpbnRlcnZhbCA9IChlbmQgLSBzdGFydCkgLyAoY291bnQgKyAxKTtcclxuXHJcblx0XHRcdFx0Ly8gcmUtY29uc3RydWN0IHVuaXF1ZSB2YWx1ZXNcclxuXHRcdFx0XHR0aWNrVmFsdWVzID0gW3N0YXJ0XTtcclxuXHJcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHRcdFx0XHRcdHRpY2tWYWx1ZSA9ICtzdGFydCArIGludGVydmFsICogKGkgKyAxKTtcclxuXHRcdFx0XHRcdHRpY2tWYWx1ZXMucHVzaChcclxuXHRcdFx0XHRcdFx0Zm9yVGltZVNlcmllcyA/IG5ldyBEYXRlKHRpY2tWYWx1ZSkgOiAoXHJcblx0XHRcdFx0XHRcdFx0aXNDYXRlZ29yaXplZCA/IE1hdGgucm91bmQodGlja1ZhbHVlKSA6IHRpY2tWYWx1ZVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGlja1ZhbHVlcy5wdXNoKGVuZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWZvclRpbWVTZXJpZXMpIHtcclxuXHRcdFx0dGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWNrVmFsdWVzO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3QgYXhpcyA9ICQkLiRlbC5heGlzO1xyXG5cclxuXHRcdGNvbnN0IFtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1YlhdID0gW1wieFwiLCBcInlcIiwgXCJ5MlwiLCBcInN1YlhcIl1cclxuXHRcdFx0Lm1hcCh2ID0+IHtcclxuXHRcdFx0XHRsZXQgYXggPSBheGlzW3ZdO1xyXG5cclxuXHRcdFx0XHRpZiAoYXggJiYgZHVyYXRpb24pIHtcclxuXHRcdFx0XHRcdGF4ID0gYXgudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBheDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1Ylh9O1xyXG5cdH1cclxuXHJcblx0cmVkcmF3KHRyYW5zaXRpb25zLCBpc0hpZGRlbiwgaXNJbml0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBvcGFjaXR5ID0gaXNIaWRkZW4gPyBcIjBcIiA6IFwiMVwiO1xyXG5cclxuXHRcdFtcInhcIiwgXCJ5XCIsIFwieTJcIiwgXCJzdWJYXCJdLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCBheGlzID0gJCQuYXhpc1tpZF07XHJcblx0XHRcdGNvbnN0ICRheGlzID0gJGVsLmF4aXNbaWRdO1xyXG5cclxuXHRcdFx0aWYgKGF4aXMgJiYgJGF4aXMpIHtcclxuXHRcdFx0XHRpZiAoIWlzSW5pdCkge1xyXG5cdFx0XHRcdFx0YXhpcy5jb25maWcud2l0aG91dFRyYW5zaXRpb24gPSAhY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb247XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQkYXhpcy5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XHJcblx0XHRcdFx0YXhpcy5jcmVhdGUodHJhbnNpdGlvbnNbYGF4aXMke2NhcGl0YWxpemUoaWQpfWBdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVBeGVzKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgYXhpc1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzVG9TaG93IHRhcmdldHMgZGF0YSB0byBiZSBzaG93blxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB3dGhcclxuXHQgKiBAcGFyYW0ge09qYmVjdH0gdHJhbnNpdGlvbnNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmxvd1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3QXhpcyh0YXJnZXRzVG9TaG93LCB3dGgsIHRyYW5zaXRpb25zLCBmbG93LCBpc0luaXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBoYXNab29tID0gISFzY2FsZS56b29tO1xyXG5cdFx0bGV0IHhEb21haW5Gb3Jab29tO1xyXG5cclxuXHRcdGlmICghaGFzWm9vbSAmJiAkJC5pc0NhdGVnb3JpemVkKCkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0c2NhbGUueC5kb21haW4oWzAsICRlbC5heGlzLnguc2VsZWN0QWxsKFwiLnRpY2tcIikuc2l6ZSgpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNjYWxlLnggJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcclxuXHRcdFx0IWhhc1pvb20gJiZcclxuXHRcdFx0XHQkJC51cGRhdGVYRG9tYWluKHRhcmdldHNUb1Nob3csIHd0aC5VcGRhdGVYRG9tYWluLCB3dGguVXBkYXRlT3JnWERvbWFpbiwgd3RoLlRyaW1YRG9tYWluKTtcclxuXHJcblx0XHRcdGlmICghY29uZmlnLmF4aXNfeF90aWNrX3ZhbHVlcykge1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3cpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKCQkLmF4aXMueCkge1xyXG5cdFx0XHQkJC5heGlzLngudGlja1ZhbHVlcyhbXSk7XHJcblx0XHRcdCQkLmF4aXMuc3ViWCAmJiAkJC5heGlzLnN1YlgudGlja1ZhbHVlcyhbXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGNvbmZpZy56b29tX3Jlc2NhbGUgJiYgIWZsb3cpIHtcclxuXHRcdFx0eERvbWFpbkZvclpvb20gPSBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdFtcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdGNvbnN0IGF4aXMgPSBzY2FsZVtrZXldO1xyXG5cclxuXHRcdFx0aWYgKGF4aXMpIHtcclxuXHRcdFx0XHRjb25zdCB0aWNrVmFsdWVzID0gY29uZmlnW2BheGlzXyR7a2V5fV90aWNrX3ZhbHVlc2BdO1xyXG5cdFx0XHRcdGNvbnN0IHRpY2tDb3VudCA9IGNvbmZpZ1tgYXhpc18ke2tleX1fdGlja19jb3VudGBdO1xyXG5cclxuXHRcdFx0XHRheGlzLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIGtleSwgeERvbWFpbkZvclpvb20pKTtcclxuXHJcblx0XHRcdFx0aWYgKCF0aWNrVmFsdWVzICYmIHRpY2tDb3VudCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgZG9tYWluID0gYXhpcy5kb21haW4oKTtcclxuXHJcblx0XHRcdFx0XHQkJFtgJHtrZXl9QXhpc2BdLnRpY2tWYWx1ZXMoXHJcblx0XHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0XHRcdGRvbWFpbixcclxuXHRcdFx0XHRcdFx0XHRkb21haW4uZXZlcnkodiA9PiB2ID09PSAwKSA/IDEgOiB0aWNrQ291bnQsXHJcblx0XHRcdFx0XHRcdFx0JCQuaXNUaW1lU2VyaWVzWSgpXHJcblx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBheGVzXHJcblx0XHR0aGlzLnJlZHJhdyh0cmFuc2l0aW9ucywgJCQuaGFzQXJjVHlwZSgpLCBpc0luaXQpO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBheGlzIGxhYmVsXHJcblx0XHR0aGlzLnVwZGF0ZUxhYmVscyh3dGguVHJhbnNpdGlvbik7XHJcblxyXG5cdFx0Ly8gc2hvdy9oaWRlIGlmIG1hbnVhbCBjdWxsaW5nIG5lZWRlZFxyXG5cdFx0aWYgKCh3dGguVXBkYXRlWERvbWFpbiB8fCB3dGguVXBkYXRlWEF4aXMgfHwgd3RoLlkpICYmIHRhcmdldHNUb1Nob3cubGVuZ3RoKSB7XHJcblx0XHRcdHRoaXMuc2V0Q3VsbGluZygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwZGF0ZSBzdWIgZG9tYWluXHJcblx0XHRpZiAod3RoLlkpIHtcclxuXHRcdFx0c2NhbGUuc3ViWSAmJiBzY2FsZS5zdWJZLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIFwieVwiKSk7XHJcblx0XHRcdHNjYWxlLnN1YlkyICYmIHNjYWxlLnN1YlkyLmRvbWFpbigkJC5nZXRZRG9tYWluKHRhcmdldHNUb1Nob3csIFwieTJcIikpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG1hbnVhbCBjdWxsaW5nXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRDdWxsaW5nKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdFtcInN1YlhcIiwgXCJ4XCIsIFwieVwiLCBcInkyXCJdLmZvckVhY2godHlwZSA9PiB7XHJcblx0XHRcdGNvbnN0IGF4aXMgPSAkZWwuYXhpc1t0eXBlXTtcclxuXHJcblx0XHRcdC8vIHN1YmNoYXJ0IHggYXhpcyBzaG91bGQgYmUgYWxpZ25lZCB3aXRoIHggYXhpcyBjdWxsaW5nXHJcblx0XHRcdGNvbnN0IGlkID0gdHlwZSA9PT0gXCJzdWJYXCIgPyBcInhcIiA6IHR5cGU7XHJcblx0XHRcdGNvbnN0IHRvQ3VsbCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2N1bGxpbmdgXTtcclxuXHJcblx0XHRcdGlmIChheGlzICYmIHRvQ3VsbCkge1xyXG5cdFx0XHRcdGNvbnN0IHRpY2tUZXh0ID0gYXhpcy5zZWxlY3RBbGwoXCIudGljayB0ZXh0XCIpO1xyXG5cdFx0XHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSBzb3J0VmFsdWUodGlja1RleHQuZGF0YSgpKTtcclxuXHRcdFx0XHRjb25zdCB0aWNrU2l6ZSA9IHRpY2tWYWx1ZXMubGVuZ3RoO1xyXG5cdFx0XHRcdGNvbnN0IGN1bGxpbmdNYXggPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19jdWxsaW5nX21heGBdO1xyXG5cdFx0XHRcdGxldCBpbnRlcnZhbEZvckN1bGxpbmc7XHJcblxyXG5cdFx0XHRcdGlmICh0aWNrU2l6ZSkge1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0aWNrU2l6ZTsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdGlmICh0aWNrU2l6ZSAvIGkgPCBjdWxsaW5nTWF4KSB7XHJcblx0XHRcdFx0XHRcdFx0aW50ZXJ2YWxGb3JDdWxsaW5nID0gaTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRpY2tUZXh0LmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnN0eWxlLmRpc3BsYXkgPSB0aWNrVmFsdWVzLmluZGV4T2YoZCkgJSBpbnRlcnZhbEZvckN1bGxpbmcgPyBcIm5vbmVcIiA6IFwiYmxvY2tcIjtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aWNrVGV4dC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0Y3N2UGFyc2UgYXMgZDNDc3ZQYXJzZSxcclxuXHR0c3ZQYXJzZSBhcyBkM1RzdlBhcnNlLFxyXG5cdGNzdlBhcnNlUm93cyBhcyBkM0NzdlBhcnNlUm93cyxcclxuXHR0c3ZQYXJzZVJvd3MgYXMgZDNUc3ZQYXJzZVJvd3MsXHJcbn0gZnJvbSBcImQzLWRzdlwiO1xyXG5pbXBvcnQge2lzVW5kZWZpbmVkLCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1ZhbHVlLCBub3RFbXB0eSwgaXNBcnJheSwgY2FwaXRhbGl6ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogRGF0YSBjb252ZXJ0XHJcbiAqIEBtZW1iZXJvZiBDaGFydEludGVybmFsXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ29udmVydCBkYXRhIGFjY29yZGluZyBpdHMgdHlwZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIGRhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBjYWxsYmFjayBmb3IgdXJsKFhIUikgdHlwZSBsb2FkaW5nXHJcblx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y29udmVydERhdGEoYXJncywgY2FsbGJhY2spIHtcclxuXHRcdGxldCBkYXRhO1xyXG5cclxuXHRcdGlmIChhcmdzLmJpbmR0bykge1xyXG5cdFx0XHRkYXRhID0ge307XHJcblxyXG5cdFx0XHRbXCJ1cmxcIiwgXCJtaW1lVHlwZVwiLCBcImhlYWRlcnNcIiwgXCJrZXlzXCIsIFwianNvblwiLCBcImtleXNcIiwgXCJyb3dzXCIsIFwiY29sdW1uc1wiXVxyXG5cdFx0XHRcdC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3Qga2V5ID0gYGRhdGFfJHt2fWA7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGtleSBpbiBhcmdzKSB7XHJcblx0XHRcdFx0XHRcdGRhdGFbdl0gPSBhcmdzW2tleV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkYXRhID0gYXJncztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZGF0YS51cmwgJiYgY2FsbGJhY2spIHtcclxuXHRcdFx0dGhpcy5jb252ZXJ0VXJsVG9EYXRhKGRhdGEudXJsLCBkYXRhLm1pbWVUeXBlLCBkYXRhLmhlYWRlcnMsIGRhdGEua2V5cywgY2FsbGJhY2spO1xyXG5cdFx0fSBlbHNlIGlmIChkYXRhLmpzb24pIHtcclxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydEpzb25Ub0RhdGEoZGF0YS5qc29uLCBkYXRhLmtleXMpO1xyXG5cdFx0fSBlbHNlIGlmIChkYXRhLnJvd3MpIHtcclxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydFJvd3NUb0RhdGEoZGF0YS5yb3dzKTtcclxuXHRcdH0gZWxzZSBpZiAoZGF0YS5jb2x1bW5zKSB7XHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRDb2x1bW5zVG9EYXRhKGRhdGEuY29sdW1ucyk7XHJcblx0XHR9IGVsc2UgaWYgKGFyZ3MuYmluZHRvKSB7XHJcblx0XHRcdHRocm93IEVycm9yKFwidXJsIG9yIGpzb24gb3Igcm93cyBvciBjb2x1bW5zIGlzIHJlcXVpcmVkLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNBcnJheShkYXRhKSAmJiBkYXRhO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENvbnZlcnQgVVJMIGRhdGFcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFJlbW90ZSBVUkxcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgTUlNRSB0eXBlIHN0cmluZzoganNvbiB8IGNzdiB8IHRzdlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJzIEhlYWRlciBvYmplY3RcclxuXHQgKiBAcGFyYW0ge09iamVjdH0ga2V5cyBLZXkgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZG9uZSBDYWxsYmFjayBmdW5jdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y29udmVydFVybFRvRGF0YSh1cmwsIG1pbWVUeXBlID0gXCJjc3ZcIiwgaGVhZGVycywga2V5cywgZG9uZSkge1xyXG5cdFx0Y29uc3QgcmVxID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG5cdFx0cmVxLm9wZW4oXCJHRVRcIiwgdXJsKTtcclxuXHJcblx0XHRpZiAoaGVhZGVycykge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhoZWFkZXJzKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0cmVxLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXEub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xyXG5cdFx0XHRpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuXHRcdFx0XHRpZiAocmVxLnN0YXR1cyA9PT0gMjAwKSB7XHJcblx0XHRcdFx0XHRjb25zdCByZXNwb25zZSA9IHJlcS5yZXNwb25zZVRleHQ7XHJcblxyXG5cdFx0XHRcdFx0cmVzcG9uc2UgJiYgZG9uZS5jYWxsKHRoaXMsXHJcblx0XHRcdFx0XHRcdHRoaXNbYGNvbnZlcnQke2NhcGl0YWxpemUobWltZVR5cGUpfVRvRGF0YWBdKFxyXG5cdFx0XHRcdFx0XHRcdG1pbWVUeXBlID09PSBcImpzb25cIiA/IEpTT04ucGFyc2UocmVzcG9uc2UpIDogcmVzcG9uc2UsXHJcblx0XHRcdFx0XHRcdFx0a2V5c1xyXG5cdFx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGAke3VybH06IFNvbWV0aGluZyB3ZW50IHdyb25nIGxvYWRpbmchYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHJlcS5zZW5kKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydCBDU1YvVFNWIGRhdGFcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyc2VyIFBhcnNlciBvYmplY3RcclxuXHQgKiBAcGFyYW0ge09iamVjdH0geHN2IERhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm4ge09iamVjdH1cclxuXHQgKi9cclxuXHRjb252ZXJ0Q3N2VHN2VG9EYXRhKHBhcnNlciwgeHN2KSB7XHJcblx0XHRjb25zdCByb3dzID0gcGFyc2VyLnJvd3MoeHN2KTtcclxuXHRcdGxldCBkO1xyXG5cclxuXHRcdGlmIChyb3dzLmxlbmd0aCA9PT0gMSkge1xyXG5cdFx0XHRkID0gW3t9XTtcclxuXHJcblx0XHRcdHJvd3NbMF0uZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdFx0ZFswXVtpZF0gPSBudWxsO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGQgPSBwYXJzZXIucGFyc2UoeHN2KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0Q3N2VG9EYXRhKHhzdikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydENzdlRzdlRvRGF0YSh7XHJcblx0XHRcdHJvd3M6IGQzQ3N2UGFyc2VSb3dzLFxyXG5cdFx0XHRwYXJzZTogZDNDc3ZQYXJzZVxyXG5cdFx0fSwgeHN2KTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VHN2VG9EYXRhKHRzdikge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29udmVydENzdlRzdlRvRGF0YSh7XHJcblx0XHRcdHJvd3M6IGQzVHN2UGFyc2VSb3dzLFxyXG5cdFx0XHRwYXJzZTogZDNUc3ZQYXJzZVxyXG5cdFx0fSwgdHN2KTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0SnNvblRvRGF0YShqc29uLCBrZXlzUGFyYW0pIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IHN0cmluZ1tdW10gPSBbXTtcclxuXHRcdGxldCB0YXJnZXRLZXlzOiBzdHJpbmdbXTtcclxuXHRcdGxldCBkYXRhO1xyXG5cclxuXHRcdGlmIChpc0FycmF5KGpzb24pKSB7XHJcblx0XHRcdGNvbnN0IGtleXMgPSBrZXlzUGFyYW0gfHwgY29uZmlnLmRhdGFfa2V5cztcclxuXHJcblx0XHRcdGlmIChrZXlzLngpIHtcclxuXHRcdFx0XHR0YXJnZXRLZXlzID0ga2V5cy52YWx1ZS5jb25jYXQoa2V5cy54KTtcclxuXHRcdFx0XHRjb25maWcuZGF0YV94ID0ga2V5cy54O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRhcmdldEtleXMgPSBrZXlzLnZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuZXdSb3dzLnB1c2godGFyZ2V0S2V5cyk7XHJcblxyXG5cdFx0XHRqc29uLmZvckVhY2gobyA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbmV3Um93ID0gdGFyZ2V0S2V5cy5tYXAoa2V5ID0+IHtcclxuXHRcdFx0XHRcdC8vIGNvbnZlcnQgdW5kZWZpbmVkIHRvIG51bGwgYmVjYXVzZSB1bmRlZmluZWQgZGF0YSB3aWxsIGJlIHJlbW92ZWQgaW4gY29udmVydERhdGFUb1RhcmdldHMoKVxyXG5cdFx0XHRcdFx0bGV0IHYgPSB0aGlzLmZpbmRWYWx1ZUluSnNvbihvLCBrZXkpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh2KSkge1xyXG5cdFx0XHRcdFx0XHR2ID0gbnVsbDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gdjtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydFJvd3NUb0RhdGEobmV3Um93cyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhqc29uKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdG1wID0ganNvbltrZXldLmNvbmNhdCgpO1xyXG5cclxuXHRcdFx0XHR0bXAudW5zaGlmdChrZXkpO1xyXG5cdFx0XHRcdG5ld1Jvd3MucHVzaCh0bXApO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdGRhdGEgPSB0aGlzLmNvbnZlcnRDb2x1bW5zVG9EYXRhKG5ld1Jvd3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRWYWx1ZUluSnNvbihvYmplY3QsIHBhdGgpIHtcclxuXHRcdGlmIChvYmplY3RbcGF0aF0gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gb2JqZWN0W3BhdGhdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGNvbnZlcnRlZFBhdGggPSBwYXRoLnJlcGxhY2UoL1xcWyhcXHcrKVxcXS9nLCBcIi4kMVwiKTsgLy8gY29udmVydCBpbmRleGVzIHRvIHByb3BlcnRpZXMgKHJlcGxhY2UgW10gd2l0aCAuKVxyXG5cdFx0Y29uc3QgcGF0aEFycmF5ID0gY29udmVydGVkUGF0aC5yZXBsYWNlKC9eXFwuLywgXCJcIikuc3BsaXQoXCIuXCIpOyAvLyBzdHJpcCBhIGxlYWRpbmcgZG90XHJcblx0XHRsZXQgdGFyZ2V0ID0gb2JqZWN0O1xyXG5cclxuXHRcdHBhdGhBcnJheS5zb21lKGsgPT4gIShcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0ICYmIGsgaW4gdGFyZ2V0ID9cclxuXHRcdFx0XHR0YXJnZXRba10gOiB1bmRlZmluZWRcclxuXHRcdCkpO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0Y29udmVydFJvd3NUb0RhdGEocm93cykge1xyXG5cdFx0Y29uc3Qga2V5cyA9IHJvd3NbMF07XHJcblx0XHRjb25zdCBuZXdSb3dzOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdHJvd3MuZm9yRWFjaCgocm93LCBpKSA9PiB7XHJcblx0XHRcdGlmIChpID4gMCkge1xyXG5cdFx0XHRcdGNvbnN0IG5ld1JvdyA9IHt9O1xyXG5cclxuXHRcdFx0XHRyb3cuZm9yRWFjaCgodiwgaikgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHYpKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgU291cmNlIGRhdGEgaXMgbWlzc2luZyBhIGNvbXBvbmVudCBhdCAoJHtpfSwgJHtqfSkhYCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bmV3Um93W2tleXNbal1dID0gdjtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKG5ld1Jvdyk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBuZXdSb3dzO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRDb2x1bW5zVG9EYXRhKGNvbHVtbnMpIHtcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IGFueVtdID0gW107XHJcblxyXG5cdFx0Y29sdW1ucy5mb3JFYWNoKChjb2wsIGkpID0+IHtcclxuXHRcdFx0Y29uc3Qga2V5ID0gY29sWzBdO1xyXG5cclxuXHRcdFx0Y29sLmZvckVhY2goKHYsIGopID0+IHtcclxuXHRcdFx0XHRpZiAoaiA+IDApIHtcclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZChuZXdSb3dzW2ogLSAxXSkpIHtcclxuXHRcdFx0XHRcdFx0bmV3Um93c1tqIC0gMV0gPSB7fTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodikpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0ICgke2l9LCAke2p9KSFgKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRuZXdSb3dzW2ogLSAxXVtrZXldID0gdjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XHJcblx0fSxcclxuXHJcblx0Y29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgYXBwZW5kWHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0Y29uc3QgZGF0YUtleXMgPSBPYmplY3Qua2V5cyhkYXRhWzBdIHx8IHt9KTtcclxuXHRcdGNvbnN0IGlkcyA9IGRhdGFLZXlzLmxlbmd0aCA/IGRhdGFLZXlzLmZpbHRlcigkJC5pc05vdFgsICQkKSA6IFtdO1xyXG5cdFx0Y29uc3QgeHMgPSBkYXRhS2V5cy5sZW5ndGggPyBkYXRhS2V5cy5maWx0ZXIoJCQuaXNYLCAkJCkgOiBbXTtcclxuXHJcblx0XHRsZXQgeHNEYXRhO1xyXG5cclxuXHRcdC8vIHNhdmUgeCBmb3IgdXBkYXRlIGRhdGEgYnkgbG9hZCB3aGVuIGN1c3RvbSB4IGFuZCBiYi54IEFQSVxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCB4S2V5ID0gdGhpcy5nZXRYS2V5KGlkKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLmlzQ3VzdG9tWCgpIHx8IGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRcdC8vIGlmIGluY2x1ZGVkIGluIGlucHV0IGRhdGFcclxuXHRcdFx0XHRpZiAoeHMuaW5kZXhPZih4S2V5KSA+PSAwKSB7XHJcblx0XHRcdFx0XHR4c0RhdGEgPSAoKGFwcGVuZFhzICYmICQkLmRhdGEueHNbaWRdKSB8fCBbXSlcclxuXHRcdFx0XHRcdFx0LmNvbmNhdChcclxuXHRcdFx0XHRcdFx0XHRkYXRhLm1hcChkID0+IGRbeEtleV0pXHJcblx0XHRcdFx0XHRcdFx0XHQuZmlsdGVyKGlzVmFsdWUpXHJcblx0XHRcdFx0XHRcdFx0XHQubWFwKChyYXdYLCBpKSA9PiAkJC5nZW5lcmF0ZVRhcmdldFgocmF3WCwgaWQsIGkpKVxyXG5cdFx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoY29uZmlnLmRhdGFfeCkge1xyXG5cdFx0XHRcdFx0Ly8gaWYgbm90IGluY2x1ZGVkIGluIGlucHV0IGRhdGEsIGZpbmQgZnJvbSBwcmVsb2FkZWQgZGF0YSBvZiBvdGhlciBpZCdzIHhcclxuXHRcdFx0XHRcdHhzRGF0YSA9IHRoaXMuZ2V0T3RoZXJUYXJnZXRYcygpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAobm90RW1wdHkoY29uZmlnLmRhdGFfeHMpKSB7XHJcblx0XHRcdFx0XHQvLyBpZiBub3QgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YSwgZmluZCBmcm9tIHByZWxvYWRlZCBkYXRhXHJcblx0XHRcdFx0XHR4c0RhdGEgPSAkJC5nZXRYVmFsdWVzT2ZYS2V5KHhLZXksICQkLmRhdGEudGFyZ2V0cyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIE1FTU86IGlmIG5vIHggaW5jbHVkZWQsIHVzZSBzYW1lIHggb2YgY3VycmVudCB3aWxsIGJlIHVzZWRcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR4c0RhdGEgPSBkYXRhLm1hcCgoZCwgaSkgPT4gaSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHhzRGF0YSAmJiAodGhpcy5kYXRhLnhzW2lkXSA9IHhzRGF0YSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBjaGVjayB4IGlzIGRlZmluZWRcclxuXHRcdGlkcy5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0aWYgKCF0aGlzLmRhdGEueHNbaWRdKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB4IGlzIG5vdCBkZWZpbmVkIGZvciBpZCA9IFwiJHtpZH1cIi5gKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gY29udmVydCB0byB0YXJnZXRcclxuXHRcdGNvbnN0IHRhcmdldHMgPSBpZHMubWFwKChpZCwgaW5kZXgpID0+IHtcclxuXHRcdFx0Y29uc3QgY29udmVydGVkSWQgPSBjb25maWcuZGF0YV9pZENvbnZlcnRlcihpZCk7XHJcblx0XHRcdGNvbnN0IHhLZXkgPSAkJC5nZXRYS2V5KGlkKTtcclxuXHRcdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHRcdFx0Y29uc3QgaGFzQ2F0ZWdvcnkgPSBpc0NhdGVnb3JpemVkICYmIGRhdGEubWFwKHYgPT4gdi54KVxyXG5cdFx0XHRcdC5ldmVyeSh2ID0+IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHYpID4gLTEpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRpZDogY29udmVydGVkSWQsXHJcblx0XHRcdFx0aWRfb3JnOiBpZCxcclxuXHRcdFx0XHR2YWx1ZXM6IGRhdGEubWFwKChkLCBpKSA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCByYXdYID0gZFt4S2V5XTtcclxuXHRcdFx0XHRcdGxldCB2YWx1ZSA9IGRbaWRdO1xyXG5cdFx0XHRcdFx0bGV0IHg7XHJcblxyXG5cdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmICFpc09iamVjdCh2YWx1ZSkgP1xyXG5cdFx0XHRcdFx0XHQrdmFsdWUgOiAoaXNBcnJheSh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiBudWxsKTtcclxuXHJcblx0XHRcdFx0XHQvLyB1c2UgeCBhcyBjYXRlZ29yaWVzIGlmIGN1c3RvbSB4IGFuZCBjYXRlZ29yaXplZFxyXG5cdFx0XHRcdFx0aWYgKGlzQ2F0ZWdvcml6ZWQgJiYgaW5kZXggPT09IDAgJiYgIWlzVW5kZWZpbmVkKHJhd1gpKSB7XHJcblx0XHRcdFx0XHRcdGlmICghaGFzQ2F0ZWdvcnkgJiYgaW5kZXggPT09IDAgJiYgaSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IFtdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR4ID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YocmF3WCk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoeCA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0XHR4ID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcclxuXHRcdFx0XHRcdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXMucHVzaChyYXdYKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0eCA9ICQkLmdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaSk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gbWFyayBhcyB4ID0gdW5kZWZpbmVkIGlmIHZhbHVlIGlzIHVuZGVmaW5lZCBhbmQgZmlsdGVyIHRvIHJlbW92ZSBhZnRlciBtYXBwZWRcclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgJCQuZGF0YS54c1tpZF0ubGVuZ3RoIDw9IGkpIHtcclxuXHRcdFx0XHRcdFx0eCA9IHVuZGVmaW5lZDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4ge3gsIHZhbHVlLCBpZDogY29udmVydGVkSWR9O1xyXG5cdFx0XHRcdH0pLmZpbHRlcih2ID0+IGlzRGVmaW5lZCh2LngpKVxyXG5cdFx0XHR9O1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gZmluaXNoIHRhcmdldHNcclxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0Ly8gc29ydCB2YWx1ZXMgYnkgaXRzIHhcclxuXHRcdFx0aWYgKGNvbmZpZy5kYXRhX3hTb3J0KSB7XHJcblx0XHRcdFx0dC52YWx1ZXMgPSB0LnZhbHVlcy5zb3J0KCh2MSwgdjIpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHgxID0gdjEueCB8fCB2MS54ID09PSAwID8gdjEueCA6IEluZmluaXR5O1xyXG5cdFx0XHRcdFx0Y29uc3QgeDIgPSB2Mi54IHx8IHYyLnggPT09IDAgPyB2Mi54IDogSW5maW5pdHk7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHgxIC0geDI7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGluZGV4aW5nIGVhY2ggdmFsdWVcclxuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCgodiwgaSkgPT4gKHYuaW5kZXggPSBpKSk7XHJcblxyXG5cdFx0XHQvLyB0aGlzIG5lZWRzIHRvIGJlIHNvcnRlZCBiZWNhdXNlIGl0cyBpbmRleCBhbmQgdmFsdWUuaW5kZXggaXMgaWRlbnRpY2FsXHJcblx0XHRcdCQkLmRhdGEueHNbdC5pZF0uc29ydCgodjEsIHYyKSA9PiB2MSAtIHYyKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGNhY2hlIGluZm9ybWF0aW9uIGFib3V0IHZhbHVlc1xyXG5cdFx0c3RhdGUuaGFzTmVnYXRpdmVWYWx1ZSA9ICQkLmhhc05lZ2F0aXZlVmFsdWVJblRhcmdldHModGFyZ2V0cyk7XHJcblx0XHRzdGF0ZS5oYXNQb3NpdGl2ZVZhbHVlID0gJCQuaGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKTtcclxuXHJcblx0XHQvLyBzZXQgdGFyZ2V0IHR5cGVzXHJcblx0XHRpZiAoY29uZmlnLmRhdGFfdHlwZSkge1xyXG5cdFx0XHQkJC5zZXRUYXJnZXRUeXBlKCQkLm1hcFRvSWRzKHRhcmdldHMpXHJcblx0XHRcdFx0LmZpbHRlcihpZCA9PiAhKGlkIGluIGNvbmZpZy5kYXRhX3R5cGVzKSksIGNvbmZpZy5kYXRhX3R5cGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNhY2hlIGFzIG9yaWdpbmFsIGlkIGtleWVkXHJcblx0XHR0YXJnZXRzLmZvckVhY2goZCA9PiAkJC5jYWNoZS5hZGQoZC5pZF9vcmcsIGQsIHRydWUpKTtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge1xyXG7CoMKgwqDCoGdldFVuaXF1ZSxcclxuwqDCoMKgwqBoYXNWYWx1ZSxcclxuwqDCoMKgwqBpc0FycmF5LFxyXG7CoMKgwqDCoGlzQm9vbGVhbixcclxuwqDCoMKgwqBpc0RlZmluZWQsXHJcbsKgwqDCoMKgaXNGdW5jdGlvbixcclxuwqDCoMKgwqBpc051bWJlcixcclxuwqDCoMKgwqBpc09iamVjdCxcclxuwqDCoMKgwqBpc09iamVjdFR5cGUsXHJcbsKgwqDCoMKgaXNTdHJpbmcsXHJcbsKgwqDCoMKgaXNVbmRlZmluZWQsXHJcbsKgwqDCoMKgaXNWYWx1ZSxcclxuwqDCoMKgwqBtZXJnZUFycmF5LFxyXG7CoMKgwqDCoG5vdEVtcHR5LFxyXG5cdHNvcnRWYWx1ZVxyXG59IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGlzWChrZXkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhS2V5ID0gY29uZmlnLmRhdGFfeCAmJiBrZXkgPT09IGNvbmZpZy5kYXRhX3g7XHJcblx0XHRjb25zdCBleGlzdFZhbHVlID0gbm90RW1wdHkoY29uZmlnLmRhdGFfeHMpICYmIGhhc1ZhbHVlKGNvbmZpZy5kYXRhX3hzLCBrZXkpO1xyXG5cclxuXHRcdHJldHVybiBkYXRhS2V5IHx8IGV4aXN0VmFsdWU7XHJcblx0fSxcclxuXHJcblx0aXNOb3RYKGtleSkge1xyXG5cdFx0cmV0dXJuICF0aGlzLmlzWChrZXkpO1xyXG5cdH0sXHJcblxyXG5cdGlzU3RhY2tOb3JtYWxpemVkKCk6IGJvb2xlYW4ge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAhIShjb25maWcuZGF0YV9zdGFja19ub3JtYWxpemUgJiYgY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aCk7XHJcblx0fSxcclxuXHJcblx0aXNHcm91cGVkKGlkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuZGF0YV9ncm91cHNcclxuXHRcdFx0Lm1hcCh2ID0+IHYuaW5kZXhPZihpZCkgPj0gMClbMF07XHJcblx0fSxcclxuXHJcblx0Z2V0WEtleShpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmRhdGFfeCA/XHJcblx0XHRcdGNvbmZpZy5kYXRhX3ggOiAobm90RW1wdHkoY29uZmlnLmRhdGFfeHMpID8gY29uZmlnLmRhdGFfeHNbaWRdIDogbnVsbCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WFZhbHVlc09mWEtleShrZXksIHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlkcyA9IHRhcmdldHMgJiYgbm90RW1wdHkodGFyZ2V0cykgPyAkJC5tYXBUb0lkcyh0YXJnZXRzKSA6IFtdO1xyXG5cdFx0bGV0IHhWYWx1ZXM7XHJcblxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRpZiAoJCQuZ2V0WEtleShpZCkgPT09IGtleSkge1xyXG5cdFx0XHRcdHhWYWx1ZXMgPSAkJC5kYXRhLnhzW2lkXTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHhWYWx1ZXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGluZGV4IG51bWJlciBiYXNlZCBvbiBnaXZlbiB4IEF4aXMgdmFsdWVcclxuXHQgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfFN0cmluZ30geCB4IEF4aXMgdG8gYmUgY29tcGFyZWRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBiYXNlZFggeCBBeGlzIGxpc3QgdG8gYmUgYmFzZWQgb25cclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IGluZGV4IG51bWJlclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0SW5kZXhCeVgoeCwgYmFzZWRYKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGJhc2VkWCA/XHJcblx0XHRcdGJhc2VkWC5pbmRleE9mKGlzU3RyaW5nKHgpID8geCA6ICt4KSA6XHJcblx0XHRcdCgkJC5maWx0ZXJCeVgoJCQuZGF0YS50YXJnZXRzLCB4KVswXSB8fCB7aW5kZXg6IG51bGx9KS5pbmRleDtcclxuXHR9LFxyXG5cclxuXHRnZXRYVmFsdWUoaWQsIGkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gaWQgaW4gJCQuZGF0YS54cyAmJlxyXG5cdFx0XHQkJC5kYXRhLnhzW2lkXSAmJlxyXG5cdFx0XHRpc1ZhbHVlKCQkLmRhdGEueHNbaWRdW2ldKSA/ICQkLmRhdGEueHNbaWRdW2ldIDogaTtcclxuXHR9LFxyXG5cclxuXHRnZXRPdGhlclRhcmdldFhzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaWRzRm9yWCA9IE9iamVjdC5rZXlzKCQkLmRhdGEueHMpO1xyXG5cclxuXHRcdHJldHVybiBpZHNGb3JYLmxlbmd0aCA/ICQkLmRhdGEueHNbaWRzRm9yWFswXV0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldE90aGVyVGFyZ2V0WChpbmRleCkge1xyXG5cdFx0Y29uc3QgeHMgPSB0aGlzLmdldE90aGVyVGFyZ2V0WHMoKTtcclxuXHJcblx0XHRyZXR1cm4geHMgJiYgaW5kZXggPCB4cy5sZW5ndGggPyB4c1tpbmRleF0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGFkZFhzKHhzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdE9iamVjdC5rZXlzKHhzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfeHNbaWRdID0geHNbaWRdO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0aXNNdWx0aXBsZVgoKSB7XHJcblx0XHRyZXR1cm4gbm90RW1wdHkodGhpcy5jb25maWcuZGF0YV94cykgfHxcclxuXHRcdFx0IXRoaXMuY29uZmlnLmRhdGFfeFNvcnQgfHxcclxuXHRcdFx0dGhpcy5oYXNUeXBlKFwiYnViYmxlXCIpIHx8XHJcblx0XHRcdHRoaXMuaGFzVHlwZShcInNjYXR0ZXJcIik7XHJcblx0fSxcclxuXHJcblx0YWRkTmFtZShkYXRhKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IG5hbWU7XHJcblxyXG5cdFx0aWYgKGRhdGEpIHtcclxuXHRcdFx0bmFtZSA9IGNvbmZpZy5kYXRhX25hbWVzW2RhdGEuaWRdO1xyXG5cdFx0XHRkYXRhLm5hbWUgPSBuYW1lICE9PSB1bmRlZmluZWQgPyBuYW1lIDogZGF0YS5pZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHR9LFxyXG5cclxuXHRnZXRBbGxWYWx1ZXNPbkluZGV4KGluZGV4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKVxyXG5cdFx0XHQubWFwKHQgPT4gJCQuYWRkTmFtZSgkJC5nZXRWYWx1ZU9uSW5kZXgodC52YWx1ZXMsIGluZGV4KSkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFZhbHVlT25JbmRleCh2YWx1ZXMsIGluZGV4KSB7XHJcblx0XHRjb25zdCB2YWx1ZU9uSW5kZXggPSB2YWx1ZXMuZmlsdGVyKHYgPT4gdi5pbmRleCA9PT0gaW5kZXgpO1xyXG5cclxuXHRcdHJldHVybiB2YWx1ZU9uSW5kZXgubGVuZ3RoID8gdmFsdWVPbkluZGV4WzBdIDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRYKHRhcmdldHMsIHgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHR2LnggPSAkJC5nZW5lcmF0ZVRhcmdldFgoeFtpXSwgdC5pZCwgaSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuZGF0YS54c1t0LmlkXSA9IHg7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRYcyh0YXJnZXRzLCB4cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0eHNbdC5pZF0gJiYgJCQudXBkYXRlVGFyZ2V0WChbdF0sIHhzW3QuaWRdKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaW5kZXgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB4ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gaW5kZXggOiAocmF3WCB8fCBpbmRleCk7XHJcblxyXG5cdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdHggPSByYXdYID8gJCQucGFyc2VEYXRlKHJhd1gpIDogJCQucGFyc2VEYXRlKCQkLmdldFhWYWx1ZShpZCwgaW5kZXgpKTtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNDdXN0b21YKCkgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHR4ID0gaXNWYWx1ZShyYXdYKSA/ICtyYXdYIDogJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWHModmFsdWVzKSB7XHJcblx0XHRpZiAodmFsdWVzLmxlbmd0aCkge1xyXG5cdFx0XHR0aGlzLmF4aXMueHMgPSB2YWx1ZXMubWFwKHYgPT4gdi54KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRQcmV2WChpKSB7XHJcblx0XHRjb25zdCB4ID0gdGhpcy5heGlzLnhzW2kgLSAxXTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHgpID8geCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0TmV4dFgoaSkge1xyXG5cdFx0Y29uc3QgeCA9IHRoaXMuYXhpcy54c1tpICsgMV07XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBiYXNlIHZhbHVlIGlzQXJlYVJhbmdlVHlwZVxyXG5cdCAqIEBwYXJhbSBkYXRhIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZVZhbHVlKGRhdGEpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB2YWx1ZSA9IGRhdGEudmFsdWU7XHJcblxyXG5cdFx0Ly8gSW4gY2FzZSBvZiBhcmVhLXJhbmdlLCBkYXRhIGlzIGdpdmVuIGFzOiBbbG93LCBtaWQsIGhpZ2hdIG9yIHtsb3csIG1pZCwgaGlnaH1cclxuXHRcdC8vIHdpbGwgdGFrZSB0aGUgJ21pZCcgYXMgdGhlIGJhc2UgdmFsdWVcclxuXHRcdGlmICh2YWx1ZSAmJiAkJC5pc0F4aXMpIHtcclxuXHRcdFx0aWYgKCQkLmlzQXJlYVJhbmdlVHlwZShkYXRhKSkge1xyXG5cdFx0XHRcdHZhbHVlID0gJCQuZ2V0QXJlYVJhbmdlRGF0YShkYXRhLCBcIm1pZFwiKTtcclxuXHRcdFx0fSBlbHNlIGlmICgkJC5pc0J1YmJsZVpUeXBlKGRhdGEpKSB7XHJcblx0XHRcdFx0dmFsdWUgPSAkJC5nZXRCdWJibGVaRGF0YSh2YWx1ZSwgXCJ5XCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IG1pbi9tYXggdmFsdWUgZnJvbSB0aGUgZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZGF0YSBhcnJheSBkYXRhIHRvIGJlIGV2YWx1YXRlZFxyXG5cdCAqIEByZXR1cm4ge3ttaW46IHtOdW1iZXJ9LCBtYXg6IHtOdW1iZXJ9fX1cclxuXHQgKi9cclxuXHRnZXRNaW5NYXhWYWx1ZShkYXRhKSB7XHJcblx0XHRjb25zdCBnZXRCYXNlVmFsdWUgPSB0aGlzLmdldEJhc2VWYWx1ZS5iaW5kKHRoaXMpO1xyXG5cdFx0bGV0IG1pbjtcclxuXHRcdGxldCBtYXg7XHJcblxyXG5cdFx0KGRhdGEgfHwgdGhpcy5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKVxyXG5cdFx0XHQuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdi5tYXAoZ2V0QmFzZVZhbHVlKS5maWx0ZXIoaXNOdW1iZXIpO1xyXG5cclxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihpID8gbWluIDogSW5maW5pdHksIC4uLnZhbHVlKTtcclxuXHRcdFx0XHRtYXggPSBNYXRoLm1heChpID8gbWF4IDogLUluZmluaXR5LCAuLi52YWx1ZSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiB7bWluLCBtYXh9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbWluL21heCBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJuIHt7bWluOiBBcnJheSwgbWF4OiBBcnJheX19XHJcblx0ICovXHJcblx0Z2V0TWluTWF4RGF0YSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCIkbWluTWF4RGF0YVwiO1xyXG5cdFx0bGV0IG1pbk1heERhdGEgPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghbWluTWF4RGF0YSkge1xyXG5cdFx0XHRjb25zdCBkYXRhID0gJCQuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKTtcclxuXHRcdFx0Y29uc3QgbWluTWF4ID0gJCQuZ2V0TWluTWF4VmFsdWUoZGF0YSk7XHJcblxyXG5cdFx0XHRsZXQgbWluID0gW107XHJcblx0XHRcdGxldCBtYXggPSBbXTtcclxuXHJcblx0XHRcdGRhdGEuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCBtaW5EYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWluKTtcclxuXHRcdFx0XHRjb25zdCBtYXhEYXRhID0gJCQuZ2V0RmlsdGVyZWREYXRhQnlWYWx1ZSh2LCBtaW5NYXgubWF4KTtcclxuXHJcblx0XHRcdFx0aWYgKG1pbkRhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRtaW4gPSBtaW4uY29uY2F0KG1pbkRhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKG1heERhdGEubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRtYXggPSBtYXguY29uY2F0KG1heERhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgdGhlIGNhY2hlZCBkYXRhXHJcblx0XHRcdCQkLmNhY2hlLmFkZChjYWNoZUtleSwgbWluTWF4RGF0YSA9IHttaW4sIG1heH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtaW5NYXhEYXRhO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBzdW0gb2YgZGF0YSBwZXIgaW5kZXhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdCAqL1xyXG5cdGdldFRvdGFsUGVySW5kZXgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJHRvdGFsUGVySW5kZXhcIjtcclxuXHRcdGxldCBzdW0gPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpICYmICFzdW0pIHtcclxuXHRcdFx0c3VtID0gW107XHJcblxyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaChyb3cgPT4ge1xyXG5cdFx0XHRcdHJvdy52YWx1ZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKCFzdW1baV0pIHtcclxuXHRcdFx0XHRcdFx0c3VtW2ldID0gMDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRzdW1baV0gKz0gaXNOdW1iZXIodi52YWx1ZSkgPyB2LnZhbHVlIDogMDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN1bTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdG90YWwgZGF0YSBzdW1cclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcbiBcdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VG90YWxEYXRhU3VtKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBcIiR0b3RhbERhdGFTdW1cIjtcclxuXHRcdGxldCB0b3RhbERhdGFTdW0gPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghdG90YWxEYXRhU3VtKSB7XHJcblx0XHRcdGNvbnN0IHRvdGFsID0gbWVyZ2VBcnJheSgkJC5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMpKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2LnZhbHVlKVxyXG5cdFx0XHRcdC5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjKTtcclxuXHJcblx0XHRcdCQkLmNhY2hlLmFkZChjYWNoZUtleSwgdG90YWxEYXRhU3VtID0gdG90YWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0b3RhbERhdGFTdW07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGZpbHRlcmVkIGRhdGEgYnkgdmFsdWVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSBmaWx0ZXJlZCBhcnJheSBkYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRGaWx0ZXJlZERhdGFCeVZhbHVlKGRhdGEsIHZhbHVlKSB7XHJcblx0XHRyZXR1cm4gZGF0YS5maWx0ZXIodCA9PiB0aGlzLmdldEJhc2VWYWx1ZSh0KSA9PT0gdmFsdWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiB0aGUgbWF4IGxlbmd0aCBvZiB0aGUgZGF0YVxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gbWF4IGRhdGEgbGVuZ3RoXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRNYXhEYXRhQ291bnQoKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5tYXgoLi4udGhpcy5kYXRhLnRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMubGVuZ3RoKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0TWF4RGF0YUNvdW50VGFyZ2V0KCkge1xyXG5cdFx0bGV0IHRhcmdldCA9IHRoaXMuZmlsdGVyVGFyZ2V0c1RvU2hvdygpIHx8IFtdO1xyXG5cdFx0Y29uc3QgbGVuZ3RoID0gdGFyZ2V0Lmxlbmd0aDtcclxuXHJcblx0XHRpZiAobGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0YXJnZXQgPSB0YXJnZXQubWFwKHQgPT4gdC52YWx1ZXMpXHJcblx0XHRcdFx0LnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpXHJcblx0XHRcdFx0Lm1hcCh2ID0+IHYueCk7XHJcblxyXG5cdFx0XHR0YXJnZXQgPSBzb3J0VmFsdWUoZ2V0VW5pcXVlKHRhcmdldCkpXHJcblx0XHRcdFx0Lm1hcCgoeCwgaW5kZXgpID0+ICh7eCwgaW5kZXh9KSk7XHJcblx0XHR9IGVsc2UgaWYgKGxlbmd0aCkge1xyXG5cdFx0XHR0YXJnZXQgPSB0YXJnZXRbMF0udmFsdWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fSxcclxuXHJcblx0bWFwVG9JZHModGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRhcmdldHMubWFwKGQgPT4gZC5pZCk7XHJcblx0fSxcclxuXHJcblx0bWFwVG9UYXJnZXRJZHMoaWRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGlkcyA/IChpc0FycmF5KGlkcykgPyBpZHMuY29uY2F0KCkgOiBbaWRzXSkgOiAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpO1xyXG5cdH0sXHJcblxyXG5cdGhhc1RhcmdldCh0YXJnZXRzLCBpZCkge1xyXG5cdFx0Y29uc3QgaWRzID0gdGhpcy5tYXBUb0lkcyh0YXJnZXRzKTtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMCwgdmFsOyAodmFsID0gaWRzW2ldKTsgaSsrKSB7XHJcblx0XHRcdGlmICh2YWwgPT09IGlkKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0aXNUYXJnZXRUb1Nob3codGFyZ2V0SWQpIHtcclxuXHRcdHJldHVybiB0aGlzLnN0YXRlLmhpZGRlblRhcmdldElkcy5pbmRleE9mKHRhcmdldElkKSA8IDA7XHJcblx0fSxcclxuXHJcblx0aXNMZWdlbmRUb1Nob3codGFyZ2V0SWQpIHtcclxuXHRcdHJldHVybiB0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcy5pbmRleE9mKHRhcmdldElkKSA8IDA7XHJcblx0fSxcclxuXHJcblx0ZmlsdGVyVGFyZ2V0c1RvU2hvdyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICh0YXJnZXRzIHx8ICQkLmRhdGEudGFyZ2V0cykuZmlsdGVyKHQgPT4gJCQuaXNUYXJnZXRUb1Nob3codC5pZCkpO1xyXG5cdH0sXHJcblxyXG5cdG1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB4czogYW55W10gPSBbXTtcclxuXHJcblx0XHRpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR4cyA9IGdldFVuaXF1ZShcclxuXHRcdFx0XHRtZXJnZUFycmF5KHRhcmdldHMubWFwKHQgPT4gdC52YWx1ZXMubWFwKHYgPT4gK3YueCkpKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0eHMgPSAkJC5pc1RpbWVTZXJpZXMoKSA/IHhzLm1hcCh4ID0+IG5ldyBEYXRlKCt4KSkgOiB4cy5tYXAoeCA9PiAreCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNvcnRWYWx1ZSh4cyk7XHJcblx0fSxcclxuXHJcblx0YWRkSGlkZGVuVGFyZ2V0SWRzKHRhcmdldElkcykge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlblRhcmdldElkcy5jb25jYXQodGFyZ2V0SWRzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIaWRkZW5UYXJnZXRJZHModGFyZ2V0SWRzKSB7XHJcblx0XHR0aGlzLnN0YXRlLmhpZGRlblRhcmdldElkcyA9IHRoaXMuc3RhdGUuaGlkZGVuVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRhZGRIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XHJcblx0XHR0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcyA9IHRoaXMuc3RhdGUuaGlkZGVuTGVnZW5kSWRzLmNvbmNhdCh0YXJnZXRJZHMpO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpIHtcclxuXHRcdHRoaXMuc3RhdGUuaGlkZGVuTGVnZW5kSWRzID0gdGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMuZmlsdGVyKGlkID0+IHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDApO1xyXG5cdH0sXHJcblxyXG5cdGdldFZhbHVlc0FzSWRLZXllZCh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB5cyA9IHt9O1xyXG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xyXG5cdFx0Y29uc3QgeHMgPSBpc011bHRpcGxlWCA/ICQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpXHJcblx0XHRcdC5tYXAodiA9PiAoaXNTdHJpbmcodikgPyB2IDogK3YpKSA6IG51bGw7XHJcblxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRjb25zdCBkYXRhOiBhbnlbXSA9IFtdO1xyXG5cclxuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYudmFsdWU7XHJcblxyXG5cdFx0XHRcdGlmIChpc0FycmF5KHZhbHVlKSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLnZhbHVlKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiBcImhpZ2hcIiBpbiB2YWx1ZSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5wdXNoKC4uLk9iamVjdC52YWx1ZXModmFsdWUpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCQkLmlzQnViYmxlWlR5cGUodikpIHtcclxuXHRcdFx0XHRcdGRhdGEucHVzaCgkJC5pc0F4aXMgJiYgJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmIChpc011bHRpcGxlWCkge1xyXG5cdFx0XHRcdFx0XHRkYXRhWyQkLmdldEluZGV4QnlYKHYueCwgeHMpXSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0ZGF0YS5wdXNoKHZhbHVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0eXNbdC5pZF0gPSBkYXRhO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHlzO1xyXG5cdH0sXHJcblxyXG5cdGNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgY2hlY2tlcikge1xyXG5cdFx0Y29uc3QgaWRzID0gT2JqZWN0LmtleXModGFyZ2V0cyk7XHJcblx0XHRsZXQgdmFsdWVzO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhbHVlcyA9IHRhcmdldHNbaWRzW2ldXS52YWx1ZXM7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGlmIChjaGVja2VyKHZhbHVlc1tqXS52YWx1ZSkpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRoYXNNdWx0aVRhcmdldHMoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXJUYXJnZXRzVG9TaG93KCkubGVuZ3RoID4gMTtcclxuXHR9LFxyXG5cclxuXHRoYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgdiA9PiB2IDwgMCk7XHJcblx0fSxcclxuXHJcblx0aGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIHYgPT4gdiA+IDApO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja09yZGVyKHR5cGUpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IG9yZGVyID0gY29uZmlnLmRhdGFfb3JkZXI7XHJcblxyXG5cdFx0cmV0dXJuIGlzU3RyaW5nKG9yZGVyKSAmJiBvcmRlci50b0xvd2VyQ2FzZSgpID09PSB0eXBlO1xyXG5cdH0sXHJcblxyXG5cdGlzT3JkZXJEZXNjKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrT3JkZXIoXCJkZXNjXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzT3JkZXJBc2MoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tPcmRlcihcImFzY1wiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTb3J0IHRhcmdldHMgZGF0YVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNWYWx1ZVxyXG5cdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b3JkZXJUYXJnZXRzKHRhcmdldHNWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSBbLi4udGFyZ2V0c1ZhbHVlXTtcclxuXHRcdGNvbnN0IG9yZGVyQXNjID0gJCQuaXNPcmRlckFzYygpO1xyXG5cdFx0Y29uc3Qgb3JkZXJEZXNjID0gJCQuaXNPcmRlckRlc2MoKTtcclxuXHJcblx0XHRpZiAob3JkZXJBc2MgfHwgb3JkZXJEZXNjKSB7XHJcblx0XHRcdHRhcmdldHMuc29ydCgodDEsIHQyKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgcmVkdWNlciA9IChwLCBjKSA9PiBwICsgTWF0aC5hYnMoYy52YWx1ZSk7XHJcblx0XHRcdFx0Y29uc3QgdDFTdW0gPSB0MS52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApO1xyXG5cdFx0XHRcdGNvbnN0IHQyU3VtID0gdDIudmFsdWVzLnJlZHVjZShyZWR1Y2VyLCAwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9yZGVyQXNjID8gdDJTdW0gLSB0MVN1bSA6IHQxU3VtIC0gdDJTdW07XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5kYXRhX29yZGVyKSkge1xyXG5cdFx0XHR0YXJnZXRzLnNvcnQoY29uZmlnLmRhdGFfb3JkZXIpO1xyXG5cdFx0fSAvLyBUT0RPOiBhY2NlcHQgbmFtZSBhcnJheSBmb3Igb3JkZXJcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJCeVgodGFyZ2V0cywgeCkge1xyXG5cdFx0cmV0dXJuIG1lcmdlQXJyYXkodGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpLmZpbHRlcih2ID0+IHYueCAtIHggPT09IDApO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlclJlbW92ZU51bGwoZGF0YSkge1xyXG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKGQgPT4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlckJ5WERvbWFpbih0YXJnZXRzLCB4RG9tYWluKSB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0cy5tYXAodCA9PiAoe1xyXG5cdFx0XHRpZDogdC5pZCxcclxuXHRcdFx0aWRfb3JnOiB0LmlkX29yZyxcclxuXHRcdFx0dmFsdWVzOiB0LnZhbHVlcy5maWx0ZXIodiA9PiB4RG9tYWluWzBdIDw9IHYueCAmJiB2LnggPD0geERvbWFpblsxXSlcclxuXHRcdH0pKTtcclxuXHR9LFxyXG5cclxuXHRoYXNEYXRhTGFiZWwoKSB7XHJcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gdGhpcy5jb25maWcuZGF0YV9sYWJlbHM7XHJcblxyXG5cdFx0cmV0dXJuIChpc0Jvb2xlYW4oZGF0YUxhYmVscykgJiYgZGF0YUxhYmVscykgfHxcclxuXHRcdFx0KGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzKSAmJiBub3RFbXB0eShkYXRhTGFiZWxzKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0RGF0YUxhYmVsTGVuZ3RoKG1pbiwgbWF4LCBrZXkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGxlbmd0aHMgPSBbMCwgMF07XHJcblx0XHRjb25zdCBwYWRkaW5nQ29lZiA9IDEuMztcclxuXHJcblx0XHQkJC4kZWwuY2hhcnQuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdEFsbChcIi5kdW1teVwiKVxyXG5cdFx0XHQuZGF0YShbbWluLCBtYXhdKVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChkID0+ICQkLmRhdGFMYWJlbEZvcm1hdChkLmlkKShkKSlcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdGxlbmd0aHNbaV0gPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV0gKiBwYWRkaW5nQ29lZjtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHJldHVybiBsZW5ndGhzO1xyXG5cdH0sXHJcblxyXG5cdGlzTm9uZUFyYyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNUYXJnZXQodGhpcy5kYXRhLnRhcmdldHMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJjKGQpIHtcclxuXHRcdHJldHVybiBcImRhdGFcIiBpbiBkICYmIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRTYW1lWE9mVmFsdWVzKHZhbHVlcywgaW5kZXgpIHtcclxuXHRcdGNvbnN0IHRhcmdldFggPSB2YWx1ZXNbaW5kZXhdLng7XHJcblx0XHRjb25zdCBzYW1lczogYW55W10gPSBbXTtcclxuXHRcdGxldCBpO1xyXG5cclxuXHRcdGZvciAoaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNhbWVzLnB1c2godmFsdWVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSBpbmRleDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGFyZ2V0WCAhPT0gdmFsdWVzW2ldLngpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2FtZXMucHVzaCh2YWx1ZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzYW1lcztcclxuXHR9LFxyXG5cclxuXHRmaW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHMsIHBvcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9IHRhcmdldHMubWFwKHRhcmdldCA9PiAkJC5maW5kQ2xvc2VzdCh0YXJnZXQudmFsdWVzLCBwb3MpKTsgLy8gbWFwIHRvIGFycmF5IG9mIGNsb3Nlc3QgcG9pbnRzIG9mIGVhY2ggdGFyZ2V0XHJcblxyXG5cdFx0Ly8gZGVjaWRlIGNsb3Nlc3QgcG9pbnQgYW5kIHJldHVyblxyXG5cdFx0cmV0dXJuICQkLmZpbmRDbG9zZXN0KGNhbmRpZGF0ZXMsIHBvcyk7XHJcblx0fSxcclxuXHJcblx0ZmluZENsb3Nlc3QodmFsdWVzLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgZGF0YSA9IHZhbHVlcy5maWx0ZXIodiA9PiB2ICYmIGlzVmFsdWUodi52YWx1ZSkpO1xyXG5cdFx0bGV0IG1pbkRpc3QgPSBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHk7XHJcblx0XHRsZXQgY2xvc2VzdDtcclxuXHJcblx0XHQvLyBmaW5kIG1vdXNlb3ZlcmluZyBiYXJcclxuXHRcdGRhdGFcclxuXHRcdFx0LmZpbHRlcih2ID0+ICQkLmlzQmFyVHlwZSh2LmlkKSlcclxuXHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYmFyc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHYuaWQpfSAuJHtDTEFTUy5iYXJ9LSR7di5pbmRleH1gKS5ub2RlKCk7XHJcblxyXG5cdFx0XHRcdGlmICghY2xvc2VzdCAmJiAkJC5pc1dpdGhpbkJhcihzaGFwZSkpIHtcclxuXHRcdFx0XHRcdGNsb3Nlc3QgPSB2O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gZmluZCBjbG9zZXN0IHBvaW50IGZyb20gbm9uLWJhclxyXG5cdFx0ZGF0YVxyXG5cdFx0XHQuZmlsdGVyKHYgPT4gISQkLmlzQmFyVHlwZSh2LmlkKSlcclxuXHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgZCA9ICQkLmRpc3QodiwgcG9zKTtcclxuXHJcblx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0KSB7XHJcblx0XHRcdFx0XHRtaW5EaXN0ID0gZDtcclxuXHRcdFx0XHRcdGNsb3Nlc3QgPSB2O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XHJcblx0fSxcclxuXHJcblx0ZGlzdChkYXRhLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWc6IHtheGlzX3JvdGF0ZWQ6IGlzUm90YXRlZH0sIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgeEluZGV4ID0gaXNSb3RhdGVkID8gMSA6IDA7XHJcblx0XHRjb25zdCB5SW5kZXggPSBpc1JvdGF0ZWQgPyAwIDogMTtcclxuXHRcdGNvbnN0IHkgPSAkJC5jaXJjbGVZKGRhdGEsIGRhdGEuaW5kZXgpO1xyXG5cdFx0Y29uc3QgeCA9IChzY2FsZS56b29tIHx8IHNjYWxlLngpKGRhdGEueCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zW3hJbmRleF0sIDIpICsgTWF0aC5wb3coeSAtIHBvc1t5SW5kZXhdLCAyKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydCBkYXRhIGZvciBzdGVwIHR5cGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgT2JqZWN0IGRhdGEgdmFsdWVzXHJcblx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3Qgc3RlcFR5cGUgPSBjb25maWcubGluZV9zdGVwX3R5cGU7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDYXRlZ29yaXplZCgpO1xyXG5cclxuXHRcdGNvbnN0IGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdO1xyXG5cclxuXHRcdGlmICghaXNSb3RhdGVkICYmICFpc0NhdGVnb3JpemVkKSB7XHJcblx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5zZXJ0ICYgYXBwZW5kIGNsb25pbmcgZmlyc3QvbGFzdCB2YWx1ZSB0byBiZSBmdWxseSByZW5kZXJlZCBjb3ZlcmluZyBvbiBlYWNoIGdhcCBzaWRlc1xyXG5cdFx0Y29uc3QgaWQgPSBjb252ZXJ0ZWRbMF0uaWQ7XHJcblxyXG5cdFx0Ly8gaW5zZXJ0XHJcblx0XHRsZXQgeCA9IGNvbnZlcnRlZFswXS54IC0gMTtcclxuXHRcdGxldCB2YWx1ZSA9IGNvbnZlcnRlZFswXS52YWx1ZTtcclxuXHJcblx0XHRpc0NhdGVnb3JpemVkICYmIGNvbnZlcnRlZC51bnNoaWZ0KHt4LCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRzdGVwVHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiZcclxuXHRcdFx0Y29udmVydGVkLnVuc2hpZnQoe3g6IHggLSAxLCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHQvLyBhcHBlbmRcclxuXHRcdHggPSBjb252ZXJ0ZWQubGVuZ3RoO1xyXG5cdFx0dmFsdWUgPSBjb252ZXJ0ZWRbeCAtIDFdLnZhbHVlO1xyXG5cclxuXHRcdGlzQ2F0ZWdvcml6ZWQgJiYgY29udmVydGVkLnB1c2goe3gsIHZhbHVlLCBpZH0pO1xyXG5cclxuXHRcdHN0ZXBUeXBlID09PSBcInN0ZXAtYmVmb3JlXCIgJiZcclxuXHRcdFx0Y29udmVydGVkLnB1c2goe3g6IHggKyAxLCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRyZXR1cm4gY29udmVydGVkO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRWYWx1ZXNUb1JhbmdlKHZhbHVlcykge1xyXG5cdFx0Y29uc3QgY29udmVydGVkID0gaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzLmNvbmNhdCgpIDogW3ZhbHVlc107XHJcblx0XHRjb25zdCByYW5nZXM6IHt4OiBzdHJpbmcgfCBudW1iZXIsIGlkOiBzdHJpbmcsIHZhbHVlOiBudW1iZXJ9W10gPSBbXTtcclxuXHJcblx0XHRjb252ZXJ0ZWQuZm9yRWFjaChyYW5nZSA9PiB7XHJcblx0XHRcdGNvbnN0IHt4LCBpZH0gPSByYW5nZTtcclxuXHJcblx0XHRcdHJhbmdlcy5wdXNoKHtcclxuXHRcdFx0XHR4LFxyXG5cdFx0XHRcdGlkLFxyXG5cdFx0XHRcdHZhbHVlOiByYW5nZS52YWx1ZVswXVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJhbmdlcy5wdXNoKHtcclxuXHRcdFx0XHR4LFxyXG5cdFx0XHRcdGlkLFxyXG5cdFx0XHRcdHZhbHVlOiByYW5nZS52YWx1ZVsyXVxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiByYW5nZXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRGF0YUF0dHJpYnV0ZXMobmFtZSwgYXR0cnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyZW50ID0gY29uZmlnW2BkYXRhXyR7bmFtZX1gXTtcclxuXHJcblx0XHRpZiAoaXNVbmRlZmluZWQoYXR0cnMpKSB7XHJcblx0XHRcdHJldHVybiBjdXJyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y3VycmVudFtpZF0gPSBhdHRyc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQkJC5yZWRyYXcoe3dpdGhMZWdlbmQ6IHRydWV9KTtcclxuXHJcblx0XHRyZXR1cm4gY3VycmVudDtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmVhUmFuZ2VEYXRhKGQsIHR5cGUpIHtcclxuXHRcdGNvbnN0IHZhbHVlID0gZC52YWx1ZTtcclxuXHJcblx0XHRpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0Y29uc3QgaW5kZXggPSBbXCJoaWdoXCIsIFwibWlkXCIsIFwibG93XCJdLmluZGV4T2YodHlwZSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHZhbHVlW2luZGV4XTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVbdHlwZV07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHJhdGlvIHZhbHVlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgUmF0aW8gZm9yIGdpdmVuIHR5cGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIHZhbHVlIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNQZXJjZW50IENvbnZlcnQgdGhlIHJldHVybiBhcyBwZXJjZW50IG9yIG5vdFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gUmF0aW8gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFJhdGlvKHR5cGUsIGQsIGFzUGVyY2VudCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBhcGkgPSAkJC5hcGk7XHJcblx0XHRsZXQgcmF0aW8gPSAwO1xyXG5cclxuXHRcdGlmIChkICYmIGFwaS5kYXRhLnNob3duKCkubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IGRhdGFWYWx1ZXMgPSBhcGkuZGF0YS52YWx1ZXMuYmluZChhcGkpO1xyXG5cclxuXHRcdFx0cmF0aW8gPSBkLnJhdGlvIHx8IGQudmFsdWU7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJhcmNcIikge1xyXG5cdFx0XHRcdC8vIGlmIGhhcyBwYWRBbmdsZSBzZXQsIGNhbGN1bGF0ZSByYXRlIGJhc2VkIG9uIHZhbHVlXHJcblx0XHRcdFx0aWYgKCQkLnBpZS5wYWRBbmdsZSgpKCkpIHtcclxuXHRcdFx0XHRcdGxldCB0b3RhbCA9ICQkLmdldFRvdGFsRGF0YVN1bSgpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzdGF0ZS5oaWRkZW5UYXJnZXRJZHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHRvdGFsIC09IGRhdGFWYWx1ZXMoc3RhdGUuaGlkZGVuVGFyZ2V0SWRzKS5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyYXRpbyA9IGQudmFsdWUgLyB0b3RhbDtcclxuXHJcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIGJhc2VkIG9uIHRoZSByZW5kZXJlZCBhbmdsZSB2YWx1ZVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyYXRpbyA9IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIChcclxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMSA6IDIpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImluZGV4XCIpIHtcclxuXHRcdFx0XHRsZXQgdG90YWwgPSB0aGlzLmdldFRvdGFsUGVySW5kZXgoKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGxldCBoaWRkZW5TdW0gPSBkYXRhVmFsdWVzKHN0YXRlLmhpZGRlblRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChoaWRkZW5TdW0ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGhpZGRlblN1bSA9IGhpZGRlblN1bVxyXG5cdFx0XHRcdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLm1hcCgodiwgaSkgPT4gKGlzTnVtYmVyKHYpID8gdiA6IDApICsgY3VycltpXSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0dG90YWwgPSB0b3RhbC5tYXAoKHYsIGkpID0+IHYgLSBoaWRkZW5TdW1baV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZC5yYXRpbyA9IGlzTnVtYmVyKGQudmFsdWUpICYmIHRvdGFsICYmIHRvdGFsW2QuaW5kZXhdID4gMCA/XHJcblx0XHRcdFx0XHRkLnZhbHVlIC8gdG90YWxbZC5pbmRleF0gOiAwO1xyXG5cclxuXHRcdFx0XHRyYXRpbyA9IGQucmF0aW87XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdFx0cmF0aW8gPSAocGFyc2VGbG9hdChTdHJpbmcoTWF0aC5tYXgoZC52YWx1ZSwgMCkpKSAvICQkLm1heFZhbHVlKSAqIGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFzUGVyY2VudCAmJiByYXRpbyA/IHJhdGlvICogMTAwIDogcmF0aW87XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCBkYXRhIGluZGV4IHRvIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGlja1ZhbHVlcyBUaWNrIGFycmF5IHZhbHVlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRGF0YUluZGV4QnlYKHRpY2tWYWx1ZXMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRjb25zdCB0aWNrVmFsdWVNYXAgPSB0aWNrVmFsdWVzLnJlZHVjZSgob3V0LCB0aWNrLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbTnVtYmVyKHRpY2sueCldID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gdGlja1ZhbHVlTWFwW051bWJlcih2YWx1ZS54KV07XHJcblxyXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRpbmRleCA9IHZhbHVlSW5kZXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhbHVlLmluZGV4ID0gaW5kZXg7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRsb2FkKHJhd1RhcmdldHMsIGFyZ3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB0YXJnZXRzID0gcmF3VGFyZ2V0cztcclxuXHJcblx0XHRpZiAodGFyZ2V0cykge1xyXG5cdFx0XHQvLyBmaWx0ZXIgbG9hZGluZyB0YXJnZXRzIGlmIG5lZWRlZFxyXG5cdFx0XHRpZiAoYXJncy5maWx0ZXIpIHtcclxuXHRcdFx0XHR0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoYXJncy5maWx0ZXIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZXQgdHlwZSBpZiBhcmdzLnR5cGVzIHx8IGFyZ3MudHlwZSBzcGVjaWZpZWRcclxuXHRcdFx0aWYgKGFyZ3MudHlwZSB8fCBhcmdzLnR5cGVzKSB7XHJcblx0XHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IChhcmdzLnR5cGVzICYmIGFyZ3MudHlwZXNbdC5pZF0pIHx8IGFyZ3MudHlwZTtcclxuXHJcblx0XHRcdFx0XHQkJC5zZXRUYXJnZXRUeXBlKHQuaWQsIHR5cGUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUvQWRkIGRhdGFcclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoZC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xyXG5cdFx0XHRcdFx0XHRkLnZhbHVlcyA9IHRhcmdldHNbaV0udmFsdWVzO1xyXG5cdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cy5jb25jYXQodGFyZ2V0cyk7IC8vIGFkZCByZW1haW5lZFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gUmVkcmF3IHdpdGggbmV3IHRhcmdldHNcclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0YXJncy5kb25lICYmIGFyZ3MuZG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdGxvYWRGcm9tQXJncyhhcmdzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBsb2FkIHdoZW4gY2hhcnQgaXMgYWxyZWFkeSBkZXN0cm95ZWRcclxuXHRcdGlmICghJCQuY29uZmlnKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXNldCBpbnRlcm5hbGx5IGNhY2hlZCBkYXRhXHJcblx0XHQkJC5jYWNoZS5yZXNldCgpO1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBhcmdzLmRhdGEgfHwgJCQuY29udmVydERhdGEoYXJncywgZCA9PiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGQpLCBhcmdzKSk7XHJcblxyXG5cdFx0ZGF0YSAmJiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpLCBhcmdzKTtcclxuXHR9LFxyXG5cclxuXHR1bmxvYWQocmF3VGFyZ2V0SWRzLCBjdXN0b21Eb25lQ2IpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0bGV0IGRvbmUgPSBjdXN0b21Eb25lQ2I7XHJcblx0XHRsZXQgdGFyZ2V0SWRzID0gcmF3VGFyZ2V0SWRzO1xyXG5cclxuXHRcdC8vIHJlc2V0IGludGVybmFsbHkgY2FjaGVkIGRhdGFcclxuXHRcdCQkLmNhY2hlLnJlc2V0KCk7XHJcblxyXG5cdFx0aWYgKCFkb25lKSB7XHJcblx0XHRcdGRvbmUgPSAoKSA9PiB7fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaWx0ZXIgZXhpc3RpbmcgdGFyZ2V0XHJcblx0XHR0YXJnZXRJZHMgPSB0YXJnZXRJZHMuZmlsdGVyKGlkID0+ICQkLmhhc1RhcmdldCgkJC5kYXRhLnRhcmdldHMsIGlkKSk7XHJcblxyXG5cdFx0Ly8gSWYgbm8gdGFyZ2V0LCBjYWxsIGRvbmUgYW5kIHJldHVyblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMgfHwgdGFyZ2V0SWRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRkb25lKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuc3ZnLnNlbGVjdEFsbCh0YXJnZXRJZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkKSkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpXHJcblx0XHRcdC5jYWxsKCQkLmVuZGFsbCwgZG9uZSk7XHJcblxyXG5cdFx0dGFyZ2V0SWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHQvLyBSZXNldCBmYWRlaW4gZm9yIGZ1dHVyZSBsb2FkXHJcblx0XHRcdHN0YXRlLndpdGhvdXRGYWRlSW5baWRdID0gZmFsc2U7XHJcblx0XHRcdC8vIFJlbW92ZSB0YXJnZXQncyBlbGVtZW50c1xyXG5cdFx0XHRpZiAoJGVsLmxlZ2VuZCkge1xyXG5cdFx0XHRcdCRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWApLnJlbW92ZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIFJlbW92ZSB0YXJnZXRcclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0ID0+IHQuaWQgIT09IGlkKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdG1vdXNlIGFzIGQzTW91c2UsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RyYWcgYXMgZDNEcmFnfSBmcm9tIFwiZDMtZHJhZ1wiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7ZW11bGF0ZUV2ZW50LCBpc051bWJlciwgaXNPYmplY3R9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEhhbmRsZSBkYXRhLm9ub3Zlci9vdXQgY2FsbGJhY2sgb3B0aW9uc1xyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRPdmVyT3V0KGlzT3ZlciwgZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc0FyYyA9IGlzT2JqZWN0KGQpO1xyXG5cclxuXHRcdC8vIENhbGwgZXZlbnQgaGFuZGxlclxyXG5cdFx0aWYgKGlzQXJjIHx8IGQgIT09IC0xKSB7XHJcblx0XHRcdGxldCBjYWxsYmFjayA9IGNvbmZpZ1tpc092ZXIgPyBcImRhdGFfb25vdmVyXCIgOiBcImRhdGFfb25vdXRcIl0uYmluZCgkJC5hcGkpO1xyXG5cclxuXHRcdFx0Y29uZmlnLmNvbG9yX29ub3ZlciAmJiAkJC5zZXRPdmVyQ29sb3IoaXNPdmVyLCBkLCBpc0FyYyk7XHJcblxyXG5cdFx0XHRpZiAoaXNBcmMpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhkLCBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXJjfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YCkubm9kZSgpKTtcclxuXHRcdFx0fSBlbHNlIGlmICghY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xyXG5cdFx0XHRcdGNvbnN0IGNhbGxlZSA9ICQkLnNldE92ZXJPdXQ7XHJcblx0XHRcdFx0bGV0IGxhc3QgPSBjYWxsZWUubGFzdCB8fCBbXTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7ZH1gKVxyXG5cdFx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHNoYXBlXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdGlmIChsYXN0Lmxlbmd0aCA9PT0gMCB8fCBsYXN0LmV2ZXJ5KHYgPT4gdiAhPT0gdGhpcykpIHtcclxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhkLCB0aGlzKTtcclxuXHRcdFx0XHRcdFx0XHRsYXN0LnB1c2godGhpcyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAobGFzdC5sZW5ndGggPiAwICYmIHNoYXBlLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrID0gY29uZmlnLmRhdGFfb25vdXQuYmluZCgkJC5hcGkpO1xyXG5cclxuXHRcdFx0XHRcdGxhc3QuZm9yRWFjaCh2ID0+IGNhbGxiYWNrKGQzU2VsZWN0KHYpLmRhdHVtKCksIHYpKTtcclxuXHRcdFx0XHRcdGxhc3QgPSBbXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNhbGxlZS5sYXN0ID0gbGFzdDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpc092ZXIgJiYgJCQuZXhwYW5kQ2lyY2xlc0JhcnMoZCwgbnVsbCwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdCEkJC5pc011bHRpcGxlWCgpICYmIG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBmb3IgdG91Y2ggZXZlbnRcclxuXHQgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IGQgdGFyZ2V0IGluZGV4IG9yIGRhdGEgb2JqZWN0IGZvciBBcmMgdHlwZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Y2FsbE92ZXJPdXRGb3JUb3VjaChkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjYWxsZWUgPSAkJC5jYWxsT3Zlck91dEZvclRvdWNoO1xyXG5cdFx0Y29uc3Qge2xhc3R9ID0gY2FsbGVlO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChkKSAmJiBsYXN0ID8gZC5pZCAhPT0gbGFzdC5pZCA6IChkICE9PSBsYXN0KSkge1xyXG5cdFx0XHQobGFzdCB8fCBpc051bWJlcihsYXN0KSkgJiYgJCQuc2V0T3Zlck91dChmYWxzZSwgbGFzdCk7XHJcblx0XHRcdChkIHx8IGlzTnVtYmVyKGQpKSAmJiAkJC5zZXRPdmVyT3V0KHRydWUsIGQpO1xyXG5cclxuXHRcdFx0Y2FsbGVlLmxhc3QgPSBkO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybiBkcmFnZ2FibGUgc2VsZWN0aW9uIGZ1bmN0aW9uXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXREcmFnZ2FibGVTZWxlY3Rpb24oKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25fZHJhZ2dhYmxlICYmICQkLmRyYWcgP1xyXG5cdFx0XHRkM0RyYWcoKVxyXG5cdFx0XHRcdC5vbihcImRyYWdcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHQkJC5kcmFnKGQzTW91c2UodGhpcykpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwic3RhcnRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHQkJC5kcmFnc3RhcnQoZDNNb3VzZSh0aGlzKSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJlbmRcIiwgKCkgPT4geyAkJC5kcmFnZW5kKCk7IH0pIDogKCkgPT4ge307XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2ggYSBtb3VzZSBldmVudC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGV2ZW50IHR5cGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2YgZXZlbnRSZWN0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gbW91c2UgeCBhbmQgeSBjb29yZGluYXRlIHZhbHVlXHJcblx0ICovXHJcblx0ZGlzcGF0Y2hFdmVudCh0eXBlLCBpbmRleCwgbW91c2UpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKTtcclxuXHRcdGNvbnN0IHNlbGVjdG9yID0gYC4ke2lzTXVsdGlwbGVYID8gQ0xBU1MuZXZlbnRSZWN0IDogYCR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWB9YDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLiRlbC5tYWluLnNlbGVjdChzZWxlY3Rvcikubm9kZSgpO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBsZWZ0LCB0b3B9ID0gZXZlbnRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdFx0Y29uc3QgeCA9IGxlZnQgKyAobW91c2UgPyBtb3VzZVswXSA6IDApICsgKFxyXG5cdFx0XHRpc011bHRpcGxlWCB8fCAkJC5jb25maWcuYXhpc19yb3RhdGVkID8gMCA6ICh3aWR0aCAvIDIpXHJcblx0XHQpO1xyXG5cdFx0Y29uc3QgeSA9IHRvcCArIChtb3VzZSA/IG1vdXNlWzFdIDogMCk7XHJcblx0XHRjb25zdCBwYXJhbXMgPSB7XHJcblx0XHRcdHNjcmVlblg6IHgsXHJcblx0XHRcdHNjcmVlblk6IHksXHJcblx0XHRcdGNsaWVudFg6IHgsXHJcblx0XHRcdGNsaWVudFk6IHlcclxuXHRcdH07XHJcblxyXG5cdFx0ZW11bGF0ZUV2ZW50Wy9eKG1vdXNlfGNsaWNrKS8udGVzdCh0eXBlKSA/IFwibW91c2VcIiA6IFwidG91Y2hcIl0oZXZlbnRSZWN0LCB0eXBlLCBwYXJhbXMpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2VuZXJhdGVDbGFzcyhwcmVmaXgsIHRhcmdldElkKSB7XHJcblx0XHRyZXR1cm4gYCAke3ByZWZpeH0gJHtwcmVmaXggKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKX1gO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzVGV4dChkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRleHQsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzVGV4dHMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy50ZXh0cywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NTaGFwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnNoYXBlLCBkLmluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc1NoYXBlcyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnNoYXBlcywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVFeHRyYUxpbmVDbGFzcygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNsYXNzZXMgPSAkJC5jb25maWcubGluZV9jbGFzc2VzIHx8IFtdO1xyXG5cdFx0Y29uc3QgaWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkKSB7XHJcblx0XHRcdGNvbnN0IGlkOiBzdHJpbmcgPSBkLmlkIHx8IChkLmRhdGEgJiYgZC5kYXRhLmlkKSB8fCBkO1xyXG5cclxuXHRcdFx0aWYgKGlkcy5pbmRleE9mKGlkKSA8IDApIHtcclxuXHRcdFx0XHRpZHMucHVzaChpZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBjbGFzc2VzW2lkcy5pbmRleE9mKGlkKSAlIGNsYXNzZXMubGVuZ3RoXTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Y2xhc3NMaW5lKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGluZSwgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NMaW5lcyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lcywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaXJjbGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5jaXJjbGUsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2lyY2xlcyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlcyhkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5jaXJjbGVzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0JhcihkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmJhciwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NCYXJzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmJhcnMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJjKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZC5kYXRhKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmMsIGQuZGF0YS5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NBcmNzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQuZGF0YSkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJjcywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0FyZWEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmVhLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0FyZWFzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyZWFzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc1JlZ2lvbihkLCBpKSB7XHJcblx0XHRyZXR1cm4gYCR7dGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnJlZ2lvbiwgaSl9ICR7XCJjbGFzc1wiIGluIGQgPyBkLmNsYXNzIDogXCJcIn1gO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzRXZlbnQoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5ldmVudFJlY3QsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzVGFyZ2V0KGlkKSB7XHJcblx0XHRjb25zdCBhZGRpdGlvbmFsQ2xhc3NTdWZmaXggPSB0aGlzLmNvbmZpZy5kYXRhX2NsYXNzZXNbaWRdO1xyXG5cdFx0bGV0IGFkZGl0aW9uYWxDbGFzcyA9IFwiXCI7XHJcblxyXG5cdFx0aWYgKGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCkge1xyXG5cdFx0XHRhZGRpdGlvbmFsQ2xhc3MgPSBgICR7Q0xBU1MudGFyZ2V0fS0ke2FkZGl0aW9uYWxDbGFzc1N1ZmZpeH1gO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGFyZ2V0LCBpZCkgKyBhZGRpdGlvbmFsQ2xhc3M7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NGb2N1cyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc0ZvY3VzZWQoZCkgKyB0aGlzLmNsYXNzRGVmb2N1c2VkKGQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzRm9jdXNlZChkKSB7XHJcblx0XHRyZXR1cm4gYCAke3RoaXMuc3RhdGUuZm9jdXNlZFRhcmdldElkcy5pbmRleE9mKGQuaWQpID49IDAgPyBDTEFTUy5mb2N1c2VkIDogXCJcIn1gO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzRGVmb2N1c2VkKGQpIHtcclxuXHRcdHJldHVybiBgICR7dGhpcy5zdGF0ZS5kZWZvY3VzZWRUYXJnZXRJZHMuaW5kZXhPZihkLmlkKSA+PSAwID8gQ0xBU1MuZGVmb2N1c2VkIDogXCJcIn1gO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRUZXh0KGQpIHtcclxuXHRcdHJldHVybiBDTEFTUy5jaGFydFRleHQgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRMaW5lKGQpIHtcclxuXHRcdHJldHVybiBDTEFTUy5jaGFydExpbmUgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRCYXIoZCkge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QmFyICsgdGhpcy5jbGFzc1RhcmdldChkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NoYXJ0QXJjKGQpIHtcclxuXHRcdHJldHVybiBDTEFTUy5jaGFydEFyYyArIHRoaXMuY2xhc3NUYXJnZXQoZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NoYXJ0UmFkYXIoZCkge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0UmFkYXIgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKSB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0SWQgfHwgdGFyZ2V0SWQgPT09IDAgP1xyXG5cdFx0XHRgLSR7dGFyZ2V0SWR9YC5yZXBsYWNlKC9bXFxzPyFAIyQlXiYqKClfPSssLjw+J1wiOjtcXFtcXF1cXC98fmB7fVxcXFxdL2csIFwiLVwiKSA6IFwiXCI7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JUYXJnZXQoaWQsIHByZWZpeCkge1xyXG5cdFx0cmV0dXJuIGAke3ByZWZpeCB8fCBcIlwifS4ke0NMQVNTLnRhcmdldCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWA7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JUYXJnZXRzKGlkc1ZhbHVlLCBwcmVmaXgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlkcyA9IGlkc1ZhbHVlIHx8IFtdO1xyXG5cclxuXHRcdHJldHVybiBpZHMubGVuZ3RoID9cclxuXHRcdFx0aWRzLm1hcChpZCA9PiAkJC5zZWxlY3RvclRhcmdldChpZCwgcHJlZml4KSkgOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdG9yTGVnZW5kKGlkKSB7XHJcblx0XHRyZXR1cm4gYC4ke0NMQVNTLmxlZ2VuZEl0ZW0gKyB0aGlzLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gO1xyXG5cdH0sXHJcblxyXG5cdHNlbGVjdG9yTGVnZW5kcyhpZHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gaWRzICYmIGlkcy5sZW5ndGggP1xyXG5cdFx0XHRpZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yTGVnZW5kKGlkKSkgOiBudWxsO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtzY2FsZU9yZGluYWwgYXMgZDNTY2FsZU9yZGluYWx9IGZyb20gXCJkMy1zY2FsZVwiO1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7bm90RW1wdHksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogU2V0IHBhdHRlcm4ncyBiYWNrZ3JvdW5kIGNvbG9yXHJcbiAqIChpdCBhZGRzIGEgPHJlY3Q+IGVsZW1lbnQgdG8gc2ltdWxhdGUgYmctY29sb3IpXHJcbiAqIEBwYXJhbSB7U1ZHUGF0dGVybkVsZW1lbnR9IHBhdHRlcm4gU1ZHIHBhdHRlcm4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3Igc3RyaW5nXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBJRCB0byBiZSBzZXRcclxuICogQHJldHVybiB7e2lkOiBzdHJpbmcsIG5vZGU6IFNWR1BhdHRlcm5FbGVtZW50fX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNvbG9yaXplUGF0dGVybiA9IChwYXR0ZXJuLCBjb2xvciwgaWQ6IHN0cmluZykgPT4ge1xyXG5cdGNvbnN0IG5vZGUgPSBkM1NlbGVjdChwYXR0ZXJuLmNsb25lTm9kZSh0cnVlKSk7XHJcblxyXG5cdG5vZGVcclxuXHRcdC5hdHRyKFwiaWRcIiwgaWQpXHJcblx0XHQuaW5zZXJ0KFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKVxyXG5cdFx0LmF0dHIoXCJ3aWR0aFwiLCBub2RlLmF0dHIoXCJ3aWR0aFwiKSlcclxuXHRcdC5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuYXR0cihcImhlaWdodFwiKSlcclxuXHRcdC5zdHlsZShcImZpbGxcIiwgY29sb3IpO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0aWQsXHJcblx0XHRub2RlOiBub2RlLm5vZGUoKVxyXG5cdH07XHJcbn07XHJcblxyXG4vLyBSZXBsYWNlbWVudCBvZiBkMy5zY2hlbWVDYXRlZ29yeTEwLlxyXG4vLyBDb250YWluZWQgZGlmZmVyZW50bHkgZGVwZW5kIG9uIGQzIHZlcnNpb246IHY0KGQzLXNjYWxlKSwgdjUoZDMtc2NhbGUtY2hyb21hdGljKVxyXG5jb25zdCBzY2hlbWVDYXRlZ29yeTEwID0gW1wiIzFmNzdiNFwiLCBcIiNmZjdmMGVcIiwgXCIjMmNhMDJjXCIsIFwiI2Q2MjcyOFwiLCBcIiM5NDY3YmRcIiwgXCIjOGM1NjRiXCIsIFwiI2UzNzdjMlwiLCBcIiM3ZjdmN2ZcIiwgXCIjYmNiZDIyXCIsIFwiIzE3YmVjZlwiXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBHZXQgY29sb3IgcGF0dGVybiBmcm9tIENTUyBmaWxlXHJcblx0ICogQ1NTIHNob3VsZCBiZSBkZWZpbmVkIGFzOiBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIjMDBjNzNjOyNmYTcxNzE7IC4uLlwiKTtcclxuXHQgKiBAcmV0dXJuIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldENvbG9yRnJvbUNzcygpIHtcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCJfX2NvbG9yUGF0dGVybl9fXCI7XHJcblx0XHRjb25zdCB7Ym9keX0gPSBkb2N1bWVudDtcclxuXHRcdGxldCBwYXR0ZXJuID0gYm9keVtjYWNoZUtleV07XHJcblxyXG5cdFx0aWYgKCFwYXR0ZXJuKSB7XHJcblx0XHRcdGNvbnN0IGRlbGltaXRlciA9IFwiO1wiO1xyXG5cdFx0XHRjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcblxyXG5cdFx0XHRzcGFuLmNsYXNzTmFtZSA9IENMQVNTLmNvbG9yUGF0dGVybjtcclxuXHRcdFx0c3Bhbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcblx0XHRcdGJvZHkuYXBwZW5kQ2hpbGQoc3Bhbik7XHJcblxyXG5cdFx0XHRjb25zdCBjb250ZW50ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuYmFja2dyb3VuZEltYWdlO1xyXG5cclxuXHRcdFx0c3Bhbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNwYW4pO1xyXG5cclxuXHRcdFx0aWYgKGNvbnRlbnQuaW5kZXhPZihkZWxpbWl0ZXIpID4gLTEpIHtcclxuXHRcdFx0XHRwYXR0ZXJuID0gY29udGVudFxyXG5cdFx0XHRcdFx0LnJlcGxhY2UoL3VybFteI10qfFtcIicoKV18KFxcc3wlMjApL2csIFwiXCIpXHJcblx0XHRcdFx0XHQuc3BsaXQoZGVsaW1pdGVyKVxyXG5cdFx0XHRcdFx0Lm1hcCh2ID0+IHYudHJpbSgpLnJlcGxhY2UoL1tcXFwiJ1xcc10vZywgXCJcIikpXHJcblx0XHRcdFx0XHQuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuXHRcdFx0XHRib2R5W2NhY2hlS2V5XSA9IHBhdHRlcm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGF0dGVybjtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUNvbG9yKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5kYXRhX2NvbG9ycztcclxuXHRcdGNvbnN0IGNhbGxiYWNrID0gY29uZmlnLmRhdGFfY29sb3I7XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0bGV0IHBhdHRlcm4gPSBub3RFbXB0eShjb25maWcuY29sb3JfcGF0dGVybikgPyBjb25maWcuY29sb3JfcGF0dGVybiA6XHJcblx0XHRcdGQzU2NhbGVPcmRpbmFsKCQkLmdldENvbG9yRnJvbUNzcygpIHx8IHNjaGVtZUNhdGVnb3J5MTApLnJhbmdlKCk7XHJcblxyXG5cdFx0Y29uc3Qgb3JpZ2luYWxDb2xvclBhdHRlcm4gPSBwYXR0ZXJuO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5jb2xvcl90aWxlcykpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBjb25maWcuY29sb3JfdGlsZXMoKTtcclxuXHJcblx0XHRcdC8vIEFkZCBiYWNrZ3JvdW5kIGNvbG9yIHRvIHBhdHRlcm5zXHJcblx0XHRcdGNvbnN0IGNvbG9yaXplZFBhdHRlcm5zID0gcGF0dGVybi5tYXAoKHAsIGluZGV4KSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY29sb3IgPSBwLnJlcGxhY2UoL1sjXFwoXFwpXFxzLF0vZywgXCJcIik7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSBgJHskJC5zdGF0ZS5kYXRldGltZUlkfS1wYXR0ZXJuLSR7Y29sb3J9LSR7aW5kZXh9YDtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNvbG9yaXplUGF0dGVybih0aWxlc1tpbmRleCAlIHRpbGVzLmxlbmd0aF0sIHAsIGlkKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRwYXR0ZXJuID0gY29sb3JpemVkUGF0dGVybnMubWFwKHAgPT4gYHVybCgjJHtwLmlkfSlgKTtcclxuXHRcdFx0JCQucGF0dGVybnMgPSBjb2xvcml6ZWRQYXR0ZXJucztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRjb25zdCBpZDogc3RyaW5nID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcclxuXHRcdFx0Y29uc3QgaXNMaW5lID0gJCQuaXNUeXBlT2YoaWQsIFtcImxpbmVcIiwgXCJzcGxpbmVcIiwgXCJzdGVwXCJdKSB8fCAhY29uZmlnLmRhdGFfdHlwZXNbaWRdO1xyXG5cdFx0XHRsZXQgY29sb3I7XHJcblxyXG5cdFx0XHQvLyBpZiBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZFxyXG5cdFx0XHRpZiAoaXNGdW5jdGlvbihjb2xvcnNbaWRdKSkge1xyXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzW2lkXShkKTtcclxuXHJcblx0XHRcdC8vIGlmIHNwZWNpZmllZCwgY2hvb3NlIHRoYXQgY29sb3JcclxuXHRcdFx0fSBlbHNlIGlmIChjb2xvcnNbaWRdKSB7XHJcblx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaWRdO1xyXG5cclxuXHRcdFx0Ly8gaWYgbm90IHNwZWNpZmllZCwgY2hvb3NlIGZyb20gcGF0dGVyblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmIChpZHMuaW5kZXhPZihpZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRpZHMucHVzaChpZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvciA9IGlzTGluZSA/IG9yaWdpbmFsQ29sb3JQYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIG9yaWdpbmFsQ29sb3JQYXR0ZXJuLmxlbmd0aF0gOlxyXG5cdFx0XHRcdFx0cGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBwYXR0ZXJuLmxlbmd0aF07XHJcblxyXG5cdFx0XHRcdGNvbG9yc1tpZF0gPSBjb2xvcjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGlzRnVuY3Rpb24oY2FsbGJhY2spID9cclxuXHRcdFx0XHRjYWxsYmFjayhjb2xvciwgZCkgOiBjb2xvcjtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVMZXZlbENvbG9yKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5jb2xvcl9wYXR0ZXJuO1xyXG5cdFx0Y29uc3QgdGhyZXNob2xkID0gY29uZmlnLmNvbG9yX3RocmVzaG9sZDtcclxuXHRcdGNvbnN0IGFzVmFsdWUgPSB0aHJlc2hvbGQudW5pdCA9PT0gXCJ2YWx1ZVwiO1xyXG5cdFx0Y29uc3QgbWF4ID0gdGhyZXNob2xkLm1heCB8fCAxMDA7XHJcblx0XHRjb25zdCB2YWx1ZXMgPSB0aHJlc2hvbGQudmFsdWVzICYmXHJcblx0XHRcdHRocmVzaG9sZC52YWx1ZXMubGVuZ3RoID8gdGhyZXNob2xkLnZhbHVlcyA6IFtdO1xyXG5cclxuXHRcdHJldHVybiBub3RFbXB0eSh0aHJlc2hvbGQpID8gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0Y29uc3QgdiA9IGFzVmFsdWUgPyB2YWx1ZSA6ICh2YWx1ZSAqIDEwMCAvIG1heCk7XHJcblx0XHRcdGxldCBjb2xvciA9IGNvbG9yc1tjb2xvcnMubGVuZ3RoIC0gMV07XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodiA8PSB2YWx1ZXNbaV0pIHtcclxuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzW2ldO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY29sb3I7XHJcblx0XHR9IDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIGRhdGEgb3ZlciBjb2xvci5cclxuXHQgKiBXaGVuIGlzIG91dCwgd2lsbCByZXN0YXRlIGluIGl0cyBwcmV2aW91cyBjb2xvciB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyIHRydWU6IHNldCBvdmVyZWQgY29sb3IsIGZhbHNlOiByZXN0b3JlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkIHRhcmdldCBpbmRleCBvciBkYXRhIG9iamVjdCBmb3IgQXJjIHR5cGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldE92ZXJDb2xvcihpc092ZXIsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgb25vdmVyID0gY29uZmlnLmNvbG9yX29ub3ZlcjtcclxuXHRcdGxldCBjb2xvciA9IGlzT3ZlciA/IG9ub3ZlciA6ICQkLmNvbG9yO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb2xvcikpIHtcclxuXHRcdFx0Y29sb3IgPSAoe2lkfSkgPT4gKGlkIGluIG9ub3ZlciA/IG9ub3ZlcltpZF0gOiAkJC5jb2xvcihpZCkpO1xyXG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhjb2xvcikpIHtcclxuXHRcdFx0Y29sb3IgPSAoKSA9PiBvbm92ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2hlbiBpcyBBcmMgdHlwZVxyXG5cdFx0aWYgKGlzT2JqZWN0KGQpKSB7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgY29sb3IoZCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2R9YClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHticnVzaEVtcHR5LCBnZXRCcnVzaFNlbGVjdGlvbiwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIG5vdEVtcHR5LCBpc1ZhbHVlLCBpc09iamVjdCwgaXNOdW1iZXIsIGRpZmZEb21haW4sIHNvcnRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNNaW4gPSB0eXBlID09PSBcIm1pblwiO1xyXG5cclxuXHRcdGNvbnN0IGRhdGFHcm91cHMgPSBjb25maWcuZGF0YV9ncm91cHM7XHJcblx0XHRjb25zdCBpZHMgPSAkJC5tYXBUb0lkcyh0YXJnZXRzKTtcclxuXHRcdGNvbnN0IHlzID0gJCQuZ2V0VmFsdWVzQXNJZEtleWVkKHRhcmdldHMpO1xyXG5cclxuXHRcdGlmIChkYXRhR3JvdXBzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0Y29uc3QgaGFzVmFsdWUgPSAkJFtgaGFzJHtpc01pbiA/IFwiTmVnYXRpdmVcIiA6IFwiUG9zaXRpdmVcIn1WYWx1ZUluVGFyZ2V0c2BdKHRhcmdldHMpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaiA9IDAsIGlkc0luR3JvdXA7IChpZHNJbkdyb3VwID0gZGF0YUdyb3Vwc1tqXSk7IGorKykge1xyXG5cdFx0XHRcdC8vIERldGVybWluZSBiYXNlSWRcclxuXHRcdFx0XHRpZHNJbkdyb3VwID0gaWRzSW5Hcm91cC5maWx0ZXIodiA9PiBpZHMuaW5kZXhPZih2KSA+PSAwKTtcclxuXHJcblx0XHRcdFx0aWYgKGlkc0luR3JvdXAubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJhc2VJZCA9IGlkc0luR3JvdXBbMF07XHJcblx0XHRcdFx0Y29uc3QgYmFzZUF4aXNJZCA9ICQkLmF4aXMuZ2V0SWQoYmFzZUlkKTtcclxuXHJcblx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBiYXNlIHZhbHVlLiBTZXQgdG8gMCBpZiBub3QgbWF0Y2ggd2l0aCB0aGUgY29uZGl0aW9uXHJcblx0XHRcdFx0aWYgKGhhc1ZhbHVlICYmIHlzW2Jhc2VJZF0pIHtcclxuXHRcdFx0XHRcdHlzW2Jhc2VJZF0gPSB5c1tiYXNlSWRdLm1hcCh2ID0+IChcclxuXHRcdFx0XHRcdFx0KGlzTWluID8gdiA8IDAgOiB2ID4gMCkgPyB2IDogMFxyXG5cdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBrID0gMSwgaWQ7IChpZCA9IGlkc0luR3JvdXBba10pOyBrKyspIHtcclxuXHRcdFx0XHRcdGlmICgheXNbaWRdKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGF4aXNJZCA9ICQkLmF4aXMuZ2V0SWQoaWQpO1xyXG5cclxuXHRcdFx0XHRcdHlzW2lkXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHZhbCA9ICt2O1xyXG5cdFx0XHRcdFx0XHRjb25zdCBtZWV0Q29uZGl0aW9uID0gaXNNaW4gPyB2YWwgPiAwIDogdmFsIDwgMDtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChheGlzSWQgPT09IGJhc2VBeGlzSWQgJiYgIShoYXNWYWx1ZSAmJiBtZWV0Q29uZGl0aW9uKSkge1xyXG5cdFx0XHRcdFx0XHRcdHlzW2Jhc2VJZF1baV0gKz0gdmFsO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0TWluTWF4KHR5cGUsIE9iamVjdC5rZXlzKHlzKS5tYXAoa2V5ID0+IGdldE1pbk1heCh0eXBlLCB5c1trZXldKSkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFlEb21haW5NaW4odGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1pblwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluTWF4KHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0WURvbWFpbih0YXJnZXRzLCBheGlzSWQsIHhEb21haW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpKSB7XHJcblx0XHRcdHJldHVybiBbMCwgMTAwXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0YXJnZXRzQnlBeGlzSWQgPSB0YXJnZXRzLmZpbHRlcih0ID0+ICQkLmF4aXMuZ2V0SWQodC5pZCkgPT09IGF4aXNJZCk7XHJcblx0XHRjb25zdCB5VGFyZ2V0cyA9IHhEb21haW4gPyAkJC5maWx0ZXJCeVhEb21haW4odGFyZ2V0c0J5QXhpc0lkLCB4RG9tYWluKSA6IHRhcmdldHNCeUF4aXNJZDtcclxuXHJcblx0XHRpZiAoeVRhcmdldHMubGVuZ3RoID09PSAwKSB7IC8vIHVzZSBkb21haW4gb2YgdGhlIG90aGVyIGF4aXMgaWYgdGFyZ2V0IG9mIGF4aXNJZCBpcyBub25lXHJcblx0XHRcdHJldHVybiBheGlzSWQgPT09IFwieTJcIiA/XHJcblx0XHRcdFx0c2NhbGUueS5kb21haW4oKSA6XHJcblx0XHRcdFx0Ly8gV2hlbiBhbGwgZGF0YSBib3VuZHMgdG8geTIsIHkgQXhpcyBkb21haW4gaXMgY2FsbGVkIHByaW9yIHkyLlxyXG5cdFx0XHRcdC8vIFNvLCBpdCBuZWVkcyB0byBjYWxsIHRvIGdldCB5MiBkb21haW4gaGVyZVxyXG5cdFx0XHRcdCQkLmdldFlEb21haW4odGFyZ2V0cywgXCJ5MlwiLCB4RG9tYWluKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB5TWluID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9taW5gXTtcclxuXHRcdGNvbnN0IHlNYXggPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X21heGBdO1xyXG5cdFx0bGV0IHlEb21haW5NaW4gPSAkJC5nZXRZRG9tYWluTWluKHlUYXJnZXRzKTtcclxuXHRcdGxldCB5RG9tYWluTWF4ID0gJCQuZ2V0WURvbWFpbk1heCh5VGFyZ2V0cyk7XHJcblxyXG5cdFx0Y29uc3QgY2VudGVyID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9jZW50ZXJgXTtcclxuXHRcdGxldCBpc1plcm9CYXNlZCA9IFtcImFyZWFcIiwgXCJiYXJcIiwgXCJidWJibGVcIiwgXCJsaW5lXCIsIFwic2NhdHRlclwiXVxyXG5cdFx0XHQuc29tZSh2ID0+ICQkLmhhc1R5cGUodiwgeVRhcmdldHMpICYmIGNvbmZpZ1tgJHt2fV96ZXJvYmFzZWRgXSk7XHJcblx0XHRjb25zdCBpc0ludmVydGVkID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9pbnZlcnRlZGBdO1xyXG5cdFx0Y29uc3Qgc2hvd0hvcml6b250YWxEYXRhTGFiZWwgPSAkJC5oYXNEYXRhTGFiZWwoKSAmJiBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3Qgc2hvd1ZlcnRpY2FsRGF0YUxhYmVsID0gJCQuaGFzRGF0YUxhYmVsKCkgJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Ly8gTUVNTzogYXZvaWQgaW52ZXJ0aW5nIGRvbWFpbiB1bmV4cGVjdGVkbHlcclxuXHRcdHlEb21haW5NaW4gPSBpc1ZhbHVlKHlNaW4pID8geU1pbiA6XHJcblx0XHRcdChpc1ZhbHVlKHlNYXgpID8gKHlEb21haW5NaW4gPCB5TWF4ID8geURvbWFpbk1pbiA6IHlNYXggLSAxMCkgOiB5RG9tYWluTWluKTtcclxuXHRcdHlEb21haW5NYXggPSBpc1ZhbHVlKHlNYXgpID8geU1heCA6XHJcblx0XHRcdChpc1ZhbHVlKHlNaW4pID8gKHlNaW4gPCB5RG9tYWluTWF4ID8geURvbWFpbk1heCA6IHlNaW4gKyAxMCkgOiB5RG9tYWluTWF4KTtcclxuXHJcblx0XHRpZiAoaXNOYU4oeURvbWFpbk1pbikpIHsgLy8gc2V0IG1pbmltdW0gdG8gemVybyB3aGVuIG5vdCBudW1iZXJcclxuXHRcdFx0eURvbWFpbk1pbiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzTmFOKHlEb21haW5NYXgpKSB7IC8vIHNldCBtYXhpbXVtIHRvIGhhdmUgc2FtZSB2YWx1ZSBhcyB5RG9tYWluTWluXHJcblx0XHRcdHlEb21haW5NYXggPSB5RG9tYWluTWluO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh5RG9tYWluTWluID09PSB5RG9tYWluTWF4KSB7XHJcblx0XHRcdHlEb21haW5NaW4gPCAwID8geURvbWFpbk1heCA9IDAgOiB5RG9tYWluTWluID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc0FsbFBvc2l0aXZlID0geURvbWFpbk1pbiA+PSAwICYmIHlEb21haW5NYXggPj0gMDtcclxuXHRcdGNvbnN0IGlzQWxsTmVnYXRpdmUgPSB5RG9tYWluTWluIDw9IDAgJiYgeURvbWFpbk1heCA8PSAwO1xyXG5cclxuXHRcdC8vIENhbmNlbCB6ZXJvYmFzZWQgaWYgYXhpc18qX21pbiAvIGF4aXNfKl9tYXggc3BlY2lmaWVkXHJcblx0XHRpZiAoKGlzVmFsdWUoeU1pbikgJiYgaXNBbGxQb3NpdGl2ZSkgfHwgKGlzVmFsdWUoeU1heCkgJiYgaXNBbGxOZWdhdGl2ZSkpIHtcclxuXHRcdFx0aXNaZXJvQmFzZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBCYXIvQXJlYSBjaGFydCBzaG91bGQgYmUgMC1iYXNlZCBpZiBhbGwgcG9zaXRpdmV8bmVnYXRpdmVcclxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xyXG5cdFx0XHRpc0FsbFBvc2l0aXZlICYmICh5RG9tYWluTWluID0gMCk7XHJcblx0XHRcdGlzQWxsTmVnYXRpdmUgJiYgKHlEb21haW5NYXggPSAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkb21haW5MZW5ndGggPSBNYXRoLmFicyh5RG9tYWluTWF4IC0geURvbWFpbk1pbik7XHJcblx0XHRjb25zdCBwYWRkaW5nID0ge3RvcDogZG9tYWluTGVuZ3RoICogMC4xLCBib3R0b206IGRvbWFpbkxlbmd0aCAqIDAuMX07XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjZW50ZXIpKSB7XHJcblx0XHRcdGNvbnN0IHlEb21haW5BYnMgPSBNYXRoLm1heChNYXRoLmFicyh5RG9tYWluTWluKSwgTWF0aC5hYnMoeURvbWFpbk1heCkpO1xyXG5cclxuXHRcdFx0eURvbWFpbk1heCA9IGNlbnRlciArIHlEb21haW5BYnM7XHJcblx0XHRcdHlEb21haW5NaW4gPSBjZW50ZXIgLSB5RG9tYWluQWJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFkZCBwYWRkaW5nIGZvciBkYXRhIGxhYmVsXHJcblx0XHRpZiAoc2hvd0hvcml6b250YWxEYXRhTGFiZWwpIHtcclxuXHRcdFx0Y29uc3QgZGlmZiA9IGRpZmZEb21haW4oc2NhbGUueS5yYW5nZSgpKTtcclxuXHRcdFx0Y29uc3QgcmF0aW8gPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgXCJ3aWR0aFwiKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2IC8gZGlmZik7XHJcblxyXG5cdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdHBhZGRpbmdbdl0gKz0gZG9tYWluTGVuZ3RoICogKHJhdGlvW2ldIC8gKDEgLSByYXRpb1swXSAtIHJhdGlvWzFdKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChzaG93VmVydGljYWxEYXRhTGFiZWwpIHtcclxuXHRcdFx0Y29uc3QgbGVuZ3RocyA9ICQkLmdldERhdGFMYWJlbExlbmd0aCh5RG9tYWluTWluLCB5RG9tYWluTWF4LCBcImhlaWdodFwiKTtcclxuXHJcblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0cGFkZGluZ1t2XSArPSAkJC5heGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKGxlbmd0aHNbaV0sIGRvbWFpbkxlbmd0aCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgvXnkyPyQvLnRlc3QoYXhpc0lkKSkge1xyXG5cdFx0XHRjb25zdCBwID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9wYWRkaW5nYF07XHJcblxyXG5cdFx0XHRpZiAobm90RW1wdHkocCkpIHtcclxuXHRcdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdHBhZGRpbmdbdl0gPSAkJC5heGlzLmdldFBhZGRpbmcocCwgdiwgcGFkZGluZ1t2XSwgZG9tYWluTGVuZ3RoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxyXG5cdFx0aWYgKGlzWmVyb0Jhc2VkKSB7XHJcblx0XHRcdGlzQWxsUG9zaXRpdmUgJiYgKHBhZGRpbmcuYm90dG9tID0geURvbWFpbk1pbik7XHJcblx0XHRcdGlzQWxsTmVnYXRpdmUgJiYgKHBhZGRpbmcudG9wID0gLXlEb21haW5NYXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRvbWFpbiA9IFt5RG9tYWluTWluIC0gcGFkZGluZy5ib3R0b20sIHlEb21haW5NYXggKyBwYWRkaW5nLnRvcF07XHJcblxyXG5cdFx0cmV0dXJuIGlzSW52ZXJ0ZWQgPyBkb21haW4ucmV2ZXJzZSgpIDogZG9tYWluO1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgdHlwZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdmFsdWUgPSAkJC5jb25maWdbYGF4aXNfeF8ke3R5cGV9YF07XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgP1xyXG5cdFx0XHQoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUodmFsdWUpIDogdmFsdWUpIDpcclxuXHRcdFx0Z2V0TWluTWF4KHR5cGUsIHRhcmdldHMubWFwKHQgPT4gZ2V0TWluTWF4KHR5cGUsIHQudmFsdWVzLm1hcCh2ID0+IHYueCkpKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbk1pbih0YXJnZXRzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW5NYXgodGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1heFwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluUGFkZGluZyhkb21haW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkaWZmID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xyXG5cdFx0Y29uc3QgeFBhZGRpbmcgPSBjb25maWcuYXhpc194X3BhZGRpbmc7XHJcblx0XHRsZXQgbWF4RGF0YUNvdW50O1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRwYWRkaW5nID0gMDtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xyXG5cdFx0XHRtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdFx0cGFkZGluZyA9IG1heERhdGFDb3VudCA+IDEgPyAoZGlmZiAvIChtYXhEYXRhQ291bnQgLSAxKSkgLyAyIDogMC41O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFkZGluZyA9IGRpZmYgKiAwLjAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBsZWZ0ID0gcGFkZGluZztcclxuXHRcdGxldCByaWdodCA9IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KHhQYWRkaW5nKSAmJiBub3RFbXB0eSh4UGFkZGluZykpIHtcclxuXHRcdFx0bGVmdCA9IGlzVmFsdWUoeFBhZGRpbmcubGVmdCkgPyB4UGFkZGluZy5sZWZ0IDogcGFkZGluZztcclxuXHRcdFx0cmlnaHQgPSBpc1ZhbHVlKHhQYWRkaW5nLnJpZ2h0KSA/IHhQYWRkaW5nLnJpZ2h0IDogcGFkZGluZztcclxuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoY29uZmlnLmF4aXNfeF9wYWRkaW5nKSkge1xyXG5cdFx0XHRsZWZ0ID0geFBhZGRpbmc7XHJcblx0XHRcdHJpZ2h0ID0geFBhZGRpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtsZWZ0LCByaWdodH07XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbih0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB4RG9tYWluID0gWyQkLmdldFhEb21haW5NaW4odGFyZ2V0cyksICQkLmdldFhEb21haW5NYXgodGFyZ2V0cyldO1xyXG5cdFx0bGV0IFtmaXJzdFgsIGxhc3RYXSA9IHhEb21haW47XHJcblx0XHRjb25zdCBwYWRkaW5nID0gJCQuZ2V0WERvbWFpblBhZGRpbmcoeERvbWFpbik7XHJcblx0XHRsZXQgbWluOiBEYXRlIHwgbnVtYmVyID0gMDtcclxuXHRcdGxldCBtYXg6IERhdGUgfCBudW1iZXIgPSAwO1xyXG5cclxuXHRcdC8vIHNob3cgY2VudGVyIG9mIHggZG9tYWluIGlmIG1pbiBhbmQgbWF4IGFyZSB0aGUgc2FtZVxyXG5cdFx0aWYgKChmaXJzdFggLSBsYXN0WCkgPT09IDAgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0XHRmaXJzdFggPSBuZXcgRGF0ZShmaXJzdFguZ2V0VGltZSgpICogMC41KTtcclxuXHRcdFx0XHRsYXN0WCA9IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSAqIDEuNSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zmlyc3RYID0gZmlyc3RYID09PSAwID8gMSA6IChmaXJzdFggKiAwLjUpO1xyXG5cdFx0XHRcdGxhc3RYID0gbGFzdFggPT09IDAgPyAtMSA6IChsYXN0WCAqIDEuNSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZmlyc3RYIHx8IGZpcnN0WCA9PT0gMCkge1xyXG5cdFx0XHRtaW4gPSAkJC5pc1RpbWVTZXJpZXMoKSA/IG5ldyBEYXRlKGZpcnN0WC5nZXRUaW1lKCkgLSBwYWRkaW5nLmxlZnQpIDogZmlyc3RYIC0gcGFkZGluZy5sZWZ0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChsYXN0WCB8fCBsYXN0WCA9PT0gMCkge1xyXG5cdFx0XHRtYXggPSAkJC5pc1RpbWVTZXJpZXMoKSA/IG5ldyBEYXRlKGxhc3RYLmdldFRpbWUoKSArIHBhZGRpbmcucmlnaHQpIDogbGFzdFggKyBwYWRkaW5nLnJpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBbbWluLCBtYXhdO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVhEb21haW4odGFyZ2V0cywgd2l0aFVwZGF0ZVhEb21haW4sIHdpdGhVcGRhdGVPcmdYRG9tYWluLCB3aXRoVHJpbSwgZG9tYWluKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBvcmcsIHNjYWxlOiB7eCwgc3ViWH19ID0gJCQ7XHJcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XHJcblxyXG5cdFx0aWYgKHdpdGhVcGRhdGVPcmdYRG9tYWluKSB7XHJcblx0XHRcdHguZG9tYWluKGRvbWFpbiB8fCBzb3J0VmFsdWUoJCQuZ2V0WERvbWFpbih0YXJnZXRzKSkpO1xyXG5cdFx0XHRvcmcueERvbWFpbiA9IHguZG9tYWluKCk7XHJcblxyXG5cdFx0XHR6b29tRW5hYmxlZCAmJiAkJC56b29tLnVwZGF0ZVNjYWxlRXh0ZW50KCk7XHJcblxyXG5cdFx0XHRzdWJYLmRvbWFpbih4LmRvbWFpbigpKTtcclxuXHRcdFx0JCQuYnJ1c2ggJiYgJCQuYnJ1c2guc2NhbGUoc3ViWCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdpdGhVcGRhdGVYRG9tYWluKSB7XHJcblx0XHRcdGNvbnN0IGRvbWFpblZhbHVlID0gZG9tYWluIHx8ICghJCQuYnJ1c2ggfHwgYnJ1c2hFbXB0eSgkJCkpID9cclxuXHRcdFx0XHRvcmcueERvbWFpbiA6IGdldEJydXNoU2VsZWN0aW9uKCQkKS5tYXAoc3ViWC5pbnZlcnQpO1xyXG5cclxuXHRcdFx0eC5kb21haW4oZG9tYWluVmFsdWUpO1xyXG5cdFx0XHR6b29tRW5hYmxlZCAmJiAkJC56b29tLnVwZGF0ZVNjYWxlRXh0ZW50KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVHJpbSBkb21haW4gd2hlbiB0b28gYmlnIGJ5IHpvb20gbW91c2Vtb3ZlIGV2ZW50XHJcblx0XHR3aXRoVHJpbSAmJiB4LmRvbWFpbigkJC50cmltWERvbWFpbih4Lm9yZ0RvbWFpbigpKSk7XHJcblxyXG5cdFx0cmV0dXJuIHguZG9tYWluKCk7XHJcblx0fSxcclxuXHJcblx0dHJpbVhEb21haW4oZG9tYWluKSB7XHJcblx0XHRjb25zdCB6b29tRG9tYWluID0gdGhpcy5nZXRab29tRG9tYWluKCk7XHJcblx0XHRjb25zdCBbbWluLCBtYXhdID0gem9vbURvbWFpbjtcclxuXHJcblx0XHRpZiAoZG9tYWluWzBdIDw9IG1pbikge1xyXG5cdFx0XHRkb21haW5bMV0gPSArZG9tYWluWzFdICsgKG1pbiAtIGRvbWFpblswXSk7XHJcblx0XHRcdGRvbWFpblswXSA9IG1pbjtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobWF4IDw9IGRvbWFpblsxXSkge1xyXG5cdFx0XHRkb21haW5bMF0gPSArZG9tYWluWzBdIC0gKGRvbWFpblsxXSAtIG1heCk7XHJcblx0XHRcdGRvbWFpblsxXSA9IG1heDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZG9tYWluO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1ZhbHVlLCBpc0Z1bmN0aW9uLCBpc09iamVjdFR5cGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZnVuY3Rpb24gZ2V0Rm9ybWF0KCQkLCB0eXBlVmFsdWUsIHYpIHtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdGNvbnN0IHR5cGUgPSBgYXhpc18ke3R5cGVWYWx1ZX1fdGlja19mb3JtYXRgO1xyXG5cdGNvbnN0IGZvcm1hdCA9IGNvbmZpZ1t0eXBlXSA/XHJcblx0XHRjb25maWdbdHlwZV0gOiAkJC5kZWZhdWx0VmFsdWVGb3JtYXQ7XHJcblxyXG5cdHJldHVybiBmb3JtYXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRZRm9ybWF0KGZvckFyYykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHt5Rm9ybWF0LCB5MkZvcm1hdH0gPSAkJDtcclxuXHJcblx0XHRpZiAoZm9yQXJjICYmICEkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcclxuXHRcdFx0eUZvcm1hdCA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdDtcclxuXHRcdFx0eTJGb3JtYXQgPSAkJC5kZWZhdWx0QXJjVmFsdWVGb3JtYXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHYsIHJhdGlvLCBpZCkge1xyXG5cdFx0XHRjb25zdCBmb3JtYXQgPSAkJC5heGlzICYmICQkLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgP1xyXG5cdFx0XHRcdHkyRm9ybWF0IDogeUZvcm1hdDtcclxuXHJcblx0XHRcdHJldHVybiBmb3JtYXQuY2FsbCgkJCwgdiwgcmF0aW8pO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHR5Rm9ybWF0KHYpIHtcclxuXHRcdHJldHVybiBnZXRGb3JtYXQodGhpcywgXCJ5XCIsIHYpO1xyXG5cdH0sXHJcblxyXG5cdHkyRm9ybWF0KHYpIHtcclxuXHRcdHJldHVybiBnZXRGb3JtYXQodGhpcywgXCJ5MlwiLCB2KTtcclxuXHR9LFxyXG5cclxuXHRkZWZhdWx0VmFsdWVGb3JtYXQodikge1xyXG5cdFx0cmV0dXJuIGlzVmFsdWUodikgPyArdiA6IFwiXCI7XHJcblx0fSxcclxuXHJcblx0ZGVmYXVsdEFyY1ZhbHVlRm9ybWF0KHYsIHJhdGlvKSB7XHJcblx0XHRyZXR1cm4gYCR7KHJhdGlvICogMTAwKS50b0ZpeGVkKDEpfSVgO1xyXG5cdH0sXHJcblxyXG5cdGRhdGFMYWJlbEZvcm1hdCh0YXJnZXRJZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgZGF0YUxhYmVscyA9ICQkLmNvbmZpZy5kYXRhX2xhYmVscztcclxuXHRcdGNvbnN0IGRlZmF1bHRGb3JtYXQgPSB2ID0+IChpc1ZhbHVlKHYpID8gK3YgOiBcIlwiKTtcclxuXHRcdGxldCBmb3JtYXQgPSBkZWZhdWx0Rm9ybWF0O1xyXG5cclxuXHRcdC8vIGZpbmQgZm9ybWF0IGFjY29yZGluZyB0byBheGlzIGlkXHJcblx0XHRpZiAoaXNGdW5jdGlvbihkYXRhTGFiZWxzLmZvcm1hdCkpIHtcclxuXHRcdFx0Zm9ybWF0ID0gZGF0YUxhYmVscy5mb3JtYXQ7XHJcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzLmZvcm1hdCkpIHtcclxuXHRcdFx0aWYgKGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXSkge1xyXG5cdFx0XHRcdGZvcm1hdCA9IGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXSA9PT0gdHJ1ZSA/XHJcblx0XHRcdFx0XHRkZWZhdWx0Rm9ybWF0IDogZGF0YUxhYmVscy5mb3JtYXRbdGFyZ2V0SWRdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZvcm1hdCA9ICgpID0+IFwiXCI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZm9ybWF0O1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50LFxyXG5cdG5hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbiwgaXNEZWZpbmVkLCBnZXRPcHRpb24sIGlzRW1wdHksIGlzRnVuY3Rpb24sIG5vdEVtcHR5LCB0cGxQcm9jZXNzfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBsZWdlbmQuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0TGVnZW5kKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLnN0YXRlLmxlZ2VuZEhhc1JlbmRlcmVkID0gZmFsc2U7XHJcblx0XHQkZWwubGVnZW5kID0gJCQuJGVsLnN2Zy5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0JGVsLmxlZ2VuZC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImxlZ2VuZFwiKSk7XHJcblxyXG5cdFx0XHQvLyBNRU1POiBjYWxsIGhlcmUgdG8gdXBkYXRlIGxlZ2VuZCBib3ggYW5kIHRyYW5zbGF0ZSBmb3IgYWxsXHJcblx0XHRcdC8vIE1FTU86IHRyYW5zbGF0ZSB3aWxsIGJlIHVwZGF0ZWQgYnkgdGhpcywgc28gdHJhbnNmb3JtIG5vdCBuZWVkZWQgaW4gdXBkYXRlTGVnZW5kKClcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC4kZWwubGVnZW5kLnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHRcdFx0JCQuc3RhdGUuaGlkZGVuTGVnZW5kSWRzID0gJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB0YXJnZXRJZHMgSUQncyBvZiB0YXJnZXRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoVHJhbnNmb3JtIDogV2hldGhlciB0byB1c2UgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBXaGV0aGVyIHRyYW5zaXRpb24gaXMgdXNlZCB3aGVuIHVzaW5nIHRoZSB0cmFuc2Zvcm0gcHJvcGVydHkgLyB3aXRoVHJhbnNpdGlvbiA6IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRyYW5zaXRpb25zIFJldHVybiB2YWx1ZSBvZiB0aGUgZ2VuZXJhdGVUcmFuc2l0aW9uc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kKHRhcmdldElkcywgb3B0aW9ucywgdHJhbnNpdGlvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCBzY2FsZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qgb3B0aW9ueiA9IG9wdGlvbnMgfHwge1xyXG5cdFx0XHR3aXRoVHJhbnNmb3JtOiBmYWxzZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IGZhbHNlLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2VcclxuXHRcdH07XHJcblxyXG5cdFx0b3B0aW9uei53aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb256LCBcIndpdGhUcmFuc2l0aW9uXCIsIHRydWUpO1xyXG5cdFx0b3B0aW9uei53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSA9IGdldE9wdGlvbihvcHRpb256LCBcIndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtXCIsIHRydWUpO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX2NvbnRlbnRzX2JpbmR0byAmJiBjb25maWcubGVnZW5kX2NvbnRlbnRzX3RlbXBsYXRlKSB7XHJcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZFRlbXBsYXRlKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRFbGVtZW50KFxyXG5cdFx0XHRcdHRhcmdldElkcyB8fCAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLFxyXG5cdFx0XHRcdG9wdGlvbnosXHJcblx0XHRcdFx0dHJhbnNpdGlvbnNcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB0b2dnbGUgbGVnZW5kIHN0YXRlXHJcblx0XHQkZWwubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbX1gKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuLCBpZCA9PiAhJCQuaXNUYXJnZXRUb1Nob3coaWQpKTtcclxuXHJcblx0XHQvLyBVcGRhdGUgc2l6ZSBhbmQgc2NhbGVcclxuXHRcdCQkLnVwZGF0ZVNjYWxlcyhmYWxzZSwgIXNjYWxlLnpvb20pO1xyXG5cdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBnIHBvc2l0aW9uc1xyXG5cdFx0JCQudHJhbnNmb3JtQWxsKG9wdGlvbnoud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0sIHRyYW5zaXRpb25zKTtcclxuXHJcblx0XHRzdGF0ZS5sZWdlbmRIYXNSZW5kZXJlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGxlZ2VuZCB1c2luZyB0ZW1wbGF0ZSBvcHRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZFRlbXBsYXRlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3Qgd3JhcHBlciA9IGQzU2VsZWN0KGNvbmZpZy5sZWdlbmRfY29udGVudHNfYmluZHRvKTtcclxuXHRcdGNvbnN0IHRlbXBsYXRlID0gY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZTtcclxuXHJcblx0XHRpZiAoIXdyYXBwZXIuZW1wdHkoKSkge1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzID0gJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3QgaWRzOiBhbnlbXSA9IFtdO1xyXG5cdFx0XHRsZXQgaHRtbCA9IFwiXCI7XHJcblxyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGlzRnVuY3Rpb24odGVtcGxhdGUpID9cclxuXHRcdFx0XHRcdHRlbXBsYXRlLmNhbGwoJCQsIHYsICQkLmNvbG9yKHYpLCAkJC5hcGkuZGF0YSh2KVswXS52YWx1ZXMpIDpcclxuXHRcdFx0XHRcdHRwbFByb2Nlc3ModGVtcGxhdGUsIHtcclxuXHRcdFx0XHRcdFx0Q09MT1I6ICQkLmNvbG9yKHYpLFxyXG5cdFx0XHRcdFx0XHRUSVRMRTogdlxyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZW50KSB7XHJcblx0XHRcdFx0XHRpZHMucHVzaCh2KTtcclxuXHRcdFx0XHRcdGh0bWwgKz0gY29udGVudDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3QgbGVnZW5kSXRlbSA9IHdyYXBwZXIuaHRtbChodG1sKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNoaWxkTm9kZXM7IH0pXHJcblx0XHRcdFx0LmRhdGEoaWRzKTtcclxuXHJcblx0XHRcdCQkLnNldExlZ2VuZEl0ZW0obGVnZW5kSXRlbSk7XHJcblxyXG5cdFx0XHQkZWwubGVnZW5kID0gd3JhcHBlcjtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIHNpemUgb2YgdGhlIGxlZ2VuZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JlamN0fSBzaXplIFNcclxuXHQgKi9cclxuXHR1cGRhdGVTaXplRm9yTGVnZW5kKHNpemUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7XHJcblx0XHRcdGlzTGVnZW5kVG9wLCBpc0xlZ2VuZExlZnQsIGlzTGVnZW5kUmlnaHQsIGlzTGVnZW5kSW5zZXQsIGN1cnJlbnRXaWR0aCwgY3VycmVudEhlaWdodFxyXG5cdFx0fX0gPSAkJDtcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XHJcblxyXG5cdFx0Y29uc3QgaW5zZXRMZWdlbmRQb3NpdGlvbiA9IHtcclxuXHRcdFx0dG9wOiBpc0xlZ2VuZFRvcCA/XHJcblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeSArIDUuNSA6XHJcblx0XHRcdFx0Y3VycmVudEhlaWdodCAtIGhlaWdodCAtICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkgLSBjb25maWcubGVnZW5kX2luc2V0X3ksXHJcblx0XHRcdGxlZnQ6IGlzTGVnZW5kTGVmdCA/XHJcblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkgKyBjb25maWcubGVnZW5kX2luc2V0X3ggKyAwLjUgOlxyXG5cdFx0XHRcdGN1cnJlbnRXaWR0aCAtIHdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF94ICsgMC41XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLnN0YXRlLm1hcmdpbjMgPSB7XHJcblx0XHRcdHRvcDogaXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0MCA6IGlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLnRvcCA6IGN1cnJlbnRIZWlnaHQgLSBoZWlnaHQsXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0bGVmdDogaXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0Y3VycmVudFdpZHRoIC0gd2lkdGggOiBpc0xlZ2VuZEluc2V0ID8gaW5zZXRMZWdlbmRQb3NpdGlvbi5sZWZ0IDogMFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm0gTGVnZW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXHJcblx0ICovXHJcblx0dHJhbnNmb3JtTGVnZW5kKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bGVnZW5kfSA9ICQkLiRlbDtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyBsZWdlbmQudHJhbnNpdGlvbigpIDogbGVnZW5kKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJsZWdlbmRcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgbGVnZW5kIHN0ZXBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kU3RlcChzdGVwKSB7XHJcblx0XHR0aGlzLnN0YXRlLmxlZ2VuZFN0ZXAgPSBzdGVwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSB3aWR0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kSXRlbVdpZHRoKHcpIHtcclxuXHRcdHRoaXMuc3RhdGUubGVnZW5kSXRlbVdpZHRoID0gdztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gaGVpZ2h0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kSXRlbUhlaWdodChoKSB7XHJcblx0XHR0aGlzLnN0YXRlLmxlZ2VuZEl0ZW1IZWlnaHQgPSBoO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSBjb2xvclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIENvcnJlc3BvbmRpbmcgZGF0YSBJRCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcihpZCwgY29sb3IpIHtcclxuXHRcdHRoaXMuJGVsLmxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19LSR7aWR9IGxpbmVgKVxyXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgY29sb3IpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSB3aWR0aFxyXG5cdCAqL1xyXG5cdGdldExlZ2VuZFdpZHRoKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2N1cnJlbnRXaWR0aCwgaXNMZWdlbmRSaWdodCwgaXNMZWdlbmRJbnNldCwgbGVnZW5kSXRlbVdpZHRoLCBsZWdlbmRTdGVwfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcubGVnZW5kX3Nob3cgPyAoXHJcblx0XHRcdGlzTGVnZW5kUmlnaHQgfHwgaXNMZWdlbmRJbnNldCA/XHJcblx0XHRcdFx0bGVnZW5kSXRlbVdpZHRoICogKGxlZ2VuZFN0ZXAgKyAxKSA6IGN1cnJlbnRXaWR0aFxyXG5cdFx0KSA6IDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRMZWdlbmRIZWlnaHQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y3VycmVudEhlaWdodCwgaXNMZWdlbmRSaWdodCwgbGVnZW5kSXRlbUhlaWdodCwgbGVnZW5kU3RlcH0gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gJCQuY29uZmlnLmxlZ2VuZF9zaG93ID8gKFxyXG5cdFx0XHRpc0xlZ2VuZFJpZ2h0ID9cclxuXHRcdFx0XHRjdXJyZW50SGVpZ2h0IDogTWF0aC5tYXgoMjAsIGxlZ2VuZEl0ZW1IZWlnaHQpICogKGxlZ2VuZFN0ZXAgKyAxKVxyXG5cdFx0KSA6IDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5TZWxlY3RcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBvcGFjaXR5XHJcblx0ICovXHJcblx0b3BhY2l0eUZvckxlZ2VuZChsZWdlbmRJdGVtKSB7XHJcblx0XHRyZXR1cm4gbGVnZW5kSXRlbS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4pID8gbnVsbCA6IFwiMVwiO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGVnZW5kIHRoYXQgaXMgdW5mb2N1c2VkXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGVnZW5kSXRlbSwgZDMuU2VsZWN0XHJcblx0ICogQHJldHVybnMge051bWJlcn0gb3BhY2l0eVxyXG5cdCAqL1xyXG5cdG9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQobGVnZW5kSXRlbSkge1xyXG5cdFx0cmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjAuM1wiO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIGZvY3VzIG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IElEJ3Mgb2YgdGFyZ2V0XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byBmb2N1cy5cclxuXHQgKi9cclxuXHR0b2dnbGVGb2N1c0xlZ2VuZCh0YXJnZXRJZHMsIGZvY3VzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0YXJnZXRJZHogPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdCQkLiRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdC5maWx0ZXIoaWQgPT4gdGFyZ2V0SWR6LmluZGV4T2YoaWQpID49IDApXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmb2N1cylcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAoZm9jdXMgPyAkJC5vcGFjaXR5Rm9yTGVnZW5kIDogJCQub3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZClcclxuXHRcdFx0XHRcdC5jYWxsKCQkLCBkM1NlbGVjdCh0aGlzKSk7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldmVydCB0aGUgbGVnZW5kIHRvIGl0cyBkZWZhdWx0IHN0YXRlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZXZlcnRMZWdlbmQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZhbHNlKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoZDNTZWxlY3QodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93cyB0aGUgbGVnZW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxyXG5cdCAqL1xyXG5cdHNob3dMZWdlbmQodGFyZ2V0SWRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmxlZ2VuZF9zaG93KSB7XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IHRydWU7XHJcblx0XHRcdGxlZ2VuZC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG5cclxuXHRcdFx0ISQkLnN0YXRlLmxlZ2VuZEhhc1JlbmRlcmVkICYmICQkLnVwZGF0ZUxlZ2VuZCgpO1xyXG5cdFx0fVxyXG5cdFx0JCQucmVtb3ZlSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0bGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSlcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIilcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAkJC5vcGFjaXR5Rm9yTGVnZW5kKGQzU2VsZWN0KHRoaXMpKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSB0aGUgbGVnZW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxyXG5cdCAqL1xyXG5cdGhpZGVMZWdlbmQodGFyZ2V0SWRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgaXNFbXB0eSh0YXJnZXRJZHMpKSB7XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xyXG5cdFx0XHRsZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xyXG5cdFx0bGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgbGVnZW5kIGl0ZW0gdGV4dGJveCBkaW1lbnNpb25cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWRcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gdGV4dEVsZW1lbnRcclxuXHQgKi9cclxuXHRnZXRMZWdlbmRJdGVtVGV4dEJveChpZD86IHN0cmluZywgdGV4dEVsZW1lbnQ/KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y2FjaGV9ID0gJCQ7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJGxlZ2VuZEl0ZW1UZXh0Qm94XCI7XHJcblxyXG5cdFx0aWYgKGlkKSB7XHJcblx0XHRcdGxldCBkYXRhID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRcdGlmICghZGF0YSkge1xyXG5cdFx0XHRcdGRhdGEgPSB7fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCFkYXRhW2lkXSkge1xyXG5cdFx0XHRcdGRhdGFbaWRdID0gJCQuZ2V0VGV4dFJlY3QodGV4dEVsZW1lbnQsIENMQVNTLmxlZ2VuZEl0ZW0pO1xyXG5cdFx0XHRcdGNhY2hlLmFkZChjYWNoZUtleSwgZGF0YSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBkYXRhW2lkXTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNhY2hlLnJlbW92ZShjYWNoZUtleSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxlZ2VuZCBpdGVtIHN0eWxlICYgYmluZCBldmVudHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBpdGVtXHJcblx0ICovXHJcblx0c2V0TGVnZW5kSXRlbShpdGVtKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cclxuXHRcdGl0ZW1cclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihpZCkge1xyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpdGVtQ2xhc3MgPSAoIW5vZGUuZW1wdHkoKSAmJiBub2RlLmF0dHIoXCJjbGFzc1wiKSkgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGl0ZW1DbGFzcyArICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGVnZW5kSXRlbSwgaWQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGlkID0+ICgkJC5pc0xlZ2VuZFRvU2hvdyhpZCkgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGlkID0+IHtcclxuXHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25jbGljaywgJCQsIGlkKSkge1xyXG5cdFx0XHRcdFx0aWYgKGQzRXZlbnQuYWx0S2V5KSB7XHJcblx0XHRcdFx0XHRcdCQkLmFwaS5oaWRlKCk7XHJcblx0XHRcdFx0XHRcdCQkLmFwaS5zaG93KGlkKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdCQkLmFwaS50b2dnbGUoaWQpO1xyXG5cdFx0XHRcdFx0XHQhaXNUb3VjaCAmJiAkJC5pc1RhcmdldFRvU2hvdyhpZCkgPyAkJC5hcGkuZm9jdXMoaWQpIDogJCQuYXBpLnJldmVydCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aXNUb3VjaCAmJiAkJC5oaWRlVG9vbHRpcCgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWlzVG91Y2gpIHtcclxuXHRcdFx0aXRlbVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGlkKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25vdXQsICQkLCBpZCkpIHtcclxuXHRcdFx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0JCQudW5kb01hcmtPdmVybGFwcGVkKCQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0JCQuYXBpLnJldmVydCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGlkKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25vdmVyLCAkJCwgaWQpKSB7XHJcblx0XHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0JCQubWFya092ZXJsYXBwZWQoaWQsICQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCFzdGF0ZS50cmFuc2l0aW5nICYmICQkLmlzVGFyZ2V0VG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdFx0XHRcdCQkLmFwaS5mb2N1cyhpZCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cclxuIFx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRFbGVtZW50KHRhcmdldElkcywgb3B0aW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nVG9wID0gNDtcclxuXHRcdGNvbnN0IHBhZGRpbmdSaWdodCA9IDEwO1xyXG5cdFx0Y29uc3QgcG9zTWluID0gMTA7XHJcblx0XHRjb25zdCB0aWxlV2lkdGggPSBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aCArIDU7XHJcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xyXG5cdFx0bGV0IG1heEhlaWdodCA9IDA7XHJcblx0XHRsZXQgeEZvckxlZ2VuZDtcclxuXHRcdGxldCB5Rm9yTGVnZW5kO1xyXG5cdFx0bGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuXHRcdGNvbnN0IG9mZnNldHMgPSB7fTtcclxuXHRcdGNvbnN0IHdpZHRocyA9IHt9O1xyXG5cdFx0Y29uc3QgaGVpZ2h0cyA9IHt9O1xyXG5cdFx0Y29uc3QgbWFyZ2lucyA9IFswXTtcclxuXHRcdGNvbnN0IHN0ZXBzID0ge307XHJcblx0XHRsZXQgc3RlcCA9IDA7XHJcblx0XHRsZXQgYmFja2dyb3VuZDtcclxuXHRcdGNvbnN0IGlzTGVnZW5kUmlnaHRPckluc2V0ID0gc3RhdGUuaXNMZWdlbmRSaWdodCB8fCBzdGF0ZS5pc0xlZ2VuZEluc2V0O1xyXG5cclxuXHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXHJcblx0XHRjb25zdCB0YXJnZXRJZHogPSB0YXJnZXRJZHNcclxuXHRcdFx0LmZpbHRlcihpZCA9PiAhaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgfHwgY29uZmlnLmRhdGFfbmFtZXNbaWRdICE9PSBudWxsKTtcclxuXHJcblx0XHRjb25zdCB3aXRoVHJhbnNpdGlvbiA9IG9wdGlvbnMud2l0aFRyYW5zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24odGV4dEVsZW1lbnQsIGlkLCBpbmRleCkge1xyXG5cdFx0XHRjb25zdCByZXNldCA9IGluZGV4ID09PSAwO1xyXG5cdFx0XHRjb25zdCBpc0xhc3QgPSBpbmRleCA9PT0gdGFyZ2V0SWR6Lmxlbmd0aCAtIDE7XHJcblx0XHRcdGNvbnN0IGJveCA9ICQkLmdldExlZ2VuZEl0ZW1UZXh0Qm94KGlkLCB0ZXh0RWxlbWVudCk7XHJcblx0XHRcdGNvbnN0IGl0ZW1XaWR0aCA9IGJveC53aWR0aCArIHRpbGVXaWR0aCArXHJcblx0XHRcdFx0KGlzTGFzdCAmJiAhaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAwIDogcGFkZGluZ1JpZ2h0KSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZztcclxuXHRcdFx0Y29uc3QgaXRlbUhlaWdodCA9IGJveC5oZWlnaHQgKyBwYWRkaW5nVG9wO1xyXG5cdFx0XHRjb25zdCBpdGVtTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBpdGVtSGVpZ2h0IDogaXRlbVdpZHRoO1xyXG5cdFx0XHRjb25zdCBhcmVhTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6ICQkLmdldExlZ2VuZFdpZHRoKCk7XHJcblx0XHRcdGxldCBtYXJnaW47XHJcblxyXG5cdFx0XHQvLyBNRU1POiBjYXJlIGFib3V0IGNvbmRpZmlvbiBvZiBzdGVwLCB0b3RhbExlbmd0aFxyXG5cdFx0XHRjb25zdCB1cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbihpZDIsIHdpdGhvdXRTdGVwPzogYm9vbGVhbikge1xyXG5cdFx0XHRcdGlmICghd2l0aG91dFN0ZXApIHtcclxuXHRcdFx0XHRcdG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gdG90YWxMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIGl0ZW1MZW5ndGgpIC8gMjtcclxuXHRcdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0XHRzdGVwKys7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGVwc1tpZDJdID0gc3RlcDtcclxuXHRcdFx0XHRtYXJnaW5zW3N0ZXBdID0gc3RhdGUuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luO1xyXG5cdFx0XHRcdG9mZnNldHNbaWQyXSA9IHRvdGFsTGVuZ3RoO1xyXG5cdFx0XHRcdHRvdGFsTGVuZ3RoICs9IGl0ZW1MZW5ndGg7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAocmVzZXQpIHtcclxuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDA7XHJcblx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0bWF4V2lkdGggPSAwO1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IDA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgISQkLmlzTGVnZW5kVG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdHdpZHRoc1tpZF0gPSAwO1xyXG5cdFx0XHRcdGhlaWdodHNbaWRdID0gMDtcclxuXHRcdFx0XHRzdGVwc1tpZF0gPSAwO1xyXG5cdFx0XHRcdG9mZnNldHNbaWRdID0gMDtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aWR0aHNbaWRdID0gaXRlbVdpZHRoO1xyXG5cdFx0XHRoZWlnaHRzW2lkXSA9IGl0ZW1IZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkge1xyXG5cdFx0XHRcdG1heFdpZHRoID0gaXRlbVdpZHRoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW1heEhlaWdodCB8fCBpdGVtSGVpZ2h0ID49IG1heEhlaWdodCkge1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IGl0ZW1IZWlnaHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1heExlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gbWF4SGVpZ2h0IDogbWF4V2lkdGg7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmxlZ2VuZF9lcXVhbGx5KSB7XHJcblx0XHRcdFx0T2JqZWN0LmtleXMod2lkdGhzKS5mb3JFYWNoKGlkMiA9PiAod2lkdGhzW2lkMl0gPSBtYXhXaWR0aCkpO1xyXG5cdFx0XHRcdE9iamVjdC5rZXlzKGhlaWdodHMpLmZvckVhY2goaWQyID0+IChoZWlnaHRzW2lkMl0gPSBtYXhIZWlnaHQpKTtcclxuXHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIG1heExlbmd0aCAqIHRhcmdldElkei5sZW5ndGgpIC8gMjtcclxuXHJcblx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0XHR0YXJnZXRJZHouZm9yRWFjaChpZDIgPT4gdXBkYXRlVmFsdWVzKGlkMikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHN0ZXAgPSBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgPyBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgOiB0YXJnZXRJZHoubGVuZ3RoO1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXTtcclxuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xyXG5cdFx0fSBlbHNlIGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXSArIDEwO1xyXG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXhIZWlnaHQgKiBzdGVwc1tpZF07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFRleHQgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpICsgNCArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFJlY3QgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpO1xyXG5cdFx0Y29uc3QgeDFGb3JMZWdlbmRUaWxlID0gKGlkLCBpPzogbnVtYmVyKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDI7XHJcblx0XHRjb25zdCB4MkZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpIC0gMiArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cclxuXHRcdGNvbnN0IHlGb3JMZWdlbmRUZXh0ID0gKGlkLCBpPzogbnVtYmVyKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDk7XHJcblx0XHRjb25zdCB5Rm9yTGVnZW5kUmVjdCA9IChpZCwgaT86IG51bWJlcikgPT4geUZvckxlZ2VuZChpZCwgaSkgLSA1O1xyXG5cdFx0Y29uc3QgeUZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHlGb3JMZWdlbmQoaWQsIGkpICsgNDtcclxuXHJcblx0XHRjb25zdCBwb3MgPSAtMjAwO1xyXG5cclxuXHRcdGNvbnN0IHtsZWdlbmR9ID0gJCQuJGVsO1xyXG5cclxuXHRcdC8vIERlZmluZSBnIGZvciBsZWdlbmQgYXJlYVxyXG5cdFx0Y29uc3QgbCA9IGxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHQkJC5zZXRMZWdlbmRJdGVtKGwpO1xyXG5cclxuXHRcdGwuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRUZXh0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGV4dCk7XHJcblxyXG5cdFx0bC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbUV2ZW50KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRSZWN0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kUmVjdCk7XHJcblxyXG5cdFx0Y29uc3QgdXNlUG9pbnQgPSBjb25maWcubGVnZW5kX3VzZVBvaW50O1xyXG5cclxuXHRcdGlmICh1c2VQb2ludCkge1xyXG5cdFx0XHRjb25zdCBpZHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0XHRsLmFwcGVuZChkID0+IHtcclxuXHRcdFx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID9cclxuXHRcdFx0XHRcdGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcclxuXHJcblx0XHRcdFx0aWRzLmluZGV4T2YoZCkgPT09IC0xICYmIGlkcy5wdXNoKGQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGQpICUgcGF0dGVybi5sZW5ndGhdO1xyXG5cclxuXHRcdFx0XHRpZiAocG9pbnQgPT09IFwicmVjdGFuZ2xlXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50ID0gXCJyZWN0XCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsICQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSA/IHBvaW50IDogXCJ1c2VcIik7XHJcblx0XHRcdH0pXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRJdGVtUG9pbnQpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiaHJlZlwiLCAoZGF0YSwgaWR4LCBzZWxlY3Rpb24pID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25baWR4XTtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSA9PT0gXCJ1c2VcIiA/IGAjJHtzdGF0ZS5kYXRldGltZUlkfS1wb2ludC0ke2RhdGF9YCA6IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGwuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbVRpbGUpXHJcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MUZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MkZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX2hlaWdodCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IGJhY2tncm91bmQgZm9yIGluc2V0IGxlZ2VuZFxyXG5cdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEJhY2tncm91bmR9IHJlY3RgKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRJbnNldCAmJiBtYXhXaWR0aCA+IDAgJiYgYmFja2dyb3VuZC5zaXplKCkgPT09IDApIHtcclxuXHRcdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRCYWNrZ3JvdW5kKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHRzID0gbGVnZW5kLnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpIC8vIE1FTU86IG5lZWRlZCBmb3IgdXBkYXRlXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXHJcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JMZWdlbmRUZXh0KTtcclxuXHJcblx0XHRjb25zdCByZWN0cyA9IGxlZ2VuZC5zZWxlY3RBbGwoYHJlY3QuJHtDTEFTUy5sZWdlbmRJdGVtRXZlbnR9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KTtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyByZWN0cy50cmFuc2l0aW9uKCkgOiByZWN0cylcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBpZCA9PiB3aWR0aHNbaWRdKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBpZCA9PiBoZWlnaHRzW2lkXSlcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIHhGb3JMZWdlbmRSZWN0KVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeUZvckxlZ2VuZFJlY3QpO1xyXG5cclxuXHJcblx0XHRpZiAodXNlUG9pbnQpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBsZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtUG9pbnR9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xyXG5cclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0XHRcdFx0bGV0IHggPSBcInhcIjtcclxuXHRcdFx0XHRcdGxldCB5ID0gXCJ5XCI7XHJcblx0XHRcdFx0XHRsZXQgeE9mZnNldCA9IDI7XHJcblx0XHRcdFx0XHRsZXQgeU9mZnNldCA9IDIuNTtcclxuXHRcdFx0XHRcdGxldCByYWRpdXM7XHJcblx0XHRcdFx0XHRsZXQgd2lkdGg7XHJcblx0XHRcdFx0XHRsZXQgaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdGlmIChub2RlTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaXplID0gcG9pbnRSICogMC4yO1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IFwiY3hcIjtcclxuXHRcdFx0XHRcdFx0eSA9IFwiY3lcIjtcclxuXHRcdFx0XHRcdFx0cmFkaXVzID0gcG9pbnRSICsgc2l6ZTtcclxuXHRcdFx0XHRcdFx0eE9mZnNldCA9IHBvaW50UiAqIDI7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAtc2l6ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFwicmVjdFwiKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSBwb2ludFIgKiAyLjU7XHJcblxyXG5cdFx0XHRcdFx0XHR3aWR0aCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdGhlaWdodCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAzO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKHgsIGQgPT4geDFGb3JMZWdlbmRUaWxlKGQpICsgeE9mZnNldClcclxuXHRcdFx0XHRcdFx0LmF0dHIoeSwgZCA9PiB5Rm9yTGVnZW5kVGlsZShkKSAtIHlPZmZzZXQpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiclwiLCByYWRpdXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCB0aWxlcyA9IGxlZ2VuZC5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy5sZWdlbmRJdGVtVGlsZX1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldElkeik7XHJcblxyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aWxlcy50cmFuc2l0aW9uKCkgOiB0aWxlcylcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQubGV2ZWxDb2xvciA/IGlkID0+ICQkLmxldmVsQ29sb3IoJCQuY2FjaGUuZ2V0KGlkKS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4MUZvckxlZ2VuZFRpbGUpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5Rm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIHgyRm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcInkyXCIsIHlGb3JMZWdlbmRUaWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYmFja2dyb3VuZCkge1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgLSAxMilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIG1heFdpZHRoICogKHN0ZXAgKyAxKSArIDEwKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVcGRhdGUgYWxsIHRvIHJlZmxlY3QgY2hhbmdlIG9mIGxlZ2VuZFxyXG5cdFx0JCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobWF4SGVpZ2h0KTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2NhbGVUaW1lIGFzIGQzU2NhbGVUaW1lLFxyXG5cdHNjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJcclxufSBmcm9tIFwiZDMtc2NhbGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZXRTY2FsZShtaW4sIG1heCwgZm9yVGltZXNlcmllcykge1xyXG5cdFx0cmV0dXJuIChmb3JUaW1lc2VyaWVzID9cclxuXHRcdFx0ZDNTY2FsZVRpbWUoKSA6IGQzU2NhbGVMaW5lYXIoKVxyXG5cdFx0KS5yYW5nZShbbWluLCBtYXhdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgeCBBeGlzIHNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pblxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9tYWluXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb2Zmc2V0IFRoZSBvZmZzZXQgZ2V0dGVyIHRvIGJlIHN1bVxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBzY2FsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WChtaW4sIG1heCwgZG9tYWluLCBvZmZzZXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGUuem9vbSB8fCAkJC5nZXRTY2FsZShtaW4sIG1heCwgJCQuaXNUaW1lU2VyaWVzKCkpO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRDdXN0b21pemVkU2NhbGUoXHJcblx0XHRcdGRvbWFpbiA/IHNjYWxlLmRvbWFpbihkb21haW4pIDogc2NhbGUsXHJcblx0XHRcdG9mZnNldFxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgeSBBeGlzIHNjYWxlIGZ1bmN0aW9uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1pblxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXhcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZG9tYWluXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259IHNjYWxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRZKG1pbiwgbWF4LCBkb21haW4pIHtcclxuXHRcdGNvbnN0IHNjYWxlID0gdGhpcy5nZXRTY2FsZShtaW4sIG1heCwgdGhpcy5pc1RpbWVTZXJpZXNZKCkpO1xyXG5cclxuXHRcdGRvbWFpbiAmJiBzY2FsZS5kb21haW4oZG9tYWluKTtcclxuXHJcblx0XHRyZXR1cm4gc2NhbGU7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGN1c3RvbWl6ZWQgc2NhbGVcclxuXHQgKiBAcGFyYW0ge2QzLnNjYWxlTGluZWFyfGQzLnNjYWxlVGltZX0gc2NhbGVWYWx1ZVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldFZhbHVlIE9mZnNldCBnZXR0ZXIgdG8gYmUgc3VtXHJcblx0ICogQHJldHVybiB7fSBzY2FsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q3VzdG9taXplZFNjYWxlKHNjYWxlVmFsdWUsIG9mZnNldFZhbHVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBvZmZzZXQgPSBvZmZzZXRWYWx1ZSB8fCAoKCkgPT4gJCQuYXhpcy54LnRpY2tPZmZzZXQoKSk7XHJcblx0XHRjb25zdCBzY2FsZSA9IGZ1bmN0aW9uKGQsIHJhdykge1xyXG5cdFx0XHRjb25zdCB2ID0gc2NhbGVWYWx1ZShkKSArIG9mZnNldCgpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHJhdyA/IHYgOiBNYXRoLmNlaWwodik7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGNvcHkgb3JpZ2luYWwgc2NhbGUgbWV0aG9kc1xyXG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gc2NhbGVWYWx1ZSkge1xyXG5cdFx0XHRzY2FsZVtrZXldID0gc2NhbGVWYWx1ZVtrZXldO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNjYWxlLm9yZ0RvbWFpbiA9ICgpID0+IHNjYWxlVmFsdWUuZG9tYWluKCk7XHJcblx0XHRzY2FsZS5vcmdTY2FsZSA9ICgpID0+IHNjYWxlVmFsdWU7XHJcblxyXG5cdFx0Ly8gZGVmaW5lIGN1c3RvbSBkb21haW4oKSBmb3IgY2F0ZWdvcml6ZWQgYXhpc1xyXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRzY2FsZS5kb21haW4gPSBmdW5jdGlvbihkb21haW5WYWx1ZSkge1xyXG5cdFx0XHRcdGxldCBkb21haW4gPSBkb21haW5WYWx1ZTtcclxuXHJcblx0XHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRkb21haW4gPSB0aGlzLm9yZ0RvbWFpbigpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBbZG9tYWluWzBdLCBkb21haW5bMV0gKyAxXTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNjYWxlVmFsdWUuZG9tYWluKGRvbWFpbik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBzY2FsZTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2NhbGU7XHJcblx0fSxcclxuXHJcblx0Z2V0WVNjYWxlKGlkKSB7XHJcblx0XHRjb25zdCB7eSwgeTJ9ID0gdGhpcy5zY2FsZTtcclxuXHRcdHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyB5MiA6IHk7XHJcblx0fSxcclxuXHJcblx0Z2V0U3ViWVNjYWxlKGlkKSB7XHJcblx0XHRjb25zdCB7c3ViWSwgc3ViWTJ9ID0gdGhpcy5zY2FsZTtcclxuXHRcdHJldHVybiB0aGlzLmF4aXMuZ2V0SWQoaWQpID09PSBcInkyXCIgPyBzdWJZMiA6IHN1Ylk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHNjYWxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5pdCAtIHBhcmFtIGlzIGdpdmVuIGF0IHRoZSBpbml0IHJlbmRlcmluZ1xyXG5cdCAqL1xyXG5cdHVwZGF0ZVNjYWxlcyhpc0luaXQsIHVwZGF0ZVhEb21haW4gPSB0cnVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7YXhpcywgY29uZmlnLCBmb3JtYXQsIG9yZywgc2NhbGUsXHJcblx0XHRcdHN0YXRlOiB7d2lkdGgsIGhlaWdodCwgd2lkdGgyLCBoZWlnaHQyfVxyXG5cdFx0fSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5pc0F4aXMpIHtcclxuXHRcdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBlZGdlc1xyXG5cdFx0XHRjb25zdCBtaW4gPSB7XHJcblx0XHRcdFx0eDogaXNSb3RhdGVkID8gMSA6IDAsXHJcblx0XHRcdFx0eTogaXNSb3RhdGVkID8gMCA6IGhlaWdodCxcclxuXHRcdFx0XHRzdWJYOiBpc1JvdGF0ZWQgPyAxIDogMCxcclxuXHRcdFx0XHRzdWJZOiBpc1JvdGF0ZWQgPyAwIDogaGVpZ2h0MlxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y29uc3QgbWF4ID0ge1xyXG5cdFx0XHRcdHg6IGlzUm90YXRlZCA/IGhlaWdodCA6IHdpZHRoLFxyXG5cdFx0XHRcdHk6IGlzUm90YXRlZCA/IHdpZHRoIDogMSxcclxuXHRcdFx0XHRzdWJYOiBpc1JvdGF0ZWQgPyBoZWlnaHQgOiB3aWR0aCxcclxuXHRcdFx0XHRzdWJZOiBpc1JvdGF0ZWQgPyB3aWR0aDIgOiAxXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzY2FsZXNcclxuXHRcdFx0Ly8geCBBeGlzXHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSB1cGRhdGVYRG9tYWluICYmIHNjYWxlLnggJiYgc2NhbGUueC5vcmdEb21haW4oKTtcclxuXHRcdFx0Y29uc3QgeFN1YkRvbWFpbiA9IHVwZGF0ZVhEb21haW4gJiYgb3JnLnhEb21haW47XHJcblxyXG5cdFx0XHRzY2FsZS54ID0gJCQuZ2V0WChtaW4ueCwgbWF4LngsIHhEb21haW4sICgpID0+IGF4aXMueC50aWNrT2Zmc2V0KCkpO1xyXG5cdFx0XHRzY2FsZS5zdWJYID0gJCQuZ2V0WChtaW4ueCwgbWF4LngsIHhTdWJEb21haW4sIGQgPT4gKGQgJSAxID8gMCA6IGF4aXMuc3ViWC50aWNrT2Zmc2V0KCkpKTtcclxuXHJcblx0XHRcdGZvcm1hdC54QXhpc1RpY2sgPSBheGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpO1xyXG5cdFx0XHRheGlzLnRpY2sueCA9IGF4aXMuZ2V0VGlja1ZhbHVlcyhcInhcIik7XHJcblxyXG5cdFx0XHRheGlzLnggPSBheGlzLmdldEF4aXMoXCJ4XCIsIHNjYWxlLngsIGNvbmZpZy5heGlzX3hfdGlja19vdXRlciwgaXNJbml0KTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuc3ViY2hhcnRfc2hvdykge1xyXG5cdFx0XHRcdGF4aXMuc3ViWCA9IGF4aXMuZ2V0QXhpcyhcInN1YlhcIiwgc2NhbGUuc3ViWCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB5IEF4aXNcclxuXHRcdFx0c2NhbGUueSA9ICQkLmdldFkobWluLnksIG1heC55LCBzY2FsZS55ID8gc2NhbGUueS5kb21haW4oKSA6IGNvbmZpZy5heGlzX3lfZGVmYXVsdCk7XHJcblx0XHRcdHNjYWxlLnN1YlkgPSAkJC5nZXRZKG1pbi5zdWJZLCBtYXguc3ViWSwgc2NhbGUuc3ViWSA/IHNjYWxlLnN1YlkuZG9tYWluKCkgOiBjb25maWcuYXhpc195X2RlZmF1bHQpO1xyXG5cclxuXHRcdFx0YXhpcy50aWNrLnkgPSBheGlzLmdldFRpY2tWYWx1ZXMoXCJ5XCIpO1xyXG5cdFx0XHRheGlzLnkgPSBheGlzLmdldEF4aXMoXCJ5XCIsIHNjYWxlLnksIGNvbmZpZy5heGlzX3lfdGlja19vdXRlciwgaXNJbml0KTtcclxuXHJcblx0XHRcdC8vIHkyIEF4aXNcclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3kyX3Nob3cpIHtcclxuXHRcdFx0XHRzY2FsZS55MiA9ICQkLmdldFkobWluLnksIG1heC55LCBzY2FsZS55MiA/IHNjYWxlLnkyLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeTJfZGVmYXVsdCk7XHJcblx0XHRcdFx0c2NhbGUuc3ViWTIgPSAkJC5nZXRZKG1pbi5zdWJZLCBtYXguc3ViWSxcclxuXHRcdFx0XHRcdHNjYWxlLnN1YlkyID8gc2NhbGUuc3ViWTIuZG9tYWluKCkgOiBjb25maWcuYXhpc195Ml9kZWZhdWx0KTtcclxuXHJcblx0XHRcdFx0YXhpcy50aWNrLnkyID0gYXhpcy5nZXRUaWNrVmFsdWVzKFwieTJcIik7XHJcblx0XHRcdFx0YXhpcy55MiA9IGF4aXMuZ2V0QXhpcyhcInkyXCIsIHNjYWxlLnkyLCBjb25maWcuYXhpc195Ml90aWNrX291dGVyLCBpc0luaXQpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB1cGRhdGUgZm9yIGFyY1xyXG5cdFx0XHQkJC51cGRhdGVBcmMgJiYgJCQudXBkYXRlQXJjKCk7XHJcblx0XHR9XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzVmFsdWUsIGNlaWwxMCwgY2FwaXRhbGl6ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGNvbnRhaW5lciBzaXplXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRDb250YWluZXJTaXplKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cclxuXHRcdHN0YXRlLmN1cnJlbnRXaWR0aCA9ICQkLmdldEN1cnJlbnRXaWR0aCgpO1xyXG5cdFx0c3RhdGUuY3VycmVudEhlaWdodCA9ICQkLmdldEN1cnJlbnRIZWlnaHQoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50V2lkdGgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5zaXplX3dpZHRoIHx8ICQkLmdldFBhcmVudFdpZHRoKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudEhlaWdodCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBoID0gY29uZmlnLnNpemVfaGVpZ2h0IHx8ICQkLmdldFBhcmVudEhlaWdodCgpO1xyXG5cclxuXHRcdHJldHVybiBoID4gMCA/IGggOiAzMjAgLyAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSA/IDIgOiAxKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgQXhpcyBzaXplIGFjY29yZGluZyBpdHMgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgQXhpcyBpZCB2YWx1ZSAtIHgsIHkgb3IgeTJcclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9IHNpemUgQXhpcyBzaXplIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRBeGlzU2l6ZShpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRyZXR1cm4gKGlzUm90YXRlZCAmJiBpZCA9PT0gXCJ4XCIpIHx8ICghaXNSb3RhdGVkICYmIC95Mj8vLnRlc3QoaWQpKSA/XHJcblx0XHRcdCQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkLCB0cnVlKSA6XHJcblx0XHRcdCQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ1RvcCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWcuYXhpc195Ml9heGVzLmxlbmd0aDtcclxuXHJcblx0XHRsZXQgcGFkZGluZyA9IGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfdG9wKSA/XHJcblx0XHRcdGNvbmZpZy5wYWRkaW5nX3RvcCA6IDA7XHJcblxyXG5cdFx0aWYgKCRlbC50aXRsZSAmJiAkZWwudGl0bGUubm9kZSgpKSB7XHJcblx0XHRcdHBhZGRpbmcgKz0gJCQuZ2V0VGl0bGVQYWRkaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF4ZXNMZW4gJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRwYWRkaW5nICs9ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieTJcIikgKiBheGVzTGVuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGF4aXNJZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInlcIiA6IFwieFwiO1xyXG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fYXhlc2BdLmxlbmd0aDtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2JvdHRvbSkgP1xyXG5cdFx0XHRjb25maWcucGFkZGluZ19ib3R0b20gOiAwO1xyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nICsgKFxyXG5cdFx0XHRheGVzTGVuID8gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoYXhpc0lkKSAqIGF4ZXNMZW4gOiAwXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGF4aXNJZCA9IGlzUm90YXRlZCA/IFwieFwiIDogXCJ5XCI7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9heGVzYF0ubGVuZ3RoO1xyXG5cdFx0Y29uc3QgYXhpc1dpZHRoID0gJCQuaXNBeGlzID8gJCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoYXhpc0lkLCB3aXRob3V0UmVjb21wdXRlKSA6IDA7XHJcblx0XHRsZXQgcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNWYWx1ZShjb25maWcucGFkZGluZ19sZWZ0KSkge1xyXG5cdFx0XHRwYWRkaW5nID0gY29uZmlnLnBhZGRpbmdfbGVmdDtcclxuXHRcdH0gZWxzZSBpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAhY29uZmlnLmF4aXNfeF9zaG93ID9cclxuXHRcdFx0XHQxIDogTWF0aC5tYXgoY2VpbDEwKGF4aXNXaWR0aCksIDQwKTtcclxuXHRcdH0gZWxzZSBpZiAoIWNvbmZpZy5heGlzX3lfc2hvdyB8fCBjb25maWcuYXhpc195X2lubmVyKSB7IC8vICYmICFjb25maWcuYXhpc19yb3RhdGVkXHJcblx0XHRcdHBhZGRpbmcgPSAkJC5heGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpLmlzT3V0ZXIgPyAzMCA6IDE7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwYWRkaW5nID0gY2VpbDEwKGF4aXNXaWR0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhZGRpbmcgKyAoYXhpc1dpZHRoICogYXhlc0xlbik7XHJcblx0fSxcclxuXHJcblx0Z2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkZWZhdWx0UGFkZGluZyA9IDEwO1xyXG5cdFx0Y29uc3QgbGVnZW5kV2lkdGhPblJpZ2h0ID0gJCQuc3RhdGUuaXNMZWdlbmRSaWdodCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgKyAyMCA6IDA7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnLmF4aXNfeTJfYXhlcy5sZW5ndGg7XHJcblx0XHRjb25zdCBheGlzV2lkdGggPSAkJC5nZXRBeGlzV2lkdGhCeUF4aXNJZChcInkyXCIpO1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfcmlnaHQpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjb25maWcucGFkZGluZ19yaWdodCArIDE7IC8vIDEgaXMgbmVlZGVkIG5vdCB0byBoaWRlIHRpY2sgbGluZVxyXG5cdFx0fSBlbHNlIGlmICgkJC5heGlzICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyA9IGRlZmF1bHRQYWRkaW5nICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xyXG5cdFx0fSBlbHNlIGlmICgkJC5heGlzICYmICghY29uZmlnLmF4aXNfeTJfc2hvdyB8fCBjb25maWcuYXhpc195Ml9pbm5lcikpIHsgLy8gJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWRcclxuXHRcdFx0cGFkZGluZyA9IDIgKyBsZWdlbmRXaWR0aE9uUmlnaHQgK1xyXG5cdFx0XHRcdCgkJC5heGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKS5pc091dGVyID8gMjAgOiAwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjZWlsMTAoYXhpc1dpZHRoKSArIGxlZ2VuZFdpZHRoT25SaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZyArIChheGlzV2lkdGggKiBheGVzTGVuKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHBhcmVudCByZWN0IGVsZW1lbnQncyBzaXplXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGtleSBwcm9wZXJ0eS9hdHRyaWJ1dGUgbmFtZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0UGFyZW50UmVjdFZhbHVlKGtleSkge1xyXG5cdFx0Y29uc3Qgb2Zmc2V0TmFtZSA9IGBvZmZzZXQke2NhcGl0YWxpemUoa2V5KX1gO1xyXG5cdFx0bGV0IHBhcmVudCA9IHRoaXMuJGVsLmNoYXJ0Lm5vZGUoKTtcclxuXHRcdGxldCB2O1xyXG5cclxuXHRcdHdoaWxlICghdiAmJiBwYXJlbnQgJiYgcGFyZW50LnRhZ05hbWUgIT09IFwiQk9EWVwiKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0diA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtrZXldO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0aWYgKG9mZnNldE5hbWUgaW4gcGFyZW50KSB7XHJcblx0XHRcdFx0XHQvLyBJbiBJRSBpbiBjZXJ0YWluIGNhc2VzIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxyXG5cdFx0XHRcdFx0Ly8gd2lsbCBjYXVzZSBhbiBcInVuc3BlY2lmaWVkIGVycm9yXCJcclxuXHRcdFx0XHRcdHYgPSBwYXJlbnRbb2Zmc2V0TmFtZV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoa2V5ID09PSBcIndpZHRoXCIpIHtcclxuXHRcdFx0Ly8gU29tZXRpbWVzIGVsZW1lbnQncyB3aWR0aCB2YWx1ZSBpcyBpbmNvcnJlY3QoZXguIGZsZXggY29udGFpbmVyKVxyXG5cdFx0XHQvLyBJbiB0aGlzIGNhc2UsIHVzZSBib2R5J3Mgb2Zmc2V0V2lkdGggaW5zdGVhZC5cclxuXHRcdFx0Y29uc3QgYm9keVdpZHRoID0gZG9jdW1lbnQuYm9keS5vZmZzZXRXaWR0aDtcclxuXHJcblx0XHRcdHYgPiBib2R5V2lkdGggJiYgKHYgPSBib2R5V2lkdGgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2O1xyXG5cdH0sXHJcblxyXG5cdGdldFBhcmVudFdpZHRoKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UGFyZW50UmVjdFZhbHVlKFwid2lkdGhcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0UGFyZW50SGVpZ2h0KCkge1xyXG5cdFx0Y29uc3QgaCA9IHRoaXMuJGVsLmNoYXJ0LnN0eWxlKFwiaGVpZ2h0XCIpO1xyXG5cclxuXHRcdHJldHVybiBoLmluZGV4T2YoXCJweFwiKSA+IDAgPyBwYXJzZUludChoLCAxMCkgOiAwO1xyXG5cdH0sXHJcblxyXG5cdGdldFN2Z0xlZnQod2l0aG91dFJlY29tcHV0ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzTGVmdEF4aXNSZWN0ID0gY29uZmlnLmF4aXNfcm90YXRlZCB8fCAoIWNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgIWNvbmZpZy5heGlzX3lfaW5uZXIpO1xyXG5cdFx0Y29uc3QgbGVmdEF4aXNDbGFzcyA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBDTEFTUy5heGlzWCA6IENMQVNTLmF4aXNZO1xyXG5cdFx0Y29uc3QgbGVmdEF4aXMgPSAkZWwubWFpbi5zZWxlY3QoYC4ke2xlZnRBeGlzQ2xhc3N9YCkubm9kZSgpO1xyXG5cdFx0Y29uc3Qgc3ZnUmVjdCA9IGxlZnRBeGlzICYmIGhhc0xlZnRBeGlzUmVjdCA/IGxlZnRBeGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDoge3JpZ2h0OiAwfTtcclxuXHRcdGNvbnN0IGNoYXJ0UmVjdCA9ICRlbC5jaGFydC5ub2RlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHRjb25zdCBoYXNBcmMgPSAkJC5oYXNBcmNUeXBlKCk7XHJcblx0XHRjb25zdCBzdmdMZWZ0ID0gc3ZnUmVjdC5yaWdodCAtIGNoYXJ0UmVjdC5sZWZ0IC1cclxuXHRcdFx0KGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQod2l0aG91dFJlY29tcHV0ZSkpO1xyXG5cclxuXHRcdHJldHVybiBzdmdMZWZ0ID4gMCA/IHN2Z0xlZnQgOiAwO1xyXG5cdH0sXHJcblxyXG5cdGdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkLCB3aXRob3V0UmVjb21wdXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCQkLmF4aXMpIHtcclxuXHRcdFx0Y29uc3QgcG9zaXRpb24gPSAkJC5heGlzICYmICQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpO1xyXG5cclxuXHRcdFx0cmV0dXJuICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkLCB3aXRob3V0UmVjb21wdXRlKSArXHJcblx0XHRcdFx0KHBvc2l0aW9uLmlzSW5uZXIgPyAyMCA6IDQwKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiA0MDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRIb3Jpem9udGFsQXhpc0hlaWdodChpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHtyb3RhdGVkUGFkZGluZywgaXNMZWdlbmRSaWdodCwgaXNMZWdlbmRJbnNldH0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgaCA9IDMwO1xyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ4XCIgJiYgIWNvbmZpZy5heGlzX3hfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gODtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiICYmIGNvbmZpZy5heGlzX3hfaGVpZ2h0KSB7XHJcblx0XHRcdHJldHVybiBjb25maWcuYXhpc194X2hlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaWQgPT09IFwieVwiICYmICFjb25maWcuYXhpc195X3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy5sZWdlbmRfc2hvdyAmJlxyXG5cdFx0XHRcdCFpc0xlZ2VuZFJpZ2h0ICYmXHJcblx0XHRcdFx0IWlzTGVnZW5kSW5zZXQgPyAxMCA6IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInkyXCIgJiYgIWNvbmZpZy5heGlzX3kyX3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuIHJvdGF0ZWRQYWRkaW5nLnRvcDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByb3RhdGUgPSBjb25maWdbYGF4aXNfJHtpZH1fdGlja19yb3RhdGVgXTtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgeC95IGF4aXMgaGVpZ2h0IHdoZW4gdGljayByb3RhdGVkXHJcblx0XHRpZiAoXHJcblx0XHRcdCgoaWQgPT09IFwieFwiICYmICFpc1JvdGF0ZWQpIHx8ICgveTI/Ly50ZXN0KGlkKSAmJiBpc1JvdGF0ZWQpKSAmJiByb3RhdGVcclxuXHRcdCkge1xyXG5cdFx0XHRoID0gMzAgK1xyXG5cdFx0XHRcdCQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkKSAqXHJcblx0XHRcdFx0TWF0aC5jb3MoTWF0aC5QSSAqICg5MCAtIHJvdGF0ZSkgLyAxODApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoICtcclxuXHRcdFx0KCQkLmF4aXMuZ2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpLmlzSW5uZXIgPyAwIDogMTApICtcclxuXHRcdFx0KGlkID09PSBcInkyXCIgJiYgIWlzUm90YXRlZCA/IC0xMCA6IDApO1xyXG5cdH0sXHJcblxyXG5cdGdldEV2ZW50UmVjdFdpZHRoKCkge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuYXhpcy54LnRpY2tJbnRlcnZhbCgpKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0c2VsZWN0QWxsIGFzIGQzU2VsZWN0QWxsXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgZ2V0Qm91bmRpbmdSZWN0LCBnZXRSYW5kb20sIGlzTnVtYmVyLCBpc09iamVjdCwgaXNTdHJpbmcsIGdldFRyYW5zbGF0aW9ufSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyB0aGUgdGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFRleHQoKSB7XHJcblx0XHRjb25zdCB7JGVsOiB7bWFpbn19ID0gdGhpcztcclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0VGV4dHMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBjaGFydFRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSAkJC5kYXRhLnRhcmdldHNcclxuXHQgKi9cclxuXHR1cGRhdGVUYXJnZXRzRm9yVGV4dCh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0VGV4dCA9ICQkLmNsYXNzQ2hhcnRUZXh0LmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NUZXh0cyA9ICQkLmNsYXNzVGV4dHMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IG1haW5UZXh0VXBkYXRlID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydFRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRUZXh0fWApXHJcblx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0VGV4dChkKSArIGNsYXNzRm9jdXMoZCkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5UZXh0RW50ZXIgPSBtYWluVGV4dFVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0VGV4dClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cclxuXHRcdG1haW5UZXh0RW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dHMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0ZXh0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhRm4gPSAkJC5sYWJlbGlzaERhdGEuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc1RleHQgPSAkJC5jbGFzc1RleHQuYmluZCgkJCk7XHJcblxyXG5cdFx0JGVsLnRleHQgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnRleHRzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MudGV4dH1gKVxyXG5cdFx0XHQuZGF0YShkID0+ICh0aGlzLmlzUmFkYXJUeXBlKGQpID8gZC52YWx1ZXMgOiBkYXRhRm4oZCkpKTtcclxuXHJcblx0XHQkZWwudGV4dC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwudGV4dCA9ICRlbC50ZXh0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0Lm1lcmdlKCQkLiRlbC50ZXh0KVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBkID0+IChjb25maWcuYXhpc19yb3RhdGVkID8gKGQudmFsdWUgPCAwID8gXCJlbmRcIiA6IFwic3RhcnRcIikgOiBcIm1pZGRsZVwiKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVUZXh0Q29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnRleHQoKGQsIGksIGopID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9ICQkLmlzQnViYmxlWlR5cGUoZCkgPyAkJC5nZXRCdWJibGVaRGF0YShkLnZhbHVlLCBcInpcIikgOiBkLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gJCQuZGF0YUxhYmVsRm9ybWF0KGQuaWQpKHZhbHVlLCBkLmlkLCBpLCBqKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGV4dENvbG9yKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGxhYmVsQ29sb3JzID0gJCQuY29uZmlnLmRhdGFfbGFiZWxzX2NvbG9ycztcclxuXHRcdGxldCBjb2xvcjtcclxuXHJcblx0XHRpZiAoaXNTdHJpbmcobGFiZWxDb2xvcnMpKSB7XHJcblx0XHRcdGNvbG9yID0gbGFiZWxDb2xvcnM7XHJcblx0XHR9IGVsc2UgaWYgKGlzT2JqZWN0KGxhYmVsQ29sb3JzKSkge1xyXG5cdFx0XHRjb2xvciA9IGxhYmVsQ29sb3JzW2QuaWRdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb2xvciB8fCAkJC5jb2xvcihkKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgY2hhcnRUZXh0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0geCBQb3NpdGlvbmluZyBmdW5jdGlvbiBmb3IgeFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHkgUG9zaXRpb25pbmcgZnVuY3Rpb24gZm9yIHlcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvckZsb3dcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdpdGhUcmFuc2l0aW9uIHRyYW5zaXRpb24gaXMgZW5hYmxlZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3VGV4dCh4LCB5LCBmb3JGbG93LCB3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdDogYW55ID0gZ2V0UmFuZG9tKCk7XHJcblx0XHRjb25zdCBvcGFjaXR5Rm9yVGV4dCA9IGZvckZsb3cgPyAwIDogJCQub3BhY2l0eUZvclRleHQuYmluZCgkJCk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0dGhpcy4kZWwudGV4dC5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNvbnN0IHRleHQgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHJcblx0XHRcdFx0Ly8gZG8gbm90IGFwcGx5IHRyYW5zaXRpb24gZm9yIG5ld2x5IGFkZGVkIHRleHQgZWxlbWVudHNcclxuXHRcdFx0XHQod2l0aFRyYW5zaXRpb24gJiYgdGV4dC5hdHRyKFwieFwiKSA/IHRleHQudHJhbnNpdGlvbih0KSA6IHRleHQpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5KVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVUZXh0Q29sb3IuYmluZCgkJCkpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgb3BhY2l0eUZvclRleHQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgdmFsdWUgb2YgdGhlIGVsZW1lbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZVxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IHZhbHVlIG9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuXHQgKi9cclxuXHRnZXRUZXh0UmVjdChlbGVtZW50LCBjbGFzc05hbWU6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IGJhc2UgPSAoZWxlbWVudC5ub2RlID8gZWxlbWVudC5ub2RlKCkgOiBlbGVtZW50KTtcclxuXHJcblx0XHRpZiAoIS90ZXh0L2kudGVzdChiYXNlLnRhZ05hbWUpKSB7XHJcblx0XHRcdGJhc2UgPSBiYXNlLnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHQgPSBiYXNlLnRleHRDb250ZW50O1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBgJCR7dGV4dC5yZXBsYWNlKC9cXFcvZywgXCJfXCIpfWA7XHJcblx0XHRsZXQgcmVjdCA9ICQkLmNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG5cdFx0aWYgKCFyZWN0KSB7XHJcblx0XHRcdCQkLiRlbC5zdmcuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0XHQuc3R5bGUoXCJmb250XCIsIGQzU2VsZWN0KGJhc2UpLnN0eWxlKFwiZm9udFwiKSlcclxuXHRcdFx0XHQuY2xhc3NlZChjbGFzc05hbWUsIHRydWUpXHJcblx0XHRcdFx0LnRleHQodGV4dClcclxuXHRcdFx0XHQuY2FsbCh2ID0+IHtcclxuXHRcdFx0XHRcdHJlY3QgPSBnZXRCb3VuZGluZ1JlY3Qodi5ub2RlKCkpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCByZWN0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB4IG9yIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBpbmRpY2VzIEluZGljZXMgdmFsdWVzXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JYIHdoZXRoZXIgb3Igbm90IHRvIHhcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBjb29yZGluYXRlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVYWUZvclRleHQoaW5kaWNlcywgZm9yWCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdHlwZXMgPSBPYmplY3Qua2V5cyhpbmRpY2VzKTtcclxuXHRcdGNvbnN0IHBvaW50cyA9IHt9O1xyXG5cdFx0Y29uc3QgZ2V0dGVyID0gZm9yWCA/ICQkLmdldFhGb3JUZXh0IDogJCQuZ2V0WUZvclRleHQ7XHJcblxyXG5cdFx0JCQuaGFzVHlwZShcInJhZGFyXCIpICYmIHR5cGVzLnB1c2goXCJyYWRhclwiKTtcclxuXHJcblx0XHR0eXBlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRwb2ludHNbdl0gPSAkJFtgZ2VuZXJhdGVHZXQke2NhcGl0YWxpemUodil9UG9pbnRzYF0oaW5kaWNlc1t2XSwgZmFsc2UpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0Y29uc3QgdHlwZSA9ICgkJC5pc0FyZWFUeXBlKGQpICYmIFwiYXJlYVwiKSB8fFxyXG5cdFx0XHRcdCgkJC5pc0JhclR5cGUoZCkgJiYgXCJiYXJcIikgfHxcclxuXHRcdFx0XHQoJCQuaXNSYWRhclR5cGUoZCkgJiYgXCJyYWRhclwiKSB8fCBcImxpbmVcIjtcclxuXHJcblx0XHRcdHJldHVybiBnZXR0ZXIuY2FsbCgkJCwgcG9pbnRzW3R5cGVdKGQsIGkpLCBkLCB0aGlzKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGNlbnRlcml6ZWQgdGV4dCBwb3NpdGlvbiBmb3IgYmFyIHR5cGUgZGF0YS5sYWJlbC50ZXh0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBEYXRhIHBvaW50cyBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRleHRFbGVtZW50IERhdGEgbGFiZWwgdGV4dCBlbGVtZW50XHJcblx0ICogQHJldHVybnMge051bWJlcn0gUG9zaXRpb24gdmFsdWVcclxuXHQgKi9cclxuXHRnZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2xhYmVscy5jZW50ZXJlZCAmJiAkJC5pc0JhclR5cGUoZCkpIHtcclxuXHRcdFx0Y29uc3QgcmVjdCA9IGdldEJvdW5kaW5nUmVjdCh0ZXh0RWxlbWVudCk7XHJcblx0XHRcdGNvbnN0IGlzUG9zaXRpdmUgPSBkLnZhbHVlID49IDA7XHJcblxyXG5cdFx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgdyA9IChcclxuXHRcdFx0XHRcdGlzUG9zaXRpdmUgP1xyXG5cdFx0XHRcdFx0XHRwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV0gOlxyXG5cdFx0XHRcdFx0XHRwb2ludHNbMF1bMV0gLSBwb2ludHNbMV1bMV1cclxuXHRcdFx0XHQpIC8gMiArIChyZWN0LndpZHRoIC8gMik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gLXcgLSAzIDogdyArIDI7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y29uc3QgaCA9IChcclxuXHRcdFx0XHRcdGlzUG9zaXRpdmUgP1xyXG5cdFx0XHRcdFx0XHRwb2ludHNbMF1bMV0gLSBwb2ludHNbMV1bMV0gOlxyXG5cdFx0XHRcdFx0XHRwb2ludHNbMV1bMV0gLSBwb2ludHNbMF1bMV1cclxuXHRcdFx0XHQpIC8gMiArIChyZWN0LmhlaWdodCAvIDIpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaXNQb3NpdGl2ZSA/IGggOiAtaCAtIDI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgZGF0YS5sYWJlbHMucG9zaXRpb24gdmFsdWVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgRGF0YSBpZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIHggfCB5XHJcblx0ICogQHJldHVybiB7TnVtYmVyfSBQb3NpdGlvbiB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VGV4dFBvcyhpZCwgdHlwZSkge1xyXG5cdFx0Y29uc3QgcG9zID0gdGhpcy5jb25maWcuZGF0YV9sYWJlbHNfcG9zaXRpb247XHJcblxyXG5cdFx0cmV0dXJuIChpZCBpbiBwb3MgPyBwb3NbaWRdIDogcG9zKVt0eXBlXSB8fCAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHggY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHBvaW50c1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IHggY29vcmRpbmF0ZVxyXG5cdCAqL1xyXG5cdGdldFhGb3JUZXh0KHBvaW50cywgZCwgdGV4dEVsZW1lbnQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCB4UG9zO1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHRwYWRkaW5nID0gJCQuaXNCYXJUeXBlKGQpID8gNCA6IDY7XHJcblx0XHRcdHhQb3MgPSBwb2ludHNbMl1bMV0gKyBwYWRkaW5nICogKGQudmFsdWUgPCAwID8gLTEgOiAxKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHhQb3MgPSAkJC5oYXNUeXBlKFwiYmFyXCIpID8gKHBvaW50c1syXVswXSArIHBvaW50c1swXVswXSkgLyAyIDogcG9pbnRzWzBdWzBdO1xyXG5cdFx0fVxyXG5cdFx0Ly8gc2hvdyBsYWJlbHMgcmVnYXJkbGVzcyBvZiB0aGUgZG9tYWluIGlmIHZhbHVlIGlzIG51bGxcclxuXHRcdGlmIChkLnZhbHVlID09PSBudWxsKSB7XHJcblx0XHRcdGlmICh4UG9zID4gc3RhdGUud2lkdGgpIHtcclxuXHRcdFx0XHRjb25zdCB7d2lkdGh9ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcclxuXHJcblx0XHRcdFx0eFBvcyA9IHN0YXRlLndpZHRoIC0gd2lkdGg7XHJcblx0XHRcdH0gZWxzZSBpZiAoeFBvcyA8IDApIHtcclxuXHRcdFx0XHR4UG9zID0gNDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0eFBvcyArPSAkJC5nZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHhQb3MgKyAkJC5nZXRUZXh0UG9zKGQuaWQsIFwieFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXRzIHRoZSB5IGNvb3JkaW5hdGUgb2YgdGhlIHRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB5IGNvb3JkaW5hdGVcclxuXHQgKi9cclxuXHRnZXRZRm9yVGV4dChwb2ludHMsIGQsIHRleHRFbGVtZW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCByID0gY29uZmlnLnBvaW50X3I7XHJcblx0XHRjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcclxuXHRcdGxldCBiYXNlWSA9IDM7XHJcblx0XHRsZXQgeVBvcztcclxuXHJcblx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdHlQb3MgPSAocG9pbnRzWzBdWzBdICsgcG9pbnRzWzJdWzBdICsgcmVjdC5oZWlnaHQgKiAwLjYpIC8gMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHlQb3MgPSBwb2ludHNbMl1bMV07XHJcblxyXG5cdFx0XHRpZiAoaXNOdW1iZXIocikgJiYgciA+IDUgJiYgKCQkLmlzTGluZVR5cGUoZCkgfHwgJCQuaXNTY2F0dGVyVHlwZShkKSkpIHtcclxuXHRcdFx0XHRiYXNlWSArPSBjb25maWcucG9pbnRfciAvIDIuMztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGQudmFsdWUgPCAwIHx8IChkLnZhbHVlID09PSAwICYmICFzdGF0ZS5oYXNQb3NpdGl2ZVZhbHVlICYmIHN0YXRlLmhhc05lZ2F0aXZlVmFsdWUpKSB7XHJcblx0XHRcdFx0eVBvcyArPSByZWN0LmhlaWdodCArICgkJC5pc0JhclR5cGUoZCkgPyAtYmFzZVkgOiBiYXNlWSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGRpZmYgPSAtYmFzZVkgKiAyO1xyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNCYXJUeXBlKGQpKSB7XHJcblx0XHRcdFx0XHRkaWZmID0gLWJhc2VZO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVUeXBlKGQpKSB7XHJcblx0XHRcdFx0XHRkaWZmID0gYmFzZVk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR5UG9zICs9IGRpZmY7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxyXG5cdFx0aWYgKGQudmFsdWUgPT09IG51bGwgJiYgIWlzUm90YXRlZCkge1xyXG5cdFx0XHRjb25zdCBib3hIZWlnaHQgPSByZWN0LmhlaWdodDtcclxuXHJcblx0XHRcdGlmICh5UG9zIDwgYm94SGVpZ2h0KSB7XHJcblx0XHRcdFx0eVBvcyA9IGJveEhlaWdodDtcclxuXHRcdFx0fSBlbHNlIGlmICh5UG9zID4gdGhpcy5oZWlnaHQpIHtcclxuXHRcdFx0XHR5UG9zID0gdGhpcy5oZWlnaHQgLSA0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc1JvdGF0ZWQpIHtcclxuXHRcdFx0eVBvcyArPSAkJC5nZXRDZW50ZXJlZFRleHRQb3MoZCwgcG9pbnRzLCB0ZXh0RWxlbWVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHlQb3MgKyAkJC5nZXRUZXh0UG9zKGQuaWQsIFwieVwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxjdWxhdGUgaWYgdHdvIG9yIG1vcmUgdGV4dCBub2RlcyBhcmUgb3ZlcmxhcHBpbmdcclxuXHQgKiBNYXJrIG92ZXJsYXBwaW5nIHRleHQgbm9kZXMgd2l0aCBcInRleHQtb3ZlcmxhcHBpbmdcIiBjbGFzc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtudW1iZXJ9IGlkXHJcblx0ICogQHBhcmFtIHtDaGFydEludGVybmFsfSAkJFxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxyXG5cdCAqL1xyXG5cdG1hcmtPdmVybGFwcGVkKGlkLCAkJCwgc2VsZWN0b3IpIHtcclxuXHRcdGNvbnN0IHRleHROb2RlcyA9ICQkLiRlbC5hcmNzLnNlbGVjdEFsbChzZWxlY3Rvcik7XHJcblx0XHRjb25zdCBmaWx0ZXJlZFRleHROb2RlcyA9IHRleHROb2Rlcy5maWx0ZXIobm9kZSA9PiBub2RlLmRhdGEuaWQgIT09IGlkKTtcclxuXHRcdGNvbnN0IHRleHROb2RlID0gdGV4dE5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUuZGF0YS5pZCA9PT0gaWQpO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlID0gZ2V0VHJhbnNsYXRpb24odGV4dE5vZGUubm9kZSgpKTtcclxuXHJcblx0XHQvLyBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhlIGh5cG90ZW51c2VcclxuXHRcdGNvbnN0IGNhbGNIeXBvID0gKHgsIHkpID0+IE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKTtcclxuXHJcblx0XHR0ZXh0Tm9kZS5ub2RlKCkgJiYgZmlsdGVyZWRUZXh0Tm9kZXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgY29vcmRpbmF0ZSA9IGdldFRyYW5zbGF0aW9uKHRoaXMpO1xyXG5cdFx0XHRjb25zdCBmaWx0ZXJlZFRleHROb2RlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdGNvbnN0IG5vZGVGb3JXaWR0aCA9IGNhbGNIeXBvKHRyYW5zbGF0ZS5lLCB0cmFuc2xhdGUuZikgPiBjYWxjSHlwbyhjb29yZGluYXRlLmUsIGNvb3JkaW5hdGUuZikgP1xyXG5cdFx0XHRcdHRleHROb2RlIDogZmlsdGVyZWRUZXh0Tm9kZTtcclxuXHJcblx0XHRcdGNvbnN0IG92ZXJsYXBzWCA9IE1hdGguY2VpbChNYXRoLmFicyh0cmFuc2xhdGUuZSAtIGNvb3JkaW5hdGUuZSkpIDxcclxuXHRcdFx0XHRNYXRoLmNlaWwobm9kZUZvcldpZHRoLm5vZGUoKS5nZXRDb21wdXRlZFRleHRMZW5ndGgoKSk7XHJcblx0XHRcdGNvbnN0IG92ZXJsYXBzWSA9IE1hdGguY2VpbChNYXRoLmFicyh0cmFuc2xhdGUuZiAtIGNvb3JkaW5hdGUuZikpIDxcclxuXHRcdFx0XHRwYXJzZUludCh0ZXh0Tm9kZS5zdHlsZShcImZvbnQtc2l6ZVwiKSwgMCk7XHJcblxyXG5cdFx0XHRmaWx0ZXJlZFRleHROb2RlLmNsYXNzZWQoQ0xBU1MuVGV4dE92ZXJsYXBwaW5nLCBvdmVybGFwc1ggJiYgb3ZlcmxhcHNZKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSBpZiB0d28gb3IgbW9yZSB0ZXh0IG5vZGVzIGFyZSBvdmVybGFwcGluZ1xyXG5cdCAqIFJlbW92ZSBcInRleHQtb3ZlcmxhcHBpbmdcIiBjbGFzcyBvbiBzZWxlY3RlZCB0ZXh0IG5vZGVzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0NoYXJ0SW50ZXJuYWx9ICQkXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXHJcblx0ICovXHJcblx0dW5kb01hcmtPdmVybGFwcGVkKCQkLCBzZWxlY3Rvcikge1xyXG5cdFx0JCQuJGVsLmFyY3Muc2VsZWN0QWxsKHNlbGVjdG9yKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRkM1NlbGVjdEFsbChbdGhpcywgdGhpcy5wcmV2aW91c1NpYmxpbmddKVxyXG5cdFx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MuVGV4dE92ZXJsYXBwaW5nLCBmYWxzZSk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzTnVtYmVyLCBzZXRUZXh0VmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSB0ZXh0IHBvc2l0aW9uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwb3MgcmlnaHQsIGxlZnQgb3IgY2VudGVyXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCBjaGFydCB3aWR0aFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfSB0ZXh0LWFuY2hvciB2YWx1ZSBvciBwb3NpdGlvbiBpbiBwaXhlbFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VGV4dFBvcyhwb3MgPSBcImxlZnRcIiwgd2lkdGg/OiBudW1iZXIpIHtcclxuXHRjb25zdCBpc051bSA9IGlzTnVtYmVyKHdpZHRoKTtcclxuXHRsZXQgcG9zaXRpb247XHJcblxyXG5cdGlmIChwb3MuaW5kZXhPZihcImNlbnRlclwiKSA+IC0xKSB7XHJcblx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRwb3NpdGlvbiA9IGlzTnVtID8gd2lkdGggLyAyIDogXCJtaWRkbGVcIjtcclxuXHR9IGVsc2UgaWYgKHBvcy5pbmRleE9mKFwicmlnaHRcIikgPiAtMSkge1xyXG5cdFx0cG9zaXRpb24gPSBpc051bSA/IHdpZHRoIDogXCJlbmRcIjtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cG9zaXRpb24gPSBpc051bSA/IDAgOiBcInN0YXJ0XCI7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcG9zaXRpb247XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplcyB0aGUgdGl0bGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUaXRsZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLnRpdGxlX3RleHQpIHtcclxuXHRcdFx0JGVsLnRpdGxlID0gJGVsLnN2Zy5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdFx0Y29uc3QgdGV4dCA9ICRlbC50aXRsZVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgZ2V0VGV4dFBvcyhjb25maWcudGl0bGVfcG9zaXRpb24pKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MudGl0bGUpO1xyXG5cclxuXHRcdFx0c2V0VGV4dFZhbHVlKHRleHQsIGNvbmZpZy50aXRsZV90ZXh0LCBbMC4zLCAxLjVdKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGl0bGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd1RpdGxlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50V2lkdGh9LCAkZWw6IHt0aXRsZX19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKHRpdGxlKSB7XHJcblx0XHRcdGNvbnN0IHkgPSAkJC55Rm9yVGl0bGUuY2FsbCgkJCk7XHJcblxyXG5cdFx0XHRpZiAoL2cvaS50ZXN0KHRpdGxlLm5vZGUoKS50YWdOYW1lKSkge1xyXG5cdFx0XHRcdHRpdGxlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke2dldFRleHRQb3MoY29uZmlnLnRpdGxlX3Bvc2l0aW9uLCBjdXJyZW50V2lkdGgpfSwgJHt5fSlgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aXRsZS5hdHRyKFwieFwiLCAkJC54Rm9yVGl0bGUuY2FsbCgkJCkpLmF0dHIoXCJ5XCIsIHkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgeCBhdHRyaWJ1dGUgdmFsdWUgb2YgdGhlIHRpdGxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSB4IGF0dHJpYnV0ZSB2YWx1ZVxyXG5cdCAqL1xyXG5cdHhGb3JUaXRsZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y3VycmVudFdpZHRofX0gPSAkJDtcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gY29uZmlnLnRpdGxlX3Bvc2l0aW9uIHx8IFwibGVmdFwiO1xyXG5cdFx0Y29uc3QgdGV4dFJlY3RXaWR0aCA9ICQkLmdldFRleHRSZWN0KCQkLiRlbC50aXRsZSwgQ0xBU1MudGl0bGUpLndpZHRoO1xyXG5cdFx0bGV0IHg7XHJcblxyXG5cdFx0aWYgKC8ocmlnaHR8Y2VudGVyKS8udGVzdChwb3NpdGlvbikpIHtcclxuXHRcdFx0eCA9IGN1cnJlbnRXaWR0aCAtIHRleHRSZWN0V2lkdGg7XHJcblxyXG5cdFx0XHRpZiAocG9zaXRpb24uaW5kZXhPZihcInJpZ2h0XCIpID49IDApIHtcclxuXHRcdFx0XHR4ID0gY3VycmVudFdpZHRoIC0gdGV4dFJlY3RXaWR0aCAtIGNvbmZpZy50aXRsZV9wYWRkaW5nLnJpZ2h0O1xyXG5cdFx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmluZGV4T2YoXCJjZW50ZXJcIikgPj0gMCkge1xyXG5cdFx0XHRcdHggPSAoY3VycmVudFdpZHRoIC0gdGV4dFJlY3RXaWR0aCkgLyAyO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgeyAvLyBsZWZ0XHJcblx0XHRcdHggPSAoY29uZmlnLnRpdGxlX3BhZGRpbmcubGVmdCB8fCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB5IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IHkgYXR0cmlidXRlIHZhbHVlXHJcblx0ICovXHJcblx0eUZvclRpdGxlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAoJCQuY29uZmlnLnRpdGxlX3BhZGRpbmcudG9wIHx8IDApICtcclxuXHRcdFx0JCQuZ2V0VGV4dFJlY3QoJCQuJGVsLnRpdGxlLCBDTEFTUy50aXRsZSkuaGVpZ2h0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aXRsZSBwYWRkaW5nXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBwYWRkaW5nIHZhbHVlXHJcblx0ICovXHJcblx0Z2V0VGl0bGVQYWRkaW5nKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC55Rm9yVGl0bGUoKSArICgkJC5jb25maWcudGl0bGVfcGFkZGluZy5ib3R0b20gfHwgMCk7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRtb3VzZSBhcyBkM01vdXNlXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZywgaXNWYWx1ZSwgY2FsbEZuLCBzYW5pdGlzZSwgdHBsUHJvY2VzcywgaXNVbmRlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0VG9vbHRpcCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHtiaW5kdG99ID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XHJcblxyXG5cdFx0JGVsLnRvb2x0aXAgPSBkM1NlbGVjdChiaW5kdG8pO1xyXG5cclxuXHRcdGlmICgkZWwudG9vbHRpcC5lbXB0eSgpKSB7XHJcblx0XHRcdCRlbC50b29sdGlwID0gJGVsLmNoYXJ0XHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJyZWxhdGl2ZVwiKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJkaXZcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnRvb2x0aXBDb250YWluZXIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9zaXRpb25cIiwgXCJhYnNvbHV0ZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNob3cgdG9vbHRpcCBpZiBuZWVkZWRcclxuXHRcdGlmIChjb25maWcudG9vbHRpcF9pbml0X3Nob3cpIHtcclxuXHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpICYmIGlzU3RyaW5nKGNvbmZpZy50b29sdGlwX2luaXRfeCkpIHtcclxuXHRcdFx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzWzBdO1xyXG5cdFx0XHRcdGxldCBpO1xyXG5cdFx0XHRcdGxldCB2YWw7XHJcblxyXG5cdFx0XHRcdGNvbmZpZy50b29sdGlwX2luaXRfeCA9ICQkLnBhcnNlRGF0ZShjb25maWcudG9vbHRpcF9pbml0X3gpO1xyXG5cclxuXHRcdFx0XHRmb3IgKGkgPSAwOyAodmFsID0gdGFyZ2V0cy52YWx1ZXNbaV0pOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmICgodmFsLnggLSBjb25maWcudG9vbHRpcF9pbml0X3gpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uZmlnLnRvb2x0aXBfaW5pdF94ID0gaTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JGVsLnRvb2x0aXAuaHRtbCgkJC5nZXRUb29sdGlwSFRNTChcclxuXHRcdFx0XHQkJC5kYXRhLnRhcmdldHMubWFwKGQgPT4gJCQuYWRkTmFtZShkLnZhbHVlc1tjb25maWcudG9vbHRpcF9pbml0X3hdKSksXHJcblx0XHRcdFx0JCQuYXhpcy5nZXRYQXhpc1RpY2tGb3JtYXQoKSxcclxuXHRcdFx0XHQkJC5nZXRZRm9ybWF0KCQkLmhhc0FyY1R5cGUobnVsbCwgW1wicmFkYXJcIl0pKSxcclxuXHRcdFx0XHQkJC5jb2xvclxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHRcdGlmICghYmluZHRvKSB7XHJcblx0XHRcdFx0JGVsLnRvb2x0aXAuc3R5bGUoXCJ0b3BcIiwgY29uZmlnLnRvb2x0aXBfaW5pdF9wb3NpdGlvbi50b3ApXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsIGNvbmZpZy50b29sdGlwX2luaXRfcG9zaXRpb24ubGVmdClcclxuXHRcdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgdG9vbHRpcCBIVE1MIHN0cmluZ1xyXG5cdCAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBGb3JtYXR0ZWQgSFRNTCBzdHJpbmdcclxuXHQgKi9cclxuXHRnZXRUb29sdGlwSFRNTCguLi5hcmdzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBpc0Z1bmN0aW9uKGNvbmZpZy50b29sdGlwX2NvbnRlbnRzKSA/XHJcblx0XHRcdGNvbmZpZy50b29sdGlwX2NvbnRlbnRzLmNhbGwoJCQsIC4uLmFyZ3MpIDogJCQuZ2V0VG9vbHRpcENvbnRlbnQoLi4uYXJncyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdG9vbHRpcCBjb250ZW50KEhUTUwgc3RyaW5nKVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIGRhdGFcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWZhdWx0VGl0bGVGb3JtYXQgRGVmYXVsdCB0aXRsZSBmb3JtYXRcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkZWZhdWx0VmFsdWVGb3JtYXQgRGVmYXVsdCBmb3JtYXQgZm9yIGVhY2ggZGF0YSB2YWx1ZSBpbiB0aGUgdG9vbHRpcC5cclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb2xvciBDb2xvciBmdW5jdGlvblxyXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IGh0bWxcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvb2x0aXBDb250ZW50KGQsIGRlZmF1bHRUaXRsZUZvcm1hdCwgZGVmYXVsdFZhbHVlRm9ybWF0LCBjb2xvcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRpdGxlRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X3RpdGxlIHx8IGRlZmF1bHRUaXRsZUZvcm1hdDtcclxuXHRcdGNvbnN0IG5hbWVGb3JtYXQgPSBjb25maWcudG9vbHRpcF9mb3JtYXRfbmFtZSB8fCAobmFtZSA9PiBuYW1lKTtcclxuXHRcdGNvbnN0IHZhbHVlRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X3ZhbHVlIHx8ICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpID8gKCh2LCByYXRpbykgPT4gYCR7KHJhdGlvICogMTAwKS50b0ZpeGVkKDIpfSVgKSA6IGRlZmF1bHRWYWx1ZUZvcm1hdCk7XHJcblx0XHRjb25zdCBvcmRlciA9IGNvbmZpZy50b29sdGlwX29yZGVyO1xyXG5cdFx0Y29uc3QgZ2V0Um93VmFsdWUgPSByb3cgPT4gKCQkLmF4aXMgJiYgJCQuaXNCdWJibGVaVHlwZShyb3cpID8gJCQuZ2V0QnViYmxlWkRhdGEocm93LnZhbHVlLCBcInpcIikgOiAkJC5nZXRCYXNlVmFsdWUocm93KSk7XHJcblx0XHRjb25zdCBnZXRCZ0NvbG9yID0gJCQubGV2ZWxDb2xvciA/IHJvdyA9PiAkJC5sZXZlbENvbG9yKHJvdy52YWx1ZSkgOiByb3cgPT4gY29sb3Iocm93KTtcclxuXHRcdGNvbnN0IGNvbnRlbnRzID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XHJcblx0XHRjb25zdCB0cGxTdHIgPSBjb250ZW50cy50ZW1wbGF0ZTtcclxuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKCk7XHJcblxyXG5cdFx0aWYgKG9yZGVyID09PSBudWxsICYmIGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGgpIHtcclxuXHRcdFx0Ly8gZm9yIHN0YWNrZWQgZGF0YSwgb3JkZXIgc2hvdWxkIGFsaWduZWQgd2l0aCB0aGUgdmlzdWFsbHkgZGlzcGxheWVkIGRhdGFcclxuXHRcdFx0Y29uc3QgaWRzID0gJCQub3JkZXJUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cylcclxuXHRcdFx0XHQubWFwKGkyID0+IGkyLmlkKVxyXG5cdFx0XHRcdC5yZXZlcnNlKCk7XHJcblxyXG5cdFx0XHRkLnNvcnQoKGEsIGIpID0+IHtcclxuXHRcdFx0XHRsZXQgdjEgPSBhID8gYS52YWx1ZSA6IG51bGw7XHJcblx0XHRcdFx0bGV0IHYyID0gYiA/IGIudmFsdWUgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRpZiAodjEgPiAwICYmIHYyID4gMCkge1xyXG5cdFx0XHRcdFx0djEgPSBhLmlkID8gaWRzLmluZGV4T2YoYS5pZCkgOiBudWxsO1xyXG5cdFx0XHRcdFx0djIgPSBiLmlkID8gaWRzLmluZGV4T2YoYi5pZCkgOiBudWxsO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHYxIC0gdjI7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmICgvXihhc2N8ZGVzYykkLy50ZXN0KG9yZGVyKSkge1xyXG5cdFx0XHRjb25zdCBpc0FzY2VuZGluZyA9IG9yZGVyID09PSBcImFzY1wiO1xyXG5cclxuXHRcdFx0ZC5zb3J0KChhLCBiKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdjEgPSBhID8gZ2V0Um93VmFsdWUoYSkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IHYyID0gYiA/IGdldFJvd1ZhbHVlKGIpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGlzQXNjZW5kaW5nID8gdjEgLSB2MiA6IHYyIC0gdjE7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKG9yZGVyKSkge1xyXG5cdFx0XHRkLnNvcnQob3JkZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRwbCA9ICQkLmdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUodHBsU3RyKTtcclxuXHRcdGNvbnN0IGxlbiA9IGQubGVuZ3RoO1xyXG5cdFx0bGV0IHRleHQ7XHJcblx0XHRsZXQgcm93O1xyXG5cdFx0bGV0IHBhcmFtO1xyXG5cdFx0bGV0IHZhbHVlO1xyXG5cdFx0bGV0IGk7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHJvdyA9IGRbaV07XHJcblxyXG5cdFx0XHRpZiAoIXJvdyB8fCAhKGdldFJvd1ZhbHVlKHJvdykgfHwgZ2V0Um93VmFsdWUocm93KSA9PT0gMCkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGlzVW5kZWZpbmVkKHRleHQpKSB7XHJcblx0XHRcdFx0Y29uc3QgdGl0bGUgPSBzYW5pdGlzZSh0aXRsZUZvcm1hdCA/IHRpdGxlRm9ybWF0KHJvdy54KSA6IHJvdy54KTtcclxuXHJcblx0XHRcdFx0dGV4dCA9IHRwbFByb2Nlc3ModHBsWzBdLCB7XHJcblx0XHRcdFx0XHRDTEFTU19UT09MVElQOiBDTEFTUy50b29sdGlwLFxyXG5cdFx0XHRcdFx0VElUTEU6IGlzVmFsdWUodGl0bGUpID8gKFxyXG5cdFx0XHRcdFx0XHR0cGxTdHIgPyB0aXRsZSA6IGA8dHI+PHRoIGNvbHNwYW49XCIyXCI+JHt0aXRsZX08L3RoPjwvdHI+YFxyXG5cdFx0XHRcdFx0KSA6IFwiXCJcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGFyYW0gPSBbcm93LnJhdGlvLCByb3cuaWQsIHJvdy5pbmRleCwgZF07XHJcblx0XHRcdHZhbHVlID0gc2FuaXRpc2UodmFsdWVGb3JtYXQoZ2V0Um93VmFsdWUocm93KSwgLi4ucGFyYW0pKTtcclxuXHJcblx0XHRcdGlmICgkJC5pc0FyZWFSYW5nZVR5cGUocm93KSkge1xyXG5cdFx0XHRcdGNvbnN0IFtoaWdoLCBsb3ddID0gW1wiaGlnaFwiLCBcImxvd1wiXS5tYXAodiA9PiBzYW5pdGlzZShcclxuXHRcdFx0XHRcdHZhbHVlRm9ybWF0KCQkLmdldEFyZWFSYW5nZURhdGEocm93LCB2KSwgLi4ucGFyYW0pXHJcblx0XHRcdFx0KSk7XHJcblxyXG5cdFx0XHRcdHZhbHVlID0gYDxiPk1pZDo8L2I+ICR7dmFsdWV9IDxiPkhpZ2g6PC9iPiAke2hpZ2h9IDxiPkxvdzo8L2I+ICR7bG93fWA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0Ly8gU2tpcCBlbGVtZW50cyB3aGVuIHRoZWlyIG5hbWUgaXMgc2V0IHRvIG51bGxcclxuXHRcdFx0XHRpZiAocm93Lm5hbWUgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgbmFtZSA9IHNhbml0aXNlKG5hbWVGb3JtYXQocm93Lm5hbWUsIC4uLnBhcmFtKSk7XHJcblx0XHRcdFx0Y29uc3QgY29sb3IgPSBnZXRCZ0NvbG9yKHJvdyk7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudFZhbHVlID0ge1xyXG5cdFx0XHRcdFx0Q0xBU1NfVE9PTFRJUF9OQU1FOiBDTEFTUy50b29sdGlwTmFtZSArICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHJvdy5pZCksXHJcblx0XHRcdFx0XHRDT0xPUjogKHRwbFN0ciB8fCAhJCQucGF0dGVybnMpID8gY29sb3IgOiBgPHN2Zz48cmVjdCBzdHlsZT1cImZpbGw6JHtjb2xvcn1cIiB3aWR0aD1cIjEwXCIgaGVpZ2h0PVwiMTBcIj48L3JlY3Q+PC9zdmc+YCxcclxuXHRcdFx0XHRcdE5BTUU6IG5hbWUsXHJcblx0XHRcdFx0XHRWQUxVRTogdmFsdWVcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRpZiAodHBsU3RyICYmIGlzT2JqZWN0KGNvbnRlbnRzLnRleHQpKSB7XHJcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IHRhcmdldElkcy5pbmRleE9mKHJvdy5pZCk7XHJcblxyXG5cdFx0XHRcdFx0T2JqZWN0LmtleXMoY29udGVudHMudGV4dCkuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb250ZW50VmFsdWVba2V5XSA9IGNvbnRlbnRzLnRleHRba2V5XVtpbmRleF07XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRleHQgKz0gdHBsUHJvY2Vzcyh0cGxbMV0sIGNvbnRlbnRWYWx1ZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYCR7dGV4dH08L3RhYmxlPmA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBjb250ZW50IHRlbXBsYXRlIHN0cmluZ1xyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0cGxTdHJcclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFRlbXBsYXRlIHN0cmluZ1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpIHtcclxuXHRcdHJldHVybiAodHBsU3RyIHx8IGA8dGFibGUgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVB9XCI+PHRib2R5PlxyXG5cdFx0XHRcdHs9VElUTEV9XHJcblx0XHRcdFx0e3s8dHIgY2xhc3M9XCJ7PUNMQVNTX1RPT0xUSVBfTkFNRX1cIj5cclxuXHRcdFx0XHRcdDx0ZCBjbGFzcz1cIm5hbWVcIj4ke3RoaXMucGF0dGVybnMgPyBgez1DT0xPUn1gIDogYDxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjp7PUNPTE9SfVwiPjwvc3Bhbj5gfXs9TkFNRX08L3RkPlxyXG5cdFx0XHRcdFx0PHRkIGNsYXNzPVwidmFsdWVcIj57PVZBTFVFfTwvdGQ+XHJcblx0XHRcdFx0PC90cj59fVxyXG5cdFx0XHQ8L3Rib2R5PjwvdGFibGU+YClcclxuXHRcdFx0LnJlcGxhY2UoLyhcXHI/XFxufFxcdCkvZywgXCJcIilcclxuXHRcdFx0LnNwbGl0KC97eyguKil9fS8pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFUb1Nob3cgZGF0YVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0V2lkdGggV2lkdGggdmFsdWUgb2YgdG9vbHRpcCBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRIZWlnaHQgSGVpZ2h0IHZhbHVlIG9mIHRvb2x0aXAgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSB0b3AsIGxlZnQgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHRvb2x0aXBQb3NpdGlvbihkYXRhVG9TaG93LCB0V2lkdGgsIHRIZWlnaHQsIGVsZW1lbnQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHQsIGN1cnJlbnRXaWR0aCwgY3VycmVudEhlaWdodCwgaXNMZWdlbmRSaWdodCwgaW5wdXRUeXBlfSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlO1xyXG5cdFx0Y29uc3Qgc3ZnTGVmdCA9ICQkLmdldFN2Z0xlZnQodHJ1ZSk7XHJcblx0XHRsZXQgW2xlZnQsIHRvcF0gPSBkM01vdXNlKGVsZW1lbnQpO1xyXG5cdFx0bGV0IGNoYXJ0UmlnaHQgPSBzdmdMZWZ0ICsgY3VycmVudFdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpO1xyXG5cclxuXHRcdHRvcCArPSAyMDtcclxuXHJcblx0XHQvLyBEZXRlcm1pbmUgdG9vbHRpcCBwb3NpdGlvblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRjb25zdCByYXcgPSBpbnB1dFR5cGUgPT09IFwidG91Y2hcIiB8fCAkJC5oYXNUeXBlKFwicmFkYXJcIik7XHJcblxyXG5cdFx0XHRpZiAoIXJhdykge1xyXG5cdFx0XHRcdHRvcCArPSBoYXNHYXVnZSA/IGhlaWdodCA6IGhlaWdodCAvIDI7XHJcblx0XHRcdFx0bGVmdCArPSAod2lkdGggLSAoaXNMZWdlbmRSaWdodCA/ICQkLmdldExlZ2VuZFdpZHRoKCkgOiAwKSkgLyAyO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCBkYXRhU2NhbGUgPSBzY2FsZS54KGRhdGFUb1Nob3dbMF0ueCk7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRcdHRvcCA9IGRhdGFTY2FsZSArIDIwO1xyXG5cdFx0XHRcdGxlZnQgKz0gc3ZnTGVmdCArIDEwMDtcclxuXHRcdFx0XHRjaGFydFJpZ2h0IC09IHN2Z0xlZnQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dG9wIC09IDU7XHJcblx0XHRcdFx0bGVmdCA9IHN2Z0xlZnQgKyAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQodHJ1ZSkgKyAyMCArIChzY2FsZS56b29tID8gbGVmdCA6IGRhdGFTY2FsZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByaWdodCA9IGxlZnQgKyB0V2lkdGg7XHJcblxyXG5cdFx0aWYgKHJpZ2h0ID4gY2hhcnRSaWdodCkge1xyXG5cdFx0XHQvLyAyMCBpcyBuZWVkZWQgZm9yIEZpcmVmb3ggdG8ga2VlcCB0b29sdGlwIHdpZHRoXHJcblx0XHRcdGxlZnQgLT0gcmlnaHQgLSBjaGFydFJpZ2h0ICsgMjA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRvcCArIHRIZWlnaHQgPiBjdXJyZW50SGVpZ2h0KSB7XHJcblx0XHRcdHRvcCAtPSBoYXNHYXVnZSA/IHRIZWlnaHQgKiAzIDogdEhlaWdodCArIDMwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0b3AgPCAwKSB7XHJcblx0XHRcdHRvcCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHt0b3AsIGxlZnR9O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgdGhlIHRvb2x0aXBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzZWxlY3RlZERhdGFcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcblx0ICovXHJcblx0c2hvd1Rvb2x0aXAoc2VsZWN0ZWREYXRhLCBlbGVtZW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHt0b29sdGlwfX0gPSAkJDtcclxuXHRcdGNvbnN0IHtiaW5kdG99ID0gY29uZmlnLnRvb2x0aXBfY29udGVudHM7XHJcblx0XHRjb25zdCBmb3JBcmMgPSAkJC5oYXNBcmNUeXBlKG51bGwsIFtcInJhZGFyXCJdKTtcclxuXHRcdGNvbnN0IGRhdGFUb1Nob3cgPSBzZWxlY3RlZERhdGEuZmlsdGVyKGQgPT4gZCAmJiBpc1ZhbHVlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cdFx0Y29uc3QgcG9zaXRpb25GdW5jdGlvbiA9IGNvbmZpZy50b29sdGlwX3Bvc2l0aW9uIHx8ICQkLnRvb2x0aXBQb3NpdGlvbjtcclxuXHJcblx0XHRpZiAoZGF0YVRvU2hvdy5sZW5ndGggPT09IDAgfHwgIWNvbmZpZy50b29sdGlwX3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRhdHVtID0gdG9vbHRpcC5kYXR1bSgpO1xyXG5cdFx0Y29uc3QgZGF0YVN0ciA9IEpTT04uc3RyaW5naWZ5KHNlbGVjdGVkRGF0YSk7XHJcblx0XHRsZXQgd2lkdGggPSAoZGF0dW0gJiYgZGF0dW0ud2lkdGgpIHx8IDA7XHJcblx0XHRsZXQgaGVpZ2h0ID0gKGRhdHVtICYmIGRhdHVtLmhlaWdodCkgfHwgMDtcclxuXHJcblx0XHRpZiAoIWRhdHVtIHx8IGRhdHVtLmN1cnJlbnQgIT09IGRhdGFTdHIpIHtcclxuXHRcdFx0Y29uc3QgaW5kZXggPSBzZWxlY3RlZERhdGEuY29uY2F0KCkuc29ydCgpWzBdLmluZGV4O1xyXG5cclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uc2hvdywgJCQsICQkLmFwaSwgc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHRcdC8vIHNldCB0b29sdGlwIGNvbnRlbnRcclxuXHRcdFx0dG9vbHRpcFxyXG5cdFx0XHRcdC5odG1sKCQkLmdldFRvb2x0aXBIVE1MKFxyXG5cdFx0XHRcdFx0c2VsZWN0ZWREYXRhLFxyXG5cdFx0XHRcdFx0JCQuYXhpcyAmJiAkJC5heGlzLmdldFhBeGlzVGlja0Zvcm1hdCgpLFxyXG5cdFx0XHRcdFx0JCQuZ2V0WUZvcm1hdChmb3JBcmMpLFxyXG5cdFx0XHRcdFx0JCQuY29sb3JcclxuXHRcdFx0XHQpKVxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgbnVsbClcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIG51bGwpIC8vIGZvciBJRTlcclxuXHRcdFx0XHQuZGF0dW0oe1xyXG5cdFx0XHRcdFx0aW5kZXgsXHJcblx0XHRcdFx0XHRjdXJyZW50OiBkYXRhU3RyLFxyXG5cdFx0XHRcdFx0d2lkdGg6IHdpZHRoID0gdG9vbHRpcC5wcm9wZXJ0eShcIm9mZnNldFdpZHRoXCIpLFxyXG5cdFx0XHRcdFx0aGVpZ2h0OiBoZWlnaHQgPSB0b29sdGlwLnByb3BlcnR5KFwib2Zmc2V0SGVpZ2h0XCIpXHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25zaG93biwgJCQsICQkLmFwaSwgc2VsZWN0ZWREYXRhKTtcclxuXHRcdFx0JCQuX2hhbmRsZUxpbmtlZENoYXJ0cyh0cnVlLCBpbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFiaW5kdG8pIHtcclxuXHRcdFx0Ly8gR2V0IHRvb2x0aXAgZGltZW5zaW9uc1xyXG5cdFx0XHRjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uRnVuY3Rpb24uY2FsbCh0aGlzLCBkYXRhVG9TaG93LCB3aWR0aCwgaGVpZ2h0LCBlbGVtZW50KTtcclxuXHJcblx0XHRcdC8vIFNldCB0b29sdGlwIHBvc2l0aW9uXHJcblx0XHRcdHRvb2x0aXBcclxuXHRcdFx0XHQuc3R5bGUoXCJ0b3BcIiwgYCR7cG9zaXRpb24udG9wfXB4YClcclxuXHRcdFx0XHQuc3R5bGUoXCJsZWZ0XCIsIGAke3Bvc2l0aW9uLmxlZnR9cHhgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIHRoZSB0b29sdGlwXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSBGb3JjZSB0byBoaWRlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoaWRlVG9vbHRpcChmb3JjZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7dG9vbHRpcH19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKHRvb2x0aXAuc3R5bGUoXCJkaXNwbGF5XCIpICE9PSBcIm5vbmVcIiAmJiAoIWNvbmZpZy50b29sdGlwX2RvTm90SGlkZSB8fCBmb3JjZSkpIHtcclxuXHRcdFx0Y29uc3Qgc2VsZWN0ZWREYXRhID0gSlNPTi5wYXJzZSh0b29sdGlwLmRhdHVtKCkuY3VycmVudCk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLnRvb2x0aXBfb25oaWRlLCAkJCwgJCQuYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cclxuXHRcdFx0Ly8gaGlkZSB0b29sdGlwXHJcblx0XHRcdHRvb2x0aXBcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIikgLy8gZm9yIElFOVxyXG5cdFx0XHRcdC5kYXR1bShudWxsKTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbmhpZGRlbiwgJCQsICQkLmFwaSwgc2VsZWN0ZWREYXRhKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGUgZGlzcGxheSBmb3IgbGlua2VkIGNoYXJ0IGluc3RhbmNlc1xyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdyB0cnVlOiBzaG93LCBmYWxzZTogaGlkZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCB4IEF4aXMgaW5kZXhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9oYW5kbGVMaW5rZWRDaGFydHMoc2hvdywgaW5kZXgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjaGFydHMsIGNvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoY29uZmlnLnRvb2x0aXBfbGlua2VkICYmIGNoYXJ0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdGNvbnN0IGxpbmtlZE5hbWUgPSBjb25maWcudG9vbHRpcF9saW5rZWRfbmFtZTtcclxuXHJcblx0XHRcdGNoYXJ0cy5mb3JFYWNoKGMgPT4ge1xyXG5cdFx0XHRcdGlmIChjICE9PSAkJC5hcGkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHtjb25maWd9ID0gYy5pbnRlcm5hbDtcclxuXHRcdFx0XHRcdGNvbnN0IGlzTGlua2VkID0gY29uZmlnLnRvb2x0aXBfbGlua2VkO1xyXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IGNvbmZpZy50b29sdGlwX2xpbmtlZF9uYW1lO1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNJbkRvbSA9IGRvY3VtZW50LmJvZHkuY29udGFpbnMoYy5lbGVtZW50KTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaXNMaW5rZWQgJiYgbGlua2VkTmFtZSA9PT0gbmFtZSAmJiBpc0luRG9tKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBjLmludGVybmFsLiRlbC50b29sdGlwLmRhdGEoKVswXTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgaXNOb3RTYW1lSW5kZXggPSBpbmRleCAhPT0gKGRhdGEgJiYgZGF0YS5pbmRleCk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IHRocm93aW5nIGVycm9yIGZvciBub24tcGFpcmVkIGxpbmtlZCBpbmRleGVzXHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHNob3cgJiYgaXNOb3RTYW1lSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5zaG93KHtpbmRleH0pO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIXNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5oaWRlKCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcblxyXG4vLyBkZWZpbmVkIGNoYXJ0IHR5cGVzIGFzIGNhdGVnb3J5XHJcbmV4cG9ydCBjb25zdCBUWVBFUyA9IHtcclxuXHRBcmVhOiBbXCJhcmVhXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiLCBcImFyZWEtc3RlcFwiXSxcclxuXHRBcmVhUmFuZ2U6IFtcImFyZWEtc3BsaW5lLXJhbmdlXCIsIFwiYXJlYS1saW5lLXJhbmdlXCJdLFxyXG5cdEFyYzogW1wicGllXCIsIFwiZG9udXRcIiwgXCJnYXVnZVwiLCBcInJhZGFyXCJdLFxyXG5cdExpbmU6IFtcImxpbmVcIiwgXCJzcGxpbmVcIiwgXCJhcmVhXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiLCBcInN0ZXBcIiwgXCJhcmVhLXN0ZXBcIl0sXHJcblx0U3RlcDogW1wic3RlcFwiLCBcImFyZWEtc3RlcFwiXSxcclxuXHRTcGxpbmU6IFtcInNwbGluZVwiLCBcImFyZWEtc3BsaW5lXCIsIFwiYXJlYS1zcGxpbmUtcmFuZ2VcIl1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzU3RyaW5nLCBpc0FycmF5fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IHtUWVBFU30gZnJvbSBcIi4uLy4uL2NvbmZpZy9jb25zdFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdHNldFRhcmdldFR5cGUodGFyZ2V0SWRzLCB0eXBlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3dpdGhvdXRGYWRlSW59fSA9ICQkO1xyXG5cclxuXHRcdCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdHdpdGhvdXRGYWRlSW5baWRdID0gKHR5cGUgPT09IGNvbmZpZy5kYXRhX3R5cGVzW2lkXSk7XHJcblx0XHRcdGNvbmZpZy5kYXRhX3R5cGVzW2lkXSA9IHR5cGU7XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZiAoIXRhcmdldElkcykge1xyXG5cdFx0XHRjb25maWcuZGF0YV90eXBlID0gdHlwZTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRoYXNUeXBlKHR5cGUsIHRhcmdldHNWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHR5cGVzID0gY29uZmlnLmRhdGFfdHlwZXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gdGFyZ2V0c1ZhbHVlIHx8ICQkLmRhdGEudGFyZ2V0cztcclxuXHRcdGxldCBoYXMgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAodGFyZ2V0cyAmJiB0YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godGFyZ2V0ID0+IHtcclxuXHRcdFx0XHRjb25zdCB0ID0gdHlwZXNbdGFyZ2V0LmlkXTtcclxuXHJcblx0XHRcdFx0aWYgKCh0ICYmIHQuaW5kZXhPZih0eXBlKSA+PSAwKSB8fCAoIXQgJiYgdHlwZSA9PT0gXCJsaW5lXCIpKSB7XHJcblx0XHRcdFx0XHRoYXMgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKE9iamVjdC5rZXlzKHR5cGVzKS5sZW5ndGgpIHtcclxuXHRcdFx0T2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRcdGlmICh0eXBlc1tpZF0gPT09IHR5cGUpIHtcclxuXHRcdFx0XHRcdGhhcyA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGhhcyA9IGNvbmZpZy5kYXRhX3R5cGUgPT09IHR5cGU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhhcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiBjb250YWlucyBnaXZlbiBjaGFydCB0eXBlc1xyXG5cdCAqIEBwYXJtYSB7U3RyaW5nfSB0eXBlIFR5cGUga2V5XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldHNcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBleGNsdWRlIEV4Y2x1ZGVkIHR5cGVzXHJcblx0ICogQHJldHVybiB7Ym9vbGVhbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhhc1R5cGVPZih0eXBlLCB0YXJnZXRzLCBleGNsdWRlID0gW10pIHtcclxuXHRcdHJldHVybiAhVFlQRVNbdHlwZV1cclxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHQuZmlsdGVyKHYgPT4gZXhjbHVkZS5pbmRleE9mKHYpID09PSAtMSlcclxuXHRcdFx0LmV2ZXJ5KHYgPT4gIXRoaXMuaGFzVHlwZSh2LCB0YXJnZXRzKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgZ2l2ZW4gZGF0YSBpcyBjZXJ0YWluIGNoYXJ0IHR5cGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0eXBlIGNoYXJ0IHR5cGVcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aXNUeXBlT2YoZCwgdHlwZSkge1xyXG5cdFx0Y29uc3QgaWQgPSBpc1N0cmluZyhkKSA/IGQgOiBkLmlkO1xyXG5cdFx0Y29uc3QgZGF0YVR5cGUgPSB0aGlzLmNvbmZpZy5kYXRhX3R5cGVzW2lkXTtcclxuXHJcblx0XHRyZXR1cm4gaXNBcnJheSh0eXBlKSA/XHJcblx0XHRcdHR5cGUuaW5kZXhPZihkYXRhVHlwZSkgPj0gMCA6IGRhdGFUeXBlID09PSB0eXBlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGlmIGNvbnRhaW5zIGFyYyB0eXBlcyBjaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xyXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYXNBcmNUeXBlKHRhcmdldHMsIGV4Y2x1ZGUpIHtcclxuXHRcdHJldHVybiB0aGlzLmhhc1R5cGVPZihcIkFyY1wiLCB0YXJnZXRzLCBleGNsdWRlKTtcclxuXHR9LFxyXG5cclxuXHRoYXNNdWx0aUFyY0dhdWdlKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzVHlwZShcImdhdWdlXCIpICYmIHRoaXMuY29uZmlnLmdhdWdlX3R5cGUgPT09IFwibXVsdGlcIjtcclxuXHR9LFxyXG5cclxuXHRpc0xpbmVUeXBlKGQpIHtcclxuXHRcdGNvbnN0IGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcclxuXHJcblx0XHRyZXR1cm4gIXRoaXMuY29uZmlnLmRhdGFfdHlwZXNbaWRdIHx8XHJcblx0XHRcdHRoaXMuaXNUeXBlT2YoaWQsIFRZUEVTLkxpbmUpO1xyXG5cdH0sXHJcblxyXG5cdGlzU3RlcFR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgVFlQRVMuU3RlcCk7XHJcblx0fSxcclxuXHJcblx0aXNTcGxpbmVUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLlNwbGluZSk7XHJcblx0fSxcclxuXHJcblx0aXNBcmVhVHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFUy5BcmVhKTtcclxuXHR9LFxyXG5cclxuXHRpc0FyZWFSYW5nZVR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgVFlQRVMuQXJlYVJhbmdlKTtcclxuXHR9LFxyXG5cclxuXHRpc0JhclR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJiYXJcIik7XHJcblx0fSxcclxuXHJcblx0aXNCdWJibGVUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYnViYmxlXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzU2NhdHRlclR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJzY2F0dGVyXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzUGllVHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcInBpZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc0dhdWdlVHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImdhdWdlXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzRG9udXRUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiZG9udXRcIik7XHJcblx0fSxcclxuXHJcblx0aXNSYWRhclR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJyYWRhclwiKTtcclxuXHR9LFxyXG5cclxuXHRpc0FyY1R5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNQaWVUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNEb251dFR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc0dhdWdlVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzUmFkYXJUeXBlKGQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRldGVybWluZSBpZiBpcyAnY2lyY2xlJyBkYXRhIHBvaW50XHJcblx0aXNDaXJjbGVQb2ludCgpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IHBhdHRlcm4gPSBjb25maWcucG9pbnRfcGF0dGVybjtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLnBvaW50X3R5cGUgPT09IFwiY2lyY2xlXCIgJiZcclxuXHRcdFx0KCFwYXR0ZXJuIHx8IChpc0FycmF5KHBhdHRlcm4pICYmIHBhdHRlcm4ubGVuZ3RoID09PSAwKSk7XHJcblx0fSxcclxuXHJcblx0bGluZURhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNMaW5lVHlwZShkKSA/IFtkXSA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdGFyY0RhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNBcmNUeXBlKGQuZGF0YSkgPyBbZF0gOiBbXTtcclxuXHR9LFxyXG5cclxuXHRiYXJEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSA/IGQudmFsdWVzIDogW107XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgYWRhcHQgZm9yIGRhdGEgbGFiZWwgc2hvd2luZ1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRsYWJlbGlzaERhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNMaW5lVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzU2NhdHRlclR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc0J1YmJsZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1JhZGFyVHlwZShkKSA/IGQudmFsdWVzIDogW107XHJcblx0fSxcclxuXHJcblx0YmFyTGluZUJ1YmJsZURhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNCYXJUeXBlKGQpIHx8IHRoaXMuaXNMaW5lVHlwZShkKSB8fCB0aGlzLmlzQnViYmxlVHlwZShkKSA/XHJcblx0XHRcdGQudmFsdWVzIDogW107XHJcblx0fSxcclxuXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNoYXBlI2N1cnZlc1xyXG5cdGlzSW50ZXJwb2xhdGlvblR5cGUodHlwZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcImJhc2lzXCIsXHJcblx0XHRcdFwiYmFzaXMtY2xvc2VkXCIsXHJcblx0XHRcdFwiYmFzaXMtb3BlblwiLFxyXG5cdFx0XHRcImJ1bmRsZVwiLFxyXG5cdFx0XHRcImNhcmRpbmFsXCIsXHJcblx0XHRcdFwiY2FyZGluYWwtY2xvc2VkXCIsXHJcblx0XHRcdFwiY2FyZGluYWwtb3BlblwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tXCIsXHJcblx0XHRcdFwiY2F0bXVsbC1yb20tY2xvc2VkXCIsXHJcblx0XHRcdFwiY2F0bXVsbC1yb20tb3BlblwiLFxyXG5cdFx0XHRcImxpbmVhclwiLFxyXG5cdFx0XHRcImxpbmVhci1jbG9zZWRcIixcclxuXHRcdFx0XCJtb25vdG9uZS14XCIsXHJcblx0XHRcdFwibW9ub3RvbmUteVwiLFxyXG5cdFx0XHRcIm5hdHVyYWxcIlxyXG5cdFx0XS5pbmRleE9mKHR5cGUpID49IDA7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNWYWx1ZSwgaXNEZWZpbmVkLCBpc09iamVjdFR5cGV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgbWluL21heCB2YWx1ZVxyXG4gKiBAcGFyYW0ge0NoYXJ0fSAkJFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcclxuICogQHJldHVybiB7dW5kZWZpbmVkfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2V0TWluTWF4KCQkLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIiwgdmFsdWUpIHtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdGNvbnN0IGF4aXNYID0gYGF4aXNfeF8ke3R5cGV9YDtcclxuXHRjb25zdCBheGlzWSA9IGBheGlzX3lfJHt0eXBlfWA7XHJcblx0Y29uc3QgYXhpc1kyID0gYGF4aXNfeTJfJHt0eXBlfWA7XHJcblxyXG5cdGlmIChpc0RlZmluZWQodmFsdWUpKSB7XHJcblx0XHRpZiAoaXNPYmplY3RUeXBlKHZhbHVlKSkge1xyXG5cdFx0XHRpc1ZhbHVlKHZhbHVlLngpICYmIChjb25maWdbYXhpc1hdID0gdmFsdWUueCk7XHJcblx0XHRcdGlzVmFsdWUodmFsdWUueSkgJiYgKGNvbmZpZ1theGlzWV0gPSB2YWx1ZS55KTtcclxuXHRcdFx0aXNWYWx1ZSh2YWx1ZS55MikgJiYgKGNvbmZpZ1theGlzWTJdID0gdmFsdWUueTIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uZmlnW2F4aXNZXSA9IHZhbHVlO1xyXG5cdFx0XHRjb25maWdbYXhpc1kyXSA9IHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBtaW4vbWF4IHZhbHVlXHJcbiAqIEBwYXJhbSB7Q2hhcnR9ICQkXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAqIEByZXR1cm4ge3t4LCB5LCB5Mn19XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNaW5NYXgoJCQsIHR5cGU6IFwibWluXCIgfCBcIm1heFwiKToge3g6IG51bWJlciwgeTogbnVtYmVyLCB5MjogbnVtYmVyfSB7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdHg6IGNvbmZpZ1tgYXhpc194XyR7dHlwZX1gXSxcclxuXHRcdHk6IGNvbmZpZ1tgYXhpc195XyR7dHlwZX1gXSxcclxuXHRcdHkyOiBjb25maWdbYGF4aXNfeTJfJHt0eXBlfWBdXHJcblx0fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERlZmluZSBheGlzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNvbnN0IGF4aXMgPSB7XHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhpcyBsYWJlbHMuXHJcblx0ICogQG1ldGhvZCBheGlz4oCkbGFiZWxzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGxhYmVscyBzcGVjaWZpZWQgYXhpcycgbGFiZWwgdG8gYmUgdXBkYXRlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMubGFiZWxzKHtcclxuXHQgKiAgIHg6IFwiTmV3IFggQXhpcyBMYWJlbFwiLFxyXG5cdCAqICAgeTogXCJOZXcgWSBBeGlzIExhYmVsXCJcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRsYWJlbHM6IGZ1bmN0aW9uKGxhYmVsczoge3g/OiBzdHJpbmcsIHk/OiBzdHJpbmcsIHkyPzogc3RyaW5nfSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGxhYmVscykuZm9yRWFjaChheGlzSWQgPT4ge1xyXG5cdFx0XHRcdCQkLmF4aXMuc2V0TGFiZWxUZXh0KGF4aXNJZCwgbGFiZWxzW2F4aXNJZF0pO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmF4aXMudXBkYXRlTGFiZWxzKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhpcyBtaW4gdmFsdWUuXHJcblx0ICogQG1ldGhvZCBheGlz4oCkbWluXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG1pbiBJZiBtaW4gaXMgZ2l2ZW4sIHNwZWNpZmllZCBheGlzJyBtaW4gdmFsdWUgd2lsbCBiZSB1cGRhdGVkLjxicj5cclxuXHQgKiAgICAgSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBtaW4gdmFsdWVzIHNldCBvbiBnZW5lcmF0aW5nIG9wdGlvbiBmb3IgZWFjaCBheGlzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogICAgIElmIG5vdCBzZXQgYW55IG1pbiB2YWx1ZXMgb24gZ2VuZXJhdGlvbiwgaXQgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbWluXHJcblx0ICogY2hhcnQuYXhpcy5taW4oe1xyXG5cdCAqICAgeDogLTEwLFxyXG5cdCAqICAgeTogMTAwMCxcclxuXHQgKiAgIHkyOiAxMDBcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRtaW46IGZ1bmN0aW9uKG1pbj86IG51bWJlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdHJldHVybiBpc1ZhbHVlKG1pbikgP1xyXG5cdFx0XHRzZXRNaW5NYXgoJCQsIFwibWluXCIsIG1pbikgOlxyXG5cdFx0XHRnZXRNaW5NYXgoJCQsIFwibWluXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWF4IHZhbHVlLlxyXG5cdCAqIEBtZXRob2QgYXhpc+KApG1heFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtYXggSWYgbWF4IGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWF4IHZhbHVlIHdpbGwgYmUgdXBkYXRlZC48YnI+XHJcblx0ICogICAgIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbWF4IHZhbHVlcyBzZXQgb24gZ2VuZXJhdGluZyBvcHRpb24gZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICAgICBJZiBub3Qgc2V0IGFueSBtYXggdmFsdWVzIG9uIGdlbmVyYXRpb24sIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gVXBkYXRlIGF4aXMnIGxhYmVsXHJcblx0ICogY2hhcnQuYXhpcy5tYXgoe1xyXG5cdCAqICAgIHg6IDEwMCxcclxuXHQgKiAgICB5OiAxMDAwLFxyXG5cdCAqICAgIHkyOiAxMDAwMFxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdG1heDogZnVuY3Rpb24obWF4PzogbnVtYmVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggP1xyXG5cdFx0XHRzZXRNaW5NYXgoJCQsIFwibWF4XCIsIG1heCkgOlxyXG5cdFx0XHRnZXRNaW5NYXgoJCQsIFwibWF4XCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWluIGFuZCBtYXggdmFsdWUuXHJcblx0ICogQG1ldGhvZCBheGlz4oCkcmFuZ2VcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcmFuZ2UgSWYgcmFuZ2UgaXMgZ2l2ZW4sIHNwZWNpZmllZCBheGlzJyBtaW4gYW5kIG1heCB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgY3VycmVudCBtaW4gYW5kIG1heCB2YWx1ZXMgZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gVXBkYXRlIGF4aXMnIGxhYmVsXHJcblx0ICogY2hhcnQuYXhpcy5yYW5nZSh7XHJcblx0ICogICBtaW46IHtcclxuXHQgKiAgICAgeDogLTEwLFxyXG5cdCAqICAgICB5OiAtMTAwMCxcclxuXHQgKiAgICAgeTI6IC0xMDAwMFxyXG5cdCAqICAgfSxcclxuXHQgKiAgIG1heDoge1xyXG5cdCAqICAgICB4OiAxMDAsXHJcblx0ICogICAgIHk6IDEwMDAsXHJcblx0ICogICAgIHkyOiAxMDAwMFxyXG5cdCAqICAgfSxcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRyYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcclxuXHRcdGNvbnN0IHtheGlzfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0aXNEZWZpbmVkKHJhbmdlLm1heCkgJiYgYXhpcy5tYXgocmFuZ2UubWF4KTtcclxuXHRcdFx0aXNEZWZpbmVkKHJhbmdlLm1pbikgJiYgYXhpcy5taW4ocmFuZ2UubWluKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0bWF4OiBheGlzLm1heCgpLFxyXG5cdFx0XHRcdG1pbjogYXhpcy5taW4oKVxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0fVxyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2F4aXN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTZXQgc3BlY2lmaWVkIGNhdGVnb3J5IG5hbWUgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBAbWV0aG9kIGNhdGVnb3J5XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGkgaW5kZXggb2YgY2F0ZWdvcnkgdG8gYmUgY2hhbmdlZFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjYXRlZ29yeSBjYXRlZ29yeSB2YWx1ZSB0byBiZSBjaGFuZ2VkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5jYXRlZ29yeSgyLCBcIkNhdGVnb3J5IDNcIik7XHJcblx0ICovXHJcblx0Y2F0ZWdvcnkoaTogbnVtYmVyLCBjYXRlZ29yeTogc3RyaW5nKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV0gPSBjYXRlZ29yeTtcclxuXHRcdFx0JCQucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllc1tpXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgY2F0ZWdvcnkgbmFtZXMgb24gY2F0ZWdvcnkgYXhpcy5cclxuXHQgKiBAbWV0aG9kIGNhdGVnb3JpZXNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBjYXRlZ29yaWVzIFRoaXMgbXVzdCBiZSBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGNhdGVnb3J5IG5hbWVzIGluIHN0cmluZy4gSWYgY2F0ZWdvcnkgbmFtZXMgYXJlIGluY2x1ZGVkIGluIHRoZSBkYXRlIGJ5IGRhdGEueCBvcHRpb24sIHRoaXMgaXMgbm90IHJlcXVpcmVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY2F0ZWdvcmllcyhbXHJcblx0ICogICAgICBcIkNhdGVnb3J5IDFcIiwgXCJDYXRlZ29yeSAyXCIsIC4uLlxyXG5cdCAqIF0pO1xyXG5cdCAqL1xyXG5cdGNhdGVnb3JpZXMoY2F0ZWdvcmllczogc3RyaW5nW10pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gY2F0ZWdvcmllcztcclxuXHRcdCQkLnJlZHJhdygpO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNEZWZpbmVkLCBpc1ZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBGbG93IGRhdGEgdG8gdGhlIGNoYXJ0Ljxicj48YnI+XHJcblx0ICogQnkgdGhpcyBBUEksIHlvdSBjYW4gYXBwZW5kIG5ldyBkYXRhIHBvaW50cyB0byB0aGUgY2hhcnQuXHJcblx0ICogQG1ldGhvZCBmbG93XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCBqc29uIHwgT2JqZWN0IHwgRGF0YSBhcyBKU09OIGZvcm1hdCAoQHNlZSBbZGF0YeKApGpzb25dKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGpzb24pKSB8XHJcblx0ICogICAgfCByb3dzIHwgQXJyYXkgfCBEYXRhIGluIGFycmF5IGFzIHJvdyBmb3JtYXQgKEBzZWUgW2RhdGHigKRyb3dzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxyXG5cdCAqICAgIHwgY29sdW1ucyB8IEFycmF5IHwgRGF0YSBpbiBhcnJheSBhcyBjb2x1bW4gZm9ybWF0IChAc2VlIFtkYXRh4oCkY29sdW1uc10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0Y29sdW1ucykpIHxcclxuXHQgKiAgICB8IHRvIHwgU3RyaW5nIHwgVGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgdG8gdGhhdCBwb2ludC4gSWYgbm90IGdpdmVuLCB0aGUgbG93ZXIgeCBlZGdlIHdpbGwgbW92ZSBieSB0aGUgbnVtYmVyIG9mIGdpdmVuIGRhdGEgcG9pbnRzIHxcclxuXHQgKiAgICB8IGxlbmd0aCB8IE51bWJlciB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIGJ5IHRoZSBudW1iZXIgb2YgdGhpcyBhcmd1bWVudCB8XHJcblx0ICogICAgfCBkdXJhdGlvbiB8IE51bWJlciB8IFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiB3aWxsIGJlIHNwZWNpZmllZCB2YWx1ZS4gSWYgbm90IGdpdmVuLCB0cmFuc2l0aW9uLmR1cmF0aW9uIHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHxcclxuXHQgKiAgICB8IGRvbmUgfCBGdW5jdGlvbiB8IFRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBmbG93IGVuZHMgfFxyXG5cdCAqXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gSWYganNvbiwgcm93cyBhbmQgY29sdW1ucyBnaXZlbiwgdGhlIGRhdGEgd2lsbCBiZSBsb2FkZWQuXHJcblx0ICogICAtIElmIGRhdGEgdGhhdCBoYXMgdGhlIHNhbWUgdGFyZ2V0IGlkIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSBhcHBlbmRlZC5cclxuXHQgKiAgIC0gT3RoZXJ3aXNlLCBuZXcgdGFyZ2V0IHdpbGwgYmUgYWRkZWQuIE9uZSBvZiB0aGVzZSBpcyByZXF1aXJlZCB3aGVuIGNhbGxpbmcuXHJcblx0ICogICAtIElmIGpzb24gc3BlY2lmaWVkLCBrZXlzIGlzIHJlcXVpcmVkIGFzIHdlbGwgYXMgZGF0YS5qc29uLlxyXG5cdCAqIFx0IC0gSWYgdGFiIGlzbid0IHZpc2libGUoYnkgZXZhbHVhdGluZyBgZG9jdW1lbnQuaGlkZGVuYCksIHdpbGwgbm90IGJlIGV4ZWN1dGVkIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnkgd29yay5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIDIgZGF0YSBwb2ludHMgd2lsbCBiZSBhcHByZW5kZWQgdG8gdGhlIHRhaWwgYW5kIHBvcHBlZCBmcm9tIHRoZSBoZWFkLlxyXG5cdCAqIC8vIEFmdGVyIHRoYXQsIDQgZGF0YSBwb2ludHMgd2lsbCBiZSBhcHBlbmRlZCBhbmQgbm8gZGF0YSBwb2ludHMgd2lsbCBiZSBwb3Bwb2VkLlxyXG5cdCAqIGNoYXJ0LmZsb3coe1xyXG5cdCAqICBjb2x1bW5zOiBbXHJcblx0ICogICAgW1wieFwiLCBcIjIwMTgtMDEtMTFcIiwgXCIyMDE4LTAxLTIxXCJdLFxyXG5cdCAqICAgIFtcImRhdGExXCIsIDUwMCwgMjAwXSxcclxuXHQgKiAgICBbXCJkYXRhMlwiLCAxMDAsIDMwMF0sXHJcblx0ICogICAgW1wiZGF0YTNcIiwgMjAwLCAxMjBdXHJcblx0ICogIF0sXHJcblx0ICogIHRvOiBcIjIwMTMtMDEtMTFcIixcclxuXHQgKiAgZG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdCAqICAgIGNoYXJ0LmZsb3coe1xyXG5cdCAqICAgICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgICBbXCJ4XCIsIFwiMjAxOC0wMi0xMVwiLCBcIjIwMTgtMDItMTJcIiwgXCIyMDE4LTAyLTEzXCIsIFwiMjAxOC0wMi0xNFwiXSxcclxuXHQgKiAgICAgICAgW1wiZGF0YTFcIiwgMjAwLCAzMDAsIDEwMCwgMjUwXSxcclxuXHQgKiAgICAgICAgW1wiZGF0YTJcIiwgMTAwLCA5MCwgNDAsIDEyMF0sXHJcblx0ICogICAgICAgIFtcImRhdGEzXCIsIDEwMCwgMTAwLCAzMDAsIDUwMF1cclxuXHQgKiAgICAgIF0sXHJcblx0ICogICAgICBsZW5ndGg6IDIsXHJcbiAgICAgKiAgICAgIGR1cmF0aW9uOiAxNTAwXHJcblx0ICogICAgfSk7XHJcblx0ICogIH1cclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRmbG93KGFyZ3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGxldCBkYXRhO1xyXG5cdFx0bGV0IGRvbWFpbjtcclxuXHRcdGxldCBsZW5ndGg6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgdGFpbCA9IDA7XHJcblx0XHRsZXQgZGlmZjtcclxuXHRcdGxldCB0bztcclxuXHJcblx0XHRpZiAoYXJncy5qc29uIHx8IGFyZ3Mucm93cyB8fCBhcmdzLmNvbHVtbnMpIHtcclxuXHRcdFx0ZGF0YSA9ICQkLmNvbnZlcnREYXRhKGFyZ3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZGF0YSB8fCAhJCQuaXNUYWJWaXNpYmxlKCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG5vdGZvdW5kSWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0Y29uc3Qgb3JnRGF0YUNvdW50ID0gJCQuZ2V0TWF4RGF0YUNvdW50KCk7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgdHJ1ZSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlL0FkZCBkYXRhXHJcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xyXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXSkge1xyXG5cdFx0XHRcdFx0XHR0YWlsID0gdC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0uaW5kZXggKyAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxlbmd0aCA9IHRhcmdldHNbaV0udmFsdWVzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHRhcmdldHNbaV0udmFsdWVzW2pdLmluZGV4ID0gdGFpbCArIGo7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoISQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGFyZ2V0c1tpXS52YWx1ZXNbal0ueCA9IHRhaWwgKyBqO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dC52YWx1ZXMgPSB0LnZhbHVlcy5jb25jYXQodGFyZ2V0c1tpXS52YWx1ZXMpO1xyXG5cdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCFmb3VuZCAmJiBub3Rmb3VuZElkcy5wdXNoKHQuaWQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gQXBwZW5kIG51bGwgZm9yIG5vdCBmb3VuZCB0YXJnZXRzXHJcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBub3Rmb3VuZElkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmICh0LmlkID09PSBub3Rmb3VuZElkc1tpXSkge1xyXG5cdFx0XHRcdFx0dGFpbCA9IHQudmFsdWVzW3QudmFsdWVzLmxlbmd0aCAtIDFdLmluZGV4ICsgMTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHQudmFsdWVzLnB1c2goe1xyXG5cdFx0XHRcdFx0XHRcdGlkOiB0LmlkLFxyXG5cdFx0XHRcdFx0XHRcdGluZGV4OiB0YWlsICsgaixcclxuXHRcdFx0XHRcdFx0XHR4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WCh0YWlsICsgaikgOiB0YWlsICsgaixcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEdlbmVyYXRlIG51bGwgdmFsdWVzIGZvciBuZXcgdGFyZ2V0XHJcblx0XHRpZiAoJCQuZGF0YS50YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbWlzc2luZzogYW55W10gPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9ICQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXNbMF0uaW5kZXg7IGkgPCB0YWlsOyBpKyspIHtcclxuXHRcdFx0XHRcdG1pc3NpbmcucHVzaCh7XHJcblx0XHRcdFx0XHRcdGlkOiB0LmlkLFxyXG5cdFx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdFx0eDogJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5nZXRPdGhlclRhcmdldFgoaSkgOiBpLFxyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0di5pbmRleCArPSB0YWlsO1xyXG5cclxuXHRcdFx0XHRcdGlmICghJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0XHRcdFx0di54ICs9IHRhaWw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHQudmFsdWVzID0gbWlzc2luZy5jb25jYXQodC52YWx1ZXMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuY29uY2F0KHRhcmdldHMpOyAvLyBhZGQgcmVtYWluZWRcclxuXHJcblx0XHQvLyBjaGVjayBkYXRhIGNvdW50IGJlY2F1c2UgYmVoYXZpb3IgbmVlZHMgdG8gY2hhbmdlIHdoZW4gaXRcInMgb25seSBvbmVcclxuXHRcdC8vIGNvbnN0IGRhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xyXG5cdFx0Y29uc3QgYmFzZVRhcmdldCA9ICQkLmRhdGEudGFyZ2V0c1swXTtcclxuXHRcdGNvbnN0IGJhc2VWYWx1ZSA9IGJhc2VUYXJnZXQudmFsdWVzWzBdO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBsZW5ndGggdG8gZmxvdyBpZiBuZWVkZWRcclxuXHRcdGlmIChpc0RlZmluZWQoYXJncy50bykpIHtcclxuXHRcdFx0bGVuZ3RoID0gMDtcclxuXHRcdFx0dG8gPSAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShhcmdzLnRvKSA6IGFyZ3MudG87XHJcblxyXG5cdFx0XHRiYXNlVGFyZ2V0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdHYueCA8IHRvICYmIGxlbmd0aCsrO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKGFyZ3MubGVuZ3RoKSkge1xyXG5cdFx0XHRsZW5ndGggPSBhcmdzLmxlbmd0aDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiBvbmx5IG9uZSBkYXRhLCB1cGRhdGUgdGhlIGRvbWFpbiB0byBmbG93IGZyb20gbGVmdCBlZGdlIG9mIHRoZSBjaGFydFxyXG5cdFx0aWYgKCFvcmdEYXRhQ291bnQpIHtcclxuXHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdFx0ZGlmZiA9IGJhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCA+IDEgP1xyXG5cdFx0XHRcdFx0YmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54IDpcclxuXHRcdFx0XHRcdGJhc2VWYWx1ZS54IC0gJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpWzBdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRpZmYgPSAxO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkb21haW4gPSBbYmFzZVZhbHVlLnggLSBkaWZmLCBiYXNlVmFsdWUueF07XHJcblx0XHR9IGVsc2UgaWYgKG9yZ0RhdGFDb3VudCA9PT0gMSAmJiAkJC5pc1RpbWVTZXJpZXMoKSkge1xyXG5cdFx0XHRkaWZmID0gKGJhc2VUYXJnZXQudmFsdWVzW2Jhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCAtIDFdLnggLSBiYXNlVmFsdWUueCkgLyAyO1xyXG5cdFx0XHRkb21haW4gPSBbbmV3IERhdGUoK2Jhc2VWYWx1ZS54IC0gZGlmZiksIG5ldyBEYXRlKCtiYXNlVmFsdWUueCArIGRpZmYpXTtcclxuXHRcdH1cclxuXHJcblx0XHRkb21haW4gJiYgJCQudXBkYXRlWERvbWFpbihudWxsLCB0cnVlLCB0cnVlLCBmYWxzZSwgZG9tYWluKTtcclxuXHJcblx0XHQvLyBTZXQgdGFyZ2V0c1xyXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdC8vIFJlZHJhdyB3aXRoIG5ldyB0YXJnZXRzXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRmbG93OiB7XHJcblx0XHRcdFx0aW5kZXg6IGJhc2VWYWx1ZS5pbmRleCxcclxuXHRcdFx0XHRsZW5ndGg6IGxlbmd0aCxcclxuXHRcdFx0XHRkdXJhdGlvbjogaXNWYWx1ZShhcmdzLmR1cmF0aW9uKSA/IGFyZ3MuZHVyYXRpb24gOiAkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbixcclxuXHRcdFx0XHRkb25lOiBhcmdzLmRvbmUsXHJcblx0XHRcdFx0b3JnRGF0YUNvdW50OiBvcmdEYXRhQ291bnQsXHJcblx0XHRcdH0sXHJcblx0XHRcdHdpdGhMZWdlbmQ6IHRydWUsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBvcmdEYXRhQ291bnQgPiAxLFxyXG5cdFx0XHR3aXRoVHJpbVhEb21haW46IGZhbHNlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWEF4aXM6IHRydWVcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2V4dGVuZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogVXBkYXRlIHggZ3JpZCBsaW5lcy5cclxuICogQG1ldGhvZCB4Z3JpZHNcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge0FycmF5fSBncmlkcyBYIGdyaWQgbGluZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoaXMgYXJndW1lbnQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLngubGluZXMuXHJcbiAqIEBleGFtcGxlXHJcbiAqICAvLyBTaG93IDIgeCBncmlkIGxpbmVzXHJcbiAqIGNoYXJ0LnhncmlkcyhbXHJcbiAqICAgIHt2YWx1ZTogMSwgdGV4dDogXCJMYWJlbCAxXCJ9LFxyXG4gKiAgICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG4gKiBdKTtcclxuICovXHJcbmZ1bmN0aW9uIHhncmlkcyhncmlkczoge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdKSB7XHJcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdGlmICghZ3JpZHMpIHtcclxuXHRcdHJldHVybiBjb25maWcuZ3JpZF94X2xpbmVzO1xyXG5cdH1cclxuXHJcblx0Y29uZmlnLmdyaWRfeF9saW5lcyA9IGdyaWRzO1xyXG5cdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XHJcblxyXG5cdHJldHVybiBjb25maWcuZ3JpZF94X2xpbmVzO1xyXG59XHJcblxyXG5leHRlbmQoeGdyaWRzLCB7XHJcblx0LyoqXHJcblx0ICogQWRkIHggZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgYWRkcyBuZXcgeCBncmlkIGxpbmVzIGluc3RlYWQgb2YgcmVwbGFjaW5nIGxpa2UgeGdyaWRzLlxyXG5cdCAqIEBtZXRob2QgeGdyaWRz4oCkYWRkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGdyaWRzIE5ldyB4IGdyaWQgbGluZXMgd2lsbCBiZSBhZGRlZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueC5saW5lcyBhbmQgaXQncyBwb3NzaWJsZSB0byBnaXZlIGFuIE9iamVjdCBpZiBvbmx5IG9uZSBsaW5lIHdpbGwgYmUgYWRkZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gQWRkIGEgbmV3IHggZ3JpZCBsaW5lXHJcblx0ICogY2hhcnQueGdyaWRzLmFkZChcclxuXHQgKiAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcblx0ICogKTtcclxuXHQgKlxyXG5cdCAqIC8vIEFkZCBuZXcgeCBncmlkIGxpbmVzXHJcblx0ICogY2hhcnQueGdyaWRzLmFkZChbXHJcblx0ICogICB7dmFsdWU6IDIsIHRleHQ6IFwiTGFiZWwgMlwifSxcclxuXHQgKiAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcblx0ICogXSk7XHJcblx0ICovXHJcblx0YWRkOiBmdW5jdGlvbihncmlkczoge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdKSB7XHJcblx0XHRyZXR1cm4gdGhpcy54Z3JpZHMoXHJcblx0XHRcdHRoaXMuaW50ZXJuYWwuY29uZmlnLmdyaWRfeF9saW5lc1xyXG5cdFx0XHRcdC5jb25jYXQoZ3JpZHMgfHwgW10pXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSB4IGdyaWQgbGluZXMuPGJyPlxyXG5cdCAqIFRoaXMgQVBJIHJlbW92ZXMgeCBncmlkIGxpbmVzLlxyXG5cdCAqIEBtZXRob2QgeGdyaWRz4oCkcmVtb3ZlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyBUaGlzIGFyZ3VtZW50IHNob3VsZCBpbmNsdWRlIHZhbHVlIG9yIGNsYXNzLiBJZiB2YWx1ZSBpcyBnaXZlbiwgdGhlIHggZ3JpZCBsaW5lcyB0aGF0IGhhdmUgc3BlY2lmaWVkIHggdmFsdWUgd2lsbCBiZSByZW1vdmVkLiBJZiBjbGFzcyBpcyBnaXZlbiwgdGhlIHggZ3JpZCBsaW5lcyB0aGF0IGhhdmUgc3BlY2lmaWVkIGNsYXNzIHdpbGwgYmUgcmVtb3ZlZC4gSWYgYXJncyBpcyBub3QgZ2l2ZW4sIGFsbCBvZiB4IGdyaWQgbGluZXMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8geCBncmlkIGxpbmUgb24geCA9IDIgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueGdyaWRzLnJlbW92ZSh7dmFsdWU6IDJ9KTtcclxuXHQgKlxyXG5cdCAqIC8vIHggZ3JpZCBsaW5lcyB0aGF0IGhhdmUgJ2dyaWQtQScgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueGdyaWRzLnJlbW92ZSh7XHJcblx0ICogICBjbGFzczogXCJncmlkLUFcIlxyXG5cdCAqIH0pO1xyXG5cdCAqXHJcblx0ICogLy8gYWxsIG9mIHggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC54Z3JpZHMucmVtb3ZlKCk7XHJcblx0ICovXHJcblx0cmVtb3ZlOiBmdW5jdGlvbihwYXJhbXM/OiB7dmFsdWU/OiBudW1iZXIsIGNsYXNzPzogc3RyaW5nfSkgeyAvLyBUT0RPOiBtdWx0aXBsZVxyXG5cdFx0dGhpcy5pbnRlcm5hbC5yZW1vdmVHcmlkTGluZXMocGFyYW1zLCB0cnVlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3hncmlkc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtleHRlbmR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB5IGdyaWQgbGluZXMuXHJcbiAqIEBtZXRob2QgeWdyaWRzXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtBcnJheX0gZ3JpZHMgWSBncmlkIGxpbmVzIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGlzIGFyZ3VtZW50LiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC55LmxpbmVzLlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgLy8gU2hvdyAyIHkgZ3JpZCBsaW5lc1xyXG4gKiBjaGFydC55Z3JpZHMoW1xyXG4gKiAgICB7dmFsdWU6IDEwMCwgdGV4dDogXCJMYWJlbCAxXCJ9LFxyXG4gKiAgICB7dmFsdWU6IDQwMCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcbiAqIF0pO1xyXG4gKi9cclxuZnVuY3Rpb24geWdyaWRzKGdyaWRzOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10pIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0aWYgKCFncmlkcykge1xyXG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XHJcblx0fVxyXG5cclxuXHRjb25maWcuZ3JpZF95X2xpbmVzID0gZ3JpZHM7aHR0cDovL2ppbmRvLmNvbS9naXQvYmlsbGJvYXJkLmpzL2RlbW8vd29yay9jaGFydC5odG1sXHJcblx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcclxuXHJcblx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XHJcbn1cclxuXHJcbmV4dGVuZCh5Z3JpZHMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgeSBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSBhZGRzIG5ldyB5IGdyaWQgbGluZXMgaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSB5Z3JpZHMuXHJcblx0ICogQG1ldGhvZCB5Z3JpZHPigKRhZGRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gZ3JpZHMgTmV3IHkgZ3JpZCBsaW5lcyB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC55LmxpbmVzIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIGxpbmUgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBBZGQgYSBuZXcgeCBncmlkIGxpbmVcclxuXHQgKiBjaGFydC55Z3JpZHMuYWRkKFxyXG5cdCAqICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqICk7XHJcblx0ICpcclxuXHQgKiAvLyBBZGQgbmV3IHggZ3JpZCBsaW5lc1xyXG5cdCAqIGNoYXJ0Lnlncmlkcy5hZGQoW1xyXG5cdCAqICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgMlwifSxcclxuXHQgKiAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuXHQgKiBdKTtcclxuXHQgKi9cclxuXHRhZGQ6IGZ1bmN0aW9uKGdyaWRzOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10pIHtcclxuXHRcdHJldHVybiB0aGlzLnlncmlkcyhcclxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF95X2xpbmVzXHJcblx0XHRcdFx0LmNvbmNhdChncmlkcyB8fCBbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHkgZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyB4IGdyaWQgbGluZXMuXHJcblx0ICogQG1ldGhvZCB5Z3JpZHPigKRyZW1vdmVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgdmFsdWUgb3IgY2xhc3MuIElmIHZhbHVlIGlzIGdpdmVuLCB0aGUgeSBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgeSB2YWx1ZSB3aWxsIGJlIHJlbW92ZWQuIElmIGNsYXNzIGlzIGdpdmVuLCB0aGUgeSBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgY2xhc3Mgd2lsbCBiZSByZW1vdmVkLiBJZiBhcmdzIGlzIG5vdCBnaXZlbiwgYWxsIG9mIHkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyB5IGdyaWQgbGluZSBvbiB5ID0gMjAwIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnlncmlkcy5yZW1vdmUoe3ZhbHVlOiAyMDB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIHkgZ3JpZCBsaW5lcyB0aGF0IGhhdmUgJ2dyaWQtQScgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSh7XHJcblx0ICogICBjbGFzczogXCJncmlkLUFcIlxyXG5cdCAqIH0pO1xyXG5cdCAqXHJcblx0ICogLy8gYWxsIG9mIHkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC55Z3JpZHMucmVtb3ZlKCk7XHJcblx0ICovXHJcblx0cmVtb3ZlOiBmdW5jdGlvbihwYXJhbXM/OiB7dmFsdWU/OiBudW1iZXIsIGNsYXNzPzogc3RyaW5nfSkgeyAvLyBUT0RPOiBtdWx0aXBsZVxyXG5cdFx0dGhpcy5pbnRlcm5hbC5yZW1vdmVHcmlkTGluZXMocGFyYW1zLCBmYWxzZSk7XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHt5Z3JpZHN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNVbmRlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBncm91cHMgZm9yIHRoZSB0YXJnZXRzLlxyXG5cdCAqIEBtZXRob2QgZ3JvdXBzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gZ3JvdXBzIFRoaXMgYXJndW1lbnQgbmVlZHMgdG8gYmUgYW4gQXJyYXkgdGhhdCBpbmNsdWRlcyBvbmUgb3IgbW9yZSBBcnJheSB0aGF0IGluY2x1ZGVzIHRhcmdldCBpZHMgdG8gYmUgZ3JvdXBlZC5cclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gR3JvdXBlZCBkYXRhIG5hbWVzIGFycmF5XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgYSBuZXcgZ3JvdXAuXHJcblx0ICogIGNoYXJ0Lmdyb3VwcyhbXHJcblx0ICogICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl1cclxuXHQgKiAgXSk7XHJcblx0ICovXHJcblx0Z3JvdXBzKGdyb3Vwczogc3RyaW5nW11bXSk6IHN0cmluZ1tdW10ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoaXNVbmRlZmluZWQoZ3JvdXBzKSkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmRhdGFfZ3JvdXBzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy5kYXRhX2dyb3VwcyA9IGdyb3VwcztcclxuXHRcdCQkLnJlZHJhdygpO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRPcHRpb24sIGV4dGVuZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogVXBkYXRlIHJlZ2lvbnMuXHJcbiAqIEBtZXRob2QgcmVnaW9uc1xyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IHJlZ2lvbnMgUmVnaW9ucyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIHJlZ2lvbnMuXHJcbiAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFNob3cgMiByZWdpb25zXHJcbiAqIGNoYXJ0LnJlZ2lvbnMoW1xyXG4gKiAgICB7YXhpczogXCJ4XCIsIHN0YXJ0OiA1LCBjbGFzczogXCJyZWdpb25YXCJ9LFxyXG4gKiAgICB7YXhpczogXCJ5XCIsIGVuZDogNTAsIGNsYXNzOiBcInJlZ2lvbllcIn1cclxuICogXSk7XHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpb25zKHJlZ2lvbnM6IHtheGlzPzogc3RyaW5nLCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyLCBjbGFzcz86IHN0cmluZ31bXSk6IHt9W10ge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRpZiAoIXJlZ2lvbnMpIHtcclxuXHRcdHJldHVybiBjb25maWcucmVnaW9ucztcclxuXHR9XHJcblxyXG5cdGNvbmZpZy5yZWdpb25zID0gcmVnaW9ucztcclxuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRyZXR1cm4gcmVnaW9ucztcclxufVxyXG5cclxuZXh0ZW5kKHJlZ2lvbnMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgbmV3IHJlZ2lvbi48YnI+PGJyPlxyXG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHJlZ2lvbiBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHJlZ2lvbnMuXHJcblx0ICogQG1ldGhvZCByZWdpb25z4oCkYWRkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHJlZ2lvbnMgTmV3IHJlZ2lvbiB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgcmVnaW9ucyBhbmQgaXQncyBwb3NzaWJsZSB0byBnaXZlIGFuIE9iamVjdCBpZiBvbmx5IG9uZSByZWdpb24gd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gcmVnaW9uc1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gQWRkIGEgbmV3IHJlZ2lvblxyXG5cdCAqIGNoYXJ0LnJlZ2lvbnMuYWRkKFxyXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn1cclxuXHQgKiApO1xyXG5cdCAqXHJcblx0ICogLy8gQWRkIG5ldyByZWdpb25zXHJcblx0ICogY2hhcnQucmVnaW9ucy5hZGQoW1xyXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXHJcblx0ICogICAge2F4aXM6IFwieVwiLCBlbmQ6IDUwLCBjbGFzczogXCJyZWdpb25ZXCJ9XHJcblx0ICpdKTtcclxuXHQgKi9cclxuXHRhZGQ6IGZ1bmN0aW9uKHJlZ2lvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFyZWdpb25zKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcucmVnaW9ucztcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcucmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zLmNvbmNhdChyZWdpb25zKTtcclxuXHRcdCQkLnJlZHJhd1dpdGhvdXRSZXNjYWxlKCk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlbW92ZSByZWdpb25zLjxicj48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyByZWdpb25zLlxyXG5cdCAqIEBtZXRob2QgcmVnaW9uc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSByZWdpb25zIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgY2xhc3Nlcy4gSWYgY2xhc3NlcyBpcyBnaXZlbiwgdGhlIHJlZ2lvbnMgdGhhdCBoYXZlIG9uZSBvZiB0aGUgc3BlY2lmaWVkIGNsYXNzZXMgd2lsbCBiZSByZW1vdmVkLiBJZiBhcmdzIGlzIG5vdCBnaXZlbiwgYWxsIG9mIHJlZ2lvbnMgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSByZWdpb25zIFJlbW92ZWQgcmVnaW9uc1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gcmVnaW9ucyB0aGF0IGhhdmUgJ3JlZ2lvbi1BJyBvciAncmVnaW9uLUInIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSh7XHJcblx0ICogICBjbGFzc2VzOiBbXHJcblx0ICogICAgIFwicmVnaW9uLUFcIiwgXCJyZWdpb24tQlwiXHJcblx0ICogICBdXHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogY2hhcnQucmVnaW9ucy5yZW1vdmUoKTtcclxuXHQgKi9cclxuXHRyZW1vdmU6IGZ1bmN0aW9uKG9wdGlvbnNWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjb25zdCBvcHRpb25zID0gb3B0aW9uc1ZhbHVlIHx8IHt9O1xyXG5cdFx0Y29uc3QgZHVyYXRpb24gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJkdXJhdGlvblwiLCBjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbik7XHJcblx0XHRjb25zdCBjbGFzc2VzID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiY2xhc3Nlc1wiLCBbQ0xBU1MucmVnaW9uXSk7XHJcblx0XHRsZXQgcmVnaW9ucyA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MucmVnaW9uc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGNsYXNzZXMubWFwKGMgPT4gYC4ke2N9YCkpO1xyXG5cclxuXHRcdChkdXJhdGlvbiA/IHJlZ2lvbnMudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IHJlZ2lvbnMpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRyZWdpb25zID0gY29uZmlnLnJlZ2lvbnM7XHJcblxyXG5cdFx0aWYgKE9iamVjdC5rZXlzKG9wdGlvbnMpLmxlbmd0aCkge1xyXG5cdFx0XHRyZWdpb25zID0gcmVnaW9ucy5maWx0ZXIocmVnaW9uID0+IHtcclxuXHRcdFx0XHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0aWYgKCFyZWdpb24uY2xhc3MpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmVnaW9uLmNsYXNzLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGMgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKGNsYXNzZXMuaW5kZXhPZihjKSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuICFmb3VuZDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRjb25maWcucmVnaW9ucyA9IHJlZ2lvbnM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25maWcucmVnaW9ucyA9IFtdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWdpb25zO1xyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7cmVnaW9uc307XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtpc0RlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7RGF0YUl0ZW19IGZyb20gXCIuLi8uLi8uLi90eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBzZWxlY3RlZCBkYXRhIHBvaW50cy48YnI+PGJyPlxyXG5cdCAqIEJ5IHRoaXMgQVBJLCB5b3UgY2FuIGdldCBzZWxlY3RlZCBkYXRhIHBvaW50cyBpbmZvcm1hdGlvbi4gVG8gdXNlIHRoaXMgQVBJLCBkYXRhLnNlbGVjdGlvbi5lbmFibGVkIG5lZWRzIHRvIGJlIHNldCB0cnVlLlxyXG5cdCAqIEBtZXRob2Qgc2VsZWN0ZWRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3RhcmdldElkXSBZb3UgY2FuIGZpbHRlciB0aGUgcmVzdWx0IGJ5IGdpdmluZyB0YXJnZXQgaWQgdGhhdCB5b3Ugd2FudCB0byBnZXQuIElmIG5vdCBnaXZlbiwgYWxsIG9mIGRhdGEgcG9pbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogQHJldHVybiB7QXJyYXl9IGRhdGFQb2ludCBBcnJheSBvZiB0aGUgZGF0YSBwb2ludHMuPGJyPmV4LikgYFt7eDogMSwgdmFsdWU6IDIwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDEsIG5hbWU6IFwiZGF0YTFcIn0sIC4uLl1gXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gYWxsIHNlbGVjdGVkIGRhdGEgcG9pbnRzIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogIGNoYXJ0LnNlbGVjdGVkKCk7XHJcblx0ICogIC8vIC0tPiBleC4pIFt7eDogMSwgdmFsdWU6IDIwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDEsIG5hbWU6IFwiZGF0YTFcIn0sIC4uLiBdXHJcblx0ICpcclxuXHQgKiAgLy8gYWxsIHNlbGVjdGVkIGRhdGEgcG9pbnRzIG9mIGRhdGExIHdpbGwgYmUgcmV0dXJuZWQuXHJcblx0ICogIGNoYXJ0LnNlbGVjdGVkKFwiZGF0YTFcIik7XHJcblx0ICovXHJcblx0c2VsZWN0ZWQodGFyZ2V0SWQ/OiBzdHJpbmcpOiBEYXRhSXRlbVtdIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IGRhdGFQb2ludDogRGF0YUl0ZW1bXSA9IFtdO1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuIGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuZWFjaChkID0+IGRhdGFQb2ludC5wdXNoKGQpKTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YVBvaW50O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBkYXRhIHBvaW50cyB0byBiZSBzZWxlY3RlZC4gKGBbZGF0YS5zZWxlY3Rpb24uZW5hYmxlZF0oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0c2VsZWN0aW9uJTI1RTIlMjU4MCUyNUE0ZW5hYmxlZCkgb3B0aW9uIHNob3VsZCBiZSBzZXQgdHJ1ZSB0byB1c2UgdGhpcyBtZXRob2QpYFxyXG5cdCAqIEBtZXRob2Qgc2VsZWN0XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFtpZHNdIGlkIHZhbHVlIHRvIGdldCBzZWxlY3RlZC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jlc2V0T3RoZXJdIFVuc2VsZWN0IGFscmVhZHkgc2VsZWN0ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xyXG5cdCAqICBjaGFydC5zZWxlY3QoKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGEyJ1xyXG5cdCAqICBjaGFydC5zZWxlY3QoXCJkYXRhMlwiKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgYWxsIGZyb20gJ2RhdGExJyBhbmQgJ2RhdGEyJ1xyXG5cdCAqICBjaGFydC5zZWxlY3QoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAgLy8gc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAyIGFuZCB1bnNlbGVjdCBvdGhlcnMgc2VsZWN0ZWRcclxuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTFcIiwgWzJdLCB0cnVlKTtcclxuXHQgKlxyXG5cdCAqICAvLyBzZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDAsIDMgYW5kIDVcclxuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTFcIiwgWzAsIDMsIDVdKTtcclxuXHQgKi9cclxuXHRzZWxlY3QoaWRzPzogc3RyaW5nW10gfCBzdHJpbmcsIGluZGljZXM/OiBudW1iZXJbXSwgcmVzZXRPdGhlcj86IGJvb2xlYW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YSA/IGQuZGF0YS5pZCA6IGQuaWQ7XHJcblx0XHRcdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoaXMsIGQpLmJpbmQoJCQpO1xyXG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAhaWRzIHx8IGlkcy5pbmRleE9mKGlkKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SW5kZXggPSAhaW5kaWNlcyB8fCBpbmRpY2VzLmluZGV4T2YoaSkgPj0gMDtcclxuXHRcdFx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblxyXG5cdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5saW5lKSB8fCBzaGFwZS5jbGFzc2VkKENMQVNTLmFyZWEpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNUYXJnZXRJZCAmJiBpc1RhcmdldEluZGV4KSB7XHJcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSAmJiAhaXNTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0XHR0b2dnbGUodHJ1ZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgdHJ1ZSksIGQsIGkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKHJlc2V0T3RoZXIpICYmIHJlc2V0T3RoZXIgJiYgaXNTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGRhdGEgcG9pbnRzIHRvIGJlIHVuLXNlbGVjdGVkLlxyXG5cdCAqIEBtZXRob2QgdW5zZWxlY3RcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW2lkc10gaWQgdmFsdWUgdG8gYmUgdW5zZWxlY3RlZC5cclxuXHQgKiBAcGFyYW0ge0FycmF5fSBbaW5kaWNlc10gVGhlIGluZGV4IGFycmF5IG9mIGRhdGEgcG9pbnRzLiBJZiBmYWxzeSB2YWx1ZSBnaXZlbiwgd2lsbCBzZWxlY3QgYWxsIGRhdGEgcG9pbnRzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBkYXRhIHBvaW50c1xyXG5cdCAqICBjaGFydC51bnNlbGVjdCgpO1xyXG5cdCAqXHJcblx0ICogIC8vIHVuc2VsZWN0IGFsbCBmcm9tICdkYXRhMSdcclxuXHQgKiAgY2hhcnQudW5zZWxlY3QoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqICAvLyB1bnNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMlxyXG5cdCAqICBjaGFydC51bnNlbGVjdChcImRhdGExXCIsIFsyXSk7XHJcblx0ICovXHJcblx0dW5zZWxlY3QoaWRzPzogc3RyaW5nIHwgc3RyaW5nW10sIGluZGljZXM/OiBudW1iZXJbXSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhID8gZC5kYXRhLmlkIDogZC5pZDtcclxuXHRcdFx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhpcywgZCkuYmluZCgkJCk7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICFpZHMgfHwgaWRzLmluZGV4T2YoaWQpID49IDA7XHJcblx0XHRcdFx0Y29uc3QgaXNUYXJnZXRJbmRleCA9ICFpbmRpY2VzIHx8IGluZGljZXMuaW5kZXhPZihpKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHJcblx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmxpbmUpIHx8IHNoYXBlLmNsYXNzZWQoQ0xBU1MuYXJlYSkpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc1RhcmdldElkICYmIGlzVGFyZ2V0SW5kZXggJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSAmJiBpc1NlbGVjdGVkKSB7XHJcblx0XHRcdFx0XHR0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgeCB2YWx1ZXMgZm9yIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIHhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB4IElmIHggaXMgZ2l2ZW4sIHggdmFsdWVzIG9mIGV2ZXJ5IHRhcmdldCB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBjdXJyZW50IHggdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSB0YXJnZXQgaWRzLlxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0geHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBHZXQgY3VycmVudCB4IHZhbHVlc1xyXG5cdCAqICBjaGFydC54KCk7XHJcblx0ICpcclxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xyXG5cdCAqICBjaGFydC54KFsxMDAsIDIwMCwgMzAwLCA0MDAsIC4uLl0pO1xyXG5cdCAqL1xyXG5cdHgoeCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHJcblx0XHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0XHRpZiAoaXNDYXRlZ29yaXplZCkge1xyXG5cdFx0XHRcdHRoaXMuY2F0ZWdvcmllcyh4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQkJC51cGRhdGVUYXJnZXRYKCQkLmRhdGEudGFyZ2V0cywgeCk7XHJcblxyXG5cdFx0XHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNDYXRlZ29yaXplZCA/IHRoaXMuY2F0ZWdvcmllcygpIDogJCQuZGF0YS54cztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCB4IHZhbHVlcyBmb3IgdGhlIGNoYXJ0LlxyXG5cdCAqIEBtZXRob2QgeHNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB4cyBJZiB4cyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIHggdmFsdWVzIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGN1cnJlbnQgeCB2YWx1ZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIHRhcmdldCBpZHMuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSB4c1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEdldCBjdXJyZW50IHggdmFsdWVzXHJcblx0ICogIGNoYXJ0LnhzKCk7XHJcblx0ICpcclxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xyXG5cdCAqICBjaGFydC54cyh7XHJcblx0ICogICAgZGF0YTE6IFsxMCwgMjAsIDMwLCA0MCwgLi4uXSxcclxuXHQgKiAgICBkYXRhMjogWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXVxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHR4cyh4cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdGlmIChpc09iamVjdCh4cykpIHtcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0WHMoJCQuZGF0YS50YXJnZXRzLCB4cyk7XHJcblxyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAkJC5kYXRhLnhzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3pvb21JZGVudGl0eSBhcyBkM1pvb21JZGVudGl0eSwgem9vbVRyYW5zZm9ybSBhcyBkM1pvb21UcmFuc2Zvcm19IGZyb20gXCJkMy16b29tXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGV4dGVuZCwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRvbWFpbiBpcyB3aXRoaW4gem9vbSByYW5nZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW5cclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhpblJhbmdlKGRvbWFpbjogbnVtYmVyW10sIHJhbmdlOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IFttaW4sIG1heF0gPSByYW5nZTtcclxuXHJcblx0cmV0dXJuIGRvbWFpbi5ldmVyeSgodiwgaSkgPT4gKFxyXG5cdFx0aSA9PT0gMCA/ICh2ID49IG1pbikgOiAodiA8PSBtYXgpXHJcblx0KSk7XHJcbn07XHJcblxyXG4vKipcclxuICogWm9vbSBieSBnaXZpbmcgeCBkb21haW4uXHJcbiAqIC0gKipOT1RFOioqXHJcbiAqICAtIEZvciBgd2hlZWxgIHR5cGUgem9vbSwgdGhlIG1pbmltdW0gem9vbSByYW5nZSB3aWxsIGJlIHNldCBhcyB0aGUgZ2l2ZW4gZG9tYWluLiBUbyBnZXQgdGhlIGluaXRpYWwgc3RhdGUsIFsudW56b29tKCldKCN1bnpvb20pIHNob3VsZCBiZSBjYWxsZWQuXHJcbiAqICAtIFRvIGJlIHVzZWQgW3pvb20uZW5hYmxlZF0oT3B0aW9ucy5odG1sIy56b29tKSBvcHRpb24gc2hvdWxkIGJlIHNldCBhcyBgdHJ1dGh5YC5cclxuICogQG1ldGhvZCB6b29tXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtBcnJheX0gZG9tYWluVmFsdWUgSWYgZG9tYWluIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB6b29tZWQgdG8gdGhlIGdpdmVuIGRvbWFpbi4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IHpvb21lZCBkb21haW4gd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHJldHVybiB7QXJyYXl9IGRvbWFpbiB2YWx1ZSBpbiBhcnJheVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgLy8gWm9vbSB0byBzcGVjaWZpZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKFsxMCwgMjBdKTtcclxuICpcclxuICogIC8vIEdldCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKCk7XHJcbiAqL1xyXG5jb25zdCB6b29tID0gZnVuY3Rpb24oZG9tYWluVmFsdWU/OiBudW1iZXJbXSkge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRsZXQgZG9tYWluID0gZG9tYWluVmFsdWU7XHJcblx0bGV0IHJlc3VsdERvbWFpbjtcclxuXHJcblx0aWYgKGNvbmZpZy56b29tX2VuYWJsZWQgJiYgZG9tYWluICYmIHdpdGhpblJhbmdlKGRvbWFpbiwgJCQuZ2V0Wm9vbURvbWFpbigpKSkge1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0aWYgKGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRkb21haW4gPSBkb21haW4ubWFwKHggPT4gJCQucGFyc2VEYXRlKHgpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcclxuXHRcdFx0Y29uc3QgeFNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cclxuXHRcdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBbeFNjYWxlKGRvbWFpblswXSksIHhTY2FsZShkb21haW5bMV0pXSk7XHJcblx0XHRcdHJlc3VsdERvbWFpbiA9IGRvbWFpbjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKGRvbWFpbik7XHJcblx0XHRcdHNjYWxlLnpvb20gPSBzY2FsZS54O1xyXG5cdFx0XHQkJC5heGlzLnguc2NhbGUoc2NhbGUuem9vbSk7XHJcblxyXG5cdFx0XHRyZXN1bHREb21haW4gPSBzY2FsZS56b29tLm9yZ0RvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHR3aXRoWTogY29uZmlnLnpvb21fcmVzY2FsZSxcclxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdCQkLnNldFpvb21SZXNldEJ1dHRvbigpO1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbSwgdGhpcywgcmVzdWx0RG9tYWluKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVzdWx0RG9tYWluID0gc2NhbGUuem9vbSA/XHJcblx0XHRcdHNjYWxlLnpvb20uZG9tYWluKCkgOiBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdERvbWFpbjtcclxufTtcclxuXHJcbmV4dGVuZCh6b29tLCB7XHJcblx0LyoqXHJcblx0ICogRW5hYmxlIGFuZCBkaXNhYmxlIHpvb21pbmcuXHJcblx0ICogQG1ldGhvZCB6b29t4oCkZW5hYmxlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gZW5hYmxlZCBQb3NzaWJsZSBzdHJpbmcgdmFsdWVzIGFyZSBcIndoZWVsXCIgb3IgXCJkcmFnXCIuIElmIGVuYWJsZWQgaXMgdHJ1ZSwgXCJ3aGVlbFwiIHdpbGwgYmUgdXNlZC4gSWYgZmFsc2UgaXMgZ2l2ZW4sIHpvb21pbmcgd2lsbCBiZSBkaXNhYmxlZC48YnI+V2hlbiBzZXQgdG8gZmFsc2UsIHRoZSBjdXJyZW50IHpvb21pbmcgc3RhdHVzIHdpbGwgYmUgcmVzZXQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gRW5hYmxlIHpvb21pbmcgdXNpbmcgdGhlIG1vdXNlIHdoZWVsXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKHRydWUpO1xyXG5cdCAqICAvLyBPclxyXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShcIndoZWVsXCIpO1xyXG5cdCAqXHJcblx0ICogIC8vIEVuYWJsZSB6b29taW5nIGJ5IGRyYWdnaW5nXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKFwiZHJhZ1wiKTtcclxuXHQgKlxyXG5cdCAqICAvLyBEaXNhYmxlIHpvb21pbmdcclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoZmFsc2UpO1xyXG5cdCAqL1xyXG5cdGVuYWJsZTogZnVuY3Rpb24oZW5hYmxlZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCBlbmFibGVUeXBlOiBhbnkgPSBlbmFibGVkO1xyXG5cclxuXHRcdGlmIChlbmFibGVkKSB7XHJcblx0XHRcdGVuYWJsZVR5cGUgPSBpc1N0cmluZyhlbmFibGVkKSAmJiAvXihkcmFnfHdoZWVsKSQvLnRlc3QoZW5hYmxlZCkgP1xyXG5cdFx0XHRcdHt0eXBlOiBlbmFibGVkfSA6IGVuYWJsZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnpvb21fZW5hYmxlZCA9IGVuYWJsZVR5cGU7XHJcblxyXG5cdFx0aWYgKCEkJC56b29tKSB7XHJcblx0XHRcdCQkLmluaXRab29tKCk7XHJcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoKTtcclxuXHRcdH0gZWxzZSBpZiAoZW5hYmxlZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0JCQuYmluZFpvb21FdmVudChmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudXBkYXRlQW5kUmVkcmF3KCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG9yIGdldCB4IEF4aXMgbWF4aW11bSB6b29tIHJhbmdlIHZhbHVlXHJcblx0ICogQG1ldGhvZCB6b29t4oCkbWF4XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttYXhdIG1heGltdW0gdmFsdWUgdG8gc2V0IGZvciB6b29tXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSB6b29tIG1heCB2YWx1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFNldCBtYXhpbXVtIHJhbmdlIHZhbHVlXHJcblx0ICogIGNoYXJ0Lnpvb20ubWF4KDIwKTtcclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKG1heD86IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBvcmc6IHt4RG9tYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAobWF4ID09PSAwIHx8IG1heCkge1xyXG5cdFx0XHRjb25maWcuem9vbV94X21heCA9IGdldE1pbk1heChcIm1heFwiLCBbeERvbWFpblsxXSwgbWF4XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy56b29tX3hfbWF4O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBvciBnZXQgeCBBeGlzIG1pbmltdW0gem9vbSByYW5nZSB2YWx1ZVxyXG5cdCAqIEBtZXRob2Qgem9vbeKApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBbbWluXSBtaW5pbXVtIHZhbHVlIHRvIHNldCBmb3Igem9vbVxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gem9vbSBtaW4gdmFsdWVcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBTZXQgbWluaW11bSByYW5nZSB2YWx1ZVxyXG5cdCAqICBjaGFydC56b29tLm1pbigtMSk7XHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbihtaW4/OiBudW1iZXIpOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnOiB7eERvbWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKG1pbiA9PT0gMCB8fCBtaW4pIHtcclxuXHRcdFx0Y29uZmlnLnpvb21feF9taW4gPSBnZXRNaW5NYXgoXCJtaW5cIiwgW3hEb21haW5bMF0sIG1pbl0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWcuem9vbV94X21pbjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgem9vbSByYW5nZVxyXG5cdCAqIEBtZXRob2Qgem9vbeKApHJhbmdlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtyYW5nZV1cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHpvb20gcmFuZ2UgdmFsdWVcclxuXHQgKiB7XHJcblx0ICogICBtaW46IDAsXHJcblx0ICogICBtYXg6IDEwMFxyXG5cdCAqIH1cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC56b29tLnJhbmdlKHtcclxuXHQgKiAgICAgIG1pbjogMTAsXHJcblx0ICogICAgICBtYXg6IDEwMFxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHRyYW5nZTogZnVuY3Rpb24ocmFuZ2UpIHtcclxuXHRcdGNvbnN0IHpvb20gPSB0aGlzLnpvb207XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KHJhbmdlKSkge1xyXG5cdFx0XHRjb25zdCB7bWluLCBtYXh9ID0gcmFuZ2U7XHJcblxyXG5cdFx0XHRpc0RlZmluZWQobWluKSAmJiB6b29tLm1pbihtaW4pO1xyXG5cdFx0XHRpc0RlZmluZWQobWF4KSAmJiB6b29tLm1heChtYXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdG1pbjogem9vbS5taW4oKSxcclxuXHRcdFx0bWF4OiB6b29tLm1heCgpXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0em9vbSxcclxuXHJcblx0LyoqXHJcblx0ICogVW56b29tIHpvb21lZCBhcmVhXHJcblx0ICogQG1ldGhvZCB1bnpvb21cclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC51bnpvb20oKTtcclxuXHQgKi9cclxuXHR1bnpvb20oKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5zY2FsZS56b29tKSB7XHJcblx0XHRcdGNvbmZpZy5zdWJjaGFydF9zaG93ID9cclxuXHRcdFx0XHQkJC5icnVzaC5nZXRTZWxlY3Rpb24oKS5jYWxsKCQkLmJydXNoLm1vdmUsIG51bGwpIDpcclxuXHRcdFx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKGQzWm9vbUlkZW50aXR5KTtcclxuXHJcblx0XHRcdCQkLnVwZGF0ZVpvb20odHJ1ZSk7XHJcblx0XHRcdCQkLnpvb20ucmVzZXRCdG4gJiYgJCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpO1xyXG5cclxuXHRcdFx0Ly8gcmVzZXQgdHJhbnNmb3JtXHJcblx0XHRcdGNvbnN0IGV2ZW50UmVjdHMgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YCk7XHJcblxyXG5cdFx0XHRpZiAoZDNab29tVHJhbnNmb3JtKGV2ZW50UmVjdHMubm9kZSgpKSAhPT0gZDNab29tSWRlbnRpdHkpIHtcclxuXHRcdFx0XHQkJC56b29tLnRyYW5zZm9ybShldmVudFJlY3RzLCBkM1pvb21JZGVudGl0eSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdFx0d2l0aFRyYW5zaXRpb246IHRydWUsXHJcblx0XHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGVcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRQYXRoQm94fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcInR5cGVzL3R5cGVzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gZHJhZ2dpbmcuXHJcblx0ICogRGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIE9iamVjdFxyXG5cdCAqL1xyXG5cdGRyYWcobW91c2UpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8XHJcblx0XHRcdCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCB8fCAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXHJcblx0XHRcdChjb25maWcuem9vbV9lbmFibGVkICYmICEkJC56b29tLmFsdERvbWFpbikgfHwgLy8gc2tpcCBpZiB6b29tYWJsZSBiZWNhdXNlIG9mIGNvbmZsaWN0IGRyYWcgYmVoYXZpb3JcclxuXHRcdFx0IWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9tdWx0aXBsZSAvLyBza2lwIHdoZW4gc2luZ2xlIHNlbGVjdGlvbiBiZWNhdXNlIGRyYWcgaXMgdXNlZCBmb3IgbXVsdGlwbGUgc2VsZWN0aW9uXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IFtzeCwgc3ldID0gc3RhdGUuZHJhZ1N0YXJ0O1xyXG5cdFx0Y29uc3QgW214LCBteV0gPSBtb3VzZTtcclxuXHJcblx0XHRjb25zdCBtaW5YID0gTWF0aC5taW4oc3gsIG14KTtcclxuXHRcdGNvbnN0IG1heFggPSBNYXRoLm1heChzeCwgbXgpO1xyXG5cdFx0Y29uc3QgbWluWSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gc3RhdGUubWFyZ2luLnRvcCA6IE1hdGgubWluKHN5LCBteSk7XHJcblx0XHRjb25zdCBtYXhZID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgPyBzdGF0ZS5oZWlnaHQgOiBNYXRoLm1heChzeSwgbXkpO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5kcmFnYXJlYX1gKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgbWluWClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIG1pblkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbWF4WCAtIG1pblgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIG1heFkgLSBtaW5ZKTtcclxuXHJcblx0XHQvLyBUT0RPOiBiaW5hcnkgc2VhcmNoIHdoZW4gbXVsdGlwbGUgeHNcclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0LmZpbHRlcihkID0+IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCBzaGFwZTogZDNTZWxlY3Rpb24gPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblx0XHRcdFx0Y29uc3QgaXNJbmNsdWRlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQpO1xyXG5cdFx0XHRcdGxldCBpc1dpdGhpbjogYW55ID0gZmFsc2U7XHJcblx0XHRcdFx0bGV0IHRvZ2dsZTtcclxuXHJcblx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuY2lyY2xlKSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgeDogbnVtYmVyID0gK3NoYXBlLmF0dHIoXCJjeFwiKSAqIDE7XHJcblx0XHRcdFx0XHRjb25zdCB5OiBudW1iZXIgPSArc2hhcGUuYXR0cihcImN5XCIpICogMTtcclxuXHJcblx0XHRcdFx0XHR0b2dnbGUgPSAkJC50b2dnbGVQb2ludDtcclxuXHRcdFx0XHRcdGlzV2l0aGluID0gbWluWCA8IHggJiYgeCA8IG1heFggJiYgbWluWSA8IHkgJiYgeSA8IG1heFk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmJhcikpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSA9IGdldFBhdGhCb3godGhpcyk7XHJcblxyXG5cdFx0XHRcdFx0dG9nZ2xlID0gJCQudG9nZ2xlUGF0aDtcclxuXHRcdFx0XHRcdGlzV2l0aGluID0gIShtYXhYIDwgeCB8fCB4ICsgd2lkdGggPCBtaW5YKSAmJiAhKG1heFkgPCB5IHx8IHkgKyBoZWlnaHQgPCBtaW5ZKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gbGluZS9hcmVhIHNlbGVjdGlvbiBub3Qgc3VwcG9ydGVkIHlldFxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdGlmIChpc1dpdGhpbiBeIGlzSW5jbHVkZWQpIHtcclxuXHRcdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuSU5DTFVERUQsICFpc0luY2x1ZGVkKTtcclxuXHRcdFx0XHRcdC8vIFRPRE86IGluY2x1ZGVkL3VuaW5jbHVkZWQgY2FsbGJhY2sgaGVyZVxyXG5cdFx0XHRcdFx0c2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgIWlzU2VsZWN0ZWQpO1xyXG5cdFx0XHRcdFx0dG9nZ2xlLmNhbGwoJCQsICFpc1NlbGVjdGVkLCBzaGFwZSwgZCwgaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgZHJhZyBzdGFydHMuXHJcblx0ICogQWRkcyBhbmQgU2hvd3MgdGhlIGRyYWcgYXJlYS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSBPYmplY3RcclxuXHQgKi9cclxuXHRkcmFnc3RhcnQobW91c2UpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuZHJhZ1N0YXJ0ID0gbW91c2U7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZHJhZ2FyZWEpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwLjFcIik7XHJcblxyXG5cdFx0JCQuc2V0RHJhZ1N0YXR1cyh0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgZHJhZyBmaW5pc2hlcy5cclxuXHQgKiBSZW1vdmVzIHRoZSBkcmFnIGFyZWEuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRkcmFnZW5kKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHsgLy8gZG8gbm90aGluZyBpZiBub3Qgc2VsZWN0YWJsZVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmRyYWdhcmVhfWApXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKDEwMClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuY2xhc3NlZChDTEFTUy5JTkNMVURFRCwgZmFsc2UpO1xyXG5cclxuXHRcdCQkLnNldERyYWdTdGF0dXMoZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdHNldERyYWdTdGF0dXMoaXNEcmFnZ2luZykge1xyXG5cdFx0dGhpcy5kcmFnZ2luZyA9IGlzRHJhZ2dpbmc7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZWFzZUxpbmVhciBhcyBkM0Vhc2VMaW5lYXJ9IGZyb20gXCJkMy1lYXNlXCI7XHJcbmltcG9ydCB7dHJhbnNpdGlvbiBhcyBkM1RyYW5zaXRpb259IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XHJcbmltcG9ydCB7ZGlmZkRvbWFpbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSBmbG93XHJcblx0ICogQG1lbWJlcm9mIENoYXJ0SW50ZXJuYWxcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzXHJcblx0ICogQHJldHVybiB7RnVuY3Rpb259XHJcblx0ICovXHJcblx0Z2VuZXJhdGVGbG93KGFyZ3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzID0gYXJncy50YXJnZXRzO1xyXG5cdFx0XHRjb25zdCBmbG93ID0gYXJncy5mbG93O1xyXG5cclxuXHRcdFx0Y29uc3Qge2JhcjogZHJhd0JhciwgbGluZTogZHJhd0xpbmUsIGFyZWE6IGRyYXdBcmVhfSA9IGFyZ3Muc2hhcGUudHlwZTtcclxuXHRcdFx0Y29uc3Qge2N4LCBjeSwgeEZvclRleHQsIHlGb3JUZXh0fSA9IGFyZ3Muc2hhcGUucG9zO1xyXG5cdFx0XHRjb25zdCB4diA9IGFyZ3MueHY7XHJcblx0XHRcdGNvbnN0IGR1cmF0aW9uID0gYXJncy5kdXJhdGlvbjtcclxuXHJcblx0XHRcdGxldCB0cmFuc2xhdGVYO1xyXG5cdFx0XHRsZXQgc2NhbGVYID0gMTtcclxuXHRcdFx0Y29uc3QgZmxvd0luZGV4ID0gZmxvdy5pbmRleDtcclxuXHRcdFx0Y29uc3QgZmxvd0xlbmd0aCA9IGZsb3cubGVuZ3RoO1xyXG5cdFx0XHRsZXQgZmxvd1N0YXJ0ID0gJCQuZ2V0VmFsdWVPbkluZGV4KCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMsIGZsb3dJbmRleCk7XHJcblx0XHRcdGxldCBmbG93RW5kID0gJCQuZ2V0VmFsdWVPbkluZGV4KCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMsIGZsb3dJbmRleCArIGZsb3dMZW5ndGgpO1xyXG5cdFx0XHRjb25zdCBvcmdEb21haW4gPSAkJC5zY2FsZS54LmRvbWFpbigpO1xyXG5cdFx0XHRjb25zdCBkdXJhdGlvbkZvckZsb3cgPSBmbG93LmR1cmF0aW9uIHx8IGR1cmF0aW9uO1xyXG5cdFx0XHRjb25zdCBkb25lID0gZmxvdy5kb25lIHx8IGZ1bmN0aW9uKCkge307XHJcblx0XHRcdGNvbnN0IHdhaXQgPSAkJC5nZW5lcmF0ZVdhaXQoKTtcclxuXHJcblx0XHRcdGNvbnN0IHhncmlkID0gJGVsLmdyaWQueDtcclxuXHRcdFx0Y29uc3QgeGdyaWRMaW5lcyA9ICRlbC5ncmlkTGluZXMueDtcclxuXHRcdFx0Y29uc3QgbWFpblJlZ2lvbiA9ICRlbC5yZWdpb24ubGlzdDtcclxuXHRcdFx0Y29uc3QgbWFpblRleHQgPSAkZWwudGV4dDtcclxuXHRcdFx0Y29uc3QgbWFpbkJhciA9ICRlbC5iYXI7XHJcblx0XHRcdGNvbnN0IG1haW5MaW5lID0gJGVsLmxpbmU7XHJcblx0XHRcdGNvbnN0IG1haW5BcmVhID0gJGVsLmFyZWE7XHJcblx0XHRcdGNvbnN0IG1haW5DaXJjbGUgPSAkZWwuY2lyY2xlO1xyXG5cclxuXHRcdFx0Ly8gc2V0IGZsYWdcclxuXHRcdFx0c3RhdGUuZmxvd2luZyA9IHRydWU7XHJcblxyXG5cdFx0XHQvLyByZW1vdmUgaGVhZCBkYXRhIGFmdGVyIHJlbmRlcmVkXHJcblx0XHRcdCQkLmRhdGEudGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRcdGQudmFsdWVzLnNwbGljZSgwLCBmbG93TGVuZ3RoKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgeCBkb21haW4gdG8gZ2VuZXJhdGUgYXhpcyBlbGVtZW50cyBmb3IgZmxvd1xyXG5cdFx0XHRjb25zdCBkb21haW4gPSAkJC51cGRhdGVYRG9tYWluKHRhcmdldHMsIHRydWUsIHRydWUpO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGVsZW1lbnRzIHJlbGF0ZWQgdG8geCBzY2FsZVxyXG5cdFx0XHRpZiAoJCQudXBkYXRlWEdyaWQpIHsgJCQudXBkYXRlWEdyaWQodHJ1ZSk7IH1cclxuXHJcblx0XHRcdGNvbnN0IHt4fSA9ICQkLnNjYWxlO1xyXG5cclxuXHRcdFx0Ly8gZ2VuZXJhdGUgdHJhbnNmb3JtIHRvIGZsb3dcclxuXHRcdFx0aWYgKCFmbG93Lm9yZ0RhdGFDb3VudCkgeyAvLyBpZiBlbXB0eVxyXG5cdFx0XHRcdGlmICgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLmxlbmd0aCAhPT0gMSkge1xyXG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9IHgob3JnRG9tYWluWzBdKSAtIHgoZG9tYWluWzBdKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdFx0XHRcdGZsb3dTdGFydCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCAwKTtcclxuXHRcdFx0XHRcdFx0Zmxvd0VuZCA9ICQkLmdldFZhbHVlT25JbmRleCgkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLCAkJC5kYXRhLnRhcmdldHNbMF0udmFsdWVzLmxlbmd0aCAtIDEpO1xyXG5cdFx0XHRcdFx0XHR0cmFuc2xhdGVYID0geChmbG93U3RhcnQueCkgLSB4KGZsb3dFbmQueCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0cmFuc2xhdGVYID0gZGlmZkRvbWFpbihkb21haW4pIC8gMjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZmxvdy5vcmdEYXRhQ291bnQgPT09IDEgfHwgKGZsb3dTdGFydCAmJiBmbG93U3RhcnQueCkgPT09IChmbG93RW5kICYmIGZsb3dFbmQueCkpIHtcclxuXHRcdFx0XHR0cmFuc2xhdGVYID0geChvcmdEb21haW5bMF0pIC0geChkb21haW5bMF0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSkge1xyXG5cdFx0XHRcdFx0dHJhbnNsYXRlWCA9ICh4KG9yZ0RvbWFpblswXSkgLSB4KGRvbWFpblswXSkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0cmFuc2xhdGVYID0gKHgoZmxvd1N0YXJ0LngpIC0geChmbG93RW5kLngpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNjYWxlWCA9IChkaWZmRG9tYWluKG9yZ0RvbWFpbikgLyBkaWZmRG9tYWluKGRvbWFpbikpO1xyXG5cdFx0XHRjb25zdCB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7dHJhbnNsYXRlWH0sMCkgc2NhbGUoJHtzY2FsZVh9LDEpYDtcclxuXHJcblx0XHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHJcblx0XHRcdGNvbnN0IGd0ID0gZDNUcmFuc2l0aW9uKCkuZWFzZShkM0Vhc2VMaW5lYXIpXHJcblx0XHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRmxvdyk7XHJcblxyXG5cdFx0XHR3YWl0LmFkZChbXHJcblx0XHRcdFx0JCQuJGVsLmF4aXMueFxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuY2FsbChnID0+ICQkLmF4aXMueC5zZXRUcmFuc2l0aW9uKGd0KS5jcmVhdGUoZykpLFxyXG5cclxuXHRcdFx0XHRtYWluQmFyXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXHJcblxyXG5cdFx0XHRcdG1haW5MaW5lXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXHJcblxyXG5cdFx0XHRcdG1haW5BcmVhXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXHJcblxyXG5cdFx0XHRcdG1haW5DaXJjbGVcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcclxuXHJcblx0XHRcdFx0bWFpblRleHRcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcclxuXHJcblx0XHRcdFx0bWFpblJlZ2lvblxyXG5cdFx0XHRcdFx0LmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcclxuXHJcblx0XHRcdFx0eGdyaWRcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcclxuXHJcblx0XHRcdFx0eGdyaWRMaW5lc1xyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxyXG5cdFx0XHRdKTtcclxuXHJcblx0XHRcdGd0LmNhbGwod2FpdCwgKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0XHRcdC8vIHJlbW92ZSBmbG93ZWQgZWxlbWVudHNcclxuXHRcdFx0XHRpZiAoZmxvd0xlbmd0aCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdGFyZ2V0OiBhbnkgPSB7XHJcblx0XHRcdFx0XHRcdHNoYXBlczogW10sXHJcblx0XHRcdFx0XHRcdHRleHRzOiBbXSxcclxuXHRcdFx0XHRcdFx0ZXZlbnRSZWN0czogW11cclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBmbG93TGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dGFyZ2V0LnNoYXBlcy5wdXNoKGAuJHtDTEFTUy5zaGFwZX0tJHtpfWApO1xyXG5cdFx0XHRcdFx0XHR0YXJnZXQudGV4dHMucHVzaChgLiR7Q0xBU1MudGV4dH0tJHtpfWApO1xyXG5cdFx0XHRcdFx0XHR0YXJnZXQuZXZlbnRSZWN0cy5wdXNoKGAuJHtDTEFTUy5ldmVudFJlY3R9LSR7aX1gKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRbXCJzaGFwZXNcIiwgXCJ0ZXh0c1wiLCBcImV2ZW50UmVjdHNcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdFx0JGVsLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTW3ZdfWApXHJcblx0XHRcdFx0XHRcdFx0LnNlbGVjdEFsbCh0YXJnZXRbdl0pXHJcblx0XHRcdFx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdFx0JGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLnhncmlkfWApXHJcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGRyYXcgYWdhaW4gZm9yIHJlbW92aW5nIGZsb3dlZCBlbGVtZW50cyBhbmQgcmV2ZXJ0aW5nIGF0dHJcclxuXHRcdFx0XHR4Z3JpZC5zaXplKCkgJiYgeGdyaWRcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXHJcblx0XHRcdFx0XHQuYXR0cihzdGF0ZS54Z3JpZEF0dHIpO1xyXG5cclxuXHRcdFx0XHR4Z3JpZExpbmVzXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKTtcclxuXHJcblx0XHRcdFx0eGdyaWRMaW5lcy5zZWxlY3QoXCJsaW5lXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiB4dilcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiB4dik7XHJcblxyXG5cdFx0XHRcdHhncmlkTGluZXMuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogMClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB4dik7XHJcblxyXG5cdFx0XHRcdG1haW5CYXJcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0Jhcik7XHJcblxyXG5cdFx0XHRcdG1haW5MaW5lXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdMaW5lKTtcclxuXHJcblx0XHRcdFx0bWFpbkFyZWFcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpO1xyXG5cclxuXHRcdFx0XHRtYWluQ2lyY2xlXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKTtcclxuXHJcblx0XHRcdFx0aWYgKCQkLmlzQ2lyY2xlUG9pbnQoKSkge1xyXG5cdFx0XHRcdFx0bWFpbkNpcmNsZVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImN4XCIsIGN4KVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImN5XCIsIGN5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc3QgeEZ1bmMgPSBkID0+IGN4KGQpIC0gY29uZmlnLnBvaW50X3I7XHJcblx0XHRcdFx0XHRjb25zdCB5RnVuYyA9IGQgPT4gY3koZCkgLSBjb25maWcucG9pbnRfcjtcclxuXHJcblx0XHRcdFx0XHRtYWluQ2lyY2xlXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwieFwiLCB4RnVuYylcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGdW5jKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImN4XCIsIGN4KSAvLyB3aGVuIHBhdHRlcm4gaXMgdXNlZCwgaXQgcG9zc2libHkgY29udGFpbiAnY2lyY2xlJyBhbHNvLlxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImN5XCIsIGN5KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG1haW5UZXh0XHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhGb3JUZXh0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JUZXh0KVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpKTtcclxuXHJcblx0XHRcdFx0bWFpblJlZ2lvblxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XHJcblxyXG5cdFx0XHRcdG1haW5SZWdpb24uc2VsZWN0KFwicmVjdFwiKS5maWx0ZXIoJCQuaXNSZWdpb25PblgpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpO1xyXG5cclxuXHRcdFx0XHRjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiAkJC5yZWRyYXdFdmVudFJlY3QoKTtcclxuXHJcblx0XHRcdFx0Ly8gY2FsbGJhY2sgZm9yIGVuZCBvZiBmbG93XHJcblx0XHRcdFx0ZG9uZSgpO1xyXG5cclxuXHRcdFx0XHRzdGF0ZS5mbG93aW5nID0gZmFsc2U7XHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzQm9vbGVhbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxyXG5cdCAqIEFkZCBhIGNvbnRhaW5lciBmb3IgdGhlIHpvbmUgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRFdmVudFJlY3QoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmV2ZW50UmVjdHMpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3cyB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3RXZlbnRSZWN0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xyXG5cdFx0bGV0IGV2ZW50UmVjdFVwZGF0ZTtcclxuXHJcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XHJcblx0XHRjb25zdCBldmVudFJlY3RzID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3RzfWApXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCB6b29tRW5hYmxlZCAmJiB6b29tRW5hYmxlZC50eXBlICE9PSBcImRyYWdcIiA/IChcclxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJucy1yZXNpemVcIiA6IFwiZXctcmVzaXplXCJcclxuXHRcdFx0KSA6IG51bGwpXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNNdWx0aXBsZSwgaXNNdWx0aXBsZVgpXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNTaW5nbGUsICFpc011bHRpcGxlWCk7XHJcblxyXG5cdFx0Ly8gY2xlYXIgb2xkIHJlY3RzXHJcblx0XHRldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIG9wZW4gYXMgcHVibGljIGNvbnN0aWFibGVcclxuXHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApO1xyXG5cclxuXHRcdGlmIChpc011bHRpcGxlWCkge1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkZWwuZXZlbnRSZWN0LmRhdGEoWzBdKTtcclxuXHRcdFx0Ly8gdXBkYXRlXHJcblx0XHRcdC8vIGVudGVyOiBvbmx5IG9uZSByZWN0IHdpbGwgYmUgYWRkZWRcclxuXHRcdFx0Ly8gZXhpdDogbm90IG5lZWRlZCBiZWNhdXNlIGFsd2F5cyBvbmx5IG9uZSByZWN0IGV4aXN0c1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdFVwZGF0ZS5lbnRlcigpKVxyXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gU2V0IGRhdGEgYW5kIHVwZGF0ZSAkZWwuZXZlbnRSZWN0XHJcblx0XHRcdGNvbnN0IHhBeGlzVGlja1ZhbHVlcyA9ICQkLmdldE1heERhdGFDb3VudFRhcmdldCgpO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGRhdGEncyBpbmRleCB2YWx1ZSB0byBiZSBhbGluZ2VkIHdpdGggdGhlIHggQXhpc1xyXG5cdFx0XHQkJC51cGRhdGVEYXRhSW5kZXhCeVgoeEF4aXNUaWNrVmFsdWVzKTtcclxuXHRcdFx0JCQudXBkYXRlWHMoeEF4aXNUaWNrVmFsdWVzKTtcclxuXHRcdFx0JCQudXBkYXRlUG9pbnRDbGFzcyh0cnVlKTtcclxuXHJcblx0XHRcdGV2ZW50UmVjdHMuZGF0dW0oeEF4aXNUaWNrVmFsdWVzKTtcclxuXHJcblx0XHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApO1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkZWwuZXZlbnRSZWN0LmRhdGEoZCA9PiBkKTtcclxuXHJcblx0XHRcdC8vIGV4aXRcclxuXHRcdFx0ZXZlbnRSZWN0VXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZVxyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdFVwZGF0ZS5lbnRlcigpKVxyXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RVcGRhdGU7XHJcblx0XHQkJC51cGRhdGVFdmVudFJlY3QoZXZlbnRSZWN0VXBkYXRlKTtcclxuXHJcblx0XHRpZiAoJCQuc3RhdGUuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgISRlbC5zdmcub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdFwiKSAmJiAhJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdCQkLmJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRiaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0RXZlbnRSZWN0ID0gKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB0b3VjaCA9IGQzRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblxyXG5cdFx0XHRyZXR1cm4gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGdldEluZGV4ID0gZXZlbnRSZWN0ID0+IHtcclxuXHRcdFx0bGV0IGluZGV4ID0gZXZlbnRSZWN0ICYmIGV2ZW50UmVjdC5hdHRyKFwiY2xhc3NcIikgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKVxyXG5cdFx0XHRcdC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke0NMQVNTLmV2ZW50UmVjdH0tP3xzKWAsIFwiZ1wiKSwgXCJcIikgKiAxO1xyXG5cclxuXHRcdFx0aWYgKGlzTmFOKGluZGV4KSB8fCBpbmRleCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdGluZGV4ID0gLTE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpbmRleDtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3Qgc2VsZWN0UmVjdCA9IGNvbnRleHQgPT4ge1xyXG5cdFx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcclxuXHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyhjb250ZXh0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KGV2ZW50UmVjdCk7XHJcblxyXG5cdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRpbmRleCA9PT0gLTEgP1xyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOlxyXG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvclNpbmdsZShjb250ZXh0LCBldmVudFJlY3QsIGluZGV4KTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0KClcclxuXHRcdC8vIGFjY29yZGluZyAnaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoLnByZXZlbnREZWZhdWx0JyBvcHRpb25cclxuXHRcdGNvbnN0IHByZXZlbnREZWZhdWx0ID0gY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaC5wcmV2ZW50RGVmYXVsdDtcclxuXHRcdGNvbnN0IGlzUHJldmVudGVkID0gKGlzQm9vbGVhbihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IGZhbHNlO1xyXG5cdFx0Y29uc3QgcHJldmVudFRocmVzaG9sZCA9ICghaXNOYU4ocHJldmVudERlZmF1bHQpICYmIHByZXZlbnREZWZhdWx0KSB8fCBudWxsO1xyXG5cdFx0bGV0IHN0YXJ0UHg7XHJcblxyXG5cdFx0Y29uc3QgcHJldmVudEV2ZW50ID0gZXZlbnQgPT4ge1xyXG5cdFx0XHRjb25zdCBldmVudFR5cGUgPSBldmVudC50eXBlO1xyXG5cdFx0XHRjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRjb25zdCBjdXJyZW50WFkgPSB0b3VjaFtgY2xpZW50JHtjb25maWcuYXhpc19yb3RhdGVkID8gXCJZXCIgOiBcIlhcIn1gXTtcclxuXHJcblx0XHRcdC8vIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nXHJcblx0XHRcdGlmIChldmVudFR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XHJcblx0XHRcdFx0aWYgKGlzUHJldmVudGVkKSB7XHJcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAocHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0c3RhcnRQeCA9IGN1cnJlbnRYWTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInRvdWNobW92ZVwiKSB7XHJcblx0XHRcdFx0aWYgKGlzUHJldmVudGVkIHx8IHN0YXJ0UHggPT09IHRydWUgfHwgKFxyXG5cdFx0XHRcdFx0cHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhzdGFydFB4IC0gY3VycmVudFhZKSA+PSBwcmV2ZW50VGhyZXNob2xkXHJcblx0XHRcdFx0KSkge1xyXG5cdFx0XHRcdFx0Ly8gb25jZSBwcmV2ZW50ZWQsIGtlZXAgcHJldmVudGVkIGR1cmluZyB3aG9sZSAndG91Y2htb3ZlJyBjb250ZXh0XHJcblx0XHRcdFx0XHRzdGFydFB4ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGJpbmQgdG91Y2ggZXZlbnRzXHJcblx0XHQkJC4kZWwuc3ZnXHJcblx0XHRcdC5vbihcInRvdWNoc3RhcnQuZXZlbnRSZWN0IHRvdWNobW92ZS5ldmVudFJlY3RcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgZXZlbnRSZWN0ID0gZ2V0RXZlbnRSZWN0KCk7XHJcblx0XHRcdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xyXG5cclxuXHRcdFx0XHRpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdCkpIHtcclxuXHRcdFx0XHRcdC8vIGlmIHRvdWNoIHBvaW50cyBhcmUgPiAxLCBtZWFucyBkb2luZyB6b29taW5nIGludGVyYWN0aW9uLiBJbiB0aGlzIGNhc2UgZG8gbm90IGV4ZWN1dGUgdG9vbHRpcCBjb2Rlcy5cclxuXHRcdFx0XHRcdGlmIChzdGF0ZS5kcmFnZ2luZyB8fCBzdGF0ZS5mbG93aW5nIHx8ICQkLmhhc0FyY1R5cGUoKSB8fCBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHByZXZlbnRFdmVudChldmVudCk7XHJcblx0XHRcdFx0XHRzZWxlY3RSZWN0KHRoaXMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIHRydWUpXHJcblx0XHRcdC5vbihcInRvdWNoZW5kLmV2ZW50UmVjdFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgZXZlbnRSZWN0ID0gZ2V0RXZlbnRSZWN0KCk7XHJcblxyXG5cdFx0XHRcdGlmICghZXZlbnRSZWN0LmVtcHR5KCkgJiYgZXZlbnRSZWN0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0KSkge1xyXG5cdFx0XHRcdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhJCQudG9nZ2xlU2hhcGUgfHwgc3RhdGUuY2FuY2VsQ2xpY2spIHtcclxuXHRcdFx0XHRcdFx0c3RhdGUuY2FuY2VsQ2xpY2sgJiYgKHN0YXRlLmNhbmNlbENsaWNrID0gZmFsc2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGUgbG9jYXRpb24gYW5kIHNpemUgb2YgdGhlIGV2ZW50UmVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdHVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHhTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdERhdGEgPSBldmVudFJlY3RVcGRhdGUgfHwgJCQuJGVsLmV2ZW50UmVjdC5kYXRhKCk7IC8vIHNldCB1cGRhdGUgc2VsZWN0aW9uIGlmIG51bGxcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgeDtcclxuXHRcdGxldCB5O1xyXG5cdFx0bGV0IHc7XHJcblx0XHRsZXQgaDtcclxuXHJcblx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHQvLyBUT0RPOiByb3RhdGVkIG5vdCBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdHggPSAwO1xyXG5cdFx0XHR5ID0gMDtcclxuXHRcdFx0dyA9IHN0YXRlLndpZHRoO1xyXG5cdFx0XHRoID0gc3RhdGUuaGVpZ2h0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IHJlY3RXO1xyXG5cdFx0XHRsZXQgcmVjdFg7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdFx0cmVjdFcgPSAkJC5nZXRFdmVudFJlY3RXaWR0aCgpO1xyXG5cdFx0XHRcdHJlY3RYID0gZCA9PiB4U2NhbGUoZC54KSAtIChyZWN0VyAvIDIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IGdldFByZXZOZXh0WCA9IGQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBkLmluZGV4O1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHByZXY6ICQkLmdldFByZXZYKGluZGV4KSxcclxuXHRcdFx0XHRcdFx0bmV4dDogJCQuZ2V0TmV4dFgoaW5kZXgpXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJlY3RXID0gZCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB4ID0gZ2V0UHJldk5leHRYKGQpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIHRoaXMgaXMgYSBzaW5nbGUgZGF0YSBwb2ludCBtYWtlIHRoZSBldmVudFJlY3QgZnVsbCB3aWR0aCAob3IgaGVpZ2h0KVxyXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCA6IHN0YXRlLndpZHRoO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0eC5wcmV2ID0geFNjYWxlLmRvbWFpbigpWzBdO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh4Lm5leHQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0eC5uZXh0ID0geFNjYWxlLmRvbWFpbigpWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heCgwLCAoeFNjYWxlKHgubmV4dCkgLSB4U2NhbGUoeC5wcmV2KSkgLyAyKTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRyZWN0WCA9IGQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IGdldFByZXZOZXh0WChkKTtcclxuXHRcdFx0XHRcdGNvbnN0IHRoaXNYID0gZC54O1xyXG5cclxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIHRoaXMgaXMgYSBzaW5nbGUgZGF0YSBwb2ludCBwb3NpdGlvbiB0aGUgZXZlbnRSZWN0IGF0IDBcclxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwgJiYgeC5uZXh0ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0eC5wcmV2ID0geFNjYWxlLmRvbWFpbigpWzBdO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiAoeFNjYWxlKHRoaXNYKSArIHhTY2FsZSh4LnByZXYpKSAvIDI7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiByZWN0WDtcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IHJlY3RYIDogMDtcclxuXHRcdFx0dyA9IGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogcmVjdFc7XHJcblx0XHRcdGggPSBpc1JvdGF0ZWQgPyByZWN0VyA6IHN0YXRlLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRldmVudFJlY3REYXRhLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0V2ZW50LmJpbmQoJCQpKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgeClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgdylcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaCk7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0UmVjdEZvclNpbmdsZShjb250ZXh0LCBldmVudFJlY3QsIGluZGV4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzU2VsZWN0aW9uRW5hYmxlZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkO1xyXG5cdFx0Y29uc3QgaXNTZWxlY3Rpb25Hcm91cGVkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ7XHJcblx0XHRjb25zdCBpc1Rvb2x0aXBHcm91cGVkID0gY29uZmlnLnRvb2x0aXBfZ3JvdXBlZDtcclxuXHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9ICQkLmdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXgpO1xyXG5cclxuXHRcdGlmIChpc1Rvb2x0aXBHcm91cGVkKSB7XHJcblx0XHRcdCQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgY29udGV4dCk7XHJcblx0XHRcdCQkLnNob3dHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHRcdGlmICghaXNTZWxlY3Rpb25FbmFibGVkIHx8IGlzU2VsZWN0aW9uR3JvdXBlZCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtpbmRleH1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcclxuXHJcblx0XHRcdFx0aWYgKGlzU2VsZWN0aW9uRW5hYmxlZCkge1xyXG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIGlzU2VsZWN0aW9uR3JvdXBlZCA/IFwicG9pbnRlclwiIDogbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIWlzVG9vbHRpcEdyb3VwZWQpIHtcclxuXHRcdFx0XHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHRcdFx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblxyXG5cdFx0XHRcdFx0IWlzU2VsZWN0aW9uR3JvdXBlZCAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhpbmRleCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhbGwoc2VsZWN0ZWQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGQgPSBzZWxlY3RlZC5kYXRhKCk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1NlbGVjdGlvbkVuYWJsZWQgJiYgKGlzU2VsZWN0aW9uR3JvdXBlZCB8fCBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpKSkge1xyXG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICghaXNUb29sdGlwR3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0JCQuc2hvd1Rvb2x0aXAoZCwgY29udGV4dCk7XHJcblx0XHRcdFx0XHQkJC5zaG93R3JpZEZvY3VzKGQpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cdFx0XHRcdFx0c2VsZWN0ZWQuZWFjaChkID0+ICQkLmV4cGFuZENpcmNsZXNCYXJzKGluZGV4LCBkLmlkKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRleHBhbmRDaXJjbGVzQmFycyhpbmRleCwgaWQsIHJlc2V0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCAmJlxyXG5cdFx0XHQkJC5leHBhbmRDaXJjbGVzKGluZGV4LCBpZCwgcmVzZXQpO1xyXG5cclxuXHRcdCQkLmV4cGFuZEJhcnMoaW5kZXgsIGlkLCByZXNldCk7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0UmVjdEZvck11bHRpcGxlWHMoY29udGV4dCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdC8vIGRvIG5vdGhpbmcgd2hlbiBkcmFnZ2luZ1xyXG5cdFx0aWYgKCQkLmRyYWdnaW5nIHx8ICQkLmhhc0FyY1R5cGUodGFyZ2V0c1RvU2hvdykpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1vdXNlID0gZDNNb3VzZShjb250ZXh0KTtcclxuXHRcdGNvbnN0IGNsb3Nlc3QgPSAkJC5maW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHNUb1Nob3csIG1vdXNlKTtcclxuXHJcblx0XHRpZiAoc3RhdGUubW91c2VvdmVyICYmICghY2xvc2VzdCB8fCBjbG9zZXN0LmlkICE9PSBzdGF0ZS5tb3VzZW92ZXIuaWQpKSB7XHJcblx0XHRcdGNvbmZpZy5kYXRhX29ub3V0LmNhbGwoJCQuYXBpLCBzdGF0ZS5tb3VzZW92ZXIpO1xyXG5cdFx0XHRzdGF0ZS5tb3VzZW92ZXIgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjbG9zZXN0KSB7XHJcblx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgc2FtZVhEYXRhID0gKFxyXG5cdFx0XHQkJC5pc0J1YmJsZVR5cGUoY2xvc2VzdCkgfHwgJCQuaXNTY2F0dGVyVHlwZShjbG9zZXN0KSB8fCAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZFxyXG5cdFx0KSA/IFtjbG9zZXN0XSA6ICQkLmZpbHRlckJ5WCh0YXJnZXRzVG9TaG93LCBjbG9zZXN0LngpO1xyXG5cclxuXHRcdC8vIHNob3cgdG9vbHRpcCB3aGVuIGN1cnNvciBpcyBjbG9zZSB0byBzb21lIHBvaW50XHJcblx0XHRjb25zdCBzZWxlY3RlZERhdGEgPSBzYW1lWERhdGEubWFwKGQgPT4gJCQuYWRkTmFtZShkKSk7XHJcblxyXG5cdFx0JCQuc2hvd1Rvb2x0aXAoc2VsZWN0ZWREYXRhLCBjb250ZXh0KTtcclxuXHJcblx0XHQvLyBleHBhbmQgcG9pbnRzXHJcblx0XHQkJC5leHBhbmRDaXJjbGVzQmFycyhjbG9zZXN0LmluZGV4LCBjbG9zZXN0LmlkLCB0cnVlKTtcclxuXHJcblx0XHQvLyBTaG93IHhncmlkIGZvY3VzIGxpbmVcclxuXHRcdCQkLnNob3dHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHQvLyBTaG93IGN1cnNvciBhcyBwb2ludGVyIGlmIHBvaW50IGlzIGNsb3NlIHRvIG1vdXNlIHBvc2l0aW9uXHJcblx0XHRpZiAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSB7XHJcblx0XHRcdCQkLiRlbC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3R9YCkuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpO1xyXG5cclxuXHRcdFx0aWYgKCFzdGF0ZS5tb3VzZW92ZXIpIHtcclxuXHRcdFx0XHRjb25maWcuZGF0YV9vbm92ZXIuY2FsbCgkJC5hcGksIGNsb3Nlc3QpO1xyXG5cdFx0XHRcdHN0YXRlLm1vdXNlb3ZlciA9IGNsb3Nlc3Q7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbnNlbGVjdCBFdmVudFJlY3QuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1bnNlbGVjdFJlY3QoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5zdHlsZShcImN1cnNvclwiLCBudWxsKTtcclxuXHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKGZhbHNlKTtcclxuXHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cdFx0JCQudW5leHBhbmRCYXJzKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ3JlYXRlIGV2ZW50UmVjdCBmb3IgZWFjaCBkYXRhIG9uIHRoZSB4LWF4aXMuXHJcblx0ICogUmVnaXN0ZXIgdG91Y2ggYW5kIGRyYWcgZXZlbnRzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICogQHJldHVybnMge09iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKi9cclxuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdEVudGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCByZWN0ID0gZXZlbnRSZWN0RW50ZXIuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzRXZlbnQuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/IFwicG9pbnRlclwiIDogbnVsbClcclxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvclNpbmdsZVguYmluZCh0aGlzKShkLCAkJCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaW5wdXRUeXBlID09PSBcIm1vdXNlXCIpIHtcclxuXHRcdFx0cmVjdFxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlclwiLCBkID0+IHtcclxuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmcgd2hpbGUgZHJhZ2dpbmcvZmxvd2luZ1xyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLmRyYWdnaW5nIHx8IHN0YXRlLmZsb3dpbmcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25maWcudG9vbHRpcF9ncm91cGVkICYmICQkLnNldE92ZXJPdXQodHJ1ZSwgZC5pbmRleCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXHJcblx0XHRcdFx0XHRpZiAoc3RhdGUuZHJhZ2dpbmcgfHwgc3RhdGUuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxldCBpbmRleCA9IGQuaW5kZXg7XHJcblx0XHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSAkJC4kZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWApO1xyXG5cclxuXHRcdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpICYmXHJcblx0XHRcdFx0XHRcdGNvbmZpZy5saW5lX3N0ZXBfdHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiZcclxuXHRcdFx0XHRcdFx0ZDNNb3VzZSh0aGlzKVswXSA8ICQkLnNjYWxlLngoJCQuZ2V0WFZhbHVlKGQuaWQsIGluZGV4KSlcclxuXHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRpbmRleCAtPSAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGluZGV4ID09PSAtMSA/XHJcblx0XHRcdFx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpIDogJCQuc2VsZWN0UmVjdEZvclNpbmdsZSh0aGlzLCBldmVudFJlY3QsIGluZGV4KTtcclxuXHJcblx0XHRcdFx0XHQvLyBBcyBvZiBpbmRpdmlkdWFsIGRhdGEgcG9pbnQob3IgPHBhdGg+KSBlbGVtZW50IGNhbid0IGJpbmQgbW91c2VvdmVyL291dCBldmVudFxyXG5cdFx0XHRcdFx0Ly8gdG8gZGV0ZXJtaW5lIGN1cnJlbnQgaW50ZXJhY3RpbmcgZWxlbWVudCwgc28gdXNlICdtb3VzZW1vdmUnIGV2ZW50IGluc3RlYWQuXHJcblx0XHRcdFx0XHRpZiAoIWNvbmZpZy50b29sdGlwX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRcdFx0JCQuc2V0T3Zlck91dChpbmRleCAhPT0gLTEsIGQuaW5kZXgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgZCA9PiB7XHJcblx0XHRcdFx0XHQvLyBjaGFydCBpcyBkZXN0cm95ZWRcclxuXHRcdFx0XHRcdGlmICghY29uZmlnIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBkLmluZGV4KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHRjbGlja0hhbmRsZXJGb3JTaW5nbGVYKGQsIGN0eCkge1xyXG5cdFx0Y29uc3QgJCQgPSBjdHg7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICEkJC50b2dnbGVTaGFwZSB8fCBzdGF0ZS5jYW5jZWxDbGljaykge1xyXG5cdFx0XHRzdGF0ZS5jYW5jZWxDbGljayAmJiAoc3RhdGUuY2FuY2VsQ2xpY2sgPSBmYWxzZSk7XHJcblxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaW5kZXggPSBkLmluZGV4O1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7aW5kZXh9YClcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZDIpIHtcclxuXHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkMikpIHtcclxuXHRcdFx0XHRcdCQkLnRvZ2dsZVNoYXBlKHRoaXMsIGQyLCBpbmRleCk7XHJcblx0XHRcdFx0XHRjb25maWcuZGF0YV9vbmNsaWNrLmNhbGwoJCQuYXBpLCBkMiwgdGhpcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgYW4gZXZlbnRSZWN0LFxyXG5cdCAqIFJlZ2lzdGVyIHRvdWNoIGFuZCBkcmFnIGV2ZW50cy5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICovXHJcblx0Z2VuZXJhdGVFdmVudFJlY3RzRm9yTXVsdGlwbGVYcyhldmVudFJlY3RFbnRlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHQsIGlucHV0VHlwZX0gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRjb25zdCByZWN0ID0gZXZlbnRSZWN0RW50ZXJcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIDApXHJcblx0XHRcdC5hdHRyKFwieVwiLCAwKVxyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIHdpZHRoKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBoZWlnaHQpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZXZlbnRSZWN0KVxyXG5cdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTLmJpbmQodGhpcykoJCQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuY2FsbCgkJC5nZXREcmFnZ2FibGVTZWxlY3Rpb24oKSk7XHJcblxyXG5cdFx0aWYgKGlucHV0VHlwZSA9PT0gXCJtb3VzZVwiKSB7XHJcblx0XHRcdHJlY3RcclxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXIgbW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvck11bHRpcGxlWHModGhpcyk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHQvLyBjaGFydCBpcyBkZXN0cm95ZWRcclxuXHRcdFx0XHRcdGlmICghJCQuY29uZmlnIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlY3Q7XHJcblx0fSxcclxuXHJcblx0Y2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUyhjdHgpIHtcclxuXHRcdGNvbnN0ICQkID0gY3R4O1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUodGFyZ2V0c1RvU2hvdykpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1vdXNlID0gZDNNb3VzZSh0aGlzKTtcclxuXHRcdGNvbnN0IGNsb3Nlc3QgPSAkJC5maW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHNUb1Nob3csIG1vdXNlKTtcclxuXHJcblx0XHRpZiAoIWNsb3Nlc3QpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNlbGVjdCBpZiBzZWxlY3Rpb24gZW5hYmxlZFxyXG5cdFx0aWYgKCQkLmlzQmFyVHlwZShjbG9zZXN0LmlkKSB8fCAkJC5kaXN0KGNsb3Nlc3QsIG1vdXNlKSA8IGNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSkge1xyXG5cdFx0XHQkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGNsb3Nlc3QuaWQpfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9LSR7Y2xvc2VzdC5pbmRleH1gKVxyXG5cdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkIHx8ICQkLmlzV2l0aGluU2hhcGUodGhpcywgY2xvc2VzdCkpIHtcclxuXHRcdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUodGhpcywgY2xvc2VzdCwgY2xvc2VzdC5pbmRleCk7XHJcblx0XHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGNsb3Nlc3QsIHRoaXMpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge1xyXG5cdGJydXNoWCBhcyBkM0JydXNoWCxcclxuXHRicnVzaFkgYXMgZDNCcnVzaFksXHJcblx0YnJ1c2hTZWxlY3Rpb24gYXMgZDNCcnVzaFNlbGVjdGlvblxyXG59IGZyb20gXCJkMy1icnVzaFwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7YnJ1c2hFbXB0eSwgY2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgZ2V0UmFuZG9tfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBicnVzaC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRCcnVzaCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCAkZWw6IHtjb250ZXh0fX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Ly8gc2V0IHRoZSBicnVzaFxyXG5cdFx0JCQuYnJ1c2ggPSBpc1JvdGF0ZWQgPyBkM0JydXNoWSgpIDogZDNCcnVzaFgoKTtcclxuXHJcblx0XHQvLyBzZXQgXCJicnVzaFwiIGV2ZW50XHJcblx0XHRjb25zdCBicnVzaEhhbmRsZXIgPSAoKSA9PiB7XHJcblx0XHRcdCQkLnJlZHJhd0ZvckJydXNoKCk7XHJcblx0XHR9O1xyXG5cdFx0Y29uc3QgZ2V0QnJ1c2hTaXplID0gKCkgPT4ge1xyXG5cdFx0XHRjb25zdCBicnVzaCA9ICQkLiRlbC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5icnVzaH0gLm92ZXJsYXlgKTtcclxuXHRcdFx0Y29uc3QgYnJ1c2hTaXplID0ge3dpZHRoOiAwLCBoZWlnaHQ6IDB9O1xyXG5cclxuXHRcdFx0aWYgKGJydXNoLnNpemUoKSkge1xyXG5cdFx0XHRcdGJydXNoU2l6ZS53aWR0aCA9ICticnVzaC5hdHRyKFwid2lkdGhcIik7XHJcblx0XHRcdFx0YnJ1c2hTaXplLmhlaWdodCA9ICticnVzaC5hdHRyKFwiaGVpZ2h0XCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gYnJ1c2hTaXplW2lzUm90YXRlZCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdO1xyXG5cdFx0fTtcclxuXHJcblx0XHRsZXQgbGFzdERvbWFpbjtcclxuXHRcdGxldCB0aW1lb3V0O1xyXG5cclxuXHRcdCQkLmJydXNoXHJcblx0XHRcdC5vbihcInN0YXJ0XCIsICgpID0+IHtcclxuXHRcdFx0XHQkJC5zdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIiAmJiAkJC5oaWRlVG9vbHRpcCgpO1xyXG5cdFx0XHRcdGJydXNoSGFuZGxlcigpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQub24oXCJicnVzaFwiLCBicnVzaEhhbmRsZXIpXHJcblx0XHRcdC5vbihcImVuZFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0bGFzdERvbWFpbiA9IHNjYWxlLngub3JnRG9tYWluKCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdCQkLmJydXNoLnVwZGF0ZVJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0aW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuXHRcdFx0dGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XHJcblxyXG5cdFx0XHRcdGxhc3REb21haW4gJiYgZDNCcnVzaFNlbGVjdGlvbihzZWxlY3Rpb24ubm9kZSgpKSAmJlxyXG5cdFx0XHRcdFx0dGhpcy5tb3ZlKHNlbGVjdGlvbiwgbGFzdERvbWFpbi5tYXAoc2NhbGUuc3ViWC5vcmdTY2FsZSgpKSk7XHJcblx0XHRcdH0sIDApO1xyXG5cdFx0fTtcclxuXHJcblx0XHQkJC5icnVzaC51cGRhdGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgZXh0ZW50ID0gdGhpcy5leHRlbnQoKSgpO1xyXG5cclxuXHRcdFx0aWYgKGV4dGVudFsxXS5maWx0ZXIodiA9PiBpc05hTih2KSkubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9YCkuY2FsbCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIHNldCB0aGUgYnJ1c2ggZXh0ZW50XHJcblx0XHQkJC5icnVzaC5zY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XHJcblx0XHRcdGNvbnN0IGggPSBjb25maWcuc3ViY2hhcnRfc2l6ZV9oZWlnaHQgfHwgZ2V0QnJ1c2hTaXplKCk7XHJcblx0XHRcdGxldCBleHRlbnQgPSAkJC5nZXRFeHRlbnQoKTtcclxuXHJcblx0XHRcdGlmICghZXh0ZW50ICYmIHNjYWxlLnJhbmdlKSB7XHJcblx0XHRcdFx0ZXh0ZW50ID0gW1swLCAwXSwgW3NjYWxlLnJhbmdlKClbMV0sIGhdXTtcclxuXHRcdFx0fSBlbHNlIGlmIChpc0FycmF5KGV4dGVudCkpIHtcclxuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKCh2LCBpKSA9PiBbdiwgaSA+IDAgPyBoIDogaV0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBbW3gwLCB5MF0sIFt4MSwgeTFdXSwgd2hlcmUgW3gwLCB5MF0gaXMgdGhlIHRvcC1sZWZ0IGNvcm5lciBhbmQgW3gxLCB5MV0gaXMgdGhlIGJvdHRvbS1yaWdodCBjb3JuZXJcclxuXHRcdFx0aXNSb3RhdGVkICYmIGV4dGVudFsxXS5yZXZlcnNlKCk7XHJcblx0XHRcdHRoaXMuZXh0ZW50KGV4dGVudCk7XHJcblxyXG5cdFx0XHQvLyB3aGVuIGV4dGVudCB1cGRhdGVzLCBicnVzaCBzZWxlY3Rpb24gYWxzbyBiZSByZS1hcHBsaWVkXHJcblx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy9pc3N1ZXMvMjkxOFxyXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0fTtcclxuXHJcblx0XHQkJC5icnVzaC5nZXRTZWxlY3Rpb24gPSAoKSA9PiAoXHJcblx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0Y29udGV4dCA/IGNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKSA6IGQzU2VsZWN0KFtdKVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBzdWJjaGFydC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRTdWJjaGFydCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y2xpcH0sICRlbDoge2RlZnMsIHN2Zywgc3ViY2hhcnQsIGF4aXN9fSA9ICQkO1xyXG5cdFx0Y29uc3QgdmlzaWJpbGl0eSA9IGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiO1xyXG5cdFx0Y29uc3QgY2xpcElkID0gYCR7Y2xpcC5pZH0tc3ViY2hhcnRgO1xyXG5cdFx0Y29uc3QgY2xpcFBhdGggPSAkJC5nZXRDbGlwUGF0aChjbGlwSWQpO1xyXG5cclxuXHRcdGNsaXAuaWRTdWJjaGFydCA9IGNsaXBJZDtcclxuXHRcdCQkLmFwcGVuZENsaXAoZGVmcywgY2xpcElkKTtcclxuXHRcdCQkLmluaXRCcnVzaCgpO1xyXG5cclxuXHRcdHN1YmNoYXJ0Lm1haW4gPSBzdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImNvbnRleHRcIikpO1xyXG5cclxuXHRcdGNvbnN0IHttYWlufSA9IHN1YmNoYXJ0O1xyXG5cclxuXHRcdG1haW4uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIHZpc2liaWxpdHkpO1xyXG5cclxuXHRcdC8vIERlZmluZSBnIGZvciBjaGFydCBhcmVhXHJcblx0XHRtYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcFBhdGgpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnQpO1xyXG5cclxuXHRcdC8vIERlZmluZSBnIGZvciBiYXIgY2hhcnQgYXJlYVxyXG5cdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiBtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEJhcnMpO1xyXG5cclxuXHRcdC8vIERlZmluZSBnIGZvciBsaW5lIGNoYXJ0IGFyZWFcclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0TGluZXMpO1xyXG5cclxuXHRcdC8vIEFkZCBleHRlbnQgcmVjdCBmb3IgQnJ1c2hcclxuXHRcdG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwUGF0aClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5icnVzaClcclxuXHRcdFx0LmNhbGwoJCQuYnJ1c2gpO1xyXG5cclxuXHRcdC8vIEFUVEVOVElPTjogVGhpcyBtdXN0IGJlIGNhbGxlZCBBRlRFUiBjaGFydCBhZGRlZFxyXG5cdFx0Ly8gQWRkIEF4aXNcclxuXHRcdGF4aXMuc3ViWCA9IG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXNYKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJzdWJYXCIpKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gXCJcIiA6IGNsaXAucGF0aFhBeGlzKVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5zdWJjaGFydF9heGlzX3hfc2hvdyA/IHZpc2liaWxpdHkgOiBcImhpZGRlblwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgc3ViIGNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gJCQuZGF0YS50YXJnZXRzXHJcblx0ICovXHJcblx0dXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtzdWJjaGFydDoge21haW59fX0gPSAkJDtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRCYXIgPSAkJC5jbGFzc0NoYXJ0QmFyLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NCYXJzID0gJCQuY2xhc3NCYXJzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydExpbmUgPSAkJC5jbGFzc0NoYXJ0TGluZS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NBcmVhcyA9ICQkLmNsYXNzQXJlYXMuYmluZCgkJCk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5zdWJjaGFydF9zaG93KSB7XHJcblx0XHRcdC8vIC0tIEJhciAtLS8vXHJcblx0XHRcdGNvbnN0IGJhclVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEJhcnN9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEJhcn1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKTtcclxuXHRcdFx0Y29uc3QgYmFyRW50ZXIgPSBiYXJVcGRhdGUuZW50ZXIoKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXHJcblx0XHRcdFx0Lm1lcmdlKGJhclVwZGF0ZSk7XHJcblxyXG5cdFx0XHQvLyBCYXJzIGZvciBlYWNoIGRhdGFcclxuXHRcdFx0YmFyRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXJzKTtcclxuXHJcblx0XHRcdC8vIC0tIExpbmUgLS0vL1xyXG5cdFx0XHRjb25zdCBsaW5lVXBkYXRlID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0TGluZXN9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydExpbmV9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpO1xyXG5cdFx0XHRjb25zdCBsaW5lRW50ZXIgPSBsaW5lVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0TGluZSlcclxuXHRcdFx0XHQubWVyZ2UobGluZVVwZGF0ZSk7XHJcblxyXG5cdFx0XHQvLyBMaW5lcyBmb3IgZWFjaCBkYXRhXHJcblx0XHRcdGxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcclxuXHJcblx0XHRcdC8vIEFyZWFcclxuXHRcdFx0JCQuaGFzVHlwZShcImFyZWFcIikgJiYgbGluZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXJlYXMpO1xyXG5cclxuXHRcdFx0Ly8gLS0gQnJ1c2ggLS0vL1xyXG5cdFx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYnJ1c2h9IHJlY3RgKVxyXG5cdFx0XHRcdC5hdHRyKGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gc3RhdGUud2lkdGgyIDogc3RhdGUuaGVpZ2h0Mik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHRoZSBiYXIgb2YgdGhlIHN1YiBjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGR1cmF0aW9uRm9yRXhpdFxyXG5cdCAqL1xyXG5cdHVwZGF0ZUJhckZvclN1YmNoYXJ0KGR1cmF0aW9uRm9yRXhpdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbDoge3N1YmNoYXJ0fX0gPSAkJDtcclxuXHJcblx0XHRzdWJjaGFydC5iYXIgPSBzdWJjaGFydC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuYmFyc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcn1gKVxyXG5cdFx0XHQuZGF0YSgkJC5iYXJEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdWJjaGFydC5iYXJcclxuXHRcdFx0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRzdWJjaGFydC5iYXIgPSBzdWJjaGFydC5iYXJcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0Jhci5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsIFwibm9uZVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2Uoc3ViY2hhcnQuYmFyKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGhlIGJhciBvZiB0aGUgc3ViY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGluIHN1YmNoYXJ0IGJhclxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqL1xyXG5cdHJlZHJhd0JhckZvclN1YmNoYXJ0KGRyYXdCYXJPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCB7YmFyfSA9IHRoaXMuJGVsLnN1YmNoYXJ0O1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IGJhci50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOiBiYXIpXHJcblx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3QmFyT25TdWIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgbGluZSBvZiB0aGUgc3ViIGNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxpbmVGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWw6IHtzdWJjaGFydH19ID0gJCQ7XHJcblxyXG5cdFx0c3ViY2hhcnQubGluZSA9IHN1YmNoYXJ0Lm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdWJjaGFydC5saW5lXHJcblx0XHRcdC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0c3ViY2hhcnQubGluZSA9IHN1YmNoYXJ0LmxpbmVcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0xpbmUuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKHN1YmNoYXJ0LmxpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgbGluZSBvZiB0aGUgc3ViY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGluIHN1YmNoYXJ0IGxpbmVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb25cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqL1xyXG5cdHJlZHJhd0xpbmVGb3JTdWJjaGFydChkcmF3TGluZU9uU3ViLCB3aXRoVHJhbnNpdGlvbiwgZHVyYXRpb24pIHtcclxuXHRcdGNvbnN0IHtsaW5lfSA9IHRoaXMuJGVsLnN1YmNoYXJ0O1xyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxpbmUudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDogbGluZSlcclxuXHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdMaW5lT25TdWIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgYXJlYSBvZiB0aGUgc3ViIGNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqL1xyXG5cdHVwZGF0ZUFyZWFGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWw6IHtzdWJjaGFydH19ID0gJCQ7XHJcblxyXG5cdFx0c3ViY2hhcnQuYXJlYSA9IHN1YmNoYXJ0Lm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdWJjaGFydC5hcmVhXHJcblx0XHRcdC5leGl0KClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0c3ViY2hhcnQuYXJlYSA9IHN1YmNoYXJ0LmFyZWFcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyZWEuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JCQuc3RhdGUub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XHJcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2Uoc3ViY2hhcnQuYXJlYSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XHJcblx0fSxcclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGhlIGFyZWEgb2YgdGhlIHN1YmNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBpbiBzdWJjaGFydCBsaW5lXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHRyZWRyYXdBcmVhRm9yU3ViY2hhcnQoZHJhd0FyZWFPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCB7YXJlYX0gPSB0aGlzLiRlbC5zdWJjaGFydDtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyBhcmVhLnRyYW5zaXRpb24oZ2V0UmFuZG9tKCkpLmR1cmF0aW9uKGR1cmF0aW9uKSA6IGFyZWEpXHJcblx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3QXJlYU9uU3ViKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIHRoaXMuY29sb3IpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgdGhpcy5zdGF0ZS5vcmdBcmVhT3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHN1YmNoYXJ0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aXRoU3ViY2hhcnQgd2hldGhlciBvciBub3QgdG8gc2hvdyBzdWJjaGFydFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBkdXJhdGlvblxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzaGFwZSBTaGFwZSdzIGluZm9cclxuXHQgKi9cclxuXHRyZWRyYXdTdWJjaGFydCh3aXRoU3ViY2hhcnQsIGR1cmF0aW9uLCBzaGFwZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7c3ViY2hhcnQ6IHttYWlufX19ID0gJCQ7XHJcblxyXG5cdFx0bWFpbi5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnN1YmNoYXJ0X3Nob3cgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpO1xyXG5cclxuXHRcdC8vIHN1YmNoYXJ0XHJcblx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcclxuXHRcdFx0Ly8gcmVmbGVjdCBtYWluIGNoYXJ0IHRvIGV4dGVudCBvbiBzdWJjaGFydCBpZiB6b29tZWRcclxuXHRcdFx0aWYgKGQzRXZlbnQgJiYgZDNFdmVudC50eXBlID09PSBcInpvb21cIikge1xyXG5cdFx0XHRcdCQkLmJydXNoLnVwZGF0ZSgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgc3ViY2hhcnQgZWxlbWVudHMgaWYgbmVlZGVkXHJcblx0XHRcdGlmICh3aXRoU3ViY2hhcnQpIHtcclxuXHRcdFx0XHQvLyBleHRlbnQgcmVjdFxyXG5cdFx0XHRcdCFicnVzaEVtcHR5KCQkKSAmJiAkJC5icnVzaC51cGRhdGUoKTtcclxuXHJcblx0XHRcdFx0T2JqZWN0LmtleXMoc2hhcGUudHlwZSkuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5hbWUgPSBjYXBpdGFsaXplKHYpO1xyXG5cdFx0XHRcdFx0Y29uc3QgZHJhdyA9ICQkW2BnZW5lcmF0ZURyYXcke25hbWV9YF0oc2hhcGUuaW5kaWNlc1t2XSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRcdFx0JCRbYHVwZGF0ZSR7bmFtZX1Gb3JTdWJjaGFydGBdKGR1cmF0aW9uKTtcclxuXHRcdFx0XHRcdCQkW2ByZWRyYXcke25hbWV9Rm9yU3ViY2hhcnRgXShkcmF3LCBkdXJhdGlvbiwgZHVyYXRpb24pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRoZSBicnVzaC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd0ZvckJydXNoKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZzoge3N1YmNoYXJ0X29uYnJ1c2gsIHpvb21fcmVzY2FsZTogd2l0aFl9LCBzY2FsZX0gPSAkJDtcclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2UsXHJcblx0XHRcdHdpdGhZLFxyXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdHN1YmNoYXJ0X29uYnJ1c2guY2FsbCgkJC5hcGksIHNjYWxlLngub3JnRG9tYWluKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyYW5zZm9ybSBjb250ZXh0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGluZGljYXRlcyB0cmFuc2l0aW9uIGlzIGVuYWJsZWRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZ2VuZXJhdGVUcmFuc2l0aW9ucyBtZXRob2Qgb2YgQXhpcy5cclxuXHQgKi9cclxuXHR0cmFuc2Zvcm1Db250ZXh0KHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsLnN1YmNoYXJ0O1xyXG5cdFx0bGV0IHN1YlhBeGlzO1xyXG5cclxuXHRcdGlmICh0cmFuc2l0aW9ucyAmJiB0cmFuc2l0aW9ucy5heGlzU3ViWCkge1xyXG5cdFx0XHRzdWJYQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNTdWJYO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3ViWEF4aXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1h9YCk7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRzdWJYQXhpcyA9IHN1YlhBeGlzLnRyYW5zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJjb250ZXh0XCIpKTtcclxuXHRcdHN1YlhBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwic3ViWFwiKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGV4dGVudCB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge0FycmF5fSBkZWZhdWx0IGV4dGVudFxyXG5cdCAqL1xyXG5cdGdldEV4dGVudCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0bGV0IGV4dGVudCA9IGNvbmZpZy5heGlzX3hfZXh0ZW50O1xyXG5cclxuXHRcdGlmIChleHRlbnQpIHtcclxuXHRcdFx0aWYgKGlzRnVuY3Rpb24oZXh0ZW50KSkge1xyXG5cdFx0XHRcdGV4dGVudCA9IGV4dGVudCgkJC5nZXRYRG9tYWluKCQkLmRhdGEudGFyZ2V0cyksIHNjYWxlLnN1YlgpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCQkLmlzVGltZVNlcmllcygpICYmIGV4dGVudC5ldmVyeShpc05hTikpIHtcclxuXHRcdFx0XHRleHRlbnQgPSBleHRlbnQubWFwKHYgPT4gc2NhbGUuc3ViWCgkJC5wYXJzZURhdGUodikpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBleHRlbnQ7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRldmVudCBhcyBkM0V2ZW50LFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkcmFnIGFzIGQzRHJhZ30gZnJvbSBcImQzLWRyYWdcIjtcclxuaW1wb3J0IHt6b29tIGFzIGQzWm9vbX0gZnJvbSBcImQzLXpvb21cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGRpZmZEb21haW4sIGdldE1pbk1heCwgaXNEZWZpbmVkLCBpc0Z1bmN0aW9ufSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHpvb20uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0Wm9vbSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5zY2FsZS56b29tID0gbnVsbDtcclxuXHJcblx0XHQkJC5nZW5lcmF0ZVpvb20oKTtcclxuXHRcdCQkLmluaXRab29tQmVoYXZpb3VyKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQmluZCB6b29tIGV2ZW50XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBiaW5kIFdlYXRoZXIgYmluZCBvciB1bmJvdW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRiaW5kWm9vbUV2ZW50KGJpbmQgPSB0cnVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IHpvb21FbmFibGVkID0gY29uZmlnLnpvb21fZW5hYmxlZDtcclxuXHJcblx0XHQkJC5yZWRyYXdFdmVudFJlY3QoKTtcclxuXHJcblx0XHRjb25zdCBldmVudFJlY3RzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdHN9YCk7XHJcblxyXG5cdFx0aWYgKHpvb21FbmFibGVkICYmIGJpbmQpIHtcclxuXHRcdFx0Ly8gRG8gbm90IGJpbmQgem9vbSBldmVudCB3aGVuIHN1YmNoYXJ0IGlzIHNob3duXHJcblx0XHRcdCFjb25maWcuc3ViY2hhcnRfc2hvdyAmJlxyXG5cdFx0XHRcdCQkLmJpbmRab29tT25FdmVudFJlY3QoZXZlbnRSZWN0cywgem9vbUVuYWJsZWQudHlwZSk7XHJcblx0XHR9IGVsc2UgaWYgKGJpbmQgPT09IGZhbHNlKSB7XHJcblx0XHRcdCQkLmFwaS51bnpvb20oKTtcclxuXHJcblx0XHRcdGV2ZW50UmVjdHNcclxuXHRcdFx0XHQub24oXCIuem9vbVwiLCBudWxsKVxyXG5cdFx0XHRcdC5vbihcIi5kcmFnXCIsIG51bGwpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIHpvb21cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlWm9vbSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZywgc2NhbGV9ID0gJCQ7XHJcblxyXG5cdFx0Y29uc3Qgem9vbSA9IGQzWm9vbSgpLmR1cmF0aW9uKDApXHJcblx0XHRcdC5vbihcInN0YXJ0XCIsICQkLm9uWm9vbVN0YXJ0LmJpbmQoJCQpKVxyXG5cdFx0XHQub24oXCJ6b29tXCIsICQkLm9uWm9vbS5iaW5kKCQkKSlcclxuXHRcdFx0Lm9uKFwiZW5kXCIsICQkLm9uWm9vbUVuZC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0Ly8gZ2V0IHpvb20gZXh0ZW50XHJcblx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHR6b29tLm9yZ1NjYWxlRXh0ZW50ID0gKCkgPT4ge1xyXG5cdFx0XHRjb25zdCBleHRlbnQgPSBjb25maWcuem9vbV9leHRlbnQgfHwgWzEsIDEwXTtcclxuXHJcblx0XHRcdHJldHVybiBbZXh0ZW50WzBdLCBNYXRoLm1heCgkJC5nZXRNYXhEYXRhQ291bnQoKSAvIGV4dGVudFsxXSwgZXh0ZW50WzFdKV07XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHpvb20udXBkYXRlU2NhbGVFeHRlbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgcmF0aW8gPSBkaWZmRG9tYWluKCQkLnNjYWxlLngub3JnRG9tYWluKCkpIC8gZGlmZkRvbWFpbigkJC5nZXRab29tRG9tYWluKCkpO1xyXG5cdFx0XHRjb25zdCBleHRlbnQgPSB0aGlzLm9yZ1NjYWxlRXh0ZW50KCk7XHJcblxyXG5cdFx0XHR0aGlzLnNjYWxlRXh0ZW50KFtleHRlbnRbMF0gKiByYXRpbywgZXh0ZW50WzFdICogcmF0aW9dKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFVwZGF0ZSBzY2FsZSBhY2NvcmRpbmcgem9vbSB0cmFuc2Zvcm0gdmFsdWVcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc2Zvcm1cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHpvb20udXBkYXRlVHJhbnNmb3JtU2NhbGUgPSB0cmFuc2Zvcm0gPT4ge1xyXG5cdFx0XHQvLyBpbiBjYXNlIG9mIHJlc2l6ZSwgdXBkYXRlIHJhbmdlIG9mIG9yZ1hTY2FsZVxyXG5cdFx0XHRvcmcueFNjYWxlICYmIG9yZy54U2NhbGUucmFuZ2Uoc2NhbGUueC5yYW5nZSgpKTtcclxuXHJcblx0XHRcdC8vIHJlc2NhbGUgZnJvbSB0aGUgb3JpZ2luYWwgc2NhbGVcclxuXHRcdFx0Y29uc3QgbmV3U2NhbGUgPSB0cmFuc2Zvcm1bXHJcblx0XHRcdFx0Y29uZmlnLmF4aXNfcm90YXRlZCA/IFwicmVzY2FsZVlcIiA6IFwicmVzY2FsZVhcIlxyXG5cdFx0XHRdKG9yZy54U2NhbGUgfHwgc2NhbGUueCk7XHJcblxyXG5cdFx0XHRjb25zdCBkb21haW4gPSAkJC50cmltWERvbWFpbihuZXdTY2FsZS5kb21haW4oKSk7XHJcblx0XHRcdGNvbnN0IHJlc2NhbGUgPSBjb25maWcuem9vbV9yZXNjYWxlO1xyXG5cclxuXHRcdFx0bmV3U2NhbGUuZG9tYWluKGRvbWFpbiwgb3JnLnhEb21haW4pO1xyXG5cclxuXHRcdFx0c2NhbGUuem9vbSA9ICQkLmdldEN1c3RvbWl6ZWRTY2FsZShuZXdTY2FsZSk7XHJcblx0XHRcdCQkLmF4aXMueC5zY2FsZShzY2FsZS56b29tKTtcclxuXHJcblx0XHRcdGlmIChyZXNjYWxlKSB7XHJcblx0XHRcdFx0Ly8gY29weSBjdXJyZW50IGluaXRpYWwgeCBzY2FsZSBpbiBjYXNlIG9mIHJlc2NhbGUgb3B0aW9uIGlzIHVzZWRcclxuXHRcdFx0XHQhb3JnLnhTY2FsZSAmJiAob3JnLnhTY2FsZSA9IHNjYWxlLnguY29weSgpKTtcclxuXHRcdFx0XHRzY2FsZS54LmRvbWFpbihkb21haW4pO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLnpvb20gPSB6b29tO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqICdzdGFydCcgZXZlbnQgbGlzdGVuZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9uWm9vbVN0YXJ0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50LnNvdXJjZUV2ZW50O1xyXG5cclxuXHRcdGlmICghZXZlbnQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnpvb20uc3RhcnRFdmVudCA9IGV2ZW50O1xyXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy56b29tX29uem9vbXN0YXJ0LCAkJC5hcGksIGV2ZW50KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiAnem9vbScgZXZlbnQgbGlzdGVuZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9uWm9vbSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBvcmd9ID0gJCQ7XHJcblx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQ7XHJcblx0XHRjb25zdCB7c291cmNlRXZlbnR9ID0gZXZlbnQ7XHJcblxyXG5cdFx0aWYgKFxyXG5cdFx0XHQhY29uZmlnLnpvb21fZW5hYmxlZCB8fFxyXG5cdFx0XHQhZXZlbnQuc291cmNlRXZlbnQgfHxcclxuXHRcdFx0JCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCA9PT0gMCB8fFxyXG5cdFx0XHQoIXNjYWxlLnpvb20gJiYgc291cmNlRXZlbnQudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPiAtMSAmJiBzb3VyY2VFdmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSlcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaXNNb3VzZW1vdmUgPSBzb3VyY2VFdmVudC50eXBlID09PSBcIm1vdXNlbW92ZVwiO1xyXG5cdFx0Y29uc3QgaXNab29tT3V0ID0gc291cmNlRXZlbnQud2hlZWxEZWx0YSA8IDA7XHJcblx0XHRjb25zdCB7dHJhbnNmb3JtfSA9IGV2ZW50O1xyXG5cclxuXHRcdGlmICghaXNNb3VzZW1vdmUgJiYgaXNab29tT3V0ICYmIHNjYWxlLnguZG9tYWluKCkuZXZlcnkoKHYsIGkpID0+IHYgIT09IG9yZy54RG9tYWluW2ldKSkge1xyXG5cdFx0XHRzY2FsZS54LmRvbWFpbihvcmcueERvbWFpbik7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuem9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZSh0cmFuc2Zvcm0pO1xyXG5cclxuXHRcdGlmICgkJC5pc0NhdGVnb3JpemVkKCkgJiYgc2NhbGUueC5vcmdEb21haW4oKVswXSA9PT0gb3JnLnhEb21haW5bMF0pIHtcclxuXHRcdFx0c2NhbGUueC5kb21haW4oW29yZy54RG9tYWluWzBdIC0gMWUtMTAsIHNjYWxlLngub3JnRG9tYWluKClbMV1dKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbjogZmFsc2UsXHJcblx0XHRcdHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlLFxyXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxyXG5cdFx0XHR3aXRoRXZlbnRSZWN0OiBmYWxzZSxcclxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdCQkLnN0YXRlLmNhbmNlbENsaWNrID0gaXNNb3VzZW1vdmU7XHJcblx0XHRjYWxsRm4oY29uZmlnLnpvb21fb256b29tLCAkJC5hcGksIHNjYWxlLnpvb20uZG9tYWluKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqICdlbmQnIGV2ZW50IGxpc3RlbmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRvblpvb21FbmQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGxldCB7c3RhcnRFdmVudH0gPSAkJC56b29tO1xyXG5cdFx0bGV0IGV2ZW50ID0gZDNFdmVudCAmJiBkM0V2ZW50LnNvdXJjZUV2ZW50O1xyXG5cclxuXHRcdGlmICgoc3RhcnRFdmVudCAmJiBzdGFydEV2ZW50LnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID4gLTEpKSB7XHJcblx0XHRcdHN0YXJ0RXZlbnQgPSBzdGFydEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRldmVudCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGlmIGNsaWNrLCBkbyBub3RoaW5nLiBvdGhlcndpc2UsIGNsaWNrIGludGVyYWN0aW9uIHdpbGwgYmUgY2FuY2VsZWQuXHJcblx0XHRpZiAoIXN0YXJ0RXZlbnQgfHxcclxuXHRcdFx0KGV2ZW50ICYmIHN0YXJ0RXZlbnQuY2xpZW50WCA9PT0gZXZlbnQuY2xpZW50WCAmJiBzdGFydEV2ZW50LmNsaWVudFkgPT09IGV2ZW50LmNsaWVudFkpXHJcblx0XHQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cdFx0JCQudXBkYXRlWm9vbSgpO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuem9vbV9vbnpvb21lbmQsICQkLmFwaSwgc2NhbGVbc2NhbGUuem9vbSA/IFwiem9vbVwiIDogXCJzdWJYXCJdLmRvbWFpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgem9vbSBkb21haW5cclxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IHpvb20gZG9tYWluXHJcbiBcdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Wm9vbURvbWFpbigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZ30gPSAkJDtcclxuXHRcdGxldCBbbWluLCBtYXhdID0gb3JnLnhEb21haW47XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjb25maWcuem9vbV94X21pbikpIHtcclxuXHRcdFx0bWluID0gZ2V0TWluTWF4KFwibWluXCIsIFttaW4sIGNvbmZpZy56b29tX3hfbWluXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjb25maWcuem9vbV94X21heCkpIHtcclxuXHRcdFx0bWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsIFttYXgsIGNvbmZpZy56b29tX3hfbWF4XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFttaW4sIG1heF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHpvb21cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHVuem9vbVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlWm9vbShmb3JjZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHtzdWJYLCB4LCB6b29tfSA9ICQkLnNjYWxlO1xyXG5cclxuXHRcdGlmICh6b29tKSB7XHJcblx0XHRcdGNvbnN0IHpvb21Eb21haW4gPSB6b29tLmRvbWFpbigpO1xyXG5cdFx0XHRjb25zdCB4RG9tYWluID0gc3ViWC5kb21haW4oKTtcclxuXHRcdFx0Y29uc3QgZGVsdGEgPSAwLjAxNTsgLy8gYXJiaXRyYXJ5IHZhbHVlXHJcblxyXG5cdFx0XHRjb25zdCBpc2Z1bGx5U2hvd24gPSAoem9vbURvbWFpblswXSA8PSB4RG9tYWluWzBdIHx8ICh6b29tRG9tYWluWzBdIC0gZGVsdGEpIDw9IHhEb21haW5bMF0pICYmXHJcblx0XHRcdFx0KHhEb21haW5bMV0gPD0gem9vbURvbWFpblsxXSB8fCB4RG9tYWluWzFdIDw9ICh6b29tRG9tYWluWzFdIC0gZGVsdGEpKTtcclxuXHJcblx0XHRcdC8vIGNoZWNrIGlmIHRoZSB6b29tZWQgY2hhcnQgaXMgZnVsbHkgc2hvd24sIHRoZW4gcmVzZXQgc2NhbGUgd2hlbiB6b29tIGlzIG91dCBhcyBpbml0aWFsXHJcblx0XHRcdGlmIChmb3JjZSB8fCBpc2Z1bGx5U2hvd24pIHtcclxuXHRcdFx0XHQkJC5heGlzLnguc2NhbGUoc3ViWCk7XHJcblx0XHRcdFx0eC5kb21haW4oc3ViWC5vcmdEb21haW4oKSk7XHJcblx0XHRcdFx0em9vbSA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBBdHRhY2ggem9vbSBldmVudCBvbiA8cmVjdD5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRab29tT25FdmVudFJlY3QoZXZlbnRSZWN0cywgdHlwZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgYmVoYXZpb3VyID0gdHlwZSA9PT0gXCJkcmFnXCIgPyAkJC56b29tQmVoYXZpb3VyIDogJCQuem9vbTtcclxuXHJcblx0XHRldmVudFJlY3RzXHJcblx0XHRcdC5jYWxsKGJlaGF2aW91cilcclxuXHRcdFx0Lm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBkcmFnIGJlaGF2aW91ciB1c2VkIGZvciB6b29taW5nLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFpvb21CZWhhdmlvdXIoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgc3RhcnQgPSAwO1xyXG5cdFx0bGV0IGVuZCA9IDA7XHJcblx0XHRsZXQgem9vbVJlY3Q7XHJcblxyXG5cdFx0Y29uc3QgcHJvcCA9IHtcclxuXHRcdFx0YXhpczogaXNSb3RhdGVkID8gXCJ5XCIgOiBcInhcIixcclxuXHRcdFx0YXR0cjogaXNSb3RhdGVkID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIixcclxuXHRcdFx0aW5kZXg6IGlzUm90YXRlZCA/IDEgOiAwXHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLnpvb21CZWhhdmlvdXIgPSBkM0RyYWcoKVxyXG5cdFx0XHQuY2xpY2tEaXN0YW5jZSg0KVxyXG5cdFx0XHQub24oXCJzdGFydFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQkJC5zZXREcmFnU3RhdHVzKHRydWUpO1xyXG5cclxuXHRcdFx0XHRpZiAoIXpvb21SZWN0KSB7XHJcblx0XHRcdFx0XHR6b29tUmVjdCA9ICQkLiRlbC5tYWluLmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgc3RhdGUuY2xpcC5wYXRoKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnpvb21CcnVzaClcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBpc1JvdGF0ZWQgPyBzdGF0ZS53aWR0aCA6IDApXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGlzUm90YXRlZCA/IDAgOiBzdGF0ZS5oZWlnaHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdHN0YXJ0ID0gZDNNb3VzZSh0aGlzKVtwcm9wLmluZGV4XTtcclxuXHRcdFx0XHRlbmQgPSBzdGFydDtcclxuXHJcblx0XHRcdFx0em9vbVJlY3RcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXhpcywgc3RhcnQpXHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF0dHIsIDApO1xyXG5cclxuXHRcdFx0XHQkJC5vblpvb21TdGFydCgpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQub24oXCJkcmFnXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRlbmQgPSBkM01vdXNlKHRoaXMpW3Byb3AuaW5kZXhdO1xyXG5cclxuXHRcdFx0XHR6b29tUmVjdFxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCBNYXRoLm1pbihzdGFydCwgZW5kKSlcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgTWF0aC5hYnMoZW5kIC0gc3RhcnQpKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm9uKFwiZW5kXCIsIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlLnpvb20gfHwgJCQuc2NhbGUueDtcclxuXHJcblx0XHRcdFx0JCQuc2V0RHJhZ1N0YXR1cyhmYWxzZSk7XHJcblxyXG5cdFx0XHRcdHpvb21SZWN0XHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIDApXHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF0dHIsIDApO1xyXG5cclxuXHRcdFx0XHRpZiAoc3RhcnQgPiBlbmQpIHtcclxuXHRcdFx0XHRcdFtzdGFydCwgZW5kXSA9IFtlbmQsIHN0YXJ0XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChzdGFydCA8IDApIHtcclxuXHRcdFx0XHRcdGVuZCArPSBNYXRoLmFicyhzdGFydCk7XHJcblx0XHRcdFx0XHRzdGFydCA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoc3RhcnQgIT09IGVuZCkge1xyXG5cdFx0XHRcdFx0JCQuYXBpLnpvb20oW3N0YXJ0LCBlbmRdLm1hcCh2ID0+IHNjYWxlLmludmVydCh2KSkpO1xyXG5cdFx0XHRcdFx0JCQub25ab29tRW5kKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICgkJC5pc011bHRpcGxlWCgpKSB7XHJcblx0XHRcdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMuYmluZCh0aGlzKSgkJCk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQuc291cmNlRXZlbnQgfHwgZDNFdmVudDtcclxuXHRcdFx0XHRcdFx0Y29uc3QgW3gsIHldID0gXCJjbGllbnRYXCIgaW4gZXZlbnQgPyBbZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WV0gOiBbZXZlbnQueCwgZXZlbnQueV07XHJcblx0XHRcdFx0XHRcdGNvbnN0IHRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XHJcblxyXG5cdFx0XHRcdFx0XHQkJC5jbGlja0hhbmRsZXJGb3JTaW5nbGVYLmJpbmQodGFyZ2V0KShkM1NlbGVjdCh0YXJnZXQpLmRhdHVtKCksICQkKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHNldFpvb21SZXNldEJ1dHRvbigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCByZXNldEJ1dHRvbiA9IGNvbmZpZy56b29tX3Jlc2V0QnV0dG9uO1xyXG5cclxuXHRcdGlmIChyZXNldEJ1dHRvbiAmJiBjb25maWcuem9vbV9lbmFibGVkLnR5cGUgPT09IFwiZHJhZ1wiKSB7XHJcblx0XHRcdGlmICghJCQuem9vbS5yZXNldEJ0bikge1xyXG5cdFx0XHRcdCQkLnpvb20ucmVzZXRCdG4gPSAkJC4kZWwuY2hhcnQuYXBwZW5kKFwiZGl2XCIpXHJcblx0XHRcdFx0XHQuY2xhc3NlZChDTEFTUy5idXR0b24sIHRydWUpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwic3BhblwiKVxyXG5cdFx0XHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGlzRnVuY3Rpb24ocmVzZXRCdXR0b24ub25jbGljaykgJiYgcmVzZXRCdXR0b24ub25jbGljayh0aGlzKTtcclxuXHRcdFx0XHRcdFx0JCQuYXBpLnVuem9vbSgpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLmJ1dHRvblpvb21SZXNldCwgdHJ1ZSlcclxuXHRcdFx0XHRcdC50ZXh0KHJlc2V0QnV0dG9uLnRleHQgfHwgXCJSZXNldCBab29tXCIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCQkLnpvb20ucmVzZXRCdG4uc3R5bGUoXCJkaXNwbGF5XCIsIG51bGwpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBDYXRlZ29yeSBOYW1lXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBnYXRlZ29yeSBOYW1lXHJcblx0ICovXHJcblx0Y2F0ZWdvcnlOYW1lKGkpIHtcclxuXHRcdGNvbnN0IHtheGlzX3hfY2F0ZWdvcmllczogY2F0ZWdvcmllc30gPSB0aGlzLmNvbmZpZztcclxuXHJcblx0XHRyZXR1cm4gaSA8IGNhdGVnb3JpZXMubGVuZ3RoID8gY2F0ZWdvcmllc1tpXSA6IGk7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRDbGlwKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NsaXB9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2xpcElkIG5lZWRzIHRvIGJlIHVuaXF1ZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBleGlzdFxyXG5cdFx0Y2xpcC5pZCA9IGAkeyQkLnN0YXRlLmRhdGV0aW1lSWR9LWNsaXBgO1xyXG5cdFx0Y2xpcC5pZFhBeGlzID0gYCR7Y2xpcC5pZH0teGF4aXNgO1xyXG5cdFx0Y2xpcC5pZFlBeGlzID0gYCR7Y2xpcC5pZH0teWF4aXNgO1xyXG5cdFx0Y2xpcC5pZEdyaWQgPSBgJHtjbGlwLmlkfS1ncmlkYDtcclxuXHJcblx0XHQvLyBEZWZpbmUgJ2NsaXAtcGF0aCcgYXR0cmlidXRlIHZhbHVlc1xyXG5cdFx0Y2xpcC5wYXRoID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcC5pZCk7XHJcblx0XHRjbGlwLnBhdGhYQXhpcyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRYQXhpcyk7XHJcblx0XHRjbGlwLnBhdGhZQXhpcyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRZQXhpcyk7XHJcblx0XHRjbGlwLnBhdGhHcmlkID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcC5pZEdyaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldENsaXBQYXRoKGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgoIWNvbmZpZy5jbGlwUGF0aCAmJiAvLWNsaXAkLy50ZXN0KGlkKSkgfHxcclxuXHRcdFx0KCFjb25maWcuYXhpc194X2NsaXBQYXRoICYmIC8tY2xpcC14YXhpcyQvLnRlc3QoaWQpKSB8fFxyXG5cdFx0XHQoIWNvbmZpZy5heGlzX3lfY2xpcFBhdGggJiYgLy1jbGlwLXlheGlzJC8udGVzdChpZCkpKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzSUU5ID0gd2luZG93Lm5hdmlnYXRvciA/XHJcblx0XHRcdHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvblxyXG5cdFx0XHRcdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJtc2llIDkuXCIpID49IDAgOiBmYWxzZTtcclxuXHJcblx0XHRyZXR1cm4gYHVybCgkeyhpc0lFOSA/IFwiXCIgOiBkb2N1bWVudC5VUkwuc3BsaXQoXCIjXCIpWzBdKX0jJHtpZH0pYDtcclxuXHR9LFxyXG5cclxuXHRhcHBlbmRDbGlwKHBhcmVudCwgaWQpIHtcclxuXHRcdHJldHVybiBwYXJlbnQuYXBwZW5kKFwiY2xpcFBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJpZFwiLCBpZClcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBYKGZvckhvcml6b250YWwpIHtcclxuXHRcdGNvbnN0IHttYXJnaW59ID0gdGhpcy5zdGF0ZTtcclxuXHRcdC8vIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnRcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID8gLSgxICsgbGVmdCkgOiAtKGxlZnQgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcFkoZm9ySG9yaXpvbnRhbCkge1xyXG5cdFx0Y29uc3Qge21hcmdpbn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID8gLTIwIDogLW1hcmdpbi50b3A7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwWCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBYKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYQXhpc0NsaXBZKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFlBeGlzQ2xpcFgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5heGlzX3lfaW5uZXIgP1xyXG5cdFx0XHQtMSA6ICQkLmdldEF4aXNDbGlwWCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZQXhpc0NsaXBZKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBXaWR0aChmb3JIb3Jpem9udGFsKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bWFyZ2luLCB3aWR0aH0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cdFx0Y29uc3QgcmlnaHQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLnJpZ2h0KTtcclxuXHJcblx0XHQvLyB3aWR0aCArIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnQvcmlnaHRcclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID9cclxuXHRcdFx0d2lkdGggKyAyICsgbGVmdCArIHJpZ2h0IDogbWFyZ2luLmxlZnQgKyAyMDtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcEhlaWdodChmb3JIb3Jpem9udGFsKSB7XHJcblx0XHRjb25zdCB7bWFyZ2luLCBoZWlnaHR9ID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHQvLyBsZXNzIHRoYW4gMjAgaXMgbm90IGVub3VnaCB0byBzaG93IHRoZSBheGlzIGxhYmVsICdvdXRlcicgd2l0aG91dCBsZWdlbmRcclxuXHRcdHJldHVybiAoZm9ySG9yaXpvbnRhbCA/IG1hcmdpbi5ib3R0b20gOiAobWFyZ2luLnRvcCArIGhlaWdodCkpICsgMjA7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwV2lkdGgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhBeGlzQ2xpcEhlaWdodCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFlBeGlzQ2xpcFdpZHRoKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFdpZHRoKCQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpICsgKCQkLmNvbmZpZy5heGlzX3lfaW5uZXIgPyAyMCA6IDApO1xyXG5cdH0sXHJcblxyXG5cdGdldFlBeGlzQ2xpcEhlaWdodCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBIZWlnaHQoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2lzQXJyYXksIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gR3JpZCBwb3NpdGlvbiBhbmQgdGV4dCBhbmNob3IgaGVscGVyc1xyXG5jb25zdCBnZXRHcmlkVGV4dEFuY2hvciA9IGQgPT4gaXNWYWx1ZShkLnBvc2l0aW9uKSB8fCBcImVuZFwiO1xyXG5jb25zdCBnZXRHcmlkVGV4dER4ID0gZCA9PiAoZC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiID8gNCA6IChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiID8gMCA6IC00KSk7XHJcbmNvbnN0IGdldEdyaWRUZXh0WCA9IChpc1gsIHdpZHRoLCBoZWlnaHQpID0+IGQgPT4ge1xyXG5cdGxldCB4ID0gaXNYID8gMCA6IHdpZHRoO1xyXG5cclxuXHRpZiAoZC5wb3NpdGlvbiA9PT0gXCJzdGFydFwiKSB7XHJcblx0XHR4ID0gaXNYID8gLWhlaWdodCA6IDA7XHJcblx0fSBlbHNlIGlmIChkLnBvc2l0aW9uID09PSBcIm1pZGRsZVwiKSB7XHJcblx0XHR4ID0gKGlzWCA/IC1oZWlnaHQgOiB3aWR0aCkgLyAyO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHg7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdEdyaWQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuaW5pdEdyaWRMaW5lcygpO1xyXG5cdFx0JCQuaW5pdEZvY3VzR3JpZCgpO1xyXG5cdH0sXHJcblxyXG5cdGluaXRHcmlkTGluZXMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2NsaXB9LCAkZWw6IHtncmlkTGluZXMsIG1haW59fSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcuZ3JpZF94X2xpbmVzLmxlbmd0aCB8fCBjb25maWcuZ3JpZF95X2xpbmVzLmxlbmd0aCkge1xyXG5cdFx0XHRncmlkTGluZXMubWFpbiA9IG1haW4uaW5zZXJ0KFwiZ1wiLCBgLiR7Q0xBU1MuY2hhcnR9JHtjb25maWcuZ3JpZF9saW5lc19mcm9udCA/IFwiICsgKlwiIDogXCJcIn1gKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXAucGF0aEdyaWQpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBgJHtDTEFTUy5ncmlkfSAke0NMQVNTLmdyaWRMaW5lc31gKTtcclxuXHJcblx0XHRcdGdyaWRMaW5lcy5tYWluLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkTGluZXMpO1xyXG5cdFx0XHRncmlkTGluZXMubWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZExpbmVzKTtcclxuXHJcblx0XHRcdGdyaWRMaW5lcy54ID0gZDNTZWxlY3RBbGwoW10pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVhHcmlkKHdpdGhvdXRVcGRhdGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZSwgJGVsOiB7bWFpbiwgZ3JpZH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgeGdyaWREYXRhID0gJCQuZ2VuZXJhdGVHcmlkRGF0YShjb25maWcuZ3JpZF94X3R5cGUsIHNjYWxlLngpO1xyXG5cdFx0Y29uc3QgdGlja09mZnNldCA9ICQkLmlzQ2F0ZWdvcml6ZWQoKSA/ICQkLmF4aXMueC50aWNrT2Zmc2V0KCkgOiAwO1xyXG5cdFx0Y29uc3QgcG9zID0gZCA9PiAoKHNjYWxlLnpvb20gfHwgc2NhbGUueCkoZCkgKyB0aWNrT2Zmc2V0KSAqIChpc1JvdGF0ZWQgPyAtMSA6IDEpO1xyXG5cclxuXHRcdHN0YXRlLnhncmlkQXR0ciA9IGlzUm90YXRlZCA/IHtcclxuXHRcdFx0XCJ4MVwiOiAwLFxyXG5cdFx0XHRcIngyXCI6IHN0YXRlLndpZHRoLFxyXG5cdFx0XHRcInkxXCI6IHBvcyxcclxuXHRcdFx0XCJ5MlwiOiBwb3MsXHJcblx0XHR9IDoge1xyXG5cdFx0XHRcIngxXCI6IHBvcyxcclxuXHRcdFx0XCJ4MlwiOiBwb3MsXHJcblx0XHRcdFwieTFcIjogMCxcclxuXHRcdFx0XCJ5MlwiOiBzdGF0ZS5oZWlnaHQsXHJcblx0XHR9O1xyXG5cclxuXHRcdGdyaWQueCA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy54Z3JpZHN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWR9YClcclxuXHRcdFx0LmRhdGEoeGdyaWREYXRhKTtcclxuXHJcblx0XHRncmlkLnguZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdGdyaWQueCA9IGdyaWQueC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWQpXHJcblx0XHRcdC5tZXJnZShncmlkLngpO1xyXG5cclxuXHRcdGlmICghd2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRncmlkLnguZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCBncmlkID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdE9iamVjdC5rZXlzKHN0YXRlLnhncmlkQXR0cikuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdFx0XHRncmlkLmF0dHIoaWQsIHN0YXRlLnhncmlkQXR0cltpZF0pXHJcblx0XHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgKCkgPT4gKFxyXG5cdFx0XHRcdFx0XHRcdGdyaWQuYXR0cihpc1JvdGF0ZWQgPyBcInkxXCIgOiBcIngxXCIpID09PSAoaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0IDogMCkgP1xyXG5cdFx0XHRcdFx0XHRcdFx0XCIwXCIgOiBcIjFcIlxyXG5cdFx0XHRcdFx0XHQpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlWUdyaWQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7Z3JpZCwgbWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgZ3JpZFZhbHVlcyA9ICQkLmF4aXMueS50aWNrVmFsdWVzKCkgfHwgJCQuc2NhbGUueS50aWNrcyhjb25maWcuZ3JpZF95X3RpY2tzKTtcclxuXHRcdGNvbnN0IHBvcyA9IGQgPT4gTWF0aC5jZWlsKCQkLnNjYWxlLnkoZCkpO1xyXG5cclxuXHRcdGdyaWQueSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy55Z3JpZHN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueWdyaWR9YClcclxuXHRcdFx0LmRhdGEoZ3JpZFZhbHVlcyk7XHJcblxyXG5cdFx0Z3JpZC55LmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRncmlkLnkgPSBncmlkLnlcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZClcclxuXHRcdFx0Lm1lcmdlKGdyaWQueSk7XHJcblxyXG5cdFx0Z3JpZC55LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyBwb3MgOiAwKVxyXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHBvcyA6IHN0YXRlLndpZHRoKVxyXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IDAgOiBwb3MpXHJcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0IDogcG9zKTtcclxuXHJcblx0XHQkJC5zbW9vdGhMaW5lcyhncmlkLnksIFwiZ3JpZFwiKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVHcmlkKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsOiB7Z3JpZCwgZ3JpZExpbmVzfX0gPSAkJDtcclxuXHJcblx0XHQhZ3JpZExpbmVzLm1haW4gJiYgJCQuaW5pdEdyaWRMaW5lcygpO1xyXG5cclxuXHRcdC8vIGhpZGUgaWYgYXJjIHR5cGVcclxuXHRcdGdyaWQubWFpbi5zdHlsZShcInZpc2liaWxpdHlcIiwgJCQuaGFzQXJjVHlwZSgpID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiKTtcclxuXHJcblx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHQkJC51cGRhdGVYR3JpZExpbmVzKGR1cmF0aW9uKTtcclxuXHRcdCQkLnVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBYIEdyaWQgbGluZXNcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVhHcmlkTGluZXMoZHVyYXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge2dyaWRMaW5lcywgbWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbmZpZy5ncmlkX3hfc2hvdyAmJiAkJC51cGRhdGVYR3JpZCgpO1xyXG5cclxuXHRcdGxldCB4TGluZXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueGdyaWRMaW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy54Z3JpZExpbmV9YClcclxuXHRcdFx0LmRhdGEoY29uZmlnLmdyaWRfeF9saW5lcyk7XHJcblxyXG5cdFx0Ly8gZXhpdFxyXG5cdFx0eExpbmVzLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0Ly8gZW50ZXJcclxuXHRcdGNvbnN0IHhncmlkTGluZSA9IHhMaW5lcy5lbnRlcigpLmFwcGVuZChcImdcIik7XHJcblxyXG5cdFx0eGdyaWRMaW5lLmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XHJcblxyXG5cdFx0eGdyaWRMaW5lLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgaXNSb3RhdGVkID8gXCJcIiA6IFwicm90YXRlKC05MClcIilcclxuXHRcdFx0LmF0dHIoXCJkeVwiLCAtNSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIik7XHJcblxyXG5cdFx0eExpbmVzID0geGdyaWRMaW5lLm1lcmdlKHhMaW5lcyk7XHJcblxyXG5cdFx0eExpbmVzXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHtDTEFTUy54Z3JpZExpbmV9ICR7ZC5jbGFzcyB8fCBcIlwifWAudHJpbSgpKVxyXG5cdFx0XHQuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIGdldEdyaWRUZXh0QW5jaG9yKVxyXG5cdFx0XHQuYXR0cihcImR4XCIsIGdldEdyaWRUZXh0RHgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQudGV4dChkID0+IGQudGV4dClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHJcblx0XHRncmlkTGluZXMueCA9IHhMaW5lcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgWSBHcmlkIGxpbmVzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVZR3JpZExpbmVzKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3dpZHRoLCBoZWlnaHR9LCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbmZpZy5ncmlkX3lfc2hvdyAmJiAkJC51cGRhdGVZR3JpZCgpO1xyXG5cclxuXHRcdGxldCB5Z3JpZExpbmVzID0gJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy55Z3JpZExpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnlncmlkTGluZX1gKVxyXG5cdFx0XHQuZGF0YShjb25maWcuZ3JpZF95X2xpbmVzKTtcclxuXHJcblx0XHQvLyBleGl0XHJcblx0XHR5Z3JpZExpbmVzLmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIGVudGVyXHJcblx0XHRjb25zdCB5Z3JpZExpbmUgPSB5Z3JpZExpbmVzLmVudGVyKCkuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHR5Z3JpZExpbmUuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBpc1JvdGF0ZWQgPyBcInJvdGF0ZSgtOTApXCIgOiBcIlwiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHR5Z3JpZExpbmVzID0geWdyaWRMaW5lLm1lcmdlKHlncmlkTGluZXMpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZVxyXG5cdFx0Y29uc3QgeXYgPSAkJC55di5iaW5kKCQkKTtcclxuXHJcblx0XHR5Z3JpZExpbmVzXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHtDTEFTUy55Z3JpZExpbmV9ICR7ZC5jbGFzcyB8fCBcIlwifWAudHJpbSgpKVxyXG5cdFx0XHQuc2VsZWN0KFwibGluZVwiKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyB5diA6IDApXHJcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8geXYgOiB3aWR0aClcclxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogeXYpXHJcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gaGVpZ2h0IDogeXYpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0eWdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgZ2V0R3JpZFRleHRBbmNob3IpXHJcblx0XHRcdC5hdHRyKFwiZHhcIiwgZ2V0R3JpZFRleHREeClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBnZXRHcmlkVGV4dFgoaXNSb3RhdGVkLCB3aWR0aCwgaGVpZ2h0KSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHl2KVxyXG5cdFx0XHQudGV4dChkID0+IGQudGV4dClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHJcblx0XHQkZWwuZ3JpZExpbmVzLnkgPSB5Z3JpZExpbmVzO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0dyaWQod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtcclxuXHRcdFx0Y29uZmlnOiB7YXhpc19yb3RhdGVkOiBpc1JvdGF0ZWR9LFxyXG5cdFx0XHRzdGF0ZToge3dpZHRoLCBoZWlnaHR9LFxyXG5cdFx0XHQkZWw6IHtncmlkTGluZXN9XHJcblx0XHR9ID0gJCQ7XHJcblx0XHRjb25zdCB4diA9ICQkLnh2LmJpbmQoJCQpO1xyXG5cclxuXHRcdGxldCBsaW5lcyA9IGdyaWRMaW5lcy54LnNlbGVjdChcImxpbmVcIik7XHJcblx0XHRsZXQgdGV4dHMgPSBncmlkTGluZXMueC5zZWxlY3QoXCJ0ZXh0XCIpO1xyXG5cclxuXHRcdGxpbmVzID0gKHdpdGhUcmFuc2l0aW9uID8gbGluZXMudHJhbnNpdGlvbigpIDogbGluZXMpXHJcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IHh2KVxyXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHdpZHRoIDogeHYpXHJcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8geHYgOiAwKVxyXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IHh2IDogaGVpZ2h0KTtcclxuXHJcblx0XHR0ZXh0cyA9ICh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgZ2V0R3JpZFRleHRYKCFpc1JvdGF0ZWQsIHdpZHRoLCBoZWlnaHQpKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeHYpXHJcblx0XHRcdC50ZXh0KGQgPT4gZC50ZXh0KTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBsaW5lcy50cmFuc2l0aW9uKCkgOiBsaW5lcykuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKSxcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0aW5pdEZvY3VzR3JpZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y2xpcH0sICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGlzRnJvbnQgPSBjb25maWcuZ3JpZF9mcm9udDtcclxuXHRcdGNvbnN0IGNsYXNzTmFtZSA9IGAuJHtDTEFTU1tpc0Zyb250ICYmICRlbC5ncmlkLm1haW4gPyBcImdyaWRMaW5lc1wiIDogXCJjaGFydFwiXX0ke2lzRnJvbnQgPyBcIiArICpcIiA6IFwiXCJ9YDtcclxuXHJcblx0XHRjb25zdCBncmlkID0gJGVsLmdyaWQubWFpbiA9ICRlbC5tYWluLmluc2VydChcImdcIiwgY2xhc3NOYW1lKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwLnBhdGhHcmlkKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmdyaWQpO1xyXG5cclxuXHRcdGNvbmZpZy5ncmlkX3hfc2hvdyAmJlxyXG5cdFx0XHRncmlkLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkcyk7XHJcblxyXG5cdFx0Y29uZmlnLmdyaWRfeV9zaG93ICYmXHJcblx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWRzKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmdyaWRfZm9jdXNfc2hvdykge1xyXG5cdFx0XHRncmlkLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkRm9jdXMpXHJcblx0XHRcdFx0LmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkRm9jdXMpO1xyXG5cclxuXHRcdFx0Ly8gdG8gc2hvdyB4eSBmb2N1cyBncmlkIGxpbmUsIHNob3VsZCBiZSAndG9vbHRpcC5ncm91cGVkPWZhbHNlJ1xyXG5cdFx0XHRpZiAoY29uZmlnLmdyaWRfZm9jdXNfeSAmJiAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xyXG5cdFx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZEZvY3VzKVxyXG5cdFx0XHRcdFx0LmFwcGVuZChcImxpbmVcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWRGb2N1cyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93IGdyaWQgZm9jdXMgbGluZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkRGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2hvd0dyaWRGb2N1cyhzZWxlY3RlZERhdGEpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7d2lkdGgsIGhlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgZGF0YVRvU2hvdyA9IHNlbGVjdGVkRGF0YS5maWx0ZXIoZCA9PiBkICYmIGlzVmFsdWUoJCQuZ2V0QmFzZVZhbHVlKGQpKSk7XHJcblxyXG5cdFx0Ly8gSGlkZSB3aGVuIGJ1YmJsZS9zY2F0dGVyL3N0YW5mb3JkIHBsb3QgZXhpc3RzXHJcblx0XHRpZiAoIWNvbmZpZy50b29sdGlwX3Nob3cgfHwgZGF0YVRvU2hvdy5sZW5ndGggPT09IDAgfHwgJCQuaGFzVHlwZShcImJ1YmJsZVwiKSB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGZvY3VzRWwgPSAkJC4kZWwubWFpbi5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfSwgbGluZS4ke0NMQVNTLnlncmlkRm9jdXN9YCk7XHJcblx0XHRjb25zdCBpc0VkZ2UgPSBjb25maWcuZ3JpZF9mb2N1c19lZGdlICYmICFjb25maWcudG9vbHRpcF9ncm91cGVkO1xyXG5cdFx0Y29uc3QgeHggPSAkJC54eC5iaW5kKCQkKTtcclxuXHJcblx0XHRmb2N1c0VsXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpXHJcblx0XHRcdC5kYXRhKGRhdGFUb1Nob3cuY29uY2F0KGRhdGFUb1Nob3cpKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3QgZWwgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBwb3MgPSB7XHJcblx0XHRcdFx0XHR4OiB4eChkKSxcclxuXHRcdFx0XHRcdHk6ICQkLmdldFlTY2FsZShkLmlkKShkLnZhbHVlKVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0bGV0IHh5O1xyXG5cclxuXHRcdFx0XHRpZiAoZWwuY2xhc3NlZChDTEFTUy54Z3JpZEZvY3VzKSkge1xyXG5cdFx0XHRcdFx0Ly8gd2lsbCBjb250YWluICd4MSwgeTEsIHgyLCB5Micgb3JkZXJcclxuXHRcdFx0XHRcdHh5ID0gaXNSb3RhdGVkID9cclxuXHRcdFx0XHRcdFx0W1xyXG5cdFx0XHRcdFx0XHRcdG51bGwsIC8vIHgxXHJcblx0XHRcdFx0XHRcdFx0cG9zLngsIC8vIHkxXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlID8gcG9zLnkgOiB3aWR0aCwgLy8geDJcclxuXHRcdFx0XHRcdFx0XHRwb3MueCAvLyB5MlxyXG5cdFx0XHRcdFx0XHRdIDogW1xyXG5cdFx0XHRcdFx0XHRcdHBvcy54LFxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSA/IHBvcy55IDogbnVsbCxcclxuXHRcdFx0XHRcdFx0XHRwb3MueCxcclxuXHRcdFx0XHRcdFx0XHRoZWlnaHRcclxuXHRcdFx0XHRcdFx0XTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNZMiA9ICQkLmF4aXMuZ2V0SWQoZC5pZCkgPT09IFwieTJcIjtcclxuXHJcblx0XHRcdFx0XHR4eSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRcdFtcclxuXHRcdFx0XHRcdFx0XHRwb3MueSwgLy8geDFcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgJiYgIWlzWTIgPyBwb3MueCA6IG51bGwsIC8vIHkxXHJcblx0XHRcdFx0XHRcdFx0cG9zLnksIC8vIHgyXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlICYmIGlzWTIgPyBwb3MueCA6IGhlaWdodCAvLyB5MlxyXG5cdFx0XHRcdFx0XHRdIDogW1xyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSAmJiBpc1kyID8gcG9zLnggOiBudWxsLFxyXG5cdFx0XHRcdFx0XHRcdHBvcy55LFxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSAmJiAhaXNZMiA/IHBvcy54IDogd2lkdGgsXHJcblx0XHRcdFx0XHRcdFx0cG9zLnlcclxuXHRcdFx0XHRcdFx0XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFtcIngxXCIsIFwieTFcIiwgXCJ4MlwiLCBcInkyXCJdXHJcblx0XHRcdFx0XHQuZm9yRWFjaCgodiwgaSkgPT4gZWwuYXR0cih2LCB4eVtpXSkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHQkJC5zbW9vdGhMaW5lcyhmb2N1c0VsLCBcImdyaWRcIik7XHJcblx0fSxcclxuXHJcblx0aGlkZUdyaWRGb2N1cygpIHtcclxuXHRcdHRoaXMuJGVsLm1haW4uc2VsZWN0QWxsKGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c30sIGxpbmUuJHtDTEFTUy55Z3JpZEZvY3VzfWApXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIik7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlZ3JpZEZvY3VzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9YClcclxuXHRcdFx0LmF0dHIoXCJ4MVwiLCBpc1JvdGF0ZWQgPyAwIDogLTEwKVxyXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHdpZHRoIDogLTEwKVxyXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IC0xMCA6IDApXHJcblx0XHRcdC5hdHRyKFwieTJcIiwgaXNSb3RhdGVkID8gLTEwIDogaGVpZ2h0KTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUdyaWREYXRhKHR5cGUsIHNjYWxlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0aWNrTnVtID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH1gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKFwiLnRpY2tcIilcclxuXHRcdFx0LnNpemUoKTtcclxuXHRcdGxldCBncmlkRGF0YTogRGF0ZVtdID0gW107XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09IFwieWVhclwiKSB7XHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSAkJC5nZXRYRG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IGZpcnN0WWVhciA9IHhEb21haW5bMF0uZ2V0RnVsbFllYXIoKTtcclxuXHRcdFx0Y29uc3QgbGFzdFllYXIgPSB4RG9tYWluWzFdLmdldEZ1bGxZZWFyKCk7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gZmlyc3RZZWFyOyBpIDw9IGxhc3RZZWFyOyBpKyspIHtcclxuXHRcdFx0XHRncmlkRGF0YS5wdXNoKG5ldyBEYXRlKGAke2l9LTAxLTAxIDAwOjAwOjAwYCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRncmlkRGF0YSA9IHNjYWxlLnRpY2tzKDEwKTtcclxuXHJcblx0XHRcdGlmIChncmlkRGF0YS5sZW5ndGggPiB0aWNrTnVtKSB7IC8vIHVzZSBvbmx5IGludFxyXG5cdFx0XHRcdGdyaWREYXRhID0gZ3JpZERhdGEuZmlsdGVyKGQgPT4gU3RyaW5nKGQpLmluZGV4T2YoXCIuXCIpIDwgMCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ3JpZERhdGE7XHJcblx0fSxcclxuXHJcblx0Z2V0R3JpZEZpbHRlclRvUmVtb3ZlKHBhcmFtcykge1xyXG5cdFx0cmV0dXJuIHBhcmFtcyA/IGxpbmUgPT4ge1xyXG5cdFx0XHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0XHRcdChpc0FycmF5KHBhcmFtcykgPyBwYXJhbXMuY29uY2F0KCkgOiBbcGFyYW1zXSkuZm9yRWFjaChwYXJhbSA9PiB7XHJcblx0XHRcdFx0aWYgKCgoXCJ2YWx1ZVwiIGluIHBhcmFtICYmIGxpbmUudmFsdWUgPT09IHBhcmFtLnZhbHVlKSB8fCAoXCJjbGFzc1wiIGluIHBhcmFtICYmIGxpbmUuY2xhc3MgPT09IHBhcmFtLmNsYXNzKSkpIHtcclxuXHRcdFx0XHRcdGZvdW5kID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZvdW5kO1xyXG5cdFx0fSA6ICgpID0+IHRydWU7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgZm9yWCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRvUmVtb3ZlID0gJCQuZ2V0R3JpZEZpbHRlclRvUmVtb3ZlKHBhcmFtcyk7XHJcblx0XHRjb25zdCB0b1Nob3cgPSBsaW5lID0+ICF0b1JlbW92ZShsaW5lKTtcclxuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSBmb3JYID8gQ0xBU1MueGdyaWRMaW5lcyA6IENMQVNTLnlncmlkTGluZXM7XHJcblx0XHRjb25zdCBjbGFzc0xpbmUgPSBmb3JYID8gQ0xBU1MueGdyaWRMaW5lIDogQ0xBU1MueWdyaWRMaW5lO1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdChgLiR7Y2xhc3NMaW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtjbGFzc0xpbmV9YClcclxuXHRcdFx0LmZpbHRlcih0b1JlbW92ZSlcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRjb25zdCBncmlkTGluZXMgPSBgZ3JpZF8ke2ZvclggPyBcInhcIiA6IFwieVwifV9saW5lc2A7XHJcblxyXG5cdFx0Y29uZmlnW2dyaWRMaW5lc10gPSBjb25maWdbZ3JpZExpbmVzXS5maWx0ZXIodG9TaG93KTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7IC8vIHNlbGVjdGlvblxyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdFJlZ2lvbigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLnJlZ2lvbi5tYWluID0gJGVsLm1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5zdGF0ZS5jbGlwLnBhdGgpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MucmVnaW9ucyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmVnaW9uKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Ly8gaGlkZSBpZiBhcmMgdHlwZVxyXG5cdFx0JGVsLnJlZ2lvbi5tYWluLnN0eWxlKFwidmlzaWJpbGl0eVwiLCAkJC5oYXNBcmNUeXBlKCkgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCIpO1xyXG5cclxuXHRcdC8vIHNlbGVjdCA8Zz4gZWxlbWVudFxyXG5cdFx0bGV0IGxpc3QgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnJlZ2lvbnN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MucmVnaW9ufWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5yZWdpb25zKTtcclxuXHJcblx0XHRsaXN0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdGxpc3QgPSBsaXN0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0Lm1lcmdlKGxpc3QpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NSZWdpb24uYmluZCgkJCkpO1xyXG5cclxuXHRcdGxpc3RcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHQkZWwucmVnaW9uLmxpc3QgPSBsaXN0O1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd1JlZ2lvbih3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC4kZWwucmVnaW9uLmxpc3Quc2VsZWN0KFwicmVjdFwiKTtcclxuXHJcblx0XHRyZWdpb25zID0gKHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsICQkLnJlZ2lvblkuYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLnJlZ2lvbkhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBkID0+IChpc1ZhbHVlKGQub3BhY2l0eSkgPyBkLm9wYWNpdHkgOiBcIjAuMVwiKSlcclxuXHRcdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3NhcnkgcmVjdCBhZnRlciB0cmFuc2l0aW9uXHJcblx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzLnBhcmVudE5vZGUpXHJcblx0XHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJyZWN0Om5vdChbeF0pXCIpXHJcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWdpb25YWSh0eXBlLCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1ggPSB0eXBlID09PSBcInhcIjtcclxuXHRcdGxldCBrZXkgPSBcInN0YXJ0XCI7XHJcblx0XHRsZXQgY3VyclNjYWxlO1xyXG5cdFx0bGV0IHBvcyA9IDA7XHJcblxyXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcclxuXHRcdFx0aWYgKCFpc1gpIHtcclxuXHRcdFx0XHRrZXkgPSBcImVuZFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoKGlzWCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XHJcblx0XHRcdFx0Y3VyclNjYWxlID0gc2NhbGVbZC5heGlzXTtcclxuXHRcdFx0XHRwb3MgPSBjdXJyU2NhbGUoZFtrZXldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICgoaXNYID8gIWlzUm90YXRlZCA6IGlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcclxuXHRcdFx0Y3VyclNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cdFx0XHRwb3MgPSBjdXJyU2NhbGUoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUoZFtrZXldKSA6IGRba2V5XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvcztcclxuXHR9LFxyXG5cclxuXHRyZWdpb25YKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieFwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRyZWdpb25ZKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieVwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWdpb25TaXplKHR5cGUsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1dpZHRoID0gdHlwZSA9PT0gXCJ3aWR0aFwiO1xyXG5cdFx0Y29uc3Qgc3RhcnQgPSAkJFtpc1dpZHRoID8gXCJyZWdpb25YXCIgOiBcInJlZ2lvbllcIl0oZCk7XHJcblx0XHRsZXQgY3VyclNjYWxlO1xyXG5cdFx0bGV0IGtleSA9IFwiZW5kXCI7XHJcblx0XHRsZXQgZW5kID0gc3RhdGVbdHlwZV07XHJcblxyXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcclxuXHRcdFx0aWYgKCFpc1dpZHRoKSB7XHJcblx0XHRcdFx0a2V5ID0gXCJzdGFydFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoKGlzV2lkdGggPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRcdGN1cnJTY2FsZSA9IHNjYWxlW2QuYXhpc107XHJcblx0XHRcdFx0ZW5kID0gY3VyclNjYWxlKGRba2V5XSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoKGlzV2lkdGggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRjdXJyU2NhbGUgPSBzY2FsZS56b29tIHx8IHNjYWxlLng7XHJcblx0XHRcdGVuZCA9IGN1cnJTY2FsZSgkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShkW2tleV0pIDogZFtrZXldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZW5kIDwgc3RhcnQgPyAwIDogZW5kIC0gc3RhcnQ7XHJcblx0fSxcclxuXHJcblx0cmVnaW9uV2lkdGgoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcIndpZHRoXCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdHJlZ2lvbkhlaWdodChkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25TaXplKFwiaGVpZ2h0XCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdGlzUmVnaW9uT25YKGQpIHtcclxuXHRcdHJldHVybiAhZC5heGlzIHx8IGQuYXhpcyA9PT0gXCJ4XCI7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge3JnYiBhcyBkM1JnYn0gZnJvbSBcImQzLWNvbG9yXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm59IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFNlbGVjdCBhIHBvaW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBvaW50XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuXHQgKi9cclxuXHRzZWxlY3RQb2ludCh0YXJnZXQsIGQsIGkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGN4ID0gKGlzUm90YXRlZCA/ICQkLmNpcmNsZVkgOiAkJC5jaXJjbGVYKS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGN5ID0gKGlzUm90YXRlZCA/ICQkLmNpcmNsZVggOiAkJC5jaXJjbGVZKS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IHIgPSAkJC5wb2ludFNlbGVjdFIuYmluZCgkJCk7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29uc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0Ly8gYWRkIHNlbGVjdGVkLWNpcmNsZSBvbiBsb3cgbGF5ZXIgZ1xyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcclxuXHRcdFx0LmRhdGEoW2RdKVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiY2lyY2xlXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKCkgPT4gJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zZWxlY3RlZENpcmNsZSwgaSkpXHJcblx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpXHJcblx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpXHJcblx0XHRcdC5hdHRyKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgZDIgPT4gJCQucG9pbnRTZWxlY3RSKGQyKSAqIDEuNClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgcik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5lbGVjdCBhIHBvaW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBvaW50XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuXHQgKi9cclxuXHR1bnNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuZGF0YV9vbnVuc2VsZWN0ZWQsICQkLmFwaSwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0Ly8gcmVtb3ZlIHNlbGVjdGVkLWNpcmNsZSBmcm9tIGxvdyBsYXllciBnXHJcblx0XHQkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlfS0ke2l9YClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuYXR0cihcInJcIiwgMClcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBwb2ludHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gc2VsZWN0LlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqL1xyXG5cdHRvZ2dsZVBvaW50KHNlbGVjdGVkLCB0YXJnZXQsIGQsIGkpIHtcclxuXHRcdGNvbnN0IG1ldGhvZCA9IGAke3NlbGVjdGVkID8gXCJcIiA6IFwidW5cIn1zZWxlY3RQb2ludGA7XHJcblxyXG5cdFx0dGhpc1ttZXRob2RdKHRhcmdldCwgZCwgaSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2VsZWN0IGEgcGF0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwYXRoXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKi9cclxuXHRzZWxlY3RQYXRoKHRhcmdldCwgZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQsIGQsIHRhcmdldC5ub2RlKCkpO1xyXG5cclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fYnJpZ2h0ZW4pIHtcclxuXHRcdFx0dGFyZ2V0LnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAoKSA9PiBkM1JnYigkJC5jb2xvcihkKSkuYnJpZ2h0ZXIoMC43NSkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVuZWxlY3QgYSBwYXRoXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBhdGhcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqL1xyXG5cdHVuc2VsZWN0UGF0aCh0YXJnZXQsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29udW5zZWxlY3RlZCwgJCQsIGQsIHRhcmdldC5ub2RlKCkpO1xyXG5cclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fYnJpZ2h0ZW4pIHtcclxuXHRcdFx0dGFyZ2V0LnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMDApXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAoKSA9PiAkJC5jb2xvcihkKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIGxpbmVzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHNlbGVjdC5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuXHQgKi9cclxuXHR0b2dnbGVQYXRoKHNlbGVjdGVkLCB0YXJnZXQsIGQsIGkpIHtcclxuXHRcdHRoaXNbXHJcblx0XHRcdGAke3NlbGVjdGVkID8gXCJcIiA6IFwidW5cIn1zZWxlY3RQYXRoYFxyXG5cdFx0XSh0YXJnZXQsIGQsIGkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHRvZ2dsZSBtZXRob2Qgb2YgdGhlIHRhcmdldFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBzaGFwZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcblx0ICogQHJldHVybnMge0Z1bmN0aW9ufSB0b2dnbGUgbWV0aG9kXHJcblx0ICovXHJcblx0Z2V0VG9nZ2xlKHRoYXQsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gdGhhdC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIgP1xyXG5cdFx0XHQkJC50b2dnbGVQYXRoIDogKFxyXG5cdFx0XHRcdCQkLmlzU3RlcFR5cGUoZCkgP1xyXG5cdFx0XHRcdFx0KCkgPT4ge30gOiAvLyBjaXJjbGUgaXMgaGlkZGVuIGluIHN0ZXAgY2hhcnQsIHNvIHRyZWF0IGFzIHdpdGhpbiB0aGUgY2xpY2sgYXJlYVxyXG5cdFx0XHRcdFx0JCQudG9nZ2xlUG9pbnRcclxuXHRcdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2Ygc2hhcGVzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXhcclxuXHQgKi9cclxuXHR0b2dnbGVTaGFwZSh0aGF0LCBkLCBpKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhhdCk7XHJcblx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblx0XHRjb25zdCB0b2dnbGUgPSAkJC5nZXRUb2dnbGUodGhhdCwgZCkuYmluZCgkJCk7XHJcblx0XHRsZXQgdG9nZ2xlZFNoYXBlO1xyXG5cclxuXHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpKSB7XHJcblx0XHRcdGlmICghY29uZmlnLmRhdGFfc2VsZWN0aW9uX211bHRpcGxlKSB7XHJcblx0XHRcdFx0bGV0IHNlbGVjdG9yID0gYC4ke0NMQVNTLnNoYXBlc31gO1xyXG5cclxuXHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQpIHtcclxuXHRcdFx0XHRcdHNlbGVjdG9yICs9ICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGQuaWQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWFpbi5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpKSB7XHJcblx0XHRcdFx0XHRcdFx0dG9nZ2xlZFNoYXBlID0gc2hhcGU7XHJcblx0XHRcdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCF0b2dnbGVkU2hhcGUgfHwgdG9nZ2xlZFNoYXBlLm5vZGUoKSAhPT0gc2hhcGUubm9kZSgpKSB7XHJcblx0XHRcdFx0c2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgIWlzU2VsZWN0ZWQpO1xyXG5cdFx0XHRcdHRvZ2dsZSghaXNTZWxlY3RlZCwgc2hhcGUsIGQsIGkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge21vdXNlIGFzIGQzTW91c2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldFJhbmRvbSwgZ2V0UmVjdFNlZ0xpc3QsIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRCYXIoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgbWFpbkJhclVwZGF0ZSA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRCYXJzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QmFyfWApXHJcblx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0QmFyKGQpICsgY2xhc3NGb2N1cyhkKSk7XHJcblx0XHRjb25zdCBtYWluQmFyRW50ZXIgPSBtYWluQmFyVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHQvLyBCYXJzIGZvciBlYWNoIGRhdGFcclxuXHRcdG1haW5CYXJFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXJzKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUJhcihkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBiYXJEYXRhID0gJCQuYmFyRGF0YS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFyID0gJCQuY2xhc3NCYXIuYmluZCgkJCk7XHJcblx0XHRjb25zdCBpbml0aWFsT3BhY2l0eSA9ICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpO1xyXG5cclxuXHRcdCRlbC5iYXIgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9YClcclxuXHRcdFx0LmRhdGEoYmFyRGF0YSk7XHJcblxyXG5cdFx0JGVsLmJhci5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwuYmFyID0gJGVsLmJhci5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0JhcilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKCRlbC5iYXIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgaW5pdGlhbE9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0JhcihkcmF3QmFyLCB3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3Qge2Jhcn0gPSB0aGlzLiRlbDtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiBiYXIpXHJcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCB0aGlzLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdGdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XHJcblx0XHRjb25zdCB0aWNrSW50ZXJ2YWwgPSAoc2NhbGUuem9vbSB8fCAkJCkgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSA/XHJcblx0XHRcdCQkLnh4KHNjYWxlLnN1YlguZG9tYWluKClbMV0pIC8gbWF4RGF0YUNvdW50IDogYXhpcy50aWNrSW50ZXJ2YWwobWF4RGF0YUNvdW50KTtcclxuXHRcdGxldCByZXN1bHQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0V2lkdGggPSAoaWQ/OiBzdHJpbmcpID0+IHtcclxuXHRcdFx0Y29uc3Qgd2lkdGggPSBpZCA/IGNvbmZpZy5iYXJfd2lkdGhbaWRdIDogY29uZmlnLmJhcl93aWR0aDtcclxuXHRcdFx0Y29uc3QgcmF0aW8gPSBpZCA/IHdpZHRoLnJhdGlvIDogY29uZmlnLmJhcl93aWR0aF9yYXRpbztcclxuXHRcdFx0Y29uc3QgbWF4ID0gaWQgPyB3aWR0aC5tYXggOiBjb25maWcuYmFyX3dpZHRoX21heDtcclxuXHRcdFx0Y29uc3QgdyA9IGlzTnVtYmVyKHdpZHRoKSA/XHJcblx0XHRcdFx0d2lkdGggOiBiYXJUYXJnZXRzTnVtID8gKHRpY2tJbnRlcnZhbCAqIHJhdGlvKSAvIGJhclRhcmdldHNOdW0gOiAwO1xyXG5cclxuXHRcdFx0cmV0dXJuIG1heCAmJiB3ID4gbWF4ID8gbWF4IDogdztcclxuXHRcdH07XHJcblxyXG5cdFx0cmVzdWx0ID0gZ2V0V2lkdGgoKTtcclxuXHJcblx0XHRpZiAoIWlzR3JvdXBlZCAmJiBpc09iamVjdFR5cGUoY29uZmlnLmJhcl93aWR0aCkpIHtcclxuXHRcdFx0cmVzdWx0ID0ge3dpZHRoOiByZXN1bHQsIHRvdGFsOiBbXX07XHJcblxyXG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRpZiAoY29uZmlnLmJhcl93aWR0aFt2LmlkXSkge1xyXG5cdFx0XHRcdFx0cmVzdWx0W3YuaWRdID0gZ2V0V2lkdGgodi5pZCk7XHJcblx0XHRcdFx0XHRyZXN1bHQudG90YWwucHVzaChyZXN1bHRbdi5pZF0gfHwgcmVzdWx0LndpZHRoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QmFycyhpLCBpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xyXG5cclxuXHRcdHJldHVybiAoaWQgPyBtYWluXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiBtYWluKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9JHtzdWZmaXh9YCk7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQmFycyhpLCBpZCwgcmVzZXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXNldCAmJiAkJC51bmV4cGFuZEJhcnMoKTtcclxuXHRcdCQkLmdldEJhcnMoaSwgaWQpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdHVuZXhwYW5kQmFycyhpKSB7XHJcblx0XHR0aGlzLmdldEJhcnMoaSkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlRHJhd0JhcihiYXJJbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc0dyb3VwZWQgPSBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoO1xyXG5cdFx0Y29uc3QgYmFyUmFkaXVzID0gY29uZmlnLmJhcl9yYWRpdXM7XHJcblx0XHRjb25zdCBiYXJSYWRpdXNSYXRpbyA9IGNvbmZpZy5iYXJfcmFkaXVzX3JhdGlvO1xyXG5cclxuXHRcdC8vIGdldCB0aGUgYmFyIHJhZGl1c1xyXG5cdFx0Y29uc3QgZ2V0UmFkaXVzID0gaXNOdW1iZXIoYmFyUmFkaXVzKSAmJiBiYXJSYWRpdXMgPiAwID9cclxuXHRcdFx0KCkgPT4gYmFyUmFkaXVzIDogKFxyXG5cdFx0XHRcdGlzTnVtYmVyKGJhclJhZGl1c1JhdGlvKSA/IHcgPT4gdyAqIGJhclJhZGl1c1JhdGlvIDogbnVsbFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xyXG5cdFx0XHQvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcclxuXHRcdFx0Y29uc3QgcG9pbnRzID0gZ2V0UG9pbnRzKGQsIGkpO1xyXG5cclxuXHRcdFx0Ly8gc3dpdGNoIHBvaW50cyBpZiBheGlzIGlzIHJvdGF0ZWQsIG5vdCBhcHBsaWNhYmxlIGZvciBzdWIgY2hhcnRcclxuXHRcdFx0Y29uc3QgaW5kZXhYID0gK2lzUm90YXRlZDtcclxuXHRcdFx0Y29uc3QgaW5kZXhZID0gKyFpbmRleFg7XHJcblxyXG5cdFx0XHRjb25zdCBpc05lZ2F0aXZlID0gZC52YWx1ZSA8IDA7XHJcblx0XHRcdGNvbnN0IHBhdGhSYWRpdXMgPSBbXCJcIiwgXCJcIl07XHJcblx0XHRcdGxldCByYWRpdXMgPSAwO1xyXG5cclxuXHRcdFx0aWYgKGdldFJhZGl1cyAmJiAhaXNHcm91cGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpc1JvdGF0ZWQgPyBpbmRleFkgOiBpbmRleFg7XHJcblx0XHRcdFx0Y29uc3QgYmFyVyA9IHBvaW50c1syXVtpbmRleF0gLSBwb2ludHNbMF1baW5kZXhdO1xyXG5cclxuXHRcdFx0XHRyYWRpdXMgPSBnZXRSYWRpdXMoYmFyVyk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGFyYyA9IGBhJHtyYWRpdXN9LCR7cmFkaXVzfSAke2lzTmVnYXRpdmUgPyBgMSAwIDBgIDogYDAgMCAxYH0gYDtcclxuXHJcblx0XHRcdFx0cGF0aFJhZGl1c1srIWlzUm90YXRlZF0gPSBgJHthcmN9JHtyYWRpdXN9LCR7cmFkaXVzfWA7XHJcblx0XHRcdFx0cGF0aFJhZGl1c1sraXNSb3RhdGVkXSA9IGAke2FyY30ke1stcmFkaXVzLCByYWRpdXNdW2lzUm90YXRlZCA/IFwic29ydFwiIDogXCJyZXZlcnNlXCJdKCl9YDtcclxuXHJcblx0XHRcdFx0aXNOZWdhdGl2ZSAmJiBwYXRoUmFkaXVzLnJldmVyc2UoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcGF0aCBzdHJpbmcgZGF0YSBzaG91bGRuJ3QgYmUgY29udGFpbmluZyBuZXcgbGluZSBjaGFyc1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy81MzBcclxuXHRcdFx0Y29uc3QgcGF0aCA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0YEgke3BvaW50c1sxXVtpbmRleFhdIC0gcmFkaXVzfSAke3BhdGhSYWRpdXNbMF19ViR7cG9pbnRzWzJdW2luZGV4WV0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1sxXX1IJHtwb2ludHNbM11baW5kZXhYXX1gIDpcclxuXHRcdFx0XHRgViR7cG9pbnRzWzFdW2luZGV4WV0gKyAoaXNOZWdhdGl2ZSA/IC1yYWRpdXMgOiByYWRpdXMpfSAke3BhdGhSYWRpdXNbMF19SCR7cG9pbnRzWzJdW2luZGV4WF0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1sxXX1WJHtwb2ludHNbM11baW5kZXhZXX1gO1xyXG5cclxuXHRcdFx0cmV0dXJuIGBNJHtwb2ludHNbMF1baW5kZXhYXX0sJHtwb2ludHNbMF1baW5kZXhZXX0ke3BhdGh9emA7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgYXhpcyA9IGlzU3ViID8gJCQuYXhpcy5zdWJYIDogJCQuYXhpcy54O1xyXG5cdFx0Y29uc3QgYmFyVGFyZ2V0c051bSA9ICQkLmdldEluZGljZXNNYXgoYmFySW5kaWNlcykgKyAxO1xyXG5cdFx0Y29uc3QgYmFyVyA9ICQkLmdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bSk7XHJcblx0XHRjb25zdCBiYXJYID0gJCQuZ2V0U2hhcGVYKGJhclcsIGJhckluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgYmFyWSA9ICQkLmdldFNoYXBlWSghIWlzU3ViKTtcclxuXHRcdGNvbnN0IGJhck9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzQmFyVHlwZSwgYmFySW5kaWNlcywgISFpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGJhck9mZnNldChkLCBpKSB8fCB5MDsgLy8gb2Zmc2V0IGlzIGZvciBzdGFja2VkIGJhciBjaGFydFxyXG5cdFx0XHRjb25zdCB3aWR0aCA9IGlzTnVtYmVyKGJhclcpID8gYmFyVyA6IGJhcldbZC5pZF0gfHwgYmFyVy53aWR0aDtcclxuXHRcdFx0Y29uc3QgcG9zWCA9IGJhclgoZCk7XHJcblx0XHRcdGxldCBwb3NZID0gYmFyWShkKTtcclxuXHJcblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCAmJiAoXHJcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcclxuXHRcdFx0KSkge1xyXG5cdFx0XHRcdHBvc1kgPSB5MDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cG9zWSAtPSAoeTAgLSBvZmZzZXQpO1xyXG5cclxuXHRcdFx0Ly8gNCBwb2ludHMgdGhhdCBtYWtlIGEgYmFyXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0sXHJcblx0XHRcdFx0W3Bvc1gsIHBvc1ldLFxyXG5cdFx0XHRcdFtwb3NYICsgd2lkdGgsIHBvc1ldLFxyXG5cdFx0XHRcdFtwb3NYICsgd2lkdGgsIG9mZnNldF1cclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5CYXIodGhhdCkge1xyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKHRoYXQpO1xyXG5cdFx0Y29uc3QgbGlzdCA9IGdldFJlY3RTZWdMaXN0KHRoYXQpO1xyXG5cdFx0Y29uc3QgW3NlZzAsIHNlZzFdID0gbGlzdDtcclxuXHRcdGNvbnN0IHggPSBNYXRoLm1pbihzZWcwLngsIHNlZzEueCk7XHJcblx0XHRjb25zdCB5ID0gTWF0aC5taW4oc2VnMC55LCBzZWcxLnkpO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gdGhpcy5jb25maWcuYmFyX3NlbnNpdGl2aXR5O1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhhdC5nZXRCQm94KCk7XHJcblx0XHRjb25zdCBzeCA9IHggLSBvZmZzZXQ7XHJcblx0XHRjb25zdCBleCA9IHggKyB3aWR0aCArIG9mZnNldDtcclxuXHRcdGNvbnN0IHN5ID0geSArIGhlaWdodCArIG9mZnNldDtcclxuXHRcdGNvbnN0IGV5ID0geSAtIG9mZnNldDtcclxuXHJcblx0XHRyZXR1cm4gc3ggPCBtb3VzZVswXSAmJlxyXG5cdFx0XHRtb3VzZVswXSA8IGV4ICYmXHJcblx0XHRcdGV5IDwgbW91c2VbMV0gJiZcclxuXHRcdFx0bW91c2VbMV0gPCBzeTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtnZXRNaW5NYXgsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBpc09iamVjdH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRCdWJibGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwiYnViYmxlXCIpKSB7XHJcblx0XHRcdGNvbmZpZy5wb2ludF9zaG93ID0gdHJ1ZTtcclxuXHRcdFx0Y29uZmlnLnBvaW50X3R5cGUgPSBcImNpcmNsZVwiO1xyXG5cdFx0XHRjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkgPSAyNTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdXNlciBhZ2VudCdzIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBwYXRoIGluIHVzZXIgdW5pdHNcclxuXHQgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU1ZHR2VvbWV0cnlFbGVtZW50L2dldFRvdGFsTGVuZ3RoXHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZUxlbmd0aCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtheGlzfSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCIkYmFzZUxlbmd0aFwiO1xyXG5cdFx0bGV0IGJhc2VMZW5ndGggPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghYmFzZUxlbmd0aCkge1xyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIGJhc2VMZW5ndGggPSBnZXRNaW5NYXgoXCJtaW5cIiwgW1xyXG5cdFx0XHRcdGF4aXMueC5zZWxlY3QoXCJwYXRoXCIpLm5vZGUoKVxyXG5cdFx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKCksXHJcblx0XHRcdFx0YXhpcy55LnNlbGVjdChcInBhdGhcIikubm9kZSgpXHJcblx0XHRcdFx0XHQuZ2V0VG90YWxMZW5ndGgoKVxyXG5cdFx0XHRdKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJhc2VMZW5ndGg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSByYWRpdXMgdmFsdWUgZm9yIGJ1YmJsZSBjaXJjbGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG4gXHQgKi9cclxuXHRnZXRCdWJibGVSKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCBtYXhSID0gJCQuY29uZmlnLmJ1YmJsZV9tYXhSO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKG1heFIpKSB7XHJcblx0XHRcdG1heFIgPSBtYXhSKGQpO1xyXG5cdFx0fSBlbHNlIGlmICghaXNOdW1iZXIobWF4UikpIHtcclxuXHRcdFx0bWF4UiA9ICgkJC5nZXRCYXNlTGVuZ3RoKCkgLyAoJCQuZ2V0TWF4RGF0YUNvdW50KCkgKiAyKSkgKyAxMjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgJCQuZ2V0TWluTWF4RGF0YSgpLm1heC5tYXAoZCA9PiAoXHJcblx0XHRcdCQkLmlzQnViYmxlWlR5cGUoZCkgP1xyXG5cdFx0XHRcdCQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwieVwiKSA6IChcclxuXHRcdFx0XHRcdGlzT2JqZWN0KGQudmFsdWUpID8gZC52YWx1ZS5taWQgOiBkLnZhbHVlXHJcblx0XHRcdFx0KVxyXG5cdFx0KSkpO1xyXG5cdFx0Y29uc3QgbWF4QXJlYSA9IG1heFIgKiBtYXhSICogTWF0aC5QSTtcclxuXHRcdGNvbnN0IGFyZWEgPSAoJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwielwiKSA6IGQudmFsdWUpICogKG1heEFyZWEgLyBtYXgpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoYXJlYSAvIE1hdGguUEkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBidWJibGUgZGltZW5zaW9uIGRhdGFcclxuXHQgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZCBkYXRhIHZhbHVlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSB5IG9yIHpcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRCdWJibGVaRGF0YShkLCB0eXBlKSB7XHJcblx0XHRyZXR1cm4gaXNPYmplY3QoZCkgPyBkW3R5cGVdIDogZFt0eXBlID09PSBcInlcIiA/IDAgOiAxXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmUgaWYgYnViYmxlIGhhcyBkaW1lbnNpb24gZGF0YVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fGFycmF5fSBkIGRhdGEgdmFsdWVcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aXNCdWJibGVaVHlwZShkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmlzQnViYmxlVHlwZShkKSAmJiAoXHJcblx0XHRcdChpc09iamVjdChkLnZhbHVlKSAmJiAoXCJ6XCIgaW4gZC52YWx1ZSB8fCBcInlcIiBpbiBkLnZhbHVlKSkgfHxcclxuXHRcdFx0KGlzQXJyYXkoZC52YWx1ZSkgJiYgZC52YWx1ZS5sZW5ndGggPT09IDIpXHJcblx0XHQpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdGFyZWEgYXMgZDNBcmVhLFxyXG5cdGxpbmUgYXMgZDNMaW5lXHJcbn0gZnJvbSBcImQzLXNoYXBlXCI7XHJcbmltcG9ydCB7XHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3RcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRSYW5kb20sIGlzQXJyYXksIGlzRGVmaW5lZCwgaXNGdW5jdGlvbiwgaXNVbmRlZmluZWQsIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRMaW5lKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0TGluZXMpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydExpbmUgPSAkJC5jbGFzc0NoYXJ0TGluZS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NBcmVhcyA9ICQkLmNsYXNzQXJlYXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0NpcmNsZXMgPSAkJC5jbGFzc0NpcmNsZXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCBtYWluTGluZVVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydExpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0TGluZX1gKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydExpbmUoZCkgKyBjbGFzc0ZvY3VzKGQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluTGluZUVudGVyID0gbWFpbkxpbmVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHQvLyBMaW5lcyBmb3IgZWFjaCBkYXRhXHJcblx0XHRtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcclxuXHJcblx0XHQvLyBBcmVhc1xyXG5cdFx0bWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBcmVhcyk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdC8vIENpcmNsZXMgZm9yIGVhY2ggZGF0YSBwb2ludCBvbiBsaW5lc1xyXG5cdFx0XHRjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zZWxlY3RlZENpcmNsZXMsIGQuaWQpKTtcclxuXHJcblx0XHRcdG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaXJjbGVzKVxyXG5cdFx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGRhdGUgZm9yIHNlbGVjdGVkIGNpcmNsZXNcclxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHQuaWQpfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgJHtDTEFTUy5zZWxlY3RlZENpcmNsZX1gKVxyXG5cdFx0XHRcdC5lYWNoKGQgPT4ge1xyXG5cdFx0XHRcdFx0ZC52YWx1ZSA9IHQudmFsdWVzW2QuaW5kZXhdLnZhbHVlO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi5cclxuXHRcdC8vIG1haW5MaW5lVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2Zvcm1hdDoge2V4dHJhTGluZUNsYXNzZXN9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLmxpbmUgPSAkZWwubWFpblxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwubGluZS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwubGluZSA9ICRlbC5saW5lLmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAkeyQkLmNsYXNzTGluZS5iaW5kKCQkKShkKX0gJHtleHRyYUxpbmVDbGFzc2VzKGQpIHx8IFwiXCJ9YClcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2UoJGVsLmxpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInNoYXBlLXJlbmRlcmluZ1wiLCBkID0+ICgkJC5pc1N0ZXBUeXBlKGQpID8gXCJjcmlzcEVkZ2VzXCIgOiBcIlwiKSlcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3TGluZShkcmF3TGluZSwgd2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0IHtsaW5lfSA9IHRoaXMuJGVsO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxpbmUudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiBsaW5lKVxyXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3TGluZSlcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgdGhpcy5jb2xvcilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGN1cnZlIGludGVycG9sYXRlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q3VydmUoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkU3RlcFR5cGUgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkICYmICQkLmlzU3RlcFR5cGUoZCk7XHJcblxyXG5cdFx0Ly8gd2hlbiBpcyBzdGVwICYgcm90YXRlZCwgc2hvdWxkIGJlIGNvbXB1dGVkIGluIGRpZmZlcmVudCB3YXlcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ3MVxyXG5cdFx0cmV0dXJuIGlzUm90YXRlZFN0ZXBUeXBlID8gY29udGV4dCA9PiB7XHJcblx0XHRcdGNvbnN0IHN0ZXAgPSAkJC5nZXRJbnRlcnBvbGF0ZShkKShjb250ZXh0KTtcclxuXHJcblx0XHRcdC8vIGtlZXAgdGhlIG9yaWdpbmFsIG1ldGhvZFxyXG5cdFx0XHRzdGVwLm9yZ1BvaW50ID0gc3RlcC5wb2ludDtcclxuXHJcblx0XHRcdC8vIHRvIGdldCByb3RhdGVkIHBhdGggZGF0YVxyXG5cdFx0XHRzdGVwLnBvaW50Um90YXRlZCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHR0aGlzLl9wb2ludCA9PT0gMSAmJiAodGhpcy5fcG9pbnQgPSAyKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgeTEgPSB0aGlzLl95ICogKDEgLSB0aGlzLl90KSArIHkgKiB0aGlzLl90O1xyXG5cclxuXHRcdFx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5MSk7XHJcblx0XHRcdFx0dGhpcy5fY29udGV4dC5saW5lVG8oeCwgeTEpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0XHR0aGlzLl95ID0geTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHN0ZXAucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0dGhpcy5fcG9pbnQgPT09IDAgPyB0aGlzLm9yZ1BvaW50KHgsIHkpIDogdGhpcy5wb2ludFJvdGF0ZWQoeCwgeSk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gc3RlcDtcclxuXHRcdH0gOiAkJC5nZXRJbnRlcnBvbGF0ZShkKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZURyYXdMaW5lKGxpbmVJbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKGxpbmVJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGVHZXR0ZXIgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IHtcclxuXHRcdFx0Y29uc3QgcCA9IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cclxuXHRcdFx0Ly8gaWYgKGQudmFsdWUgPT09IDIwMCkge1xyXG5cdFx0XHQvLyBcdGNvbnNvbGUubG9nKHApO1xyXG5cdFx0XHQvLyB9XHJcblxyXG5cdFx0XHRyZXR1cm4gcDtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgeVZhbHVlID0gKGQsIGkpID0+IChcclxuXHRcdFx0JCQuaXNHcm91cGVkKGQuaWQpID9cclxuXHRcdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHRcdHlTY2FsZUdldHRlci5jYWxsKCQkLCBkLmlkKSgkJC5nZXRCYXNlVmFsdWUoZCkpXHJcblx0XHQpO1xyXG5cclxuXHRcdGxldCBsaW5lID0gZDNMaW5lKCk7XHJcblxyXG5cdFx0bGluZSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdGxpbmUueCh5VmFsdWUpLnkoeFZhbHVlKSA6IGxpbmUueCh4VmFsdWUpLnkoeVZhbHVlKTtcclxuXHJcblx0XHRpZiAoIWxpbmVDb25uZWN0TnVsbCkge1xyXG5cdFx0XHRsaW5lID0gbGluZS5kZWZpbmVkKGQgPT4gJCQuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB4ID0gaXNTdWIgPyBzY2FsZS5zdWJYIDogc2NhbGUueDtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGNvbnN0IHkgPSB5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCk7XHJcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xyXG5cdFx0XHRsZXQgeDAgPSAwO1xyXG5cdFx0XHRsZXQgeTAgPSAwO1xyXG5cdFx0XHRsZXQgcGF0aDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0xpbmVUeXBlKGQpKSB7XHJcblx0XHRcdFx0Y29uc3QgcmVnaW9ucyA9IGNvbmZpZy5kYXRhX3JlZ2lvbnNbZC5pZF07XHJcblxyXG5cdFx0XHRcdGlmIChyZWdpb25zKSB7XHJcblx0XHRcdFx0XHRwYXRoID0gJCQubGluZVdpdGhSZWdpb25zKHZhbHVlcywgeCwgeSwgcmVnaW9ucyk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpKSB7XHJcblx0XHRcdFx0XHRcdHZhbHVlcyA9ICQkLmNvbnZlcnRWYWx1ZXNUb1N0ZXAodmFsdWVzKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRwYXRoID0gbGluZS5jdXJ2ZSgkJC5nZXRDdXJ2ZShkKSkodmFsdWVzKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh2YWx1ZXNbMF0pIHtcclxuXHRcdFx0XHRcdHgwID0geCh2YWx1ZXNbMF0ueCk7XHJcblx0XHRcdFx0XHR5MCA9IHkodmFsdWVzWzBdLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHBhdGggPSBpc1JvdGF0ZWQgPyBgTSAke3kwfSAke3gwfWAgOiBgTSAke3gwfSAke3kwfWA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBwYXRoIHx8IFwiTSAwIDBcIjtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRMaW5lUG9pbnRzKGxpbmVJbmRpY2VzLCBpc1N1YlZhbHVlKSB7IC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1N1YiA9ICEhaXNTdWJWYWx1ZTtcclxuXHRcdGNvbnN0IHggPSAkJC5nZXRTaGFwZVgoMCwgbGluZUluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoaXNTdWIpO1xyXG5cdFx0Y29uc3QgbGluZU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzTGluZVR5cGUsIGxpbmVJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGxpbmVPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XHJcblx0XHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xyXG5cdFx0XHRsZXQgcG9zWSA9IHkoZCk7XHJcblxyXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxyXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXHJcblx0XHRcdCkpIHtcclxuXHRcdFx0XHRwb3NZID0geTA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgbGluZSBwb3NpdGlvblxyXG5cdFx0XHRjb25zdCBwb2ludCA9IFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV07XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdHBvaW50LFxyXG5cdFx0XHRcdHBvaW50LCAvLyBmcm9tIGhlcmUgYW5kIGJlbG93LCBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRsaW5lV2l0aFJlZ2lvbnMoZCwgeCwgeSwgX3JlZ2lvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRjb25zdCB4T2Zmc2V0ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gMC41IDogMDtcclxuXHRcdGNvbnN0IHJlZ2lvbnM6IGFueVtdID0gW107XHJcblx0XHRjb25zdCBkYXNoYXJyYXkgPSBcIjIgMlwiOyAvLyBkZWZhdWx0IHZhbHVlXHJcblxyXG5cdFx0bGV0IHhwO1xyXG5cdFx0bGV0IHlwO1xyXG5cdFx0bGV0IGRpZmY7XHJcblx0XHRsZXQgZGlmZngyO1xyXG5cclxuXHRcdC8vIGNoZWNrIHdlYXRoZXIgZGF0YSBpcyB3aXRoaW4gcmVnaW9uXHJcblx0XHRjb25zdCBpc1dpdGhpblJlZ2lvbnMgPSAod2l0aGluWCwgd2l0aGluUmVnaW9ucykgPT4ge1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgcmVnOyAocmVnID0gd2l0aGluUmVnaW9uc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdGlmIChyZWcuc3RhcnQgPCB3aXRoaW5YICYmIHdpdGhpblggPD0gcmVnLmVuZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlZy5zdHlsZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQ2hlY2sgc3RhcnQvZW5kIG9mIHJlZ2lvbnNcclxuXHRcdGlmIChpc0RlZmluZWQoX3JlZ2lvbnMpKSB7XHJcblx0XHRcdGNvbnN0IGdldFZhbHVlID0gKHY6IERhdGUgfCBhbnksIGRlZjogbnVtYmVyKTogRGF0ZSB8IGFueSA9PiAoXHJcblx0XHRcdFx0aXNVbmRlZmluZWQodikgPyBkZWYgOiAoaXNUaW1lU2VyaWVzID8gJCQucGFyc2VEYXRlKHYpIDogdilcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCByZWc7IChyZWcgPSBfcmVnaW9uc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gZ2V0VmFsdWUocmVnLnN0YXJ0LCBkWzBdLngpO1xyXG5cdFx0XHRcdGNvbnN0IGVuZCA9IGdldFZhbHVlKHJlZy5lbmQsIGRbZC5sZW5ndGggLSAxXS54KTtcclxuXHRcdFx0XHRjb25zdCBzdHlsZSA9IHJlZy5zdHlsZSB8fCB7ZGFzaGFycmF5fTtcclxuXHJcblx0XHRcdFx0cmVnaW9uc1tpXSA9IHtzdGFydCwgZW5kLCBzdHlsZX07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgc2NhbGVzXHJcblx0XHRjb25zdCB4VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB5KGR0LnZhbHVlKSA6IGR0ID0+IHgoZHQueCk7XHJcblx0XHRjb25zdCB5VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB4KGR0LngpIDogZHQgPT4geShkdC52YWx1ZSk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIHN2ZyBnZW5lcmF0b3IgZnVuY3Rpb24gZm9yIHJlZ2lvblxyXG5cdFx0Y29uc3QgZ2VuZXJhdGVNID0gcG9pbnRzID0+IGBNJHtwb2ludHNbMF1bMF19LCR7cG9pbnRzWzBdWzFdfUwke3BvaW50c1sxXVswXX0sJHtwb2ludHNbMV1bMV19YDtcclxuXHJcblx0XHRjb25zdCBzV2l0aFJlZ2lvbiA9IGlzVGltZVNlcmllcyA/IChkMCwgZDEsIGssIHRpbWVzZXJpZXNEaWZmKSA9PiB7XHJcblx0XHRcdGNvbnN0IHgwID0gZDAueC5nZXRUaW1lKCk7XHJcblx0XHRcdGNvbnN0IHhEaWZmID0gZDEueCAtIGQwLng7XHJcblx0XHRcdGNvbnN0IHh2MCA9IG5ldyBEYXRlKHgwICsgeERpZmYgKiBrKTtcclxuXHRcdFx0Y29uc3QgeHYxID0gbmV3IERhdGUoeDAgKyB4RGlmZiAqIChrICsgdGltZXNlcmllc0RpZmYpKTtcclxuXHJcblx0XHRcdGNvbnN0IHBvaW50cyA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0W1t5KHlwKGspKSwgeCh4djApXSwgW3koeXAoayArIGRpZmYpKSwgeCh4djEpXV0gOlxyXG5cdFx0XHRcdFtbeCh4djApLCB5KHlwKGspKV0sIFt4KHh2MSksIHkoeXAoayArIGRpZmYpKV1dO1xyXG5cclxuXHRcdFx0cmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xyXG5cdFx0fSA6IChkMCwgZDEsIGssIG90aGVyRGlmZikgPT4ge1xyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFtbeSh5cChrKSwgdHJ1ZSksIHgoeHAoaykpXSwgW3koeXAoayArIG90aGVyRGlmZiksIHRydWUpLCB4KHhwKGsgKyBvdGhlckRpZmYpKV1dIDpcclxuXHRcdFx0XHRbW3goeHAoayksIHRydWUpLCB5KHlwKGspKV0sIFt4KHhwKGsgKyBvdGhlckRpZmYpLCB0cnVlKSwgeSh5cChrICsgb3RoZXJEaWZmKSldXTtcclxuXHJcblx0XHRcdHJldHVybiBnZW5lcmF0ZU0ocG9pbnRzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGVcclxuXHRcdGxldCBwYXRoID0gXCJcIjtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMCwgZGF0YTsgKGRhdGEgPSBkW2ldKTsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHByZXZEYXRhID0gZFtpIC0gMV07XHJcblx0XHRcdGNvbnN0IGhhc1ByZXZEYXRhID0gcHJldkRhdGEgJiYgaXNWYWx1ZShwcmV2RGF0YS52YWx1ZSk7XHJcblx0XHRcdGxldCBzdHlsZSA9IGlzV2l0aGluUmVnaW9ucyhkYXRhLngsIHJlZ2lvbnMpO1xyXG5cclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvMTE3MlxyXG5cdFx0XHRpZiAoIWlzVmFsdWUoZGF0YS52YWx1ZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRHJhdyBhcyBub3JtYWxcclxuXHRcdFx0aWYgKGlzVW5kZWZpbmVkKHJlZ2lvbnMpIHx8ICFzdHlsZSB8fCAhaGFzUHJldkRhdGEpIHtcclxuXHRcdFx0XHRwYXRoICs9IGAke2kgJiYgaGFzUHJldkRhdGEgPyBcIkxcIiA6IFwiTVwifSR7eFZhbHVlKGRhdGEpfSwke3lWYWx1ZShkYXRhKX1gO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGhhc1ByZXZEYXRhKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHN0eWxlID0gc3R5bGUuZGFzaGFycmF5LnNwbGl0KFwiIFwiKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRzdHlsZSA9IGRhc2hhcnJheS5zcGxpdChcIiBcIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBEcmF3IHdpdGggcmVnaW9uIC8vIFRPRE86IEZpeCBmb3IgaG9yaXpvdGFsIGNoYXJ0c1xyXG5cdFx0XHRcdHhwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEueCArIHhPZmZzZXQsIGRhdGEueCArIHhPZmZzZXQsIGlzVGltZVNlcmllcyk7XHJcblx0XHRcdFx0eXAgPSAkJC5nZXRTY2FsZShwcmV2RGF0YS52YWx1ZSwgZGF0YS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGR4ID0geChkYXRhLngpIC0geChwcmV2RGF0YS54KTtcclxuXHRcdFx0XHRjb25zdCBkeSA9IHkoZGF0YS52YWx1ZSkgLSB5KHByZXZEYXRhLnZhbHVlKTtcclxuXHRcdFx0XHRjb25zdCBkZCA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xyXG5cclxuXHRcdFx0XHRkaWZmID0gc3R5bGVbMF0gLyBkZDtcclxuXHRcdFx0XHRkaWZmeDIgPSBkaWZmICogc3R5bGVbMV07XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGogPSBkaWZmOyBqIDw9IDE7IGogKz0gZGlmZngyKSB7XHJcblx0XHRcdFx0XHRwYXRoICs9IHNXaXRoUmVnaW9uKHByZXZEYXRhLCBkYXRhLCBqLCBkaWZmKTtcclxuXHJcblx0XHRcdFx0XHQvLyB0byBtYWtlIHN1cmUgY29ycmVjdCBsaW5lIGRyYXdpbmdcclxuXHRcdFx0XHRcdGlmIChqICsgZGlmZngyID49IDEpIHtcclxuXHRcdFx0XHRcdFx0cGF0aCArPSBzV2l0aFJlZ2lvbihwcmV2RGF0YSwgZGF0YSwgMSwgMCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhdGg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJlYUdyYWRpZW50KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtkYXRldGltZUlkfSwgJGVsOiB7ZGVmc319ID0gJCQ7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdGNvbnN0IGlkID0gYCR7ZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzQXJlYVR5cGUoZCkgJiYgZGVmcy5zZWxlY3QoYCMke2lkfWApLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9ICQkLmNvbG9yKGQpO1xyXG5cdFx0XHRcdGNvbnN0IHtcclxuXHRcdFx0XHRcdHggPSBbMCwgMF0sXHJcblx0XHRcdFx0XHR5ID0gWzAsIDFdLFxyXG5cdFx0XHRcdFx0c3RvcHMgPSBbWzAsIGNvbG9yLCAxXSwgWzEsIGNvbG9yLCAwXV1cclxuXHRcdFx0XHR9ID0gY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQ7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGxpbmVhckdyYWRpZW50ID0gZGVmcy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJpZFwiLCBgJHtpZH1gKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4WzBdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB4WzFdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5WzBdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB5WzFdKTtcclxuXHJcblx0XHRcdFx0c3RvcHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHN0b3BDb2xvciA9IGlzRnVuY3Rpb24odlsxXSkgPyB2WzFdKGQuaWQpIDogdlsxXTtcclxuXHJcblx0XHRcdFx0XHRsaW5lYXJHcmFkaWVudC5hcHBlbmQoXCJzdG9wXCIpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwib2Zmc2V0XCIsIHZbMF0pXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwic3RvcC1jb2xvclwiLCBzdG9wQ29sb3IgfHwgY29sb3IpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwic3RvcC1vcGFjaXR5XCIsIHZbMl0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmVhQ29sb3IoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCA/XHJcblx0XHRcdGB1cmwoIyR7JCQuc3RhdGUuZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX0pYCA6XHJcblx0XHRcdCQkLmNvbG9yKGQpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50ICYmICQkLnVwZGF0ZUFyZWFHcmFkaWVudCgpO1xyXG5cclxuXHRcdCRlbC5hcmVhID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwuYXJlYS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwuYXJlYSA9ICRlbC5hcmVhLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3RhdGUub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XHJcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2UoJGVsLmFyZWEpO1xyXG5cclxuXHRcdCRlbC5hcmVhXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgc3RhdGUub3JnQXJlYU9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyZWEoZHJhd0FyZWEsIHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7b3JnQXJlYU9wYWNpdHl9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gJCQuJGVsLmFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiAkJC4kZWwuYXJlYSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+IFN0cmluZygkJC5pc0FyZWFSYW5nZVR5cGUoZCkgPyBvcmdBcmVhT3BhY2l0eSAvIDEuNzUgOiBvcmdBcmVhT3BhY2l0eSkpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGFyZWEgcGF0aCBkYXRhXHJcblx0ICogQHBhcmFtIGFyZWFJbmRpY2VzXHJcblx0ICogQHBhcmFtIGlzU3ViXHJcblx0ICogQHJldHVybiB7ZnVuY3Rpb24oKj0pOiAoKnxzdHJpbmcpfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVEcmF3QXJlYShhcmVhSW5kaWNlcywgaXNTdWIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGVHZXR0ZXIgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cdFx0Y29uc3QgdmFsdWUwID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHR5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCkoXHJcblx0XHRcdFx0JCQuaXNBcmVhUmFuZ2VUeXBlKGQpID9cclxuXHRcdFx0XHRcdCQkLmdldEFyZWFSYW5nZURhdGEoZCwgXCJoaWdoXCIpIDogMFxyXG5cdFx0XHQpKTtcclxuXHRcdGNvbnN0IHZhbHVlMSA9IChkLCBpKSA9PiAoJCQuaXNHcm91cGVkKGQuaWQpID9cclxuXHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzFdWzFdIDpcclxuXHRcdFx0eVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKFxyXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XHJcblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwibG93XCIpIDogZC52YWx1ZVxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xyXG5cdFx0XHRsZXQgeDAgPSAwO1xyXG5cdFx0XHRsZXQgeTAgPSAwO1xyXG5cdFx0XHRsZXQgcGF0aDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpKSB7XHJcblx0XHRcdFx0bGV0IGFyZWEgPSBkM0FyZWEoKTtcclxuXHJcblx0XHRcdFx0YXJlYSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRhcmVhLnkoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQueDAodmFsdWUwKVxyXG5cdFx0XHRcdFx0XHQueDEodmFsdWUxKSA6XHJcblx0XHRcdFx0XHRhcmVhLngoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHRcdC55MChjb25maWcuYXJlYV9hYm92ZSA/IDAgOiB2YWx1ZTApXHJcblx0XHRcdFx0XHRcdC55MSh2YWx1ZTEpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWxpbmVDb25uZWN0TnVsbCkge1xyXG5cdFx0XHRcdFx0YXJlYSA9IGFyZWEuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xyXG5cdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGFyZWEuY3VydmUoJCQuZ2V0Q3VydmUoZCkpKHZhbHVlcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xyXG5cdFx0XHRcdFx0eDAgPSAkJC5zY2FsZS54KHZhbHVlc1swXS54KTtcclxuXHRcdFx0XHRcdHkwID0gJCQuZ2V0WVNjYWxlKGQuaWQpKHZhbHVlc1swXS52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwYXRoID0gaXNSb3RhdGVkID8gYE0gJHt5MH0gJHt4MH1gIDogYE0gJHt4MH0gJHt5MH1gO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0QXJlYVBvaW50cyhhcmVhSW5kaWNlcywgaXNTdWIpIHtcclxuXHRcdC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB4ID0gJCQuZ2V0U2hhcGVYKDAsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XHJcblx0XHRjb25zdCBhcmVhT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNBcmVhVHlwZSwgYXJlYUluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGFyZWFPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XHJcblx0XHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xyXG5cdFx0XHRsZXQgcG9zWSA9IHkoZCk7XHJcblxyXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxyXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXHJcblx0XHRcdCkpIHtcclxuXHRcdFx0XHRwb3NZID0geTA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgYXJlYSBwb3NpdGlvblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdFtwb3NYLCBvZmZzZXRdLFxyXG5cdFx0XHRcdFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sXHJcblx0XHRcdFx0W3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSwgLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0gLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XHJcblx0XHRcdF07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGlzV2l0aGluU3RlcCh0aGF0LCB5KSB7XHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoeSAtIGQzTW91c2UodGhhdClbMV0pIDwgMzA7XHJcblx0fSxcclxuXHJcblx0c2hvdWxkRHJhd1BvaW50c0ZvckxpbmUoZCkge1xyXG5cdFx0Y29uc3QgbGluZVBvaW50ID0gdGhpcy5jb25maWcubGluZV9wb2ludDtcclxuXHJcblx0XHRyZXR1cm4gbGluZVBvaW50ID09PSB0cnVlIHx8XHJcblx0XHRcdChpc0FycmF5KGxpbmVQb2ludCkgJiYgbGluZVBvaW50LmluZGV4T2YoZC5pZCkgIT09IC0xKTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXMsXHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3RcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7Z2V0UmFuZG9tLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNPYmplY3RUeXBlLCBpc1ZhbHVlLCB0b0FycmF5LCBub3RFbXB0eX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aGFzVmFsaWRQb2ludFR5cGUodHlwZSkge1xyXG5cdFx0cmV0dXJuIC9eKGNpcmNsZXxyZWN0KGFuZ2xlKT98cG9seWdvbnxlbGxpcHNlfHVzZSkkL2kudGVzdCh0eXBlIHx8IHRoaXMuY29uZmlnLnBvaW50X3R5cGUpO1xyXG5cdH0sXHJcblxyXG5cdGhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyh0eXBlKSB7XHJcblx0XHRjb25zdCBwb2ludFR5cGUgPSB0eXBlIHx8IHRoaXMuY29uZmlnLnBvaW50X3R5cGU7XHJcblxyXG5cdFx0cmV0dXJuIGlzT2JqZWN0VHlwZShwb2ludFR5cGUpICYmXHJcblx0XHRcdGlzRnVuY3Rpb24ocG9pbnRUeXBlLmNyZWF0ZSkgJiYgaXNGdW5jdGlvbihwb2ludFR5cGUudXBkYXRlKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVDaXJjbGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCFjb25maWcucG9pbnRfc2hvdykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JGVsLmNpcmNsZSA9ICRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlc31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZX1gKVxyXG5cdFx0XHQuZGF0YShkID0+ICEkJC5pc0JhclR5cGUoZCkgJiYgKFxyXG5cdFx0XHRcdCEkJC5pc0xpbmVUeXBlKGQpIHx8ICQkLnNob3VsZERyYXdQb2ludHNGb3JMaW5lKGQpXHJcblx0XHRcdCkgJiYgJCQubGFiZWxpc2hEYXRhKGQpKTtcclxuXHJcblx0XHQkZWwuY2lyY2xlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRjb25zdCBmbiA9ICQkLnBvaW50KFwiY3JlYXRlXCIsIHRoaXMsICQkLnBvaW50Ui5iaW5kKCQkKSwgJCQuY29sb3IpO1xyXG5cclxuXHRcdCRlbC5jaXJjbGUgPSAkZWwuY2lyY2xlLmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChmbilcclxuXHRcdFx0Lm1lcmdlKCRlbC5jaXJjbGUpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5pbml0aWFsT3BhY2l0eUZvckNpcmNsZS5iaW5kKCQkKSk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3Q2lyY2xlKGN4LCBjeSwgd2l0aFRyYW5zaXRpb24sIGZsb3cpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNlbGVjdGVkQ2lyY2xlcyA9ICQkLiRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGV9YCk7XHJcblxyXG5cdFx0aWYgKCEkJC5jb25maWcucG9pbnRfc2hvdykge1xyXG5cdFx0XHRyZXR1cm4gW107XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbWFpbkNpcmNsZXM6IGFueVtdID0gW107XHJcblxyXG5cdFx0JCQuJGVsLmNpcmNsZS5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0Y29uc3QgZm4gPSAkJC5wb2ludChcInVwZGF0ZVwiLCAkJCwgY3gsIGN5LCAkJC5vcGFjaXR5Rm9yQ2lyY2xlLmJpbmQoJCQpLCAkJC5jb2xvciwgd2l0aFRyYW5zaXRpb24sIGZsb3csIHNlbGVjdGVkQ2lyY2xlcykuYmluZCh0aGlzKTtcclxuXHRcdFx0Y29uc3QgcmVzdWx0ID0gZm4oZCk7XHJcblxyXG5cdFx0XHRtYWluQ2lyY2xlcy5wdXNoKHJlc3VsdCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRjb25zdCBwb3NBdHRyID0gJCQuaXNDaXJjbGVQb2ludCgpID8gXCJjXCIgOiBcIlwiO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdG1haW5DaXJjbGVzLFxyXG5cdFx0XHRzZWxlY3RlZENpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihgJHtwb3NBdHRyfXhgLCBjeClcclxuXHRcdFx0XHQuYXR0cihgJHtwb3NBdHRyfXlgLCBjeSlcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0Y2lyY2xlWChkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7eCwgem9vbX0gPSAkJC5zY2FsZTtcclxuXHRcdGNvbnN0IGhhc1ZhbHVlID0gaXNWYWx1ZShkLngpO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuem9vbV9lbmFibGVkICYmIHpvb20gP1xyXG5cdFx0XHQoaGFzVmFsdWUgPyB6b29tKGQueCkgOiBudWxsKSA6XHJcblx0XHRcdChoYXNWYWx1ZSA/IHgoZC54KSA6IG51bGwpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUNpcmNsZVkoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBnZXRQb2ludHMgPSAkJC5nZW5lcmF0ZUdldExpbmVQb2ludHMoJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzTGluZVR5cGUpLCBmYWxzZSk7XHJcblxyXG5cdFx0JCQuY2lyY2xlWSA9IChkLCBpKSA9PiB7XHJcblx0XHRcdGNvbnN0IGlkID0gZC5pZDtcclxuXHJcblx0XHRcdHJldHVybiAkJC5pc0dyb3VwZWQoaWQpID9cclxuXHRcdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHRcdCQkLmdldFlTY2FsZShpZCkoJCQuZ2V0QmFzZVZhbHVlKGQpKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2V0Q2lyY2xlcyhpLCBpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xyXG5cclxuXHRcdHJldHVybiAoaWQgPyAkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiAkJC4kZWwubWFpbilcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlfSR7c3VmZml4fWApO1xyXG5cdH0sXHJcblxyXG5cdGV4cGFuZENpcmNsZXMoaSwgaWQsIHJlc2V0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCByID0gJCQucG9pbnRFeHBhbmRlZFIuYmluZCgkJCk7XHJcblxyXG5cdFx0cmVzZXQgJiYgJCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblxyXG5cdFx0Y29uc3QgY2lyY2xlcyA9ICQkLmdldENpcmNsZXMoaSwgaWQpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIHRydWUpO1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSByKGNpcmNsZXMpIC8gJCQuY29uZmlnLnBvaW50X3I7XHJcblx0XHRjb25zdCByYXRpbyA9IDEgLSBzY2FsZTtcclxuXHJcblx0XHRpZiAoJCQuaXNDaXJjbGVQb2ludCgpKSB7XHJcblx0XHRcdGNpcmNsZXMuYXR0cihcInJcIiwgcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvLyB0cmFuc2Zvcm0gbXVzdCBiZSBhcHBsaWVkIHRvIGVhY2ggbm9kZSBpbmRpdmlkdWFsbHlcclxuXHRcdFx0Y2lyY2xlcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGNvbnN0IHBvaW50ID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdGlmICh0aGlzLnRhZ05hbWUgPT09IFwiY2lyY2xlXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50LmF0dHIoXCJyXCIsIHIpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLmdldEJCb3goKTtcclxuXHRcdFx0XHRcdGNvbnN0IHggPSByYXRpbyAqICgrcG9pbnQuYXR0cihcInhcIikgKyB3aWR0aCAvIDIpO1xyXG5cdFx0XHRcdFx0Y29uc3QgeSA9IHJhdGlvICogKCtwb2ludC5hdHRyKFwieVwiKSArIGhlaWdodCAvIDIpO1xyXG5cclxuXHRcdFx0XHRcdHBvaW50LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3h9ICR7eX0pIHNjYWxlKCR7c2NhbGV9KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dW5leHBhbmRDaXJjbGVzKGkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHIgPSAkJC5wb2ludFIuYmluZCgkJCk7XHJcblxyXG5cdFx0Y29uc3QgY2lyY2xlcyA9ICQkLmdldENpcmNsZXMoaSlcclxuXHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXR1cm4gZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLkVYUEFOREVELCBmYWxzZSk7XHJcblxyXG5cdFx0Y2lyY2xlcy5hdHRyKFwiclwiLCByKTtcclxuXHJcblx0XHQhJCQuaXNDaXJjbGVQb2ludCgpICYmXHJcblx0XHRcdGNpcmNsZXMuYXR0cihcInRyYW5zZm9ybVwiLCBgc2NhbGUoJHtyKGNpcmNsZXMpIC8gJCQuY29uZmlnLnBvaW50X3J9KWApO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50UihkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgcG9pbnRSID0gY29uZmlnLnBvaW50X3I7XHJcblx0XHRsZXQgciA9IHBvaW50UjtcclxuXHJcblx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xyXG5cdFx0XHRyID0gMDtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVUeXBlKGQpKSB7XHJcblx0XHRcdHIgPSAkJC5nZXRCdWJibGVSKGQpO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKHBvaW50UikpIHtcclxuXHRcdFx0ciA9IHBvaW50UihkKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcjtcclxuXHR9LFxyXG5cclxuXHRwb2ludEV4cGFuZGVkUihkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSAkJC5pc0J1YmJsZVR5cGUoZCkgPyAxLjE1IDogMS43NTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkID9cclxuXHRcdFx0KGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfciB8fCAkJC5wb2ludFIoZCkgKiBzY2FsZSkgOiAkJC5wb2ludFIoZCk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRTZWxlY3RSKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNlbGVjdFIgPSAkJC5jb25maWcucG9pbnRfc2VsZWN0X3I7XHJcblxyXG5cdFx0cmV0dXJuIGlzRnVuY3Rpb24oc2VsZWN0UikgP1xyXG5cdFx0XHRzZWxlY3RSKGQpIDogKHNlbGVjdFIgfHwgJCQucG9pbnRSKGQpICogNCk7XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5DaXJjbGUobm9kZSwgcikge1xyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKG5vZGUpO1xyXG5cdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KG5vZGUpO1xyXG5cdFx0Y29uc3QgcHJlZml4ID0gdGhpcy5pc0NpcmNsZVBvaW50KCkgPyBcImNcIiA6IFwiXCI7XHJcblxyXG5cdFx0bGV0IGN4ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eGApO1xyXG5cdFx0bGV0IGN5ID0gK2VsZW1lbnQuYXR0cihgJHtwcmVmaXh9eWApO1xyXG5cclxuXHRcdC8vIGlmIG5vZGUgZG9uJ3QgaGF2ZSBjeC95IG9yIHgveSBhdHRyaWJ1dGUgdmFsdWVcclxuXHRcdGlmICghKGN4IHx8IGN5KSAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XHJcblx0XHRcdGNvbnN0IHt4LCB5fSA9IG5vZGUuZ2V0QkJveCA/IG5vZGUuZ2V0QkJveCgpIDogbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHJcblx0XHRcdGN4ID0geDtcclxuXHRcdFx0Y3kgPSB5O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoXHJcblx0XHRcdE1hdGgucG93KGN4IC0gbW91c2VbMF0sIDIpICsgTWF0aC5wb3coY3kgLSBtb3VzZVsxXSwgMilcclxuXHRcdCkgPCAociB8fCB0aGlzLmNvbmZpZy5wb2ludF9zZW5zaXRpdml0eSk7XHJcblx0fSxcclxuXHJcblx0aW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgaWQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNvcHlBdHRyID0gKGZyb20sIHRhcmdldCkgPT4ge1xyXG5cdFx0XHRjb25zdCBhdHRyaWJzID0gZnJvbS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDAsIG5hbWU7IChuYW1lID0gYXR0cmlic1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdG5hbWUgPSBuYW1lLm5hbWU7XHJcblx0XHRcdFx0dGFyZ2V0LnNldEF0dHJpYnV0ZShuYW1lLCBmcm9tLmdldEF0dHJpYnV0ZShuYW1lKSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhwb2ludCwgXCJpbWFnZS9zdmcreG1sXCIpO1xyXG5cdFx0Y29uc3Qgbm9kZSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XHJcblx0XHRjb25zdCBjbG9uZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhkM05hbWVzcGFjZXMuc3ZnLCBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG5cclxuXHRcdGNsb25lLmlkID0gaWQ7XHJcblx0XHRjbG9uZS5zdHlsZS5maWxsID0gXCJpbmhlcml0XCI7XHJcblx0XHRjbG9uZS5zdHlsZS5zdHJva2UgPSBcImluaGVyaXRcIjtcclxuXHJcblx0XHRjb3B5QXR0cihub2RlLCBjbG9uZSk7XHJcblxyXG5cdFx0aWYgKG5vZGUuY2hpbGROb2RlcyAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IHBhcmVudCA9IGQzU2VsZWN0KGNsb25lKTtcclxuXHJcblx0XHRcdGlmIChcImlubmVySFRNTFwiIGluIGNsb25lKSB7XHJcblx0XHRcdFx0cGFyZW50Lmh0bWwobm9kZS5pbm5lckhUTUwpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRvQXJyYXkobm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0Y29weUF0dHIodiwgcGFyZW50LmFwcGVuZCh2LnRhZ05hbWUpLm5vZGUoKSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQkJC4kZWwuZGVmcy5ub2RlKCkuYXBwZW5kQ2hpbGQoY2xvbmUpO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50RnJvbURlZnMoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLiRlbC5kZWZzLnNlbGVjdChgIyR7aWR9YCk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUG9pbnRDbGFzcyhkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y2lyY2xlfSA9ICQkLiRlbDtcclxuXHRcdGxldCBwb2ludENsYXNzID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KGQpIHx8IGNpcmNsZSkge1xyXG5cdFx0XHRwb2ludENsYXNzID0gZCA9PT0gdHJ1ZSA/XHJcblx0XHRcdFx0Y2lyY2xlLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0NpcmNsZS5iaW5kKCQkKSkgOlxyXG5cdFx0XHRcdCQkLmNsYXNzQ2lyY2xlKGQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwb2ludENsYXNzO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlUG9pbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2RhdGV0aW1lSWR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0Y29uc3QgcGF0dGVybiA9IG5vdEVtcHR5KGNvbmZpZy5wb2ludF9wYXR0ZXJuKSA/IGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24obWV0aG9kLCBjb250ZXh0LCAuLi5hcmdzKSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3QgaWQ6IHN0cmluZyA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XHJcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRpZHMuaW5kZXhPZihpZCkgPCAwICYmIGlkcy5wdXNoKGlkKTtcclxuXHJcblx0XHRcdFx0bGV0IHBvaW50ID0gcGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBwYXR0ZXJuLmxlbmd0aF07XHJcblxyXG5cdFx0XHRcdGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZShwb2ludCkpIHtcclxuXHRcdFx0XHRcdHBvaW50ID0gJCRbcG9pbnRdO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoISQkLmhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyhwb2ludCkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50SWQgPSBgJHtkYXRldGltZUlkfS1wb2ludC0ke2lkfWA7XHJcblx0XHRcdFx0XHRjb25zdCBwb2ludEZyb21EZWZzID0gJCQucG9pbnRGcm9tRGVmcyhwb2ludElkKTtcclxuXHJcblx0XHRcdFx0XHRpZiAocG9pbnRGcm9tRGVmcy5zaXplKCkgPCAxKSB7XHJcblx0XHRcdFx0XHRcdCQkLmluc2VydFBvaW50SW5mb0RlZnMocG9pbnQsIHBvaW50SWQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChtZXRob2QgPT09IFwiY3JlYXRlXCIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmN1c3RvbS5jcmVhdGUuYmluZChjb250ZXh0KShlbGVtZW50LCBwb2ludElkLCAuLi5hcmdzKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobWV0aG9kID09PSBcInVwZGF0ZVwiKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAkJC5jdXN0b20udXBkYXRlLmJpbmQoY29udGV4dCkoZWxlbWVudCwgLi4uYXJncyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gcG9pbnRbbWV0aG9kXS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIC4uLmFyZ3MpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRUcmFuc2l0aW9uTmFtZSgpIHtcclxuXHRcdHJldHVybiBnZXRSYW5kb20oKTtcclxuXHR9LFxyXG5cclxuXHRjdXN0b206IHtcclxuXHRcdGNyZWF0ZShlbGVtZW50LCBpZCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xyXG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJ1c2VcIilcclxuXHRcdFx0XHQuYXR0cihcInhsaW5rOmhyZWZcIiwgYCMke2lkfWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgb3BhY2l0eVN0eWxlRm4sIGZpbGxTdHlsZUZuLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XHJcblx0XHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWxlbWVudC5ub2RlKCkuZ2V0QkJveCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgeFBvc0ZuMiA9IGQgPT4geFBvc0ZuKGQpIC0gd2lkdGggLyAyO1xyXG5cdFx0XHRjb25zdCB5UG9zRm4yID0gZCA9PiB5UG9zRm4oZCkgLSBoZWlnaHQgLyAyO1xyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xyXG5cclxuXHRcdFx0XHRmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJ4XCIsIHhQb3NGbjIpO1xyXG5cclxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKCQkLmdldFRyYW5zaXRpb25OYW1lKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgeFBvc0ZuMilcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgeVBvc0ZuMilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHlTdHlsZUZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vICdjaXJjbGUnIGRhdGEgcG9pbnRcclxuXHRjaXJjbGU6IHtcclxuXHRcdGNyZWF0ZShlbGVtZW50LCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcImNpcmNsZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgdGhpcy51cGRhdGVQb2ludENsYXNzLmJpbmQodGhpcykpXHJcblx0XHRcdFx0LmF0dHIoXCJyXCIsIHNpemVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgb3BhY2l0eVN0eWxlRm4sIGZpbGxTdHlsZUZuLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XHJcblx0XHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdFx0bGV0IG1haW5DaXJjbGVzID0gZWxlbWVudDtcclxuXHJcblx0XHRcdC8vIHdoZW4gJy5sb2FkKCknIGNhbGxlZCwgYnViYmxlIHNpemUgc2hvdWxkIGJlIHVwZGF0ZWRcclxuXHRcdFx0aWYgKCQkLmhhc1R5cGUoXCJidWJibGVcIikpIHtcclxuXHRcdFx0XHRtYWluQ2lyY2xlcy5hdHRyKFwiclwiLCAkJC5wb2ludFIuYmluZCgkJCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uTmFtZSA9ICQkLmdldFRyYW5zaXRpb25OYW1lKCk7XHJcblxyXG5cdFx0XHRcdGZsb3cgJiYgbWFpbkNpcmNsZXMuYXR0cihcImN4XCIsIHhQb3NGbik7XHJcblxyXG5cdFx0XHRcdGlmIChtYWluQ2lyY2xlcy5hdHRyKFwiY3hcIikpIHtcclxuXHRcdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXMudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1haW5DaXJjbGVzXHJcblx0XHRcdFx0LmF0dHIoXCJjeFwiLCB4UG9zRm4pXHJcblx0XHRcdFx0LmF0dHIoXCJjeVwiLCB5UG9zRm4pXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyAncmVjdGFuZ2xlJyBkYXRhIHBvaW50XHJcblx0cmVjdGFuZ2xlOiB7XHJcblx0XHRjcmVhdGUoZWxlbWVudCwgc2l6ZUZuLCBmaWxsU3R5bGVGbikge1xyXG5cdFx0XHRjb25zdCByZWN0U2l6ZUZuID0gZCA9PiBzaXplRm4oZCkgKiAyLjA7XHJcblxyXG5cdFx0XHRyZXR1cm4gZWxlbWVudC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHJlY3RTaXplRm4pXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgcmVjdFNpemVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKVxyXG5cdFx0XHRcdC5ub2RlKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdHVwZGF0ZShlbGVtZW50LCB4UG9zRm4sIHlQb3NGbiwgb3BhY2l0eVN0eWxlRm4sIGZpbGxTdHlsZUZuLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKSB7XHJcblx0XHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdFx0Y29uc3QgciA9ICQkLmNvbmZpZy5wb2ludF9yO1xyXG5cdFx0XHRjb25zdCByZWN0WFBvc0ZuID0gZCA9PiB4UG9zRm4oZCkgLSByO1xyXG5cdFx0XHRjb25zdCByZWN0WVBvc0ZuID0gZCA9PiB5UG9zRm4oZCkgLSByO1xyXG5cclxuXHRcdFx0bGV0IG1haW5DaXJjbGVzID0gZWxlbWVudDtcclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdGNvbnN0IHRyYW5zaXRpb25OYW1lID0gJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKTtcclxuXHJcblx0XHRcdFx0ZmxvdyAmJiBtYWluQ2lyY2xlcy5hdHRyKFwieFwiLCByZWN0WFBvc0ZuKTtcclxuXHJcblx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlcy50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKTtcclxuXHRcdFx0XHRzZWxlY3RlZENpcmNsZXMudHJhbnNpdGlvbigkJC5nZXRUcmFuc2l0aW9uTmFtZSgpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1haW5DaXJjbGVzXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIHJlY3RYUG9zRm4pXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIHJlY3RZUG9zRm4pXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5U3R5bGVGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGZpbGxTdHlsZUZuKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRjdXJ2ZVN0ZXBCZWZvcmUgYXMgZDNDdXJ2ZVN0ZXBCZWZvcmUsXHJcblx0Y3VydmVTdGVwQWZ0ZXIgYXMgZDNDdXJ2ZVN0ZXBBZnRlcixcclxuXHRjdXJ2ZUJhc2lzQ2xvc2VkIGFzIGQzQ3VydmVCYXNpc0Nsb3NlZCxcclxuXHRjdXJ2ZUJhc2lzT3BlbiBhcyBkM0N1cnZlQmFzaXNPcGVuLFxyXG5cdGN1cnZlQmFzaXMgYXMgZDNDdXJ2ZUJhc2lzLFxyXG5cdGN1cnZlQnVuZGxlIGFzIGQzQ3VydmVCdW5kbGUsXHJcblx0Y3VydmVDYXJkaW5hbENsb3NlZCBhcyBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXHJcblx0Y3VydmVDYXJkaW5hbE9wZW4gYXMgZDNDdXJ2ZUNhcmRpbmFsT3BlbixcclxuXHRjdXJ2ZUNhcmRpbmFsIGFzIGQzQ3VydmVDYXJkaW5hbCxcclxuXHRjdXJ2ZUNhdG11bGxSb21DbG9zZWQgYXMgZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXHJcblx0Y3VydmVDYXRtdWxsUm9tT3BlbiBhcyBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXHJcblx0Y3VydmVDYXRtdWxsUm9tIGFzIGQzQ3VydmVDYXRtdWxsUm9tLFxyXG5cdGN1cnZlTGluZWFyQ2xvc2VkIGFzIGQzQ3VydmVMaW5lYXJDbG9zZWQsXHJcblx0Y3VydmVMaW5lYXIgYXMgZDNDdXJ2ZUxpbmVhcixcclxuXHRjdXJ2ZU1vbm90b25lWCBhcyBkM0N1cnZlTW9ub3RvbmVYLFxyXG5cdGN1cnZlTW9ub3RvbmVZIGFzIGQzQ3VydmVNb25vdG9uZVksXHJcblx0Y3VydmVOYXR1cmFsIGFzIGQzQ3VydmVOYXR1cmFsLFxyXG5cdGN1cnZlU3RlcCBhcyBkM0N1cnZlU3RlcFxyXG59IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0VW5pcXVlLCBpc09iamVjdFR5cGUsIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgbm90RW1wdHl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGdldFNoYXBlSW5kaWNlcyh0eXBlRmlsdGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgeHMgPSBjb25maWcuZGF0YV94cztcclxuXHRcdGNvbnN0IGhhc1hzID0gbm90RW1wdHkoeHMpO1xyXG5cdFx0Y29uc3QgaW5kaWNlcyA9IHt9O1xyXG5cdFx0bGV0IGk6IGFueSA9IGhhc1hzID8ge30gOiAwO1xyXG5cclxuXHRcdGlmIChoYXNYcykge1xyXG5cdFx0XHRnZXRVbmlxdWUoT2JqZWN0LmtleXMoeHMpLm1hcCh2ID0+IHhzW3ZdKSlcclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGlbdl0gPSAwO1xyXG5cdFx0XHRcdFx0aW5kaWNlc1t2XSA9IHt9O1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpXHJcblx0XHRcdC5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHhLZXkgPSBkLmlkIGluIHhzID8geHNbZC5pZF0gOiBcIlwiO1xyXG5cdFx0XHRcdGNvbnN0IGluZCA9IHhLZXkgPyBpbmRpY2VzW3hLZXldIDogaW5kaWNlcztcclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGdyb3VwczsgKGdyb3VwcyA9IGNvbmZpZy5kYXRhX2dyb3Vwc1tqXSk7IGorKykge1xyXG5cdFx0XHRcdFx0aWYgKGdyb3Vwcy5pbmRleE9mKGQuaWQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gMCwgcm93OyAocm93ID0gZ3JvdXBzW2tdKTsgaysrKSB7XHJcblx0XHRcdFx0XHRcdGlmIChyb3cgaW4gaW5kKSB7XHJcblx0XHRcdFx0XHRcdFx0aW5kW2QuaWRdID0gaW5kW3Jvd107XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc1VuZGVmaW5lZChpbmRbZC5pZF0pKSB7XHJcblx0XHRcdFx0XHRpbmRbZC5pZF0gPSB4S2V5ID8gaVt4S2V5XSsrIDogaSsrO1xyXG5cdFx0XHRcdFx0aW5kLl9fbWF4X18gPSAoeEtleSA/IGlbeEtleV0gOiBpKSAtIDE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gaW5kaWNlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgaW5kaWNlcyB2YWx1ZSBiYXNlZCBvbiBkYXRhIElEIHZhbHVlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGluZGljZXMgSW5kaWNlcyBvYmplY3RcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgRGF0YSBpZCB2YWx1ZVxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gSW5kaWNlcyBvYmplY3RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEluZGljZXMoaW5kaWNlcywgaWQpIHtcclxuXHRcdGNvbnN0IHhzID0gdGhpcy5jb25maWcuZGF0YV94cztcclxuXHJcblx0XHRyZXR1cm4gbm90RW1wdHkoeHMpID9cclxuXHRcdFx0aW5kaWNlc1t4c1tpZF1dIDogaW5kaWNlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgaW5kaWNlcyBtYXggbnVtYmVyXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGluZGljZXMgSW5kaWNlcyBvYmplY3RcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IE1heCBudW1iZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEluZGljZXNNYXgoaW5kaWNlcykge1xyXG5cdFx0cmV0dXJuIG5vdEVtcHR5KHRoaXMuY29uZmlnLmRhdGFfeHMpID9cclxuXHRcdFx0Ly8gaWYgaXMgbXVsdGlwbGUgeHMsIHJldHVybiB0b3RhbCBzdW0gb2YgeHMnIF9fbWF4X18gdmFsdWVcclxuXHRcdFx0T2JqZWN0LmtleXMoaW5kaWNlcylcclxuXHRcdFx0XHQubWFwKHYgPT4gaW5kaWNlc1t2XS5fX21heF9fIHx8IDApXHJcblx0XHRcdFx0LnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyKSA6IGluZGljZXMuX19tYXhfXztcclxuXHR9LFxyXG5cclxuXHRnZXRTaGFwZVgob2Zmc2V0LCBpbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyU2NhbGUgPSBpc1N1YiA/IHNjYWxlLnN1YlggOiAoc2NhbGUuem9vbSB8fCBzY2FsZS54KTtcclxuXHRcdGNvbnN0IGJhclBhZGRpbmcgPSBjb25maWcuYmFyX3BhZGRpbmc7XHJcblx0XHRjb25zdCBzdW0gPSAocCwgYykgPT4gcCArIGM7XHJcblx0XHRjb25zdCBoYWxmV2lkdGggPSBpc09iamVjdFR5cGUob2Zmc2V0KSAmJiBvZmZzZXQudG90YWwubGVuZ3RoID8gb2Zmc2V0LnRvdGFsLnJlZHVjZShzdW0pIC8gMiA6IDA7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRjb25zdCBpbmQgPSAkJC5nZXRJbmRpY2VzKGluZGljZXMsIGQuaWQpO1xyXG5cdFx0XHRjb25zdCBpbmRleCA9IGQuaWQgaW4gaW5kID8gaW5kW2QuaWRdIDogMDtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0c051bSA9IChpbmQuX19tYXhfXyB8fCAwKSArIDE7XHJcblx0XHRcdGxldCB4ID0gMDtcclxuXHJcblx0XHRcdGlmIChub3RFbXB0eShkLngpKSB7XHJcblx0XHRcdFx0Y29uc3QgeFBvcyA9IGN1cnJTY2FsZShkLngpO1xyXG5cclxuXHRcdFx0XHRpZiAoaGFsZldpZHRoKSB7XHJcblx0XHRcdFx0XHR4ID0geFBvcyAtIChvZmZzZXRbZC5pZF0gfHwgb2Zmc2V0LndpZHRoKSArXHJcblx0XHRcdFx0XHRcdG9mZnNldC50b3RhbC5zbGljZSgwLCBpbmRleCArIDEpLnJlZHVjZShzdW0pIC1cclxuXHRcdFx0XHRcdFx0aGFsZldpZHRoO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR4ID0geFBvcyAtIChpc051bWJlcihvZmZzZXQpID8gb2Zmc2V0IDogb2Zmc2V0LndpZHRoKSAqICh0YXJnZXRzTnVtIC8gMiAtIGluZGV4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGFkanVzdCB4IHBvc2l0aW9uIGZvciBiYXIucGFkZGluZyBvcHRpb25xXHJcblx0XHRcdGlmIChvZmZzZXQgJiYgeCAmJiB0YXJnZXRzTnVtID4gMSAmJiBiYXJQYWRkaW5nKSB7XHJcblx0XHRcdFx0aWYgKGluZGV4KSB7XHJcblx0XHRcdFx0XHR4ICs9IGJhclBhZGRpbmcgKiBpbmRleDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh0YXJnZXRzTnVtID4gMikge1xyXG5cdFx0XHRcdFx0eCAtPSAodGFyZ2V0c051bSAtIDEpICogYmFyUGFkZGluZyAvIDI7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXRzTnVtID09PSAyKSB7XHJcblx0XHRcdFx0XHR4IC09IGJhclBhZGRpbmcgLyAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHg7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldFNoYXBlWShpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNTdGFja05vcm1hbGl6ZWQgPSAkJC5pc1N0YWNrTm9ybWFsaXplZCgpO1xyXG5cclxuXHRcdHJldHVybiBkID0+IHtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBpc1N0YWNrTm9ybWFsaXplZCA/ICQkLmdldFJhdGlvKFwiaW5kZXhcIiwgZCwgdHJ1ZSkgOiAoXHJcblx0XHRcdFx0JCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwieVwiKSA6IGQudmFsdWVcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiAoaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUoZC5pZCkgOiAkJC5nZXRZU2NhbGUoZC5pZCkpKHZhbHVlKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IFNoYXBlJ3Mgb2Zmc2V0IGRhdGFcclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6IGJvb2xlYW59IHR5cGVGaWx0ZXJcclxuXHQgKiBAcmV0dXJuIHt7c2hhcGVPZmZzZXRUYXJnZXRzOiBTaGFwZU9mZnNldFRhcmdldFtdLCBpbmRleE1hcEJ5VGFyZ2V0SWQ6IG9iamVjdH19XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRTaGFwZU9mZnNldERhdGEodHlwZUZpbHRlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLm9yZGVyVGFyZ2V0cygkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cy5maWx0ZXIodHlwZUZpbHRlciwgJCQpKSk7XHJcblx0XHRjb25zdCBzaGFwZU9mZnNldFRhcmdldHMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xyXG5cdFx0XHRsZXQgcm93VmFsdWVzID0gdGFyZ2V0LnZhbHVlcztcclxuXHJcblx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKHRhcmdldCkpIHtcclxuXHRcdFx0XHRyb3dWYWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHJvd1ZhbHVlcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc3Qgcm93VmFsdWVNYXBCeVhWYWx1ZSA9IHJvd1ZhbHVlcy5yZWR1Y2UoKG91dCwgdmFsdWUpID0+IHtcclxuXHRcdFx0XHRvdXRbTnVtYmVyKHZhbHVlLngpXSA9IHZhbHVlO1xyXG5cdFx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHRcdH0sIHt9KTtcclxuXHJcblx0XHRcdGNvbnN0IHZhbHVlcyA9IHJvd1ZhbHVlcy5tYXAoXHJcblx0XHRcdFx0JCQuaXNTdGFja05vcm1hbGl6ZWQoKSA/XHJcblx0XHRcdFx0XHR2ID0+ICQkLmdldFJhdGlvKFwiaW5kZXhcIiwgdiwgdHJ1ZSkgOlxyXG5cdFx0XHRcdFx0KHt2YWx1ZX0pID0+IHZhbHVlXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGlkOiB0YXJnZXQuaWQsXHJcblx0XHRcdFx0cm93VmFsdWVzLFxyXG5cdFx0XHRcdHJvd1ZhbHVlTWFwQnlYVmFsdWUsXHJcblx0XHRcdFx0dmFsdWVzLFxyXG5cdFx0XHR9O1xyXG5cdFx0fSk7XHJcblx0XHRjb25zdCBpbmRleE1hcEJ5VGFyZ2V0SWQgPSB0YXJnZXRzLnJlZHVjZSgob3V0LCB7aWR9LCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbaWRdID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0cmV0dXJuIHtpbmRleE1hcEJ5VGFyZ2V0SWQsIHNoYXBlT2Zmc2V0VGFyZ2V0c307XHJcblx0fSxcclxuXHJcblx0Z2V0U2hhcGVPZmZzZXQodHlwZUZpbHRlciwgaW5kaWNlcywgaXNTdWIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzaGFwZU9mZnNldFRhcmdldHMsIGluZGV4TWFwQnlUYXJnZXRJZH0gPSAkJC5nZXRTaGFwZU9mZnNldERhdGEodHlwZUZpbHRlcik7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpZHgpID0+IHtcclxuXHRcdFx0Y29uc3QgaW5kID0gJCQuZ2V0SW5kaWNlcyhpbmRpY2VzLCBkLmlkKTtcclxuXHRcdFx0Y29uc3Qgc2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZShkLmlkKSA6ICQkLmdldFlTY2FsZShkLmlkKTtcclxuXHRcdFx0Y29uc3QgeTAgPSBzY2FsZSgwKTtcclxuXHRcdFx0Y29uc3QgZGF0YVhBc051bWJlciA9IE51bWJlcihkLngpO1xyXG5cdFx0XHRsZXQgb2Zmc2V0ID0geTA7XHJcblxyXG5cdFx0XHRzaGFwZU9mZnNldFRhcmdldHNcclxuXHRcdFx0XHQuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHJvd1ZhbHVlcyA9IHQucm93VmFsdWVzO1xyXG5cdFx0XHRcdFx0Y29uc3QgdmFsdWVzID0gdC52YWx1ZXM7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHQuaWQgPT09IGQuaWQgfHwgaW5kW3QuaWRdICE9PSBpbmRbZC5pZF0pIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChpbmRleE1hcEJ5VGFyZ2V0SWRbdC5pZF0gPCBpbmRleE1hcEJ5VGFyZ2V0SWRbZC5pZF0pIHtcclxuXHRcdFx0XHRcdFx0bGV0IHJvd1ZhbHVlID0gcm93VmFsdWVzW2lkeF07XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgeCB2YWx1ZXMgbGluZSB1cFxyXG5cdFx0XHRcdFx0XHRpZiAoIXJvd1ZhbHVlIHx8IE51bWJlcihyb3dWYWx1ZS54KSAhPT0gZGF0YVhBc051bWJlcikge1xyXG5cdFx0XHRcdFx0XHRcdHJvd1ZhbHVlID0gdC5yb3dWYWx1ZU1hcEJ5WFZhbHVlW2RhdGFYQXNOdW1iZXJdO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAocm93VmFsdWUgJiYgcm93VmFsdWUudmFsdWUgKiBkLnZhbHVlID49IDApIHtcclxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gc2NhbGUodmFsdWVzW3Jvd1ZhbHVlLmluZGV4XSkgLSB5MDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cmV0dXJuIG9mZnNldDtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5TaGFwZSh0aGF0LCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBzaGFwZSA9IGQzU2VsZWN0KHRoYXQpO1xyXG5cdFx0bGV0IGlzV2l0aGluO1xyXG5cclxuXHRcdGlmICghJCQuaXNUYXJnZXRUb1Nob3coZC5pZCkpIHtcclxuXHRcdFx0aXNXaXRoaW4gPSBmYWxzZTtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVmFsaWRQb2ludFR5cGUodGhhdC5ub2RlTmFtZSkpIHtcclxuXHRcdFx0aXNXaXRoaW4gPSAkJC5pc1N0ZXBUeXBlKGQpID9cclxuXHRcdFx0XHQkJC5pc1dpdGhpblN0ZXAodGhhdCwgJCQuZ2V0WVNjYWxlKGQuaWQpKGQudmFsdWUpKSA6XHJcblx0XHRcdFx0JCQuaXNXaXRoaW5DaXJjbGUodGhhdCwgJCQuaXNCdWJibGVUeXBlKGQpID8gJCQucG9pbnRTZWxlY3RSKGQpICogMS41IDogMCk7XHJcblx0XHR9IGVsc2UgaWYgKHRoYXQubm9kZU5hbWUgPT09IFwicGF0aFwiKSB7XHJcblx0XHRcdGlzV2l0aGluID0gc2hhcGUuY2xhc3NlZChDTEFTUy5iYXIpID8gJCQuaXNXaXRoaW5CYXIodGhhdCkgOiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc1dpdGhpbjtcclxuXHR9LFxyXG5cclxuXHRnZXRJbnRlcnBvbGF0ZShkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpbnRlcnBvbGF0aW9uID0gJCQuZ2V0SW50ZXJwb2xhdGVUeXBlKGQpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdFwiYmFzaXNcIjogZDNDdXJ2ZUJhc2lzLFxyXG5cdFx0XHRcImJhc2lzLWNsb3NlZFwiOiBkM0N1cnZlQmFzaXNDbG9zZWQsXHJcblx0XHRcdFwiYmFzaXMtb3BlblwiOiBkM0N1cnZlQmFzaXNPcGVuLFxyXG5cdFx0XHRcImJ1bmRsZVwiOiBkM0N1cnZlQnVuZGxlLFxyXG5cdFx0XHRcImNhcmRpbmFsXCI6IGQzQ3VydmVDYXJkaW5hbCxcclxuXHRcdFx0XCJjYXJkaW5hbC1jbG9zZWRcIjogZDNDdXJ2ZUNhcmRpbmFsQ2xvc2VkLFxyXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIjogZDNDdXJ2ZUNhcmRpbmFsT3BlbixcclxuXHRcdFx0XCJjYXRtdWxsLXJvbVwiOiBkM0N1cnZlQ2F0bXVsbFJvbSxcclxuXHRcdFx0XCJjYXRtdWxsLXJvbS1jbG9zZWRcIjogZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXHJcblx0XHRcdFwiY2F0bXVsbC1yb20tb3BlblwiOiBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXHJcblx0XHRcdFwibW9ub3RvbmUteFwiOiBkM0N1cnZlTW9ub3RvbmVYLFxyXG5cdFx0XHRcIm1vbm90b25lLXlcIjogZDNDdXJ2ZU1vbm90b25lWSxcclxuXHRcdFx0XCJuYXR1cmFsXCI6IGQzQ3VydmVOYXR1cmFsLFxyXG5cdFx0XHRcImxpbmVhci1jbG9zZWRcIjogZDNDdXJ2ZUxpbmVhckNsb3NlZCxcclxuXHRcdFx0XCJsaW5lYXJcIjogZDNDdXJ2ZUxpbmVhcixcclxuXHRcdFx0XCJzdGVwXCI6IGQzQ3VydmVTdGVwLFxyXG5cdFx0XHRcInN0ZXAtYWZ0ZXJcIjogZDNDdXJ2ZVN0ZXBBZnRlcixcclxuXHRcdFx0XCJzdGVwLWJlZm9yZVwiOiBkM0N1cnZlU3RlcEJlZm9yZVxyXG5cdFx0fVtpbnRlcnBvbGF0aW9uXTtcclxuXHR9LFxyXG5cclxuXHRnZXRJbnRlcnBvbGF0ZVR5cGUoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHR5cGUgPSBjb25maWcuc3BsaW5lX2ludGVycG9sYXRpb25fdHlwZTtcclxuXHRcdGNvbnN0IGludGVycG9sYXRpb24gPSAkJC5pc0ludGVycG9sYXRpb25UeXBlKHR5cGUpID8gdHlwZSA6IFwiY2FyZGluYWxcIjtcclxuXHJcblx0XHRyZXR1cm4gJCQuaXNTcGxpbmVUeXBlKGQpID9cclxuXHRcdFx0aW50ZXJwb2xhdGlvbiA6IChcclxuXHRcdFx0XHQkJC5pc1N0ZXBUeXBlKGQpID9cclxuXHRcdFx0XHRcdGNvbmZpZy5saW5lX3N0ZXBfdHlwZSA6IFwibGluZWFyXCJcclxuXHRcdFx0KTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIE1vZHVsZXMgZXhwb3J0cyBmb3IgQXhpcyBiYXNlZCBjaGFydFxyXG4gKi9cclxuLy8gQ2hhcnRcclxuaW1wb3J0IGFwaUF4aXMgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9heGlzXCI7XHJcbmltcG9ydCBhcGlDYXRlZ29yeSBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2NhdGVnb3J5XCI7XHJcbmltcG9ydCBhcGlGbG93IGZyb20gXCIuLi8uLi9DaGFydC9hcGkvZmxvd1wiO1xyXG5pbXBvcnQgYXBpWEdyaWQgZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9ncmlkLnhcIjtcclxuaW1wb3J0IGFwaVlHcmlkIGZyb20gXCIuLi8uLi9DaGFydC9hcGkvZ3JpZC55XCI7XHJcbmltcG9ydCBhcGlHcm91cCBmcm9tIFwiLi4vLi4vQ2hhcnQvYXBpL2dyb3VwXCI7XHJcbmltcG9ydCBhcGlSZWdpb24gZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9yZWdpb25zXCI7XHJcbmltcG9ydCBhcGlTZWxlY3Rpb24gZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS9zZWxlY3Rpb25cIjtcclxuaW1wb3J0IGFwaVggZnJvbSBcIi4uLy4uL0NoYXJ0L2FwaS94XCI7XHJcbmltcG9ydCBhcGlab29tIGZyb20gXCIuLi8uLi9DaGFydC9hcGkvem9vbVwiO1xyXG5cclxuLy8gQ2hhcnRJbnRlcm5hbFxyXG5pbXBvcnQgZHJhZyBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZHJhZ1wiO1xyXG5pbXBvcnQgZmxvdyBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZmxvd1wiO1xyXG5pbXBvcnQgZXZlbnRyZWN0IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9ldmVudHJlY3RcIjtcclxuaW1wb3J0IHN1YmNoYXJ0IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy9zdWJjaGFydFwiO1xyXG5pbXBvcnQgem9vbSBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvem9vbVwiO1xyXG5cclxuaW1wb3J0IGNhdGVnb3J5IGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVybmFscy9jYXRlZ29yeVwiO1xyXG5pbXBvcnQgY2xpcCBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2xpcFwiO1xyXG5pbXBvcnQgZ3JpZCBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvZ3JpZFwiO1xyXG5pbXBvcnQgcmVnaW9uIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL2ludGVybmFscy9yZWdpb25cIjtcclxuaW1wb3J0IHNlbGVjdGlvbiBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvc2VsZWN0aW9uXCI7XHJcblxyXG5pbXBvcnQgYmFyIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL3NoYXBlL2JhclwiO1xyXG5pbXBvcnQgYnViYmxlIGZyb20gXCIuLi8uLi9DaGFydEludGVybmFsL3NoYXBlL2J1YmJsZVwiO1xyXG5pbXBvcnQgbGluZSBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9saW5lXCI7XHJcbmltcG9ydCBwb2ludCBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9wb2ludFwiO1xyXG5pbXBvcnQgc2hhcGUgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvc2hhcGVcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRhcGk6IFtcclxuXHRcdGFwaUF4aXMsXHJcblx0XHRhcGlDYXRlZ29yeSxcclxuXHRcdGFwaUZsb3csXHJcblx0XHRhcGlYR3JpZCxcclxuXHRcdGFwaVlHcmlkLFxyXG5cdFx0YXBpR3JvdXAsXHJcblx0XHRhcGlSZWdpb24sXHJcblx0XHRhcGlTZWxlY3Rpb24sXHJcblx0XHRhcGlYLFxyXG5cdFx0YXBpWm9vbVxyXG5cdF0sXHJcblx0aW50ZXJuYWw6IFtcclxuXHRcdGNhdGVnb3J5LFxyXG5cdFx0ZHJhZyxcclxuXHRcdGZsb3csXHJcblx0XHRzdWJjaGFydCxcclxuXHRcdHpvb20sXHJcblxyXG5cdFx0Y2xpcCxcclxuXHRcdGdyaWQsXHJcblx0XHRyZWdpb24sXHJcblx0XHRzZWxlY3Rpb24sXHJcblx0XHRldmVudHJlY3QsXHJcblxyXG5cdFx0YmFyLFxyXG5cdFx0YnViYmxlLFxyXG5cdFx0bGluZSxcclxuXHRcdHBvaW50LFxyXG5cdFx0c2hhcGVcclxuXHRdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0ZXZlbnQgYXMgZDNFdmVudFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtcclxuXHRhcmMgYXMgZDNBcmMsXHJcblx0cGllIGFzIGQzUGllXHJcbn0gZnJvbSBcImQzLXNoYXBlXCI7XHJcbmltcG9ydCB7aW50ZXJwb2xhdGUgYXMgZDNJbnRlcnBvbGF0ZX0gZnJvbSBcImQzLWludGVycG9sYXRlXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FsbEZuLCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNVbmRlZmluZWQsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdFBpZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkYXRhVHlwZSA9IGNvbmZpZy5kYXRhX3R5cGU7XHJcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLnBpZV9wYWRkaW5nO1xyXG5cdFx0Y29uc3Qgc3RhcnRpbmdBbmdsZSA9IGNvbmZpZ1tgJHtkYXRhVHlwZX1fc3RhcnRpbmdBbmdsZWBdIHx8IDA7XHJcblx0XHRjb25zdCBwYWRBbmdsZSA9IChcclxuXHRcdFx0JCQuaGFzVHlwZShcInBpZVwiKSAmJiBwYWRkaW5nID8gcGFkZGluZyAqIDAuMDEgOlxyXG5cdFx0XHRcdGNvbmZpZ1tgJHtkYXRhVHlwZX1fcGFkQW5nbGVgXVxyXG5cdFx0KSB8fCAwO1xyXG5cdFx0Y29uc3Qgc29ydFZhbHVlOiBhbnkgPSAkJC5pc09yZGVyQXNjKCkgfHwgJCQuaXNPcmRlckRlc2MoKSA/XHJcblx0XHRcdChhLCBiKSA9PiAoJCQuaXNPcmRlckFzYygpID8gYSAtIGIgOiBiIC0gYSkgOiBudWxsO1xyXG5cclxuXHRcdCQkLnBpZSA9IGQzUGllKClcclxuXHRcdFx0LnN0YXJ0QW5nbGUoc3RhcnRpbmdBbmdsZSlcclxuXHRcdFx0LmVuZEFuZ2xlKHN0YXJ0aW5nQW5nbGUgKyAoMiAqIE1hdGguUEkpKVxyXG5cdFx0XHQucGFkQW5nbGUocGFkQW5nbGUpXHJcblx0XHRcdC5zb3J0VmFsdWVzKHNvcnRWYWx1ZSlcclxuXHRcdFx0LnZhbHVlKChkOiBhbnkpID0+IGQudmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIudmFsdWUsIDApKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVSYWRpdXMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHJhZGl1cyA9IGNvbmZpZy5waWVfaW5uZXJSYWRpdXM7XHJcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLnBpZV9wYWRkaW5nO1xyXG5cdFx0Y29uc3QgdyA9IGNvbmZpZy5nYXVnZV93aWR0aCB8fCBjb25maWcuZG9udXRfd2lkdGg7XHJcblx0XHRjb25zdCBnYXVnZUFyY1dpZHRoID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCAqXHJcblx0XHRcdGNvbmZpZy5nYXVnZV9hcmNzX21pbldpZHRoO1xyXG5cclxuXHRcdHN0YXRlLnJhZGl1c0V4cGFuZGVkID0gTWF0aC5taW4oc3RhdGUuYXJjV2lkdGgsIHN0YXRlLmFyY0hlaWdodCkgLyAyICogKCQkLmhhc011bHRpQXJjR2F1Z2UoKSA/IDAuODUgOiAxKTtcclxuXHRcdHN0YXRlLnJhZGl1cyA9IHN0YXRlLnJhZGl1c0V4cGFuZGVkICogMC45NTtcclxuXHRcdHN0YXRlLmlubmVyUmFkaXVzUmF0aW8gPSB3ID8gKHN0YXRlLnJhZGl1cyAtIHcpIC8gc3RhdGUucmFkaXVzIDogMC42O1xyXG5cdFx0c3RhdGUuZ2F1Z2VBcmNXaWR0aCA9IHcgfHwgKFxyXG5cdFx0XHRnYXVnZUFyY1dpZHRoIDw9IHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzdGF0ZS5pbm5lclJhZGl1cyA6XHJcblx0XHRcdFx0KGdhdWdlQXJjV2lkdGggPD0gc3RhdGUucmFkaXVzID8gZ2F1Z2VBcmNXaWR0aCA6IHN0YXRlLnJhZGl1cylcclxuXHRcdCk7XHJcblxyXG5cdFx0Y29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXMgfHwgKFxyXG5cdFx0XHRwYWRkaW5nID8gcGFkZGluZyAqIChzdGF0ZS5pbm5lclJhZGl1c1JhdGlvICsgMC4xKSA6IDBcclxuXHRcdCk7XHJcblxyXG5cdFx0Ly8gTk9URTogaW5uZXJSYWRpdXMgY2FuIGJlIGFuIG9iamVjdCBieSB1c2VyIHNldHRpbmcsIG9ubHkgZm9yICdwaWUnIHR5cGVcclxuXHRcdHN0YXRlLmlubmVyUmFkaXVzID0gJCQuaGFzVHlwZShcImRvbnV0XCIpIHx8ICQkLmhhc1R5cGUoXCJnYXVnZVwiKSA/XHJcblx0XHRcdHN0YXRlLnJhZGl1cyAqIHN0YXRlLmlubmVyUmFkaXVzUmF0aW8gOiBpbm5lclJhZGl1cztcclxuXHR9LFxyXG5cclxuXHRnZXRJbm5lclJhZGl1cyhkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQge2lubmVyUmFkaXVzfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdGlmICghaXNOdW1iZXIoaW5uZXJSYWRpdXMpICYmIGQpIHtcclxuXHRcdFx0aW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1c1tkLmRhdGEuaWRdIHx8IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlubmVyUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyYygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5zdmdBcmMgPSAkJC5nZXRTdmdBcmMoKTtcclxuXHRcdCQkLnN2Z0FyY0V4cGFuZGVkID0gJCQuZ2V0U3ZnQXJjRXhwYW5kZWQoKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBbmdsZShkVmFsdWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRsZXQgcGllID0gJCQucGllO1xyXG5cdFx0bGV0IGQgPSBkVmFsdWU7XHJcblx0XHRsZXQgZm91bmQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoIWNvbmZpZykge1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCByYWRpdXMgPSBNYXRoLlBJICogKGNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpO1xyXG5cdFx0Y29uc3QgZ1N0YXJ0ID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XHJcblxyXG5cdFx0aWYgKGQuZGF0YSAmJiAkJC5pc0dhdWdlVHlwZShkLmRhdGEpKSB7XHJcblx0XHRcdGNvbnN0IHRvdGFsU3VtID0gJCQuZ2V0VG90YWxEYXRhU3VtKCk7XHJcblxyXG5cdFx0XHQvLyBpZiBnYXVnZV9tYXggbGVzcyB0aGFuIHRvdGFsU3VtLCBtYWtlIHRvdGFsU3VtIHRvIG1heCB2YWx1ZVxyXG5cdFx0XHRpZiAodG90YWxTdW0gPiBjb25maWcuZ2F1Z2VfbWF4KSB7XHJcblx0XHRcdFx0Y29uZmlnLmdhdWdlX21heCA9IHRvdGFsU3VtO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBnRW5kID0gcmFkaXVzICogKHRvdGFsU3VtIC8gKGNvbmZpZy5nYXVnZV9tYXggLSBjb25maWcuZ2F1Z2VfbWluKSk7XHJcblxyXG5cdFx0XHRwaWUgPSBwaWVcclxuXHRcdFx0XHQuc3RhcnRBbmdsZShnU3RhcnQpXHJcblx0XHRcdFx0LmVuZEFuZ2xlKGdFbmQgKyBnU3RhcnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBpZSgkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCkpXHJcblx0XHRcdC5mb3JFYWNoKCh0LCBpKSA9PiB7XHJcblx0XHRcdFx0aWYgKCFmb3VuZCAmJiB0LmRhdGEuaWQgPT09IGQuZGF0YS5pZCkge1xyXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0ZCA9IHQ7XHJcblx0XHRcdFx0XHRkLmluZGV4ID0gaTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdGlmIChpc05hTihkLnN0YXJ0QW5nbGUpKSB7XHJcblx0XHRcdGQuc3RhcnRBbmdsZSA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzTmFOKGQuZW5kQW5nbGUpKSB7XHJcblx0XHRcdGQuZW5kQW5nbGUgPSBkLnN0YXJ0QW5nbGU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGQuZGF0YSAmJiAkJC5oYXNNdWx0aUFyY0dhdWdlKCkpIHtcclxuXHRcdFx0Y29uc3QgbWF4VmFsdWUgPSAkJC5nZXRNaW5NYXhEYXRhKCkubWF4WzBdLnZhbHVlO1xyXG5cclxuXHRcdFx0Ly8gaWYgZ2F1Z2VfbWF4IGxlc3MgdGhhbiBtYXhWYWx1ZSwgbWFrZSBtYXhWYWx1ZSB0byBtYXggdmFsdWVcclxuXHRcdFx0aWYgKG1heFZhbHVlID4gY29uZmlnLmdhdWdlX21heCkge1xyXG5cdFx0XHRcdGNvbmZpZy5nYXVnZV9tYXggPSBtYXhWYWx1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29uc3QgZ01pbiA9IGNvbmZpZy5nYXVnZV9taW47XHJcblx0XHRcdGNvbnN0IGdNYXggPSBjb25maWcuZ2F1Z2VfbWF4O1xyXG5cdFx0XHRjb25zdCBnVGljID0gcmFkaXVzIC8gKGdNYXggLSBnTWluKTtcclxuXHRcdFx0Y29uc3QgZ1ZhbHVlID0gZC52YWx1ZSA8IGdNaW4gPyAwIDogZC52YWx1ZSA8IGdNYXggPyBkLnZhbHVlIC0gZ01pbiA6IChnTWF4IC0gZ01pbik7XHJcblxyXG5cdFx0XHRkLnN0YXJ0QW5nbGUgPSBnU3RhcnQ7XHJcblx0XHRcdGQuZW5kQW5nbGUgPSBnU3RhcnQgKyBnVGljICogZ1ZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmb3VuZCA/IGQgOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldFN2Z0FyYygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlyID0gJCQuZ2V0SW5uZXJSYWRpdXMoKTtcclxuXHRcdGNvbnN0IHNpbmdsZUFyY1dpZHRoID0gc3RhdGUuZ2F1Z2VBcmNXaWR0aCAvICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGg7XHJcblx0XHRjb25zdCBoYXNNdWx0aUFyY0dhdWdlID0gJCQuaGFzTXVsdGlBcmNHYXVnZSgpO1xyXG5cclxuXHRcdGxldCBhcmMgPSBkM0FyYygpXHJcblx0XHRcdC5vdXRlclJhZGl1cygoZDogYW55KSA9PiAoaGFzTXVsdGlBcmNHYXVnZSA/IChzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIGQuaW5kZXgpIDogc3RhdGUucmFkaXVzKSlcclxuXHRcdFx0LmlubmVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIChkLmluZGV4ICsgMSkgOlxyXG5cdFx0XHRcdGlzTnVtYmVyKGlyKSA/IGlyIDogMCkpO1xyXG5cclxuXHRcdGNvbnN0IG5ld0FyYyA9IGZ1bmN0aW9uKGQsIHdpdGhvdXRVcGRhdGUpIHtcclxuXHRcdFx0bGV0IHBhdGg6IHN0cmluZyB8IG51bGwgPSBcIk0gMCAwXCI7XHJcblxyXG5cdFx0XHRpZiAoZC52YWx1ZSB8fCBkLmRhdGEpIHtcclxuXHRcdFx0XHRpZiAoIWlzTnVtYmVyKGlyKSkge1xyXG5cdFx0XHRcdFx0YXJjID0gYXJjLmlubmVyUmFkaXVzKCQkLmdldElubmVyUmFkaXVzKGQpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAhd2l0aG91dFVwZGF0ZSAmJiAkJC51cGRhdGVBbmdsZShkKTtcclxuXHJcblx0XHRcdFx0aWYgKHdpdGhvdXRVcGRhdGUpIHtcclxuXHRcdFx0XHRcdHBhdGggPSBhcmMoZCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRwYXRoID0gYXJjKHVwZGF0ZWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHBhdGg7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFRPRE86IGV4dGVuZHMgYWxsIGZ1bmN0aW9uXHJcblx0XHRuZXdBcmMuY2VudHJvaWQgPSBhcmMuY2VudHJvaWQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ld0FyYztcclxuXHR9LFxyXG5cclxuXHRnZXRTdmdBcmNFeHBhbmRlZChyYXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBuZXdSYXRlID0gcmF0ZSB8fCAxO1xyXG5cdFx0Y29uc3Qgc2luZ2xlQXJjV2lkdGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aDtcclxuXHRcdGNvbnN0IGhhc011bHRpQXJjR2F1Z2UgPSAkJC5oYXNNdWx0aUFyY0dhdWdlKCk7XHJcblx0XHRjb25zdCBleHBhbmRXaWR0aCA9IE1hdGgubWluKHN0YXRlLnJhZGl1c0V4cGFuZGVkICogbmV3UmF0ZSAtIHN0YXRlLnJhZGl1cyxcclxuXHRcdFx0c2luZ2xlQXJjV2lkdGggKiAwLjggLSAoMSAtIG5ld1JhdGUpICogMTAwXHJcblx0XHQpO1xyXG5cclxuXHRcdGNvbnN0IGFyYyA9IGQzQXJjKClcclxuXHRcdFx0Lm91dGVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIGQuaW5kZXggKyBleHBhbmRXaWR0aCA6XHJcblx0XHRcdFx0c3RhdGUucmFkaXVzRXhwYW5kZWQgKiBuZXdSYXRlKVxyXG5cdFx0XHQpXHJcblx0XHRcdC5pbm5lclJhZGl1cygoZDogYW55KSA9PiAoaGFzTXVsdGlBcmNHYXVnZSA/XHJcblx0XHRcdFx0c3RhdGUucmFkaXVzIC0gc2luZ2xlQXJjV2lkdGggKiAoZC5pbmRleCArIDEpIDogc3RhdGUuaW5uZXJSYWRpdXMpKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblxyXG5cdFx0XHRpZiAodXBkYXRlZCkge1xyXG5cdFx0XHRcdHJldHVybiAoXHJcblx0XHRcdFx0XHRoYXNNdWx0aUFyY0dhdWdlID8gYXJjIDogYXJjLmlubmVyUmFkaXVzKCQkLmdldElubmVyUmFkaXVzKGQpKVxyXG5cdFx0XHRcdCkodXBkYXRlZCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIFwiTSAwIDBcIjtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmMoZCwgd2l0aG91dFVwZGF0ZSwgZm9yY2UpIHtcclxuXHRcdHJldHVybiBmb3JjZSB8fCB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gdGhpcy5zdmdBcmMoZCwgd2l0aG91dFVwZGF0ZSkgOiBcIk0gMCAwXCI7XHJcblx0fSxcclxuXHJcblx0dHJhbnNmb3JtRm9yQXJjTGFiZWwoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtyYWRpdXMsIHJhZGl1c0V4cGFuZGVkfX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRsZXQgdHJhbnNsYXRlID0gXCJcIjtcclxuXHJcblx0XHRpZiAodXBkYXRlZCkge1xyXG5cdFx0XHRpZiAoJCQuaGFzTXVsdGlBcmNHYXVnZSgpKSB7XHJcblx0XHRcdFx0Y29uc3QgeTEgPSBNYXRoLnNpbih1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDIpO1xyXG5cclxuXHRcdFx0XHRjb25zdCB4ID0gTWF0aC5jb3ModXBkYXRlZC5lbmRBbmdsZSAtIE1hdGguUEkgLyAyKSAqIChyYWRpdXNFeHBhbmRlZCArIDI1KTtcclxuXHRcdFx0XHRjb25zdCB5ID0geTEgKiAocmFkaXVzRXhwYW5kZWQgKyAxNSAtIE1hdGguYWJzKHkxICogMTApKSArIDM7XHJcblxyXG5cdFx0XHRcdHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt4fSwke3l9KWA7XHJcblx0XHRcdH0gZWxzZSBpZiAoISQkLmhhc1R5cGUoXCJnYXVnZVwiKSB8fCAkJC5kYXRhLnRhcmdldHMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHRcdGNvbnN0IGMgPSB0aGlzLnN2Z0FyYy5jZW50cm9pZCh1cGRhdGVkKTtcclxuXHRcdFx0XHRjb25zdCB4ID0gaXNOYU4oY1swXSkgPyAwIDogY1swXTtcclxuXHRcdFx0XHRjb25zdCB5ID0gaXNOYU4oY1sxXSkgPyAwIDogY1sxXTtcclxuXHRcdFx0XHRjb25zdCBoID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xyXG5cclxuXHRcdFx0XHRsZXQgcmF0aW8gPSAoJCQuaGFzVHlwZShcImRvbnV0XCIpICYmIGNvbmZpZy5kb251dF9sYWJlbF9yYXRpbykgfHxcclxuXHRcdFx0XHRcdCgkJC5oYXNUeXBlKFwicGllXCIpICYmIGNvbmZpZy5waWVfbGFiZWxfcmF0aW8pO1xyXG5cclxuXHRcdFx0XHRpZiAocmF0aW8pIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gaXNGdW5jdGlvbihyYXRpbykgPyByYXRpbyhkLCByYWRpdXMsIGgpIDogcmF0aW87XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJhdGlvID0gcmFkaXVzICYmIChcclxuXHRcdFx0XHRcdFx0aCA/ICgzNiAvIHJhZGl1cyA+IDAuMzc1ID8gMS4xNzUgLSAzNiAvIHJhZGl1cyA6IDAuOCkgKiByYWRpdXMgLyBoIDogMFxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRyYW5zbGF0ZSA9IGB0cmFuc2xhdGUoJHt4ICogcmF0aW99LCR7eSAqIHJhdGlvfSlgO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRyYW5zbGF0ZTtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0VG9BcmNEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmFkZE5hbWUoe1xyXG5cdFx0XHRpZDogZC5kYXRhLmlkLFxyXG5cdFx0XHR2YWx1ZTogZC52YWx1ZSxcclxuXHRcdFx0cmF0aW86IHRoaXMuZ2V0UmF0aW8oXCJhcmNcIiwgZCksXHJcblx0XHRcdGluZGV4OiBkLmluZGV4LFxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dGV4dEZvckFyY0xhYmVsKHNlbGVjdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdGlmICgkJC5zaG91bGRTaG93QXJjTGFiZWwoKSkge1xyXG5cdFx0XHRzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHVwZGF0ZWQgPyB1cGRhdGVkLnZhbHVlIDogZC52YWx1ZTtcclxuXHRcdFx0XHRjb25zdCByYXRpbyA9ICQkLmdldFJhdGlvKFwiYXJjXCIsIHVwZGF0ZWQpO1xyXG5cdFx0XHRcdGNvbnN0IGlkID0gZC5kYXRhLmlkO1xyXG5cdFx0XHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0XHRcdGNvbnN0IGlzVW5kZXJUaHJlc2hvbGQgPSAhKFxyXG5cdFx0XHRcdFx0IWhhc0dhdWdlICYmICEkJC5tZWV0c0FyY0xhYmVsVGhyZXNob2xkKHJhdGlvKVxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1VuZGVyVGhyZXNob2xkKSB7XHJcblx0XHRcdFx0XHRjb25zdCB0ZXh0ID0gKFxyXG5cdFx0XHRcdFx0XHQkJC5nZXRBcmNMYWJlbEZvcm1hdCgpIHx8ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdFxyXG5cdFx0XHRcdFx0KSh2YWx1ZSwgcmF0aW8sIGlkKS50b1N0cmluZygpO1xyXG5cclxuXHRcdFx0XHRcdHNldFRleHRWYWx1ZShub2RlLCB0ZXh0LCBbLTEsIDFdLCBoYXNHYXVnZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR0ZXh0Rm9yR2F1Z2VNaW5NYXgodmFsdWUsIGlzTWF4KSB7XHJcblx0XHRjb25zdCBmb3JtYXQgPSB0aGlzLmdldEdhdWdlTGFiZWxFeHRlbnRzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZvcm1hdCA/IGZvcm1hdCh2YWx1ZSwgaXNNYXgpIDogdmFsdWU7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQXJjKHRhcmdldElkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7dHJhbnNpdGluZ30sICRlbH0gPSAkJDtcclxuXHJcblx0XHQvLyBNRU1POiBhdm9pZCB0byBjYW5jZWwgdHJhbnNpdGlvblxyXG5cdFx0aWYgKHRyYW5zaXRpbmcpIHtcclxuXHRcdFx0Y29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XHJcblx0XHRcdFx0aWYgKCF0cmFuc2l0aW5nKSB7XHJcblx0XHRcdFx0XHRjbGVhckludGVydmFsKGludGVydmFsKTtcclxuXHJcblx0XHRcdFx0XHQkZWwubGVnZW5kLnNlbGVjdEFsbChgLiR7Q0xBU1MubGVnZW5kSXRlbUZvY3VzZWR9YCkuc2l6ZSgpID4gMCAmJlxyXG5cdFx0XHRcdFx0XHQkJC5leHBhbmRBcmModGFyZ2V0SWRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIDEwKTtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBuZXdUYXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdCRlbC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyhuZXdUYXJnZXRJZHMsIGAuJHtDTEFTUy5jaGFydEFyY31gKSlcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGlmICghJCQuc2hvdWxkRXhwYW5kKGQuZGF0YS5pZCkpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGV4cGFuZER1cmF0aW9uID0gJCQuZ2V0RXhwYW5kQ29uZmlnKGQuZGF0YS5pZCwgXCJkdXJhdGlvblwiKTtcclxuXHRcdFx0XHRjb25zdCBzdmdBcmNFeHBhbmRlZFN1YiA9ICQkLmdldFN2Z0FyY0V4cGFuZGVkKCQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwicmF0ZVwiKSk7XHJcblxyXG5cdFx0XHRcdGQzU2VsZWN0KHRoaXMpLnNlbGVjdEFsbChcInBhdGhcIilcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0XHRcdC5kdXJhdGlvbihleHBhbmREdXJhdGlvbilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZFwiLCAkJC5zdmdBcmNFeHBhbmRlZClcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0XHRcdC5kdXJhdGlvbihleHBhbmREdXJhdGlvbiAqIDIpXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgc3ZnQXJjRXhwYW5kZWRTdWIpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1bmV4cGFuZEFyYyh0YXJnZXRJZHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZToge3RyYW5zaXRpbmd9LCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdGlmICh0cmFuc2l0aW5nKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBuZXdUYXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdHN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKG5ld1RhcmdldElkcywgYC4ke0NMQVNTLmNoYXJ0QXJjfWApKVxyXG5cdFx0XHQuc2VsZWN0QWxsKFwicGF0aFwiKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkID0+ICQkLmdldEV4cGFuZENvbmZpZyhkLmRhdGEuaWQsIFwiZHVyYXRpb25cIikpXHJcblx0XHRcdC5hdHRyKFwiZFwiLCAkJC5zdmdBcmMpO1xyXG5cclxuXHRcdHN2Zy5zZWxlY3RBbGwoYCR7Q0xBU1MuYXJjfWApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBleHBhbmQgY29uZmlnIHZhbHVlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIGRhdGEgSURcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30ga2V5IGNvbmZpZyBrZXk6ICdkdXJhdGlvbiB8IHJhdGUnXHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RXhwYW5kQ29uZmlnKGlkLCBrZXkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkZWYgPSB7XHJcblx0XHRcdGR1cmF0aW9uOiA1MCxcclxuXHRcdFx0cmF0ZTogMC45OFxyXG5cdFx0fTtcclxuXHRcdGxldCB0eXBlO1xyXG5cclxuXHRcdGlmICgkJC5pc0RvbnV0VHlwZShpZCkpIHtcclxuXHRcdFx0dHlwZSA9IFwiZG9udXRcIjtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNHYXVnZVR5cGUoaWQpKSB7XHJcblx0XHRcdHR5cGUgPSBcImdhdWdlXCI7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmlzUGllVHlwZShpZCkpIHtcclxuXHRcdFx0dHlwZSA9IFwicGllXCI7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHR5cGUgPyBjb25maWdbYCR7dHlwZX1fZXhwYW5kXyR7a2V5fWBdIDogZGVmW2tleV07XHJcblx0fSxcclxuXHJcblx0c2hvdWxkRXhwYW5kKGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiAoJCQuaXNEb251dFR5cGUoaWQpICYmIGNvbmZpZy5kb251dF9leHBhbmQpIHx8XHJcblx0XHRcdCgkJC5pc0dhdWdlVHlwZShpZCkgJiYgY29uZmlnLmdhdWdlX2V4cGFuZCkgfHxcclxuXHRcdFx0KCQkLmlzUGllVHlwZShpZCkgJiYgY29uZmlnLnBpZV9leHBhbmQpO1xyXG5cdH0sXHJcblxyXG5cdHNob3VsZFNob3dBcmNMYWJlbCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuIFtcInBpZVwiLCBcImRvbnV0XCIsIFwiZ2F1Z2VcIl1cclxuXHRcdFx0LnNvbWUodiA9PiAkJC5oYXNUeXBlKHYpICYmIGNvbmZpZ1tgJHt2fV9sYWJlbF9zaG93YF0pO1xyXG5cdH0sXHJcblxyXG5cdG1lZXRzQXJjTGFiZWxUaHJlc2hvbGQocmF0aW8pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0aHJlc2hvbGQgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgPyBjb25maWcuZG9udXRfbGFiZWxfdGhyZXNob2xkIDogY29uZmlnLnBpZV9sYWJlbF90aHJlc2hvbGQ7XHJcblxyXG5cdFx0cmV0dXJuIHJhdGlvID49IHRocmVzaG9sZDtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmNMYWJlbEZvcm1hdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRsZXQgZm9ybWF0ID0gY29uZmlnLnBpZV9sYWJlbF9mb3JtYXQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHRmb3JtYXQgPSBjb25maWcuZ2F1Z2VfbGFiZWxfZm9ybWF0O1xyXG5cdFx0fSBlbHNlIGlmICgkJC5oYXNUeXBlKFwiZG9udXRcIikpIHtcclxuXHRcdFx0Zm9ybWF0ID0gY29uZmlnLmRvbnV0X2xhYmVsX2Zvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZm9ybWF0O1xyXG5cdH0sXHJcblxyXG5cdGdldEdhdWdlTGFiZWxFeHRlbnRzKCkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuZ2F1Z2VfbGFiZWxfZXh0ZW50cztcclxuXHR9LFxyXG5cclxuXHRnZXRBcmNUaXRsZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHR5cGUgPSAoJCQuaGFzVHlwZShcImRvbnV0XCIpICYmIFwiZG9udXRcIikgfHwgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiBcImdhdWdlXCIpO1xyXG5cclxuXHRcdHJldHVybiB0eXBlID8gJCQuY29uZmlnW2Ake3R5cGV9X3RpdGxlYF0gOiBcIlwiO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldHNGb3JBcmModGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0QXJjID0gJCQuY2xhc3NDaGFydEFyYy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQXJjcyA9ICQkLmNsYXNzQXJjcy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgbWFpblBpZVVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3N9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRBcmN9YClcclxuXHRcdFx0LmRhdGEoJCQucGllKHRhcmdldHMpKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydEFyYyhkKSArIGNsYXNzRm9jdXMoZC5kYXRhKSk7XHJcblxyXG5cdFx0Y29uc3QgbWFpblBpZUVudGVyID0gbWFpblBpZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QXJjKTtcclxuXHJcblx0XHRtYWluUGllRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXJjcylcclxuXHRcdFx0Lm1lcmdlKG1haW5QaWVVcGRhdGUpO1xyXG5cclxuXHRcdG1haW5QaWVFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwiZHlcIiwgaGFzR2F1Z2UgJiYgISQkLmhhc011bHRpVGFyZ2V0cygpID8gXCItLjFlbVwiIDogXCIuMzVlbVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxyXG5cdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIik7XHJcblx0XHQvLyBNRU1POiBjYW4gbm90IGtlZXAgc2FtZSBjb2xvci4uLiwgYnV0IG5vdCBiYWQgdG8gdXBkYXRlIGNvbG9yIGluIHJlZHJhd1xyXG5cdFx0Ly8gbWFpblBpZVVwZGF0ZS5leGl0KCkucmVtb3ZlKCk7XHJcblx0fSxcclxuXHJcblx0aW5pdEFyYygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLmFyY3MgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJhcmNcIikpO1xyXG5cclxuXHRcdCQkLnNldEFyY1RpdGxlKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGFyYyB0aXRsZSB0ZXh0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRBcmNUaXRsZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHRpdGxlID0gJCQuZ2V0QXJjVGl0bGUoKTtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cclxuXHRcdGlmICh0aXRsZSkge1xyXG5cdFx0XHRjb25zdCB0ZXh0ID0gJCQuJGVsLmFyY3MuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1NbaGFzR2F1Z2UgPyBcImNoYXJ0QXJjc0dhdWdlVGl0bGVcIiA6IFwiY2hhcnRBcmNzVGl0bGVcIl0pXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIik7XHJcblxyXG5cdFx0XHRpZiAoaGFzR2F1Z2UpIHtcclxuXHRcdFx0XHR0ZXh0XHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiLTAuM2VtXCIpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgXCIyN3B4XCIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzZXRUZXh0VmFsdWUodGV4dCwgdGl0bGUsIGhhc0dhdWdlID8gdW5kZWZpbmVkIDogWy0wLjYsIDEuMzVdLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRyZWRyYXdBcmMoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCwgd2l0aFRyYW5zZm9ybSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzSW50ZXJhY3Rpb24gPSBjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZDtcclxuXHJcblx0XHRsZXQgbWFpbkFyYyA9IG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY31gKVxyXG5cdFx0XHQuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRtYWluQXJjLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdG1haW5BcmMgPSBtYWluQXJjLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJjLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gJCQuY29sb3IoZC5kYXRhKSlcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGQgPT4gKGhhc0ludGVyYWN0aW9uICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgPyBcInBvaW50ZXJcIiA6IG51bGwpKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0aWYgKCQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkpIHtcclxuXHRcdFx0XHRcdGQuc3RhcnRBbmdsZSA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xyXG5cdFx0XHRcdFx0ZC5lbmRBbmdsZSA9IGNvbmZpZy5nYXVnZV9zdGFydGluZ0FuZ2xlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGhpcy5fY3VycmVudCA9IGQ7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5tZXJnZShtYWluQXJjKTtcclxuXHJcblx0XHQkJC5oYXNNdWx0aUFyY0dhdWdlKCkgJiYgJCQucmVkcmF3TXVsdGlBcmNHYXVnZSgpO1xyXG5cclxuXHRcdG1haW5BcmNcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiAoISQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkgJiYgd2l0aFRyYW5zZm9ybSA/IFwic2NhbGUoMClcIiA6IFwiXCIpKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRyZXR1cm4gZCA9PT0gdGhpcy5fY3VycmVudCA/IFwiMFwiIDogXCIxXCI7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5lYWNoKCgpID0+IHtcclxuXHRcdFx0XHRzdGF0ZS50cmFuc2l0aW5nID0gdHJ1ZTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdC5hdHRyVHdlZW4oXCJkXCIsIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblxyXG5cdFx0XHRcdGlmICghdXBkYXRlZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuICgpID0+IFwiTSAwIDBcIjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc05hTih0aGlzLl9jdXJyZW50LnN0YXJ0QW5nbGUpKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50LnN0YXJ0QW5nbGUgPSAwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMuX2N1cnJlbnQuZW5kQW5nbGUpKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50LmVuZEFuZ2xlID0gdGhpcy5fY3VycmVudC5zdGFydEFuZ2xlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgaW50ZXJwb2xhdGUgPSBkM0ludGVycG9sYXRlKHRoaXMuX2N1cnJlbnQsIHVwZGF0ZWQpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9jdXJyZW50ID0gaW50ZXJwb2xhdGUoMCk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbih0KSB7XHJcblx0XHRcdFx0XHRjb25zdCBpbnRlcnBvbGF0ZWQgPSBpbnRlcnBvbGF0ZSh0KTtcclxuXHJcblx0XHRcdFx0XHRpbnRlcnBvbGF0ZWQuZGF0YSA9IGQuZGF0YTsgLy8gZGF0YS5pZCB3aWxsIGJlIHVwZGF0ZWQgYnkgaW50ZXJwb3JhdG9yXHJcblx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGludGVycG9sYXRlZCwgdHJ1ZSk7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgd2l0aFRyYW5zZm9ybSA/IFwic2NhbGUoMSlcIiA6IFwiXCIpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgZCA9PiB7XHJcblx0XHRcdFx0bGV0IGNvbG9yO1xyXG5cclxuXHRcdFx0XHRpZiAoJCQubGV2ZWxDb2xvcikge1xyXG5cdFx0XHRcdFx0Y29sb3IgPSAkJC5sZXZlbENvbG9yKGQuZGF0YS52YWx1ZXNbMF0udmFsdWUpO1xyXG5cclxuXHRcdFx0XHRcdC8vIHVwZGF0ZSBkYXRhJ3MgY29sb3JcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX2NvbG9yc1tkLmRhdGEuaWRdID0gY29sb3I7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbG9yID0gJCQuY29sb3IoZC5kYXRhLmlkKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBjb2xvcjtcclxuXHRcdFx0fSlcclxuXHRcdFx0Ly8gV2hlcmUgZ2F1Z2UgcmVhZGluZyBjb2xvciB3b3VsZCByZWNlaXZlIGN1c3RvbWl6YXRpb24uXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRcdC5jYWxsKCQkLmVuZGFsbCwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKCQkLmxldmVsQ29sb3IpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHBhdGggPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRcdGNvbnN0IGQ6IGFueSA9IHBhdGguZGF0dW0oKTtcclxuXHJcblx0XHRcdFx0XHQkJC51cGRhdGVMZWdlbmRJdGVtQ29sb3IoZC5kYXRhLmlkLCBwYXRoLnN0eWxlKFwiZmlsbFwiKSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGF0ZS50cmFuc2l0aW5nID0gZmFsc2U7XHJcblx0XHRcdFx0Y2FsbEZuKGNvbmZpZy5vbnJlbmRlcmVkLCAkJCwgJCQuYXBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gYmluZCBhcmMgZXZlbnRzXHJcblx0XHRoYXNJbnRlcmFjdGlvbiAmJiAkJC5iaW5kQXJjRXZlbnQobWFpbkFyYyk7XHJcblxyXG5cdFx0JCQucmVkcmF3QXJjVGV4dChkdXJhdGlvbik7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3TXVsdGlBcmNHYXVnZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB7aGlkZGVuVGFyZ2V0SWRzfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdGNvbnN0IGFyY0xhYmVsTGluZXMgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY3N9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjTGFiZWxMaW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmFyY0RhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdGNvbnN0IG1haW5BcmNMYWJlbExpbmUgPSBhcmNMYWJlbExpbmVzLmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAke0NMQVNTLmFyY0xhYmVsTGluZX0gJHtDTEFTUy50YXJnZXR9ICR7Q0xBU1MudGFyZ2V0fS0ke2QuZGF0YS5pZH1gKVxyXG5cdFx0XHQubWVyZ2UoYXJjTGFiZWxMaW5lcyk7XHJcblxyXG5cdFx0bWFpbkFyY0xhYmVsTGluZVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gKCQkLmxldmVsQ29sb3IgPyAkJC5sZXZlbENvbG9yKGQuZGF0YS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IoZC5kYXRhKSkpXHJcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBcIlwiIDogXCJub25lXCIpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRsZXQgbGluZUxlbmd0aCA9IDA7XHJcblx0XHRcdFx0Y29uc3QgbGluZVRoaWNrbmVzcyA9IDI7XHJcblx0XHRcdFx0bGV0IHggPSAwO1xyXG5cdFx0XHRcdGxldCB5ID0gMDtcclxuXHRcdFx0XHRsZXQgdHJhbnNmb3JtID0gXCJcIjtcclxuXHJcblx0XHRcdFx0aWYgKGhpZGRlblRhcmdldElkcy5pbmRleE9mKGQuZGF0YS5pZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBpbm5lckxpbmVMZW5ndGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCAqXHJcblx0XHRcdFx0XHRcdCh1cGRhdGVkLmluZGV4ICsgMSk7XHJcblx0XHRcdFx0XHRjb25zdCBsaW5lQW5nbGUgPSB1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDI7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNJbm5lclJhZGl1cyA9IHN0YXRlLnJhZGl1cyAtIGlubmVyTGluZUxlbmd0aDtcclxuXHRcdFx0XHRcdGNvbnN0IGxpbmVQb3NpdGlvbmluZ0FuZ2xlID0gbGluZUFuZ2xlIC0gKGFyY0lubmVyUmFkaXVzID09PSAwID8gMCA6ICgxIC8gYXJjSW5uZXJSYWRpdXMpKTtcclxuXHJcblx0XHRcdFx0XHRsaW5lTGVuZ3RoID0gc3RhdGUucmFkaXVzRXhwYW5kZWQgLSBzdGF0ZS5yYWRpdXMgKyBpbm5lckxpbmVMZW5ndGg7XHJcblx0XHRcdFx0XHR4ID0gTWF0aC5jb3MobGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXM7XHJcblx0XHRcdFx0XHR5ID0gTWF0aC5zaW4obGluZVBvc2l0aW9uaW5nQW5nbGUpICogYXJjSW5uZXJSYWRpdXM7XHJcblx0XHRcdFx0XHR0cmFuc2Zvcm0gPSBgcm90YXRlKCR7bGluZUFuZ2xlICogMTgwIC8gTWF0aC5QSX0sICR7eH0sICR7eX0pYDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGQzU2VsZWN0KHRoaXMpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeClcclxuXHRcdFx0XHRcdC5hdHRyKFwieVwiLCB5KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBsaW5lTGVuZ3RoKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgbGluZVRoaWNrbmVzcylcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSlcclxuXHRcdFx0XHRcdC5zdHlsZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgYDAsICR7bGluZUxlbmd0aCArIGxpbmVUaGlja25lc3N9LCAwYCk7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGJpbmRBcmNFdmVudChhcmMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNUb3VjaCA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiO1xyXG5cdFx0Y29uc3QgaXNNb3VzZSA9IHN0YXRlLmlucHV0VHlwZSA9PT0gXCJtb3VzZVwiO1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNlbGVjdEFyYyhfdGhpcywgYXJjRGF0YSwgaWQpIHtcclxuXHRcdFx0Ly8gdHJhbnNpdGlvbnNcclxuXHRcdFx0JCQuZXhwYW5kQXJjKGlkKTtcclxuXHRcdFx0JCQuYXBpLmZvY3VzKGlkKTtcclxuXHRcdFx0JCQudG9nZ2xlRm9jdXNMZWdlbmQoaWQsIHRydWUpO1xyXG5cdFx0XHQkJC5zaG93VG9vbHRpcChbYXJjRGF0YV0sIF90aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiB1bnNlbGVjdEFyYyhhcmNEYXRhPykge1xyXG5cdFx0XHRjb25zdCBpZCA9IChhcmNEYXRhICYmIGFyY0RhdGEuaWQpIHx8IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdCQkLnVuZXhwYW5kQXJjKGlkKTtcclxuXHRcdFx0JCQuYXBpLnJldmVydCgpO1xyXG5cdFx0XHQkJC5yZXZlcnRMZWdlbmQoKTtcclxuXHRcdFx0JCQuaGlkZVRvb2x0aXAoKTtcclxuXHRcdH1cclxuXHJcblx0XHRhcmNcclxuXHRcdFx0Lm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdFx0XHRsZXQgYXJjRGF0YTtcclxuXHJcblx0XHRcdFx0aWYgKHVwZGF0ZWQpIHtcclxuXHRcdFx0XHRcdGFyY0RhdGEgPSAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnRvZ2dsZVNoYXBlICYmICQkLnRvZ2dsZVNoYXBlKHRoaXMsIGFyY0RhdGEsIGkpO1xyXG5cdFx0XHRcdFx0Y29uZmlnLmRhdGFfb25jbGljay5jYWxsKCQkLmFwaSwgYXJjRGF0YSwgdGhpcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHQvLyBtb3VzZSBldmVudHNcclxuXHRcdGlmIChpc01vdXNlKSB7XHJcblx0XHRcdGFyY1xyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRpZiAoc3RhdGUudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XHJcblx0XHRcdFx0XHRjb25zdCBpZCA9IChhcmNEYXRhICYmIGFyY0RhdGEuaWQpIHx8IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdFx0XHRzZWxlY3RBcmModGhpcywgYXJjRGF0YSwgaWQpO1xyXG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dCh0cnVlLCBhcmNEYXRhKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsIGQgPT4ge1xyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLnRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRcdHVuc2VsZWN0QXJjKCk7XHJcblx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBhcmNEYXRhKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRcdCQkLnNob3dUb29sdGlwKFthcmNEYXRhXSwgdGhpcyk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdG91Y2ggZXZlbnRzXHJcblx0XHRpZiAoaXNUb3VjaCAmJiAkJC5oYXNBcmNUeXBlKCkgJiYgISQkLnJhZGFycykge1xyXG5cdFx0XHRjb25zdCBnZXRFdmVudEFyYyA9ICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCB0b3VjaCA9IGQzRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblx0XHRcdFx0Y29uc3QgZXZlbnRBcmMgPSBkM1NlbGVjdChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGV2ZW50QXJjO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0Y29uc3QgaGFuZGxlciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmIChzdGF0ZS50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgZXZlbnRBcmMgPSBnZXRFdmVudEFyYygpO1xyXG5cdFx0XHRcdGNvbnN0IGRhdHVtOiBhbnkgPSBldmVudEFyYy5kYXR1bSgpO1xyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAoZGF0dW0gJiYgZGF0dW0uZGF0YSAmJiBkYXR1bS5kYXRhLmlkKSA/ICQkLnVwZGF0ZUFuZ2xlKGRhdHVtKSA6IG51bGw7XHJcblx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHRcdFx0XHRjb25zdCBpZCA9IChhcmNEYXRhICYmIGFyY0RhdGEuaWQpIHx8IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaChhcmNEYXRhKTtcclxuXHJcblx0XHRcdFx0aXNVbmRlZmluZWQoaWQpID9cclxuXHRcdFx0XHRcdHVuc2VsZWN0QXJjKCkgOiBzZWxlY3RBcmModGhpcywgYXJjRGF0YSwgaWQpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0JCQuJGVsLnN2Z1xyXG5cdFx0XHRcdC5vbihcInRvdWNoc3RhcnRcIiwgaGFuZGxlcilcclxuXHRcdFx0XHQub24oXCJ0b3VjaG1vdmVcIiwgaGFuZGxlcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVkcmF3QXJjVGV4dChkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge21haW4sIGFyY3N9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblx0XHRjb25zdCBoYXNNdWx0aUFyY0dhdWdlID0gJCQuaGFzTXVsdGlBcmNHYXVnZSgpO1xyXG5cdFx0bGV0IHRleHQ7XHJcblxyXG5cdFx0Ly8gZm9yIGdhdWdlIHR5cGUsIHVwZGF0ZSB0ZXh0IHdoZW4gaGFzIG5vIHRpdGxlICYgbXVsdGkgZGF0YVxyXG5cdFx0aWYgKCEoaGFzR2F1Z2UgJiYgJCQuZGF0YS50YXJnZXRzLmxlbmd0aCA9PT0gMSAmJiBjb25maWcuZ2F1Z2VfdGl0bGUpKSB7XHJcblx0XHRcdHRleHQgPSBtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2hhcnRBcmN9YClcclxuXHRcdFx0XHQuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+ICgkJC5pc0dhdWdlVHlwZShkLmRhdGEpID8gQ0xBU1MuZ2F1Z2VWYWx1ZSA6IG51bGwpKVxyXG5cdFx0XHRcdC5jYWxsKCQkLnRleHRGb3JBcmNMYWJlbC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC50cmFuc2Zvcm1Gb3JBcmNMYWJlbC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuc3R5bGUoXCJmb250LXNpemVcIiwgZCA9PiAoXHJcblx0XHRcdFx0XHQkJC5pc0dhdWdlVHlwZShkLmRhdGEpICYmICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPT09IDEgJiYgIWhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdFx0XHRgJHtNYXRoLnJvdW5kKHN0YXRlLnJhZGl1cyAvIDUpfXB4YCA6IG51bGxcclxuXHRcdFx0XHQpKVxyXG5cdFx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0XHQuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+ICgkJC5pc1RhcmdldFRvU2hvdyhkLmRhdGEuaWQpICYmICQkLmlzQXJjVHlwZShkLmRhdGEpID8gXCIxXCIgOiBcIjBcIikpO1xyXG5cclxuXHRcdFx0aGFzTXVsdGlBcmNHYXVnZSAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBcIi0uMWVtXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NUaXRsZX1gKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmhhc1R5cGUoXCJkb251dFwiKSB8fCBoYXNHYXVnZSA/IFwiMVwiIDogXCIwXCIpO1xyXG5cclxuXHRcdGlmIChoYXNHYXVnZSkge1xyXG5cdFx0XHRjb25zdCBpc0Z1bGxDaXJjbGUgPSBjb25maWcuZ2F1Z2VfZnVsbENpcmNsZTtcclxuXHRcdFx0Y29uc3Qgc3RhcnRBbmdsZSA9IC0xICogTWF0aC5QSSAvIDI7XHJcblx0XHRcdGNvbnN0IGVuZEFuZ2xlID0gKGlzRnVsbENpcmNsZSA/IC00IDogLTEpICogc3RhcnRBbmdsZTtcclxuXHJcblx0XHRcdGlzRnVsbENpcmNsZSAmJiB0ZXh0ICYmIHRleHQuYXR0cihcImR5XCIsIGAke01hdGgucm91bmQoc3RhdGUucmFkaXVzIC8gMTQpfWApO1xyXG5cclxuXHRcdFx0bGV0IGJhY2tncm91bmRBcmMgPSAkJC4kZWwuYXJjcy5zZWxlY3QoXHJcblx0XHRcdFx0YCR7aGFzTXVsdGlBcmNHYXVnZSA/IFwiZ1wiIDogXCJcIn0uJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfWBcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGlmIChoYXNNdWx0aUFyY0dhdWdlKSB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gMDtcclxuXHJcblx0XHRcdFx0YmFja2dyb3VuZEFyYyA9IGJhY2tncm91bmRBcmNcclxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoYHBhdGguJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfWApXHJcblx0XHRcdFx0XHQuZGF0YSgkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmVudGVyKClcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBgJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfSAke0NMQVNTLmNoYXJ0QXJjc0JhY2tncm91bmR9LSR7aX1gKVxyXG5cdFx0XHRcdFx0Lm1lcmdlKGJhY2tncm91bmRBcmMpXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZDEgPT4ge1xyXG5cdFx0XHRcdFx0XHRpZiAoc3RhdGUuaGlkZGVuVGFyZ2V0SWRzLmluZGV4T2YoZDEuaWQpID49IDApIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gXCJNIDAgMFwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRjb25zdCBkID0ge1xyXG5cdFx0XHRcdFx0XHRcdGRhdGE6IFt7dmFsdWU6IGNvbmZpZy5nYXVnZV9tYXh9XSxcclxuXHRcdFx0XHRcdFx0XHRzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRcdGVuZEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRcdGluZGV4OiBpbmRleCsrXHJcblx0XHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMuZXhpdCgpLnJlbW92ZSgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMuYXR0cihcImRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgZCA9IHtcclxuXHRcdFx0XHRcdFx0ZGF0YTogW3t2YWx1ZTogY29uZmlnLmdhdWdlX21heH1dLFxyXG5cdFx0XHRcdFx0XHRzdGFydEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRlbmRBbmdsZVxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gJCQuZ2V0QXJjKGQsIHRydWUsIHRydWUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VVbml0fWApXHJcblx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi43NWVtXCIpXHJcblx0XHRcdFx0LnRleHQoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyBjb25maWcuZ2F1Z2VfdW5pdHMgOiBcIlwiKTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuZ2F1Z2VfbGFiZWxfc2hvdykge1xyXG5cdFx0XHRcdGFyY3Muc2VsZWN0KGAuJHtDTEFTUy5jaGFydEFyY3NHYXVnZU1pbn1gKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCBgJHstMSAqIChzdGF0ZS5pbm5lclJhZGl1cyArICgoc3RhdGUucmFkaXVzIC0gc3RhdGUuaW5uZXJSYWRpdXMpIC8gKGlzRnVsbENpcmNsZSA/IDEgOiAyKSkpfXB4YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIxLjJlbVwiKVxyXG5cdFx0XHRcdFx0LnRleHQoJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9taW4sIGZhbHNlKSk7XHJcblxyXG5cdFx0XHRcdC8vIHNob3cgbWF4IHRleHQgd2hlbiBpc24ndCBmdWxsQ2lyY2xlXHJcblx0XHRcdFx0IWlzRnVsbENpcmNsZSAmJiBhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXh9YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7c3RhdGUuaW5uZXJSYWRpdXMgKyAoKHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzKSAvIDIpfXB4YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIxLjJlbVwiKVxyXG5cdFx0XHRcdFx0LnRleHQoJCQudGV4dEZvckdhdWdlTWluTWF4KGNvbmZpZy5nYXVnZV9tYXgsIHRydWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGluaXRHYXVnZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge2FyY3N9fSA9ICQkO1xyXG5cdFx0Y29uc3QgYXBwZW5kVGV4dCA9IGNsYXNzTmFtZSA9PiB7XHJcblx0XHRcdGFyY3MuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NOYW1lKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XHJcblx0XHRcdGFyY3MuYXBwZW5kKCQkLmhhc011bHRpQXJjR2F1Z2UoKSA/IFwiZ1wiIDogXCJwYXRoXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kKTtcclxuXHJcblx0XHRcdGNvbmZpZy5nYXVnZV91bml0cyAmJiBhcHBlbmRUZXh0KENMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdCk7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cpIHtcclxuXHRcdFx0XHRhcHBlbmRUZXh0KENMQVNTLmNoYXJ0QXJjc0dhdWdlTWluKTtcclxuXHRcdFx0XHQhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgJiYgYXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZU1heCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRHYXVnZUxhYmVsSGVpZ2h0KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cgPyAyMCA6IDA7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRNaW5NYXgsIGdldFJhbmdlLCBpc0RlZmluZWQsIGlzRW1wdHksIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgc2V0VGV4dFZhbHVlLCB0b0FycmF5fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHBvc2l0aW9uIHZhbHVlXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNDbG9ja3dpc2UgSWYgdGhlIGRpcmVjdGlvbiBpcyBjbG9ja3dpc2VcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQ29vcmRpbmF0ZSB0eXBlICd4JyBvciAneSdcclxuICogQHBhcmFtIHtOdW1iZXJ9IGVkZ2UgTnVtYmVyIG9mIGVkZ2VcclxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcyBUaGUgaW5kZXhlZCBwb3NpdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFuZ2VcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGlzQ2xvY2t3aXNlLCB0eXBlLCBlZGdlLCBwb3MsIHJhbmdlLCByYXRpbykge1xyXG5cdGNvbnN0IGluZGV4ID0gaXNDbG9ja3dpc2UgJiYgcG9zID4gMCA/IGVkZ2UgLSBwb3MgOiBwb3M7XHJcblx0Y29uc3QgciA9IDIgKiBNYXRoLlBJO1xyXG5cdGNvbnN0IGZ1bmMgPSB0eXBlID09PSBcInhcIiA/IE1hdGguc2luIDogTWF0aC5jb3M7XHJcblxyXG5cdHJldHVybiByYW5nZSAqICgxIC0gcmF0aW8gKiBmdW5jKGluZGV4ICogciAvIGVkZ2UpKTtcclxufVxyXG5cclxuLy8gY2FjaGUga2V5XHJcbmNvbnN0IGNhY2hlS2V5ID0gXCIkcmFkYXJQb2ludHNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0UmFkYXIoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwicmFkYXJcIikpIHtcclxuXHRcdFx0JCQucmFkYXJzID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydFJhZGFycyk7XHJcblxyXG5cdFx0XHQvLyBsZXZlbFxyXG5cdFx0XHQkJC5yYWRhcnMubGV2ZWxzID0gJCQucmFkYXJzLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmxldmVscyk7XHJcblxyXG5cdFx0XHQvLyBheGlzXHJcblx0XHRcdCQkLnJhZGFycy5heGVzID0gJCQucmFkYXJzLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXMpO1xyXG5cclxuXHRcdFx0Ly8gc2hhcGVzXHJcblx0XHRcdCQkLnJhZGFycy5zaGFwZXMgPSAkJC5yYWRhcnMuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muc2hhcGVzKTtcclxuXHJcblx0XHRcdCQkLm1heFZhbHVlID0gY29uZmlnLnJhZGFyX2F4aXNfbWF4IHx8ICQkLmdldE1pbk1heERhdGEoKS5tYXhbMF0udmFsdWU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkYXJTaXplKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHthcmNXaWR0aCwgYXJjSGVpZ2h0fX0gPSAkJDtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoIDwgNCA/IC0yMCA6IDEwO1xyXG5cdFx0Y29uc3Qgc2l6ZSA9IChNYXRoLm1pbihhcmNXaWR0aCwgYXJjSGVpZ2h0KSAtIHBhZGRpbmcpIC8gMjtcclxuXHJcblx0XHRyZXR1cm4gW3NpemUsIHNpemVdO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmIChpc0VtcHR5KGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcykpIHtcclxuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gZ2V0UmFuZ2UoMCwgZ2V0TWluTWF4KFwibWF4XCIsIHRhcmdldHMubWFwKHYgPT4gdi52YWx1ZXMubGVuZ3RoKSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmdlbmVyYXRlUmFkYXJQb2ludHMoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRSYWRhclBvc2l0aW9uKHR5cGUsIGluZGV4LCByYW5nZSwgcmF0aW8pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IGVkZ2UgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xyXG5cdFx0Y29uc3QgaXNDbG9ja3dpc2UgPSBjb25maWcucmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZTtcclxuXHJcblx0XHRjb25zdCBwb3MgPSB0b0FycmF5KHR5cGUpLm1hcCh2ID0+IGdldFBvc2l0aW9uKFxyXG5cdFx0XHRpc0Nsb2Nrd2lzZSxcclxuXHRcdFx0dixcclxuXHRcdFx0ZWRnZSxcclxuXHRcdFx0aW5kZXgsXHJcblx0XHRcdGlzRGVmaW5lZChyYW5nZSkgPyByYW5nZSA6ICh0eXBlID09PSBcInhcIiA/IHdpZHRoIDogaGVpZ2h0KSxcclxuXHRcdFx0aXNOdW1iZXIocmF0aW8pID8gcmF0aW8gOiBjb25maWcucmFkYXJfc2l6ZV9yYXRpb1xyXG5cdFx0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHBvcy5sZW5ndGggPT09IDEgPyBwb3NbMF0gOiBwb3M7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgZGF0YSBwb2ludHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlUmFkYXJQb2ludHMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzO1xyXG5cclxuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cdFx0Y29uc3QgcG9pbnRzID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KSB8fCB7fTtcclxuXHRcdGNvbnN0IHNpemUgPSBwb2ludHMuX3NpemU7XHJcblxyXG5cdFx0Ly8gcmVjYWxjdWxhdGUgcG9zaXRpb24gb25seSB3aGVuIHRoZSBwcmV2aW91cyBkaW1lbnNpb24gaGFzIGJlZW4gY2hhbmdlZFxyXG5cdFx0aWYgKCFzaXplIHx8IChzaXplLndpZHRoICE9PSB3aWR0aCAmJiBzaXplLmhlaWdodCAhPT0gaGVpZ2h0KSkge1xyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0cG9pbnRzW2QuaWRdID0gZC52YWx1ZXMubWFwKCh2LCBpKSA9PiAoXHJcblx0XHRcdFx0XHQkJC5nZXRSYWRhclBvc2l0aW9uKFtcInhcIiwgXCJ5XCJdLCBpLCB1bmRlZmluZWQsICQkLmdldFJhdGlvKFwicmFkYXJcIiwgdikpXHJcblx0XHRcdFx0KSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0cG9pbnRzLl9zaXplID0ge3dpZHRoLCBoZWlnaHR9O1xyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIHBvaW50cyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVkcmF3UmFkYXIoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3QgdHJhbnNsYXRlID0gJCQuZ2V0VHJhbnNsYXRlKFwicmFkYXJcIik7XHJcblxyXG5cdFx0Ly8gQWRqdXN0IHJhZGFyLCBjaXJjbGVzIGFuZCB0ZXh0cycgcG9zaXRpb25cclxuXHRcdGlmICh0cmFuc2xhdGUpIHtcclxuXHRcdFx0JCQucmFkYXJzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlKTtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNpcmNsZXN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xyXG5cdFx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRUZXh0c31gKS5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XHJcblxyXG5cdFx0XHQkJC5nZW5lcmF0ZVJhZGFyUG9pbnRzKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVJhZGFyTGV2ZWwoKTtcclxuXHRcdFx0JCQudXBkYXRlUmFkYXJBeGVzKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVJhZGFyU2hhcGUoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRSYWRhclBvaW50cygpIHtcclxuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3QgcG9pbnQgPSBwb2ludHNbZC5pZF1baV07XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdHBvaW50LFxyXG5cdFx0XHRcdHBvaW50LFxyXG5cdFx0XHRcdHBvaW50LFxyXG5cdFx0XHRcdHBvaW50XHJcblx0XHRcdF07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGFyTGV2ZWwoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XHJcblx0XHRjb25zdCBkZXB0aCA9IGNvbmZpZy5yYWRhcl9sZXZlbF9kZXB0aDtcclxuXHRcdGNvbnN0IGVkZ2UgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xyXG5cdFx0Y29uc3Qgc2hvd1RleHQgPSBjb25maWcucmFkYXJfbGV2ZWxfdGV4dF9zaG93O1xyXG5cclxuXHRcdGNvbnN0IHJhZGFyTGV2ZWxzID0gJCQucmFkYXJzLmxldmVscztcclxuXHRcdGNvbnN0IGxldmVsRGF0YSA9IGdldFJhbmdlKDAsIGRlcHRoKTtcclxuXHJcblx0XHRjb25zdCByYWRpdXMgPSBjb25maWcucmFkYXJfc2l6ZV9yYXRpbyAqIE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xyXG5cdFx0Y29uc3QgbGV2ZWxSYXRpbyA9IGxldmVsRGF0YS5tYXAobCA9PiByYWRpdXMgKiAoKGwgKyAxKSAvIGRlcHRoKSk7XHJcblx0XHRjb25zdCBsZXZlbFRleHRGb3JtYXQgPSBjb25maWcucmFkYXJfbGV2ZWxfdGV4dF9mb3JtYXQ7XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgcG9pbnRzXHJcblx0XHRjb25zdCBwb2ludHMgPSBsZXZlbERhdGEubWFwKHYgPT4ge1xyXG5cdFx0XHRjb25zdCByYW5nZSA9IGxldmVsUmF0aW9bdl07XHJcblx0XHRcdGNvbnN0IHBvcyA9IGdldFJhbmdlKDAsIGVkZ2UpLm1hcChpID0+IChcclxuXHRcdFx0XHQkJC5nZXRSYWRhclBvc2l0aW9uKFtcInhcIiwgXCJ5XCJdLCBpLCByYW5nZSwgMSkpLmpvaW4oXCIsXCIpXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gcG9zLmpvaW4oXCIgXCIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWwgPSByYWRhckxldmVsc1xyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZXZlbH1gKVxyXG5cdFx0XHQuZGF0YShsZXZlbERhdGEpO1xyXG5cclxuXHRcdGxldmVsLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRjb25zdCBsZXZlbEVudGVyID0gbGV2ZWwuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGAke0NMQVNTLmxldmVsfSAke0NMQVNTLmxldmVsfS0ke2l9YCk7XHJcblxyXG5cdFx0bGV2ZWxFbnRlci5hcHBlbmQoXCJwb2x5Z29uXCIpXHJcblx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgY29uZmlnLnJhZGFyX2xldmVsX3Nob3cgPyBudWxsIDogXCJoaWRkZW5cIik7XHJcblxyXG5cdFx0aWYgKHNob3dUZXh0KSB7XHJcblx0XHRcdGlmIChyYWRhckxldmVscy5zZWxlY3QoXCJ0ZXh0XCIpLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRyYWRhckxldmVsc1xyXG5cdFx0XHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi0uN2VtXCIpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxyXG5cdFx0XHRcdFx0LnRleHQoKCkgPT4gbGV2ZWxUZXh0Rm9ybWF0KDApKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV2ZWxFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJkeFwiLCBcIi0uNWVtXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcclxuXHRcdFx0XHQudGV4dChkID0+IGxldmVsVGV4dEZvcm1hdChcclxuXHRcdFx0XHRcdCQkLm1heFZhbHVlIC8gbGV2ZWxEYXRhLmxlbmd0aCAqIChkICsgMSlcclxuXHRcdFx0XHQpKTtcclxuXHRcdH1cclxuXHJcblx0XHRsZXZlbEVudGVyXHJcblx0XHRcdC5tZXJnZShsZXZlbClcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKCR7d2lkdGggLSBsZXZlbFJhdGlvW2RdfSwgJHtoZWlnaHQgLSBsZXZlbFJhdGlvW2RdfSlgKVxyXG5cdFx0XHQuc2VsZWN0QWxsKFwicG9seWdvblwiKVxyXG5cdFx0XHQuYXR0cihcInBvaW50c1wiLCBkID0+IHBvaW50c1tkXSk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGxldmVsIHRleHQgcG9zaXRpb25cclxuXHRcdGlmIChzaG93VGV4dCkge1xyXG5cdFx0XHRyYWRhckxldmVscy5zZWxlY3RBbGwoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsIGQgPT4gKGlzVW5kZWZpbmVkKGQpID8gd2lkdGggOiBwb2ludHNbZF0uc3BsaXQoXCIsXCIpWzBdKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgZCA9PiAoaXNVbmRlZmluZWQoZCkgPyBoZWlnaHQgOiAwKSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmFkYXJBeGVzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cdFx0Y29uc3QgY2F0ZWdvcmllcyA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcztcclxuXHJcblx0XHRsZXQgYXhpcyA9ICQkLnJhZGFycy5heGVzLnNlbGVjdEFsbChcImdcIilcclxuXHRcdFx0LmRhdGEoY2F0ZWdvcmllcyk7XHJcblxyXG5cdFx0YXhpcy5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Y29uc3QgYXhpc0VudGVyID0gYXhpcy5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MuYXhpc30tJHtpfWApO1xyXG5cclxuXHRcdGNvbmZpZy5yYWRhcl9heGlzX2xpbmVfc2hvdyAmJiBheGlzRW50ZXIuYXBwZW5kKFwibGluZVwiKTtcclxuXHRcdGNvbmZpZy5yYWRhcl9heGlzX3RleHRfc2hvdyAmJiBheGlzRW50ZXIuYXBwZW5kKFwidGV4dFwiKTtcclxuXHJcblx0XHRheGlzID0gYXhpc0VudGVyLm1lcmdlKGF4aXMpO1xyXG5cclxuXHRcdC8vIGF4aXMgbGluZVxyXG5cdFx0aWYgKGNvbmZpZy5yYWRhcl9heGlzX2xpbmVfc2hvdykge1xyXG5cdFx0XHRheGlzLnNlbGVjdChcImxpbmVcIilcclxuXHRcdFx0XHQuYXR0cihcIngxXCIsIHdpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwieTFcIiwgaGVpZ2h0KVxyXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgKGQsIGkpID0+ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ4XCIsIGkpKVxyXG5cdFx0XHRcdC5hdHRyKFwieTJcIiwgKGQsIGkpID0+ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ5XCIsIGkpKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBheGlzIHRleHRcclxuXHRcdGlmIChjb25maWcucmFkYXJfYXhpc190ZXh0X3Nob3cpIHtcclxuXHRcdFx0Y29uc3Qge3ggPSAwLCB5ID0gMH0gPSBjb25maWcucmFkYXJfYXhpc190ZXh0X3Bvc2l0aW9uO1xyXG5cclxuXHRcdFx0YXhpcy5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcclxuXHRcdFx0XHQuYXR0cihcImR5XCIsIFwiLjVlbVwiKVxyXG5cdFx0XHRcdC5jYWxsKHNlbGVjdGlvbiA9PiB7XHJcblx0XHRcdFx0XHRzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdHNldFRleHRWYWx1ZShkM1NlbGVjdCh0aGlzKSwgU3RyaW5nKGQpLCBbLTAuNiwgMS4yXSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5kYXR1bSgoZCwgaSkgPT4gKHtpbmRleDogaX0pKVxyXG5cdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh0aGlzLndpZHRoKSkge1xyXG5cdFx0XHRcdFx0XHQvLyBjYWNoZSBldmFsdWF0ZWQgYXhpcyB0ZXh0IHdpZHRoXHJcblx0XHRcdFx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gMjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRsZXQgcG9zWCA9ICQkLmdldFJhZGFyUG9zaXRpb24oXCJ4XCIsIGQuaW5kZXgsIHVuZGVmaW5lZCwgMSk7XHJcblx0XHRcdFx0XHRsZXQgcG9zWSA9IE1hdGgucm91bmQoJCQuZ2V0UmFkYXJQb3NpdGlvbihcInlcIiwgZC5pbmRleCwgdW5kZWZpbmVkLCAxKSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKHBvc1ggPiB3aWR0aCkge1xyXG5cdFx0XHRcdFx0XHRwb3NYICs9IHRoaXMud2lkdGggKyB4O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChNYXRoLnJvdW5kKHBvc1gpIDwgd2lkdGgpIHtcclxuXHRcdFx0XHRcdFx0cG9zWCAtPSB0aGlzLndpZHRoICsgeDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAocG9zWSA+IGhlaWdodCkge1xyXG5cdFx0XHRcdFx0XHQvLyB1cGRhdGUgdmVydGljYWwgY2VudGVyZWQgZWRnZSBheGlzIHRleHQgZHkgcG9zaXRpb25cclxuXHRcdFx0XHRcdFx0aWYgKHBvc1kgLyAyID09PSBoZWlnaHQgJiYgdGhpcy5maXJzdENoaWxkLnRhZ05hbWUgPT09IFwidHNwYW5cIikge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkeVwiLCBcIjBlbVwiKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0cG9zWSArPSB5O1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChwb3NZIDwgaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdHBvc1kgLT0geTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gYHRyYW5zbGF0ZSgke3Bvc1h9ICR7cG9zWX0pYDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5iaW5kRXZlbnQoKTtcclxuXHR9LFxyXG5cclxuXHRiaW5kRXZlbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2lucHV0VHlwZSwgdHJhbnNpdGluZ30sICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkKSB7XHJcblx0XHRcdGNvbnN0IGlzTW91c2UgPSBpbnB1dFR5cGUgPT09IFwibW91c2VcIjtcclxuXHRcdFx0Y29uc3QgZ2V0SW5kZXggPSAoKSA9PiB7XHJcblx0XHRcdFx0bGV0IHRhcmdldCA9IGQzRXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIG11bHRpbGluZWQgYXhpcyB0ZXh0XHJcblx0XHRcdFx0aWYgKC90c3Bhbi9pLnRlc3QodGFyZ2V0LnRhZ05hbWUpKSB7XHJcblx0XHRcdFx0XHR0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGQ6IGFueSA9IGQzU2VsZWN0KHRhcmdldCkuZGF0dW0oKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGQgJiYgT2JqZWN0LmtleXMoZCkubGVuZ3RoID09PSAxID8gZC5pbmRleCA6IHVuZGVmaW5lZDtcclxuXHRcdFx0fTtcclxuXHRcdFx0Y29uc3QgaGlkZSA9ICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KCk7XHJcblx0XHRcdFx0Y29uc3Qgbm9JbmRleCA9IGlzVW5kZWZpbmVkKGluZGV4KTtcclxuXHJcblx0XHRcdFx0aWYgKGlzTW91c2UgfHwgbm9JbmRleCkge1xyXG5cdFx0XHRcdFx0dGhpcy5oaWRlVG9vbHRpcCgpO1xyXG5cdFx0XHRcdFx0dGhpcy51bmV4cGFuZENpcmNsZXMoKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaXNNb3VzZSkge1xyXG5cdFx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGZhbHNlLCBpbmRleCk7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG5vSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0JCQuY2FsbE92ZXJPdXRGb3JUb3VjaCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdCQkLnJhZGFycy5zZWxlY3QoYC4ke0NMQVNTLmF4aXN9YClcclxuXHRcdFx0XHQub24oaXNNb3VzZSA/IFwibW91c2VvdmVyIFwiIDogXCJ0b3VjaHN0YXJ0XCIsICgpID0+IHtcclxuXHRcdFx0XHRcdGlmICh0cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBnZXRJbmRleCgpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnNlbGVjdFJlY3RGb3JTaW5nbGUoc3ZnLm5vZGUoKSwgbnVsbCwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0aXNNb3VzZSA/ICQkLnNldE92ZXJPdXQodHJ1ZSwgaW5kZXgpIDogJCQuY2FsbE92ZXJPdXRGb3JUb3VjaChpbmRleCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBpc01vdXNlID8gaGlkZSA6IG51bGwpO1xyXG5cclxuXHRcdFx0aWYgKCFpc01vdXNlKSB7XHJcblx0XHRcdFx0c3ZnLm9uKFwidG91Y2hzdGFydFwiLCBoaWRlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGFyU2hhcGUoZHVyYXRpb24sIGR1cmF0aW9uRm9yRXhpdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cztcclxuXHRcdGNvbnN0IHBvaW50cyA9ICQkLmNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG5cdFx0Y29uc3QgYXJlYXMgPSAkJC5yYWRhcnMuc2hhcGVzXHJcblx0XHRcdC5zZWxlY3RBbGwoXCJwb2x5Z29uXCIpXHJcblx0XHRcdC5kYXRhKHRhcmdldHMpO1xyXG5cclxuXHRcdGNvbnN0IGFyZWFzRW50ZXIgPSBhcmVhcy5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0NoYXJ0UmFkYXIuYmluZCgkJCkpO1xyXG5cclxuXHRcdGFyZWFzLmV4aXQoKS50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdGFyZWFzRW50ZXJcclxuXHRcdFx0LmFwcGVuZChcInBvbHlnb25cIilcclxuXHRcdFx0Lm1lcmdlKGFyZWFzKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGQgPT4gJCQuY29sb3IoZCkpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBkID0+ICQkLmNvbG9yKGQpKVxyXG5cdFx0XHQuYXR0cihcInBvaW50c1wiLCBkID0+IHBvaW50c1tkLmlkXS5qb2luKFwiIFwiKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgcG9pbnQgeCBjb29yZGluYXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyYWRhckNpcmNsZVgoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KVtkLmlkXVtkLmluZGV4XVswXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgZGF0YSBwb2ludCB5IGNvb3JkaW5hdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJhZGFyQ2lyY2xlWShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jYWNoZS5nZXQoY2FjaGVLZXkpW2QuaWRdW2QuaW5kZXhdWzFdO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogTW9kdWxlcyBleHBvcnRzIGZvciBBcmMgYmFzZWQgY2hhcnRcclxuICovXHJcbi8vIHNoYXBlXHJcbmltcG9ydCBhcmMgZnJvbSBcIi4uLy4uL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYXJjXCI7XHJcbmltcG9ydCByYWRhciBmcm9tIFwiLi4vLi4vQ2hhcnRJbnRlcm5hbC9zaGFwZS9yYWRhclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGludGVybmFsOiBbXHJcblx0XHRhcmMsXHJcblx0XHRyYWRhclxyXG5cdF1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7XHJcblx0dGltZVBhcnNlIGFzIGQzVGltZVBhcnNlLFxyXG5cdHRpbWVGb3JtYXQgYXMgZDNUaW1lRm9ybWF0LFxyXG5cdHV0Y1BhcnNlIGFzIGQzVXRjUGFyc2UsXHJcblx0dXRjRm9ybWF0IGFzIGQzVXRjRm9ybWF0XHJcbn0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7dHJhbnNpdGlvbiBhcyBkM1RyYW5zaXRpb259IGZyb20gXCJkMy10cmFuc2l0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IFN0b3JlIGZyb20gXCIuLi9jb25maWcvU3RvcmVcIjtcclxuaW1wb3J0IE9wdGlvbnMgZnJvbSBcIi4uL2NvbmZpZy9PcHRpb25zL09wdGlvbnNcIjtcclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENhY2hlIGZyb20gXCIuLi9tb2R1bGUvQ2FjaGVcIjtcclxuaW1wb3J0IHtleHRlbmQsIG5vdEVtcHR5LCBhc0hhbGZQaXhlbCwgZ2V0T3B0aW9uLCBpc0FycmF5LCBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nLCBpc1ZhbHVlLCBjYWxsRm4sIHNvcnRWYWx1ZX0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vLyBmb3IgVHlwZXNcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzL3R5cGVzXCI7XHJcblxyXG4vLyBBeGlzXHJcbmltcG9ydCBBeGlzIGZyb20gXCIuL0F4aXMvQXhpc1wiO1xyXG5cclxuLy8gZGF0YVxyXG5pbXBvcnQgZGF0YUNvbnZlcnQgZnJvbSBcIi4vZGF0YS9kYXRhLmNvbnZlcnRcIjtcclxuaW1wb3J0IGRhdGEgZnJvbSBcIi4vZGF0YS9kYXRhXCI7XHJcbmltcG9ydCBkYXRhTG9hZCBmcm9tIFwiLi9kYXRhL2RhdGEubG9hZFwiO1xyXG5cclxuLy8gaW50ZXJhY3Rpb25zXHJcbmltcG9ydCBpbnRlcmFjdGlvbiBmcm9tIFwiLi9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb25cIjtcclxuXHJcbi8vIGludGVybmFsc1xyXG5pbXBvcnQgY2xhc3NNb2R1bGUgZnJvbSBcIi4vaW50ZXJuYWxzL2NsYXNzXCI7XHJcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9pbnRlcm5hbHMvY29sb3JcIjtcclxuaW1wb3J0IGRvbWFpbiBmcm9tIFwiLi9pbnRlcm5hbHMvZG9tYWluXCI7XHJcbmltcG9ydCBmb3JtYXQgZnJvbSBcIi4vaW50ZXJuYWxzL2Zvcm1hdFwiO1xyXG5pbXBvcnQgbGVnZW5kIGZyb20gXCIuL2ludGVybmFscy9sZWdlbmRcIjtcclxuaW1wb3J0IHNjYWxlIGZyb20gXCIuL2ludGVybmFscy9zY2FsZVwiO1xyXG5pbXBvcnQgc2l6ZSBmcm9tIFwiLi9pbnRlcm5hbHMvc2l6ZVwiO1xyXG5pbXBvcnQgdGV4dCBmcm9tIFwiLi9pbnRlcm5hbHMvdGV4dFwiO1xyXG5pbXBvcnQgdGl0bGUgZnJvbSBcIi4vaW50ZXJuYWxzL3RpdGxlXCI7XHJcbmltcG9ydCB0b29sdGlwIGZyb20gXCIuL2ludGVybmFscy90b29sdGlwXCI7XHJcbmltcG9ydCB0eXBlIGZyb20gXCIuL2ludGVybmFscy90eXBlXCI7XHJcblxyXG5pbXBvcnQgbW9kdWxlQXhpcyBmcm9tIFwiLi4vY29uZmlnL3Jlc29sdmVyL2F4aXNcIjtcclxuaW1wb3J0IG1vZHVsZUFyYyBmcm9tIFwiLi4vY29uZmlnL3Jlc29sdmVyL2FyY1wiO1xyXG5cclxudHlwZSBOID0gZDNTZWxlY3Rpb258bnVsbDtcclxudHlwZSBGID0gRnVuY3Rpb258bnVsbDtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBjaGFydCBjbGFzcy5cclxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cclxuICogQGNsYXNzIENoYXJ0SW50ZXJuYWxcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnRJbnRlcm5hbCB7XHJcblx0cHVibGljIGFwaTtcdCAgIC8vIEFQSSBpbnRlcmZhY2VcclxuXHRwdWJsaWMgY29uZmlnOyAvLyBjb25maWcgb2JqZWN0XHJcblx0cHVibGljIGNhY2hlOyAgLy8gY2FjaGUgaW5zdGFuY2VcclxuXHRwdWJsaWMgc3RhdGU7ICAvLyBzdGF0ZSB2YXJpYWJsZXNcclxuXHRwdWJsaWMgY2hhcnRzOyAvLyBhbGwgQ2hhcnQgaW5zdGFuY2VzIGFycmF5IHdpdGhpbiBwYWdlIChlcXVpdmFsZW50IG9mICdiYi5pbnN0YW5jZXMnKVxyXG5cdHB1YmxpYyBpc0FyYyA9IGZhbHNlOyAvLyBpZiBpcyBBcmMgdHlwZSBjaGFydFxyXG5cclxuXHQvLyBkYXRhIG9iamVjdFxyXG5cdHB1YmxpYyBkYXRhID0ge1xyXG5cdFx0eHM6IHt9LFxyXG5cdFx0dGFyZ2V0czogW11cclxuXHR9O1xyXG5cclxuXHQvLyBzZWxlY3Rpb25zXHJcblx0cHVibGljICRlbDoge1xyXG5cdFx0W2tleTogc3RyaW5nXTogTiB8IHtba2V5OiBzdHJpbmddOiBOfVxyXG5cdH0gPSB7XHJcblx0XHRjaGFydDogbnVsbCxcclxuXHRcdG1haW46IG51bGwsXHJcblx0XHRzdmc6IG51bGwsXHJcblx0XHRheGlzOiB7ICAvLyBheGVzXHJcblx0XHRcdHg6IG51bGwsXHJcblx0XHRcdHk6IG51bGwsXHJcblx0XHRcdHkyOiBudWxsLFxyXG5cdFx0XHRzdWJYOiBudWxsXHJcblx0XHR9LFxyXG5cdFx0ZGVmczogbnVsbCxcclxuXHRcdHRvb2x0aXA6IG51bGwsXHJcblx0XHRsZWdlbmQ6IG51bGwsXHJcblx0XHR0aXRsZTogbnVsbCxcclxuXHRcdHN1YmNoYXJ0OiB7XHJcblx0XHRcdG1haW46IG51bGwsXHJcblx0XHRcdGJhcjogbnVsbCxcclxuXHRcdFx0bGluZTogbnVsbCxcclxuXHRcdFx0YXJlYTogbnVsbFxyXG5cdFx0fSxcclxuXHJcblx0XHRhcmNzOiBudWxsLFxyXG5cdFx0YmFyOiBudWxsLCAvL21haW5CYXIsXHJcblx0XHRsaW5lOiBudWxsLCAvL21haW5MaW5lLFxyXG5cdFx0YXJlYTogbnVsbCwgLy9tYWluQXJlYSxcclxuXHRcdGNpcmNsZTogbnVsbCwgLy9tYWluQ2lyY2xlLFxyXG5cdFx0dGV4dDogbnVsbCwgLy9tYWluVGV4dCxcclxuXHRcdGdyaWQ6IHtcclxuXHRcdFx0bWFpbjogbnVsbCwgIC8vIGdyaWQgKGFsc28gZm9jdXMpXHJcblx0XHRcdHg6IG51bGwsIC8vIHhncmlkLFxyXG5cdFx0XHR5OiBudWxsLCAvLyB5Z3JpZCxcclxuXHRcdH0sXHJcblx0XHRncmlkTGluZXM6IHtcclxuXHRcdFx0bWFpbjogbnVsbCwgIC8vIGdyaWRMaW5lc1xyXG5cdFx0XHR4OiBudWxsLCAvLyB4Z3JpZExpbmVzLFxyXG5cdFx0XHR5OiBudWxsLCAvLyB5Z3JpZExpbmVzXHJcblx0XHR9LFxyXG5cdFx0cmVnaW9uOiB7XHJcblx0XHRcdG1haW46IG51bGwsIC8vcmVnaW9uXHJcblx0XHRcdGxpc3Q6IG51bGwgLy8gbWFpblJlZ2lvblxyXG5cdFx0fSxcclxuXHRcdGV2ZW50UmVjdDogbnVsbFxyXG5cdH07XHJcblxyXG5cdC8vIEF4aXNcclxuXHRwdWJsaWMgYXhpczsgLy8gQXhpc1xyXG5cclxuXHQvLyBzY2FsZXNcclxuXHRwdWJsaWMgc2NhbGUgPSB7XHJcblx0XHR4OiBudWxsLFxyXG5cdFx0eTogbnVsbCxcclxuXHRcdHkyOiBudWxsLFxyXG5cdFx0c3ViWDogbnVsbCxcclxuXHRcdHN1Ylk6IG51bGwsXHJcblx0XHRzdWJZMjogbnVsbCxcclxuXHRcdHpvb206IG51bGxcclxuXHR9XHJcblxyXG5cdC8vIG9yaWdpbmFsIHZhbHVlc1xyXG5cdHB1YmxpYyBvcmcgPSB7XHJcblx0XHR4U2NhbGU6IG51bGwsXHJcblx0XHR4RG9tYWluOiBudWxsXHJcblx0fTtcclxuXHJcblx0Ly8gZm9ybWF0dGVyIGZ1bmN0aW9uXHJcblx0cHVibGljIGNvbG9yO1xyXG5cdHB1YmxpYyBwYXR0ZXJucztcclxuXHRwdWJsaWMgbGV2ZWxDb2xvcjtcclxuXHRwdWJsaWMgcG9pbnQ7XHJcblx0cHVibGljIGJydXNoO1xyXG5cclxuXHQvLyBmb3JtYXQgZnVuY3Rpb25cclxuXHRwdWJsaWMgZm9ybWF0ID0ge1xyXG5cdFx0ZXh0cmFMaW5lQ2xhc3NlczogbnVsbCxcclxuXHRcdHhBeGlzVGljazogbnVsbCxcclxuXHRcdGRhdGFUaW1lOiBudWxsLCAvLyBkYXRhVGltZUZvcm1hdFxyXG5cdFx0ZGVmYXVsdEF4aXNUaW1lOiBudWxsLCAvLyBkZWZhdWx0QXhpc1RpbWVGb3JtYXRcclxuXHRcdGF4aXNUaW1lOiBudWxsIC8vIGF4aXNUaW1lRm9ybWF0XHJcblx0fTtcclxuXHJcblx0cHVibGljIGlzQXhpcztcclxuXHJcblx0Y29uc3RydWN0b3IoYXBpKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuYXBpID0gYXBpO1xyXG5cdFx0JCQuY29uZmlnID0gbmV3IE9wdGlvbnMoKTtcclxuXHRcdCQkLmNhY2hlID0gbmV3IENhY2hlKCk7XHJcblx0XHQkJC5zdGF0ZSA9IG5ldyBTdG9yZSgpOyAvLyBzdGF0dXMgdmFyaWFibGVzXHJcblx0fVxyXG5cclxuXHRiZWZvcmVJbml0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGJlZm9yZUluaXRcIik7XHJcblxyXG5cdFx0Ly8gY2FuIGRvIHNvbWV0aGluZ1xyXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmJlZm9yZWluaXQsICQkLCAkJC5hcGkpO1xyXG5cdH1cclxuXHJcblx0YWZ0ZXJJbml0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJGFmdGVySW5pdFwiKTtcclxuXHJcblx0XHQvLyBjYW4gZG8gc29tZXRoaW5nXHJcblx0XHRjYWxsRm4oJCQuY29uZmlnLm9uYWZ0ZXJpbml0LCAkJCwgJCQuYXBpKTtcclxuXHR9XHJcblxyXG5cdGluaXQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0JCQuaXNBeGlzID0gISQkLmhhc0FyY1R5cGUoKTtcclxuXHRcdCQkLmluaXRQYXJhbXMoKTtcclxuXHJcblx0XHRjb25zdCBiaW5kdG8gPSB7XHJcblx0XHRcdGVsZW1lbnQ6IGNvbmZpZy5iaW5kdG8sXHJcblx0XHRcdGNsYXNzbmFtZTogXCJiYlwiXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb25maWcuYmluZHRvKSkge1xyXG5cdFx0XHRiaW5kdG8uZWxlbWVudCA9IGNvbmZpZy5iaW5kdG8uZWxlbWVudCB8fCBcIiNjaGFydFwiO1xyXG5cdFx0XHRiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgYmluZCBlbGVtZW50XHJcblx0XHQkZWwuY2hhcnQgPSBpc0Z1bmN0aW9uKGJpbmR0by5lbGVtZW50Lm5vZGUpID9cclxuXHRcdFx0Y29uZmlnLmJpbmR0by5lbGVtZW50IDogZDNTZWxlY3QoYmluZHRvLmVsZW1lbnQgfHwgW10pO1xyXG5cclxuXHRcdGlmICgkZWwuY2hhcnQuZW1wdHkoKSkge1xyXG5cdFx0XHQkZWwuY2hhcnQgPSBkM1NlbGVjdChkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuY2hhcnQuaHRtbChcIlwiKS5jbGFzc2VkKGJpbmR0by5jbGFzc25hbWUsIHRydWUpO1xyXG5cclxuXHRcdCQkLmluaXRUb1JlbmRlcigpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3NcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlZCBGb3JjZSB0byByZW5kZXIgcHJvY2Vzc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFRvUmVuZGVyKGZvcmNlZD86IGJvb2xlYW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc0hpZGRlbiA9ICgpID0+IGNoYXJ0LnN0eWxlKFwiZGlzcGxheVwiKSA9PT0gXCJub25lXCIgfHwgY2hhcnQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiO1xyXG5cclxuXHRcdGNvbnN0IGlzTGF6eSA9IGNvbmZpZy5yZW5kZXIubGF6eSB8fCBpc0hpZGRlbigpO1xyXG5cdFx0Y29uc3QgTXV0YXRpb25PYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyO1xyXG5cclxuXHRcdGlmIChpc0xhenkgJiYgTXV0YXRpb25PYnNlcnZlciAmJiBjb25maWcucmVuZGVyLm9ic2VydmUgIT09IGZhbHNlICYmICFmb3JjZWQpIHtcclxuXHRcdFx0bmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9uLCBvYnNlcnZlcikgPT4ge1xyXG5cdFx0XHRcdGlmICghaXNIaWRkZW4oKSkge1xyXG5cdFx0XHRcdFx0b2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG5cdFx0XHRcdFx0IXN0YXRlLnJlbmRlcmVkICYmICQkLmluaXRUb1JlbmRlcih0cnVlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pLm9ic2VydmUoY2hhcnQubm9kZSgpLCB7XHJcblx0XHRcdFx0YXR0cmlidXRlczogdHJ1ZSxcclxuXHRcdFx0XHRhdHRyaWJ1dGVGaWx0ZXI6IFtcImNsYXNzXCIsIFwic3R5bGVcIl1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFpc0xhenkgfHwgZm9yY2VkKSB7XHJcblx0XHRcdGNvbnN0IGNvbnZlcnRlZERhdGEgPSAkJC5jb252ZXJ0RGF0YShjb25maWcsICQkLmluaXRXaXRoRGF0YSk7XHJcblxyXG5cdFx0XHRjb252ZXJ0ZWREYXRhICYmICQkLmluaXRXaXRoRGF0YShjb252ZXJ0ZWREYXRhKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGluaXRQYXJhbXMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBmb3JtYXQsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBkYXRldGltZSB0byBiZSB1c2VkIGZvciB1bmlxdWVuZXNzXHJcblx0XHRzdGF0ZS5kYXRldGltZUlkID0gYGJiLSR7K25ldyBEYXRlKCl9YDtcclxuXHJcblx0XHQkJC5jb2xvciA9ICQkLmdlbmVyYXRlQ29sb3IoKTtcclxuXHRcdCQkLmxldmVsQ29sb3IgPSAkJC5nZW5lcmF0ZUxldmVsQ29sb3IoKTtcclxuXHJcblx0XHQvL0BUT0RPOkF4aXMgJiBSYWRhclxyXG5cdFx0aWYgKCQkLmlzQXhpcyB8fCAkJC5oYXNUeXBlKFwicmFkYXJcIikpIHtcclxuXHRcdFx0JCQucG9pbnQgPSAkJC5nZW5lcmF0ZVBvaW50KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCQkLmlzQXhpcykge1xyXG5cdFx0XHQkJC5pbml0Q2xpcCgpO1xyXG4vL1x0XHRcdCQkLnBvaW50ID0gJCQuZ2VuZXJhdGVQb2ludCgpO1xyXG5cclxuXHRcdFx0Zm9ybWF0LmV4dHJhTGluZUNsYXNzZXMgPSAkJC5nZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCk7XHJcblx0XHRcdGZvcm1hdC5kYXRhVGltZSA9IGNvbmZpZy5kYXRhX3hMb2NhbHRpbWUgPyBkM1RpbWVQYXJzZSA6IGQzVXRjUGFyc2U7XHJcblx0XHRcdGZvcm1hdC5heGlzVGltZSA9IGNvbmZpZy5heGlzX3hfbG9jYWx0aW1lID8gZDNUaW1lRm9ybWF0IDogZDNVdGNGb3JtYXQ7XHJcblxyXG5cdFx0XHRjb25zdCBpc0RyYWdab29tID0gJCQuY29uZmlnLnpvb21fZW5hYmxlZCAmJiAkJC5jb25maWcuem9vbV9lbmFibGVkLnR5cGUgPT09IFwiZHJhZ1wiO1xyXG5cclxuXHRcdFx0Zm9ybWF0LmRlZmF1bHRBeGlzVGltZSA9IGQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHt4LCB6b29tfSA9ICQkLnNjYWxlO1xyXG5cdFx0XHRcdGNvbnN0IGlzWm9vbWVkID0gaXNEcmFnWm9vbSA/IHpvb20gOlxyXG5cdFx0XHRcdFx0em9vbSAmJiB4Lm9yZ0RvbWFpbigpLnRvU3RyaW5nKCkgIT09IHpvb20uZG9tYWluKCkudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdFx0Y29uc3Qgc3BlY2lmaWVyOiBzdHJpbmcgPSAoZC5nZXRNaWxsaXNlY29uZHMoKSAmJiBcIi4lTFwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0U2Vjb25kcygpICYmIFwiLjolU1wiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0TWludXRlcygpICYmIFwiJUk6JU1cIikgfHxcclxuXHRcdFx0XHRcdChkLmdldEhvdXJzKCkgJiYgXCIlSSAlcFwiKSB8fFxyXG5cdFx0XHRcdFx0KGQuZ2V0RGF0ZSgpICE9PSAxICYmIFwiJWIgJWRcIikgfHxcclxuXHRcdFx0XHRcdChpc1pvb21lZCAmJiBkLmdldERhdGUoKSA9PT0gMSAmJiBcIiViXFwnJXlcIikgfHxcclxuXHRcdFx0XHRcdChkLmdldE1vbnRoKCkgJiYgXCIlLW0vJS1kXCIpIHx8IFwiJVlcIjtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZvcm1hdC5heGlzVGltZShzcGVjaWZpZXIpKGQpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmlzTGVnZW5kUmlnaHQgPSBjb25maWcubGVnZW5kX3Bvc2l0aW9uID09PSBcInJpZ2h0XCI7XHJcblx0XHRzdGF0ZS5pc0xlZ2VuZEluc2V0ID0gY29uZmlnLmxlZ2VuZF9wb3NpdGlvbiA9PT0gXCJpbnNldFwiO1xyXG5cclxuXHRcdHN0YXRlLmlzTGVnZW5kVG9wID0gY29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwidG9wLWxlZnRcIiB8fFxyXG5cdFx0XHRjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtcmlnaHRcIjtcclxuXHRcdHN0YXRlLmlzTGVnZW5kTGVmdCA9IGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1sZWZ0XCIgfHxcclxuXHRcdFx0Y29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwiYm90dG9tLWxlZnRcIjtcclxuXHJcblx0XHRzdGF0ZS5yb3RhdGVkUGFkZGluZ1JpZ2h0ID0gaXNSb3RhdGVkICYmICFjb25maWcuYXhpc194X3Nob3cgPyAwIDogMzA7XHJcblx0XHRzdGF0ZS5pbnB1dFR5cGUgPSAkJC5jb252ZXJ0SW5wdXRUeXBlKCk7XHJcblx0fVxyXG5cclxuXHRpbml0V2l0aERhdGEoZGF0YSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRjb25maWcsIHN0YXRlLCAkZWwsXHJcblx0XHRcdHNjYWxlOiB7XHJcblx0XHRcdFx0eCwgeSwgeTIsIHN1YlgsIHN1YlksIHN1YlkyXHJcblx0XHRcdH0sXHJcblx0XHRcdG9yZ1xyXG5cdFx0fSA9ICQkO1xyXG5cclxuXHRcdC8vIGZvciBhcmMgdHlwZSwgc2V0IGF4ZXMgdG8gbm90IGJlIHNob3duXHJcblx0XHQvLyAkJC5oYXNBcmNUeXBlKCkgJiYgW1wieFwiLCBcInlcIiwgXCJ5MlwiXS5mb3JFYWNoKGlkID0+IChjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdID0gZmFsc2UpKTtcclxuXHJcblx0XHRpZiAoJCQuaXNBeGlzKSB7XHJcblx0XHRcdCQkLmF4aXMgPSBuZXcgQXhpcygkJCk7XHJcblx0XHRcdGNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuaW5pdFpvb20oKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJbml0IGRhdGEgYXMgdGFyZ2V0c1xyXG5cdFx0JCQuZGF0YS54cyA9IHt9O1xyXG5cdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2ZpbHRlcikge1xyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKGNvbmZpZy5kYXRhX2ZpbHRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IHRhcmdldHMgdG8gaGlkZSBpZiBuZWVkZWRcclxuXHRcdGlmIChjb25maWcuZGF0YV9oaWRlKSB7XHJcblx0XHRcdCQkLmFkZEhpZGRlblRhcmdldElkcyhcclxuXHRcdFx0XHRjb25maWcuZGF0YV9oaWRlID09PSB0cnVlID9cclxuXHRcdFx0XHRcdCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cykgOiBjb25maWcuZGF0YV9oaWRlXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9oaWRlKSB7XHJcblx0XHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyhcclxuXHRcdFx0XHRjb25maWcubGVnZW5kX2hpZGUgPT09IHRydWUgP1xyXG5cdFx0XHRcdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSA6IGNvbmZpZy5sZWdlbmRfaGlkZVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluaXQgc2l6ZXMgYW5kIHNjYWxlc1xyXG5cdFx0JCQudXBkYXRlU2l6ZXMoKTtcclxuXHRcdCQkLnVwZGF0ZVNjYWxlcyh0cnVlKTtcclxuXHJcblx0XHQvLyBTZXQgZG9tYWlucyBmb3IgZWFjaCBzY2FsZVxyXG5cdFx0aWYgKHgpIHtcclxuXHRcdFx0eC5kb21haW4oc29ydFZhbHVlKCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSkpO1xyXG5cdFx0XHRzdWJYLmRvbWFpbih4LmRvbWFpbigpKTtcclxuXHJcblx0XHRcdC8vIFNhdmUgb3JpZ2luYWwgeCBkb21haW4gZm9yIHpvb20gdXBkYXRlXHJcblx0XHRcdG9yZy54RG9tYWluID0geC5kb21haW4oKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoeSkge1xyXG5cdFx0XHR5LmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5XCIpKTtcclxuXHRcdFx0c3ViWS5kb21haW4oeS5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHkyKSB7XHJcblx0XHRcdHkyLmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5MlwiKSk7XHJcblx0XHRcdHN1YlkyICYmIHN1YlkyLmRvbWFpbih5Mi5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gLS0gQmFzaWMgRWxlbWVudHMgLS1cclxuXHRcdCRlbC5zdmcgPSAkZWwuY2hhcnQuYXBwZW5kKFwic3ZnXCIpXHJcblx0XHRcdC5zdHlsZShcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpXHJcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgc3RhdGUuaW5wdXRUeXBlKSB7XHJcblx0XHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHJcblx0XHRcdCRlbC5zdmdcclxuXHRcdFx0XHQub24oaXNUb3VjaCA/IFwidG91Y2hzdGFydFwiIDogXCJtb3VzZWVudGVyXCIsICgpID0+IGNhbGxGbihjb25maWcub25vdmVyLCAkJCwgJCQuYXBpKSlcclxuXHRcdFx0XHQub24oaXNUb3VjaCA/IFwidG91Y2hlbmRcIiA6IFwibW91c2VsZWF2ZVwiLCAoKSA9PiBjYWxsRm4oY29uZmlnLm9ub3V0LCAkJCwgJCQuYXBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnN2Z19jbGFzc25hbWUgJiYgJGVsLnN2Zy5hdHRyKFwiY2xhc3NcIiwgY29uZmlnLnN2Z19jbGFzc25hbWUpO1xyXG5cclxuXHRcdC8vIERlZmluZSBkZWZzXHJcblx0XHRpZiAoJCQuaXNBeGlzKSB7XHJcblx0XHRcdCRlbC5kZWZzID0gJGVsLnN2Zy5hcHBlbmQoXCJkZWZzXCIpO1xyXG5cclxuXHRcdFx0JCQuYXBwZW5kQ2xpcCgkZWwuZGVmcywgc3RhdGUuY2xpcC5pZCk7XHJcblx0XHRcdCQkLmFwcGVuZENsaXAoJGVsLmRlZnMsIHN0YXRlLmNsaXAuaWRYQXhpcyk7XHJcblx0XHRcdCQkLmFwcGVuZENsaXAoJGVsLmRlZnMsIHN0YXRlLmNsaXBZQXhpcyk7XHJcblx0XHRcdCQkLmFwcGVuZENsaXAoJGVsLmRlZnMsIHN0YXRlLmNsaXAuaWRHcmlkKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgY29sb3IgcGF0dGVybnNcclxuXHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5jb2xvcl90aWxlcykgJiYgJCQucGF0dGVybnMpIHtcclxuXHRcdFx0JCQucGF0dGVybnMuZm9yRWFjaChwID0+ICRlbC5kZWZzLmFwcGVuZCgoKSA9PiBwLm5vZGUpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIHJlZ2lvbnNcclxuXHRcdGNvbnN0IG1haW4gPSAkZWwuc3ZnLmFwcGVuZChcImdcIikuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcclxuXHJcblx0XHQkZWwubWFpbiA9IG1haW47XHJcblxyXG5cdFx0Ly8gaW5pdGlhbGl6ZSBzdWJjaGFydCB3aGVuIHN1YmNoYXJ0IHNob3cgb3B0aW9uIGlzIHNldFxyXG5cdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQuaW5pdFN1YmNoYXJ0KCk7XHJcblxyXG5cdFx0JCQuaW5pdFRvb2x0aXAgJiYgJCQuaW5pdFRvb2x0aXAoKTtcclxuXHRcdCQkLmluaXRMZWdlbmQgJiYgJCQuaW5pdExlZ2VuZCgpO1xyXG5cdFx0JCQuaW5pdFRpdGxlICYmICQkLmluaXRUaXRsZSgpO1xyXG5cclxuXHRcdC8vIC0tIE1haW4gUmVnaW9uIC0tXHJcblxyXG5cdFx0Ly8gdGV4dCB3aGVuIGVtcHR5XHJcblx0XHRpZiAoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dCkge1xyXG5cdFx0XHRtYWluLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGAke0NMQVNTLnRleHR9ICR7Q0xBU1MuZW1wdHl9YClcclxuXHRcdFx0XHQuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpIC8vIGhvcml6b250YWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeCBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMuXHJcblx0XHRcdFx0LmF0dHIoXCJkb21pbmFudC1iYXNlbGluZVwiLCBcIm1pZGRsZVwiKTsgLy8gdmVydGljYWwgY2VudGVyaW5nIG9mIHRleHQgYXQgeSBwb3NpdGlvbiBpbiBhbGwgYnJvd3NlcnMsIGV4Y2VwdCBJRS5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJCQuaXNBeGlzKSB7XHJcblx0XHRcdC8vIFJlZ2lvbnNcclxuXHRcdFx0JCQuaW5pdFJlZ2lvbiAmJiAkJC5pbml0UmVnaW9uKCk7XHJcblxyXG5cdFx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICdmYWxzZSdcclxuXHRcdFx0IWNvbmZpZy5jbGlwUGF0aCAmJiAkJC5heGlzLmluaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnQgYXJlYVxyXG5cdFx0bWFpbi5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydClcclxuXHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgc3RhdGUuY2xpcC5wYXRoKTtcclxuXHJcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRpbml0XCIpO1xyXG5cclxuXHRcdGlmICgkJC5pc0F4aXMpIHtcclxuXHRcdFx0Ly8gQ292ZXIgd2hvbGUgd2l0aCByZWN0cyBmb3IgZXZlbnRzXHJcblx0XHRcdCQkLmluaXRFdmVudFJlY3QgJiYgJCQuaW5pdEV2ZW50UmVjdCgpO1xyXG5cclxuXHRcdFx0Ly8gR3JpZHNcclxuXHRcdFx0JCQuaW5pdEdyaWQgJiYgJCQuaW5pdEdyaWQoKTtcclxuXHJcblx0XHRcdC8vIGlmIHpvb20gcHJpdmlsZWdlZCwgaW5zZXJ0IHJlY3QgdG8gZm9yZWZyb250XHJcblx0XHRcdC8vIFRPRE86IGlzIHRoaXMgbmVlZGVkP1xyXG5cdFx0XHRpZiAoJCQuaXNBeGlzKSB7XHJcblx0XHRcdFx0bWFpbi5pbnNlcnQoXCJyZWN0XCIsIGNvbmZpZy56b29tX3ByaXZpbGVnZWQgPyBudWxsIDogYGcuJHtDTEFTUy5yZWdpb25zfWApXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnpvb21SZWN0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5zdGF0ZS53aWR0aClcclxuXHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLnN0YXRlLmhlaWdodClcclxuXHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdFx0XHQub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICd0cnVlJ1xyXG5cdFx0XHRjb25maWcuY2xpcFBhdGggJiYgJCQuYXhpcyAmJiAkJC5heGlzLmluaXQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5pbml0Q2hhcnRFbGVtZW50cygpO1xyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gRHJhdyB3aXRoIHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZURpbWVuc2lvbigpO1xyXG5cclxuXHRcdC8vIG9uaW5pdCBjYWxsYmFja1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy5vbmluaXQsICQkLCAkJC5hcGkpO1xyXG5cclxuXHRcdC8vIFNldCBiYWNrZ3JvdW5kXHJcblx0XHQkJC5zZXRCYWNrZ3JvdW5kKCk7XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoVHJhbnNmb3JtOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yQXhpczogZmFsc2UsXHJcblx0XHRcdGluaXRpYWxpemluZzogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gZGF0YS5vbm1pbi9tYXggY2FsbGJhY2tcclxuXHRcdGlmIChjb25maWcuZGF0YV9vbm1pbiB8fCBjb25maWcuZGF0YV9vbm1heCkge1xyXG5cdFx0XHRjb25zdCBtaW5NYXggPSAkJC5nZXRNaW5NYXhEYXRhKCk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25taW4sICQkLCBtaW5NYXgubWluKTtcclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29ubWF4LCAkJCwgbWluTWF4Lm1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQmluZCByZXNpemUgZXZlbnRcclxuXHRcdCQkLmJpbmRSZXNpemUoKTtcclxuXHJcblx0XHQvLyBleHBvcnQgZWxlbWVudCBvZiB0aGUgY2hhcnRcclxuXHRcdCQkLmFwaS5lbGVtZW50ID0gJGVsLmNoYXJ0Lm5vZGUoKTtcclxuXHJcblx0XHRzdGF0ZS5yZW5kZXJlZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRpbml0Q2hhcnRFbGVtZW50cygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHR5cGVzID0gJCQuaXNBeGlzID8gW1wiQmFyXCIsIFwiQnViYmxlXCIsIFwiTGluZVwiXSA6XHJcblx0XHRcdFtcIkFyY1wiLCBcIkdhdWdlXCIsIFwiUGllXCIsIFwiUmFkYXJcIl07XHJcblxyXG5cdFx0dHlwZXMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0JCRbYGluaXQke3Z9YF0oKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdG5vdEVtcHR5KCQkLmNvbmZpZy5kYXRhX2xhYmVscykgJiYgJCQuaW5pdFRleHQoKTtcclxuXHR9XHJcblxyXG5cdHNldENoYXJ0RWxlbWVudHMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLmFwaS4kID0ge1xyXG5cdFx0XHRjaGFydDogJGVsLmNoYXJ0LFxyXG5cdFx0XHRzdmc6ICRlbC5zdmcsXHJcblx0XHRcdGRlZnM6ICRlbC5kZWZzLFxyXG5cdFx0XHRtYWluOiAkZWwubWFpbixcclxuXHRcdFx0dG9vbHRpcDogJGVsLnRvb2x0aXAsXHJcblx0XHRcdGxlZ2VuZDogJGVsLmxlZ2VuZCxcclxuXHRcdFx0dGl0bGU6ICRlbC50aXRsZSxcclxuXHRcdFx0Z3JpZDogJGVsLmdyaWQsXHJcblx0XHRcdGFyYzogJGVsLmFyY3MsXHJcblx0XHRcdGJhcjoge1xyXG5cdFx0XHRcdGJhcnM6ICRlbC5iYXJcclxuXHRcdFx0fSxcclxuXHRcdFx0bGluZToge1xyXG5cdFx0XHRcdGxpbmVzOiAkZWwubGluZSxcclxuXHRcdFx0XHRhcmVhczogJGVsLmFyZWEsXHJcblx0XHRcdFx0Y2lyY2xlczogJGVsLmNpcmNsZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHR0ZXh0OiB7XHJcblx0XHRcdFx0dGV4dHM6ICRlbC50ZXh0XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYmFja2dyb3VuZCBlbGVtZW50L2ltYWdlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRCYWNrZ3JvdW5kKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZzoge2JhY2tncm91bmQ6IGJnfSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHJcblx0XHRpZiAobm90RW1wdHkoYmcpKSB7XHJcblx0XHRcdGNvbnN0IGVsZW1lbnQgPSBzdmcuc2VsZWN0KGAuJHtDTEFTU1skJC5oYXNBcmNUeXBlKCkgPyBcImNoYXJ0XCIgOiBcInJlZ2lvbnNcIl19YClcclxuXHRcdFx0XHQuaW5zZXJ0KGJnLmltZ1VybCA/IFwiaW1hZ2VcIiA6IFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKTtcclxuXHJcblx0XHRcdGlmIChiZy5pbWdVcmwpIHtcclxuXHRcdFx0XHRlbGVtZW50LmF0dHIoXCJocmVmXCIsIGJnLmltZ1VybCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoYmcuY29sb3IpIHtcclxuXHRcdFx0XHRlbGVtZW50LnN0eWxlKFwiZmlsbFwiLCBiZy5jb2xvcik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGVsZW1lbnRcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGJnLmNsYXNzIHx8IG51bGwpXHJcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBcIjEwMCVcIilcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCBcIjEwMCVcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRzbW9vdGhMaW5lcyhlbCwgdHlwZSkge1xyXG5cdFx0aWYgKHR5cGUgPT09IFwiZ3JpZFwiKSB7XHJcblx0XHRcdGVsLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgZyA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRbXCJ4MVwiLCBcIngyXCIsIFwieTFcIiwgXCJ5MlwiXVxyXG5cdFx0XHRcdFx0LmZvckVhY2godiA9PiBnLmF0dHIodiwgTWF0aC5jZWlsKCtnLmF0dHIodikpKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIHNpemUgdmFsdWVzXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0luaXQgSWYgaXMgY2FsbGVkIGF0IGluaXRpYWxpemF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVTaXplcyhpc0luaXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcclxuXHJcblx0XHRjb25zdCBjdXJyTGVnZW5kID0ge1xyXG5cdFx0XHR3aWR0aDogbGVnZW5kID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSA6IDAsXHJcblx0XHRcdGhlaWdodDogbGVnZW5kID8gJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgOiAwXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGxlZ2VuZEhlaWdodEZvckJvdHRvbSA9IHN0YXRlLmlzTGVnZW5kUmlnaHQgfHwgc3RhdGUuaXNMZWdlbmRJbnNldCA/IDAgOiBjdXJyTGVnZW5kLmhlaWdodDtcclxuXHRcdGNvbnN0IHhBeGlzSGVpZ2h0ID0gaXNSb3RhdGVkIHx8IGhhc0FyYyA/IDAgOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInhcIik7XHJcblxyXG5cdFx0Y29uc3Qgc3ViY2hhcnRYQXhpc0hlaWdodCA9IGNvbmZpZy5zdWJjaGFydF9heGlzX3hfc2hvdyAmJiBjb25maWcuc3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93ID9cclxuXHRcdFx0eEF4aXNIZWlnaHQgOiAzMDtcclxuXHRcdGNvbnN0IHN1YmNoYXJ0SGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgIWhhc0FyYyA/XHJcblx0XHRcdChjb25maWcuc3ViY2hhcnRfc2l6ZV9oZWlnaHQgKyBzdWJjaGFydFhBeGlzSGVpZ2h0KSA6IDA7XHJcblxyXG5cdFx0IWlzSW5pdCAmJiAkJC5zZXRDb250YWluZXJTaXplKCk7XHJcblxyXG5cdFx0Ly8gZm9yIG1haW5cclxuXHRcdHN0YXRlLm1hcmdpbiA9IGlzUm90YXRlZCA/IHtcclxuXHRcdFx0dG9wOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInkyXCIpICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSxcclxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXHJcblx0XHRcdGJvdHRvbTogJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoXCJ5XCIpICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20oKSxcclxuXHRcdFx0bGVmdDogc3ViY2hhcnRIZWlnaHQgKyAoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpKVxyXG5cdFx0fSA6IHtcclxuXHRcdFx0dG9wOiA0ICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSwgLy8gZm9yIHRvcCB0aWNrIHRleHRcclxuXHRcdFx0cmlnaHQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCksXHJcblx0XHRcdGJvdHRvbTogeEF4aXNIZWlnaHQgKyBzdWJjaGFydEhlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSArICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCksXHJcblx0XHRcdGxlZnQ6IGhhc0FyYyA/IDAgOiAkJC5nZXRDdXJyZW50UGFkZGluZ0xlZnQoKVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmb3Igc3ViY2hhcnRcclxuXHRcdHN0YXRlLm1hcmdpbjIgPSBpc1JvdGF0ZWQgPyB7XHJcblx0XHRcdHRvcDogc3RhdGUubWFyZ2luLnRvcCxcclxuXHRcdFx0cmlnaHQ6IE5hTixcclxuXHRcdFx0Ym90dG9tOiAyMCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcclxuXHRcdFx0bGVmdDogJCQuc3RhdGUucm90YXRlZFBhZGRpbmcubGVmdFxyXG5cdFx0fSA6IHtcclxuXHRcdFx0dG9wOiBzdGF0ZS5jdXJyZW50SGVpZ2h0IC0gc3ViY2hhcnRIZWlnaHQgLSBsZWdlbmRIZWlnaHRGb3JCb3R0b20sXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogc3ViY2hhcnRYQXhpc0hlaWdodCArIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcclxuXHRcdFx0bGVmdDogc3RhdGUubWFyZ2luLmxlZnRcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gZm9yIGxlZ2VuZFxyXG5cdFx0c3RhdGUubWFyZ2luMyA9IHtcclxuXHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRyaWdodDogTmFOLFxyXG5cdFx0XHRib3R0b206IDAsXHJcblx0XHRcdGxlZnQ6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0JCQudXBkYXRlU2l6ZUZvckxlZ2VuZCAmJiAkJC51cGRhdGVTaXplRm9yTGVnZW5kKGN1cnJMZWdlbmQpO1xyXG5cclxuXHRcdHN0YXRlLndpZHRoID0gc3RhdGUuY3VycmVudFdpZHRoIC0gc3RhdGUubWFyZ2luLmxlZnQgLSBzdGF0ZS5tYXJnaW4ucmlnaHQ7XHJcblx0XHRzdGF0ZS5oZWlnaHQgPSBzdGF0ZS5jdXJyZW50SGVpZ2h0IC0gc3RhdGUubWFyZ2luLnRvcCAtIHN0YXRlLm1hcmdpbi5ib3R0b207XHJcblxyXG5cdFx0aWYgKHN0YXRlLndpZHRoIDwgMCkge1xyXG5cdFx0XHRzdGF0ZS53aWR0aCA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXRlLmhlaWdodCA8IDApIHtcclxuXHRcdFx0c3RhdGUuaGVpZ2h0ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRzdGF0ZS53aWR0aDIgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRzdGF0ZS5tYXJnaW4ubGVmdCAtIHN0YXRlLnJvdGF0ZWRQYWRkaW5nLmxlZnQgLSBzdGF0ZS5yb3RhdGVkUGFkZGluZy5yaWdodCA6IHN0YXRlLndpZHRoO1xyXG5cclxuXHRcdHN0YXRlLmhlaWdodDIgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRzdGF0ZS5oZWlnaHQgOiBzdGF0ZS5jdXJyZW50SGVpZ2h0IC0gc3RhdGUubWFyZ2luMi50b3AgLSBzdGF0ZS5tYXJnaW4yLmJvdHRvbTtcclxuXHJcblx0XHRpZiAoc3RhdGUud2lkdGgyIDwgMCkge1xyXG5cdFx0XHRzdGF0ZS53aWR0aDIgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5oZWlnaHQyIDwgMCkge1xyXG5cdFx0XHRzdGF0ZS5oZWlnaHQyID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgYXJjXHJcblx0XHRzdGF0ZS5hcmNXaWR0aCA9IHN0YXRlLndpZHRoIC0gKHN0YXRlLmlzTGVnZW5kUmlnaHQgPyBjdXJyTGVnZW5kLndpZHRoICsgMTAgOiAwKTtcclxuXHRcdHN0YXRlLmFyY0hlaWdodCA9IHN0YXRlLmhlaWdodCAtIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0ID8gMCA6IDEwKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmICFjb25maWcuZ2F1Z2VfZnVsbENpcmNsZSkge1xyXG5cdFx0XHRzdGF0ZS5hcmNIZWlnaHQgKz0gc3RhdGUuaGVpZ2h0IC0gJCQuZ2V0R2F1Z2VMYWJlbEhlaWdodCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnVwZGF0ZVJhZGl1cyAmJiAkJC51cGRhdGVSYWRpdXMoKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRSaWdodCAmJiBoYXNBcmMpIHtcclxuXHRcdFx0c3RhdGUubWFyZ2luMy5sZWZ0ID0gc3RhdGUuYXJjV2lkdGggLyAyICsgc3RhdGUucmFkaXVzRXhwYW5kZWQgKiAxLjE7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGFyZ2V0ZWQgZWxlbWVudCB3aXRoIGdpdmVuIGRhdGFcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0cyBEYXRhIG9iamVjdCBmb3JtYXR0ZWQgYXMgJ3RhcmdldCdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVRhcmdldHModGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdC8vIFRleHRcclxuXHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JUZXh0KHRhcmdldHMpO1xyXG5cclxuXHRcdGlmICgkJC5pc0F4aXMpIHtcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0c0ZvckJhcih0YXJnZXRzKTsgLy8gQmFyXHJcblx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpOyAvLyBMaW5lXHJcblxyXG5cdFx0XHQvLyBTdWIgQ2hhcnRcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0ICYmXHJcblx0XHRcdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gQXJjICYgUmFkYXJcclxuXHRcdFx0JCQuaGFzQXJjVHlwZSh0YXJnZXRzKSAmJiAoXHJcblx0XHRcdFx0JCQuaGFzVHlwZShcInJhZGFyXCIpID9cclxuXHRcdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JSYWRhcih0YXJnZXRzKSA6XHJcblx0XHRcdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yQXJjKHRhcmdldHMpXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmFkZS1pbiBlYWNoIGNoYXJ0XHJcblx0XHQkJC5zaG93VGFyZ2V0cygpO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGxheSB0YXJnZXRlZCBlbGVtZW50c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0c2hvd1RhcmdldHMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLnN2Zy5zZWxlY3RBbGwoYC4ke0NMQVNTLnRhcmdldH1gKVxyXG5cdFx0XHQuZmlsdGVyKGQgPT4gJCQuaXNUYXJnZXRUb1Nob3coZC5pZCkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKCQkLmNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHR9XHJcblxyXG5cdGdldFdpdGhPcHRpb24ob3B0aW9ucykge1xyXG5cdFx0Y29uc3Qgd2l0aE9wdGlvbnMgPSB7XHJcblx0XHRcdFk6IHRydWUsXHJcblx0XHRcdFN1YmNoYXJ0OiB0cnVlLFxyXG5cdFx0XHRUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHRFdmVudFJlY3Q6IHRydWUsXHJcblx0XHRcdERpbWVuc2lvbjogdHJ1ZSxcclxuXHRcdFx0VHJpbVhEb21haW46IHRydWUsXHJcblx0XHRcdFRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdFVwZGF0ZVhEb21haW46IGZhbHNlLFxyXG5cdFx0XHRVcGRhdGVPcmdYRG9tYWluOiBmYWxzZSxcclxuXHRcdFx0TGVnZW5kOiBmYWxzZSxcclxuXHRcdFx0VXBkYXRlWEF4aXM6IFwiVXBkYXRlWERvbWFpblwiLFxyXG5cdFx0XHRUcmFuc2l0aW9uRm9yRXhpdDogXCJUcmFuc2l0aW9uXCIsXHJcblx0XHRcdFRyYW5zaXRpb25Gb3JBeGlzOiBcIlRyYW5zaXRpb25cIlxyXG5cdFx0fTtcclxuXHJcblx0XHRPYmplY3Qua2V5cyh3aXRoT3B0aW9ucykuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRsZXQgZGVmVmFsID0gd2l0aE9wdGlvbnNba2V5XTtcclxuXHJcblx0XHRcdGlmIChpc1N0cmluZyhkZWZWYWwpKSB7XHJcblx0XHRcdFx0ZGVmVmFsID0gd2l0aE9wdGlvbnNbZGVmVmFsXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2l0aE9wdGlvbnNba2V5XSA9IGdldE9wdGlvbihvcHRpb25zLCBgd2l0aCR7a2V5fWAsIGRlZlZhbCk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gd2l0aE9wdGlvbnM7XHJcblx0fVxyXG5cclxuXHRyZWRyYXcob3B0aW9ucyA9IHt9LCB0cmFuc2l0aW9uc1ZhbHVlPykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IHttYWlufSA9ICRlbDtcclxuXHRcdGNvbnN0IHRhcmdldHNUb1Nob3cgPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Y29uc3QgaW5pdGlhbGl6aW5nID0gb3B0aW9ucy5pbml0aWFsaXppbmc7XHJcblx0XHRjb25zdCBmbG93ID0gb3B0aW9ucy5mbG93O1xyXG5cdFx0Y29uc3Qgd3RoID0gJCQuZ2V0V2l0aE9wdGlvbihvcHRpb25zKTtcclxuXHRcdGNvbnN0IGR1cmF0aW9uID0gd3RoLlRyYW5zaXRpb24gPyBjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbiA6IDA7XHJcblx0XHRjb25zdCBkdXJhdGlvbkZvckV4aXQgPSB3dGguVHJhbnNpdGlvbkZvckV4aXQgPyBkdXJhdGlvbiA6IDA7XHJcblx0XHRjb25zdCBkdXJhdGlvbkZvckF4aXMgPSB3dGguVHJhbnNpdGlvbkZvckF4aXMgPyBkdXJhdGlvbiA6IDA7XHJcblx0XHRjb25zdCB0cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zVmFsdWUgfHwgJCQuYXhpcyAmJiAkJC5heGlzLmdlbmVyYXRlVHJhbnNpdGlvbnMoZHVyYXRpb25Gb3JBeGlzKTtcclxuXHJcblx0XHQhKGluaXRpYWxpemluZyAmJiBjb25maWcudG9vbHRpcF9pbml0X3Nob3cpICYmXHJcblx0XHRcdHN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICQkLmhpZGVUb29sdGlwKCk7XHJcblxyXG5cdFx0JCQudXBkYXRlU2l6ZXMoaW5pdGlhbGl6aW5nKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgbGVnZW5kIGFuZCB0cmFuc2Zvcm0gZWFjaCBnXHJcblxyXG5cdFx0aWYgKHd0aC5MZWdlbmQgJiYgY29uZmlnLmxlZ2VuZF9zaG93KSB7XHJcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZCgkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLCBvcHRpb25zLCB0cmFuc2l0aW9ucyk7XHJcblx0XHR9IGVsc2UgaWYgKHd0aC5EaW1lbnNpb24pIHtcclxuXHRcdFx0Ly8gbmVlZCB0byB1cGRhdGUgZGltZW5zaW9uIChlLmcuIGF4aXMueS50aWNrLnZhbHVlcykgYmVjYXVzZSB5IHRpY2sgdmFsdWVzIHNob3VsZCBjaGFuZ2VcclxuXHRcdFx0Ly8gbm8gbmVlZCB0byB1cGRhdGUgYXhpcyBpbiBpdCBiZWNhdXNlIHRoZXkgd2lsbCBiZSB1cGRhdGVkIGluIHJlZHJhdygpXHJcblx0XHRcdCQkLnVwZGF0ZURpbWVuc2lvbih0cnVlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvL0BUT0RPOiBBeGlzICYgUmFkYXIgdHlwZVxyXG5cdFx0aWYgKCQkLmlzQXhpcyB8fCAkJC5oYXNUeXBlKFwicmFkYXJcIikpIHtcclxuXHRcdFx0JCQudXBkYXRlQ2lyY2xlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGF4aXNcclxuXHRcdGlmICgkJC5pc0F4aXMpIHtcclxuXHRcdFx0Ly8gQFRPRE86IE1ha2UgJ2luaXQnIHN0YXRlIHRvIGJlIGFjY2Vzc2libGUgZXZlcnl3aGVyZSBub3QgcGFzc2luZyBhcyBhcmd1bWVudC5cclxuXHRcdFx0JCQuYXhpcy5yZWRyYXdBeGlzKHRhcmdldHNUb1Nob3csIHd0aCwgdHJhbnNpdGlvbnMsIGZsb3csIGluaXRpYWxpemluZyk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgY2lyY2xlWSBiYXNlZCBvbiB1cGRhdGVkIHBhcmFtZXRlcnNcclxuXHRcdFx0JCQudXBkYXRlQ2lyY2xlWSgpO1xyXG5cclxuXHRcdFx0Ly8geGdyaWQgZm9jdXNcclxuXHRcdFx0JCQudXBkYXRlZ3JpZEZvY3VzKCk7XHJcblxyXG5cdFx0XHQvLyBEYXRhIGVtcHR5IGxhYmVsIHBvc2l0aW9uaW5nIGFuZCB0ZXh0LlxyXG5cdFx0XHRjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0ICYmIG1haW4uc2VsZWN0KGB0ZXh0LiR7Q0xBU1MudGV4dH0uJHtDTEFTUy5lbXB0eX1gKVxyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCBzdGF0ZS53aWR0aCAvIDIpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIHN0YXRlLmhlaWdodCAvIDIpXHJcblx0XHRcdFx0LnRleHQoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dClcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIHRhcmdldHNUb1Nob3cubGVuZ3RoID8gXCJub25lXCIgOiBudWxsKTtcclxuXHJcblx0XHRcdC8vIGdyaWRcclxuXHRcdFx0JCQudXBkYXRlR3JpZChkdXJhdGlvbik7XHJcblxyXG5cdFx0XHQvLyByZWN0IGZvciByZWdpb25zXHJcblx0XHRcdCQkLnVwZGF0ZVJlZ2lvbihkdXJhdGlvbik7XHJcblxyXG5cdFx0XHQvLyBiYXJzXHJcblx0XHRcdCQkLnVwZGF0ZUJhcihkdXJhdGlvbkZvckV4aXQpO1xyXG5cclxuXHRcdFx0Ly8gbGluZXMsIGFyZWFzIGFuZCBjaXJjbGVzXHJcblx0XHRcdCQkLnVwZGF0ZUxpbmUoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdFx0JCQudXBkYXRlQXJlYShkdXJhdGlvbkZvckV4aXQpO1xyXG5cdFx0XHQvLyQkLnVwZGF0ZUNpcmNsZSgpO1xyXG5cclxuXHRcdFx0Ly8gdGV4dFxyXG5cdFx0XHQkJC5oYXNEYXRhTGFiZWwoKSAmJiAkJC51cGRhdGVUZXh0KGR1cmF0aW9uRm9yRXhpdCk7XHJcblxyXG5cdFx0XHQvLyBjaXJjbGVzIGZvciBzZWxlY3RcclxuXHRcdFx0JGVsLnRleHQgJiYgbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc31gKVxyXG5cdFx0XHRcdC5maWx0ZXIoJCQuaXNCYXJUeXBlLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoXCJjaXJjbGVcIilcclxuXHRcdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHQvLyBldmVudCByZWN0cyB3aWxsIHJlZHJhd24gd2hlbiBmbG93IGNhbGxlZFxyXG5cdFx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgIWZsb3cgJiYgd3RoLkV2ZW50UmVjdCkge1xyXG5cdFx0XHRcdCQkLmJpbmRab29tRXZlbnQoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gYXJjXHJcblx0XHRcdCRlbC5hcmNzICYmICQkLnJlZHJhd0FyYyhkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCB3dGguVHJhbnNmb3JtKTtcclxuXHJcblx0XHRcdC8vIHJhZGFyXHJcblx0XHRcdCQkLnJhZGFycyAmJiAkJC5yZWRyYXdSYWRhcihkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB0aXRsZVxyXG5cdFx0JCQucmVkcmF3VGl0bGUgJiYgJCQucmVkcmF3VGl0bGUoKTtcclxuXHJcblx0XHRpbml0aWFsaXppbmcgJiYgJCQuc2V0Q2hhcnRFbGVtZW50cygpO1xyXG5cclxuXHRcdCQkLmdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzVG9TaG93LCBmbG93LCBkdXJhdGlvbiwgd3RoLlN1YmNoYXJ0KTtcclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJHJlZHJhd1wiLCBvcHRpb25zLCBkdXJhdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSByZWRyYXcgbGlzdFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzIHRhcmdldHMgZGF0YSB0byBiZSBzaG93blxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmbG93XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGR1cmF0aW9uXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aXRoU3ViY2hhcnQgd2hldGhlciBvciBub3QgdG8gc2hvdyBzdWJjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVSZWRyYXdMaXN0KHRhcmdldHMsIGZsb3csIGR1cmF0aW9uLCB3aXRoU3ViY2hhcnQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2hhcGUgPSAkJC5nZXREcmF3U2hhcGUoKTtcclxuXHJcblx0XHRpZiAoJCQuaXNBeGlzKSB7XHJcblxyXG5cdFx0XHQvLyBzdWJjaGFydFxyXG5cdFx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyAmJiAkJC5yZWRyYXdTdWJjaGFydCh3aXRoU3ViY2hhcnQsIGR1cmF0aW9uLCBzaGFwZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZ2VuZXJhdGUgZmxvd1xyXG5cdFx0Y29uc3QgZmxvd0ZuID0gZmxvdyAmJiAkJC5nZW5lcmF0ZUZsb3coe1xyXG5cdFx0XHR0YXJnZXRzLFxyXG5cdFx0XHRmbG93LFxyXG5cdFx0XHRkdXJhdGlvbjogZmxvdy5kdXJhdGlvbixcclxuXHRcdFx0c2hhcGUsXHJcblx0XHRcdHh2OiAkJC54di5iaW5kKCQkKVxyXG5cdFx0fSk7XHJcblx0XHRjb25zdCBpc1RyYW5zaXRpb24gPSAoZHVyYXRpb24gfHwgZmxvd0ZuKSAmJiAkJC5pc1RhYlZpc2libGUoKTtcclxuXHJcblx0XHQvLyByZWRyYXcgbGlzdFxyXG5cdFx0Y29uc3QgcmVkcmF3TGlzdCA9ICQkLmdldFJlZHJhd0xpc3Qoc2hhcGUsIGZsb3csIGZsb3dGbiwgaXNUcmFuc2l0aW9uKTtcclxuXHJcblx0XHQvLyBjYWxsYmFjayBmdW5jdGlvbiBhZnRlciByZWRyYXcgZW5kc1xyXG5cdFx0Y29uc3QgYWZ0ZXJSZWRyYXcgPSBmbG93IHx8IGNvbmZpZy5vbnJlbmRlcmVkID8gKCkgPT4ge1xyXG5cdFx0XHRmbG93Rm4gJiYgZmxvd0ZuKCk7XHJcblx0XHRcdGNhbGxGbihjb25maWcub25yZW5kZXJlZCwgJCQsICQkLmFwaSk7XHJcblx0XHR9IDogbnVsbDtcclxuXHJcblx0XHRpZiAoYWZ0ZXJSZWRyYXcpIHtcclxuXHRcdFx0Ly8gT25seSB1c2UgdHJhbnNpdGlvbiB3aGVuIGN1cnJlbnQgdGFiIGlzIHZpc2libGUuXHJcblx0XHRcdGlmIChpc1RyYW5zaXRpb24gJiYgcmVkcmF3TGlzdC5sZW5ndGgpIHtcclxuXHRcdFx0XHQvLyBXYWl0IGZvciBlbmQgb2YgdHJhbnNpdGlvbnMgZm9yIGNhbGxiYWNrXHJcblx0XHRcdFx0Y29uc3Qgd2FpdEZvckRyYXcgPSAkJC5nZW5lcmF0ZVdhaXQoKTtcclxuXHJcblx0XHRcdFx0Ly8gdHJhbnNpdGlvbiBzaG91bGQgYmUgZGVyaXZlZCBmcm9tIG9uZSB0cmFuc2l0aW9uXHJcblx0XHRcdFx0ZDNUcmFuc2l0aW9uKCkuZHVyYXRpb24oZHVyYXRpb24pXHJcblx0XHRcdFx0XHQuZWFjaCgoKSA9PiB7XHJcblx0XHRcdFx0XHRcdHJlZHJhd0xpc3RcclxuXHRcdFx0XHRcdFx0XHQucmVkdWNlKChhY2MsIHQxKSA9PiBhY2MuY29uY2F0KHQxKSwgW10pXHJcblx0XHRcdFx0XHRcdFx0LmZvckVhY2godCA9PiB3YWl0Rm9yRHJhdy5hZGQodCkpO1xyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHRcdC5jYWxsKHdhaXRGb3JEcmF3LCBhZnRlclJlZHJhdyk7XHJcblx0XHRcdH0gZWxzZSBpZiAoIXN0YXRlLnRyYW5zaXRpbmcpIHtcclxuXHRcdFx0XHRhZnRlclJlZHJhdygpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGZhZGVpbiBjb25kaXRpb25cclxuXHRcdCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cykuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdHN0YXRlLndpdGhvdXRGYWRlSW5baWRdID0gdHJ1ZTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBzaGFwZSBkcmF3IGZ1bmN0aW9uXHJcblx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RHJhd1NoYXBlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGhhc1JhZGFyID0gJCQuaGFzVHlwZShcInJhZGFyXCIpO1xyXG5cdFx0Y29uc3Qgc2hhcGUgPSB7dHlwZToge30sIGluZGljZXM6IHt9LCBwb3M6IHt9fTtcclxuXHJcblx0XHQvLyBzZXR1cCBkcmF3ZXIgLSBNRU1POiB0aGVzZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBheGlzIHVwZGF0ZWRcclxuXHRcdGlmICgkJC5oYXNUeXBlT2YoXCJMaW5lXCIpIHx8ICQkLmhhc1R5cGUoXCJidWJibGVcIikgfHwgJCQuaGFzVHlwZShcInNjYXR0ZXJcIikpIHtcclxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0xpbmVUeXBlKTtcclxuXHJcblx0XHRcdHNoYXBlLmluZGljZXMubGluZSA9IGluZGljZXM7XHJcblx0XHRcdHNoYXBlLnR5cGUubGluZSA9ICQkLmdlbmVyYXRlRHJhd0xpbmUgPyAkJC5nZW5lcmF0ZURyYXdMaW5lKGluZGljZXMsIGZhbHNlKSA6IHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlT2YoXCJBcmVhXCIpKSB7XHJcblx0XHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0FyZWFUeXBlKTtcclxuXHJcblx0XHRcdFx0c2hhcGUuaW5kaWNlcy5hcmVhID0gaW5kaWNlcztcclxuXHRcdFx0XHRzaGFwZS50eXBlLmFyZWEgPSAkJC5nZW5lcmF0ZURyYXdBcmVhID8gJCQuZ2VuZXJhdGVEcmF3QXJlYShpbmRpY2VzLCBmYWxzZSkgOiB1bmRlZmluZWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xyXG5cdFx0XHRjb25zdCBpbmRpY2VzID0gJCQuZ2V0U2hhcGVJbmRpY2VzKCQkLmlzQmFyVHlwZSk7XHJcblxyXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmJhciA9IGluZGljZXM7XHJcblx0XHRcdHNoYXBlLnR5cGUuYmFyID0gJCQuZ2VuZXJhdGVEcmF3QmFyID8gJCQuZ2VuZXJhdGVEcmF3QmFyKGluZGljZXMpIDogdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgkJC5pc0F4aXMgfHwgaGFzUmFkYXIpIHtcclxuXHRcdFx0c2hhcGUucG9zID0ge1xyXG5cdFx0XHRcdHhGb3JUZXh0OiAkJC5nZW5lcmF0ZVhZRm9yVGV4dChzaGFwZS5pbmRpY2VzLCB0cnVlKSxcclxuXHRcdFx0XHR5Rm9yVGV4dDogJCQuZ2VuZXJhdGVYWUZvclRleHQoc2hhcGUuaW5kaWNlcywgZmFsc2UpLFxyXG5cclxuXHRcdFx0XHQvLyBnZW5lcmF0ZSBjaXJjbGUgeC95IGZ1bmN0aW9ucyBkZXBlbmRpbmcgb24gdXBkYXRlZCBwYXJhbXNcclxuXHRcdFx0XHRjeDogKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVYIDogKGlzUm90YXRlZCA/ICQkLmNpcmNsZVkgOiAkJC5jaXJjbGVYKSkuYmluZCgkJCksXHJcblx0XHRcdFx0Y3k6IChoYXNSYWRhciA/ICQkLnJhZGFyQ2lyY2xlWSA6IChpc1JvdGF0ZWQgPyAkJC5jaXJjbGVYIDogJCQuY2lyY2xlWSkpLmJpbmQoJCQpXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNoYXBlO1xyXG5cdH1cclxuXHJcblx0Z2V0UmVkcmF3TGlzdChzaGFwZSwgZmxvdywgZmxvd0ZuLCBpc1RyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gc2hhcGUucG9zO1xyXG5cdFx0Y29uc3QgbGlzdCA9IFtdO1xyXG5cclxuXHRcdGlmICgkJC5pc0F4aXMpIHtcclxuXHRcdFx0Y29uc3Qge2FyZWEsIGJhciwgbGluZX0gPSBzaGFwZS50eXBlO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5ncmlkX3hfbGluZXMubGVuZ3RoIHx8IGNvbmZpZy5ncmlkX3lfbGluZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd0dyaWQoaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcucmVnaW9ucy5sZW5ndGgpIHtcclxuXHRcdFx0XHRsaXN0LnB1c2goJCQucmVkcmF3UmVnaW9uKGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiTGluZVwiKSkge1xyXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdMaW5lKGxpbmUsIGlzVHJhbnNpdGlvbikpO1xyXG5cdFx0XHRcdCQkLmhhc1R5cGVPZihcIkFyZWFcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0FyZWEoYXJlYSwgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJiYXJcIikgJiYgbGlzdC5wdXNoKCQkLnJlZHJhd0JhcihiYXIsIGlzVHJhbnNpdGlvbikpO1xyXG5cclxuXHRcdFx0bm90RW1wdHkoY29uZmlnLmRhdGFfbGFiZWxzKSAmJlxyXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdUZXh0KHhGb3JUZXh0LCB5Rm9yVGV4dCwgZmxvdywgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0KCQkLmlzQXhpcyB8fCAkJC5oYXNUeXBlKFwicmFkYXJcIikpICYmIGxpc3QucHVzaCgkJC5yZWRyYXdDaXJjbGUoY3gsIGN5LCBpc1RyYW5zaXRpb24sIGZsb3dGbikpO1xyXG5cclxuXHRcdHJldHVybiBsaXN0O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlQW5kUmVkcmF3KG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCB0cmFuc2l0aW9ucztcclxuXHJcblx0XHQvLyBzYW1lIHdpdGggcmVkcmF3XHJcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25cIiwgdHJ1ZSk7XHJcblx0XHRvcHRpb25zLndpdGhUcmFuc2Zvcm0gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoVHJhbnNmb3JtXCIsIGZhbHNlKTtcclxuXHRcdG9wdGlvbnMud2l0aExlZ2VuZCA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhMZWdlbmRcIiwgZmFsc2UpO1xyXG5cclxuXHRcdC8vIE5PVCBzYW1lIHdpdGggcmVkcmF3XHJcblx0XHRvcHRpb25zLndpdGhVcGRhdGVYRG9tYWluID0gdHJ1ZTtcclxuXHRcdG9wdGlvbnMud2l0aFVwZGF0ZU9yZ1hEb21haW4gPSB0cnVlO1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvckV4aXQgPSBmYWxzZTtcclxuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm0gPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybVwiLCBvcHRpb25zLndpdGhUcmFuc2l0aW9uKTtcclxuXHJcblx0XHQvLyBNRU1POiBjYWxsZWQgaW4gdXBkYXRlTGVnZW5kIGluIHJlZHJhdyBpZiB3aXRoTGVnZW5kXHJcblx0XHRpZiAoIShvcHRpb25zLndpdGhMZWdlbmQgJiYgY29uZmlnLmxlZ2VuZF9zaG93KSkge1xyXG5cdFx0XHR0cmFuc2l0aW9ucyA9ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhcclxuXHRcdFx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yQXhpcyA/IGNvbmZpZy50cmFuc2l0aW9uX2R1cmF0aW9uIDogMFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHNjYWxlc1xyXG5cdFx0XHQkJC51cGRhdGVTY2FsZXMoKTtcclxuXHRcdFx0JCQudXBkYXRlU3ZnU2l6ZSgpO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIGcgcG9zaXRpb25zXHJcblx0XHRcdCQkLnRyYW5zZm9ybUFsbChvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtLCB0cmFuc2l0aW9ucyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRHJhdyB3aXRoIG5ldyBzaXplcyAmIHNjYWxlc1xyXG5cdFx0JCQucmVkcmF3KG9wdGlvbnMsIHRyYW5zaXRpb25zKTtcclxuXHR9XHJcblxyXG5cdHJlZHJhd1dpdGhvdXRSZXNjYWxlKCkge1xyXG5cdFx0dGhpcy5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoWTogZmFsc2UsXHJcblx0XHRcdHdpdGhTdWJjaGFydDogZmFsc2UsXHJcblx0XHRcdHdpdGhFdmVudFJlY3Q6IGZhbHNlLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvckF4aXM6IGZhbHNlXHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdGlzVGltZVNlcmllcygpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3hfdHlwZSA9PT0gXCJ0aW1lc2VyaWVzXCI7XHJcblx0fVxyXG5cclxuXHRpc0NhdGVnb3JpemVkKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmF4aXNfeF90eXBlLmluZGV4T2YoXCJjYXRlZ29yeVwiKSA+PSAwIHx8IHRoaXMuaGFzVHlwZShcInJhZGFyXCIpO1xyXG5cdH1cclxuXHJcblx0aXNDdXN0b21YKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gISQkLmlzVGltZVNlcmllcygpICYmIChjb25maWcuZGF0YV94IHx8IG5vdEVtcHR5KGNvbmZpZy5kYXRhX3hzKSk7XHJcblx0fVxyXG5cclxuXHRpc1RpbWVTZXJpZXNZKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLmF4aXNfeV90eXBlID09PSBcInRpbWVzZXJpZXNcIjtcclxuXHR9XHJcblxyXG5cdGdldFRyYW5zbGF0ZSh0YXJnZXQsIGluZGV4ID0gMCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblx0XHRsZXQgcGFkZGluZyA9IDA7XHJcblx0XHRsZXQgeDtcclxuXHRcdGxldCB5O1xyXG5cclxuXHRcdGlmIChpbmRleCAmJiAvXih4fHkyPykkLy50ZXN0KHRhcmdldCkpIHtcclxuXHRcdFx0cGFkZGluZyA9ICQkLmdldEF4aXNTaXplKHRhcmdldCkgKiBpbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGFyZ2V0ID09PSBcIm1haW5cIikge1xyXG5cdFx0XHR4ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luLmxlZnQpO1xyXG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luLnRvcCk7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJjb250ZXh0XCIpIHtcclxuXHRcdFx0eCA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbjIubGVmdCk7XHJcblx0XHRcdHkgPSBhc0hhbGZQaXhlbChzdGF0ZS5tYXJnaW4yLnRvcCk7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJsZWdlbmRcIikge1xyXG5cdFx0XHR4ID0gc3RhdGUubWFyZ2luMy5sZWZ0O1xyXG5cdFx0XHR5ID0gc3RhdGUubWFyZ2luMy50b3AgKyAoaGFzR2F1Z2UgPyAxMCA6IDApO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieFwiKSB7XHJcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAtcGFkZGluZyA6IDA7XHJcblx0XHRcdHkgPSBpc1JvdGF0ZWQgPyAwIDogc3RhdGUuaGVpZ2h0ICsgcGFkZGluZztcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInlcIikge1xyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IC1wYWRkaW5nO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gc3RhdGUuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ5MlwiKSB7XHJcblx0XHRcdHggPSBpc1JvdGF0ZWQgPyAwIDogc3RhdGUud2lkdGggKyBwYWRkaW5nO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMSAtIHBhZGRpbmcgOiAwO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwic3ViWFwiKSB7XHJcblx0XHRcdHggPSAwO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodDI7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJhcmNcIikge1xyXG5cdFx0XHR4ID0gc3RhdGUuYXJjV2lkdGggLyAyO1xyXG5cdFx0XHR5ID0gc3RhdGUuYXJjSGVpZ2h0IC8gMjtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInJhZGFyXCIpIHtcclxuXHRcdFx0Y29uc3QgW3dpZHRoXSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cclxuXHRcdFx0eCA9IHN0YXRlLndpZHRoIC8gMiAtIHdpZHRoO1xyXG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luLnRvcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGB0cmFuc2xhdGUoJHt4fSwgJHt5fSlgO1xyXG5cdH1cclxuXHJcblx0aW5pdGlhbE9wYWNpdHkoZCkge1xyXG5cdFx0Y29uc3Qge3dpdGhvdXRGYWRlSW59ID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwgJiZcclxuXHRcdFx0d2l0aG91dEZhZGVJbltkLmlkXSA/IFwiMVwiIDogXCIwXCI7XHJcblx0fVxyXG5cclxuXHRpbml0aWFsT3BhY2l0eUZvckNpcmNsZShkKSB7XHJcblx0XHRjb25zdCB7d2l0aG91dEZhZGVJbn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCAmJlxyXG5cdFx0XHR3aXRob3V0RmFkZUluW2QuaWRdID8gdGhpcy5vcGFjaXR5Rm9yQ2lyY2xlKGQpIDogXCIwXCI7XHJcblx0fVxyXG5cclxuXHRvcGFjaXR5Rm9yQ2lyY2xlKGQpIHtcclxuXHRcdGNvbnN0IG9wYWNpdHkgPSB0aGlzLmNvbmZpZy5wb2ludF9zaG93ID8gXCIxXCIgOiBcIjBcIjtcclxuXHJcblx0XHRyZXR1cm4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkgP1xyXG5cdFx0XHQodGhpcy5pc0J1YmJsZVR5cGUoZCkgfHwgdGhpcy5pc1NjYXR0ZXJUeXBlKGQpID9cclxuXHRcdFx0XHRcIjAuNVwiIDogb3BhY2l0eSkgOiBcIjBcIjtcclxuXHR9XHJcblxyXG5cdG9wYWNpdHlGb3JUZXh0KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaGFzRGF0YUxhYmVsKCkgPyBcIjFcIiA6IFwiMFwiO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSB6b29tIG9yIHVuem9vbWVkIHNjYWxlZCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ8T2JqZWN0fSBkIERhdGEgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHh4KGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlOiB7eCwgem9vbX19ID0gJCQ7XHJcblx0XHRjb25zdCBmbiA9IGNvbmZpZy56b29tX2VuYWJsZWQgJiYgem9vbSA/XHJcblx0XHRcdHpvb20gOiB4O1xyXG5cclxuXHRcdHJldHVybiBkID8gZm4oaXNWYWx1ZShkLngpID8gZC54IDogZCkgOiBudWxsO1xyXG5cdH1cclxuXHJcblx0eHYoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGU6IHt4fX0gPSAkJDtcclxuXHRcdGxldCB2YWx1ZSA9ICQkLmdldEJhc2VWYWx1ZShkKTtcclxuXHJcblx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0dmFsdWUgPSAkJC5wYXJzZURhdGUodmFsdWUpO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5pc0NhdGVnb3JpemVkKCkgJiYgaXNTdHJpbmcodmFsdWUpKSB7XHJcblx0XHRcdHZhbHVlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodmFsdWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBNYXRoLmNlaWwoeCh2YWx1ZSkpO1xyXG5cdH1cclxuXHJcblx0eXYoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NjYWxlOiB7eSwgeTJ9fSA9ICQkO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gZC5heGlzICYmIGQuYXhpcyA9PT0gXCJ5MlwiID8geTIgOiB5O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmNlaWwoeVNjYWxlKCQkLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cdH1cclxuXHJcblx0c3VieHgoZCkge1xyXG5cdFx0cmV0dXJuIGQgPyB0aGlzLnNjYWxlLnN1YlgoZC54KSA6IG51bGw7XHJcblx0fVxyXG5cclxuXHR0cmFuc2Zvcm1NYWluKHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0bGV0IHhBeGlzO1xyXG5cdFx0bGV0IHlBeGlzO1xyXG5cdFx0bGV0IHkyQXhpcztcclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1gpIHtcclxuXHRcdFx0eEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHhBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0eEF4aXMgPSB4QXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kpIHtcclxuXHRcdFx0eUF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHlBeGlzID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0eUF4aXMgPSB5QXhpcy50cmFuc2l0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1kyKSB7XHJcblx0XHRcdHkyQXhpcyA9IHRyYW5zaXRpb25zLmF4aXNZMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHkyQXhpcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWTJ9YCk7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHR5MkF4aXMgPSB5MkF4aXMudHJhbnNpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gbWFpbi50cmFuc2l0aW9uKCkgOiBtYWluKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJtYWluXCIpKTtcclxuXHJcblx0XHR4QXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInhcIikpO1xyXG5cdFx0eUF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ5XCIpKTtcclxuXHRcdHkyQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInkyXCIpKTtcclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzfWApXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImFyY1wiKSk7XHJcblx0fVxyXG5cclxuXHR0cmFuc2Zvcm1BbGwod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0JCQudHJhbnNmb3JtTWFpbih3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpO1xyXG5cclxuXHRcdGNvbmZpZy5zdWJjaGFydF9zaG93ICYmXHJcblx0XHRcdCQkLnRyYW5zZm9ybUNvbnRleHQod2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcclxuXHJcblx0XHQkZWwubGVnZW5kICYmICQkLnRyYW5zZm9ybUxlZ2VuZCh3aXRoVHJhbnNpdGlvbik7XHJcblx0fVxyXG5cclxuXHR1cGRhdGVTdmdTaXplKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlLCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdHN2Z1xyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLmN1cnJlbnRXaWR0aClcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgc3RhdGUuY3VycmVudEhlaWdodCk7XHJcblxyXG5cdFx0aWYgKCQkLmlzQXhpcykge1xyXG5cdFx0XHRjb25zdCBicnVzaCA9IHN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xyXG5cdFx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XHJcblx0XHRcdFx0YnJ1c2hTaXplLndpZHRoID0gK2JydXNoLmF0dHIoXCJ3aWR0aFwiKTtcclxuXHRcdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHN2Zy5zZWxlY3RBbGwoW2AjJHtzdGF0ZS5jbGlwLmlkfWAsIGAjJHtzdGF0ZS5jbGlwLmlkR3JpZH1gXSlcclxuXHRcdFx0XHQuc2VsZWN0KFwicmVjdFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUud2lkdGgpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgc3RhdGUuaGVpZ2h0KTtcclxuXHJcblx0XHRcdHN2Zy5zZWxlY3QoYCMke3N0YXRlLmNsaXAuaWRYQXhpc31gKVxyXG5cdFx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4XCIsICQkLmdldFhBeGlzQ2xpcFguYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsICQkLmdldFhBeGlzQ2xpcFkuYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5nZXRYQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5nZXRYQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFlBeGlzfWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgJCQuZ2V0WUF4aXNDbGlwWC5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgJCQuZ2V0WUF4aXNDbGlwWS5iaW5kKCQkKSlcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmdldFlBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLmdldFlBeGlzQ2xpcEhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0XHRzdGF0ZS5jbGlwLmlkU3ViY2hhcnQgJiYgc3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFN1YmNoYXJ0fWApXHJcblx0XHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLndpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGJydXNoU2l6ZS5oZWlnaHQpO1xyXG5cclxuXHRcdFx0c3ZnLnNlbGVjdChgLiR7Q0xBU1Muem9vbVJlY3R9YClcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIHN0YXRlLndpZHRoKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHN0YXRlLmhlaWdodCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR1cGRhdGVEaW1lbnNpb24od2l0aG91dEF4aXMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge2F4aXN9fSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5pc0F4aXMgJiYgIXdpdGhvdXRBeGlzKSB7XHJcblx0XHRcdGlmICgkJC5heGlzLnggJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRcdCQkLmF4aXMueC5jcmVhdGUoYXhpcy54KTtcclxuXHRcdFx0XHQkJC5heGlzLnN1YlggJiYgJCQuYXhpcy5zdWJYLmNyZWF0ZShheGlzLnN1YlgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCQkLmF4aXMueSAmJiAkJC5heGlzLnkuY3JlYXRlKGF4aXMueSk7XHJcblx0XHRcdFx0JCQuYXhpcy55MiAmJiAkJC5heGlzLnkyLmNyZWF0ZShheGlzLnkyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHBhc3MgJ3dpdGhvdXRBeGlzJyBwYXJhbSB0byBub3QgYW5pbWF0ZSBhdCB0aGUgaW5pdCByZW5kZXJpbmdcclxuXHRcdCQkLnVwZGF0ZVNjYWxlcyh3aXRob3V0QXhpcyk7XHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblx0XHQkJC50cmFuc2Zvcm1BbGwoZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0YmluZFJlc2l6ZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0JCQucmVzaXplRnVuY3Rpb24gPSAkJC5nZW5lcmF0ZVJlc2l6ZSgpO1xyXG5cdFx0JCQucmVzaXplRnVuY3Rpb24uYWRkKCgpID0+IGNhbGxGbihjb25maWcub25yZXNpemUsICQkLCAkJC5hcGkpKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLnJlc2l6ZV9hdXRvKSB7XHJcblx0XHRcdCQkLnJlc2l6ZUZ1bmN0aW9uLmFkZCgoKSA9PiB7XHJcblx0XHRcdFx0aWYgKCQkLnJlc2l6ZVRpbWVvdXQpIHtcclxuXHRcdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoJCQucmVzaXplVGltZW91dCk7XHJcblx0XHRcdFx0XHQkJC5yZXNpemVUaW1lb3V0ID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCQkLnJlc2l6ZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0XHQkJC5hcGkuZmx1c2goZmFsc2UsIHRydWUpO1xyXG5cdFx0XHRcdH0sIDIwMCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlc2l6ZUZ1bmN0aW9uLmFkZCgoKSA9PiBjYWxsRm4oY29uZmlnLm9ucmVzaXplZCwgJCQsICQkLmFwaSkpO1xyXG5cclxuXHRcdC8vIGF0dGFjaCByZXNpemUgZXZlbnRcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICQkLnJlc2l6ZUZ1bmN0aW9uKTtcclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlUmVzaXplKCkge1xyXG5cdFx0Y29uc3QgcmVzaXplRnVuY3Rpb25zID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2FsbFJlc2l6ZUZ1bmN0aW9ucygpIHtcclxuXHRcdFx0cmVzaXplRnVuY3Rpb25zLmZvckVhY2goZiA9PiBmKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMuYWRkID0gZiA9PiByZXNpemVGdW5jdGlvbnMucHVzaChmKTtcclxuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMucmVtb3ZlID0gZiA9PiByZXNpemVGdW5jdGlvbnMuc3BsaWNlKHJlc2l6ZUZ1bmN0aW9ucy5pbmRleE9mKGYpLCAxKTtcclxuXHJcblx0XHRyZXR1cm4gY2FsbFJlc2l6ZUZ1bmN0aW9ucztcclxuXHR9XHJcblxyXG5cdGVuZGFsbCh0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xyXG5cdFx0bGV0IG4gPSAwO1xyXG5cclxuXHRcdHRyYW5zaXRpb25cclxuXHRcdFx0LmVhY2goKCkgPT4gKytuKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRcdCEtLW4gJiYgY2FsbGJhY2suYXBwbHkodGhpcywgLi4uYXJncyk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVXYWl0KCkge1xyXG5cdFx0bGV0IHRyYW5zaXRpb25zVG9XYWl0ID0gW107XHJcblx0XHRjb25zdCBmID0gZnVuY3Rpb24odCwgY2FsbGJhY2spIHtcclxuXHRcdFx0bGV0IHRpbWVyO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gbG9vcCgpIHtcclxuXHRcdFx0XHRsZXQgZG9uZSA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCB0OyAodCA9IHRyYW5zaXRpb25zVG9XYWl0W2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAodC5lbXB0eSgpKSB7XHJcblx0XHRcdFx0XHRcdGRvbmUrKztcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0dC50cmFuc2l0aW9uKCk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdGRvbmUrKztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XHJcblxyXG5cdFx0XHRcdGlmIChkb25lID09PSB0cmFuc2l0aW9uc1RvV2FpdC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dChsb29wLCA1MCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsb29wKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGYuYWRkID0gZnVuY3Rpb24odCkge1xyXG5cdFx0XHRpc0FycmF5KHQpID9cclxuXHRcdFx0XHQodHJhbnNpdGlvbnNUb1dhaXQgPSB0cmFuc2l0aW9uc1RvV2FpdC5jb25jYXQodCkpIDpcclxuXHRcdFx0XHR0cmFuc2l0aW9uc1RvV2FpdC5wdXNoKHQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZjtcclxuXHR9XHJcblxyXG5cdHBhcnNlRGF0ZShkYXRlOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogRGF0ZSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgcGFyc2VkRGF0ZTtcclxuXHJcblx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdFx0cGFyc2VkRGF0ZSA9IGRhdGU7XHJcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGRhdGUpKSB7XHJcblx0XHRcdHBhcnNlZERhdGUgPSAkJC5mb3JtYXQuZGF0YVRpbWUoJCQuY29uZmlnLmRhdGFfeEZvcm1hdCkoZGF0ZSk7XHJcblx0XHR9IGVsc2UgaWYgKGlzTnVtYmVyKGRhdGUpICYmICFpc05hTihkYXRlKSkge1xyXG5cdFx0XHRwYXJzZWREYXRlID0gbmV3IERhdGUoK2RhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghcGFyc2VkRGF0ZSB8fCBpc05hTigrcGFyc2VkRGF0ZSkpIHtcclxuXHRcdFx0Y29uc29sZSAmJiBjb25zb2xlLmVycm9yICYmXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBhcnNlIHggJyR7ZGF0ZX0nIHRvIERhdGUgb2JqZWN0YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhcnNlZERhdGU7XHJcblx0fVxyXG5cclxuXHRpc1RhYlZpc2libGUoKSB7XHJcblx0XHRyZXR1cm4gIWRvY3VtZW50LmhpZGRlbjtcclxuXHR9XHJcblxyXG5cdGNvbnZlcnRJbnB1dFR5cGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IGlzTW9iaWxlID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Ccm93c2VyX2RldGVjdGlvbl91c2luZ190aGVfdXNlcl9hZ2VudCNNb2JpbGVfVGFibGV0X29yX0Rlc2t0b3BcclxuXHRcdGlmICgvTW9iaS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaCkge1xyXG5cdFx0XHQvLyBTb21lIEVkZ2UgZGVza3RvcCByZXR1cm4gdHJ1ZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMjA0MTcwNzQvXHJcblx0XHRcdGNvbnN0IGhhc1RvdWNoUG9pbnRzID0gd2luZG93Lm5hdmlnYXRvciAmJiBcIm1heFRvdWNoUG9pbnRzXCIgaW4gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcclxuXHJcblx0XHRcdC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL3RvdWNoZXZlbnRzLmpzXHJcblx0XHRcdC8vIE9uIElFMTEgd2l0aCBJRTkgZW11bGF0aW9uIG1vZGUsICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIGlzIHJldHVybmluZyB0cnVlXHJcblx0XHRcdGNvbnN0IGhhc1RvdWNoID0gKFwib250b3VjaG1vdmVcIiBpbiB3aW5kb3cgfHwgKHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcblx0XHRcdGlzTW9iaWxlID0gaGFzVG91Y2hQb2ludHMgfHwgaGFzVG91Y2g7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaGFzTW91c2UgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlICYmICFpc01vYmlsZSA/IChcIm9ubW91c2VvdmVyXCIgaW4gd2luZG93KSA6IGZhbHNlO1xyXG5cclxuXHRcdHJldHVybiAoaGFzTW91c2UgJiYgXCJtb3VzZVwiKSB8fCAoaXNNb2JpbGUgJiYgXCJ0b3VjaFwiKSB8fCBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbCBwbHVnaW4gaG9va1xyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwaGFzZSBUaGUgbGlmZWN5Y2xlIHBoYXNlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjYWxsUGx1Z2luSG9vayhwaGFzZSwgLi4uYXJncykge1xyXG5cdFx0dGhpcy5jb25maWcucGx1Z2lucy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRpZiAocGhhc2UgPT09IFwiJGJlZm9yZUluaXRcIikge1xyXG5cdFx0XHRcdHYuJCQgPSB0aGlzO1xyXG5cdFx0XHRcdHRoaXMuYXBpLnBsdWdpbnMucHVzaCh2KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dltwaGFzZV0oLi4uYXJncyk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwgW1xyXG5cdC8vIGNvbW1vblxyXG5cdGRhdGFDb252ZXJ0LFxyXG5cdGRhdGEsXHJcblx0ZGF0YUxvYWQsXHJcblx0Y2xhc3NNb2R1bGUsXHJcblx0Y29sb3IsXHJcblx0ZG9tYWluLFxyXG5cdGludGVyYWN0aW9uLFxyXG5cdGZvcm1hdCxcclxuXHRsZWdlbmQsXHJcblx0c2NhbGUsXHJcblx0c2l6ZSxcclxuXHR0ZXh0LFxyXG5cdHRpdGxlLFxyXG5cdHRvb2x0aXAsXHJcblx0dHlwZSxcclxuXHQuLi5tb2R1bGVBcmMuaW50ZXJuYWwsXHJcblx0Li4ubW9kdWxlQXhpcy5pbnRlcm5hbFxyXG5dKTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzRGVmaW5lZCwgaXNPYmplY3RUeXBlfSBmcm9tIFwiLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCB7bG9hZENvbmZpZ307XHJcblxyXG4vKipcclxuICogTG9hZCBjb25maWd1cmF0aW9uIG9wdGlvblxyXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFVzZXIncyBnZW5lcmF0aW9uIGNvbmZpZyB2YWx1ZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbG9hZENvbmZpZyhjb25maWcpIHtcclxuXHRjb25zdCB0aGlzQ29uZmlnID0gdGhpcy5jb25maWc7XHJcblx0bGV0IHRhcmdldDtcclxuXHRsZXQga2V5cztcclxuXHRsZXQgcmVhZDtcclxuXHJcblx0Y29uc3QgZmluZCA9ICgpID0+IHtcclxuXHRcdGNvbnN0IGtleSA9IGtleXMuc2hpZnQoKTtcclxuXHJcblx0XHRpZiAoa2V5ICYmIHRhcmdldCAmJiBpc09iamVjdFR5cGUodGFyZ2V0KSAmJiBrZXkgaW4gdGFyZ2V0KSB7XHJcblx0XHRcdHRhcmdldCA9IHRhcmdldFtrZXldO1xyXG5cdFx0XHRyZXR1cm4gZmluZCgpO1xyXG5cdFx0fSBlbHNlIGlmICgha2V5KSB7XHJcblx0XHRcdHJldHVybiB0YXJnZXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHR9O1xyXG5cclxuXHRPYmplY3Qua2V5cyh0aGlzQ29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHR0YXJnZXQgPSBjb25maWc7XHJcblx0XHRrZXlzID0ga2V5LnNwbGl0KFwiX1wiKTtcclxuXHRcdHJlYWQgPSBmaW5kKCk7XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChyZWFkKSkge1xyXG5cdFx0XHR0aGlzQ29uZmlnW2tleV0gPSByZWFkO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHt3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQge25vdEVtcHR5LCBpc0RlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFJlc2l6ZSB0aGUgY2hhcnQuXHJcblx0ICogQG1ldGhvZCByZXNpemVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gc2l6ZSBUaGlzIGFyZ3VtZW50IHNob3VsZCBpbmNsdWRlIHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gUmVzaXplIHRvIDY0MHg0ODBcclxuXHQgKiBjaGFydC5yZXNpemUoe1xyXG5cdCAqICAgIHdpZHRoOiA2NDAsXHJcblx0ICogICAgaGVpZ2h0OiA0ODBcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRyZXNpemUoc2l6ZT86IHt3aWR0aD86IG51bWJlciwgaGVpZ2h0PzogbnVtYmVyfSkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdGNvbmZpZy5zaXplX3dpZHRoID0gc2l6ZSA/IHNpemUud2lkdGggOiBudWxsO1xyXG5cdFx0Y29uZmlnLnNpemVfaGVpZ2h0ID0gc2l6ZSA/IHNpemUuaGVpZ2h0IDogbnVsbDtcclxuXHJcblx0XHR0aGlzLmZsdXNoKGZhbHNlLCB0cnVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBGb3JjZSB0byByZWRyYXcuXHJcblx0ICogQG1ldGhvZCBmbHVzaFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NvZnRdIEZvciBzb2Z0IHJlZHJhdy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmZsdXNoKCk7XHJcblx0ICpcclxuXHQgKiAvLyBmb3Igc29mdCByZWRyYXdcclxuXHQgKiBjaGFydC5mbHVzaCh0cnVlKTtcclxuXHQgKi9cclxuXHRmbHVzaChzb2Z0PzogYm9vbGVhbiwgX2lzRnJvbVJlc2l6ZT86IGJvb2xlYW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblxyXG5cdFx0aWYgKCQkLnN0YXRlLnJlbmRlcmVkKSB7XHJcblx0XHRcdC8vIHJlc2V0IHBvc3NpYmxlIHpvb20gc2NhbGUgd2hlbiBpcyBjYWxsZWQgZnJvbSByZXNpemUgZXZlbnRcclxuXHRcdFx0aWYgKF9pc0Zyb21SZXNpemUpIHtcclxuXHRcdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC51cGRhdGVSZXNpemUoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyByZS11cGRhdGUgY29uZmlnIGluZm9cclxuXHRcdFx0XHQkJC5heGlzICYmICQkLmF4aXMuc2V0T3JpZW50KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCQkLnNjYWxlLnpvb20gPSBudWxsO1xyXG5cclxuXHRcdFx0c29mdCA/ICQkLnJlZHJhdyh7XHJcblx0XHRcdFx0d2l0aFRyYW5zZm9ybTogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0XHRcdH0pIDogJCQudXBkYXRlQW5kUmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcclxuXHRcdFx0XHR3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0JCQuaW5pdFRvUmVuZGVyKHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlc2V0IHRoZSBjaGFydCBvYmplY3QgYW5kIHJlbW92ZSBlbGVtZW50IGFuZCBldmVudHMgY29tcGxldGVseS5cclxuXHQgKiBAbWV0aG9kIGRlc3Ryb3lcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmRlc3Ryb3koKTtcclxuXHQgKi9cclxuXHRkZXN0cm95KCk6IG51bGwge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3QgeyRlbDoge2NoYXJ0LCBzdmd9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChub3RFbXB0eSgkJCkpIHtcclxuXHRcdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkd2lsbERlc3Ryb3lcIik7XHJcblx0XHRcdCQkLmNoYXJ0cy5zcGxpY2UoJCQuY2hhcnRzLmluZGV4T2YodGhpcyksIDEpO1xyXG5cclxuXHRcdFx0Ly8gY2xlYXIgdGltZXJzICYmIHBlbmRpbmcgdHJhbnNpdGlvblxyXG5cdFx0XHRzdmcuc2VsZWN0KFwiKlwiKS5pbnRlcnJ1cHQoKTtcclxuXHRcdFx0aXNEZWZpbmVkKCQkLnJlc2l6ZVRpbWVvdXQpICYmIHdpbmRvdy5jbGVhclRpbWVvdXQoJCQucmVzaXplVGltZW91dCk7XHJcblxyXG5cdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCAkJC5yZXNpemVGdW5jdGlvbik7XHJcblx0XHRcdGNoYXJ0LmNsYXNzZWQoXCJiYlwiLCBmYWxzZSkuaHRtbChcIlwiKTtcclxuXHJcblx0XHRcdC8vIHJlbGVhc2luZyByZWZlcmVuY2VzXHJcblx0XHRcdE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRrZXkgPT09IFwiaW50ZXJuYWxcIiAmJiBPYmplY3Qua2V5cygkJCkuZm9yRWFjaChrID0+IHtcclxuXHRcdFx0XHRcdCQkW2tdID0gbnVsbDtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dGhpc1trZXldID0gbnVsbDtcclxuXHRcdFx0XHRkZWxldGUgdGhpc1trZXldO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgb3Igc2V0IHNpbmdsZSBjb25maWcgb3B0aW9uIHZhbHVlLlxyXG5cdCAqIEBtZXRob2QgY29uZmlnXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIG9wdGlvbiBrZXkgbmFtZS5cclxuXHQgKiBAcGFyYW0geyp9IFt2YWx1ZV0gVGhlIHZhbHVlIGFjY2VwdGVkIGZvciBpbmRpY2F0ZWQgb3B0aW9uLlxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlZHJhd10gU2V0IHRvIHJlZHJhdyB3aXRoIHRoZSBuZXcgb3B0aW9uIGNoYW5nZXMuXHJcblx0ICogLSAqKk5PVEU6KiogRG9lc24ndCBndWFyYW50ZWUgd29yayBpbiBhbGwgY2lyY3Vtc3RhbmNlcy4gSXQgY2FuIGJlIGFwcGxpZWQgZm9yIGxpbWl0ZWQgb3B0aW9ucyBvbmx5LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0dGVyXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIpO1xyXG5cdCAqXHJcblx0ICogLy8gU2V0dGVyXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCk7XHJcblx0ICpcclxuXHQgKiAvLyBTZXR0ZXIgJiByZWRyYXcgd2l0aCB0aGUgbmV3IG9wdGlvblxyXG5cdCAqIGNoYXJ0LmNvbmZpZyhcImdhdWdlLm1heFwiLCAxMDAsIHRydWUpO1xyXG5cdCAqL1xyXG5cdGNvbmZpZyhuYW1lOiBzdHJpbmcsIHZhbHVlPzogYW55LCByZWRyYXc/OiBib29sZWFuKTogYW55IHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBrZXkgPSBuYW1lICYmIG5hbWUucmVwbGFjZSgvXFwuL2csIFwiX1wiKTtcclxuXHRcdGxldCByZXM7XHJcblxyXG5cdFx0aWYgKGtleSBpbiBjb25maWcpIHtcclxuXHRcdFx0aWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcclxuXHRcdFx0XHRjb25maWdba2V5XSA9IHZhbHVlO1xyXG5cdFx0XHRcdHJlcyA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZWRyYXcgJiYgdGhpcy5mbHVzaCgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHJlcyA9IGNvbmZpZ1trZXldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlcztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgY29sb3JcclxuXHQgKiBAbWV0aG9kIGNvbG9yXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIGlkIHRvIGdldCB0aGUgY29sb3JcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmNvbG9yKFwiZGF0YTFcIik7XHJcblx0ICovXHJcblx0Y29sb3IoaWQ6IHN0cmluZykge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuY29sb3IoaWQpOyAvLyBtb3JlIHBhdHRlcm5zXHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZXh0ZW5kLCBpc1VuZGVmaW5lZCwgaXNBcnJheX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogR2V0IGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuICogQG1ldGhvZCBkYXRhXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIEFQSSByZXR1cm5zIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGRhdGEuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBhbGwgb2YgZGF0YSB3aWxsIGJlIHJldHVybmVkLlxyXG4gKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIEdldCBvbmx5IGRhdGExIGRhdGFcclxuICogY2hhcnQuZGF0YShcImRhdGExXCIpO1xyXG4gKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cclxuICpcclxuICogLy8gR2V0IGRhdGExIGFuZCBkYXRhMiBkYXRhXHJcbiAqIGNoYXJ0LmRhdGEoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcbiAqXHJcbiAqIC8vIEdldCBhbGwgZGF0YVxyXG4gKiBjaGFydC5kYXRhKCk7XHJcbiAqL1xyXG5mdW5jdGlvbiBkYXRhKHRhcmdldElkcykge1xyXG5cdGNvbnN0IHt0YXJnZXRzfSA9IHRoaXMuaW50ZXJuYWwuZGF0YTtcclxuXHJcblx0aWYgKCFpc1VuZGVmaW5lZCh0YXJnZXRJZHMpKSB7XHJcblx0XHRjb25zdCBpZHMgPSBpc0FycmF5KHRhcmdldElkcykgPyB0YXJnZXRJZHMgOiBbdGFyZ2V0SWRzXTtcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0cy5maWx0ZXIodCA9PiBpZHMuc29tZSh2ID0+IHYgPT09IHQuaWQpKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0YXJnZXRzO1xyXG59XHJcblxyXG5leHRlbmQoZGF0YSwge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhIHNob3duIGluIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIGRhdGHigKRzaG93blxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhpcyBBUEkgZmlsdGVycyB0aGUgZGF0YSB3aXRoIHNwZWNpZmllZCB0YXJnZXQgaWRzLiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgYWxsIHNob3duIGRhdGEgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgc2hvd24gZGF0YSBieSBmaWx0ZXJpbmcgdG8gaW5jbHVkZSBvbmx5IGRhdGExIGRhdGFcclxuXHQgKiBjaGFydC5kYXRhLnNob3duKFwiZGF0YTFcIik7XHJcblx0ICogLy8gLS0+IFt7aWQ6IFwiZGF0YTFcIiwgaWRfb3JnOiBcImRhdGExXCIsIHZhbHVlczogQXJyYXkoNil9LCAuLi5dXHJcblx0ICpcclxuXHQgKiAvLyBHZXQgc2hvd24gZGF0YSBieSBmaWx0ZXJpbmcgdG8gaW5jbHVkZSBkYXRhMSBhbmQgZGF0YTIgZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBHZXQgYWxsIHNob3duIGRhdGFcclxuXHQgKiBjaGFydC5kYXRhLnNob3duKCk7XHJcblx0ICovXHJcblx0c2hvd246IGZ1bmN0aW9uKHRhcmdldElkczogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLmZpbHRlclRhcmdldHNUb1Nob3codGhpcy5kYXRhKHRhcmdldElkcykpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB2YWx1ZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIGRhdGHigKR2YWx1ZXNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIFRoaXMgQVBJIHJldHVybnMgdGhlIHZhbHVlcyBvZiBzcGVjaWZpZWQgdGFyZ2V0LiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBnaXZlbiwgbnVsbCB3aWxsIGJlIHJldHJ1bmVkXHJcblx0ICogQHJldHVybiB7QXJyYXl9IERhdGEgdmFsdWVzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgZGF0YTEgdmFsdWVzXHJcblx0ICogY2hhcnQuZGF0YS52YWx1ZXMoXCJkYXRhMVwiKTtcclxuXHQgKiAvLyAtLT4gWzEwLCAyMCwgMzAsIDQwXVxyXG5cdCAqL1xyXG5cdHZhbHVlczogZnVuY3Rpb24odGFyZ2V0SWQ/OiBzdHJpbmcgfCBzdHJpbmdbXSwgZmxhdDogYm9vbGVhbiA9IHRydWUpIHtcclxuXHRcdGxldCB2YWx1ZXM7XHJcblxyXG5cdFx0aWYgKHRhcmdldElkKSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldHMgPSB0aGlzLmRhdGEodGFyZ2V0SWQpO1xyXG5cclxuXHRcdFx0aWYgKHRhcmdldHMgJiYgaXNBcnJheSh0YXJnZXRzKSkge1xyXG5cdFx0XHRcdHZhbHVlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHR0YXJnZXRzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBkYXRhVmFsdWUgPSB2LnZhbHVlcy5tYXAoZCA9PiBkLnZhbHVlKTtcclxuXHJcblx0XHRcdFx0XHRmbGF0ID8gKHZhbHVlcyA9IHZhbHVlcy5jb25jYXQoZGF0YVZhbHVlKSkgOiB2YWx1ZXMucHVzaChkYXRhVmFsdWUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBuYW1lcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBtZXRob2QgZGF0YeKApG5hbWVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IG5hbWVzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBuYW1lcyBvZiBkYXRhIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm90IGdpdmVuLCB0aGUgY3VycmVudCBuYW1lcyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXNcclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgbmFtZXMgYWNjb3JkaW5nIGl0cyBrZXkgdmFsdWUsIGlmIHNwZWNpZmllZCBuYW1lcyB2YWx1ZXMuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBuYW1lc1xyXG5cdCAqIGNoYXJ0LmRhdGEubmFtZXMoKTtcclxuXHQgKiAvLyAtLT4ge2RhdGExOiBcInRlc3QxXCIsIGRhdGEyOiBcInRlc3QyXCJ9XHJcblx0ICpcclxuXHQgKiAvLyBVcGRhdGUgbmFtZXNcclxuXHQgKiBjaGFydC5kYXRhLm5hbWVzKHtcclxuXHQgKiAgZGF0YTE6IFwiTmV3IE5hbWUgMVwiLFxyXG5cdCAqICBkYXRhMjogXCJOZXcgTmFtZSAyXCJcclxuXHQgKn0pO1xyXG5cdCAqL1xyXG5cdG5hbWVzOiBmdW5jdGlvbihuYW1lcz86IEFycmF5PHsgW2tleTogc3RyaW5nXTogc3RyaW5nOyB9Pik6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9IHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHQvLyByZXNldCBleGlzdGluZyBsZWdlbmQgaXRlbSBkaW1lbnNpb24gZGF0YVxyXG5cdFx0JCQuZ2V0TGVnZW5kSXRlbVRleHRCb3goKTtcclxuXHJcblx0XHRyZXR1cm4gJCQudXBkYXRlRGF0YUF0dHJpYnV0ZXMoXCJuYW1lc1wiLCBuYW1lcyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgY29sb3JzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcblx0ICogQG1ldGhvZCBkYXRh4oCkY29sb3JzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGNvbG9ycyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgY29sb3JzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IGNvbG9ycyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgW2RhdGEuY29sb3JzXSguL09wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGNvbG9ycykuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBDb3JyZXNwb25kaW5nIGRhdGEgY29sb3IgdmFsdWUgYWNjb3JkaW5nIGl0cyBrZXkgdmFsdWUuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBjb2xvcnNcclxuXHQgKiBjaGFydC5kYXRhLmNvbG9ycygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwiIzAwYzczY1wiLCBkYXRhMjogXCIjZmE3MTcxXCJ9XHJcblx0ICpcclxuXHQgKiAvLyBVcGRhdGUgY29sb3JzXHJcblx0ICogY2hhcnQuZGF0YS5jb2xvcnMoe1xyXG5cdCAqICBkYXRhMTogXCIjRkZGRkZGXCIsXHJcblx0ICogIGRhdGEyOiBcIiMwMDAwMDBcIlxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGNvbG9yczogZnVuY3Rpb24oY29sb3JzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0+KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcyhcImNvbG9yc1wiLCBjb2xvcnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4ZXMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuXHQgKiAtICoqTk9URToqKiBJZiBhbGwgZGF0YSBpcyByZWxhdGVkIHRvIG9uZSBvZiB0aGUgYXhlcywgdGhlIGRvbWFpbiBvZiBheGlzIHdpdGhvdXQgcmVsYXRlZCBkYXRhIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGRvbWFpbiBmcm9tIHRoZSBheGlzIHdpdGggcmVsYXRlZCBkYXRhXHJcblx0ICogQG1ldGhvZCBkYXRh4oCkYXhlc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBheGVzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBheGVzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IGF4ZXMgd2lsbCBiZSByZXR1cm5lZC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSBDb3JyZXNwb25kaW5nIGF4ZXMgdmFsdWUgZm9yIGRhdGEsIGlmIHNwZWNpZmllZCBheGVzIHZhbHVlLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEuYXhlcygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwieVwifVxyXG5cdCAqXHJcblx0ICogLy8gVXBkYXRlIGF4ZXNcclxuXHQgKiBjaGFydC5kYXRhLmF4ZXMoe1xyXG5cdCAqICBkYXRhMTogXCJ5XCIsXHJcblx0ICogIGRhdGEyOiBcInkyXCJcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRheGVzOiBmdW5jdGlvbihheGVzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfT4pOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9IHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiYXhlc1wiLCBheGVzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG1pbmltdW0gZGF0YSB2YWx1ZSBib3VuZCB0byB0aGUgY2hhcnRcclxuXHQgKiBAbWV0aG9kIGRhdGHigKRtaW5cclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5taW4oKTtcclxuXHQgKiAvLyAtLT4gW3t4OiAwLCB2YWx1ZTogMzAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAwfSwgLi4uXVxyXG5cdCAqL1xyXG5cdG1pbjogZnVuY3Rpb24oKTogeyB4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIGlkOiBzdHJpbmcsIGluZGV4OiBudW1iZXIgfVtdIHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLmdldE1pbk1heERhdGEoKS5taW47XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBtYXhpbXVtIGRhdGEgdmFsdWUgYm91bmQgdG8gdGhlIGNoYXJ0XHJcblx0ICogQG1ldGhvZCBkYXRh4oCkbWF4XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHJldHVybiB7QXJyYXl9IERhdGEgb2JqZWN0c1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gR2V0IGN1cnJlbnQgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEubWF4KCk7XHJcblx0ICogLy8gLS0+IFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi5dXHJcblx0ICovXHJcblx0bWF4OiBmdW5jdGlvbigpOiB7eDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyLCBpZDogc3RyaW5nLCBpbmRleDogbnVtYmVyfVtdIHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLmdldE1pbk1heERhdGEoKS5tYXg7XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtkYXRhfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge25hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzfSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQge2lzRnVuY3Rpb24sIHRvQXJyYXksIGdldENzc1J1bGVzfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBFbmNvZGUgdG8gYmFzZTY0XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2tvL2RvY3MvV2ViL0FQSS9XaW5kb3dCYXNlNjQvQmFzZTY0X2VuY29kaW5nX2FuZF9kZWNvZGluZ1xyXG4gKi9cclxuY29uc3QgYjY0RW5jb2RlVW5pY29kZSA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiBidG9hKFxyXG5cdGVuY29kZVVSSUNvbXBvbmVudChzdHIpXHJcblx0XHQucmVwbGFjZSgvJShbMC05QS1GXXsyfSkvZywgKG1hdGNoLCBwOiBudW1iZXIgfCBzdHJpbmcpOiBzdHJpbmcgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoYDB4JHtwfWApKSlcclxuKTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0IHN2ZyBub2RlIHRvIGRhdGEgdXJsXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcclxuICogQHBhcmFtIHtvYmplY3R9IHNpemVcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gbm9kZVRvU3ZnRGF0YVVybChub2RlLCBzaXplKSB7XHJcblx0Y29uc3Qgc2VyaWFsaXplciA9IG5ldyBYTUxTZXJpYWxpemVyKCk7XHJcblx0Y29uc3QgY2xvbmUgPSBub2RlLmNsb25lTm9kZSh0cnVlKTtcclxuXHRjb25zdCBjc3NUZXh0ID0gZ2V0Q3NzUnVsZXModG9BcnJheShkb2N1bWVudC5zdHlsZVNoZWV0cykpXHJcblx0XHQuZmlsdGVyKChyOiBhbnkpOiBhbnlbXSA9PiByLmNzc1RleHQpXHJcblx0XHQubWFwKChyOiBhbnkpOiBhbnlbXT0+IHIuY3NzVGV4dCk7XHJcblxyXG5cdGNsb25lLnNldEF0dHJpYnV0ZShcInhtbG5zXCIsIGQzTmFtZXNwYWNlcy54aHRtbCk7XHJcblxyXG5cdGNvbnN0IG5vZGVYbWwgPSBzZXJpYWxpemVyLnNlcmlhbGl6ZVRvU3RyaW5nKGNsb25lKTtcclxuXHJcblx0Ly8gZXNjYXBlIGNzcyBmb3IgWE1MXHJcblx0Y29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcblxyXG5cdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzc1RleHQuam9pbihcIlxcblwiKSkpO1xyXG5cclxuXHRjb25zdCBzdHlsZVhtbCA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoc3R5bGUpO1xyXG5cclxuXHQvLyBmb3JlaWduT2JqZWN0IG5vdCBzdXBwb3J0ZWQgaW4gSUUxMSBhbmQgYmVsb3dcclxuXHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2hoODM0Njc1KHY9dnMuODUpLmFzcHhcclxuXHRjb25zdCBkYXRhU3RyID0gYDxzdmcgeG1sbnM9XCIke2QzTmFtZXNwYWNlcy5zdmd9XCIgd2lkdGg9XCIke3NpemUud2lkdGh9XCIgaGVpZ2h0PVwiJHtzaXplLmhlaWdodH1cIj5cclxuXHRcdFx0PGZvcmVpZ25PYmplY3Qgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiPlxyXG5cdFx0XHRcdCR7c3R5bGVYbWx9XHJcblx0XHRcdFx0JHtub2RlWG1sLnJlcGxhY2UoLyh1cmxcXCgpW14jXSsvZywgXCIkMVwiKX1cclxuXHRcdFx0PC9mb3JlaWduT2JqZWN0Pjwvc3ZnPmBcclxuXHRcdC5yZXBsYWNlKFwiL1xcbi9nXCIsIFwiJTBBXCIpO1xyXG5cclxuXHRyZXR1cm4gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtiNjRFbmNvZGVVbmljb2RlKGRhdGFTdHIpfWA7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBFeHBvcnQgY2hhcnQgYXMgYW4gaW1hZ2UuXHJcblx0ICogLSAqKk5PVEU6KipcclxuXHQgKiAgIC0gSUUxMSBhbmQgYmVsb3cgbm90IHdvcmsgcHJvcGVybHkgZHVlIHRvIHRoZSBsYWNrIG9mIHRoZSBmZWF0dXJlKDxhIGhyZWY9XCJodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2hoODM0Njc1KHY9dnMuODUpLmFzcHhcIj5mb3JlaWduT2JqZWN0PC9hPikgc3VwcG9ydFxyXG5cdCAqICAgLSBUaGUgYmFzaWMgQ1NTIGZpbGUoZXguIGJpbGxib2FyZC5jc3MpIHNob3VsZCBiZSBhdCBzYW1lIGRvbWFpbiBhcyBBUEkgY2FsbCBjb250ZXh0IHRvIGdldCBjb3JyZWN0IHN0eWxlZCBleHBvcnQgaW1hZ2UuXHJcblx0ICogQG1ldGhvZCBleHBvcnRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW21pbWVUeXBlPWltYWdlL3BuZ10gVGhlIGRlc2lyZWQgb3V0cHV0IGltYWdlIGZvcm1hdC4gKGV4LiAnaW1hZ2UvcG5nJyBmb3IgcG5nLCAnaW1hZ2UvanBlZycgZm9yIGpwZWcgZm9ybWF0KVxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBleHBvcnQgaXMgcmVhZHkuXHJcblx0ICogQHJldHVybiB7U3RyaW5nfSBkYXRhVVJJXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgY2hhcnQuZXhwb3J0KCk7XHJcblx0ICogIC8vIC0tPiBcImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOLi4uXCJcclxuXHQgKlxyXG5cdCAqICAvLyBJbml0aWFsaXplIHRoZSBkb3dubG9hZCBhdXRvbWF0aWNhbGx5XHJcblx0ICogIGNoYXJ0LmV4cG9ydChcImltYWdlL3BuZ1wiLCBkYXRhVXJsID0+IHtcclxuXHQgKiAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xyXG5cdCAqXHJcblx0ICogICAgIGxpbmsuZG93bmxvYWQgPSBgJHtEYXRlLm5vdygpfS5wbmdgO1xyXG5cdCAqICAgICBsaW5rLmhyZWYgPSBkYXRhVXJsO1xyXG5cdCAqICAgICBsaW5rLmlubmVySFRNTCA9IFwiRG93bmxvYWQgY2hhcnQgYXMgaW1hZ2VcIjtcclxuXHQgKlxyXG5cdCAqICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHRleHBvcnQobWltZVR5cGU/OiBzdHJpbmcsIGNhbGxiYWNrPzogKGRhdGFVcmw6IHN0cmluZykgPT4gdm9pZCk6IHN0cmluZyB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y3VycmVudFdpZHRoOiB3aWR0aCwgY3VycmVudEhlaWdodDogaGVpZ2h0fSA9ICQkLnN0YXRlO1xyXG5cdFx0Y29uc3Qgc2l6ZSA9IHt3aWR0aCwgaGVpZ2h0fTtcclxuXHRcdGNvbnN0IHN2Z0RhdGFVcmwgPSBub2RlVG9TdmdEYXRhVXJsKHRoaXMuZWxlbWVudCwgc2l6ZSk7XHJcblxyXG5cdFx0aWYgKGNhbGxiYWNrICYmIGlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XHJcblx0XHRcdGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG5cclxuXHRcdFx0aW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIjtcclxuXHRcdFx0aW1nLm9ubG9hZCA9ICgpID0+IHtcclxuXHRcdFx0XHRjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG5cdFx0XHRcdGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcblxyXG5cdFx0XHRcdGNhbnZhcy53aWR0aCA9IHNpemUud2lkdGg7XHJcblx0XHRcdFx0Y2FudmFzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xyXG5cdFx0XHRcdGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwKTtcclxuXHJcblx0XHRcdFx0Y2FsbGJhY2soY2FudmFzLnRvRGF0YVVSTChtaW1lVHlwZSkpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0aW1nLnNyYyA9IHN2Z0RhdGFVcmw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHN2Z0RhdGFVcmw7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBUaGlzIEFQSSBoaWdobGlnaHRzIHNwZWNpZmllZCB0YXJnZXRzIGFuZCBmYWRlIG91dCB0aGUgb3RoZXJzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSBoaWdobGlnaHRlZC5cclxuXHQgKiBAbWV0aG9kIGZvY3VzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1ZhbHVlIFRhcmdldCBpZHMgdG8gYmUgaGlnaGxpZ2h0ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gZGF0YTEgd2lsbCBiZSBoaWdobGlnaHRlZCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIGZhZGVkIG91dFxyXG5cdCAqICBjaGFydC5mb2N1cyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSBmYWRlZCBvdXRcclxuXHQgKiBjaGFydC5mb2N1cyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWRcclxuXHQgKiBjaGFydC5mb2N1cygpO1xyXG5cdCAqL1xyXG5cdGZvY3VzKHRhcmdldElkc1ZhbHVlPzogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkc1ZhbHVlKTtcclxuXHRcdGNvbnN0IGNhbmRpZGF0ZXMgPSAkJC4kZWwuc3ZnLnNlbGVjdEFsbChcclxuXHRcdFx0JCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcy5maWx0ZXIoJCQuaXNUYXJnZXRUb1Nob3csICQkKSlcclxuXHRcdCk7XHJcblxyXG5cdFx0dGhpcy5yZXZlcnQoKTtcclxuXHRcdHRoaXMuZGVmb2N1cygpO1xyXG5cclxuXHRcdGNhbmRpZGF0ZXMuY2xhc3NlZChDTEFTUy5mb2N1c2VkLCB0cnVlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgZmFsc2UpO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0JCQuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0XHQkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiZcclxuXHRcdFx0XHQkJC5tYXJrT3ZlcmxhcHBlZCh0YXJnZXRJZHNWYWx1ZSwgJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgdHJ1ZSk7XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcclxuXHRcdHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcyA9IHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVGhpcyBBUEkgZmFkZXMgb3V0IHNwZWNpZmllZCB0YXJnZXRzIGFuZCByZXZlcnRzIHRoZSBvdGhlcnMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIGZhZGVkIG91dC5cclxuXHQgKiBAbWV0aG9kIGRlZm9jdXNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gVGFyZ2V0IGlkcyB0byBiZSBmYWRlZCBvdXQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBkYXRhMSB3aWxsIGJlIGZhZGVkIG91dCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIGNoYXJ0LmRlZm9jdXMoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIGZhZGVkIG91dCBhbmQgdGhlIG90aGVycyB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIGNoYXJ0LmRlZm9jdXMoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIGZhZGVkIG91dC5cclxuXHQgKiBjaGFydC5kZWZvY3VzKCk7XHJcblx0ICovXHJcblx0ZGVmb2N1cyh0YXJnZXRJZHNWYWx1ZT86IHN0cmluZyB8IHN0cmluZ1tdKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuJGVsLnN2Zy5zZWxlY3RBbGwoXHJcblx0XHRcdCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpXHJcblx0XHQpO1xyXG5cclxuXHRcdGNhbmRpZGF0ZXMuY2xhc3NlZChDTEFTUy5mb2N1c2VkLCBmYWxzZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIHRydWUpO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0JCQudW5leHBhbmRBcmModGFyZ2V0SWRzKTtcclxuXHJcblx0XHRcdCQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJlxyXG5cdFx0XHRcdCQkLnVuZG9NYXJrT3ZlcmxhcHBlZCgkJCwgYC4ke0NMQVNTLmdhdWdlVmFsdWV9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudG9nZ2xlRm9jdXNMZWdlbmQodGFyZ2V0SWRzLCBmYWxzZSk7XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IHN0YXRlLmZvY3VzZWRUYXJnZXRJZHMuZmlsdGVyKGlkID0+IHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDApO1xyXG5cdFx0c3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzID0gdGFyZ2V0SWRzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgQVBJIHJldmVydHMgc3BlY2lmaWVkIHRhcmdldHMuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIEBtZXRob2QgcmV2ZXJ0XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFRhcmdldCBpZHMgdG8gYmUgcmV2ZXJ0ZWRcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGRhdGExIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQucmV2ZXJ0KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5yZXZlcnQoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIGNoYXJ0LnJldmVydCgpO1xyXG5cdCAqL1xyXG5cdHJldmVydCh0YXJnZXRJZHNWYWx1ZT86IHN0cmluZyB8IHN0cmluZ1tdKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICRlbC5zdmcuc2VsZWN0QWxsKCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMpKTsgLy8gc2hvdWxkIGJlIGZvciBhbGwgdGFyZ2V0c1xyXG5cclxuXHRcdGNhbmRpZGF0ZXMuY2xhc3NlZChDTEFTUy5mb2N1c2VkLCBmYWxzZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIGZhbHNlKTtcclxuXHRcdCQkLmhhc0FyY1R5cGUoKSAmJiAkJC51bmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0JCQuc2hvd0xlZ2VuZCh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzTGVnZW5kVG9TaG93LmJpbmQoJCQpKSk7XHJcblx0XHRcdCRlbC5sZWdlbmQuc2VsZWN0QWxsKCQkLnNlbGVjdG9yTGVnZW5kcyh0YXJnZXRJZHMpKVxyXG5cdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZmFsc2UpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmZvY3VzZWRUYXJnZXRJZHMgPSBbXTtcclxuXHRcdHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcyA9IFtdO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogRGVmaW5lIGxlZ2VuZFxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jb25zdCBsZWdlbmQgPSB7XHJcblx0LyoqXHJcblx0ICogU2hvdyBsZWdlbmQgZm9yIGVhY2ggdGFyZ2V0LlxyXG5cdCAqIEBtZXRob2QgbGVnZW5k4oCkc2hvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHNcclxuXHQgKiAtIElmIHRhcmdldElkcyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIHNob3duLlxyXG5cdCAqIC0gSWYgb25seSBvbmUgdGFyZ2V0IGlzIHRoZSBjYW5kaWRhdGUsIFN0cmluZyBjYW4gYmUgcGFzc2VkLlxyXG5cdCAqIC0gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBzaG93bi5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMS5cclxuXHQgKiBjaGFydC5sZWdlbmQuc2hvdyhcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gU2hvdyBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cclxuXHQgKiBjaGFydC5sZWdlbmQuc2hvdyhbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIFNob3cgYWxsIGxlZ2VuZC5cclxuXHQgKiBjaGFydC5sZWdlbmQuc2hvdygpO1xyXG5cdCAqL1xyXG5cdHNob3c6IGZ1bmN0aW9uKHRhcmdldElkcz86IHN0cmluZyB8IHN0cmluZ1tdKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0JCQuc2hvd0xlZ2VuZCgkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpKTtcclxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdyh7d2l0aExlZ2VuZDogdHJ1ZX0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgbGVnZW5kIGZvciBlYWNoIHRhcmdldC5cclxuXHQgKiBAbWV0aG9kIGxlZ2VuZOKApGhpZGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXHJcblx0ICogLSBJZiB0YXJnZXRJZHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uXHJcblx0ICogLSBJZiBvbmx5IG9uZSB0YXJnZXQgaXMgdGhlIGNhbmRpZGF0ZSwgU3RyaW5nIGNhbiBiZSBwYXNzZWQuXHJcblx0ICogLSBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldCdzIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEhpZGUgbGVnZW5kIGZvciBkYXRhMS5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZShcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gSGlkZSBsZWdlbmQgZm9yIGRhdGExIGFuZCBkYXRhMi5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZShbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIEhpZGUgYWxsIGxlZ2VuZC5cclxuXHQgKiBjaGFydC5sZWdlbmQuaGlkZSgpO1xyXG5cdCAqL1xyXG5cdGhpZGU6IGZ1bmN0aW9uKHRhcmdldElkcz86IHN0cmluZyB8IHN0cmluZ1tdKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0JCQuaGlkZUxlZ2VuZCgkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpKTtcclxuXHRcdCQkLnVwZGF0ZUFuZFJlZHJhdyh7d2l0aExlZ2VuZDogdHJ1ZX0pO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtsZWdlbmR9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNTdHJpbmcsIGlzQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIExvYWQgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXHJcblx0ICogLSA8Yj5Ob3RlOjwvYj5cclxuXHQgKiAgIC0gdW5sb2FkIHNob3VsZCBiZSB1c2VkIGlmIHNvbWUgZGF0YSBuZWVkcyB0byBiZSB1bmxvYWRlZCBzaW11bHRhbmVvdXNseS5cclxuXHQgKiAgICAgSWYgeW91IGNhbGwgdW5sb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSBsb2FkIGluc3RlYWQgb2YgdW5sb2FkIHBhcmFtLCBjaGFydCB3aWxsIG5vdCBiZSByZW5kZXJlZCBwcm9wZXJseSBiZWNhdXNlIG9mIGNhbmNlbCBvZiBhbmltYXRpb24uPGJyPlxyXG5cdCAqICAgLSBkb25lIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGRhdGEgbG9hZGVkLCBidXQgaXQncyBub3QgYWZ0ZXIgcmVuZGVyaW5nLlxyXG5cdCAqICAgICBJdCdzIGJlY2F1c2UgcmVuZGVyaW5nIHdpbGwgZmluaXNoIGFmdGVyIHNvbWUgdHJhbnNpdGlvbiBhbmQgdGhlcmUgaXMgc29tZSB0aW1lIGxhZyBiZXR3ZWVuIGxvYWRpbmcgYW5kIHJlbmRlcmluZ1xyXG5cdCAqIEBtZXRob2QgbG9hZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCAtIHVybDxicj4tIGpzb248YnI+LSByb3dzPGJyPi0gY29sdW1ucyB8IFRoZSBkYXRhIHdpbGwgYmUgbG9hZGVkLiBJZiBkYXRhIHRoYXQgaGFzIHRoZSBzYW1lIHRhcmdldCBpZCBpcyBnaXZlbiwgdGhlIGNoYXJ0IHdpbGwgYmUgdXBkYXRlZC4gT3RoZXJ3aXNlLCBuZXcgdGFyZ2V0IHdpbGwgYmUgYWRkZWQgfFxyXG5cdCAqICAgIHwgZGF0YSB8IERhdGEgb2JqZWN0cyB0byBiZSBsb2FkZWQuIENoZWNrb3V0IHRoZSBleGFtcGxlLiB8XHJcblx0ICogICAgfCBuYW1lcyB8IFNhbWUgYXMgZGF0YS5uYW1lcygpIHxcclxuXHQgKiAgICB8IHhzIHwgU2FtZSBhcyBkYXRhLnhzIG9wdGlvbiAgfFxyXG5cdCAqICAgIHwgY2xhc3NlcyB8IFRoZSBjbGFzc2VzIHNwZWNpZmllZCBieSBkYXRhLmNsYXNzZXMgd2lsbCBiZSB1cGRhdGVkLiBjbGFzc2VzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XHJcblx0ICogICAgfCBjYXRlZ29yaWVzIHwgVGhlIGNhdGVnb3JpZXMgc3BlY2lmaWVkIGJ5IGF4aXMueC5jYXRlZ29yaWVzIG9yIGRhdGEueCB3aWxsIGJlIHVwZGF0ZWQuIGNhdGVnb3JpZXMgbXVzdCBiZSBBcnJheS4gfFxyXG5cdCAqICAgIHwgYXhlcyB8IFRoZSBheGVzIHNwZWNpZmllZCBieSBkYXRhLmF4ZXMgd2lsbCBiZSB1cGRhdGVkLiBheGVzIG11c3QgYmUgT2JqZWN0IHRoYXQgaGFzIHRhcmdldCBpZCBhcyBrZXlzLiB8XHJcblx0ICogICAgfCBjb2xvcnMgfCBUaGUgY29sb3JzIHNwZWNpZmllZCBieSBkYXRhLmNvbG9ycyB3aWxsIGJlIHVwZGF0ZWQuIGNvbG9ycyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxyXG5cdCAqICAgIHwgaGVhZGVycyB8ICBTZXQgcmVxdWVzdCBoZWFkZXIgaWYgbG9hZGluZyB2aWEgYGRhdGEudXJsYC48YnI+QHNlZSBbZGF0YeKApGhlYWRlcnNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGhlYWRlcnMpIHxcclxuXHQgKiAgICB8IGtleXMgfCAgQ2hvb3NlIHdoaWNoIEpTT04gb2JqZWN0cyBrZXlzIGNvcnJlc3BvbmQgdG8gZGVzaXJlZCBkYXRhLjxicj4qKk5PVEU6KiogT25seSBmb3IgSlNPTiBvYmplY3QgZ2l2ZW4gYXMgYXJyYXkuPGJyPkBzZWUgW2RhdGHigKRrZXlzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRrZXlzKSB8XHJcblx0ICogICAgfCBtaW1lVHlwZSB8ICBTZXQgJ2pzb24nIGlmIGxvYWRpbmcgSlNPTiB2aWEgdXJsLjxicj5Ac2VlIFtkYXRh4oCkbWltZVR5cGVdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNG1pbWVUeXBlKSB8XHJcblx0ICogICAgfCAtIHR5cGU8YnI+LSB0eXBlcyB8IFRoZSB0eXBlIG9mIHRhcmdldHMgd2lsbCBiZSB1cGRhdGVkLiB0eXBlIG11c3QgYmUgU3RyaW5nIGFuZCB0eXBlcyBtdXN0IGJlIE9iamVjdC4gfFxyXG5cdCAqICAgIHwgdW5sb2FkIHwgU3BlY2lmeSB0aGUgZGF0YSB3aWxsIGJlIHVubG9hZGVkIGJlZm9yZSBsb2FkaW5nIG5ldyBkYXRhLiBJZiB0cnVlIGdpdmVuLCBhbGwgb2YgZGF0YSB3aWxsIGJlIHVubG9hZGVkLiBJZiB0YXJnZXQgaWRzIGdpdmVuIGFzIFN0cmluZyBvciBBcnJheSwgc3BlY2lmaWVkIHRhcmdldHMgd2lsbCBiZSB1bmxvYWRlZC4gSWYgYWJzZW50IG9yIGZhbHNlIGdpdmVuLCB1bmxvYWQgd2lsbCBub3Qgb2NjdXIuIHxcclxuXHQgKiAgICB8IGRvbmUgfCBUaGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGRhdGEgbG9hZGVkLnxcclxuXHQgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhRnJvbVVSTClcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIExvYWQgZGF0YTEgYW5kIHVubG9hZCBkYXRhMiBhbmQgZGF0YTNcclxuXHQgKiBjaGFydC5sb2FkKHtcclxuXHQgKiAgICAgY29sdW1uczogW1xyXG5cdCAqICAgICAgICBbXCJkYXRhMVwiLCAxMDAsIDIwMCwgMTUwLCAuLi5dLFxyXG5cdCAqICAgICAgICAuLi5cclxuXHQgKiAgICBdLFxyXG5cdCAqICAgIHVubG9hZDogW1wiZGF0YTJcIiwgXCJkYXRhM1wiXSxcclxuXHQgKiAgICB1cmw6IFwiLi4uXCIsXHJcblx0ICogICAgZG9uZTogZnVuY3Rpb24oKSB7IC4uLiB9XHJcblx0ICogfSk7XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBteUFQSS5qc29uXHJcblx0ICogLy8ge1xyXG5cdCAqIC8vICAgXCJkYXRhMVwiOiBbMjIwLCAyNDAsIDI3MCwgMjUwLCAyODBdLFxyXG5cdCAqIC8vICAgXCJkYXRhMlwiOiBbMTgwLCAxNTAsIDMwMCwgNzAsIDEyMF1cclxuXHQgKiAvLyB9XHJcblx0ICpcclxuXHQgKiBjaGFydC5sb2FkKHtcclxuXHQgKiAgICAgdXJsOiAnLi9kYXRhL215QVBJLmpzb24nLFxyXG5cdCAqICAgICBtaW1lVHlwZTogXCJqc29uXCIsXHJcblx0ICpcclxuXHQgKiAgICAgLy8gc2V0IHJlcXVlc3QgaGVhZGVyIGlmIGlzIG5lZWRlZFxyXG5cdCAqICAgICBoZWFkZXJzOiB7XHJcblx0ICogICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2pzb25cIlxyXG5cdCAqICAgICB9XHJcblx0ICogfSk7XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiBjaGFydC5sb2FkKHtcclxuXHQgKiAgICAgZGF0YTogW1xyXG5cdCAqICAgICAgIC8vIGVxdWl2YWxlbnQgYXM6IGNvbHVtbnM6IFtbXCJkYXRhMVwiLCAzMCwgMjAwLCAxMDBdXVxyXG5cdCAqICAgICAgIHtcImRhdGExXCI6IDMwfSwge1wiZGF0YTFcIjogMjAwfSwge1wiZGF0YTFcIjogMTAwfVxyXG5cdCAqXHJcblx0ICogICAgICAgLy8gb3JcclxuXHQgKiAgICAgICAvLyBlcXVpdmFsZW50IGFzOiBjb2x1bW5zOiBbW1wiZGF0YTFcIiwgMTAsIDIwXSwgW1wiZGF0YTJcIiwgMTMsIDMwXV1cclxuXHQgKiAgICAgICAvLyB7XCJkYXRhMVwiOiAxMCwgXCJkYXRhMlwiOiAxM30sIHtcImRhdGExXCI6IDIwLCBcImRhdGEyXCI6IDMwfX1cclxuXHQgKiAgICAgXVxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGxvYWQoYXJncykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHQvLyB1cGRhdGUgeHMgaWYgc3BlY2lmaWVkXHJcblx0XHRhcmdzLnhzICYmICQkLmFkZFhzKGFyZ3MueHMpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBuYW1lcyBpZiBleGlzdHNcclxuXHRcdFwibmFtZXNcIiBpbiBhcmdzICYmIHRoaXMuZGF0YS5uYW1lcyhhcmdzLm5hbWVzKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2xhc3NlcyBpZiBleGlzdHNcclxuXHRcdFwiY2xhc3Nlc1wiIGluIGFyZ3MgJiYgT2JqZWN0LmtleXMoYXJncy5jbGFzc2VzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfY2xhc3Nlc1tpZF0gPSBhcmdzLmNsYXNzZXNbaWRdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNhdGVnb3JpZXMgaWYgZXhpc3RzXHJcblx0XHRpZiAoXCJjYXRlZ29yaWVzXCIgaW4gYXJncyAmJiAkJC5pc0NhdGVnb3JpemVkKCkpIHtcclxuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gYXJncy5jYXRlZ29yaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBheGVzIGlmIGV4aXN0c1xyXG5cdFx0XCJheGVzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmF4ZXMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25maWcuZGF0YV9heGVzW2lkXSA9IGFyZ3MuYXhlc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY29sb3JzIGlmIGV4aXN0c1xyXG5cdFx0XCJjb2xvcnNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuY29sb3JzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfY29sb3JzW2lkXSA9IGFyZ3MuY29sb3JzW2lkXTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIHVubG9hZCBpZiBuZWVkZWRcclxuXHRcdGlmIChcInVubG9hZFwiIGluIGFyZ3MgJiYgYXJncy51bmxvYWQgIT09IGZhbHNlKSB7XHJcblx0XHRcdC8vIFRPRE86IGRvIG5vdCB1bmxvYWQgaWYgdGFyZ2V0IHdpbGwgbG9hZCAoaW5jbHVkZWQgaW4gdXJsL3Jvd3MvY29sdW1ucylcclxuXHRcdFx0JCQudW5sb2FkKCQkLm1hcFRvVGFyZ2V0SWRzKGFyZ3MudW5sb2FkID09PSB0cnVlID8gbnVsbCA6IGFyZ3MudW5sb2FkKSwgKCkgPT5cclxuXHRcdFx0XHQkJC5sb2FkRnJvbUFyZ3MoYXJncylcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLmxvYWRGcm9tQXJncyhhcmdzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbmxvYWQgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXHJcblx0ICogLSA8Yj5Ob3RlOjwvYj5cclxuXHQgKiBJZiB5b3UgY2FsbCBsb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSB1bmxvYWQsIHVubG9hZCBwYXJhbSBvZiBsb2FkIHNob3VsZCBiZSB1c2VkLiBPdGhlcndpc2UgY2hhcnQgd2lsbCBub3QgYmUgcmVuZGVyZWQgcHJvcGVybHkgYmVjYXVzZSBvZiBjYW5jZWwgb2YgYW5pbWF0aW9uLjxicj5cclxuXHQgKiBgZG9uZWAgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQsIGJ1dCBpdCdzIG5vdCBhZnRlciByZW5kZXJpbmcuIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nLlxyXG5cdCAqIEBtZXRob2QgdW5sb2FkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcclxuXHQgKiAgfCBrZXkgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogIHwgaWRzIHwgU3RyaW5nICZ2ZXJ0OyBBcnJheSB8IFRhcmdldCBpZCBkYXRhIHRvIGJlIHVubG9hZGVkLiBJZiBub3QgZ2l2ZW4sIGFsbCBkYXRhIHdpbGwgYmUgdW5sb2FkZWQuIHxcclxuXHQgKiAgfCBkb25lIHwgRnVjdGlvbiB8IENhbGxiYWNrIGFmdGVyIGRhdGEgaXMgdW5sb2FkZWQuIHxcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBVbmxvYWQgZGF0YTIgYW5kIGRhdGEzXHJcblx0ICogIGNoYXJ0LnVubG9hZCh7XHJcblx0ICogICAgaWRzOiBbXCJkYXRhMlwiLCBcImRhdGEzXCJdLFxyXG5cdCAqICAgIGRvbmU6IGZ1bmN0aW9uKCkge1xyXG5cdCAqICAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgdW5sb2FkZWRcclxuXHQgKiAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdHVubG9hZChhcmdzVmFsdWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGxldCBhcmdzID0gYXJnc1ZhbHVlIHx8IHt9O1xyXG5cclxuXHRcdGlmIChpc0FycmF5KGFyZ3MpKSB7XHJcblx0XHRcdGFyZ3MgPSB7aWRzOiBhcmdzfTtcclxuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoYXJncykpIHtcclxuXHRcdFx0YXJncyA9IHtpZHM6IFthcmdzXX07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaWRzID0gJCQubWFwVG9UYXJnZXRJZHMoYXJncy5pZHMpO1xyXG5cclxuXHRcdCQkLnVubG9hZChpZHMsICgpID0+IHtcclxuXHRcdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuY2FjaGUucmVtb3ZlKGlkcyk7XHJcblx0XHRcdGFyZ3MuZG9uZSAmJiBhcmdzLmRvbmUoKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFNob3cvSGlkZSBkYXRhIHNlcmllc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gc2hvd0hpZGUoc2hvdywgdGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMpIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xyXG5cclxuXHQkJFtgJHtzaG93ID8gXCJyZW1vdmVcIiA6IFwiYWRkXCJ9SGlkZGVuVGFyZ2V0SWRzYF0odGFyZ2V0SWRzKTtcclxuXHRjb25zdCB0YXJnZXRzID0gJCQuJGVsLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpO1xyXG5cdGNvbnN0IG9wYWNpdHkgPSBzaG93ID8gXCIxXCIgOiBcIjBcIjtcclxuXHJcblx0dGFyZ2V0cy50cmFuc2l0aW9uKClcclxuXHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSwgXCJpbXBvcnRhbnRcIilcclxuXHRcdC5jYWxsKCQkLmVuZGFsbCwgKCkgPT4ge1xyXG5cdFx0XHR0YXJnZXRzLnN0eWxlKFwib3BhY2l0eVwiLCBudWxsKS5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XHJcblx0XHR9KTtcclxuXHJcblx0b3B0aW9ucy53aXRoTGVnZW5kICYmICQkW2Ake3Nob3cgPyBcInNob3dcIiA6IFwiaGlkZVwifUxlZ2VuZGBdKHRhcmdldElkcyk7XHJcblxyXG5cdCQkLnJlZHJhdyh7XHJcblx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0d2l0aExlZ2VuZDogdHJ1ZVxyXG5cdH0pO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2hvdyBkYXRhIHNlcmllcyBvbiBjaGFydFxyXG5cdCAqIEBtZXRob2Qgc2hvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWVdIFRoZSB0YXJnZXQgaWQgdmFsdWUuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgZGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuXHQgKiAgICB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogICAgfCB3aXRoTGVnZW5kIHwgQm9vbGVhbiB8IGZhbHNlIHwgd2hldGhlciBvciBub3QgZGlzcGxheSBsZWdlbmQgfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBzaG93ICdkYXRhMSdcclxuXHQgKiBjaGFydC5zaG93KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBzaG93ICdkYXRhMScgYW5kICdkYXRhMydcclxuXHQgKiBjaGFydC5zaG93KFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdHNob3codGFyZ2V0SWRzVmFsdWU/OiBzdHJpbmdbXSB8IHN0cmluZywgb3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzaG93SGlkZS5jYWxsKHRoaXMsIHRydWUsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGRhdGEgc2VyaWVzIGZyb20gY2hhcnRcclxuXHQgKiBAbWV0aG9kIGhpZGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3RhcmdldElkc1ZhbHVlPWFsbF0gVGhlIHRhcmdldCBpZCB2YWx1ZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBkZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XHJcblx0ICpcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIGhpZGUgJ2RhdGExJ1xyXG5cdCAqIGNoYXJ0LmhpZGUoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIGhpZGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xyXG5cdCAqIGNoYXJ0LmhpZGUoW1wiZGF0YTFcIiwgXCJkYXRhM1wiXSk7XHJcblx0ICovXHJcblx0aGlkZSh0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyA9IHt9KSB7XHJcblx0XHRzaG93SGlkZS5jYWxsKHRoaXMsIGZhbHNlLCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlIGRhdGEgc2VyaWVzIG9uIGNoYXJ0LiBXaGVuIHRhcmdldCBkYXRhIGlzIGhpZGRlbiwgaXQgd2lsbCBzaG93LiBJZiBpcyBzaG93biwgaXQgd2lsbCBoaWRlIGluIHZpY2UgdmVyc2EuXHJcblx0ICogQG1ldGhvZCB0b2dnbGVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gW3RhcmdldElkc1ZhbHVlPWFsbF0gVGhlIHRhcmdldCBpZCB2YWx1ZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBkZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XHJcblx0ICpcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHRvZ2dsZSAnZGF0YTEnXHJcblx0ICogY2hhcnQudG9nZ2xlKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyB0b2dnbGUgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xyXG5cdCAqIGNoYXJ0LnRvZ2dsZShbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcclxuXHQgKi9cclxuXHR0b2dnbGUodGFyZ2V0SWRzLCBvcHRpb25zID0ge30pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSB7c2hvdzogW10sIGhpZGU6IFtdfTtcclxuXHJcblx0XHQvLyBzb3J0IHNob3cgJiBoaWRlIHRhcmdldCBpZHNcclxuXHRcdCQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcylcclxuXHRcdFx0LmZvckVhY2goKGlkOiBzdHJpbmcpID0+IHRhcmdldHNbJCQuaXNUYXJnZXRUb1Nob3coaWQpID8gXCJoaWRlXCIgOiBcInNob3dcIl0ucHVzaChpZCkpO1xyXG5cclxuXHRcdC8vIHBlcmZvcm0gc2hvdyAmIGhpZGUgdGFzayBzZXBhcmF0ZWx5XHJcblx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy80NTRcclxuXHRcdHRhcmdldHMuc2hvdy5sZW5ndGggJiYgdGhpcy5zaG93KHRhcmdldHMuc2hvdywgb3B0aW9ucyk7XHJcblx0XHR0YXJnZXRzLmhpZGUubGVuZ3RoICYmIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5oaWRlKHRhcmdldHMuaGlkZSwgb3B0aW9ucyksIDApO1xyXG5cdH1cclxufTtcclxuXHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc1ZhbHVlLCBpc0RlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIERlZmluZSB0b29sdGlwXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNvbnN0IHRvb2x0aXAgPSB7XHJcblx0LyoqXHJcblx0ICogU2hvdyB0b29sdGlwXHJcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkc2hvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgaW5kZXggfCBOdW1iZXIgfCBEZXRlcm1pbmUgZm9jdXMgYnkgaW5kZXggfFxyXG5cdCAqICAgIHwgeCB8IE51bWJlciAmdmVydDsgRGF0ZSB8IERldGVybWluZSBmb2N1cyBieSB4IEF4aXMgaW5kZXggfFxyXG5cdCAqICAgIHwgbW91c2UgfCBBcnJheSB8IERldGVybWluZSB4IGFuZCB5IGNvb3JkaW5hdGUgdmFsdWUgcmVsYXRpdmUgdGhlIHRhcmdldGVkICcuYmItZXZlbnQtcmVjdCcgeCBBeGlzLjxicj5JdCBzaG91bGQgYmUgdXNlZCBhbG9uZyB3aXRoIGBkYXRhYCwgYGluZGV4YCBvciBgeGAgdmFsdWUuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHNldCBhcyBgWzAsMF1gIHxcclxuXHQgKiAgICB8IGRhdGEgfCBPYmplY3QgfCBXaGVuIFtkYXRhLnhzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTR4cykgb3B0aW9uIGlzIHVzZWQgb3IgW3Rvb2x0aXAuZ3JvdXBlZF0oT3B0aW9ucy5odG1sIy50b29sdGlwKSBzZXQgdG8gJ2ZhbHNlJywgYHNob3VsZCBiZSB1c2VkIGdpdmluZyB0aGlzIHBhcmFtYC48YnI+PGJyPioqS2V5OioqPGJyPi0geCB7TnVtYmVyICZ2ZXJiYXI7IERhdGV9OiB4IEF4aXMgdmFsdWU8YnI+LSBpbmRleCB7TnVtYmVyfTogeCBBeGlzIGluZGV4ICh1c2VsZXNzIGZvciBkYXRhLnhzKTxicj4tIGlkIHtTdHJpbmd9OiBkYXRhIGlkPGJyPi0gdmFsdWUge051bWJlcn06IFRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIGZvciB0b29sdGlwLiB8XHJcblx0ICpcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBzaG93IHRoZSAybmQgeCBBeGlzIGNvb3JkaW5hdGUgdG9vbHRpcFxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIGluZGV4OiAxXHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHNob3cgdG9vbHRpcCBmb3IgdGhlIDNyZCB4IEF4aXMgaW4geDo1MCBhbmQgeToxMDAgY29vcmRpbmF0ZSBvZiAnLmJiLWV2ZW50LXJlY3QnIG9mIHRoZSB4IEF4aXMuXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgeDogMixcclxuXHQgKiAgICBtb3VzZTogWzUwLCAxMDBdXHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHNob3cgdG9vbHRpcCBmb3IgdGltZXNlcmllcyB4IGF4aXNcclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICB4OiBuZXcgRGF0ZShcIjIwMTgtMDEtMDIgMDA6MDBcIilcclxuXHQgKiAgfSk7XHJcblx0ICpcclxuXHQgKiAgLy8gd2hlbiBkYXRhLnhzIGlzIHVzZWRcclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICBkYXRhOiB7XHJcblx0ICogICAgICAgIHg6IDMsICAvLyB4IEF4aXMgdmFsdWVcclxuXHQgKiAgICAgICAgaWQ6IFwiZGF0YTFcIiwgIC8vIGRhdGEgaWRcclxuXHQgKiAgICAgICAgdmFsdWU6IDUwMCAgLy8gZGF0YSB2YWx1ZVxyXG5cdCAqICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICpcclxuXHQgKiAgLy8gd2hlbiBkYXRhLnhzIGlzbid0IHVzZWQsIGJ1dCB0b29sdGlwLmdyb3VwZWQ9ZmFsc2UgaXMgc2V0XHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgZGF0YToge1xyXG5cdCAqICAgICAgICBpbmRleDogMywgIC8vIG9yICd4JyBrZXkgdmFsdWVcclxuXHQgKiAgICAgICAgaWQ6IFwiZGF0YTFcIiwgIC8vIGRhdGEgaWRcclxuXHQgKiAgICAgICAgdmFsdWU6IDUwMCAgLy8gZGF0YSB2YWx1ZVxyXG5cdCAqICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICovXHJcblx0c2hvdzogZnVuY3Rpb24oYXJncykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtpbnB1dFR5cGV9fSA9ICQkO1xyXG5cdFx0bGV0IGluZGV4O1xyXG5cdFx0bGV0IG1vdXNlO1xyXG5cclxuXHRcdC8vIGRldGVybWluZSBtb3VzZSBwb3NpdGlvbiBvbiB0aGUgY2hhcnRcclxuXHRcdGlmIChhcmdzLm1vdXNlKSB7XHJcblx0XHRcdG1vdXNlID0gYXJncy5tb3VzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgZm9jdXMgZGF0YVxyXG5cdFx0aWYgKGFyZ3MuZGF0YSkge1xyXG5cdFx0XHRjb25zdCB5ID0gJCQuZ2V0WVNjYWxlKGFyZ3MuZGF0YS5pZCkoYXJncy5kYXRhLnZhbHVlKTtcclxuXHJcblx0XHRcdGlmICgkJC5pc011bHRpcGxlWCgpKSB7XHJcblx0XHRcdFx0Ly8gaWYgbXVsdGlwbGUgeHMsIHRhcmdldCBwb2ludCB3aWxsIGJlIGRldGVybWluZWQgYnkgbW91c2VcclxuXHRcdFx0XHRtb3VzZSA9IFskJC5zY2FsZS54KGFyZ3MuZGF0YS54KSwgeV07XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKCFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0XHRtb3VzZSA9IFswLCB5XTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGluZGV4ID0gaXNWYWx1ZShhcmdzLmRhdGEuaW5kZXgpID8gYXJncy5kYXRhLmluZGV4IDogJCQuZ2V0SW5kZXhCeVgoYXJncy5kYXRhLngpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLngpKSB7XHJcblx0XHRcdGluZGV4ID0gJCQuZ2V0SW5kZXhCeVgoYXJncy54KTtcclxuXHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKGFyZ3MuaW5kZXgpKSB7XHJcblx0XHRcdGluZGV4ID0gYXJncy5pbmRleDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBlbXVsYXRlIGV2ZW50cyB0byBzaG93XHJcblx0XHQoaW5wdXRUeXBlID09PSBcIm1vdXNlXCIgP1xyXG5cdFx0XHRbXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW1vdmVcIl0gOiBbXCJ0b3VjaHN0YXJ0XCJdXHJcblx0XHQpLmZvckVhY2goZXZlbnROYW1lID0+IHtcclxuXHRcdFx0JCQuZGlzcGF0Y2hFdmVudChldmVudE5hbWUsIGluZGV4LCBtb3VzZSk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIHRvb2x0aXBcclxuXHQgKiBAbWV0aG9kIHRvb2x0aXDigKRoaWRlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICovXHJcblx0aGlkZTogZnVuY3Rpb24oKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0JCQuaGlkZVRvb2x0aXAodHJ1ZSk7XHJcblx0XHQkJC5oaWRlR3JpZEZvY3VzKCk7XHJcblx0XHQkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHRcdCQkLnVuZXhwYW5kQmFycygpO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHt0b29sdGlwfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vQ2hhcnRJbnRlcm5hbC9DaGFydEludGVybmFsXCI7XHJcbmltcG9ydCB7VFlQRVN9IGZyb20gXCIuLi9jb25maWcvY29uc3RcIjtcclxuaW1wb3J0IHtsb2FkQ29uZmlnfSBmcm9tIFwiLi4vY29uZmlnL2NvbmZpZ1wiO1xyXG5pbXBvcnQge2V4dGVuZCwgaXNGdW5jdGlvbn0gZnJvbSBcIi4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5pbXBvcnQgYXBpQ2hhcnQgZnJvbSBcIi4vYXBpL2NoYXJ0XCI7XHJcbmltcG9ydCBhcGlDb2xvciBmcm9tIFwiLi9hcGkvY29sb3JcIjtcclxuaW1wb3J0IGFwaURhdGEgZnJvbSBcIi4vYXBpL2RhdGFcIjtcclxuaW1wb3J0IGFwaUV4cG9ydCBmcm9tIFwiLi9hcGkvZXhwb3J0XCI7XHJcbmltcG9ydCBhcGlGb2N1cyBmcm9tIFwiLi9hcGkvZm9jdXNcIjtcclxuaW1wb3J0IGFwaUxlZ2VuZCBmcm9tIFwiLi9hcGkvbGVnZW5kXCI7XHJcbmltcG9ydCBhcGlMb2FkIGZyb20gXCIuL2FwaS9sb2FkXCI7XHJcbmltcG9ydCBhcGlTaG93IGZyb20gXCIuL2FwaS9zaG93XCI7XHJcbmltcG9ydCBhcGlUb29sdGlwIGZyb20gXCIuL2FwaS90b29sdGlwXCI7XHJcblxyXG5pbXBvcnQgbW9kdWxlQXhpcyBmcm9tIFwiLi4vY29uZmlnL3Jlc29sdmVyL2F4aXNcIjtcclxuXHJcbi8qKlxyXG4gKiBNYWluIGNoYXJ0IGNsYXNzLlxyXG4gKiAtIE5vdGU6IEluc3RhbnRpYXRlZCB2aWEgYGJiLmdlbmVyYXRlKClgLlxyXG4gKiBAY2xhc3MgQ2hhcnRcclxuICogQGV4YW1wbGVcclxuICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xyXG4gKiAgZGF0YToge1xyXG4gKiAgICBjb2x1bW5zOiBbXHJcbiAqXHQgICAgW1wieFwiLCBcIjIwMTUtMTEtMDJcIiwgXCIyMDE1LTEyLTAxXCIsIFwiMjAxNi0wMS0wMVwiLCBcIjIwMTYtMDItMDFcIiwgXCIyMDE2LTAzLTAxXCJdLFxyXG4gKiBcdCAgICBbXCJjb3VudDFcIiwgMTEsIDgsIDcsIDYsIDUgXSxcclxuICpcdCAgICBbXCJjb3VudDJcIiwgOSwgMywgNiwgMiwgOCBdXHJcbiAqICAgXX1cclxuICogfVxyXG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gZm9yIHRoZSBpbml0aWFsaXphdGlvbi5cclxuKi9cclxuLyoqXHJcbiAqIEFjY2VzcyBpbnN0YW5jZSdzIHByaW1hcnkgbm9kZSBlbGVtZW50c1xyXG4gKiBAbWVtYmVyIHtPYmplY3R9ICRcclxuICogQHByb3BlcnR5IHtPYmplY3R9ICRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuY2hhcnQgV3JhcHBlciBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnN2ZyBNYWluIHN2ZyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmRlZnMgRGVmaW5pdGlvbiBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLm1haW4gTWFpbiBncm91cGluZyBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRvb2x0aXAgVG9vbHRpcCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxlZ2VuZCBMZWdlbmQgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50aXRsZSBUaXRsZSBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmdyaWQgR3JpZCBlbGVtZW50XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmFyYyBBcmMgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gJC5iYXJcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQuYmFyLmJhcnMgQmFyIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkLmxpbmVcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGluZS5saW5lcyBMaW5lIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUuYXJlYXMgQXJlYXMgZWxlbWVudHNcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQubGluZS5jaXJjbGVzIERhdGEgcG9pbnQgY2lyY2xlIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkLnRleHRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudGV4dC50ZXh0cyBEYXRhIGxhYmVsIHRleHQgZWxlbWVudHNcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHsgLi4uIH0pO1xyXG4gKlxyXG4gKiBjaGFydC4kLmNoYXJ0OyAvLyB3cmFwcGVyIGVsZW1lbnRcclxuICogY2hhcnQuJC5saW5lLmNpcmNsZXM7ICAvLyBhbGwgZGF0YSBwb2ludCBjaXJjbGUgZWxlbWVudHNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENoYXJ0IHtcclxuXHQvKipcclxuXHQgKiBQbHVnaW4gaW5zdGFuY2UgYXJyYXlcclxuXHQgKiBAbWVtYmVyIHtBcnJheX0gcGx1Z2luc1xyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuXHQgKiAgICAgLi4uXHJcblx0ICogICAgIHBsdWdpbnM6IFtcclxuXHQgKiAgICAgICAgbmV3IGJiLnBsdWdpbi5zdGFuZm9yZCh7IC4uLiB9KSxcclxuXHQgKiAgICAgICAgbmV3IFBsdWdpbkEoKVxyXG5cdCAqICAgICBdXHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIGNoYXJ0LnBsdWdpbnM7IC8vIFtTdGFuZm9yZCwgUGx1Z2luQV0gLSBpbnN0YW5jZSBhcnJheVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBwbHVnaW5zID0gW107XHJcblx0cHVibGljIGludGVybmFsOiBDaGFydEludGVybmFsO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcblx0XHRjb25zdCBjdHggPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3R5cGUsIHR5cGVzfSA9IG9wdGlvbnMuZGF0YTtcclxuXHRcdC8vIGxldCBpc0FyYyA9IGZhbHNlO1xyXG5cclxuXHRcdC8vIGlmICh0eXBlKSB7XHJcblx0XHQvLyBcdGlzQXJjID0gVFlQRVMuQXJjLmluZGV4T2YodHlwZSkgPiAtMTtcclxuXHRcdC8vIH0gZWxzZSBpZiAodHlwZXMpIHtcclxuXHRcdC8vIFx0Zm9yIChjb25zdCB4IGluIHR5cGVzKSB7XHJcblx0XHQvLyBcdFx0aWYgKFRZUEVTLkFyYy5pbmRleE9mKHR5cGVzW3hdKSA+IC0xKSB7XHJcblx0XHQvLyBcdFx0XHRpc0FyYyA9IHRydWU7XHJcblx0XHQvLyBcdFx0XHRicmVhaztcclxuXHRcdC8vIFx0XHR9XHJcblx0XHQvLyBcdH1cclxuXHRcdC8vIH1cclxuXHJcblx0XHRjb25zdCAkJCA9IG5ldyBDaGFydEludGVybmFsKGN0eCk7XHJcblxyXG5cdFx0dGhpcy5pbnRlcm5hbCA9ICQkO1xyXG5cclxuXHRcdC8vIGJpbmQgdG8gbmFtZXNwYWNlZCBBUElzXHJcblx0XHQoZnVuY3Rpb24gYmluZFRoaXMoZm4sIHRhcmdldCwgYXJnVGhpcykge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhmbikuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGlzRnVuYyA9IGlzRnVuY3Rpb24oZm5ba2V5XSk7XHJcblx0XHRcdFx0Y29uc3QgaXNDaGlsZCA9IHRhcmdldCAhPT0gYXJnVGhpcztcclxuXHRcdFx0XHRjb25zdCBoYXNDaGlsZCA9IE9iamVjdC5rZXlzKGZuW2tleV0pLmxlbmd0aCA+IDA7XHJcblxyXG5cdFx0XHRcdGlmIChpc0Z1bmMgJiYgKCghaXNDaGlsZCAmJiBoYXNDaGlsZCkgfHwgaXNDaGlsZCkpIHtcclxuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gZm5ba2V5XS5iaW5kKGFyZ1RoaXMpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIWlzRnVuYykge1xyXG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSB7fTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGhhc0NoaWxkICYmIGJpbmRUaGlzKGZuW2tleV0sIHRhcmdldFtrZXldLCBhcmdUaGlzKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KShDaGFydC5wcm90b3R5cGUsIHRoaXMsIHRoaXMpO1xyXG5cclxuXHRcdGxvYWRDb25maWcuY2FsbCgkJCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0JCQuYmVmb3JlSW5pdCgpO1xyXG5cdFx0JCQuaW5pdCgpO1xyXG5cdFx0JCQuYWZ0ZXJJbml0KCk7XHJcblx0fVxyXG59XHJcblxyXG4vLyBleHRlbmQgY29tbW9uIEFQSXMgYXMgcGFydCBvZiBDaGFydCBjbGFzc1xyXG5leHRlbmQoQ2hhcnQucHJvdG90eXBlLCBbXHJcblx0YXBpQ2hhcnQsXHJcblx0YXBpQ29sb3IsXHJcblx0YXBpRGF0YSxcclxuXHRhcGlFeHBvcnQsXHJcblx0YXBpRm9jdXMsXHJcblx0YXBpTGVnZW5kLFxyXG5cdGFwaUxvYWQsXHJcblx0YXBpU2hvdyxcclxuXHRhcGlUb29sdGlwLFxyXG5cdC4uLm1vZHVsZUF4aXMuYXBpXHJcbl0pO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydC9DaGFydFwiO1xyXG5pbXBvcnQge2lzT2JqZWN0LCBtZXJnZU9ian0gZnJvbSBcIi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2UtYmVmb3JlLWRlZmluZVxyXG5leHBvcnQge2JiLCBiYiBhcyBkZWZhdWx0fTtcclxuXHJcbmxldCBkZWZhdWx0cyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgYmJcclxuICogQHZlcnNpb24gMi4wLjAtYWxwaGFcclxuICovXHJcbmNvbnN0IGJiID0ge1xyXG5cdC8qKlxyXG5cdCAqIFZlcnNpb24gaW5mb3JtYXRpb25cclxuXHQgKiBAcHJvcGVydHkge1N0cmluZ30gdmVyc2lvbiB2ZXJzaW9uXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgICBiYi52ZXJzaW9uOyAgLy8gXCIxLjAuMFwiXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICovXHJcblx0dmVyc2lvbjogXCIyLjAuMC1hbHBoYVwiLFxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSBjaGFydFxyXG5cdCAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBjaGFydCBvcHRpb25zXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICogQHJldHVybiB7Q2hhcnR9XHJcblx0ICogQHNlZSB7QGxpbmsgT3B0aW9uc30gZm9yIGRpZmZlcmVudCBnZW5lcmF0aW9uIG9wdGlvbnNcclxuXHQgKiBAc2VlIHtAbGluayBDaGFydH0gZm9yIGRpZmZlcmVudCBtZXRob2RzIEFQSVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIDwhLS0gY2hhcnQgaG9sZGVyIC0tPlxyXG5cdCAqIDxkaXYgaWQ9XCJMaW5lQ2hhcnRcIj48L2Rpdj5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAgLy8gZ2VuZXJhdGUgY2hhcnQgd2l0aCBvcHRpb25zXHJcblx0ICogIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuXHQgKiAgICAgIFwiYmluZHRvXCI6IFwiI0xpbmVDaGFydFwiXHJcblx0ICogICAgICBcImRhdGFcIjoge1xyXG5cdCAqICAgICAgICAgIFwiY29sdW1uc1wiOiBbXHJcblx0ICogICAgICAgICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMCwgNDAwLCAxNTAsIDI1MF0sXHJcblx0ICogICAgICAgICAgICAgIFtcImRhdGEyXCIsIDUwLCAyMCwgMTAsIDQwLCAxNSwgMjVdXHJcblx0ICogICAgICAgICAgIF1cclxuXHQgKiAgICAgIH1cclxuXHQgKiAgfSk7XHJcblx0ICpcclxuXHQgKiAgLy8gY2FsbCBzb21lIEFQSVxyXG5cdCAqICAvLyBleCkgZ2V0IHRoZSBkYXRhIG9mICdkYXRhMSdcclxuXHQgKiAgY2hhcnQuZGF0YShcImRhdGExXCIpO1xyXG5cdCAqL1xyXG5cdGdlbmVyYXRlKGNvbmZpZykge1xyXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IG1lcmdlT2JqKHt9LCBkZWZhdWx0cywgY29uZmlnKTtcclxuXHRcdGNvbnN0IGluc3QgPSBuZXcgQ2hhcnQob3B0aW9ucyk7XHJcblxyXG5cdFx0aW5zdC5pbnRlcm5hbC5jaGFydHMgPSB0aGlzLmluc3RhbmNlO1xyXG5cdFx0dGhpcy5pbnN0YW5jZS5wdXNoKGluc3QpO1xyXG5cclxuXHRcdHJldHVybiBpbnN0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBvciBnZXQgZ2xvYmFsIGRlZmF1bHQgb3B0aW9ucy5cclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgLSBUaGUgb3B0aW9ucyB2YWx1ZXMgc2V0dGluZ3MgYXJlIHZhbGlkIHdpdGhpbiBwYWdlIGNvbnRleHQgb25seS5cclxuXHQgKiAgIC0gSWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCB3aWxsIG92ZXJyaWRlIHRoZSBsYXN0IHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBjaGFydCBvcHRpb25zXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICogQHJldHVybiB7T3B0aW9uc31cclxuXHQgKiBAc2VlIHtAbGluayBPcHRpb25zfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gU2V0IHNhbWUgb3B0aW9uIHZhbHVlIGFzIGZvciBgLmdlbmVyYXRlKClgXHJcblx0ICogYmIuZGVmYXVsdHMoe1xyXG5cdCAqICAgZGF0YToge1xyXG5cdCAqICAgICB0eXBlOiBcImJhclwiXHJcblx0ICogICB9XHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiBiYi5kZWZhdWx0cygpOyAgLy8ge2RhdGE6e3R5cGU6IFwiYmFyXCJ9fVxyXG5cdCAqXHJcblx0ICogLy8gZGF0YS50eXBlIGRlZmF1bHRzIHRvICdiYXInXHJcblx0ICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XHJcblx0ICovXHJcblx0ZGVmYXVsdHMob3B0aW9ucykge1xyXG5cdFx0aWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XHJcblx0XHRcdGRlZmF1bHRzID0gb3B0aW9ucztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGVmYXVsdHM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQW4gYXJyYXkgY29udGFpbmluZyBpbnN0YW5jZSBjcmVhdGVkXHJcblx0ICogQHByb3BlcnR5IHtBcnJheX0gaW5zdGFuY2UgaW5zdGFuY2UgYXJyYXlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBnZW5lcmF0ZSBjaGFydHNcclxuXHQgKiAgdmFyIGNoYXJ0MSA9IGJiLmdlbmVyYXRlKC4uLik7XHJcblx0ICogIHZhciBjaGFydDIgPSBiYi5nZW5lcmF0ZSguLi4pO1xyXG5cdCAqXHJcblx0ICogIGJiLmluc3RhbmNlOyAgLy8gWyBjaGFydDEsIGNoYXJ0MiwgLi4uIF1cclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKi9cclxuXHRpbnN0YW5jZTogW10sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE5hbWVzcGFjZSBmb3IgcGx1Z2luc1xyXG5cdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwbHVnaW4gcGx1Z2luIG5hbWVzcGFjZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFN0YW5mb3JkIGRpYWdyYW0gcGx1Z2luXHJcblx0ICogIGJiLnBsdWdpbi5zdGFuZm9yZDtcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKi9cclxuXHRwbHVnaW46IHt9XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=