(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-ease"), require("d3-drag"), require("d3-zoom"), require("d3-color"), require("d3-shape"), require("d3-interpolate"));
	else if(typeof define === 'function' && define.amd)
		define(["d3-time-format", "d3-selection", "d3-transition", "d3-brush", "d3-axis", "d3-scale", "d3-dsv", "d3-ease", "d3-drag", "d3-zoom", "d3-color", "d3-shape", "d3-interpolate"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("d3-time-format"), require("d3-selection"), require("d3-transition"), require("d3-brush"), require("d3-axis"), require("d3-scale"), require("d3-dsv"), require("d3-ease"), require("d3-drag"), require("d3-zoom"), require("d3-color"), require("d3-shape"), require("d3-interpolate")) : factory(root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"], root["d3"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE__36__, __WEBPACK_EXTERNAL_MODULE__37__, __WEBPACK_EXTERNAL_MODULE__38__, __WEBPACK_EXTERNAL_MODULE__39__, __WEBPACK_EXTERNAL_MODULE__40__, __WEBPACK_EXTERNAL_MODULE__41__, __WEBPACK_EXTERNAL_MODULE__42__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__44__, __WEBPACK_EXTERNAL_MODULE__45__, __WEBPACK_EXTERNAL_MODULE__46__, __WEBPACK_EXTERNAL_MODULE__47__, __WEBPACK_EXTERNAL_MODULE__48__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 1);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(2);
__webpack_require__(32);
module.exports = __webpack_require__(49);


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__resourceQuery) {
/* global __resourceQuery WorkerGlobalScope self */

/* eslint prefer-destructuring: off */

var stripAnsi = __webpack_require__(3);

var socket = __webpack_require__(5);

var overlay = __webpack_require__(9);

var _require = __webpack_require__(15),
    log = _require.log,
    setLogLevel = _require.setLogLevel;

var sendMessage = __webpack_require__(17);

var reloadApp = __webpack_require__(18);

var createSocketUrl = __webpack_require__(21);

var status = {
  isUnloading: false,
  currentHash: ''
};
var options = {
  hot: false,
  hotReload: true,
  liveReload: false,
  initial: true,
  useWarningOverlay: false,
  useErrorOverlay: false,
  useProgress: false
};
var socketUrl = createSocketUrl(__resourceQuery);
self.addEventListener('beforeunload', function () {
  status.isUnloading = true;
});

if (typeof window !== 'undefined') {
  var qs = window.location.search.toLowerCase();
  options.hotReload = qs.indexOf('hotreload=false') === -1;
}

var onSocketMessage = {
  hot: function hot() {
    options.hot = true;
    log.info('[WDS] Hot Module Replacement enabled.');
  },
  liveReload: function liveReload() {
    options.liveReload = true;
    log.info('[WDS] Live Reloading enabled.');
  },
  invalid: function invalid() {
    log.info('[WDS] App updated. Recompiling...'); // fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('Invalid');
  },
  hash: function hash(_hash) {
    status.currentHash = _hash;
  },
  'still-ok': function stillOk() {
    log.info('[WDS] Nothing changed.');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    sendMessage('StillOk');
  },
  'log-level': function logLevel(level) {
    var hotCtx = __webpack_require__(30);

    if (hotCtx.keys().indexOf('./log') !== -1) {
      hotCtx('./log').setLogLevel(level);
    }

    setLogLevel(level);
  },
  overlay: function overlay(value) {
    if (typeof document !== 'undefined') {
      if (typeof value === 'boolean') {
        options.useWarningOverlay = false;
        options.useErrorOverlay = value;
      } else if (value) {
        options.useWarningOverlay = value.warnings;
        options.useErrorOverlay = value.errors;
      }
    }
  },
  progress: function progress(_progress) {
    if (typeof document !== 'undefined') {
      options.useProgress = _progress;
    }
  },
  'progress-update': function progressUpdate(data) {
    if (options.useProgress) {
      log.info("[WDS] ".concat(data.percent, "% - ").concat(data.msg, "."));
    }

    sendMessage('Progress', data);
  },
  ok: function ok() {
    sendMessage('Ok');

    if (options.useWarningOverlay || options.useErrorOverlay) {
      overlay.clear();
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  'content-changed': function contentChanged() {
    log.info('[WDS] Content base changed. Reloading...');
    self.location.reload();
  },
  warnings: function warnings(_warnings) {
    log.warn('[WDS] Warnings while compiling.');

    var strippedWarnings = _warnings.map(function (warning) {
      return stripAnsi(warning);
    });

    sendMessage('Warnings', strippedWarnings);

    for (var i = 0; i < strippedWarnings.length; i++) {
      log.warn(strippedWarnings[i]);
    }

    if (options.useWarningOverlay) {
      overlay.showMessage(_warnings);
    }

    if (options.initial) {
      return options.initial = false;
    } // eslint-disable-line no-return-assign


    reloadApp(options, status);
  },
  errors: function errors(_errors) {
    log.error('[WDS] Errors while compiling. Reload prevented.');

    var strippedErrors = _errors.map(function (error) {
      return stripAnsi(error);
    });

    sendMessage('Errors', strippedErrors);

    for (var i = 0; i < strippedErrors.length; i++) {
      log.error(strippedErrors[i]);
    }

    if (options.useErrorOverlay) {
      overlay.showMessage(_errors);
    }

    options.initial = false;
  },
  error: function error(_error) {
    log.error(_error);
  },
  close: function close() {
    log.error('[WDS] Disconnected!');
    sendMessage('Close');
  }
};
socket(socketUrl, onSocketMessage);
/* WEBPACK VAR INJECTION */}.call(this, "?http://localhost:8080"))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ansiRegex = __webpack_require__(4)();

module.exports = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(__webpack_dev_server_client__) {
/* global __webpack_dev_server_client__ */

/* eslint-disable
  camelcase
*/
// this SockJSClient is here as a default fallback, in case inline mode
// is off or the client is not injected. This will be switched to
// WebsocketClient when it becomes the default
// important: the path to SockJSClient here is made to work in the 'client'
// directory, but is updated via the webpack compilation when compiled from
// the 'client-src' directory

var Client = typeof __webpack_dev_server_client__ !== 'undefined' ? __webpack_dev_server_client__ : // eslint-disable-next-line import/no-unresolved
__webpack_require__(6);
var retries = 0;
var client = null;

var socket = function initSocket(url, handlers) {
  client = new Client(url);
  client.onOpen(function () {
    retries = 0;
  });
  client.onClose(function () {
    if (retries === 0) {
      handlers.close();
    } // Try to reconnect.


    client = null; // After 10 retries stop trying, to prevent logspam.

    if (retries <= 10) {
      // Exponentially increase timeout to reconnect.
      // Respectfully copied from the package `got`.
      // eslint-disable-next-line no-mixed-operators, no-restricted-properties
      var retryInMs = 1000 * Math.pow(2, retries) + Math.random() * 100;
      retries += 1;
      setTimeout(function () {
        socket(url, handlers);
      }, retryInMs);
    }
  });
  client.onMessage(function (data) {
    var msg = JSON.parse(data);

    if (handlers[msg.type]) {
      handlers[msg.type](msg.data);
    }
  });
};

module.exports = socket;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var SockJS = __webpack_require__(7);

var BaseClient = __webpack_require__(8);

module.exports =
/*#__PURE__*/
function (_BaseClient) {
  _inherits(SockJSClient, _BaseClient);

  function SockJSClient(url) {
    var _this;

    _classCallCheck(this, SockJSClient);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SockJSClient).call(this));
    _this.sock = new SockJS(url);

    _this.sock.onerror = function (err) {// TODO: use logger to log the error event once client and client-src
      // are reorganized to have the same directory structure
    };

    return _this;
  }

  _createClass(SockJSClient, [{
    key: "onOpen",
    value: function onOpen(f) {
      this.sock.onopen = f;
    }
  }, {
    key: "onClose",
    value: function onClose(f) {
      this.sock.onclose = f;
    } // call f with the message string as the first argument

  }, {
    key: "onMessage",
    value: function onMessage(f) {
      this.sock.onmessage = function (e) {
        f(e.data);
      };
    }
  }], [{
    key: "getClientPath",
    value: function getClientPath(options) {
      return /*require.resolve*/(6);
    }
  }]);

  return SockJSClient;
}(BaseClient);

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

var require;var require;/* sockjs-client v1.4.0 | http://sockjs.org | MIT license */
(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./main":14,"./transport-list":16}],2:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":4,"inherits":57}],3:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function() {
  var type = arguments[0];
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  // equivalent of Array.prototype.slice.call(arguments, 1);
  var l = arguments.length;
  var args = new Array(l - 1);
  for (var ai = 1; ai < l; ai++) {
    args[ai - 1] = arguments[ai];
  }
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":5,"inherits":57}],4:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET = 2;
Event.BUBBLING_PHASE = 3;

module.exports = Event;

},{}],5:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function() {
  var event = arguments[0];
  var t = event.type;
  // equivalent of Array.prototype.slice.call(arguments, 0);
  var args = arguments.length === 1 ? [event] : Array.apply(null, arguments);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],6:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":4,"inherits":57}],7:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":47,"json3":58}],8:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatible SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,{ env: {} })

},{"./facade":7,"./info-iframe-receiver":10,"./location":13,"./utils/event":46,"./utils/iframe":47,"./utils/url":52,"debug":55,"json3":58}],9:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,{ env: {} })

},{"./utils/object":49,"debug":55,"events":3,"inherits":57,"json3":58}],10:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":9,"./transport/sender/xhr-local":37,"events":3,"inherits":57,"json3":58}],11:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./info-iframe-receiver":10,"./transport/iframe":22,"./utils/event":46,"debug":55,"events":3,"inherits":57,"json3":58}],12:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,{ env: {} })

},{"./info-ajax":9,"./info-iframe":11,"./transport/sender/xdr":34,"./transport/sender/xhr-cors":35,"./transport/sender/xhr-fake":36,"./transport/sender/xhr-local":37,"./utils/url":52,"debug":55,"events":3,"inherits":57}],13:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http:'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],14:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;
  this._transportOptions = options.transportOptions || {};
  this._timeout = options.timeout || 0;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError('If sessionId is used in the options, it needs to be a number or a function.');
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https:' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = Math.max(this._timeout, (this._rto * Transport.roundTrips) || 5000);
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    var options = this._transportOptions[Transport.transportName];
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl, options);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transport) {
      this._transport.close();
    }

    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport && this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./event/close":2,"./event/event":4,"./event/eventtarget":5,"./event/trans-message":6,"./iframe-bootstrap":8,"./info-receiver":12,"./location":13,"./shims":15,"./utils/browser":44,"./utils/escape":45,"./utils/event":46,"./utils/log":48,"./utils/object":49,"./utils/random":50,"./utils/transport":51,"./utils/url":52,"./version":53,"debug":55,"inherits":57,"json3":58,"url-parse":61}],15:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],16:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":20,"./transport/htmlfile":21,"./transport/jsonp-polling":23,"./transport/lib/iframe-wrap":26,"./transport/websocket":38,"./transport/xdr-polling":39,"./transport/xdr-streaming":40,"./transport/xhr-polling":41,"./transport/xhr-streaming":42}],17:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {
    // intentionally empty
  }

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = true;
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {
          // intentionally empty
        }
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {
  // intentionally empty
}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],18:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],19:[function(require,module,exports){
(function (global){
'use strict';

var Driver = global.WebSocket || global.MozWebSocket;
if (Driver) {
	module.exports = function WebSocketBrowserDriver(url) {
		return new Driver(url);
	};
} else {
	module.exports = undefined;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":24,"./receiver/eventsource":29,"./sender/xhr-cors":35,"eventsource":18,"inherits":57}],21:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":24,"./receiver/htmlfile":30,"./sender/xhr-local":37,"inherits":57}],22:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {
      // intentionally empty
    }
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/iframe":47,"../utils/random":50,"../utils/url":52,"../version":53,"debug":55,"events":3,"inherits":57,"json3":58}],23:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./lib/sender-receiver":28,"./receiver/jsonp":31,"./sender/jsonp":33,"inherits":57}],24:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type': 'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./sender-receiver":28,"debug":55,"inherits":57}],25:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self.close();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.close = function() {
  debug('close');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],26:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/object":49,"../iframe":22,"inherits":57}],27:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],28:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  BufferedSender.prototype.close.call(this);
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
};

module.exports = SenderReceiver;

}).call(this,{ env: {} })

},{"../../utils/url":52,"./buffered-sender":25,"./polling":27,"debug":55,"inherits":57}],29:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"eventsource":18,"inherits":57}],30:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {
    // intentionally empty
  }
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],31:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {
          // intentionally empty
        }
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {
        // intentionally empty
      }
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/iframe":47,"../../utils/random":50,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],32:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,{ env: {} })

},{"debug":55,"events":3,"inherits":57}],33:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/random":50,"../../utils/url":52,"debug":55}],34:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {
      // intentionally empty
    }
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../utils/browser":44,"../../utils/event":46,"../../utils/url":52,"debug":55,"events":3,"inherits":57}],35:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":17,"inherits":57}],36:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":3,"inherits":57}],37:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":17,"inherits":57}],38:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl, ignore, options) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url, [], options);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  var ws = this.ws;
  this._cleanup();
  if (ws) {
    ws.close();
  }
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,{ env: {} })

},{"../utils/event":46,"../utils/url":52,"./driver/websocket":19,"debug":55,"events":3,"inherits":57}],39:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"./xdr-streaming":40,"inherits":57}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xdr":34,"inherits":57}],41:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],42:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../utils/browser":44,"./lib/ajax-based":24,"./receiver/xhr":32,"./sender/xhr-cors":35,"./sender/xhr-local":37,"inherits":57}],43:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],44:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],45:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
// eslint-disable-next-line no-control-regex
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":58}],46:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./random":50}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {
        // intentionally empty
      }
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      setTimeout(function() {
        try {
          // When the iframe is not loaded, IE raises an exception
          // on 'contentWindow'.
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        } catch (x) {
          // intentionally empty
        }
      }, 0);
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* eslint no-undef: "off", new-cap: "off" */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r) {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {
        // intentionally empty
      }
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,{ env: {} },typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./browser":44,"./event":46,"debug":55,"json3":58}],48:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists;

  try {
    levelExists = global.console && global.console[level] && global.console[level].apply;
  } catch(e) {
    // do nothing
  }

  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],49:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],50:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":43}],51:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,{ env: {} })

},{"debug":55}],52:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,{ env: {} })

},{"debug":55,"url-parse":61}],53:[function(require,module,exports){
module.exports = '1.4.0';

},{}],54:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

},{}],55:[function(require,module,exports){
(function (process){
"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console;

  // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = require('./common')(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};


}).call(this,{ env: {} })

},{"./common":56}],56:[function(require,module,exports){
"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = require('ms');
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;


},{"ms":54}],57:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],58:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],59:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String} The decoded string.
 * @api private
 */
function decode(input) {
  return decodeURIComponent(input.replace(/\+/g, ' '));
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    if (key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],60:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\S\s]*)/i
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address) {          // Sanitize what is left of the address
    return address.replace('\\', '/');
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var location = global && global.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address) {
  var match = protocolre.exec(address);

  return {
    protocol: match[1] ? match[1].toLowerCase() : '',
    slashes: !!match[2],
    rest: match[3]
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} location Location defaults for relative paths.
 * @param {Boolean|Function} parser Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '');
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (/:\d+$/.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    default:
      url[part] = value;
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.origin = url.protocol && url.host && url.protocol !== 'file:'
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result = protocol + (url.slashes ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.qs = qs;

module.exports = Url;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":59,"requires-port":60}]},{},[1])(1)
});


//# sourceMappingURL=sockjs.js.map


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable
  no-unused-vars
*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function BaseClient() {
    _classCallCheck(this, BaseClient);
  }

  _createClass(BaseClient, null, [{
    key: "getClientPath",
    value: function getClientPath(options) {
      throw new Error('Client needs implementation');
    }
  }]);

  return BaseClient;
}();

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

var ansiHTML = __webpack_require__(10);

var _require = __webpack_require__(11),
    AllHtmlEntities = _require.AllHtmlEntities;

var entities = new AllHtmlEntities();
var colors = {
  reset: ['transparent', 'transparent'],
  black: '181818',
  red: 'E36049',
  green: 'B3CB74',
  yellow: 'FFD080',
  blue: '7CAFC2',
  magenta: '7FACCA',
  cyan: 'C3C2EF',
  lightgrey: 'EBE7E3',
  darkgrey: '6D7891'
};
var overlayIframe = null;
var overlayDiv = null;
var lastOnOverlayDivReady = null;
ansiHTML.setColors(colors);

function createOverlayIframe(onIframeLoad) {
  var iframe = document.createElement('iframe');
  iframe.id = 'webpack-dev-server-client-overlay';
  iframe.src = 'about:blank';
  iframe.style.position = 'fixed';
  iframe.style.left = 0;
  iframe.style.top = 0;
  iframe.style.right = 0;
  iframe.style.bottom = 0;
  iframe.style.width = '100vw';
  iframe.style.height = '100vh';
  iframe.style.border = 'none';
  iframe.style.zIndex = 9999999999;
  iframe.onload = onIframeLoad;
  return iframe;
}

function addOverlayDivTo(iframe) {
  var div = iframe.contentDocument.createElement('div');
  div.id = 'webpack-dev-server-client-overlay-div';
  div.style.position = 'fixed';
  div.style.boxSizing = 'border-box';
  div.style.left = 0;
  div.style.top = 0;
  div.style.right = 0;
  div.style.bottom = 0;
  div.style.width = '100vw';
  div.style.height = '100vh';
  div.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
  div.style.color = '#E8E8E8';
  div.style.fontFamily = 'Menlo, Consolas, monospace';
  div.style.fontSize = 'large';
  div.style.padding = '2rem';
  div.style.lineHeight = '1.2';
  div.style.whiteSpace = 'pre-wrap';
  div.style.overflow = 'auto';
  iframe.contentDocument.body.appendChild(div);
  return div;
}

function ensureOverlayDivExists(onOverlayDivReady) {
  if (overlayDiv) {
    // Everything is ready, call the callback right away.
    onOverlayDivReady(overlayDiv);
    return;
  } // Creating an iframe may be asynchronous so we'll schedule the callback.
  // In case of multiple calls, last callback wins.


  lastOnOverlayDivReady = onOverlayDivReady;

  if (overlayIframe) {
    // We've already created it.
    return;
  } // Create iframe and, when it is ready, a div inside it.


  overlayIframe = createOverlayIframe(function () {
    overlayDiv = addOverlayDivTo(overlayIframe); // Now we can talk!

    lastOnOverlayDivReady(overlayDiv);
  }); // Zalgo alert: onIframeLoad() will be called either synchronously
  // or asynchronously depending on the browser.
  // We delay adding it so `overlayIframe` is set when `onIframeLoad` fires.

  document.body.appendChild(overlayIframe);
} // Successful compilation.


function clear() {
  if (!overlayDiv) {
    // It is not there in the first place.
    return;
  } // Clean up and reset internal state.


  document.body.removeChild(overlayIframe);
  overlayDiv = null;
  overlayIframe = null;
  lastOnOverlayDivReady = null;
} // Compilation with errors (e.g. syntax error or missing modules).


function showMessage(messages) {
  ensureOverlayDivExists(function (div) {
    // Make it look similar to our terminal.
    div.innerHTML = "<span style=\"color: #".concat(colors.red, "\">Failed to compile.</span><br><br>").concat(ansiHTML(entities.encode(messages[0])));
  });
}

module.exports = {
  clear: clear,
  showMessage: showMessage
};

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = ansiHTML

// Reference to https://github.com/sindresorhus/ansi-regex
var _regANSI = /(?:(?:\u001b\[)|\u009b)(?:(?:[0-9]{1,3})?(?:(?:;[0-9]{0,3})*)?[A-M|f-m])|\u001b[A-M]/

var _defColors = {
  reset: ['fff', '000'], // [FOREGROUD_COLOR, BACKGROUND_COLOR]
  black: '000',
  red: 'ff0000',
  green: '209805',
  yellow: 'e8bf03',
  blue: '0000ff',
  magenta: 'ff00ff',
  cyan: '00ffee',
  lightgrey: 'f0f0f0',
  darkgrey: '888'
}
var _styles = {
  30: 'black',
  31: 'red',
  32: 'green',
  33: 'yellow',
  34: 'blue',
  35: 'magenta',
  36: 'cyan',
  37: 'lightgrey'
}
var _openTags = {
  '1': 'font-weight:bold', // bold
  '2': 'opacity:0.5', // dim
  '3': '<i>', // italic
  '4': '<u>', // underscore
  '8': 'display:none', // hidden
  '9': '<del>' // delete
}
var _closeTags = {
  '23': '</i>', // reset italic
  '24': '</u>', // reset underscore
  '29': '</del>' // reset delete
}

;[0, 21, 22, 27, 28, 39, 49].forEach(function (n) {
  _closeTags[n] = '</span>'
})

/**
 * Converts text with ANSI color codes to HTML markup.
 * @param {String} text
 * @returns {*}
 */
function ansiHTML (text) {
  // Returns the text if the string has no ANSI escape code.
  if (!_regANSI.test(text)) {
    return text
  }

  // Cache opened sequence.
  var ansiCodes = []
  // Replace with markup.
  var ret = text.replace(/\033\[(\d+)*m/g, function (match, seq) {
    var ot = _openTags[seq]
    if (ot) {
      // If current sequence has been opened, close it.
      if (!!~ansiCodes.indexOf(seq)) { // eslint-disable-line no-extra-boolean-cast
        ansiCodes.pop()
        return '</span>'
      }
      // Open tag.
      ansiCodes.push(seq)
      return ot[0] === '<' ? ot : '<span style="' + ot + ';">'
    }

    var ct = _closeTags[seq]
    if (ct) {
      // Pop sequence
      ansiCodes.pop()
      return ct
    }
    return ''
  })

  // Make sure tags are closed.
  var l = ansiCodes.length
  ;(l > 0) && (ret += Array(l + 1).join('</span>'))

  return ret
}

/**
 * Customize colors.
 * @param {Object} colors reference to _defColors
 */
ansiHTML.setColors = function (colors) {
  if (typeof colors !== 'object') {
    throw new Error('`colors` parameter must be an Object.')
  }

  var _finalColors = {}
  for (var key in _defColors) {
    var hex = colors.hasOwnProperty(key) ? colors[key] : null
    if (!hex) {
      _finalColors[key] = _defColors[key]
      continue
    }
    if ('reset' === key) {
      if (typeof hex === 'string') {
        hex = [hex]
      }
      if (!Array.isArray(hex) || hex.length === 0 || hex.some(function (h) {
        return typeof h !== 'string'
      })) {
        throw new Error('The value of `' + key + '` property must be an Array and each item could only be a hex string, e.g.: FF0000')
      }
      var defHexColor = _defColors[key]
      if (!hex[0]) {
        hex[0] = defHexColor[0]
      }
      if (hex.length === 1 || !hex[1]) {
        hex = [hex[0]]
        hex.push(defHexColor[1])
      }

      hex = hex.slice(0, 2)
    } else if (typeof hex !== 'string') {
      throw new Error('The value of `' + key + '` property must be a hex string, e.g.: FF0000')
    }
    _finalColors[key] = hex
  }
  _setTags(_finalColors)
}

/**
 * Reset colors.
 */
ansiHTML.reset = function () {
  _setTags(_defColors)
}

/**
 * Expose tags, including open and close.
 * @type {Object}
 */
ansiHTML.tags = {}

if (Object.defineProperty) {
  Object.defineProperty(ansiHTML.tags, 'open', {
    get: function () { return _openTags }
  })
  Object.defineProperty(ansiHTML.tags, 'close', {
    get: function () { return _closeTags }
  })
} else {
  ansiHTML.tags.open = _openTags
  ansiHTML.tags.close = _closeTags
}

function _setTags (colors) {
  // reset all
  _openTags['0'] = 'font-weight:normal;opacity:1;color:#' + colors.reset[0] + ';background:#' + colors.reset[1]
  // inverse
  _openTags['7'] = 'color:#' + colors.reset[1] + ';background:#' + colors.reset[0]
  // dark grey
  _openTags['90'] = 'color:#' + colors.darkgrey

  for (var code in _styles) {
    var color = _styles[code]
    var oriColor = colors[color] || '000'
    _openTags[code] = 'color:#' + oriColor
    code = parseInt(code)
    _openTags[(code + 10).toString()] = 'background:#' + oriColor
  }
}

ansiHTML.reset()


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  XmlEntities: __webpack_require__(12),
  Html4Entities: __webpack_require__(13),
  Html5Entities: __webpack_require__(14),
  AllHtmlEntities: __webpack_require__(14)
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

var ALPHA_INDEX = {
    '&lt': '<',
    '&gt': '>',
    '&quot': '"',
    '&apos': '\'',
    '&amp': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&apos;': '\'',
    '&amp;': '&'
};

var CHAR_INDEX = {
    60: 'lt',
    62: 'gt',
    34: 'quot',
    39: 'apos',
    38: 'amp'
};

var CHAR_S_INDEX = {
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&apos;',
    '&': '&amp;'
};

/**
 * @constructor
 */
function XmlEntities() {}

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/<|>|"|'|&/g, function(s) {
        return CHAR_S_INDEX[s];
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encode = function(str) {
    return new XmlEntities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&#?[0-9a-zA-Z]+;?/g, function(s) {
        if (s.charAt(1) === '#') {
            var code = s.charAt(2).toLowerCase() === 'x' ?
                parseInt(s.substr(3), 16) :
                parseInt(s.substr(2));

            if (isNaN(code) || code < -32768 || code > 65535) {
                return '';
            }
            return String.fromCharCode(code);
        }
        return ALPHA_INDEX[s] || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.decode = function(str) {
    return new XmlEntities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var alpha = CHAR_INDEX[c];
        if (alpha) {
            result += "&" + alpha + ";";
            i++;
            continue;
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonUTF = function(str) {
    return new XmlEntities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
XmlEntities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLenght = str.length;
    var result = '';
    var i = 0;
    while (i < strLenght) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 XmlEntities.encodeNonASCII = function(str) {
    return new XmlEntities().encodeNonASCII(str);
 };

module.exports = XmlEntities;


/***/ }),
/* 13 */
/***/ (function(module, exports) {

var HTML_ALPHA = ['apos', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'Aelig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'acirc', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'quot', 'amp', 'lt', 'gt', 'OElig', 'oelig', 'Scaron', 'scaron', 'Yuml', 'circ', 'tilde', 'ensp', 'emsp', 'thinsp', 'zwnj', 'zwj', 'lrm', 'rlm', 'ndash', 'mdash', 'lsquo', 'rsquo', 'sbquo', 'ldquo', 'rdquo', 'bdquo', 'dagger', 'Dagger', 'permil', 'lsaquo', 'rsaquo', 'euro', 'fnof', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigmaf', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'thetasym', 'upsih', 'piv', 'bull', 'hellip', 'prime', 'Prime', 'oline', 'frasl', 'weierp', 'image', 'real', 'trade', 'alefsym', 'larr', 'uarr', 'rarr', 'darr', 'harr', 'crarr', 'lArr', 'uArr', 'rArr', 'dArr', 'hArr', 'forall', 'part', 'exist', 'empty', 'nabla', 'isin', 'notin', 'ni', 'prod', 'sum', 'minus', 'lowast', 'radic', 'prop', 'infin', 'ang', 'and', 'or', 'cap', 'cup', 'int', 'there4', 'sim', 'cong', 'asymp', 'ne', 'equiv', 'le', 'ge', 'sub', 'sup', 'nsub', 'sube', 'supe', 'oplus', 'otimes', 'perp', 'sdot', 'lceil', 'rceil', 'lfloor', 'rfloor', 'lang', 'rang', 'loz', 'spades', 'clubs', 'hearts', 'diams'];
var HTML_CODES = [39, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 34, 38, 60, 62, 338, 339, 352, 353, 376, 710, 732, 8194, 8195, 8201, 8204, 8205, 8206, 8207, 8211, 8212, 8216, 8217, 8218, 8220, 8221, 8222, 8224, 8225, 8240, 8249, 8250, 8364, 402, 913, 914, 915, 916, 917, 918, 919, 920, 921, 922, 923, 924, 925, 926, 927, 928, 929, 931, 932, 933, 934, 935, 936, 937, 945, 946, 947, 948, 949, 950, 951, 952, 953, 954, 955, 956, 957, 958, 959, 960, 961, 962, 963, 964, 965, 966, 967, 968, 969, 977, 978, 982, 8226, 8230, 8242, 8243, 8254, 8260, 8472, 8465, 8476, 8482, 8501, 8592, 8593, 8594, 8595, 8596, 8629, 8656, 8657, 8658, 8659, 8660, 8704, 8706, 8707, 8709, 8711, 8712, 8713, 8715, 8719, 8721, 8722, 8727, 8730, 8733, 8734, 8736, 8743, 8744, 8745, 8746, 8747, 8756, 8764, 8773, 8776, 8800, 8801, 8804, 8805, 8834, 8835, 8836, 8838, 8839, 8853, 8855, 8869, 8901, 8968, 8969, 8970, 8971, 9001, 9002, 9674, 9824, 9827, 9829, 9830];

var alphaIndex = {};
var numIndex = {};

var i = 0;
var length = HTML_ALPHA.length;
while (i < length) {
    var a = HTML_ALPHA[i];
    var c = HTML_CODES[i];
    alphaIndex[a] = String.fromCharCode(c);
    numIndex[c] = a;
    i++;
}

/**
 * @constructor
 */
function Html4Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1).toLowerCase() === 'x' ?
                parseInt(entity.substr(2), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.decode = function(str) {
    return new Html4Entities().decode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var alpha = numIndex[str.charCodeAt(i)];
        result += alpha ? "&" + alpha + ";" : str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encode = function(str) {
    return new Html4Entities().encode(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var cc = str.charCodeAt(i);
        var alpha = numIndex[cc];
        if (alpha) {
            result += "&" + alpha + ";";
        } else if (cc < 32 || cc > 126) {
            result += "&#" + cc + ";";
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonUTF = function(str) {
    return new Html4Entities().encodeNonUTF(str);
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
Html4Entities.encodeNonASCII = function(str) {
    return new Html4Entities().encodeNonASCII(str);
};

module.exports = Html4Entities;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

var ENTITIES = [['Aacute', [193]], ['aacute', [225]], ['Abreve', [258]], ['abreve', [259]], ['ac', [8766]], ['acd', [8767]], ['acE', [8766, 819]], ['Acirc', [194]], ['acirc', [226]], ['acute', [180]], ['Acy', [1040]], ['acy', [1072]], ['AElig', [198]], ['aelig', [230]], ['af', [8289]], ['Afr', [120068]], ['afr', [120094]], ['Agrave', [192]], ['agrave', [224]], ['alefsym', [8501]], ['aleph', [8501]], ['Alpha', [913]], ['alpha', [945]], ['Amacr', [256]], ['amacr', [257]], ['amalg', [10815]], ['amp', [38]], ['AMP', [38]], ['andand', [10837]], ['And', [10835]], ['and', [8743]], ['andd', [10844]], ['andslope', [10840]], ['andv', [10842]], ['ang', [8736]], ['ange', [10660]], ['angle', [8736]], ['angmsdaa', [10664]], ['angmsdab', [10665]], ['angmsdac', [10666]], ['angmsdad', [10667]], ['angmsdae', [10668]], ['angmsdaf', [10669]], ['angmsdag', [10670]], ['angmsdah', [10671]], ['angmsd', [8737]], ['angrt', [8735]], ['angrtvb', [8894]], ['angrtvbd', [10653]], ['angsph', [8738]], ['angst', [197]], ['angzarr', [9084]], ['Aogon', [260]], ['aogon', [261]], ['Aopf', [120120]], ['aopf', [120146]], ['apacir', [10863]], ['ap', [8776]], ['apE', [10864]], ['ape', [8778]], ['apid', [8779]], ['apos', [39]], ['ApplyFunction', [8289]], ['approx', [8776]], ['approxeq', [8778]], ['Aring', [197]], ['aring', [229]], ['Ascr', [119964]], ['ascr', [119990]], ['Assign', [8788]], ['ast', [42]], ['asymp', [8776]], ['asympeq', [8781]], ['Atilde', [195]], ['atilde', [227]], ['Auml', [196]], ['auml', [228]], ['awconint', [8755]], ['awint', [10769]], ['backcong', [8780]], ['backepsilon', [1014]], ['backprime', [8245]], ['backsim', [8765]], ['backsimeq', [8909]], ['Backslash', [8726]], ['Barv', [10983]], ['barvee', [8893]], ['barwed', [8965]], ['Barwed', [8966]], ['barwedge', [8965]], ['bbrk', [9141]], ['bbrktbrk', [9142]], ['bcong', [8780]], ['Bcy', [1041]], ['bcy', [1073]], ['bdquo', [8222]], ['becaus', [8757]], ['because', [8757]], ['Because', [8757]], ['bemptyv', [10672]], ['bepsi', [1014]], ['bernou', [8492]], ['Bernoullis', [8492]], ['Beta', [914]], ['beta', [946]], ['beth', [8502]], ['between', [8812]], ['Bfr', [120069]], ['bfr', [120095]], ['bigcap', [8898]], ['bigcirc', [9711]], ['bigcup', [8899]], ['bigodot', [10752]], ['bigoplus', [10753]], ['bigotimes', [10754]], ['bigsqcup', [10758]], ['bigstar', [9733]], ['bigtriangledown', [9661]], ['bigtriangleup', [9651]], ['biguplus', [10756]], ['bigvee', [8897]], ['bigwedge', [8896]], ['bkarow', [10509]], ['blacklozenge', [10731]], ['blacksquare', [9642]], ['blacktriangle', [9652]], ['blacktriangledown', [9662]], ['blacktriangleleft', [9666]], ['blacktriangleright', [9656]], ['blank', [9251]], ['blk12', [9618]], ['blk14', [9617]], ['blk34', [9619]], ['block', [9608]], ['bne', [61, 8421]], ['bnequiv', [8801, 8421]], ['bNot', [10989]], ['bnot', [8976]], ['Bopf', [120121]], ['bopf', [120147]], ['bot', [8869]], ['bottom', [8869]], ['bowtie', [8904]], ['boxbox', [10697]], ['boxdl', [9488]], ['boxdL', [9557]], ['boxDl', [9558]], ['boxDL', [9559]], ['boxdr', [9484]], ['boxdR', [9554]], ['boxDr', [9555]], ['boxDR', [9556]], ['boxh', [9472]], ['boxH', [9552]], ['boxhd', [9516]], ['boxHd', [9572]], ['boxhD', [9573]], ['boxHD', [9574]], ['boxhu', [9524]], ['boxHu', [9575]], ['boxhU', [9576]], ['boxHU', [9577]], ['boxminus', [8863]], ['boxplus', [8862]], ['boxtimes', [8864]], ['boxul', [9496]], ['boxuL', [9563]], ['boxUl', [9564]], ['boxUL', [9565]], ['boxur', [9492]], ['boxuR', [9560]], ['boxUr', [9561]], ['boxUR', [9562]], ['boxv', [9474]], ['boxV', [9553]], ['boxvh', [9532]], ['boxvH', [9578]], ['boxVh', [9579]], ['boxVH', [9580]], ['boxvl', [9508]], ['boxvL', [9569]], ['boxVl', [9570]], ['boxVL', [9571]], ['boxvr', [9500]], ['boxvR', [9566]], ['boxVr', [9567]], ['boxVR', [9568]], ['bprime', [8245]], ['breve', [728]], ['Breve', [728]], ['brvbar', [166]], ['bscr', [119991]], ['Bscr', [8492]], ['bsemi', [8271]], ['bsim', [8765]], ['bsime', [8909]], ['bsolb', [10693]], ['bsol', [92]], ['bsolhsub', [10184]], ['bull', [8226]], ['bullet', [8226]], ['bump', [8782]], ['bumpE', [10926]], ['bumpe', [8783]], ['Bumpeq', [8782]], ['bumpeq', [8783]], ['Cacute', [262]], ['cacute', [263]], ['capand', [10820]], ['capbrcup', [10825]], ['capcap', [10827]], ['cap', [8745]], ['Cap', [8914]], ['capcup', [10823]], ['capdot', [10816]], ['CapitalDifferentialD', [8517]], ['caps', [8745, 65024]], ['caret', [8257]], ['caron', [711]], ['Cayleys', [8493]], ['ccaps', [10829]], ['Ccaron', [268]], ['ccaron', [269]], ['Ccedil', [199]], ['ccedil', [231]], ['Ccirc', [264]], ['ccirc', [265]], ['Cconint', [8752]], ['ccups', [10828]], ['ccupssm', [10832]], ['Cdot', [266]], ['cdot', [267]], ['cedil', [184]], ['Cedilla', [184]], ['cemptyv', [10674]], ['cent', [162]], ['centerdot', [183]], ['CenterDot', [183]], ['cfr', [120096]], ['Cfr', [8493]], ['CHcy', [1063]], ['chcy', [1095]], ['check', [10003]], ['checkmark', [10003]], ['Chi', [935]], ['chi', [967]], ['circ', [710]], ['circeq', [8791]], ['circlearrowleft', [8634]], ['circlearrowright', [8635]], ['circledast', [8859]], ['circledcirc', [8858]], ['circleddash', [8861]], ['CircleDot', [8857]], ['circledR', [174]], ['circledS', [9416]], ['CircleMinus', [8854]], ['CirclePlus', [8853]], ['CircleTimes', [8855]], ['cir', [9675]], ['cirE', [10691]], ['cire', [8791]], ['cirfnint', [10768]], ['cirmid', [10991]], ['cirscir', [10690]], ['ClockwiseContourIntegral', [8754]], ['clubs', [9827]], ['clubsuit', [9827]], ['colon', [58]], ['Colon', [8759]], ['Colone', [10868]], ['colone', [8788]], ['coloneq', [8788]], ['comma', [44]], ['commat', [64]], ['comp', [8705]], ['compfn', [8728]], ['complement', [8705]], ['complexes', [8450]], ['cong', [8773]], ['congdot', [10861]], ['Congruent', [8801]], ['conint', [8750]], ['Conint', [8751]], ['ContourIntegral', [8750]], ['copf', [120148]], ['Copf', [8450]], ['coprod', [8720]], ['Coproduct', [8720]], ['copy', [169]], ['COPY', [169]], ['copysr', [8471]], ['CounterClockwiseContourIntegral', [8755]], ['crarr', [8629]], ['cross', [10007]], ['Cross', [10799]], ['Cscr', [119966]], ['cscr', [119992]], ['csub', [10959]], ['csube', [10961]], ['csup', [10960]], ['csupe', [10962]], ['ctdot', [8943]], ['cudarrl', [10552]], ['cudarrr', [10549]], ['cuepr', [8926]], ['cuesc', [8927]], ['cularr', [8630]], ['cularrp', [10557]], ['cupbrcap', [10824]], ['cupcap', [10822]], ['CupCap', [8781]], ['cup', [8746]], ['Cup', [8915]], ['cupcup', [10826]], ['cupdot', [8845]], ['cupor', [10821]], ['cups', [8746, 65024]], ['curarr', [8631]], ['curarrm', [10556]], ['curlyeqprec', [8926]], ['curlyeqsucc', [8927]], ['curlyvee', [8910]], ['curlywedge', [8911]], ['curren', [164]], ['curvearrowleft', [8630]], ['curvearrowright', [8631]], ['cuvee', [8910]], ['cuwed', [8911]], ['cwconint', [8754]], ['cwint', [8753]], ['cylcty', [9005]], ['dagger', [8224]], ['Dagger', [8225]], ['daleth', [8504]], ['darr', [8595]], ['Darr', [8609]], ['dArr', [8659]], ['dash', [8208]], ['Dashv', [10980]], ['dashv', [8867]], ['dbkarow', [10511]], ['dblac', [733]], ['Dcaron', [270]], ['dcaron', [271]], ['Dcy', [1044]], ['dcy', [1076]], ['ddagger', [8225]], ['ddarr', [8650]], ['DD', [8517]], ['dd', [8518]], ['DDotrahd', [10513]], ['ddotseq', [10871]], ['deg', [176]], ['Del', [8711]], ['Delta', [916]], ['delta', [948]], ['demptyv', [10673]], ['dfisht', [10623]], ['Dfr', [120071]], ['dfr', [120097]], ['dHar', [10597]], ['dharl', [8643]], ['dharr', [8642]], ['DiacriticalAcute', [180]], ['DiacriticalDot', [729]], ['DiacriticalDoubleAcute', [733]], ['DiacriticalGrave', [96]], ['DiacriticalTilde', [732]], ['diam', [8900]], ['diamond', [8900]], ['Diamond', [8900]], ['diamondsuit', [9830]], ['diams', [9830]], ['die', [168]], ['DifferentialD', [8518]], ['digamma', [989]], ['disin', [8946]], ['div', [247]], ['divide', [247]], ['divideontimes', [8903]], ['divonx', [8903]], ['DJcy', [1026]], ['djcy', [1106]], ['dlcorn', [8990]], ['dlcrop', [8973]], ['dollar', [36]], ['Dopf', [120123]], ['dopf', [120149]], ['Dot', [168]], ['dot', [729]], ['DotDot', [8412]], ['doteq', [8784]], ['doteqdot', [8785]], ['DotEqual', [8784]], ['dotminus', [8760]], ['dotplus', [8724]], ['dotsquare', [8865]], ['doublebarwedge', [8966]], ['DoubleContourIntegral', [8751]], ['DoubleDot', [168]], ['DoubleDownArrow', [8659]], ['DoubleLeftArrow', [8656]], ['DoubleLeftRightArrow', [8660]], ['DoubleLeftTee', [10980]], ['DoubleLongLeftArrow', [10232]], ['DoubleLongLeftRightArrow', [10234]], ['DoubleLongRightArrow', [10233]], ['DoubleRightArrow', [8658]], ['DoubleRightTee', [8872]], ['DoubleUpArrow', [8657]], ['DoubleUpDownArrow', [8661]], ['DoubleVerticalBar', [8741]], ['DownArrowBar', [10515]], ['downarrow', [8595]], ['DownArrow', [8595]], ['Downarrow', [8659]], ['DownArrowUpArrow', [8693]], ['DownBreve', [785]], ['downdownarrows', [8650]], ['downharpoonleft', [8643]], ['downharpoonright', [8642]], ['DownLeftRightVector', [10576]], ['DownLeftTeeVector', [10590]], ['DownLeftVectorBar', [10582]], ['DownLeftVector', [8637]], ['DownRightTeeVector', [10591]], ['DownRightVectorBar', [10583]], ['DownRightVector', [8641]], ['DownTeeArrow', [8615]], ['DownTee', [8868]], ['drbkarow', [10512]], ['drcorn', [8991]], ['drcrop', [8972]], ['Dscr', [119967]], ['dscr', [119993]], ['DScy', [1029]], ['dscy', [1109]], ['dsol', [10742]], ['Dstrok', [272]], ['dstrok', [273]], ['dtdot', [8945]], ['dtri', [9663]], ['dtrif', [9662]], ['duarr', [8693]], ['duhar', [10607]], ['dwangle', [10662]], ['DZcy', [1039]], ['dzcy', [1119]], ['dzigrarr', [10239]], ['Eacute', [201]], ['eacute', [233]], ['easter', [10862]], ['Ecaron', [282]], ['ecaron', [283]], ['Ecirc', [202]], ['ecirc', [234]], ['ecir', [8790]], ['ecolon', [8789]], ['Ecy', [1069]], ['ecy', [1101]], ['eDDot', [10871]], ['Edot', [278]], ['edot', [279]], ['eDot', [8785]], ['ee', [8519]], ['efDot', [8786]], ['Efr', [120072]], ['efr', [120098]], ['eg', [10906]], ['Egrave', [200]], ['egrave', [232]], ['egs', [10902]], ['egsdot', [10904]], ['el', [10905]], ['Element', [8712]], ['elinters', [9191]], ['ell', [8467]], ['els', [10901]], ['elsdot', [10903]], ['Emacr', [274]], ['emacr', [275]], ['empty', [8709]], ['emptyset', [8709]], ['EmptySmallSquare', [9723]], ['emptyv', [8709]], ['EmptyVerySmallSquare', [9643]], ['emsp13', [8196]], ['emsp14', [8197]], ['emsp', [8195]], ['ENG', [330]], ['eng', [331]], ['ensp', [8194]], ['Eogon', [280]], ['eogon', [281]], ['Eopf', [120124]], ['eopf', [120150]], ['epar', [8917]], ['eparsl', [10723]], ['eplus', [10865]], ['epsi', [949]], ['Epsilon', [917]], ['epsilon', [949]], ['epsiv', [1013]], ['eqcirc', [8790]], ['eqcolon', [8789]], ['eqsim', [8770]], ['eqslantgtr', [10902]], ['eqslantless', [10901]], ['Equal', [10869]], ['equals', [61]], ['EqualTilde', [8770]], ['equest', [8799]], ['Equilibrium', [8652]], ['equiv', [8801]], ['equivDD', [10872]], ['eqvparsl', [10725]], ['erarr', [10609]], ['erDot', [8787]], ['escr', [8495]], ['Escr', [8496]], ['esdot', [8784]], ['Esim', [10867]], ['esim', [8770]], ['Eta', [919]], ['eta', [951]], ['ETH', [208]], ['eth', [240]], ['Euml', [203]], ['euml', [235]], ['euro', [8364]], ['excl', [33]], ['exist', [8707]], ['Exists', [8707]], ['expectation', [8496]], ['exponentiale', [8519]], ['ExponentialE', [8519]], ['fallingdotseq', [8786]], ['Fcy', [1060]], ['fcy', [1092]], ['female', [9792]], ['ffilig', [64259]], ['fflig', [64256]], ['ffllig', [64260]], ['Ffr', [120073]], ['ffr', [120099]], ['filig', [64257]], ['FilledSmallSquare', [9724]], ['FilledVerySmallSquare', [9642]], ['fjlig', [102, 106]], ['flat', [9837]], ['fllig', [64258]], ['fltns', [9649]], ['fnof', [402]], ['Fopf', [120125]], ['fopf', [120151]], ['forall', [8704]], ['ForAll', [8704]], ['fork', [8916]], ['forkv', [10969]], ['Fouriertrf', [8497]], ['fpartint', [10765]], ['frac12', [189]], ['frac13', [8531]], ['frac14', [188]], ['frac15', [8533]], ['frac16', [8537]], ['frac18', [8539]], ['frac23', [8532]], ['frac25', [8534]], ['frac34', [190]], ['frac35', [8535]], ['frac38', [8540]], ['frac45', [8536]], ['frac56', [8538]], ['frac58', [8541]], ['frac78', [8542]], ['frasl', [8260]], ['frown', [8994]], ['fscr', [119995]], ['Fscr', [8497]], ['gacute', [501]], ['Gamma', [915]], ['gamma', [947]], ['Gammad', [988]], ['gammad', [989]], ['gap', [10886]], ['Gbreve', [286]], ['gbreve', [287]], ['Gcedil', [290]], ['Gcirc', [284]], ['gcirc', [285]], ['Gcy', [1043]], ['gcy', [1075]], ['Gdot', [288]], ['gdot', [289]], ['ge', [8805]], ['gE', [8807]], ['gEl', [10892]], ['gel', [8923]], ['geq', [8805]], ['geqq', [8807]], ['geqslant', [10878]], ['gescc', [10921]], ['ges', [10878]], ['gesdot', [10880]], ['gesdoto', [10882]], ['gesdotol', [10884]], ['gesl', [8923, 65024]], ['gesles', [10900]], ['Gfr', [120074]], ['gfr', [120100]], ['gg', [8811]], ['Gg', [8921]], ['ggg', [8921]], ['gimel', [8503]], ['GJcy', [1027]], ['gjcy', [1107]], ['gla', [10917]], ['gl', [8823]], ['glE', [10898]], ['glj', [10916]], ['gnap', [10890]], ['gnapprox', [10890]], ['gne', [10888]], ['gnE', [8809]], ['gneq', [10888]], ['gneqq', [8809]], ['gnsim', [8935]], ['Gopf', [120126]], ['gopf', [120152]], ['grave', [96]], ['GreaterEqual', [8805]], ['GreaterEqualLess', [8923]], ['GreaterFullEqual', [8807]], ['GreaterGreater', [10914]], ['GreaterLess', [8823]], ['GreaterSlantEqual', [10878]], ['GreaterTilde', [8819]], ['Gscr', [119970]], ['gscr', [8458]], ['gsim', [8819]], ['gsime', [10894]], ['gsiml', [10896]], ['gtcc', [10919]], ['gtcir', [10874]], ['gt', [62]], ['GT', [62]], ['Gt', [8811]], ['gtdot', [8919]], ['gtlPar', [10645]], ['gtquest', [10876]], ['gtrapprox', [10886]], ['gtrarr', [10616]], ['gtrdot', [8919]], ['gtreqless', [8923]], ['gtreqqless', [10892]], ['gtrless', [8823]], ['gtrsim', [8819]], ['gvertneqq', [8809, 65024]], ['gvnE', [8809, 65024]], ['Hacek', [711]], ['hairsp', [8202]], ['half', [189]], ['hamilt', [8459]], ['HARDcy', [1066]], ['hardcy', [1098]], ['harrcir', [10568]], ['harr', [8596]], ['hArr', [8660]], ['harrw', [8621]], ['Hat', [94]], ['hbar', [8463]], ['Hcirc', [292]], ['hcirc', [293]], ['hearts', [9829]], ['heartsuit', [9829]], ['hellip', [8230]], ['hercon', [8889]], ['hfr', [120101]], ['Hfr', [8460]], ['HilbertSpace', [8459]], ['hksearow', [10533]], ['hkswarow', [10534]], ['hoarr', [8703]], ['homtht', [8763]], ['hookleftarrow', [8617]], ['hookrightarrow', [8618]], ['hopf', [120153]], ['Hopf', [8461]], ['horbar', [8213]], ['HorizontalLine', [9472]], ['hscr', [119997]], ['Hscr', [8459]], ['hslash', [8463]], ['Hstrok', [294]], ['hstrok', [295]], ['HumpDownHump', [8782]], ['HumpEqual', [8783]], ['hybull', [8259]], ['hyphen', [8208]], ['Iacute', [205]], ['iacute', [237]], ['ic', [8291]], ['Icirc', [206]], ['icirc', [238]], ['Icy', [1048]], ['icy', [1080]], ['Idot', [304]], ['IEcy', [1045]], ['iecy', [1077]], ['iexcl', [161]], ['iff', [8660]], ['ifr', [120102]], ['Ifr', [8465]], ['Igrave', [204]], ['igrave', [236]], ['ii', [8520]], ['iiiint', [10764]], ['iiint', [8749]], ['iinfin', [10716]], ['iiota', [8489]], ['IJlig', [306]], ['ijlig', [307]], ['Imacr', [298]], ['imacr', [299]], ['image', [8465]], ['ImaginaryI', [8520]], ['imagline', [8464]], ['imagpart', [8465]], ['imath', [305]], ['Im', [8465]], ['imof', [8887]], ['imped', [437]], ['Implies', [8658]], ['incare', [8453]], ['in', [8712]], ['infin', [8734]], ['infintie', [10717]], ['inodot', [305]], ['intcal', [8890]], ['int', [8747]], ['Int', [8748]], ['integers', [8484]], ['Integral', [8747]], ['intercal', [8890]], ['Intersection', [8898]], ['intlarhk', [10775]], ['intprod', [10812]], ['InvisibleComma', [8291]], ['InvisibleTimes', [8290]], ['IOcy', [1025]], ['iocy', [1105]], ['Iogon', [302]], ['iogon', [303]], ['Iopf', [120128]], ['iopf', [120154]], ['Iota', [921]], ['iota', [953]], ['iprod', [10812]], ['iquest', [191]], ['iscr', [119998]], ['Iscr', [8464]], ['isin', [8712]], ['isindot', [8949]], ['isinE', [8953]], ['isins', [8948]], ['isinsv', [8947]], ['isinv', [8712]], ['it', [8290]], ['Itilde', [296]], ['itilde', [297]], ['Iukcy', [1030]], ['iukcy', [1110]], ['Iuml', [207]], ['iuml', [239]], ['Jcirc', [308]], ['jcirc', [309]], ['Jcy', [1049]], ['jcy', [1081]], ['Jfr', [120077]], ['jfr', [120103]], ['jmath', [567]], ['Jopf', [120129]], ['jopf', [120155]], ['Jscr', [119973]], ['jscr', [119999]], ['Jsercy', [1032]], ['jsercy', [1112]], ['Jukcy', [1028]], ['jukcy', [1108]], ['Kappa', [922]], ['kappa', [954]], ['kappav', [1008]], ['Kcedil', [310]], ['kcedil', [311]], ['Kcy', [1050]], ['kcy', [1082]], ['Kfr', [120078]], ['kfr', [120104]], ['kgreen', [312]], ['KHcy', [1061]], ['khcy', [1093]], ['KJcy', [1036]], ['kjcy', [1116]], ['Kopf', [120130]], ['kopf', [120156]], ['Kscr', [119974]], ['kscr', [120000]], ['lAarr', [8666]], ['Lacute', [313]], ['lacute', [314]], ['laemptyv', [10676]], ['lagran', [8466]], ['Lambda', [923]], ['lambda', [955]], ['lang', [10216]], ['Lang', [10218]], ['langd', [10641]], ['langle', [10216]], ['lap', [10885]], ['Laplacetrf', [8466]], ['laquo', [171]], ['larrb', [8676]], ['larrbfs', [10527]], ['larr', [8592]], ['Larr', [8606]], ['lArr', [8656]], ['larrfs', [10525]], ['larrhk', [8617]], ['larrlp', [8619]], ['larrpl', [10553]], ['larrsim', [10611]], ['larrtl', [8610]], ['latail', [10521]], ['lAtail', [10523]], ['lat', [10923]], ['late', [10925]], ['lates', [10925, 65024]], ['lbarr', [10508]], ['lBarr', [10510]], ['lbbrk', [10098]], ['lbrace', [123]], ['lbrack', [91]], ['lbrke', [10635]], ['lbrksld', [10639]], ['lbrkslu', [10637]], ['Lcaron', [317]], ['lcaron', [318]], ['Lcedil', [315]], ['lcedil', [316]], ['lceil', [8968]], ['lcub', [123]], ['Lcy', [1051]], ['lcy', [1083]], ['ldca', [10550]], ['ldquo', [8220]], ['ldquor', [8222]], ['ldrdhar', [10599]], ['ldrushar', [10571]], ['ldsh', [8626]], ['le', [8804]], ['lE', [8806]], ['LeftAngleBracket', [10216]], ['LeftArrowBar', [8676]], ['leftarrow', [8592]], ['LeftArrow', [8592]], ['Leftarrow', [8656]], ['LeftArrowRightArrow', [8646]], ['leftarrowtail', [8610]], ['LeftCeiling', [8968]], ['LeftDoubleBracket', [10214]], ['LeftDownTeeVector', [10593]], ['LeftDownVectorBar', [10585]], ['LeftDownVector', [8643]], ['LeftFloor', [8970]], ['leftharpoondown', [8637]], ['leftharpoonup', [8636]], ['leftleftarrows', [8647]], ['leftrightarrow', [8596]], ['LeftRightArrow', [8596]], ['Leftrightarrow', [8660]], ['leftrightarrows', [8646]], ['leftrightharpoons', [8651]], ['leftrightsquigarrow', [8621]], ['LeftRightVector', [10574]], ['LeftTeeArrow', [8612]], ['LeftTee', [8867]], ['LeftTeeVector', [10586]], ['leftthreetimes', [8907]], ['LeftTriangleBar', [10703]], ['LeftTriangle', [8882]], ['LeftTriangleEqual', [8884]], ['LeftUpDownVector', [10577]], ['LeftUpTeeVector', [10592]], ['LeftUpVectorBar', [10584]], ['LeftUpVector', [8639]], ['LeftVectorBar', [10578]], ['LeftVector', [8636]], ['lEg', [10891]], ['leg', [8922]], ['leq', [8804]], ['leqq', [8806]], ['leqslant', [10877]], ['lescc', [10920]], ['les', [10877]], ['lesdot', [10879]], ['lesdoto', [10881]], ['lesdotor', [10883]], ['lesg', [8922, 65024]], ['lesges', [10899]], ['lessapprox', [10885]], ['lessdot', [8918]], ['lesseqgtr', [8922]], ['lesseqqgtr', [10891]], ['LessEqualGreater', [8922]], ['LessFullEqual', [8806]], ['LessGreater', [8822]], ['lessgtr', [8822]], ['LessLess', [10913]], ['lesssim', [8818]], ['LessSlantEqual', [10877]], ['LessTilde', [8818]], ['lfisht', [10620]], ['lfloor', [8970]], ['Lfr', [120079]], ['lfr', [120105]], ['lg', [8822]], ['lgE', [10897]], ['lHar', [10594]], ['lhard', [8637]], ['lharu', [8636]], ['lharul', [10602]], ['lhblk', [9604]], ['LJcy', [1033]], ['ljcy', [1113]], ['llarr', [8647]], ['ll', [8810]], ['Ll', [8920]], ['llcorner', [8990]], ['Lleftarrow', [8666]], ['llhard', [10603]], ['lltri', [9722]], ['Lmidot', [319]], ['lmidot', [320]], ['lmoustache', [9136]], ['lmoust', [9136]], ['lnap', [10889]], ['lnapprox', [10889]], ['lne', [10887]], ['lnE', [8808]], ['lneq', [10887]], ['lneqq', [8808]], ['lnsim', [8934]], ['loang', [10220]], ['loarr', [8701]], ['lobrk', [10214]], ['longleftarrow', [10229]], ['LongLeftArrow', [10229]], ['Longleftarrow', [10232]], ['longleftrightarrow', [10231]], ['LongLeftRightArrow', [10231]], ['Longleftrightarrow', [10234]], ['longmapsto', [10236]], ['longrightarrow', [10230]], ['LongRightArrow', [10230]], ['Longrightarrow', [10233]], ['looparrowleft', [8619]], ['looparrowright', [8620]], ['lopar', [10629]], ['Lopf', [120131]], ['lopf', [120157]], ['loplus', [10797]], ['lotimes', [10804]], ['lowast', [8727]], ['lowbar', [95]], ['LowerLeftArrow', [8601]], ['LowerRightArrow', [8600]], ['loz', [9674]], ['lozenge', [9674]], ['lozf', [10731]], ['lpar', [40]], ['lparlt', [10643]], ['lrarr', [8646]], ['lrcorner', [8991]], ['lrhar', [8651]], ['lrhard', [10605]], ['lrm', [8206]], ['lrtri', [8895]], ['lsaquo', [8249]], ['lscr', [120001]], ['Lscr', [8466]], ['lsh', [8624]], ['Lsh', [8624]], ['lsim', [8818]], ['lsime', [10893]], ['lsimg', [10895]], ['lsqb', [91]], ['lsquo', [8216]], ['lsquor', [8218]], ['Lstrok', [321]], ['lstrok', [322]], ['ltcc', [10918]], ['ltcir', [10873]], ['lt', [60]], ['LT', [60]], ['Lt', [8810]], ['ltdot', [8918]], ['lthree', [8907]], ['ltimes', [8905]], ['ltlarr', [10614]], ['ltquest', [10875]], ['ltri', [9667]], ['ltrie', [8884]], ['ltrif', [9666]], ['ltrPar', [10646]], ['lurdshar', [10570]], ['luruhar', [10598]], ['lvertneqq', [8808, 65024]], ['lvnE', [8808, 65024]], ['macr', [175]], ['male', [9794]], ['malt', [10016]], ['maltese', [10016]], ['Map', [10501]], ['map', [8614]], ['mapsto', [8614]], ['mapstodown', [8615]], ['mapstoleft', [8612]], ['mapstoup', [8613]], ['marker', [9646]], ['mcomma', [10793]], ['Mcy', [1052]], ['mcy', [1084]], ['mdash', [8212]], ['mDDot', [8762]], ['measuredangle', [8737]], ['MediumSpace', [8287]], ['Mellintrf', [8499]], ['Mfr', [120080]], ['mfr', [120106]], ['mho', [8487]], ['micro', [181]], ['midast', [42]], ['midcir', [10992]], ['mid', [8739]], ['middot', [183]], ['minusb', [8863]], ['minus', [8722]], ['minusd', [8760]], ['minusdu', [10794]], ['MinusPlus', [8723]], ['mlcp', [10971]], ['mldr', [8230]], ['mnplus', [8723]], ['models', [8871]], ['Mopf', [120132]], ['mopf', [120158]], ['mp', [8723]], ['mscr', [120002]], ['Mscr', [8499]], ['mstpos', [8766]], ['Mu', [924]], ['mu', [956]], ['multimap', [8888]], ['mumap', [8888]], ['nabla', [8711]], ['Nacute', [323]], ['nacute', [324]], ['nang', [8736, 8402]], ['nap', [8777]], ['napE', [10864, 824]], ['napid', [8779, 824]], ['napos', [329]], ['napprox', [8777]], ['natural', [9838]], ['naturals', [8469]], ['natur', [9838]], ['nbsp', [160]], ['nbump', [8782, 824]], ['nbumpe', [8783, 824]], ['ncap', [10819]], ['Ncaron', [327]], ['ncaron', [328]], ['Ncedil', [325]], ['ncedil', [326]], ['ncong', [8775]], ['ncongdot', [10861, 824]], ['ncup', [10818]], ['Ncy', [1053]], ['ncy', [1085]], ['ndash', [8211]], ['nearhk', [10532]], ['nearr', [8599]], ['neArr', [8663]], ['nearrow', [8599]], ['ne', [8800]], ['nedot', [8784, 824]], ['NegativeMediumSpace', [8203]], ['NegativeThickSpace', [8203]], ['NegativeThinSpace', [8203]], ['NegativeVeryThinSpace', [8203]], ['nequiv', [8802]], ['nesear', [10536]], ['nesim', [8770, 824]], ['NestedGreaterGreater', [8811]], ['NestedLessLess', [8810]], ['nexist', [8708]], ['nexists', [8708]], ['Nfr', [120081]], ['nfr', [120107]], ['ngE', [8807, 824]], ['nge', [8817]], ['ngeq', [8817]], ['ngeqq', [8807, 824]], ['ngeqslant', [10878, 824]], ['nges', [10878, 824]], ['nGg', [8921, 824]], ['ngsim', [8821]], ['nGt', [8811, 8402]], ['ngt', [8815]], ['ngtr', [8815]], ['nGtv', [8811, 824]], ['nharr', [8622]], ['nhArr', [8654]], ['nhpar', [10994]], ['ni', [8715]], ['nis', [8956]], ['nisd', [8954]], ['niv', [8715]], ['NJcy', [1034]], ['njcy', [1114]], ['nlarr', [8602]], ['nlArr', [8653]], ['nldr', [8229]], ['nlE', [8806, 824]], ['nle', [8816]], ['nleftarrow', [8602]], ['nLeftarrow', [8653]], ['nleftrightarrow', [8622]], ['nLeftrightarrow', [8654]], ['nleq', [8816]], ['nleqq', [8806, 824]], ['nleqslant', [10877, 824]], ['nles', [10877, 824]], ['nless', [8814]], ['nLl', [8920, 824]], ['nlsim', [8820]], ['nLt', [8810, 8402]], ['nlt', [8814]], ['nltri', [8938]], ['nltrie', [8940]], ['nLtv', [8810, 824]], ['nmid', [8740]], ['NoBreak', [8288]], ['NonBreakingSpace', [160]], ['nopf', [120159]], ['Nopf', [8469]], ['Not', [10988]], ['not', [172]], ['NotCongruent', [8802]], ['NotCupCap', [8813]], ['NotDoubleVerticalBar', [8742]], ['NotElement', [8713]], ['NotEqual', [8800]], ['NotEqualTilde', [8770, 824]], ['NotExists', [8708]], ['NotGreater', [8815]], ['NotGreaterEqual', [8817]], ['NotGreaterFullEqual', [8807, 824]], ['NotGreaterGreater', [8811, 824]], ['NotGreaterLess', [8825]], ['NotGreaterSlantEqual', [10878, 824]], ['NotGreaterTilde', [8821]], ['NotHumpDownHump', [8782, 824]], ['NotHumpEqual', [8783, 824]], ['notin', [8713]], ['notindot', [8949, 824]], ['notinE', [8953, 824]], ['notinva', [8713]], ['notinvb', [8951]], ['notinvc', [8950]], ['NotLeftTriangleBar', [10703, 824]], ['NotLeftTriangle', [8938]], ['NotLeftTriangleEqual', [8940]], ['NotLess', [8814]], ['NotLessEqual', [8816]], ['NotLessGreater', [8824]], ['NotLessLess', [8810, 824]], ['NotLessSlantEqual', [10877, 824]], ['NotLessTilde', [8820]], ['NotNestedGreaterGreater', [10914, 824]], ['NotNestedLessLess', [10913, 824]], ['notni', [8716]], ['notniva', [8716]], ['notnivb', [8958]], ['notnivc', [8957]], ['NotPrecedes', [8832]], ['NotPrecedesEqual', [10927, 824]], ['NotPrecedesSlantEqual', [8928]], ['NotReverseElement', [8716]], ['NotRightTriangleBar', [10704, 824]], ['NotRightTriangle', [8939]], ['NotRightTriangleEqual', [8941]], ['NotSquareSubset', [8847, 824]], ['NotSquareSubsetEqual', [8930]], ['NotSquareSuperset', [8848, 824]], ['NotSquareSupersetEqual', [8931]], ['NotSubset', [8834, 8402]], ['NotSubsetEqual', [8840]], ['NotSucceeds', [8833]], ['NotSucceedsEqual', [10928, 824]], ['NotSucceedsSlantEqual', [8929]], ['NotSucceedsTilde', [8831, 824]], ['NotSuperset', [8835, 8402]], ['NotSupersetEqual', [8841]], ['NotTilde', [8769]], ['NotTildeEqual', [8772]], ['NotTildeFullEqual', [8775]], ['NotTildeTilde', [8777]], ['NotVerticalBar', [8740]], ['nparallel', [8742]], ['npar', [8742]], ['nparsl', [11005, 8421]], ['npart', [8706, 824]], ['npolint', [10772]], ['npr', [8832]], ['nprcue', [8928]], ['nprec', [8832]], ['npreceq', [10927, 824]], ['npre', [10927, 824]], ['nrarrc', [10547, 824]], ['nrarr', [8603]], ['nrArr', [8655]], ['nrarrw', [8605, 824]], ['nrightarrow', [8603]], ['nRightarrow', [8655]], ['nrtri', [8939]], ['nrtrie', [8941]], ['nsc', [8833]], ['nsccue', [8929]], ['nsce', [10928, 824]], ['Nscr', [119977]], ['nscr', [120003]], ['nshortmid', [8740]], ['nshortparallel', [8742]], ['nsim', [8769]], ['nsime', [8772]], ['nsimeq', [8772]], ['nsmid', [8740]], ['nspar', [8742]], ['nsqsube', [8930]], ['nsqsupe', [8931]], ['nsub', [8836]], ['nsubE', [10949, 824]], ['nsube', [8840]], ['nsubset', [8834, 8402]], ['nsubseteq', [8840]], ['nsubseteqq', [10949, 824]], ['nsucc', [8833]], ['nsucceq', [10928, 824]], ['nsup', [8837]], ['nsupE', [10950, 824]], ['nsupe', [8841]], ['nsupset', [8835, 8402]], ['nsupseteq', [8841]], ['nsupseteqq', [10950, 824]], ['ntgl', [8825]], ['Ntilde', [209]], ['ntilde', [241]], ['ntlg', [8824]], ['ntriangleleft', [8938]], ['ntrianglelefteq', [8940]], ['ntriangleright', [8939]], ['ntrianglerighteq', [8941]], ['Nu', [925]], ['nu', [957]], ['num', [35]], ['numero', [8470]], ['numsp', [8199]], ['nvap', [8781, 8402]], ['nvdash', [8876]], ['nvDash', [8877]], ['nVdash', [8878]], ['nVDash', [8879]], ['nvge', [8805, 8402]], ['nvgt', [62, 8402]], ['nvHarr', [10500]], ['nvinfin', [10718]], ['nvlArr', [10498]], ['nvle', [8804, 8402]], ['nvlt', [60, 8402]], ['nvltrie', [8884, 8402]], ['nvrArr', [10499]], ['nvrtrie', [8885, 8402]], ['nvsim', [8764, 8402]], ['nwarhk', [10531]], ['nwarr', [8598]], ['nwArr', [8662]], ['nwarrow', [8598]], ['nwnear', [10535]], ['Oacute', [211]], ['oacute', [243]], ['oast', [8859]], ['Ocirc', [212]], ['ocirc', [244]], ['ocir', [8858]], ['Ocy', [1054]], ['ocy', [1086]], ['odash', [8861]], ['Odblac', [336]], ['odblac', [337]], ['odiv', [10808]], ['odot', [8857]], ['odsold', [10684]], ['OElig', [338]], ['oelig', [339]], ['ofcir', [10687]], ['Ofr', [120082]], ['ofr', [120108]], ['ogon', [731]], ['Ograve', [210]], ['ograve', [242]], ['ogt', [10689]], ['ohbar', [10677]], ['ohm', [937]], ['oint', [8750]], ['olarr', [8634]], ['olcir', [10686]], ['olcross', [10683]], ['oline', [8254]], ['olt', [10688]], ['Omacr', [332]], ['omacr', [333]], ['Omega', [937]], ['omega', [969]], ['Omicron', [927]], ['omicron', [959]], ['omid', [10678]], ['ominus', [8854]], ['Oopf', [120134]], ['oopf', [120160]], ['opar', [10679]], ['OpenCurlyDoubleQuote', [8220]], ['OpenCurlyQuote', [8216]], ['operp', [10681]], ['oplus', [8853]], ['orarr', [8635]], ['Or', [10836]], ['or', [8744]], ['ord', [10845]], ['order', [8500]], ['orderof', [8500]], ['ordf', [170]], ['ordm', [186]], ['origof', [8886]], ['oror', [10838]], ['orslope', [10839]], ['orv', [10843]], ['oS', [9416]], ['Oscr', [119978]], ['oscr', [8500]], ['Oslash', [216]], ['oslash', [248]], ['osol', [8856]], ['Otilde', [213]], ['otilde', [245]], ['otimesas', [10806]], ['Otimes', [10807]], ['otimes', [8855]], ['Ouml', [214]], ['ouml', [246]], ['ovbar', [9021]], ['OverBar', [8254]], ['OverBrace', [9182]], ['OverBracket', [9140]], ['OverParenthesis', [9180]], ['para', [182]], ['parallel', [8741]], ['par', [8741]], ['parsim', [10995]], ['parsl', [11005]], ['part', [8706]], ['PartialD', [8706]], ['Pcy', [1055]], ['pcy', [1087]], ['percnt', [37]], ['period', [46]], ['permil', [8240]], ['perp', [8869]], ['pertenk', [8241]], ['Pfr', [120083]], ['pfr', [120109]], ['Phi', [934]], ['phi', [966]], ['phiv', [981]], ['phmmat', [8499]], ['phone', [9742]], ['Pi', [928]], ['pi', [960]], ['pitchfork', [8916]], ['piv', [982]], ['planck', [8463]], ['planckh', [8462]], ['plankv', [8463]], ['plusacir', [10787]], ['plusb', [8862]], ['pluscir', [10786]], ['plus', [43]], ['plusdo', [8724]], ['plusdu', [10789]], ['pluse', [10866]], ['PlusMinus', [177]], ['plusmn', [177]], ['plussim', [10790]], ['plustwo', [10791]], ['pm', [177]], ['Poincareplane', [8460]], ['pointint', [10773]], ['popf', [120161]], ['Popf', [8473]], ['pound', [163]], ['prap', [10935]], ['Pr', [10939]], ['pr', [8826]], ['prcue', [8828]], ['precapprox', [10935]], ['prec', [8826]], ['preccurlyeq', [8828]], ['Precedes', [8826]], ['PrecedesEqual', [10927]], ['PrecedesSlantEqual', [8828]], ['PrecedesTilde', [8830]], ['preceq', [10927]], ['precnapprox', [10937]], ['precneqq', [10933]], ['precnsim', [8936]], ['pre', [10927]], ['prE', [10931]], ['precsim', [8830]], ['prime', [8242]], ['Prime', [8243]], ['primes', [8473]], ['prnap', [10937]], ['prnE', [10933]], ['prnsim', [8936]], ['prod', [8719]], ['Product', [8719]], ['profalar', [9006]], ['profline', [8978]], ['profsurf', [8979]], ['prop', [8733]], ['Proportional', [8733]], ['Proportion', [8759]], ['propto', [8733]], ['prsim', [8830]], ['prurel', [8880]], ['Pscr', [119979]], ['pscr', [120005]], ['Psi', [936]], ['psi', [968]], ['puncsp', [8200]], ['Qfr', [120084]], ['qfr', [120110]], ['qint', [10764]], ['qopf', [120162]], ['Qopf', [8474]], ['qprime', [8279]], ['Qscr', [119980]], ['qscr', [120006]], ['quaternions', [8461]], ['quatint', [10774]], ['quest', [63]], ['questeq', [8799]], ['quot', [34]], ['QUOT', [34]], ['rAarr', [8667]], ['race', [8765, 817]], ['Racute', [340]], ['racute', [341]], ['radic', [8730]], ['raemptyv', [10675]], ['rang', [10217]], ['Rang', [10219]], ['rangd', [10642]], ['range', [10661]], ['rangle', [10217]], ['raquo', [187]], ['rarrap', [10613]], ['rarrb', [8677]], ['rarrbfs', [10528]], ['rarrc', [10547]], ['rarr', [8594]], ['Rarr', [8608]], ['rArr', [8658]], ['rarrfs', [10526]], ['rarrhk', [8618]], ['rarrlp', [8620]], ['rarrpl', [10565]], ['rarrsim', [10612]], ['Rarrtl', [10518]], ['rarrtl', [8611]], ['rarrw', [8605]], ['ratail', [10522]], ['rAtail', [10524]], ['ratio', [8758]], ['rationals', [8474]], ['rbarr', [10509]], ['rBarr', [10511]], ['RBarr', [10512]], ['rbbrk', [10099]], ['rbrace', [125]], ['rbrack', [93]], ['rbrke', [10636]], ['rbrksld', [10638]], ['rbrkslu', [10640]], ['Rcaron', [344]], ['rcaron', [345]], ['Rcedil', [342]], ['rcedil', [343]], ['rceil', [8969]], ['rcub', [125]], ['Rcy', [1056]], ['rcy', [1088]], ['rdca', [10551]], ['rdldhar', [10601]], ['rdquo', [8221]], ['rdquor', [8221]], ['CloseCurlyDoubleQuote', [8221]], ['rdsh', [8627]], ['real', [8476]], ['realine', [8475]], ['realpart', [8476]], ['reals', [8477]], ['Re', [8476]], ['rect', [9645]], ['reg', [174]], ['REG', [174]], ['ReverseElement', [8715]], ['ReverseEquilibrium', [8651]], ['ReverseUpEquilibrium', [10607]], ['rfisht', [10621]], ['rfloor', [8971]], ['rfr', [120111]], ['Rfr', [8476]], ['rHar', [10596]], ['rhard', [8641]], ['rharu', [8640]], ['rharul', [10604]], ['Rho', [929]], ['rho', [961]], ['rhov', [1009]], ['RightAngleBracket', [10217]], ['RightArrowBar', [8677]], ['rightarrow', [8594]], ['RightArrow', [8594]], ['Rightarrow', [8658]], ['RightArrowLeftArrow', [8644]], ['rightarrowtail', [8611]], ['RightCeiling', [8969]], ['RightDoubleBracket', [10215]], ['RightDownTeeVector', [10589]], ['RightDownVectorBar', [10581]], ['RightDownVector', [8642]], ['RightFloor', [8971]], ['rightharpoondown', [8641]], ['rightharpoonup', [8640]], ['rightleftarrows', [8644]], ['rightleftharpoons', [8652]], ['rightrightarrows', [8649]], ['rightsquigarrow', [8605]], ['RightTeeArrow', [8614]], ['RightTee', [8866]], ['RightTeeVector', [10587]], ['rightthreetimes', [8908]], ['RightTriangleBar', [10704]], ['RightTriangle', [8883]], ['RightTriangleEqual', [8885]], ['RightUpDownVector', [10575]], ['RightUpTeeVector', [10588]], ['RightUpVectorBar', [10580]], ['RightUpVector', [8638]], ['RightVectorBar', [10579]], ['RightVector', [8640]], ['ring', [730]], ['risingdotseq', [8787]], ['rlarr', [8644]], ['rlhar', [8652]], ['rlm', [8207]], ['rmoustache', [9137]], ['rmoust', [9137]], ['rnmid', [10990]], ['roang', [10221]], ['roarr', [8702]], ['robrk', [10215]], ['ropar', [10630]], ['ropf', [120163]], ['Ropf', [8477]], ['roplus', [10798]], ['rotimes', [10805]], ['RoundImplies', [10608]], ['rpar', [41]], ['rpargt', [10644]], ['rppolint', [10770]], ['rrarr', [8649]], ['Rrightarrow', [8667]], ['rsaquo', [8250]], ['rscr', [120007]], ['Rscr', [8475]], ['rsh', [8625]], ['Rsh', [8625]], ['rsqb', [93]], ['rsquo', [8217]], ['rsquor', [8217]], ['CloseCurlyQuote', [8217]], ['rthree', [8908]], ['rtimes', [8906]], ['rtri', [9657]], ['rtrie', [8885]], ['rtrif', [9656]], ['rtriltri', [10702]], ['RuleDelayed', [10740]], ['ruluhar', [10600]], ['rx', [8478]], ['Sacute', [346]], ['sacute', [347]], ['sbquo', [8218]], ['scap', [10936]], ['Scaron', [352]], ['scaron', [353]], ['Sc', [10940]], ['sc', [8827]], ['sccue', [8829]], ['sce', [10928]], ['scE', [10932]], ['Scedil', [350]], ['scedil', [351]], ['Scirc', [348]], ['scirc', [349]], ['scnap', [10938]], ['scnE', [10934]], ['scnsim', [8937]], ['scpolint', [10771]], ['scsim', [8831]], ['Scy', [1057]], ['scy', [1089]], ['sdotb', [8865]], ['sdot', [8901]], ['sdote', [10854]], ['searhk', [10533]], ['searr', [8600]], ['seArr', [8664]], ['searrow', [8600]], ['sect', [167]], ['semi', [59]], ['seswar', [10537]], ['setminus', [8726]], ['setmn', [8726]], ['sext', [10038]], ['Sfr', [120086]], ['sfr', [120112]], ['sfrown', [8994]], ['sharp', [9839]], ['SHCHcy', [1065]], ['shchcy', [1097]], ['SHcy', [1064]], ['shcy', [1096]], ['ShortDownArrow', [8595]], ['ShortLeftArrow', [8592]], ['shortmid', [8739]], ['shortparallel', [8741]], ['ShortRightArrow', [8594]], ['ShortUpArrow', [8593]], ['shy', [173]], ['Sigma', [931]], ['sigma', [963]], ['sigmaf', [962]], ['sigmav', [962]], ['sim', [8764]], ['simdot', [10858]], ['sime', [8771]], ['simeq', [8771]], ['simg', [10910]], ['simgE', [10912]], ['siml', [10909]], ['simlE', [10911]], ['simne', [8774]], ['simplus', [10788]], ['simrarr', [10610]], ['slarr', [8592]], ['SmallCircle', [8728]], ['smallsetminus', [8726]], ['smashp', [10803]], ['smeparsl', [10724]], ['smid', [8739]], ['smile', [8995]], ['smt', [10922]], ['smte', [10924]], ['smtes', [10924, 65024]], ['SOFTcy', [1068]], ['softcy', [1100]], ['solbar', [9023]], ['solb', [10692]], ['sol', [47]], ['Sopf', [120138]], ['sopf', [120164]], ['spades', [9824]], ['spadesuit', [9824]], ['spar', [8741]], ['sqcap', [8851]], ['sqcaps', [8851, 65024]], ['sqcup', [8852]], ['sqcups', [8852, 65024]], ['Sqrt', [8730]], ['sqsub', [8847]], ['sqsube', [8849]], ['sqsubset', [8847]], ['sqsubseteq', [8849]], ['sqsup', [8848]], ['sqsupe', [8850]], ['sqsupset', [8848]], ['sqsupseteq', [8850]], ['square', [9633]], ['Square', [9633]], ['SquareIntersection', [8851]], ['SquareSubset', [8847]], ['SquareSubsetEqual', [8849]], ['SquareSuperset', [8848]], ['SquareSupersetEqual', [8850]], ['SquareUnion', [8852]], ['squarf', [9642]], ['squ', [9633]], ['squf', [9642]], ['srarr', [8594]], ['Sscr', [119982]], ['sscr', [120008]], ['ssetmn', [8726]], ['ssmile', [8995]], ['sstarf', [8902]], ['Star', [8902]], ['star', [9734]], ['starf', [9733]], ['straightepsilon', [1013]], ['straightphi', [981]], ['strns', [175]], ['sub', [8834]], ['Sub', [8912]], ['subdot', [10941]], ['subE', [10949]], ['sube', [8838]], ['subedot', [10947]], ['submult', [10945]], ['subnE', [10955]], ['subne', [8842]], ['subplus', [10943]], ['subrarr', [10617]], ['subset', [8834]], ['Subset', [8912]], ['subseteq', [8838]], ['subseteqq', [10949]], ['SubsetEqual', [8838]], ['subsetneq', [8842]], ['subsetneqq', [10955]], ['subsim', [10951]], ['subsub', [10965]], ['subsup', [10963]], ['succapprox', [10936]], ['succ', [8827]], ['succcurlyeq', [8829]], ['Succeeds', [8827]], ['SucceedsEqual', [10928]], ['SucceedsSlantEqual', [8829]], ['SucceedsTilde', [8831]], ['succeq', [10928]], ['succnapprox', [10938]], ['succneqq', [10934]], ['succnsim', [8937]], ['succsim', [8831]], ['SuchThat', [8715]], ['sum', [8721]], ['Sum', [8721]], ['sung', [9834]], ['sup1', [185]], ['sup2', [178]], ['sup3', [179]], ['sup', [8835]], ['Sup', [8913]], ['supdot', [10942]], ['supdsub', [10968]], ['supE', [10950]], ['supe', [8839]], ['supedot', [10948]], ['Superset', [8835]], ['SupersetEqual', [8839]], ['suphsol', [10185]], ['suphsub', [10967]], ['suplarr', [10619]], ['supmult', [10946]], ['supnE', [10956]], ['supne', [8843]], ['supplus', [10944]], ['supset', [8835]], ['Supset', [8913]], ['supseteq', [8839]], ['supseteqq', [10950]], ['supsetneq', [8843]], ['supsetneqq', [10956]], ['supsim', [10952]], ['supsub', [10964]], ['supsup', [10966]], ['swarhk', [10534]], ['swarr', [8601]], ['swArr', [8665]], ['swarrow', [8601]], ['swnwar', [10538]], ['szlig', [223]], ['Tab', [9]], ['target', [8982]], ['Tau', [932]], ['tau', [964]], ['tbrk', [9140]], ['Tcaron', [356]], ['tcaron', [357]], ['Tcedil', [354]], ['tcedil', [355]], ['Tcy', [1058]], ['tcy', [1090]], ['tdot', [8411]], ['telrec', [8981]], ['Tfr', [120087]], ['tfr', [120113]], ['there4', [8756]], ['therefore', [8756]], ['Therefore', [8756]], ['Theta', [920]], ['theta', [952]], ['thetasym', [977]], ['thetav', [977]], ['thickapprox', [8776]], ['thicksim', [8764]], ['ThickSpace', [8287, 8202]], ['ThinSpace', [8201]], ['thinsp', [8201]], ['thkap', [8776]], ['thksim', [8764]], ['THORN', [222]], ['thorn', [254]], ['tilde', [732]], ['Tilde', [8764]], ['TildeEqual', [8771]], ['TildeFullEqual', [8773]], ['TildeTilde', [8776]], ['timesbar', [10801]], ['timesb', [8864]], ['times', [215]], ['timesd', [10800]], ['tint', [8749]], ['toea', [10536]], ['topbot', [9014]], ['topcir', [10993]], ['top', [8868]], ['Topf', [120139]], ['topf', [120165]], ['topfork', [10970]], ['tosa', [10537]], ['tprime', [8244]], ['trade', [8482]], ['TRADE', [8482]], ['triangle', [9653]], ['triangledown', [9663]], ['triangleleft', [9667]], ['trianglelefteq', [8884]], ['triangleq', [8796]], ['triangleright', [9657]], ['trianglerighteq', [8885]], ['tridot', [9708]], ['trie', [8796]], ['triminus', [10810]], ['TripleDot', [8411]], ['triplus', [10809]], ['trisb', [10701]], ['tritime', [10811]], ['trpezium', [9186]], ['Tscr', [119983]], ['tscr', [120009]], ['TScy', [1062]], ['tscy', [1094]], ['TSHcy', [1035]], ['tshcy', [1115]], ['Tstrok', [358]], ['tstrok', [359]], ['twixt', [8812]], ['twoheadleftarrow', [8606]], ['twoheadrightarrow', [8608]], ['Uacute', [218]], ['uacute', [250]], ['uarr', [8593]], ['Uarr', [8607]], ['uArr', [8657]], ['Uarrocir', [10569]], ['Ubrcy', [1038]], ['ubrcy', [1118]], ['Ubreve', [364]], ['ubreve', [365]], ['Ucirc', [219]], ['ucirc', [251]], ['Ucy', [1059]], ['ucy', [1091]], ['udarr', [8645]], ['Udblac', [368]], ['udblac', [369]], ['udhar', [10606]], ['ufisht', [10622]], ['Ufr', [120088]], ['ufr', [120114]], ['Ugrave', [217]], ['ugrave', [249]], ['uHar', [10595]], ['uharl', [8639]], ['uharr', [8638]], ['uhblk', [9600]], ['ulcorn', [8988]], ['ulcorner', [8988]], ['ulcrop', [8975]], ['ultri', [9720]], ['Umacr', [362]], ['umacr', [363]], ['uml', [168]], ['UnderBar', [95]], ['UnderBrace', [9183]], ['UnderBracket', [9141]], ['UnderParenthesis', [9181]], ['Union', [8899]], ['UnionPlus', [8846]], ['Uogon', [370]], ['uogon', [371]], ['Uopf', [120140]], ['uopf', [120166]], ['UpArrowBar', [10514]], ['uparrow', [8593]], ['UpArrow', [8593]], ['Uparrow', [8657]], ['UpArrowDownArrow', [8645]], ['updownarrow', [8597]], ['UpDownArrow', [8597]], ['Updownarrow', [8661]], ['UpEquilibrium', [10606]], ['upharpoonleft', [8639]], ['upharpoonright', [8638]], ['uplus', [8846]], ['UpperLeftArrow', [8598]], ['UpperRightArrow', [8599]], ['upsi', [965]], ['Upsi', [978]], ['upsih', [978]], ['Upsilon', [933]], ['upsilon', [965]], ['UpTeeArrow', [8613]], ['UpTee', [8869]], ['upuparrows', [8648]], ['urcorn', [8989]], ['urcorner', [8989]], ['urcrop', [8974]], ['Uring', [366]], ['uring', [367]], ['urtri', [9721]], ['Uscr', [119984]], ['uscr', [120010]], ['utdot', [8944]], ['Utilde', [360]], ['utilde', [361]], ['utri', [9653]], ['utrif', [9652]], ['uuarr', [8648]], ['Uuml', [220]], ['uuml', [252]], ['uwangle', [10663]], ['vangrt', [10652]], ['varepsilon', [1013]], ['varkappa', [1008]], ['varnothing', [8709]], ['varphi', [981]], ['varpi', [982]], ['varpropto', [8733]], ['varr', [8597]], ['vArr', [8661]], ['varrho', [1009]], ['varsigma', [962]], ['varsubsetneq', [8842, 65024]], ['varsubsetneqq', [10955, 65024]], ['varsupsetneq', [8843, 65024]], ['varsupsetneqq', [10956, 65024]], ['vartheta', [977]], ['vartriangleleft', [8882]], ['vartriangleright', [8883]], ['vBar', [10984]], ['Vbar', [10987]], ['vBarv', [10985]], ['Vcy', [1042]], ['vcy', [1074]], ['vdash', [8866]], ['vDash', [8872]], ['Vdash', [8873]], ['VDash', [8875]], ['Vdashl', [10982]], ['veebar', [8891]], ['vee', [8744]], ['Vee', [8897]], ['veeeq', [8794]], ['vellip', [8942]], ['verbar', [124]], ['Verbar', [8214]], ['vert', [124]], ['Vert', [8214]], ['VerticalBar', [8739]], ['VerticalLine', [124]], ['VerticalSeparator', [10072]], ['VerticalTilde', [8768]], ['VeryThinSpace', [8202]], ['Vfr', [120089]], ['vfr', [120115]], ['vltri', [8882]], ['vnsub', [8834, 8402]], ['vnsup', [8835, 8402]], ['Vopf', [120141]], ['vopf', [120167]], ['vprop', [8733]], ['vrtri', [8883]], ['Vscr', [119985]], ['vscr', [120011]], ['vsubnE', [10955, 65024]], ['vsubne', [8842, 65024]], ['vsupnE', [10956, 65024]], ['vsupne', [8843, 65024]], ['Vvdash', [8874]], ['vzigzag', [10650]], ['Wcirc', [372]], ['wcirc', [373]], ['wedbar', [10847]], ['wedge', [8743]], ['Wedge', [8896]], ['wedgeq', [8793]], ['weierp', [8472]], ['Wfr', [120090]], ['wfr', [120116]], ['Wopf', [120142]], ['wopf', [120168]], ['wp', [8472]], ['wr', [8768]], ['wreath', [8768]], ['Wscr', [119986]], ['wscr', [120012]], ['xcap', [8898]], ['xcirc', [9711]], ['xcup', [8899]], ['xdtri', [9661]], ['Xfr', [120091]], ['xfr', [120117]], ['xharr', [10231]], ['xhArr', [10234]], ['Xi', [926]], ['xi', [958]], ['xlarr', [10229]], ['xlArr', [10232]], ['xmap', [10236]], ['xnis', [8955]], ['xodot', [10752]], ['Xopf', [120143]], ['xopf', [120169]], ['xoplus', [10753]], ['xotime', [10754]], ['xrarr', [10230]], ['xrArr', [10233]], ['Xscr', [119987]], ['xscr', [120013]], ['xsqcup', [10758]], ['xuplus', [10756]], ['xutri', [9651]], ['xvee', [8897]], ['xwedge', [8896]], ['Yacute', [221]], ['yacute', [253]], ['YAcy', [1071]], ['yacy', [1103]], ['Ycirc', [374]], ['ycirc', [375]], ['Ycy', [1067]], ['ycy', [1099]], ['yen', [165]], ['Yfr', [120092]], ['yfr', [120118]], ['YIcy', [1031]], ['yicy', [1111]], ['Yopf', [120144]], ['yopf', [120170]], ['Yscr', [119988]], ['yscr', [120014]], ['YUcy', [1070]], ['yucy', [1102]], ['yuml', [255]], ['Yuml', [376]], ['Zacute', [377]], ['zacute', [378]], ['Zcaron', [381]], ['zcaron', [382]], ['Zcy', [1047]], ['zcy', [1079]], ['Zdot', [379]], ['zdot', [380]], ['zeetrf', [8488]], ['ZeroWidthSpace', [8203]], ['Zeta', [918]], ['zeta', [950]], ['zfr', [120119]], ['Zfr', [8488]], ['ZHcy', [1046]], ['zhcy', [1078]], ['zigrarr', [8669]], ['zopf', [120171]], ['Zopf', [8484]], ['Zscr', [119989]], ['zscr', [120015]], ['zwj', [8205]], ['zwnj', [8204]]];

var alphaIndex = {};
var charIndex = {};

createIndexes(alphaIndex, charIndex);

/**
 * @constructor
 */
function Html5Entities() {}

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.decode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    return str.replace(/&(#?[\w\d]+);?/g, function(s, entity) {
        var chr;
        if (entity.charAt(0) === "#") {
            var code = entity.charAt(1) === 'x' ?
                parseInt(entity.substr(2).toLowerCase(), 16) :
                parseInt(entity.substr(1));

            if (!(isNaN(code) || code < -32768 || code > 65535)) {
                chr = String.fromCharCode(code);
            }
        } else {
            chr = alphaIndex[entity];
        }
        return chr || s;
    });
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.decode = function(str) {
    return new Html5Entities().decode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encode = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var charInfo = charIndex[str.charCodeAt(i)];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        result += str.charAt(i);
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encode = function(str) {
    return new Html5Entities().encode(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonUTF = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        var charInfo = charIndex[c];
        if (charInfo) {
            var alpha = charInfo[str.charCodeAt(i + 1)];
            if (alpha) {
                i++;
            } else {
                alpha = charInfo[''];
            }
            if (alpha) {
                result += "&" + alpha + ";";
                i++;
                continue;
            }
        }
        if (c < 32 || c > 126) {
            result += '&#' + c + ';';
        } else {
            result += str.charAt(i);
        }
        i++;
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonUTF = function(str) {
    return new Html5Entities().encodeNonUTF(str);
 };

/**
 * @param {String} str
 * @returns {String}
 */
Html5Entities.prototype.encodeNonASCII = function(str) {
    if (!str || !str.length) {
        return '';
    }
    var strLength = str.length;
    var result = '';
    var i = 0;
    while (i < strLength) {
        var c = str.charCodeAt(i);
        if (c <= 255) {
            result += str[i++];
            continue;
        }
        result += '&#' + c + ';';
        i++
    }
    return result;
};

/**
 * @param {String} str
 * @returns {String}
 */
 Html5Entities.encodeNonASCII = function(str) {
    return new Html5Entities().encodeNonASCII(str);
 };

/**
 * @param {Object} alphaIndex Passed by reference.
 * @param {Object} charIndex Passed by reference.
 */
function createIndexes(alphaIndex, charIndex) {
    var i = ENTITIES.length;
    var _results = [];
    while (i--) {
        var e = ENTITIES[i];
        var alpha = e[0];
        var chars = e[1];
        var chr = chars[0];
        var addChar = (chr < 32 || chr > 126) || chr === 62 || chr === 60 || chr === 38 || chr === 34 || chr === 39;
        var charInfo;
        if (addChar) {
            charInfo = charIndex[chr] = charIndex[chr] || {};
        }
        if (chars[1]) {
            var chr2 = chars[1];
            alphaIndex[alpha] = String.fromCharCode(chr) + String.fromCharCode(chr2);
            _results.push(addChar && (charInfo[chr2] = alpha));
        } else {
            alphaIndex[alpha] = String.fromCharCode(chr);
            _results.push(addChar && (charInfo[''] = alpha));
        }
    }
}

module.exports = Html5Entities;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var log = __webpack_require__(16).getLogger('webpack-dev-server');

var INFO = 'info';
var WARN = 'warn';
var ERROR = 'error';
var DEBUG = 'debug';
var TRACE = 'trace';
var SILENT = 'silent'; // deprecated
// TODO: remove these at major released
// https://github.com/webpack/webpack-dev-server/pull/1825

var WARNING = 'warning';
var NONE = 'none'; // Set the default log level

log.setDefaultLevel(INFO);

function setLogLevel(level) {
  switch (level) {
    case INFO:
    case WARN:
    case ERROR:
    case DEBUG:
    case TRACE:
      log.setLevel(level);
      break;
    // deprecated

    case WARNING:
      // loglevel's warning name is different from webpack's
      log.setLevel('warn');
      break;
    // deprecated

    case NONE:
    case SILENT:
      log.disableAll();
      break;

    default:
      log.error("[WDS] Unknown clientLogLevel '".concat(level, "'"));
  }
}

module.exports = {
  log: log,
  setLogLevel: setLogLevel
};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
}(this, function () {
    "use strict";

    // Slightly dubious tricks to cut down minimized file size
    var noop = function() {};
    var undefinedType = "undefined";
    var isIE = (typeof window !== undefinedType) && (
        /Trident\/|MSIE /.test(window.navigator.userAgent)
    );

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    // Cross-browser bind equivalent that works at least back to IE6
    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // Trace() doesn't print the message in IE, so for that case we need to wrap it
    function traceForIE() {
        if (console.log) {
            if (console.log.apply) {
                console.log.apply(console, arguments);
            } else {
                // In old IE, native console methods themselves don't have apply().
                Function.prototype.apply.apply(console.log, [console, arguments]);
            }
        }
        if (console.trace) console.trace();
    }

    // Build the best logging method possible for this env
    // Wherever possible we want to bind, not wrap, to preserve stack traces
    function realMethod(methodName) {
        if (methodName === 'debug') {
            methodName = 'log';
        }

        if (typeof console === undefinedType) {
            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
        } else if (methodName === 'trace' && isIE) {
            return traceForIE;
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    // These private functions always need `this` to be set properly

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }

        // Define log.log as an alias for log.debug
        this.log = this.debug;
    }

    // In old IE versions, the console isn't present until you first open it.
    // We build realMethod() replacements here that regenerate logging methods
    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    // By default, we use closely bound real methods wherever possible, and
    // otherwise we wait for a console to appear, and then try again.
    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          if (typeof window === undefinedType) return;

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          if (typeof window === undefinedType) return;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          // Fallback to cookies if local storage gives us nothing
          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */

      self.name = name;

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Top-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    defaultLogger.getLoggers = function getLoggers() {
        return _loggersByName;
    };

    return defaultLogger;
}));


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global __resourceQuery WorkerGlobalScope self */
// Send messages to the outside, so plugins can consume it.

function sendMsg(type, data) {
  if (typeof self !== 'undefined' && (typeof WorkerGlobalScope === 'undefined' || !(self instanceof WorkerGlobalScope))) {
    self.postMessage({
      type: "webpack".concat(type),
      data: data
    }, '*');
  }
}

module.exports = sendMsg;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global WorkerGlobalScope self */

var _require = __webpack_require__(15),
    log = _require.log;

function reloadApp(_ref, _ref2) {
  var hotReload = _ref.hotReload,
      hot = _ref.hot,
      liveReload = _ref.liveReload;
  var isUnloading = _ref2.isUnloading,
      currentHash = _ref2.currentHash;

  if (isUnloading || !hotReload) {
    return;
  }

  if (hot) {
    log.info('[WDS] App hot update...');

    var hotEmitter = __webpack_require__(19);

    hotEmitter.emit('webpackHotUpdate', currentHash);

    if (typeof self !== 'undefined' && self.window) {
      // broadcast update to window
      self.postMessage("webpackHotUpdate".concat(currentHash), '*');
    }
  } // allow refreshing the page only if liveReload isn't disabled
  else if (liveReload) {
      var rootWindow = self; // use parent window for reload (in case we're in an iframe with no valid src)

      var intervalId = self.setInterval(function () {
        if (rootWindow.location.protocol !== 'about:') {
          // reload immediately if protocol is valid
          applyReload(rootWindow, intervalId);
        } else {
          rootWindow = rootWindow.parent;

          if (rootWindow.parent === rootWindow) {
            // if parent equals current window we've reached the root which would continue forever, so trigger a reload anyways
            applyReload(rootWindow, intervalId);
          }
        }
      });
    }

  function applyReload(rootWindow, intervalId) {
    clearInterval(intervalId);
    log.info('[WDS] App updated. Reloading...');
    rootWindow.location.reload();
  }
}

module.exports = reloadApp;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var EventEmitter = __webpack_require__(20);
module.exports = new EventEmitter();


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* global self */

var url = __webpack_require__(22);

var getCurrentScriptSource = __webpack_require__(29);

function createSocketUrl(resourceQuery, currentLocation) {
  var urlParts;

  if (typeof resourceQuery === 'string' && resourceQuery !== '') {
    // If this bundle is inlined, use the resource query to get the correct url.
    // format is like `?http://0.0.0.0:8096&sockPort=8097&sockHost=localhost`
    urlParts = url.parse(resourceQuery // strip leading `?` from query string to get a valid URL
    .substr(1) // replace first `&` with `?` to have a valid query string
    .replace('&', '?'), true);
  } else {
    // Else, get the url from the <script> this file was called with.
    var scriptHost = getCurrentScriptSource();
    urlParts = url.parse(scriptHost || '/', true, true);
  } // Use parameter to allow passing location in unit tests


  if (typeof currentLocation === 'string' && currentLocation !== '') {
    currentLocation = url.parse(currentLocation);
  } else {
    currentLocation = self.location;
  }

  return getSocketUrl(urlParts, currentLocation);
}
/*
 * Gets socket URL based on Script Source/Location
 * (scriptSrc: URL, location: URL) -> URL
 */


function getSocketUrl(urlParts, loc) {
  var auth = urlParts.auth,
      query = urlParts.query;
  var hostname = urlParts.hostname,
      protocol = urlParts.protocol,
      port = urlParts.port;

  if (!port || port === '0') {
    port = loc.port;
  } // check ipv4 and ipv6 `all hostname`
  // why do we need this check?
  // hostname n/a for file protocol (example, when using electron, ionic)
  // see: https://github.com/webpack/webpack-dev-server/pull/384


  if ((hostname === '0.0.0.0' || hostname === '::') && loc.hostname && loc.protocol.indexOf('http') === 0) {
    hostname = loc.hostname;
  } // `hostname` can be empty when the script path is relative. In that case, specifying
  // a protocol would result in an invalid URL.
  // When https is used in the app, secure websockets are always necessary
  // because the browser doesn't accept non-secure websockets.


  if (hostname && hostname !== '127.0.0.1' && (loc.protocol === 'https:' || urlParts.hostname === '0.0.0.0')) {
    protocol = loc.protocol;
  } // all of these sock url params are optionally passed in through
  // resourceQuery, so we need to fall back to the default if
  // they are not provided


  var sockHost = query.sockHost || hostname;
  var sockPath = query.sockPath || '/sockjs-node';
  var sockPort = query.sockPort || port;

  if (sockPort === 'location') {
    sockPort = loc.port;
  }

  return url.format({
    protocol: protocol,
    auth: auth,
    hostname: sockHost,
    port: sockPort,
    // If sockPath is provided it'll be passed in via the resourceQuery as a
    // query param so it has to be parsed out of the querystring in order for the
    // client to open the socket to the correct location.
    pathname: sockPath
  });
}

module.exports = createSocketUrl;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(23);
var util = __webpack_require__(25);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(26);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.2',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)(module)))

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(27);
exports.encode = exports.stringify = __webpack_require__(28);


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return Object.keys(obj).map(function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (Array.isArray(obj[k])) {
        return obj[k].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function getCurrentScriptSource() {
  // `document.currentScript` is the most accurate way to find the current script,
  // but is not supported in all browsers.
  if (document.currentScript) {
    return document.currentScript.getAttribute('src');
  } // Fall back to getting all scripts in the document.


  var scriptElements = document.scripts || [];
  var currentScript = scriptElements[scriptElements.length - 1];

  if (currentScript) {
    return currentScript.getAttribute('src');
  } // Fail as there was no script to use.


  throw new Error('[WDS] Failed to get current script source.');
}

module.exports = getCurrentScriptSource;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./log": 31
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 30;

/***/ }),
/* 31 */
/***/ (function(module, exports) {

var logLevel = "info";

function dummy() {}

function shouldLog(level) {
	var shouldLog =
		(logLevel === "info" && level === "info") ||
		(["info", "warning"].indexOf(logLevel) >= 0 && level === "warning") ||
		(["info", "warning", "error"].indexOf(logLevel) >= 0 && level === "error");
	return shouldLog;
}

function logGroup(logFn) {
	return function(level, msg) {
		if (shouldLog(level)) {
			logFn(msg);
		}
	};
}

module.exports = function(level, msg) {
	if (shouldLog(level)) {
		if (level === "info") {
			console.log(msg);
		} else if (level === "warning") {
			console.warn(msg);
		} else if (level === "error") {
			console.error(msg);
		}
	}
};

/* eslint-disable node/no-unsupported-features/node-builtins */
var group = console.group || dummy;
var groupCollapsed = console.groupCollapsed || dummy;
var groupEnd = console.groupEnd || dummy;
/* eslint-enable node/no-unsupported-features/node-builtins */

module.exports.group = logGroup(group);

module.exports.groupCollapsed = logGroup(groupCollapsed);

module.exports.groupEnd = logGroup(groupEnd);

module.exports.setLogLevel = function(level) {
	logLevel = level;
};

module.exports.formatError = function(err) {
	var message = err.message;
	var stack = err.stack;
	if (!stack) {
		return message;
	} else if (stack.indexOf(message) < 0) {
		return message + "\n" + stack;
	} else {
		return stack;
	}
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var api = __webpack_require__(33);
            var content = __webpack_require__(34);

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.i, content, '']];
            }

var options = {};

options.insert = "head";
options.singleton = false;

var update = api(content, options);

var exported = content.locals ? content.locals : {};



module.exports = exported;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : undefined;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && btoa) {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(35);
exports = ___CSS_LOADER_API_IMPORT___(false);
// Module
exports.push([module.i, "/*-- Chart --*/\n.bb svg {\n  font: 10px sans-serif;\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0); }\n\n.bb path, .bb line {\n  fill: none;\n  stroke: #000; }\n\n.bb text, .bb .bb-button {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  user-select: none; }\n\n.bb-legend-item-tile,\n.bb-xgrid-focus,\n.bb-ygrid-focus,\n.bb-ygrid,\n.bb-event-rect,\n.bb-bars path {\n  shape-rendering: crispEdges; }\n\n.bb-chart-arc .bb-gauge-value {\n  fill: #000; }\n\n.bb-chart-arc path {\n  stroke: #fff; }\n\n.bb-chart-arc rect {\n  stroke: #fff;\n  stroke-width: 1; }\n\n.bb-chart-arc text {\n  fill: #fff;\n  font-size: 13px; }\n\n/*-- Axis --*/\n.bb-axis {\n  shape-rendering: crispEdges; }\n\n/*-- Grid --*/\n.bb-grid line {\n  stroke: #aaa; }\n\n.bb-grid text {\n  fill: #aaa; }\n\n.bb-xgrid, .bb-ygrid {\n  stroke-dasharray: 3 3; }\n\n/*-- Text on Chart --*/\n.bb-text.bb-empty {\n  fill: #808080;\n  font-size: 2em; }\n\n/*-- Line --*/\n.bb-line {\n  stroke-width: 1px; }\n\n/*-- Point --*/\n.bb-circle._expanded_ {\n  stroke-width: 1px;\n  stroke: white; }\n\n.bb-selected-circle {\n  fill: white;\n  stroke-width: 2px; }\n\n/*-- Bar --*/\n.bb-bar {\n  stroke-width: 0; }\n  .bb-bar._expanded_ {\n    fill-opacity: 0.75; }\n\n/*-- Focus --*/\n.bb-target.bb-focused {\n  opacity: 1; }\n\n.bb-target.bb-focused path.bb-line, .bb-target.bb-focused path.bb-step {\n  stroke-width: 2px; }\n\n.bb-target.bb-defocused {\n  opacity: 0.3 !important; }\n  .bb-target.bb-defocused .text-overlapping {\n    opacity: .05 !important; }\n\n/*-- Region --*/\n.bb-region {\n  fill: steelblue;\n  fill-opacity: .1; }\n\n/*-- Zoom region --*/\n.bb-zoom-brush {\n  fill-opacity: .1; }\n\n/*-- Brush --*/\n.bb-brush .extent {\n  fill-opacity: .1; }\n\n/*-- Select - Drag --*/\n/*-- Legend --*/\n.bb-legend-item {\n  font-size: 12px;\n  user-select: none; }\n\n.bb-legend-item-hidden {\n  opacity: 0.15; }\n\n.bb-legend-background {\n  opacity: 0.75;\n  fill: white;\n  stroke: lightgray;\n  stroke-width: 1; }\n\n/*-- Title --*/\n.bb-title {\n  font: 14px sans-serif; }\n\n/*-- Tooltip --*/\n.bb-tooltip-container {\n  z-index: 10;\n  user-select: none; }\n\n.bb-tooltip {\n  border-collapse: collapse;\n  border-spacing: 0;\n  background-color: #fff;\n  empty-cells: show;\n  opacity: 0.9;\n  -webkit-box-shadow: 7px 7px 12px -9px #777777;\n  -moz-box-shadow: 7px 7px 12px -9px #777777;\n  box-shadow: 7px 7px 12px -9px #777777; }\n  .bb-tooltip tr {\n    border: 1px solid #CCC; }\n  .bb-tooltip th {\n    background-color: #aaa;\n    font-size: 14px;\n    padding: 2px 5px;\n    text-align: left;\n    color: #FFF; }\n  .bb-tooltip td {\n    font-size: 13px;\n    padding: 3px 6px;\n    background-color: #fff;\n    border-left: 1px dotted #999; }\n    .bb-tooltip td > span, .bb-tooltip td > svg {\n      display: inline-block;\n      width: 10px;\n      height: 10px;\n      margin-right: 6px; }\n  .bb-tooltip.value {\n    text-align: right; }\n\n/*-- Area --*/\n.bb-area {\n  stroke-width: 0;\n  opacity: 0.2; }\n\n/*-- Arc --*/\n.bb-chart-arcs-title {\n  dominant-baseline: middle;\n  font-size: 1.3em; }\n\n.bb-chart-arcs-gauge-title {\n  dominant-baseline: middle;\n  font-size: 2.7em; }\n\n.bb-chart-arcs .bb-chart-arcs-background {\n  fill: #e0e0e0;\n  stroke: #fff; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-unit {\n  fill: #000;\n  font-size: 16px; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-max {\n  fill: #777; }\n\n.bb-chart-arcs .bb-chart-arcs-gauge-min {\n  fill: #777; }\n\n/*-- Radar --*/\n.bb-chart-radars .bb-levels polygon {\n  fill: none;\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-levels text {\n  fill: #848282; }\n\n.bb-chart-radars .bb-axis line {\n  stroke: #848282;\n  stroke-width: .5px; }\n\n.bb-chart-radars .bb-axis text {\n  font-size: 1.15em;\n  cursor: default; }\n\n.bb-chart-radars .bb-shapes polygon {\n  fill-opacity: .2;\n  stroke-width: 1px; }\n\n/*-- Button --*/\n.bb-button {\n  position: absolute;\n  top: 10px;\n  right: 10px; }\n  .bb-button .bb-zoom-reset {\n    font-size: 11px;\n    border: solid 1px #ccc;\n    background-color: #fff;\n    padding: 5px;\n    border-radius: 5px;\n    cursor: pointer; }\n", ""]);
// Exports
module.exports = exports;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join('');
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === 'string') {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring

  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || '').concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
  return "/*# ".concat(data, " */");
}

/***/ }),
/* 36 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__36__;

/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__37__;

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__38__;

/***/ }),
/* 39 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__39__;

/***/ }),
/* 40 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__40__;

/***/ }),
/* 41 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__41__;

/***/ }),
/* 42 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__42__;

/***/ }),
/* 43 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__44__;

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__45__;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__46__;

/***/ }),
/* 47 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__47__;

/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__48__;

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// EXTERNAL MODULE: external {"commonjs":"d3-time-format","commonjs2":"d3-time-format","amd":"d3-time-format","root":"d3"}
var external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_ = __webpack_require__(36);

// EXTERNAL MODULE: external {"commonjs":"d3-selection","commonjs2":"d3-selection","amd":"d3-selection","root":"d3"}
var external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_ = __webpack_require__(37);

// EXTERNAL MODULE: external {"commonjs":"d3-transition","commonjs2":"d3-transition","amd":"d3-transition","root":"d3"}
var external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_ = __webpack_require__(38);

// CONCATENATED MODULE: ./src/config/classes.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * CSS class names definition
 * @private
 */
/* harmony default export */ var config_classes = ({
  arc: "bb-arc",
  arcLabelLine: "bb-arc-label-line",
  arcs: "bb-arcs",
  area: "bb-area",
  areas: "bb-areas",
  axis: "bb-axis",
  axisX: "bb-axis-x",
  axisXLabel: "bb-axis-x-label",
  axisY: "bb-axis-y",
  axisY2: "bb-axis-y2",
  axisY2Label: "bb-axis-y2-label",
  axisYLabel: "bb-axis-y-label",
  bar: "bb-bar",
  bars: "bb-bars",
  brush: "bb-brush",
  button: "bb-button",
  buttonZoomReset: "bb-zoom-reset",
  chart: "bb-chart",
  chartArc: "bb-chart-arc",
  chartArcs: "bb-chart-arcs",
  chartArcsBackground: "bb-chart-arcs-background",
  chartArcsGaugeMax: "bb-chart-arcs-gauge-max",
  chartArcsGaugeMin: "bb-chart-arcs-gauge-min",
  chartArcsGaugeUnit: "bb-chart-arcs-gauge-unit",
  chartArcsTitle: "bb-chart-arcs-title",
  chartArcsGaugeTitle: "bb-chart-arcs-gauge-title",
  chartBar: "bb-chart-bar",
  chartBars: "bb-chart-bars",
  chartLine: "bb-chart-line",
  chartLines: "bb-chart-lines",
  chartRadar: "bb-chart-radar",
  chartRadars: "bb-chart-radars",
  chartText: "bb-chart-text",
  chartTexts: "bb-chart-texts",
  circle: "bb-circle",
  circles: "bb-circles",
  colorPattern: "bb-color-pattern",
  colorScale: "bb-colorscale",
  defocused: "bb-defocused",
  dragarea: "bb-dragarea",
  empty: "bb-empty",
  eventRect: "bb-event-rect",
  eventRects: "bb-event-rects",
  eventRectsMultiple: "bb-event-rects-multiple",
  eventRectsSingle: "bb-event-rects-single",
  focused: "bb-focused",
  gaugeValue: "bb-gauge-value",
  grid: "bb-grid",
  gridLines: "bb-grid-lines",
  legendBackground: "bb-legend-background",
  legendItem: "bb-legend-item",
  legendItemEvent: "bb-legend-item-event",
  legendItemFocused: "bb-legend-item-focused",
  legendItemHidden: "bb-legend-item-hidden",
  legendItemPoint: "bb-legend-item-point",
  legendItemTile: "bb-legend-item-tile",
  level: "bb-level",
  levels: "bb-levels",
  line: "bb-line",
  lines: "bb-lines",
  region: "bb-region",
  regions: "bb-regions",
  selectedCircle: "bb-selected-circle",
  selectedCircles: "bb-selected-circles",
  shape: "bb-shape",
  shapes: "bb-shapes",
  stanfordElements: "bb-stanford-elements",
  stanfordLine: "bb-stanford-line",
  stanfordLines: "bb-stanford-lines",
  stanfordRegion: "bb-stanford-region",
  stanfordRegions: "bb-stanford-regions",
  target: "bb-target",
  text: "bb-text",
  texts: "bb-texts",
  title: "bb-title",
  tooltip: "bb-tooltip",
  tooltipContainer: "bb-tooltip-container",
  tooltipName: "bb-tooltip-name",
  xgrid: "bb-xgrid",
  xgridFocus: "bb-xgrid-focus",
  xgridLine: "bb-xgrid-line",
  xgridLines: "bb-xgrid-lines",
  xgrids: "bb-xgrids",
  ygrid: "bb-ygrid",
  ygridFocus: "bb-ygrid-focus",
  ygridLine: "bb-ygrid-line",
  ygridLines: "bb-ygrid-lines",
  ygrids: "bb-ygrids",
  zoomBrush: "bb-zoom-brush",
  zoomRect: "bb-zoom-rect",
  EXPANDED: "_expanded_",
  SELECTED: "_selected_",
  INCLUDED: "_included_",
  TextOverlapping: "text-overlapping"
});
// CONCATENATED MODULE: ./src/config/Store.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
var Store_state = function () {
  return {
    width: 0,
    width2: 0,
    height: 0,
    height2: 0,
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin2: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    margin3: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    },
    arcWidth: 0,
    arcHeight: 0,
    currentWidth: 0,
    currentHeight: 0,
    // legend
    isLegendRight: !1,
    isLegendInset: !1,
    isLegendTop: !1,
    isLegendLeft: !1,
    legendStep: 0,
    legendItemWidth: 0,
    legendItemHeight: 0,
    legendHasRendered: !1,
    currentMaxTickWidths: {
      x: {
        size: 0,
        domain: ""
      },
      y: {
        size: 0,
        domain: ""
      },
      y2: {
        size: 0,
        domain: ""
      }
    },
    rotatedPadding: {
      left: 30,
      right: 0,
      top: 5
    },
    withoutFadeIn: {},
    inputType: "",
    datetimeId: "",
    // clip id string
    clip: {
      id: "",
      idXAxis: "",
      idYAxis: "",
      idGrid: "",
      idSubchart: "",
      // clipIdForSubchart
      path: "",
      pathXAxis: "",
      pathYAxis: "",
      pathGrid: ""
    },
    // status
    dragStart: null,
    dragging: !1,
    flowing: !1,
    cancelClick: !1,
    mouseover: !1,
    rendered: !1,
    transiting: !1,
    hasNegativeValue: !1,
    hasPositiveValue: !0,
    orgAreaOpacity: "0.2",
    // ID strings
    hiddenTargetIds: [],
    hiddenLegendIds: [],
    focusedTargetIds: [],
    defocusedTargetIds: [],
    // value for Arc
    radius: 0,
    innerRadius: 0,
    innerRadiusRatio: 0,
    gaugeArcWidth: 0,
    radiusExpanded: 0,
    // xgrid attribute
    xgridAttr: {
      x1: null,
      x2: null,
      y1: null,
      y2: null
    }
  };
};


// CONCATENATED MODULE: ./src/config/Options/data/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * data.selection config options
 */
/* harmony default export */ var data_selection = ({
  /**
   * Set data selection enabled<br><br>
   * If this option is set true, we can select the data points and get/set its state of selection by API (e.g. select, unselect, selected).
   * @name data․selection․enabled
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataSelection)
   * @example
   * data: {
   *    selection: {
   *       enabled: true
   *    }
   * }
   */
  data_selection_enabled: !1,

  /**
   * Set grouped selection enabled.<br><br>
   * If this option set true, multiple data points that have same x value will be selected by one selection.
   * @name data․selection․grouped
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       grouped: true
   *    }
   * }
   */
  data_selection_grouped: !1,

  /**
   * Set a callback for each data point to determine if it's selectable or not.<br><br>
   * The callback will receive d as an argument and it has some parameters like id, value, index. This callback should return boolean.
   * @name data․selection․isselectable
   * @memberof Options
   * @type {Function}
   * @default function() { return true; }
   * @example
   * data: {
   *    selection: {
   *       isselectable: function(d) { ... }
   *    }
   * }
   */
  data_selection_isselectable: function data_selection_isselectable() {
    return !0;
  },

  /**
   * Set multiple data points selection enabled.<br><br>
   * If this option set true, multile data points can have the selected state at the same time. If false set, only one data point can have the selected state and the others will be unselected when the new data point is selected.
   * @name data․selection․multiple
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *    selection: {
   *       multiple: false
   *    }
   * }
   */
  data_selection_multiple: !0,

  /**
   * Enable to select data points by dragging.
   * If this option set true, data points can be selected by dragging.
   * - **NOTE:** If this option set true, scrolling on the chart will be disabled because dragging event will handle the event.
   * @name data․selection․draggable
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * data: {
   *    selection: {
   *       draggable: true
   *   }
   * }
   */
  data_selection_draggable: !1
});
// EXTERNAL MODULE: external {"commonjs":"d3-brush","commonjs2":"d3-brush","amd":"d3-brush","root":"d3"}
var external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_ = __webpack_require__(39);

// CONCATENATED MODULE: ./src/module/browser.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Window object
 * @module
 * @ignore
 */

/* eslint-disable no-new-func, no-undef */


var win = function () {
  var def = function (o) {
    return typeof o !== "undefined" && o;
  };

  return def(self) || def(window) || def(global) || def(globalThis) || Function("return this")();
}(),
    browser_doc = win && win.document;
/* eslint-enable no-new-func, no-undef */
// CONCATENATED MODULE: ./src/module/util.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */






var isValue = function (v) {
  return v || v === 0;
},
    isFunction = function (v) {
  return typeof v === "function";
},
    isString = function (v) {
  return typeof v === "string";
},
    isNumber = function (v) {
  return typeof v === "number";
},
    isUndefined = function (v) {
  return typeof v === "undefined";
},
    isDefined = function (v) {
  return typeof v !== "undefined";
},
    isBoolean = function (v) {
  return typeof v === "boolean";
},
    ceil10 = function (v) {
  return Math.ceil(v / 10) * 10;
},
    asHalfPixel = function (n) {
  return Math.ceil(n) + .5;
},
    diffDomain = function (d) {
  return d[1] - d[0];
},
    isObjectType = function (v) {
  return typeof v === "object";
},
    isEmpty = function (o) {
  return isUndefined(o) || o === null || isString(o) && o.length === 0 || isObjectType(o) && !(o instanceof Date) && Object.keys(o).length === 0 || isNumber(o) && isNaN(o);
},
    notEmpty = function (o) {
  return !isEmpty(o);
},
    isArray = function (arr) {
  return Array.isArray(arr);
},
    isObject = function (obj) {
  return obj && !obj.nodeType && isObjectType(obj) && !isArray(obj);
};

function getOption(options, key, defaultValue) {
  return isDefined(options[key]) ? options[key] : defaultValue;
}

function util_hasValue(dict, value) {
  var found = !1;
  return Object.keys(dict).forEach(function (key) {
    return dict[key] === value && (found = !0);
  }), found;
}
/**
 * Call function with arguments
 * @param {Function} fn Function to be called
 * @param {*} args Arguments
 * @return {Boolean} true: fn is function, false: fn is not function
 * @private
 */


function callFn(fn) {
  for (var isFn = isFunction(fn), _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];

  return isFn && fn.call.apply(fn, args), isFn;
}
/**
 * Replace tag sign to html entity
 * @param {String} str
 * @return {String}
 * @private
 */


function sanitise(str) {
  return isString(str) ? str.replace(/</g, "&lt;").replace(/>/g, "&gt;") : str;
}
/**
 * Set text value. If there's multiline add nodes.
 * @param {d3Selection} node Text node
 * @param {String} text Text value string
 * @param {Array} dy dy value for multilined text
 * @param {Boolean} toMiddle To be alingned vertically middle
 * @private
 */


function setTextValue(node, text, dy, toMiddle) {
  if (dy === void 0 && (dy = [-1, 1]), toMiddle === void 0 && (toMiddle = !1), node && isString(text)) if (text.indexOf("\n") === -1) node.text(text);else {
    var diff = [node.text(), text].map(function (v) {
      return v.replace(/[\s\n]/g, "");
    });

    if (diff[0] !== diff[1]) {
      var multiline = text.split("\n"),
          len = toMiddle ? multiline.length - 1 : 1;
      node.html(""), multiline.forEach(function (v, i) {
        node.append("tspan").attr("x", 0).attr("dy", (i === 0 ? dy[0] * len : dy[1]) + "em").text(v);
      });
    }
  }
} // substitution of SVGPathSeg API polyfill


function getRectSegList(path) {
  /*
   * seg1 ---------- seg2
   *   |               |
   *   |               |
   *   |               |
   * seg0 ---------- seg3
   * */
  var _path$getBBox = path.getBBox(),
      x = _path$getBBox.x,
      y = _path$getBBox.y,
      width = _path$getBBox.width,
      height = _path$getBBox.height;

  return [{
    x: x,
    y: y + height
  }, // seg0
  {
    x: x,
    y: y
  }, // seg1
  {
    x: x + width,
    y: y
  }, // seg2
  {
    x: x + width,
    y: y + height
  } // seg3
  ];
}

function getPathBox(path) {
  var _path$getBoundingClie = path.getBoundingClientRect(),
      width = _path$getBoundingClie.width,
      height = _path$getBoundingClie.height,
      items = getRectSegList(path),
      x = items[0].x,
      y = Math.min(items[0].y, items[1].y);

  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
} // return brush selection array


function getBrushSelection(ctx) {
  var selection,
      event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
      main = ctx.context || ctx.main;
  return event && event.constructor.name === "BrushEvent" ? selection = event.selection : main && (selection = main.select("." + config_classes.brush).node()) && (selection = Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection)), selection;
} // Get boundingClientRect. cache the evaluated value once it was called.


var getBoundingRect = function (node) {
  return node.rect || (node.rect = node.getBoundingClientRect());
}; // retrun random number


function getRandom(asStr) {
  asStr === void 0 && (asStr = !0);
  var rand = Math.random();
  return asStr ? rand + "" : rand;
}

function brushEmpty(ctx) {
  var selection = getBrushSelection(ctx);
  return !selection || selection[0] === selection[1];
}

function extend(target, source) {
  // exclude name with only numbers
  for (var p in target === void 0 && (target = {}), isArray(source) && source.forEach(function (v) {
    return extend(target, v);
  }), source) /^\d+$/.test(p) || (target[p] = source[p]);

  return target;
}
/**
 * Return first letter capitalized
 * @param {String} str
 * @return {String} capitalized string
 * @private
 */


var capitalize = function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
},
    toArray = function (v) {
  return [].slice.call(v);
};
/**
 * Convert to array
 * @param {Object} v
 * @returns {Array}
 * @private
 */


/**
 * Get css rules for specified stylesheets
 * @param {Array} styleSheets The stylesheets to get the rules from
 * @returns {Array}
 * @private
 */
function getCssRules(styleSheets) {
  var rules = [];
  return styleSheets.forEach(function (sheet) {
    try {
      sheet.cssRules && sheet.cssRules.length && (rules = rules.concat(toArray(sheet.cssRules)));
    } catch (e) {
      console.error("Error while reading rules from " + sheet.href + ": " + e.toString());
    }
  }), rules;
}
/**
 * Gets the SVGMatrix of an SVGElement
 * @param {SVGElement} element
 * @return {SVGMatrix} matrix
 * @private
 */


function getTranslation(node) {
  var transform = node ? node.transform : null,
      baseVal = transform ? transform.baseVal : [];
  return baseVal.length ? baseVal.getItem(0).matrix : {
    a: 0,
    b: 0,
    c: 0,
    d: 0,
    e: 0,
    f: 0
  };
}
/**
 * Get unique value from array
 * @param {Array} data
 * @return {Array} Unique array value
 * @private
 */


function getUnique(data) {
  var isDate = data[0] instanceof Date,
      d = (isDate ? data.map(Number) : data).filter(function (v, i, self) {
    return self.indexOf(v) === i;
  });
  return isDate ? d.map(function (v) {
    return new Date(v);
  }) : d;
}
/**
 * Merge array
 * @param {Array} arr
 * @return {Array}
 * @private
 */


function mergeArray(arr) {
  return arr && arr.length ? arr.reduce(function (p, c) {
    return p.concat(c);
  }) : [];
}
/**
 * Merge object returning new object
 * @param {Object} target
 * @param {Object} objectN
 * @returns {Object} merged target object
 * @private
 */


function mergeObj(target) {
  for (var _len2 = arguments.length, objectN = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) objectN[_key2 - 1] = arguments[_key2];

  if (!objectN.length || objectN.length === 1 && !objectN[0]) return target;
  var source = objectN.shift();
  return isObject(target) && isObject(source) && Object.keys(source).forEach(function (key) {
    var value = source[key];
    isObject(value) ? (!target[key] && (target[key] = {}), target[key] = mergeObj(target[key], value)) : target[key] = isArray(value) ? value.concat() : value;
  }), mergeObj.apply(void 0, [target].concat(objectN));
}
/**
 * Sort value
 * @param {Array} data value to be sorted
 * @param {Boolean} isAsc true: asc, false: desc
 * @return {Number|String|Date} sorted date
 * @private
 */


function util_sortValue(data, isAsc) {
  isAsc === void 0 && (isAsc = !0);
  var fn;
  return data[0] instanceof Date ? fn = isAsc ? function (a, b) {
    return a - b;
  } : function (a, b) {
    return b - a;
  } : isAsc && !data.every(isNaN) ? fn = function (a, b) {
    return a - b;
  } : !isAsc && (fn = function (a, b) {
    return a > b && -1 || a < b && 1 || a === b && 0;
  }), data.concat().sort(fn);
}
/**
 * Get min/max value
 * @param {String} type 'min' or 'max'
 * @param {Array} data Array data value
 * @retun {Number|Date|undefined}
 * @private
 */


function getMinMax(type, data) {
  var res = data.filter(function (v) {
    return notEmpty(v);
  });
  return res.length ? isNumber(res[0]) ? res = Math[type].apply(Math, res) : res[0] instanceof Date && (res = util_sortValue(res, type === "min")[0]) : res = undefined, res;
}
/**
 * Get range
 * @param {Number} start Start number
 * @param {Number} end End number
 * @return {Array}
 * @private
 */


function getRange(start, end) {
  var res = [];

  for (var i = start; i < end; i++) res.push(i);

  return res;
} // emulate event


var emulateEvent = {
  mouse: function () {
    var getParams = function () {
      return {
        bubbles: !1,
        cancelable: !1,
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0
      };
    };

    try {
      return new MouseEvent("t"), function (el, eventType, params) {
        params === void 0 && (params = getParams()), el.dispatchEvent(new MouseEvent(eventType, params));
      };
    } catch (e) {
      // Polyfills DOM4 MouseEvent
      return function (el, eventType, params) {
        params === void 0 && (params = getParams());
        var mouseEvent = browser_doc.createEvent("MouseEvent"); // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/initMouseEvent

        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, win, 0, // the event's mouse click count
        params.screenX, params.screenY, params.clientX, params.clientY, !1, !1, !1, !1, 0, null), el.dispatchEvent(mouseEvent);
      };
    }
  }(),
  touch: function touch(el, eventType, params) {
    var touchObj = new Touch(mergeObj({
      identifier: Date.now(),
      target: el,
      radiusX: 2.5,
      radiusY: 2.5,
      rotationAngle: 10,
      force: .5
    }, params));
    el.dispatchEvent(new TouchEvent(eventType, {
      cancelable: !0,
      bubbles: !0,
      shiftKey: !0,
      touches: [touchObj],
      targetTouches: [],
      changedTouches: [touchObj]
    }));
  }
};
/**
 * Process the template  & return bound string
 * @param {String} tpl Template string
 * @param {Object} data Data value to be replaced
 * @return {String}
 * @private
 */

function tplProcess(tpl, data) {
  var res = tpl;

  for (var x in data) res = res.replace(new RegExp("{=" + x + "}", "g"), data[x]);

  return res;
}
// CONCATENATED MODULE: ./src/config/Options/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * data config options
 */

/* harmony default export */ var data_data = (mergeObj({
  /**
   * Specify the key of x values in the data.<br><br>
   * We can show the data with non-index x values by this option. This option is required when the type of x axis is timeseries. If this option is set on category axis, the values of the data on the key will be used for category names.
   * @name data․x
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * data: {
   *   x: "date"
   * }
   */
  data_x: undefined,

  /**
   * Specify the keys of the x values for each data.<br><br>
   * This option can be used if we want to show the data that has different x values.
   * @name data․xs
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   xs: {
   *      data1: "x1",
   *      data2: "x2"
   *   }
   * }
   */
  data_xs: {},

  /**
   * Set a format specifier to parse string specifed as x.
   * @name data․xFormat
   * @memberof Options
   * @type {String}
   * @default %Y-%m-%d
   * @example
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "01012019", "02012019", "03012019"],
   *        ["data1", 30, 200, 100]
   *    ],
   *    // Format specifier to parse as datetime for given 'x' string value
   *    xFormat: "%m%d%Y"
   * },
   * axis: {
   *    x: {
   *        type: "timeseries"
   *    }
   * }
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   */
  data_xFormat: "%Y-%m-%d",

  /**
   * Set localtime format to parse x axis.
   * @name data․xLocaltime
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *   xLocaltime: false
   * }
   */
  data_xLocaltime: !0,

  /**
   * Sort on x axis.
   * @name data․xSort
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * data: {
   *   xSort: false
   * }
   */
  data_xSort: !0,

  /**
   * Converts data id value
   * @name data․idConverter
   * @memberof Options
   * @type {Function}
   * @default function(id) { return id; }
   * @example
   * data: {
   *    idConverter: function(id) {
   *       // when id is 'data1', converts to be 'data2'
   *       // 'data2' should be given as the initial data value
   *       if (id === "data1") {
   *          return "data2";
   *       } else {
   *          return id;
   *       }
   *    }
   * }
   */
  data_idConverter: function data_idConverter(id) {
    return id;
  },

  /**
   * Set custom data name.
   * @name data․names
   * @memberof Options
   * @type {Object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataName)
   * @example
   * data: {
   *   names: {
   *     data1: "Data Name 1",
   *     data2: "Data Name 2"
   *   }
   * }
   */
  data_names: {},

  /**
   * Set custom data class.<br><br>
   * If this option is specified, the element g for the data has an additional class that has the prefix 'bb-target-' (eg. bb-target-additional-data1-class).
   * @name data․classes
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   classes: {
   *     data1: "additional-data1-class",
   *     data2: "additional-data2-class"
   *   }
   * }
   */
  data_classes: {},

  /**
   * Set groups for the data for stacking.
   * @name data․groups
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * data: {
   *   groups: [
   *     ["data1", "data2"],
   *     ["data3"]
   *   ]
   * }
   */
  data_groups: [],

  /**
   * Set y axis the data related to. y and y2 can be used.
  * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @name data․axes
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   axes: {
   *     data1: "y",
   *     data2: "y2"
   *   }
   * }
   */
  data_axes: {},

  /**
   * Set chart type at once.<br><br>
   * If this option is specified, the type will be applied to every data. This setting can be overwritten by data.types.<br><br>
   * **Available Values:**
   * - area
   * - area-line-range
   * - area-spline
   * - area-spline-range
   * - area-step
   * - bar
   * - bubble
   * - donut
   * - gauge
   * - line
   * - pie
   * - radar
   * - scatter
   * - spline
   * - step
   * @name data․type
   * @memberof Options
   * @type {String}
   * @default line
   * @example
   * data: {
   *    type: "bar"
   * }
   */
  data_type: undefined,

  /**
   * Set chart type for each data.<br>
   * This setting overwrites data.type setting.
   * - **NOTE:** `radar` type can't be combined with other types.
   * @name data․types
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   types: {
   *     data1: "bar",
   *     data2: "spline"
   *   }
   * }
   */
  data_types: {},

  /**
   * Set labels options
   * @name data․labels
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [data.labels=false] Show or hide labels on each data points
   * @property {Boolean} [data.labels.centered=false] Centerize labels on `bar` shape. (**NOTE:** works only for 'bar' type)
   * @property {Function} [data.labels.format] Set formatter function for data labels.<br>
   * The formatter function receives 4 arguments such as v, id, i, j and it must return a string that will be shown as the label. The arguments are:<br>
   *  - `v` is the value of the data point where the label is shown.
   *  - `id` is the id of the data where the label is shown.
   *  - `i` is the index of the data point where the label is shown.
   *  - `j` is the sub index of the data point where the label is shown.<br><br>
   * Formatter function can be defined for each data by specifying as an object and D3 formatter function can be set (ex. d3.format('$'))
   * @property {String|Object} [data.labels.colors] Set label text colors.
   * @property {Object} [data.labels.position] Set each dataset position, relative the original.
   * @property {Number} [data.labels.position.x=0] x coordinate position, relative the original.
   * @property {Number} [data.labels.position.y=0] y coordinate position, relative the original.
   * @memberof Options
   * @type {Object}
   * @default {}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataLabel)
   * @see [Demo: label colors](https://naver.github.io/billboard.js/demo/#Data.DataLabelColors)
   * @see [Demo: label format](https://naver.github.io/billboard.js/demo/#Data.DataLabelFormat)
   * @see [Demo: label overlap](https://naver.github.io/billboard.js/demo/#Data.DataLabelOverlap)
   * @see [Demo: label position](https://naver.github.io/billboard.js/demo/#Data.DataLabelPosition)
   * @example
   * data: {
   *   labels: true,
   *
   *   // or set specific options
   *   labels: {
   *     format: function(v, id, i, j) { ... },
   *
   *     // it's possible to set for each data
   *     format: {
   *         data1: function(v, id, i, j) { ... },
   *         ...
   *     },
   *
   *     // align text to center of the 'bar' shape (works only for 'bar' type)
   *     centered: true,
   *
   *     // apply for all label texts
   *     colors: "red",
   *
   *     // or set different colors per dataset
   *     // for not specified dataset, will have the default color value
   *     colors: {
   *        data1: "yellow",
   *        data3: "green"
   *     },
   *
   *     // set x, y coordinate position
   *     position: {
   *        x: -10,
   *        y: 10
   *     },
   *
   *     // or set x, y coordinate position by each dataset
   *     position: {
   *        data1: {x: 5, y: 5},
   *        data2: {x: 10, y: -20}
   *     }
   *   }
   * }
   */
  data_labels: {},
  data_labels_colors: undefined,
  data_labels_position: {},

  /**
   *  This option changes the order of stacking data and pieces of pie/donut.
   *  - If `null` specified, it will be the order the data loaded.
   *  - If function specified, it will be used as [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)<br><br>
   *
   *  **Available Values:**
   *  - `desc`: In descending order
   *  - `asc`: In ascending order
   *  - `null`: It keeps the data load order
   *  - `function(data1, data2) { ... }`: Array.sort compareFunction
   * @name data․order
   * @memberof Options
   * @type {String|Function|null}
   * @default desc
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataOrder)
   * @example
   * data: {
   *   // in descending order (default)
   *   order: "desc"
   *
   *   // in ascending order
   *   order: "asc"
   *
   *   // keeps data input order
   *   order: null
   *
   *   // specifying sort function
   *   order: function(a, b) {
   *       // param data passed format
   *       {
   *          id: "data1", id_org: "data1", values: [
   *              {x: 5, value: 250, id: "data1", index: 5, name: "data1"},
   *              ...
   *          ]
   *       }
   *   }
   * }
   */
  data_order: "desc",

  /**
   * Define regions for each data.<br>
   * The values must be an array for each data and it should include an object that has `start`, `end` and `style`.
   * - The object type should be as:
   *   - start {Number}: Start data point number. If not set, the start will be the first data point.
   *   - [end] {Number}: End data point number. If not set, the end will be the last data point.
   *   - [style.dasharray="2 2"] {Object}: The first number specifies a distance for the filled area, and the second a distance for the unfilled area.
   * - **NOTE:** Currently this option supports only line chart and dashed style. If this option specified, the line will be dashed only in the regions.
   * @name data․regions
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   regions: {
   *     data1: [{
   *         start: 1,
   *         end: 2,
   *         style: {
   *             dasharray: "5 2"
   *         }
   *     }, {
   *         start: 3
   *     }],
   *     ...
   *   }
   * }
   */
  data_regions: {},

  /**
   * Set color converter function.<br><br>
   * This option should a function and the specified function receives color (e.g. '#ff0000') and d that has data parameters like id, value, index, etc. And it must return a string that represents color (e.g. '#00ff00').
   * @name data․color
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataColor)
   * @example
   * data: {
   *   color: function(color, d) { ... }
   * }
   */
  data_color: undefined,

  /**
   * Set color for each data.
   * @name data․colors
   * @memberof Options
   * @type {Object}
   * @default {}
   * @example
   * data: {
   *   colors: {
   *     data1: "#ff0000",
   *     data2: function(d) {
   *        return "#000";
   *     }
   *     ...
   *   }
   * }
   */
  data_colors: {},

  /**
   * Hide each data when the chart appears.<br><br>
   * If true specified, all of data will be hidden. If multiple ids specified as an array, those will be hidden.
   * @name data․hide
   * @memberof Options
   * @type {Boolean|Array}
   * @default false
   * @example
   * data: {
   *   // all of data will be hidden
   *   hide: true
   *
   *   // specified data will be hidden
   *   hide: ["data1", ...]
   * }
   */
  data_hide: !1,

  /**
   * Filter values to be shown
   * The data value is the same as the returned by `.data()`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
   * @name data․filter
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * data: {
   *   // filter for id value
   *   filter: function(v) {
   *      // v: [{id: "data1", id_org: "data1", values: [
   *      //      {x: 0, value: 130, id: "data2", index: 0}, ...]
   *      //    }, ...]
   *      return v.id !== "data1";
   *   }
   */
  data_filter: undefined,

  /**
   * Set the stacking to be normalized
   * - **NOTE:**
   *   - For stacking, '[data.groups](#.data%25E2%2580%25A4groups)' option should be set
   *   - y Axis will be set in percentage value (0 ~ 100%)
   *   - Must have postive values
   * @name data․stack․normalize
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataStackNormalized)
   * @example
   * data: {
   *   stack: {
   *      normalize: true
   *   }
   * }
   */
  data_stack_normalize: !1,

  /**
   * Set a callback for click event on each data point.<br><br>
   * This callback will be called when each data point clicked and will receive `d` and element as the arguments.
   * - `d` is the data clicked and element is the element clicked.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onclick
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onclick: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onclick: function data_onclick() {},

  /**
   * Set a callback for mouse/touch over event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves onto each data point and will receive `d` and `element` as the argument.
   * - `d` is the data where mouse cursor moves onto.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onover
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onover: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onover: function data_onover() {},

  /**
   * Set a callback for mouse/touch out event on each data point.<br><br>
   * This callback will be called when mouse cursor or via touch moves out each data point and will receive `d` as the argument.
   * - `d` is the data where mouse cursor moves out.
   * - `element` is the current interacting svg element.
   * - In this callback, `this` will be the Chart object.
   * @name data․onout
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onout: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4}
   *        // element - <circle>
   *        ...
   *     }
   * }
   */
  data_onout: function data_onout() {},

  /**
   * Set a callback for on data selection.
   * @name data․onselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onselected: function data_onselected() {},

  /**
   * Set a callback for on data un-selection.
   * @name data․onunselected
   * @memberof Options
   * @type {Function}
   * @default function() {}
   * @example
   * data: {
   *     onunselected: function(d, element) {
   *        // d - ex) {x: 4, value: 150, id: "data1", index: 4, name: "data1"}
   *        // element - <circle>
   *        ...
   *    }
   * }
   */
  data_onunselected: function data_onunselected() {},

  /**
   * Set a callback for minimum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmin
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmin: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmin: undefined,

  /**
   * Set a callback for maximum data
   * - **NOTE:** For 'area-line-range' and 'area-spline-range', `mid` data will be taken for the comparison
   * @name data․onmax
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.OnMinMaxCallback)
   * @example
   *  onmax: function(data) {
   *    // data - ex) [{x: 3, value: 400, id: "data1", index: 3}, ... ]
   *    ...
   *  }
   */
  data_onmax: undefined,

  /**
   * Load a CSV or JSON file from a URL. NOTE that this will not work if loading via the "file://" protocol as the most browsers will block XMLHTTPRequests.
   * @name data․url
   * @memberof Options
   * @type {String}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.LoadData)
   * @example
   * data: {
   *     url: "/data/test.csv"
   * }
   */
  data_url: undefined,

  /**
   * XHR header value
   * - **NOTE:** Should be used with `data.url` option
   * @name data․headers
   * @memberof Options
   * @type {String}
   * @default undefined
   * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader
   * @example
   * data: {
   *     url: "/data/test.csv",
   *     headers: {
   *        "Content-Type": "text/xml",
   *        ...
   *     }
   * }
   */
  data_headers: undefined,

  /**
   * Parse a JSON object for data. See also data.keys.
   * @name data․json
   * @memberof Options
   * @type {Object}
   * @default undefined
   * @see [data․keys](#.data%25E2%2580%25A4keys)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.JSONData)
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_json: undefined,

  /**
   * Load data from a multidimensional array, with the first element containing the data names, the following containing related data in that order.
   * @name data․rows
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.RowOrientedData)
   * @example
   * data: {
   *   rows: [
   *     ["A", "B", "C"],
   *     [90, 120, 300],
   *     [40, 160, 240],
   *     [50, 200, 290],
   *     [120, 160, 230],
   *     [80, 130, 300],
   *     [90, 220, 320]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {high:150, mid: 140, low: 110}, 120
   *        [150, 140, 110], 120
   *      ],
   *      [[155, 130, 115], 55],
   *      [[160, 135, 120], 60]
   *   ],
   *   types: {
   *       data1: "area-line-range",
   *       data2: "line"
   *   }
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   rows: [
   *      ["data1", "data2"],
   *      [
   *        // or {y:10, z: 140}, 120
   *        [10, 140], 120
   *      ],
   *      [[100, 30], 55],
   *      [[50, 100], 60]
   *   ],
   *   types: {
   *       data1: "bubble",
   *       data2: "line"
   *   }
   * }
   */
  data_rows: undefined,

  /**
   * Load data from a multidimensional array, with each element containing an array consisting of a datum name and associated data values.
   * @name data․columns
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.ColumnOrientedData)
   * @example
   * data: {
   *   columns: [
   *      ["data1", 30, 20, 50, 40, 60, 50],
   *      ["data2", 200, 130, 90, 240, 130, 220],
   *      ["data3", 300, 200, 160, 400, 250, 250]
   *   ]
   * }
   *
   * // for 'range' types('area-line-range' or 'area-spline-range'), data should contain:
   * // - an array of [high, mid, low] data following the order
   * // - or an object with 'high', 'mid' and 'low' key value
   * data: {
   *   columns: [
   *      ["data1",
   *          [150, 140, 110],  // or {high:150, mid: 140, low: 110}
   *          [150, 140, 110],
   *          [150, 140, 110]
   *      ]
   *   ],
   *   type: "area-line-range"
   * }
   *
   * // for 'bubble' type, data can contain dimension value:
   * // - an array of [y, z] data following the order
   * // - or an object with 'y' and 'z' key value
   * // 'y' is for y axis coordination and 'z' is the bubble radius value
   * data: {
   *   columns: [
   *      ["data1",
   *          [10, 140],  // or {y:10, z: 140}
   *          [100, 30],
   *          [50, 100]
   *      ]
   *   ],
   *   type: "bubble"
   * }
   */
  data_columns: undefined,

  /**
   * Used if loading JSON via data.url.
   * - **Available Values:**
   *   - json
   *   - csv
   *   - tsv
   * @name data․mimeType
   * @memberof Options
   * @type {String}
   * @default csv
   * @example
   * data: {
   *     mimeType: "json"
   * }
   */
  data_mimeType: "csv",

  /**
   * Choose which JSON object keys correspond to desired data.
   * - **NOTE:** Only for JSON object given as array.
   * @name data․keys
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * data: {
   *     json: [
   *       {name: "www.site1.com", upload: 200, download: 200, total: 400},
   *       {name: "www.site2.com", upload: 100, download: 300, total: 400},
   *       {name: "www.site3.com", upload: 300, download: 200, total: 500},
   *       {name: "www.site4.com", upload: 400, download: 100, total: 500}
   *     ],
   *     keys: {
   *       // x: "name", // it's possible to specify 'x' when category axis
   *       value: ["upload", "download"]
   *     }
   * }
   */
  data_keys: undefined,

  /**
   * Set text label to be displayed when there's no data to show.
   * - ex. Toggling all visible data to not be shown, unloading all current data, etc.
   * @name data․empty․label․text
   * @memberof Options
   * @type {String}
   * @default ""
   * @example
   * data: {
   *   empty: {
   *     label: {
   *       text: "No Data"
   *     }
   *   }
   * }
   */
  data_empty_label_text: ""
}, data_selection));
// CONCATENATED MODULE: ./src/config/Options/axis/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var axis_x = ({
  /**
   * Set clip-path attribute for x axis element
   * @name axis․x․clipPath
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo]()
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_x_clipPath: !0,

  /**
   * Show or hide x axis.
   * @name axis․x․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     show: false
   *   }
   * }
   */
  axis_x_show: !0,

  /**
   * Set type of x axis.<br><br>
   * **Available Values:**
   * - timeseries
   * - category
   * - indexed
   * @name axis․x․type
   * @memberof Options
   * @type {String}
   * @default indexed
   * @see [Demo: indexed](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: timeseries](https://naver.github.io/billboard.js/demo/#Chart.TimeseriesChart)
   * @see [Demo: category](https://naver.github.io/billboard.js/demo/#Data.CategoryData)
   * @example
   * axis: {
   *   x: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_x_type: "indexed",

  /**
   * Set how to treat the timezone of x values.<br>
   * If true, treat x value as localtime. If false, convert to UTC internally.
   * @name axis․x․localtime
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     localtime: false
   *   }
   * }
   */
  axis_x_localtime: !0,

  /**
   * Set category names on category axis.
   * This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @name axis․x․categories
   * @memberof Options
   * @type {Array}
   * @default []
   * @example
   * axis: {
   *   x: {
   *     categories: ["Category 1", "Category 2", ...]
   *   }
   * }
   */
  axis_x_categories: [],

  /**
   * centerize ticks on category axis.
   * @name axis․x․tick․centered
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       centered: true
   *     }
   *   }
   * }
   */
  axis_x_tick_centered: !1,

  /**
   * A function to format tick value. Format string is also available for timeseries data.
   * @name axis․x․tick․format
   * @memberof Options
   * @type {Function|String}
   * @default undefined
   * @see [D3's time specifier](https://github.com/d3/d3-time-format#locale_format)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *        // for timeseries, a 'datetime' object is given as parameter
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *
   *       // for category, index(Number) and categoryName(String) are given as parameter
   *       format: function(index, categoryName) {
   *           return categoryName.substr(0, 10);
   *       },
   *
   *        // for timeseries format specifier
   *        format: "%Y-%m-%d %H:%M:%S"
   *     }
   *   }
   * }
   */
  axis_x_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.x.tick.culling.max.
   * @name axis․x․tick․culling
   * @memberof Options
   * @type {Boolean}
   * @default
   * - true for indexed axis and timeseries axis
   * - false for category axis
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_x_tick_culling: {},

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․x․tick․culling․max
   * @memberof Options
   * @type {Number}
   * @default 10
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_culling_max: 10,

  /**
   * The number of x axis ticks to show.<br><br>
   * This option hides tick lines together with tick text. If this option is used on timeseries axis, the ticks position will be determined precisely and not nicely positioned (e.g. it will have rough second value).
   * @name axis․x․tick․count
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_x_tick_count: undefined,

  /**
   * Show or hide x axis tick line.
   * @name axis․x․tick․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_x_tick_show: !0,

  /**
   * Show or hide x axis tick text.
   * @name axis․x․tick․text․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_show: !0,

  /**
   * Set the x Axis tick text's position relatively its original position
   * @name axis․x․tick․text․position
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Fit x axis ticks.
   * - **true**: ticks will be positioned nicely to have same intervals.
   * - **false**: ticks will be positioned according to x value of the data points.
   * @name axis․x․tick․fit
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickFitting)
   * @see [Demo: for timeseries zoom](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickTimeseries)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       fit: false
   *     }
   *   }
   * }
   */
  axis_x_tick_fit: !0,

  /**
   * Set the x values of ticks manually.<br><br>
   * If this option is provided, the position of the ticks will be determined based on those values.<br>
   * This option works with `timeseries` data and the x values will be parsed accoding to the type of the value and data.xFormat option.
   * @name axis․x․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       values: [1, 2, 4, 8, 16, 32, ...],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_x_tick_values: null,

  /**
   * Rotate x axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `false`.
   * @name axis․x․tick․rotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.RotateXAxisTickText)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_x_tick_rotate: 0,

  /**
   * Show x axis outer tick.
   * @name axis․x․tick․outer
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_x_tick_outer: !0,

  /**
   * Set tick text to be multiline
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break and 'axis.x.tick.width' option is ignored.
   * @name axis․x․tick․multiline
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.XAxisTickMultiline)
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       multiline: false
   *     }
   *   }
   * }
   * @example
   * // example of line break with '\n'
   * // In this case, 'axis.x.tick.width' is ignored
   * data: {
   *    x: "x",
   *    columns: [
   *        ["x", "long\ntext", "Another\nLong\nText"],
   *        ...
   *    ],
   * }
   */
  axis_x_tick_multiline: !0,

  /**
   * Set tick width
   * - **NOTE:**
   *  > When x tick text contains `\n`, this option is ignored.
   * @name axis․x․tick․width
   * @memberof Options
   * @type {Number}
   * @default null
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       width: 50
   *     }
   *   }
   * }
   */
  axis_x_tick_width: null,

  /**
   * Set to display system tooltip(via 'title' attribute) for tick text
   * - **NOTE:** Only available for category axis type (`axis.x.type='category'`)
   * @name axis․x․tick․tooltip
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   x: {
   *     tick: {
   *       tooltip: true
   *     }
   *   }
   * }
   */
  axis_x_tick_tooltip: !1,

  /**
   * Set max value of x axis range.
   * @name axis․x․max
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     max: 100
   *   }
   * }
   */
  axis_x_max: undefined,

  /**
   * Set min value of x axis range.
   * @name axis․x․min
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     min: -100
   *   }
   * }
   */
  axis_x_min: undefined,

  /**
   * Set padding for x axis.<br><br>
   * If this option is set, the range of x axis will increase/decrease according to the values.
   * If no padding is needed in the rage of x axis, 0 should be set.
   * - **NOTE:**
   *   The padding values aren't based on pixels. It differs according axis types<br>
   *   - **category:** The unit of tick value
   *     ex. the given value `1`, is same as the width of 1 tick width
   *   - **timeseries:** Numeric time value
   *     ex. the given value `1000*60*60*24`, which is numeric time equivalent of a day, is same as the width of 1 tick width
   * @name axis․x․padding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   x: {
   *     padding: {
   *       // when axis type is 'category'
   *       left: 1,  // set left padding width of equivalent value of a tick's width
   *       right: 0.5  // set right padding width as half of equivalent value of tick's width
   *
   *       // when axis type is 'timeseries'
   *       left: 1000*60*60*24,  // set left padding width of equivalent value of a day tick's width
   *       right: 1000*60*60*12   // set right padding width as half of equivalent value of a day tick's width
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_x_padding: {},

  /**
   * Set height of x axis.<br><br>
   * The height of x axis can be set manually by this option. If you need more space for x axis, please use this option for that. The unit is pixel.
   * @name axis․x․height
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     height: 20
   *   }
   * }
   */
  axis_x_height: undefined,

  /**
   * Set default extent for subchart and zoom. This can be an array or function that returns an array.
   * @name axis․x․extent
   * @memberof Options
   * @type {Array|Function}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     // extent range as a pixel value
   *     extent: [0, 200],
   *
   *     // when axis is 'timeseries', parsable datetime string
   *     extent: ["2019-03-01", "2019-03-05"],
   *
   *     // return extent value
   *     extent: function(domain, scale) {
   *    	 var extent = domain.map(function(v) {
   *     	    return scale(v);
   *     	 });
   *
   *   	 // it should return a format of array
   *   	 // ex) [0, 584]
   *     	 return extent;
   *     }
   *   }
   * }
   */
  axis_x_extent: undefined,

  /**
   * Set label on x axis.<br><br>
   * You can set x axis label and change its position by this option.
   * `string` and `object` can be passed and we can change the poisiton by passing object that has position key.<br>
   * Available position differs according to the axis direction (vertical or horizontal).
   * If string set, the position will be the default.
   *
   *  - **If it's horizontal axis:**
   *    - inner-right [default]
   *    - inner-center
   *    - inner-left
   *    - outer-right
   *    - outer-center
   *    - outer-left
   *  - **If it's vertical axis:**
   *    - inner-top [default]
   *    - inner-middle
   *    - inner-bottom
   *    - outer-top
   *    - outer-middle
   *    - outer-bottom
   * @name axis․x․label
   * @memberof Options
   * @type {String|Object}
   * @default undefined
   * @example
   * axis: {
   *   x: {
   *     label: "Your X Axis"
   *   }
   * }
   *
   * axis: {
   *   x: {
   *     label: {
   *        text: "Your X Axis",
   *        position: "outer-center"
   *     }
   *   }
   * }
   */
  axis_x_label: {},

  /**
   * Set additional axes for x Axis.
   * - **NOTE:** Axis' scale is based on x Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․x․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * x: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main x Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_x_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y Axis  config options
 */
/* harmony default export */ var axis_y = ({
  /**
   * Set clip-path attribute for y axis element
   * - **NOTE**: `clip-path` attribute for y Axis is set only when `axis.y.inner` option is true.
   * @name axis․y․clipPath
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * // don't set 'clip-path' attribute
   * clipPath: false
   */
  axis_y_clipPath: !0,

  /**
   * Show or hide y axis.
   * @name axis․y․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     show: false
   *   }
   * }
   */
  axis_y_show: !0,

  /**
   * Set type of y axis.<br><br>
   * **Available Values:**
   *   - timeseries
   *   - category
   *   - indexed
   * @name axis․y․type
   * @memberof Options
   * @type {String}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     type: "timeseries"
   *   }
   * }
   */
  axis_y_type: undefined,

  /**
   * Set max value of y axis.
   * - **NOTE:** Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․max
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     max: 1000
   *   }
   * }
   */
  axis_y_max: undefined,

  /**
   * Set min value of y axis.
   * - **NOTE:**
   *   Padding will be added based on this value, so if you don't need the padding, please set axis.y.padding to disable it (e.g. axis.y.padding = 0).
   * @name axis․y․min
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     min: 1000
   *   }
   * }
   */
  axis_y_min: undefined,

  /**
   * Change the direction of y axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y․inverted
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inverted: true
   *   }
   * }
   */
  axis_y_inverted: !1,

  /**
   * Set center value of y axis.
   * @name axis․y․center
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     center: 0
   *   }
   * }
   */
  axis_y_center: undefined,

  /**
   * Show y axis inside of the chart.
   * @name axis․y․inner
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     inner: true
   *   }
   * }
   */
  axis_y_inner: !1,

  /**
   * Set label on y axis.<br><br>
   * You can set y axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y․label
   * @memberof Options
   * @type {String|Object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y: {
   *     label: "Your Y Axis"
   *   }
   * }
   *
   * axis: {
   *   y: {
   *     label: {
   *        text: "Your Y Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y_label: {},

  /**
   * Set formatter for y axis tick text.<br><br>
   * This option accepts d3.format object as well as a function you define.
   * @name axis․y․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       format: function(x) {
   *           return x.getFullYear();
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y․tick․culling
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y․tick․culling․max
   * @memberof Options
   * @type {Number}
   * @default 5
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_culling_max: 5,

  /**
   * Show y axis outer tick.
   * @name axis․y․tick․outer
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y_tick_outer: !0,

  /**
   * Set y axis tick values manually.
   * @name axis․y․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_values: null,

  /**
   * Rotate y axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y․tick․rotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y_tick_rotate: 0,

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․count
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y_tick_count: undefined,

  /**
   * Show or hide y axis tick line.
   * @name axis․y․tick․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y.tick.count` or `axis.y.tick.values` options are set.
   * @name axis․y․tick․stepSize
   * @memberof Options
   * @type {Number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y_tick_stepSize: null,

  /**
  * Show or hide y axis tick text.
  * @name axis․y․tick․text․show
  * @memberof Options
  * @type {Boolean}
  * @default true
  * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
  * @example
  * axis: {
  *   y: {
  *     tick: {
  *       text: {
  *           show: false
  *       }
  *     }
  *   }
  * }
  */
  axis_y_tick_text_show: !0,

  /**
   * Set the y Axis tick text's position relatively its original position
   * @name axis․y․tick․text․position
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y axis ticks.<br><br>
   * - **NOTE:** The position of the ticks will be calculated precisely, so the values on the ticks will not be rounded nicely. In the case, axis.y.tick.format or axis.y.tick.values will be helpful.
   * @name axis․y․tick․time
   * @memberof Options
   * @private
   * @type {Object}
   * @property {Function} [time.value] D3's time interval function (https://github.com/d3/d3-time#intervals)
   * @example
   * axis: {
   *   y: {
   *     tick: {
   *       time: {
   *          // ticks at 15-minute intervals
   *          // https://github.com/d3/d3-scale/blob/master/README.md#time_ticks
   *          value: d3.timeMinute.every(15)
   *       }
   *     }
   *   }
   * }
   */
  // @TODO: not fully implemented yet
  axis_y_tick_time_value: undefined,

  /**
   * Set padding for y axis.<br><br>
   * You can set padding for y axis to create more space on the edge of the axis.
   * This option accepts object and it can include top and bottom. top, bottom will be treated as pixels.
   *
   * - **NOTE:** For area and bar type charts, [area.zerobased](#.area) or [bar.zerobased](#.bar) options should be set to 'false` to get padded bottom.
   * @name axis․y․padding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   y: {
   *     padding: {
   *       top: 0,
   *       bottom: 0
   *     },
   *
   *     // or set both values at once.
   *     padding: 10
   *   }
   * }
   */
  axis_y_padding: {},

  /**
   * Set default range of y axis.<br><br>
   * This option set the default value for y axis when there is no data on init.
   * @name axis․y․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y_default: undefined,

  /**
   * Set additional axes for y Axis.
   * - **NOTE:** Axis' scale is based on y Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/y2.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * y2 Axis  config options
 */
/* harmony default export */ var axis_y2 = ({
  /**
   * Show or hide y2 axis.
   * - **NOTE**:
   *   - When set to `false` will not generate y2 axis node. In this case, all 'y2' axis related functionality won't work properly.
   *   - If need to use 'y2' related options while y2 isn't visible, set the value `true` and control visibility by css display property.
   * @name axis․y2․show
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     show: true
   *   }
   * }
   */
  axis_y2_show: !1,

  /**
   * Set max value of y2 axis.
   * @name axis․y2․max
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     max: 1000
   *   }
   * }
   */
  axis_y2_max: undefined,

  /**
   * Set min value of y2 axis.
   * @name axis․y2․min
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     min: -1000
   *   }
   * }
   */
  axis_y2_min: undefined,

  /**
   * Change the direction of y2 axis.<br><br>
   * If true set, the direction will be from the top to the bottom.
   * @name axis․y2․inverted
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inverted: true
   *   }
   * }
   */
  axis_y2_inverted: !1,

  /**
   * Set center value of y2 axis.
   * @name axis․y2․center
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     center: 0
   *   }
   * }
   */
  axis_y2_center: undefined,

  /**
   * Show y2 axis inside of the chart.
   * @name axis․y2․inner
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     inner: true
   *   }
   * }
   */
  axis_y2_inner: !1,

  /**
   * Set label on y2 axis.<br><br>
   * You can set y2 axis label and change its position by this option. This option works in the same way as [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label).
   * @name axis․y2․label
   * @memberof Options
   * @type {String|Object}
   * @default {}
   * @see [axis.x.label](#.axis%25E2%2580%25A4x%25E2%2580%25A4label) for position string value.
   * @example
   * axis: {
   *   y2: {
   *     label: "Your Y2 Axis"
   *   }
   * }
   *
   * axis: {
   *   y2: {
   *     label: {
   *        text: "Your Y2 Axis",
   *        position: "outer-middle"
   *     }
   *   }
   * }
   */
  axis_y2_label: {},

  /**
   * Set formatter for y2 axis tick text.<br><br>
   * This option works in the same way as axis.y.format.
   * @name axis․y2․tick․format
   * @memberof Options
   * @type {Function}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       format: d3.format("$,")
   *       //or format: function(d) { return "$" + d; }
   *     }
   *   }
   * }
   */
  axis_y2_tick_format: undefined,

  /**
   * Setting for culling ticks.<br><br>
   * If true is set, the ticks will be culled, then only limitted tick text will be shown. This option does not hide the tick lines. If false is set, all of ticks will be shown.<br><br>
   * We can change the number of ticks to be shown by axis.y.tick.culling.max.
   * @name axis․y2․tick․culling
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling: !1,

  /**
   * The number of tick texts will be adjusted to less than this value.
   * @name axis․y2․tick․culling․max
   * @memberof Options
   * @type {Number}
   * @default 5
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       culling: {
   *           max: 5
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_culling_max: 5,

  /**
   * Show or hide y2 axis outer tick.
   * @name axis․y2․tick․outer
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       outer: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_outer: !0,

  /**
   * Set y2 axis tick values manually.
   * @name axis․y2․tick․values
   * @memberof Options
   * @type {Array|Function}
   * @default null
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       values: [100, 1000, 10000],
   *
   *       // an Array value should be returned
   *       values: function() {
   *       	return [ ... ];
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_values: null,

  /**
   * Rotate y2 axis tick text.
   * - If you set negative value, it will rotate to opposite direction.
   * - Applied when [`axis.rotated`](#.axis%25E2%2580%25A4rotated) option is `true`.
   * @name axis․y2․tick․rotate
   * @memberof Options
   * @type {Number}
   * @default 0
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       rotate: 60
   *     }
   *   }
   * }
   */
  axis_y2_tick_rotate: 0,

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axis․y2․tick․count
   * @memberof Options
   * @type {Number}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       count: 5
   *     }
   *   }
   * }
   */
  axis_y2_tick_count: undefined,

  /**
   * Show or hide y2 axis tick line.
   * @name axis․y2․tick․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       show: false
   *     }
   *   }
   * }
   */
  axis_y2_tick_show: !0,

  /**
   * Set axis tick step(interval) size.
   * - **NOTE:** Will be ignored if `axis.y2.tick.count` or `axis.y2.tick.values` options are set.
   * @name axis․y2․tick․stepSize
   * @memberof Options
   * @type {Number}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.StepSizeForYAxis)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       // tick value will step as indicated interval value.
   *       // ex) 'stepSize=15' ==> [0, 15, 30, 45, 60]
   *       stepSize: 15
   *     }
   *   }
   * }
   */
  axis_y2_tick_stepSize: null,

  /**
   * Show or hide y2 axis tick text.
   * @name axis․y2․tick․text․show
   * @memberof Options
   * @type {Boolean}
   * @default true
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.HideTickLineText)
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *           show: false
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_show: !0,

  /**
   * Set the y2 Axis tick text's position relatively its original position
   * @name axis․y2․tick․text․position
   * @memberof Options
   * @type {Object}
   * @default {x: 0, y:0}
   * @example
   * axis: {
   *   y2: {
   *     tick: {
   *       text: {
   *         position: {
   *           x: 10,
   *           y: 10
   *         }
   *       }
   *     }
   *   }
   * }
   */
  axis_y2_tick_text_position: {
    x: 0,
    y: 0
  },

  /**
   * Set the number of y2 axis ticks.
   * - **NOTE:** This works in the same way as axis.y.tick.count.
   * @name axis․y2․padding
   * @memberof Options
   * @type {Object|Number}
   * @default {}
   * @example
   * axis: {
   *   y2: {
   *     padding: {
   *       top: 100,
   *       bottom: 100
   *     }
   *
   *     // or set both values at once.
   *     padding: 10
   * }
   */
  axis_y2_padding: {},

  /**
   * Set default range of y2 axis.<br><br>
   * This option set the default value for y2 axis when there is no data on init.
   * @name axis․y2․default
   * @memberof Options
   * @type {Array}
   * @default undefined
   * @example
   * axis: {
   *   y2: {
   *     default: [0, 1000]
   *   }
   * }
   */
  axis_y2_default: undefined,

  /**
   * Set additional axes for y2 Axis.
   * - **NOTE:** Axis' scale is based on y2 Axis value if domain option isn't set.
   *
   * Each axis object should consist with following options:
   *
   * | Name | Type | Default | Description |
   * | --- | --- | --- | --- |
   * | domain | Array | - | Set the domain value |
   * | tick.outer | Boolean | true | Show outer tick |
   * | tick.format | Function | - | Set formatter for tick text |
   * | tick.count | Number | - | Set the number of y axis ticks |
   * | tick.values | Array | - | Set tick values manually |
   * @name axis․y2․axes
   * @memberof Options
   * @type {Array}
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Axis.MultiAxes)
   * @see [Demo: Domain](https://naver.github.io/billboard.js/demo/#Axis.MultiAxesDomain)
   * @example
   * y2: {
   *    axes: [
   *      {
   *        // if set, will not be correlated with the main y2 Axis domain value
   *        domain: [0, 1000],
   *        tick: {
   *          outer: false,
   *          format: function(x) {
   *             return x + "%";
   *          },
   *          count: 2,
   *          values: [10, 20, 30]
   *        }
   *      },
   *      ...
   *    ]
   * }
   */
  axis_y2_axes: []
});
// CONCATENATED MODULE: ./src/config/Options/axis/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/**
* y Axis  config options
*/

/* harmony default export */ var axis_axis = (mergeObj({
  /**
   * Switch x and y axis position.
   * @name axis․rotated
   * @memberof Options
   * @type {Boolean}
   * @default false
   * @example
   * axis: {
   *   rotated: true
   * }
   */
  axis_rotated: !1
}, axis_x, axis_y, axis_y2));
// CONCATENATED MODULE: ./src/config/Options/common/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * color config options
 */
/* harmony default export */ var common_color = ({
  /**
   * Set color of the data values
   * @name color
   * @memberof Options
   * @type {Object}
   * @property {String|Object|Function} [color.onover] Set the color value for each data point when mouse/touch onover event occurs.
   * @property {Array} [color.pattern=[]] custom color pattern
   * @property {Function} [color.tiles] if defined, allows use svg's patterns to fill data area. It should return an array of [SVGPatternElement](https://developer.mozilla.org/en-US/docs/Web/API/SVGPatternElement).
   *  - **NOTE:** The pattern element's id will be defined as `bb-colorize-pattern-$COLOR-VALUE`.<br>
   *    ex. When color pattern value is `['red', '#fff']` and defined 2 patterns,then ids for pattern elements are:<br>
   *    - `bb-colorize-pattern-red`
   *    - `bb-colorize-pattern-fff`
   * @property {Object} [color.threshold] color threshold for gauge and tooltip color
   * @property {String} [color.threshold.unit] If set to `value`, the threshold will be based on the data value. Otherwise it'll be based on equation of the `threshold.max` option value.
   * @property {Array} [color.threshold.values] Threshold values for each steps
   * @property {Number} [color.threshold.max=100] The base value to determine threshold step value condition. When the given value is 15 and max 10, then the value for threshold is `15*100/10`.
   * @example
   *  color: {
   *      pattern: ["#1f77b4", "#aec7e8", ...],
   *
   *      // Set colors' patterns
   *      // it should return an array of SVGPatternElement
   *      tiles: function() {
   *         var pattern = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
   *         var g = document.createElementNS("http://www.w3.org/2000/svg", "g");
   *         var circle1 = document.createElementNS("http://www.w3.org/2000/svg", "circle");
   *
   *         pattern.setAttribute("patternUnits", "userSpaceOnUse");
   *         pattern.setAttribute("width", "32");
   *         pattern.setAttribute("height", "32");
   *
   *         g.style.fill = "#000";
   *         g.style.opacity = "0.2";
   *
   *         circle1.setAttribute("cx", "3");
   *         circle1.setAttribute("cy", "3");
   *         circle1.setAttribute("r", "3");
   *
   *         g.appendChild(circle1);
   *         pattern.appendChild(g);
   *
   *         return [pattern];
   *      },
   *
   *      // for threshold usage, pattern values should be set for each steps
   *      pattern: ["grey", "green", "yellow", "orange", "red"],
   *      threshold: {
   *          unit: "value",
   *
   *          // when value is 20 => 'green', value is 40 => 'orange' will be set.
   *          values: [10, 20, 30, 40, 50],
   *
   *          // the equation for max:
   *          // - unit == 'value': max => 30
   *          // - unit != 'value': max => value*100/30
   *          max: 30
   *      },
   *
   *      // set all data to 'red'
   *      onover: "red",
   *
   *      // set different color for data
   *      onover: {
   *          data1: "red",
   *          data2: "yellow"
   *      },
   *
   *      // will pass data object to the callback
   *      onover: function(d) {
   *          return d.id === "data1" ? "red" : "green";
   *      }
   *  }
   */
  color_pattern: [],
  color_tiles: undefined,
  color_threshold: {},
  color_onover: undefined
});
// CONCATENATED MODULE: ./src/config/Options/common/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * grid config options
 */
/* harmony default export */ var common_grid = ({
  /**
   * Set related options
   * @name grid
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [front=false] Set 'grid & focus lines' to be positioned over grid lines and chart elements.
   * @property {Boolean} [x.show=false] Show grids along x axis.
   * @property {Array} [x.lines=[]] Show additional grid lines along x axis.<br>
   *  This option accepts array including object that has value, text, position and class. text, position and class are optional. For position, start, middle and end (default) are available.
   *  If x axis is category axis, value can be category name. If x axis is timeseries axis, value can be date string, Date object and unixtime integer.
   * @property {Boolean} [y.show=false] Show grids along x axis.
   * @property {Array} [y.lines=[]] Show additional grid lines along y axis.<br>
   *  This option accepts array including object that has value, text, position and class.
   * @property {Number} [y.ticks=10] Number of y grids to be shown.
   * @property {Boolean} [focus.edge=false] Show edged focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {Boolean} [focus.show=true] Show grid line when focus.
   * @property {Boolean} [focus.y=false] Show y coordinate focus grid line.<br>**NOTE:** Available when [`tooltip.grouped=false`](#.tooltip) option is set.
   * @property {Boolean} [lines.front=true] Set grid lines to be positioned over chart elements.
   * @default undefined
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Grid.GridLines)
   * @see [Demo: X Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalXGridLines)
   * @see [Demo: Y Grid Lines](https://naver.github.io/billboard.js/demo/#Grid.OptionalYGridLines)
   * @example
   * grid: {
   *   x: {
   *     show: true,
   *     lines: [
   *       {value: 2, text: "Label on 2"},
   *       {value: 5, text: "Label on 5", class: "label-5"},
   *       {value: 6, text: "Label on 6", position: "start"}
   *     ]
   *   },
   *   y: {
   *     show: true,
   *     lines: [
   *       {value: 100, text: "Label on 100"},
   *       {value: 200, text: "Label on 200", class: "label-200"},
   *       {value: 300, text: "Label on 300", position: 'middle'}
   *     ],
   *     ticks: 5
   *   },
   *   front: true,
   *   focus: {
   *      show: false,
   *
   *      // Below options are available when 'tooltip.grouped=false' option is set
   *      edge: true,
   *      y: true
   *   },
   *   lines: {
   *      front: false
   *   }
   * }
   */
  grid_x_show: !1,
  grid_x_type: "tick",
  grid_x_lines: [],
  grid_y_show: !1,
  grid_y_lines: [],
  grid_y_ticks: 10,
  grid_focus_edge: !1,
  grid_focus_show: !0,
  grid_focus_y: !1,
  grid_front: !1,
  grid_lines_front: !0
});
// CONCATENATED MODULE: ./src/config/Options/common/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * interaction config options
 */
/* harmony default export */ var interaction = ({
  /**
   * Interaction options
   * @name interaction
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [interaction.enabled=true] Indicate if the chart should have interactions.<br>
   *     If `false` is set, all of interactions (showing/hiding tooltip, selection, mouse events, etc) will be disabled.
   * @property {Boolean} [interaction.brighten=true] Make brighter for the selected area (ex. 'pie' type data selected area)
   * @property {Boolean} [interaction.inputType.mouse=true] enable or disable mouse interaction
   * @property {Boolean} [interaction.inputType.touch=true] enable or disable  touch interaction
   * @property {Boolean|Number} [interaction.inputType.touch.preventDefault=false] enable or disable to call event.preventDefault on touchstart & touchmove event. It's usually used to prevent document scrolling.
   * @see [Demo: touch.preventDefault](https://naver.github.io/billboard.js/demo/#Interaction.PreventScrollOnTouch)
   * @example
   * interaction: {
   *    enabled: false,
   *    brighten: false,
   *    inputType: {
   *        mouse: true,
   *        touch: false
   *
   *        // or declare preventDefault explicitly.
   *        // In this case touch inputType is enabled by default
   *        touch: {
   *            preventDefault: true
   *
   *            // or threshold pixel value (pixel moved from touchstart to touchmove)
   *            preventDefault: 5
   *        }
   *    }
   * }
   */
  interaction_enabled: !0,
  interaction_brighten: !0,
  interaction_inputType_mouse: !0,
  interaction_inputType_touch: {}
});
// CONCATENATED MODULE: ./src/config/Options/common/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * legend config options
 */
/* harmony default export */ var common_legend = ({
  /**
   * Legend options
   * @name legend
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [legend.show=true] Show or hide legend.
   * @property {Boolean} [legend.hide=false] Hide legend
   *  If true given, all legend will be hidden. If string or array given, only the legend that has the id will be hidden.
   * @property {String|HTMLElement} [legend.contents.bindto=undefined] Set CSS selector or element reference to bind legend items.
   * @property {String|Function} [legend.contents.template=undefined] Set item's template.<br>
   *  - If set `string` value, within template the 'color' and 'title' can be replaced using template-like syntax string:
   *    - {=COLOR}: data color value
   *    - {=TITLE}: data title value
   *  - If set `function` value, will pass following arguments to the given function:
   *   - title {String}: data's id value
   *   - color {String}: color string
   *   - data {Array}: data array
   * @property {String} [legend.position=bottom] Change the position of legend.<br>
   *  Available values are: `bottom`, `right` and `inset` are supported.
   * @property {Object} [legend.inset={anchor: 'top-left',x: 10,y: 0,step: undefined}] Change inset legend attributes.<br>
   *  This option accepts object that has the keys `anchor`, `x`, `y` and `step`.
   *  - **anchor** decides the position of the legend:
   *   - top-left
   *   - top-right
   *   - bottom-left
   *   - bottom-right
   *  - **x** and **y**:
   *   - set the position of the legend based on the anchor.
   *  - **step**:
   *   - defines the max step the legend has (e.g. If 2 set and legend has 3 legend item, the legend 2 columns).
   * @property {Boolean} [legend.equally=false] Set to all items have same width size.
   * @property {Boolean} [legend.padding=0] Set padding value
   * @property {Function} [legend.item.onclick=undefined] Set click event handler to the legend item.
   * @property {Function} [legend.item.onover=undefined] Set mouse/touch over event handler to the legend item.
   * @property {Function} [legend.item.onout=undefined] Set mouse/touch out event handler to the legend item.
   * @property {Number} [legend.item.tile.width=10] Set width of item tile element
   * @property {Number} [legend.item.tile.height=10] Set height of item tile element
   * @property {Boolean} [legend.usePoint=false] Whether to use custom points in legend.
   * @see [Demo: position](https://naver.github.io/billboard.js/demo/#Legend.LegendPosition)
   * @see [Demo: contents.template](https://naver.github.io/billboard.js/demo/#Legend.LegendTemplate1)
   * @see [Demo: usePoint](https://naver.github.io/billboard.js/demo/#Legend.usePoint)
   * @example
   *  legend: {
   *      show: true,
   *      hide: true,
   *      //or hide: "data1"
   *      //or hide: ["data1", "data2"]
   *      contents: {
   *          bindto: "#legend",   // <ul id='legend'></ul>
   *
   *          // will be as: <li style='background-color:#1f77b4'>data1</li>
   *          template: "<li style='background-color:{=COLOR}'>{=TITLE}</li>"
   *
   *          // or using function
   *          template: function(id, color, data) {
   *               // if you want omit some legend, return falsy value
   *               if (title !== "data1") {
   *                    return "<li style='background-color:"+ color +">"+ title +"</li>";
   *               }
   *          }
   *      },
   *      position: "bottom",  // bottom, right, inset
   *      inset: {
   *          anchor: "top-right"  // top-left, top-right, bottom-left, bottom-right
   *          x: 20,
   *          y: 10,
   *          step: 2
   *      },
   *      equally: false,
   *      padding: 10,
   *      item: {
   *          onclick: function(id) { ... },
   *          onover: function(id) { ... },
   *          onout: function(id) { ... },
   *
   *          // set tile's size
   *          tile: {
   *              width: 20,
   *              height: 15
   *          }
   *      },
   *      usePoint: true
   *  }
   */
  legend_show: !0,
  legend_hide: !1,
  legend_contents_bindto: undefined,
  legend_contents_template: undefined,
  legend_position: "bottom",
  legend_inset_anchor: "top-left",
  legend_inset_x: 10,
  legend_inset_y: 0,
  legend_inset_step: undefined,
  legend_item_onclick: undefined,
  legend_item_onover: undefined,
  legend_item_onout: undefined,
  legend_equally: !1,
  legend_padding: 0,
  legend_item_tile_width: 10,
  legend_item_tile_height: 10,
  legend_usePoint: !1
});
// CONCATENATED MODULE: ./src/config/Options/common/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * point config options
 */
/* harmony default export */ var common_point = ({
  /**
   * Set point options
   * @name point
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [point.show=true] Whether to show each point in line.
   * @property {Number|Function} [point.r=2.5] The radius size of each point.
   *  - **NOTE:** Disabled for 'bubble' type
   * @property {Boolean} [point.focus.expand.enabled=true] Whether to expand each point on focus.
   * @property {Number} [point.focus.expand.r=point.r*1.75] The radius size of each point on focus.
   *  - **NOTE:** For 'bubble' type, the default is `bubbleSize*1.15`
   * @property {Number} [point.sensitivity=10] The senstivity value for interaction boundary.
   * @property {Number} [point.select.r=point.r*4] The radius size of each point on selected.
   * @property {String} [point.type="circle"] The type of point to be drawn
   * - **NOTE:**
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   * @property {Array} [point.pattern=[]] The type of point or svg shape as string, to be drawn for each line
   * - **NOTE:**
   *   - This is an `experimental` feature and can have some unexpected behaviors.
   *   - If chart has 'bubble' type, only circle can be used.
   *   - For IE, non circle point expansions are not supported due to lack of transform support.
   * - **Available Values:**
   *   - circle
   *   - rectangle
   *   - svg shape tag interpreted as string<br>
   *     (ex. `<polygon points='2.5 0 0 5 5 5'></polygon>`)
   * @see [Demo: point type](https://naver.github.io/billboard.js/demo/#Point.RectanglePoints)
   * @example
   *  point: {
   *      show: false,
   *      r: 5,
   *
   *      // or customize the radius
   *      r: function(d) {
   *          ...
   *          return r;
   *      },
   *
   *      focus: {
   *          expand: {
   *              enabled: true,
   *              r: 1
   *          }
   *      },
   *      select: {
   *          r: 3
   *      },
   *
   *      // having lower value, means how closer to be for interaction
   *      sensitivity: 3,
   *
   *      // valid values are "circle" or "rectangle"
   *      type: "rectangle",
   *
   *      // or indicate as pattern
   *      pattern: [
   *        "circle",
   *        "rectangle",
   *        "<polygon points='0 6 4 0 -4 0'></polygon>"
   *     ],
   *  }
   */
  point_show: !0,
  point_r: 2.5,
  point_sensitivity: 10,
  point_focus_expand_enabled: !0,
  point_focus_expand_r: undefined,
  point_pattern: [],
  point_select_r: undefined,
  point_type: "circle"
});
// CONCATENATED MODULE: ./src/config/Options/common/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var subchart = ({
  /**
   * Set subchart options
   * @name subchart
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [subchart.show=false] Show sub chart on the bottom of the chart.
   * @property {Boolean} [subchart.axis.x.show=true] Show or hide x axis.
   * @property {Boolean} [subchart.axis.x.tick.show=true] Show or hide x axis tick line.
   * @property {Boolean} [subchart.axis.x.tick.text.show=true] Show or hide x axis tick text.
   * @property {Number} [subchart.size.height] Change the height of the subchart.
   * @property {Function} [subchart.onbrush] Set callback for brush event.<br>
   *  Specified function receives the current zoomed x domain.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Interaction.SubChart)
   * @example
   *  subchart: {
   *      axis: {
   *      	x: {
   *      	  show: true,
   *      	    tick: {
   *      	      show: true,
   *      	      text: {
   *      	        show: false
   *      	      }
   *      	    }
   *      	}
   *      },
   *      show: true,
   *      size: {
   *          height: 20
   *      },
   *      onbrush: function(domain) { ... }
   *  }
   */
  subchart_show: !1,
  subchart_size_height: 60,
  subchart_axis_x_show: !0,
  subchart_axis_x_tick_show: !0,
  subchart_axis_x_tick_text_show: !0,
  subchart_onbrush: function subchart_onbrush() {}
});
// CONCATENATED MODULE: ./src/config/Options/common/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * title config options
 */
/* harmony default export */ var common_title = ({
  /**
   * Set title options
   * @name title
   * @memberof Options
   * @type {Object}
   * @property {String} [title.text] Title text. If contains `\n`, it's used as line break allowing multiline title.
   * @property {Number} [title.padding.top=0] Top padding value.
   * @property {Number} [title.padding.right=0] Right padding value.
   * @property {Number} [title.padding.bottom=0] Bottom padding value.
   * @property {Number} [title.padding.left=0] Left padding value.
   * @property {String} [title.position=center] Available values are: 'center', 'right' and 'left'.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Title.MultilinedTitle)
   * @example
   *  title: {
   *      text: "Title Text",
   *
   *      // or Multiline title text
   *      text: "Main title text\nSub title text",
   *
   *      padding: {
   *          top: 10,
   *          right: 10,
   *          bottom: 10,
   *          left: 10
   *      },
   *      position: "center"
   *  }
   */
  title_text: undefined,
  title_padding: {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  },
  title_position: "center"
});
// CONCATENATED MODULE: ./src/config/Options/common/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * tooltip config options
 */
/* harmony default export */ var common_tooltip = ({
  /**
   * Tooltip options
   * @name tooltip
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [tooltip.show=true] Show or hide tooltip.
   * @property {Boolean} [tooltip.doNotHide=false] Make tooltip keep showing not hiding on interaction.
   * @property {Boolean} [tooltip.grouped=true] Set if tooltip is grouped or not for the data points.
   *   - **NOTE:** The overlapped data points will be displayed as grouped even if set false.
   * @property {Boolean} [tooltip.linked=false] Set if tooltips on all visible charts with like x points are shown together when one is shown.
   * @property {String} [tooltip.linked.name=""] Groping name for linked tooltip.<br>If specified, linked tooltip will be groped interacting to be worked only with the same name.
   * @property {Function} [tooltip.format.title] Set format for the title of tooltip.<br>
   *  Specified function receives x of the data point to show.
   * @property {Function} [tooltip.format.name] Set format for the name of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   * @property {Function} [tooltip.format.value] Set format for the value of each data in tooltip.<br>
   *  Specified function receives name, ratio, id and index of the data point to show. ratio will be undefined if the chart is not donut/pie/gauge.
   *  If undefined returned, the row of that value will be skipped.
   * @property {Function} [tooltip.position] Set custom position for the tooltip.<br>
   *  This option can be used to modify the tooltip position by returning object that has top and left.
   * @property {Function|Object} [tooltip.contents] Set custom HTML for the tooltip.<br>
   *  Specified function receives data, defaultTitleFormat, defaultValueFormat and color of the data point to show. If tooltip.grouped is true, data includes multiple data points.
   * @property {String|HTMLElement} [tooltip.contents.bindto=undefined] Set CSS selector or element reference to bind tooltip.
   *  - **NOTE:** When is specified, will not be updating tooltip's position.
   * @property {String} [tooltip.contents.template=undefined] Set tooltip's template.<br><br>
   *  Within template, below syntax will be replaced using template-like syntax string:
   *    - **{{ ... }}**: the doubly curly brackets indicate loop block for data rows.
   *    - **{=CLASS_TOOLTIP}**: default tooltip class name `bb-tooltip`.
   *    - **{=CLASS_TOOLTIP_NAME}**: default tooltip data class name (ex. `bb-tooltip-name-data1`)
   *    - **{=TITLE}**: title value.
   *    - **{=COLOR}**: data color.
   *    - **{=VALUE}**: data value.
   * @property {Object} [tooltip.contents.text=undefined] Set additional text content within data loop, using template syntax.
   *  - **NOTE:** It should contain `{ key: Array, ... }` value
   *    - 'key' name is used as substitution within template as '{=KEY}'
   *    - The value array length should match with the data length
   * @property {Boolean} [tooltip.init.show=false] Show tooltip at the initialization.
   * @property {Number} [tooltip.init.x=0] Set x Axis index to be shown at the initialization.
   * @property {Object} [tooltip.init.position={top: "0px",left: "50px"}] Set the position of tooltip at the initialization.
   * @property {Function} [tooltip.onshow] Set a callback that will be invoked before the tooltip is shown.
   * @property {Function} [tooltip.onhide] Set a callback that will be invoked before the tooltip is hidden.
   * @property {Function} [tooltip.onshown] Set a callback that will be invoked after the tooltip is shown
   * @property {Function} [tooltip.onhidden] Set a callback that will be invoked after the tooltip is hidden.
   * @property {String|Function|null} [tooltip.order=null] Set tooltip data display order.<br><br>
   *  **Available Values:**
   *  - `desc`: In descending data value order
   *  - `asc`: In ascending data value order
   *  - `null`: It keeps the data display order<br>
   *     **NOTE:** When `data.groups` is set, the order will follow as the stacked graph order.<br>
   *      If want to order as data bound, set any value rather than asc, desc or null. (ex. empty string "")
   *  - `function(data1, data2) { ... }`: [Array.sort compareFunction](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)
   * @see [Demo: Hide Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.HideTooltip)
   * @see [Demo: Tooltip Grouping](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipGrouping)
   * @see [Demo: Tooltip Format](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipFormat)
   * @see [Demo: Linked Tooltip](https://naver.github.io/billboard.js/demo/#Tooltip.LinkedTooltips)
   * @see [Demo: Tooltip Template](https://naver.github.io/billboard.js/demo/#Tooltip.TooltipTemplate)
   * @example
   *  tooltip: {
   *      show: true,
   *      doNotHide: true,
   *      grouped: false,
   *      format: {
   *          title: function(x) { return "Data " + x; },
   *          name: function(name, ratio, id, index) { return name; },
   *          value: function(value, ratio, id, index) { return ratio; }
   *      },
   *      position: function(data, width, height, element) {
   *          return {top: 0, left: 0}
   *      },
   *
   *      contents: function(d, defaultTitleFormat, defaultValueFormat, color) {
   *          return ... // formatted html as you want
   *      },
   *
   *       // specify tooltip contents using template
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br><span style="color:#00c73c">data1</span></li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br><span style="color:#fa7171">data2</span></li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span><br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span></li>' +
   *      		'}}</ul>'
   *      }
   *
   *       // with additional text value
   *       // - example of HTML returned:
   *       // <ul class="bb-tooltip">
   *       //   <li class="bb-tooltip-name-data1"><span>250</span><br>comment1<span style="color:#00c73c">data1</span>text1</li>
   *       //   <li class="bb-tooltip-name-data2"><span>50</span><br>comment2<span style="color:#fa7171">data2</span>text2</li>
   *       // </ul>
   *       contents: {
   *      	bindto: "#tooltip",
   *      	text: {
   *      		// a) 'key' name is used as substitution within template as '{=KEY}'
   *      		// b) the length should match with the data length
   *      		VAR1: ["text1", "text2"],
   *      		VAR2: ["comment1", "comment2"],
   *      	},
   *      	template: '<ul class={=CLASS_TOOLTIP}>{{' +
   *      			'<li class="{=CLASS_TOOLTIP_NAME}"><span>{=VALUE}</span>{=VAR2}<br>' +
   *      			'<span style=color:{=COLOR}>{=NAME}</span>{=VAR1}</li>' +
   *      		'}}</ul>'
   *      }
   *
   *      // sort tooltip data value display in ascending order
   *      order: "asc",
   *
   *      // specifying sort function
   *      order: function(a, b) {
   *         // param data passed format
   *         {x: 5, value: 250, id: "data1", index: 5, name: "data1"}
   *           ...
   *      },
   *
   *      // show at the initialization
   *      init: {
   *          show: true,
   *          x: 2,
   *          position: {
   *              top: "150px",
   *              left: "250px"
   *          }
   *      },
   *
   *      // fires prior tooltip is shown
   *      onshow: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires prior tooltip is hidden
   *      onhide: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is shown
   *      onshown: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // fires after tooltip is hidden
   *      onhidden: function(ctx, selectedData) {
   *      	ctx; // current chart instance
   *
   *      	// current dataset selected
   *      	// ==> [{x: 4, value: 150, id: "data2", index: 4, name: "data2"}, ...]
   *      	selectedData;
   *      },
   *
   *      // Link any tooltips when multiple charts are on the screen where same x coordinates are available
   *      // Useful for timeseries correlation
   *      linked: true,
   *
   *      // Specify name to interact those with the same name only.
   *      linked: {
   *          name: "some-group"
   *      }
   *  }
   */
  tooltip_show: !0,
  tooltip_doNotHide: !1,
  tooltip_grouped: !0,
  tooltip_format_title: undefined,
  tooltip_format_name: undefined,
  tooltip_format_value: undefined,
  tooltip_position: undefined,
  tooltip_contents: {},
  tooltip_init_show: !1,
  tooltip_init_x: 0,
  tooltip_init_position: {
    top: "0px",
    left: "50px"
  },
  tooltip_linked: !1,
  tooltip_linked_name: "",
  tooltip_onshow: function tooltip_onshow() {},
  tooltip_onhide: function tooltip_onhide() {},
  tooltip_onshown: function tooltip_onshown() {},
  tooltip_onhidden: function tooltip_onhidden() {},
  tooltip_order: null
});
// CONCATENATED MODULE: ./src/config/Options/common/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * zoom config options
 */
/* harmony default export */ var common_zoom = ({
  /**
   * Set zoom options
   * @name zoom
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [zoom.enabled=false] Enable zooming.
   * @property {String} [zoom.enabled.type='wheel'] Set zoom interaction type.
   *  - **Available types:**
   *    - wheel
   *    - drag
   * @property {Boolean} [zoom.rescale=false] Enable to rescale after zooming.<br>
   *  If true set, y domain will be updated according to the zoomed region.
   * @property {Array} [zoom.extent=[1, 10]] Change zoom extent.
   * @property {Number|Date} [zoom.x.min] Set x Axis minimum zoom range
   * @property {Number|Date} [zoom.x.max] Set x Axis maximum zoom range
   * @property {Function} [zoom.onzoomstart=undefined] Set callback that is called when zooming starts.<br>
   *  Specified function receives the zoom event.
   * @property {Function} [zoom.onzoom=undefined] Set callback that is called when the chart is zooming.<br>
   *  Specified function receives the zoomed domain.
   * @property {Function} [zoom.onzoomend=undefined] Set callback that is called when zooming ends.<br>
   *  Specified function receives the zoomed domain.
   * @property {Boolean|Object} [zoom.resetButton=true] Set to display zoom reset button for 'drag' type zoom
   * @property {Function} [zoom.resetButton.onclick] Set callback when clicks the reset button. The callback will receive reset button element reference as argument.
   * @property {String} [zoom.resetButton.text='Reset Zoom'] Text value for zoom reset button.
   * @see [Demo:zoom](https://naver.github.io/billboard.js/demo/#Interaction.Zoom)
   * @see [Demo:drag zoom](https://naver.github.io/billboard.js/demo/#Interaction.DragZoom)
   * @example
   *  zoom: {
   *      enabled: {
   *          type: "drag"
   *      },
   *      rescale: true,
   *      extent: [1, 100]  // enable more zooming
   *      x: {
   *          min: -1,  // set min range
   *          max: 10  // set max range
   *      },
   *      onzoomstart: function(event) { ... },
   *      onzoom: function(domain) { ... },
   *      onzoomend: function(domain) { ... },
   *
   *      // show reset button when is zoomed-in
   *      resetButton: true,
   *
   *      resetButton: {
   *          // onclick callback when reset button is clicked
   *          onclick: function(button) {
   *            button; // Reset button element reference
   *            ...
   *          },
   *
   *          // customized text value for reset zoom button
   *          text: "Unzoom"
   *      }
   *  }
   */
  zoom_enabled: undefined,
  zoom_extent: undefined,
  zoom_privileged: !1,
  zoom_rescale: !1,
  zoom_onzoom: undefined,
  zoom_onzoomstart: undefined,
  zoom_onzoomend: undefined,
  zoom_resetButton: !0,
  zoom_x_min: undefined,
  zoom_x_max: undefined
});
// CONCATENATED MODULE: ./src/config/Options/shape/area.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * area config options
 */
/* harmony default export */ var shape_area = ({
  /**
   * Set area options
   * @name area
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [area.zerobased=true] Set if min or max value will be 0 on area chart.
   * @property {Boolean} [area.above=false] Set background area above the data chart line.
   * @property {Boolean|Object} [area.linearGradient=false] Set the linear gradient on area.<br><br>
   * Or customize by giving below object value:
   *  - x {Array}: `x1`, `x2` value
   *  - y {Array}: `y1`, `y2` value
   *  - stops {Array}: Each item should be having `[offset, stop-color, stop-opacity]` values.
   * @see [MDN's &lt;linearGradient>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/linearGradient), [&lt;stop>](https://developer.mozilla.org/en-US/docs/Web/SVG/Element/stop)
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.AreaChart)
   * @see [Demo: above](https://naver.github.io/billboard.js/demo/#AreaChartOptions.Above)
   * @see [Demo: linearGradient](https://naver.github.io/billboard.js/demo/#AreaChartOptions.LinearGradient)
   * @example
   *  area: {
   *      zerobased: false,
   *      above: true,
   *
   *      // will generate follwing linearGradient:
   *      // <linearGradient x1="0" x2="0" y1="0" y2="1">
   *      //    <stop offset="0" stop-color="$DATA_COLOR" stop-opacity="1"></stop>
   *      //    <stop offset="1" stop-color="$DATA_COLOR" stop-opacity="0"></stop>
   *      // </linearGradient>
   *      linearGradient: true,
   *
   *      // Or customized gradient
   *      linearGradient: {
   *      	x: [0, 0],  // x1, x2 attributes
   *      	y: [0, 0],  // y1, y2 attributes
   *      	stops: [
   *      	  // offset, stop-color, stop-opacity
   *      	  [0, "#7cb5ec", 1],
   *
   *      	  // setting 'null' for stop-color, will set its original data color
   *      	  [0.5, null, 0],
   *
   *      	  // setting 'function' for stop-color, will pass data id as argument.
   *      	  // It should return color string or null value
   *      	  [1, function(id) { return id === "data1" ? "red" : "blue"; }, 0],
   *      	]
   *      }
   *  }
   */
  area_zerobased: !0,
  area_above: !1,
  area_linearGradient: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bar config options
 */
/* harmony default export */ var shape_bar = ({
  /**
   * Set bar options
   * @name bar
   * @memberof Options
   * @type {Object}
   * @property {Number} [bar.padding=0] The padding pixel value between each bar.
   * @property {Number} [bar.radius] Set the radius of bar edge in pixel.
   * - **NOTE:** Works only for non-stacked bar
   * @property {Number} [bar.radius.ratio] Set the radius ratio of bar edge in relative the bar's width.
   * @property {Number} [bar.sensitivity=2] The senstivity offset value for interaction boundary.
   * @property {Number} [bar.width] Change the width of bar chart.
   * @property {Number} [bar.width.ratio=0.6] Change the width of bar chart by ratio.
   * @property {Number} [bar.width.max] The maximum width value for ratio.
   * @property {Number} [bar.width.dataname] Change the width of bar for indicated dataset only.
   * - **NOTE:**
   *   - Works only for non-stacked bar
   *   - Bars are centered accoding its total width value
   * @property {Number} [bar.width.dataname.ratio=0.6] Change the width of bar chart by ratio.
   * @property {Number} [bar.width.dataname.max] The maximum width value for ratio.
   * @property {Boolean} [bar.zerobased=true] Set if min or max value will be 0 on bar chart.
   * @see [Demo: bar padding](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarPadding)
   * @see [Demo: bar radius](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarRadius)
   * @see [Demo: bar width](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidth)
   * @see [Demo: bar width variant](https://naver.github.io/billboard.js/demo/#BarChartOptions.BarWidthVariant)
   * @example
   *  bar: {
   *      padding: 1,
   *
   *      // the 'radius' option can be used only for non-stacking bars
   *      radius: 10,
   *      // or
   *      radius: {
   *          ratio: 0.5
   *      }
   *
   *      // will not have offset between each bar elements for interaction
   *      sensitivity: 0,
   *
   *      width: 10,
   *
   *      // or
   *      width: {
   *          ratio: 0.2,
   *          max: 20
   *      },
   *
   *      // or specify width per dataset
   *      width: {
   *          data1: 20,
   *          data2: {
   *              ratio: 0.2,
   *              max: 20
   *          }
   *      },
   *
   *      zerobased: false
   *  }
   */
  bar_padding: 0,
  bar_radius: undefined,
  bar_radius_ratio: undefined,
  bar_sensitivity: 2,
  bar_width: undefined,
  bar_width_ratio: .6,
  bar_width_max: undefined,
  bar_zerobased: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * bubble config options
 */
/* harmony default export */ var bubble = ({
  /**
   * Set bubble options
   * @name bubble
   * @memberof Options
   * @type {Object}
   * @property {Number|Function} [bubble.maxR=35] Set the max bubble radius value
   * @property {Boolean} [bubble.zerobased=false] Set if min or max value will be 0 on bubble chart.
   * @example
   *  bubble: {
   *      // ex) If 100 is the highest value among data bound, the representation bubble of 100 will have radius of 50.
   *      // And the lesser will have radius relatively from tha max value.
   *      maxR: 50,
   *
   *      // or set radius callback
   *      maxR: function(d) {
   *          // ex. of d param - {x: Fri Oct 06 2017 00:00:00 GMT+0900, value: 80, id: "data2", index: 5}
   *          ...
   *          return Math.sqrt(d.value * 2);
   *      },
   *      zerobased: false
   *  }
   */
  bubble_maxR: 35,
  bubble_zerobased: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/donut.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * donut config options
 */
/* harmony default export */ var donut = ({
  /**
   * Set donut options
   * @name donut
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [donut.label.show=true] Show or hide label on each donut piece.
   * @property {Function} [donut.label.format] Set formatter for the label on each donut piece.
   * @property {Number} [donut.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {Number|Function} [donut.label.ratio=undefined] Set ratio of labels position.
   * @property {Boolean} [donut.expand=true] Enable or disable expanding donut pieces.
   * @property {Number} [donut.expand.rate=0.98] Set expand rate.
   * @property {Number} [donut.expand.duration=50] Set expand transition time in ms.
   * @property {Number} [donut.width] Set width of donut chart.
   * @property {String} [donut.title=""] Set title of donut chart. Use `\n` character to enter line break.
   * @property {Number} [donut.padAngle=0] Set padding between data.
   * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  donut: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *          	...
   *          	return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      width: 10,
   *      padAngle: 0.2,
   *      startingAngle: 1,
   *      title: "Donut Title"
   *
   *      // title with line break
   *      title: "Title1\nTitle2"
   *  }
   */
  donut_label_show: !0,
  donut_label_format: undefined,
  donut_label_threshold: .05,
  donut_label_ratio: undefined,
  donut_width: undefined,
  donut_title: "",
  donut_expand: {},
  donut_expand_rate: .98,
  donut_expand_duration: 50,
  donut_padAngle: 0,
  donut_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/gauge.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * gauge config options
 */
/* harmony default export */ var gauge = ({
  /**
   * Set gauge options
   * @name gauge
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [gauge.fullCircle=false] Show full circle as donut. When set to 'true', the max label will not be showed due to start and end points are same location.
   * @property {Boolean} [gauge.label.show=true] Show or hide label on gauge.
   * @property {Function} [gauge.label.format] Set formatter for the label on gauge. Label text can be multilined with `\n` character.
   * @property {Function} [gauge.label.extents] Set customized min/max label text.
   * @property {Boolean} [gauge.expand=true] Enable or disable expanding gauge.
   * @property {Number} [gauge.expand.rate=0.98] Set expand rate.
   * @property {Number} [gauge.expand.duration=50] Set the expand transition time in milliseconds.
   * @property {Number} [gauge.min=0] Set min value of the gauge.
   * @property {Number} [gauge.max=100] Set max value of the gauge.
   * @property {Number} [gauge.startingAngle=-1 * Math.PI / 2] Set starting angle where data draws.
   * @property {String} [gauge.title=""] Set title of gauge chart. Use `\n` character to enter line break.
   * @property {String} [gauge.units] Set units of the gauge.
   * @property {Number} [gauge.width] Set width of gauge chart.
   * @property {String} [gauge.type="single"] Set type of gauge to be displayed.<br><br>
   * **Available Values:**
   * - single
   * - multi
   * @property {String} [gauge.arcs.minWidth=5] Set minimal width of gauge arcs until the innerRadius disappears.
   * @example
   *  gauge: {
   *      fullCircle: false,
   *      label: {
   *          show: false,
   *          format: function(value, ratio) {
   *              return value;
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          extents: function(value, isMax) {
   *              return (isMax ? "Max:" : "Min:") + value;
   *          }
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      min: -100,
   *      max: 200,
   *      type: "single"  // or 'multi'
   *      title: "Title Text",
   *      units: "%",
   *      width: 10,
   *      arcs: {
   *          minWidth: 5
   *      }
   *  }
   */
  gauge_fullCircle: !1,
  gauge_label_show: !0,
  gauge_label_format: undefined,
  gauge_min: 0,
  gauge_max: 100,
  gauge_type: "single",
  gauge_startingAngle: -1 * Math.PI / 2,
  gauge_label_extents: undefined,
  gauge_title: "",
  gauge_units: undefined,
  gauge_width: undefined,
  gauge_arcs_minWidth: 5,
  gauge_expand: {},
  gauge_expand_rate: .98,
  gauge_expand_duration: 50
});
// CONCATENATED MODULE: ./src/config/Options/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * line config options
 */
/* harmony default export */ var shape_line = ({
  /**
   * Set line options
   * @name line
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [line.connectNull=false] Set if null data point will be connected or not.<br>
   *  If true set, the region of null data will be connected without any data point. If false set, the region of null data will not be connected and get empty.
   * @property {Array}   [line.classes=undefined] If set, used to set a css class on each line.
   * @property {Boolean} [line.step.type=step] Change step type for step chart.<br>
   * **Available values:**
   * - step
   * - step-before
   * - step-after
   * @property {Boolean|Array} [line.point=true] Set to false to not draw points on linecharts. Or pass an array of line ids to draw points for.
   * @property {Boolean} [line.zerobased=false] Set if min or max value will be 0 on line chart.
   * @example
   *  line: {
   *      connectNull: true,
   *      classes: [
   *          "line-class1",
   *          "line-class2"
   *      ],
   *      step: {
   *          type: "step-after"
   *      },
   *
   *      // hide all data points ('point.show=false' also has similar effect)
   *      point: false,
   *
   *      // show data points for only indicated datas
   *      point: [
   *          "data1", "data3"
   *      ],
   *
   *      zerobased: false
   *  }
   */
  line_connectNull: !1,
  line_step_type: "step",
  line_zerobased: !1,
  line_classes: undefined,
  line_point: !0
});
// CONCATENATED MODULE: ./src/config/Options/shape/pie.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var pie = ({
  /**
   * Set pie options
   * @name pie
   * @memberof Options
   * @type {Object}
   * @property {Boolean} [pie.label.show=true] Show or hide label on each pie piece.
   * @property {Function} [pie.label.format] Set formatter for the label on each pie piece.
   * @property {Number} [pie.label.threshold=0.05] Set threshold to show/hide labels.
   * @property {Number|Function} [pie.label.ratio=undefined] Set ratio of labels position.
   * @property {Boolean|Object} [pie.expand=true] Enable or disable expanding pie pieces.
   * @property {Number} [pie.expand.rate=0.98] Set expand rate.
   * @property {Number} [pie.expand.duration=50] Set expand transition time in ms.
   * @property {Number|Object} [pie.innerRadius=0] Sets the inner radius of pie arc.
   * @property {Number} [pie.padAngle=0] Set padding between data.
   * @property {Number} [pie.padding=0] Sets the gap between pie arcs.
   * @property {Number} [donut.startingAngle=0] Set starting angle where data draws.
   * @example
   *  pie: {
   *      label: {
   *          show: false,
   *          format: function(value, ratio, id) {
   *              return d3.format("$")(value);
   *
   *              // to multiline, return with '\n' character
   *              // return value +"%\nLine1\n2Line2";
   *          },
   *          threshold: 0.1,
   *
   *          // set ratio callback. Should return ratio value
   *          ratio: function(d, radius, h) {
   *              ...
   *              return ratio;
   *          },
   *          // or set ratio number
   *          ratio: 0.5
   *      },
   *
   *      // disable expand transition for interaction
   *      expand: false,
   *
   *      expand: {
   *      	// set duration of expand transition to 500ms.
   *          duration: 500,
   *
   *      	// set expand area rate
   *          rate: 1
   *      },
   *
   *      innerRadius: 0,
   *
   *      // set different innerRadius for each data
   *      innerRadius: {
   *      	data1: 10,
   *      	data2: 0
   *      }
   *
   *      padAngle: 0.1,
   *      padding: 0,
   *      startingAngle: 1
   *  }
   */
  pie_label_show: !0,
  pie_label_format: undefined,
  pie_label_threshold: .05,
  pie_label_ratio: undefined,
  pie_expand: {},
  pie_expand_rate: .98,
  pie_expand_duration: 50,
  pie_innerRadius: 0,
  pie_padAngle: 0,
  pie_padding: 0,
  pie_startingAngle: 0
});
// CONCATENATED MODULE: ./src/config/Options/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var radar = ({
  /**
   * Set radar options
   * - **NOTE:**
   *  > When x tick text contains `\n`, it's used as line break.
   * @name radar
   * @memberof Options
   * @type {Object}
   * @property {Number} [radar.axis.max=undefined] The max value of axis. If not given, it'll take the max value from the given data.
   * @property {Boolean} [radar.axis.line.show=true] Show or hide axis line.
   * @property {Number} [radar.axis.text.position.x=0] x coordinate position, relative the original.
   * @property {NUmber} [radar.axis.text.position.y=0] y coordinate position, relative the original.
   * @property {Boolean} [radar.axis.text.show=true] Show or hide axis text.
   * @property {Boolean} [radar.direction.clockwise=false] Set the direction to be drawn.
   * @property {Number} [radar.level.depth=3] Set the level depth.
   * @property {Boolean} [radar.level.show=true] Show or hide level.
   * @property {Function} [radar.level.text.format=(x) => (x % 1 === 0 ? x : x.toFixed(2))] Set format function for the level value.
   * @property {Boolean} [radar.level.text.show=true] Show or hide level text.
   * @property {Number} [radar.size.ratio=0.87] Set size ratio.
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Chart.RadarChart)
   * @see [Demo: radar axis](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxis)
   * @see [Demo: radar level](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarLevel)
   * @see [Demo: radar size](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarSize)
   * @see [Demo: radar axis multiline](https://naver.github.io/billboard.js/demo/#RadarChartOptions.RadarAxisMultiline)
   * @example
   *  radar: {
   *      axis: {
   *          max: 50,
   *          line: {
   *              show: false
   *          },
   *          text: {
   *              position: {
   *              	x: 0,
   *              	y: 0
   *              },
   *              show: false
   *          }
   *      },
   *      direction: {
   *          clockwise: true
   *      },
   *      level: {
   *          show: false,
   *          text: {
   *              format: function(x) {
   *                  return x + "%";
   *              },
   *              show: true
   *          }
   *      },
   *      size: {
   *          ratio: 0.7
   *      }
   *  }
   */
  radar_axis_max: undefined,
  radar_axis_line_show: !0,
  radar_axis_text_show: !0,
  radar_axis_text_position: {},
  radar_level_depth: 3,
  radar_level_show: !0,
  radar_level_text_format: function radar_level_text_format(x) {
    return x % 1 === 0 ? x : x.toFixed(2);
  },
  radar_level_text_show: !0,
  radar_size_ratio: .87,
  radar_direction_clockwise: !1
});
// CONCATENATED MODULE: ./src/config/Options/shape/spline.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * x Axis config options
 */
/* harmony default export */ var spline = ({
  /**
   * Set spline options
   * - **Available interpolation type values:**
   *  - basis (d3.curveBasis)
   *  - basis-closed (d3.curveBasisClosed)
   *  - basis-open (d3.curveBasisOpen)
   *  - bundle (d3.curveBundle)
   *  - cardinal (d3.curveCardinal)
   *  - cardinal-closed (d3.curveCardinalClosed)
   *  - cardinal-open (d3.curveCardinalOpen)
   *  - catmull-rom (d3.curveCatmullRom)
   *  - catmull-rom-closed (d3.curveCatmullRomClosed)
   *  - catmull-rom-open (d3.curveCatmullRomOpen)
   *  - monotone-x (d3.curveMonotoneX)
   *  - monotone-y (d3.curveMonotoneY)
   *  - natural (d3.curveNatural)
   *  - linear-closed (d3.curveLinearClosed)
   *  - linear (d3.curveLinear)
   *  - step (d3.curveStep)
   *  - step-after (d3.curveStepAfter)
   *  - step-before (d3.curveStepBefore)
   * @name spline
   * @memberof Options
   * @type {Object}
   * @property {String} [spline.interpolation.type="cardinal"]
   * @see [Interpolation (d3 v4)](http://bl.ocks.org/emmasaunders/c25a147970def2b02d8c7c2719dc7502)
   * @example
   *  spline: {
   *      interpolation: {
   *          type: "cardinal"
   *      }
   *  }
   */
  spline_interpolation_type: "cardinal"
});
// CONCATENATED MODULE: ./src/config/Options/Options.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

 // common









 // shape











/**
 * Class to set options on generating chart.
 * - It's instantiated internally, not exposed for public.
 * @class Options
 * @see {@link bb.generate} to use these options on generating the chart
 */

var Options = function () {
  var commonConfig = mergeObj({}, data_data, axis_axis, common_color, common_grid, interaction, common_legend, common_point, subchart, common_title, common_tooltip, common_zoom),
      shapeConfig = mergeObj({}, shape_area, shape_bar, bubble, donut, gauge, shape_line, pie, radar, spline);
  return mergeObj({
    /**
     * Specify the CSS selector or the element which the chart will be set to. D3 selection object can be specified also.<br>
     * If other chart is set already, it will be replaced with the new one (only one chart can be set in one element).
     * - **NOTE:** In case of element doesn't exist or not specified, will add a `<div>` element to the body.
     * @name bindto
     * @memberof Options
     * @property {String|HTMLElement|d3.selection} bindto=#chart Specify the element where chart will be drawn.
     * @property {String|HTMLElement|d3.selection} bindto.element=#chart Specify the element where chart will be drawn.
     * @property {String} [bindto.classname=bb] Specify the class name of bind element.<br>
     *     **NOTE:** When class name isn't `bb`, then you also need to update the default CSS to be rendered correctly.
     * @default #chart
     * @example
     * bindto: "#myContainer"
     *
     * // or HTMLElement
     * bindto: document.getElementById("myContainer")
     *
     * // or D3 selection object
     * bindto: d3.select("#myContainer")
     *
     * // or to change default classname
     * bindto: {
     *    element: "#chart",
     *    classname: "bill-board"  // ex) <div id='chart' class='bill-board'>
     * }
     */
    bindto: "#chart",

    /**
     * Set chart background.
     * @name background
     * @memberof Options
     * @property {String} background.class Specify the class name for background element.
     * @property {String} background.color Specify the fill color for background element.<br>**NOTE:** Will be ignored if `imgUrl` option is set.
     * @property {String} background.imgUrl Specify the image url string for background.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.Background)
     * @example
     * background: {
     *    class: "myClass",
     *    color: "red",
     *
     *    // Set image url for background.
     *    // If specified, 'color' option will be ignored.
     *    imgUrl: "https://naver.github.io/billboard.js/img/logo/billboard.js.svg",
     * }
     */
    background: {},

    /**
     * Set 'clip-path' attribute for chart element
     * - **NOTE:**
     *  > When is false, chart node element is positioned after the axis node in DOM tree hierarchy.
     *  > Is to make chart element positioned over axis element.
     * @name clipPath
     * @memberof Options
     * @type {Boolean}
     * @default true
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.clipPath)
     * @example
     * // don't set 'clip-path' attribute
     * clipPath: false
     */
    clipPath: !0,

    /**
     * Set svg element's class name
     * @name svg
     * @memberof Options
     * @type {Object}
     * @property {String} [svg.classname] class name for svg element
     * @example
     * svg: {
              *   classname: "test_class"
     * }
     */
    svg_classname: undefined,

    /**
     * The desired size of the chart element.
     * If value is not specified, the width of the chart will be calculated by the size of the parent element it's appended to.
     * @name size
     * @memberof Options
     * @type {Object}
     * @property {Number} [size.width] width of the chart element
     * @property {Number} [size.height] height of the chart element
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.ChartSize)
     * @example
     * size: {
              *   width: 640,
              *   height: 480
     * }
     */
    size_width: undefined,
    size_height: undefined,

    /**
     * The padding of the chart element.
     * @name padding
     * @memberof Options
     * @type {Object}
     * @property {Number} [padding.top] padding on the top of chart
     * @property {Number} [padding.right] padding on the right of chart
     * @property {Number} [padding.bottom] padding on the bottom of chart
     * @property {Number} [padding.left] padding on the left of chart
     * @example
     * padding: {
              *   top: 20,
              *   right: 20,
              *   bottom: 20,
              *   left: 20
     * }
     */
    padding_left: undefined,
    padding_right: undefined,
    padding_top: undefined,
    padding_bottom: undefined,

    /**
     * Set chart resize options
     * @name resize
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [resize.auto=true] Set chart resize automatically on viewport changes.
     * @example
     *  resize: {
     *      auto: false
     *  }
     */
    resize_auto: !0,

    /**
     * Set a callback to execute when mouse/touch enters the chart.
     * @name onover
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onover: function(ctx) {
     *   ...
     * }
     */
    onover: undefined,

    /**
     * Set a callback to execute when mouse/touch leaves the chart.
     * @name onout
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onout: function(ctx) {
     *   ...
     * }
     */
    onout: undefined,

    /**
     * Set a callback to execute when user resizes the screen.
     * @name onresize
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresize: function(ctx) {
     *   ...
     * }
     */
    onresize: undefined,

    /**
     * Set a callback to execute when screen resize finished.
     * @name onresized
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onresized: function(ctx) {
     *   ...
     * }
     */
    onresized: undefined,

    /**
     * Set a callback to execute before the chart is initialized
     * @name onbeforeinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onbeforeinit: function(ctx) {
     *   ...
     * }
     */
    onbeforeinit: undefined,

    /**
     * Set a callback to execute when the chart is initialized.
     * @name oninit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * oninit: function(ctx) {
     *   ...
     * }
     */
    oninit: undefined,

    /**
     * Set a callback to execute after the chart is initialized
     * @name onafterinit
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onafterinit: function(ctx) {
     *   ...
     * }
     */
    onafterinit: undefined,

    /**
     * Set a callback which is executed when the chart is rendered. Basically, this callback will be called in each time when the chart is redrawed.
     * @name onrendered
     * @memberof Options
     * @type {Function}
     * @default undefined
     * @example
     * // @param {Chart} ctx - Instance itself
     * onrendered: function(ctx) {
     *   ...
     * }
     */
    onrendered: undefined,

    /**
     * Set duration of transition (in milliseconds) for chart animation.<br><br>
     * - **NOTE:** If `0 `or `null` set, transition will be skipped. So, this makes initial rendering faster especially in case you have a lot of data.
     * @name transition
     * @memberof Options
     * @type {Object}
     * @property {Number} [transition.duration=350] duration in milliseconds
     * @example
     * transition: {
     *    duration: 500
     * }
     */
    transition_duration: 350,

    /**
    	* Set scatter options
    	* @name scatter
    	* @memberof Options
    	* @type {Object}
    	* @property {Boolean} [scatter.zerobased=false] Set if min or max value will be 0 on scatter chart.
    	* @example
    	*  scatter: {
    	*      connectNull: true,
    	*      step: {
    	*          type: "step-after"
    	*      },
    	*
    	*      // hide all data points ('point.show=false' also has similar effect)
    	*      point: false,
    	*
    	*      // show data points for only indicated datas
    	*      point: [
    	*          "data1", "data3"
    	*      ],
    	*
    	*      zerobased: false
    	*  }
    	*/
    scatter_zerobased: !1,

    /**
     * Set plugins
     * @name plugins
     * @memberof Options
     * @type {Array}
     * @example
     *  plugins: [
     *    new bb.plugin.stanford({ ... }),
     *    new PluginA(),
     *    ...
     * ]
     */
    plugins: [],

    /**
     * Control the render timing
     * @name render
     * @memberof Options
     * @type {Object}
     * @property {Boolean} [render.lazy=true] Make to not render at initialization (enabled by default when bind element's visibility is hidden).
     * @property {Boolean} [render.observe=true] Observe bind element's visibility(`display` or `visiblity` inline css property or class value) & render when is visible automatically (for IEs, only works IE11+). When set to **false**, call [`.flush()`](./Chart.html#flush) to render.
     * @see [Demo](https://naver.github.io/billboard.js/demo/#ChartOptions.LazyRender)
     * @example
     *  render: {
     *    lazy: true,
     *    observe: true
     * }
     *
     * @example
     *	// <!-- render.lazy will detect visibility defined -->
     *  // (a) <div id='chart' class='hide'></div>
     *  // (b) <div id='chart' style='display:none'></div>
     *
     *  // render.lazy enabled by default when element is hidden
     *  var chart = bb.generate({ ... });
     *
     *  // chart will be rendered automatically when element's visibility changes
     *  // Note: works only for inlined css property or class attribute changes
     *  document.getElementById('chart').classList.remove('hide')  // (a)
     *  document.getElementById('chart').style.display = 'block';  // (b)
     *
     * @example
     *	// chart won't be rendered and not observing bind element's visiblity changes
     *  var chart = bb.generate({
     *     render: {
     *          lazy: true,
     *          observe: false
     *     }
     *  });
     *
     *  // call at any point when you want to render
     *  chart.flush();
     */
    render: {},

    /**
     * Show rectangles inside the chart.<br><br>
     * This option accepts array including object that has axis, start, end and class.
     * The keys start, end and class are optional.
     * axis must be x, y or y2. start and end should be the value where regions start and end.
     * If not specified, the edge values will be used.
     * If timeseries x axis, date string, Date object and unixtime integer can be used.
     * If class is set, the region element will have it as class.
     * @name regions
     * @memberof Options
     * @type {Array}
     * @default []
     * @example
     *  regions: [
     *    {
     *      axis: "x",
     *      start: 1,
     *      end: 4,
     *      class: "region-1-4"
     *    }
     *  ]
     */
    regions: []
  }, commonConfig, shapeConfig);
};


// CONCATENATED MODULE: ./src/module/Cache.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


var Cache_Cache =
/*#__PURE__*/
function () {
  function Cache() {
    _defineProperty(this, "cache", {});
  }

  var _proto = Cache.prototype;
  return _proto.add =
  /**
   * Add cache
   * @param {String} key
   * @param {*} value
   * @param {Boolean} isDataType
   * @private
   */
  function add(key, value, isDataType) {
    isDataType === void 0 && (isDataType = !1), this.cache[key] = isDataType ? this.cloneTarget(value) : value;
  }
  /**
   * Remove cache
   * @param {String|Array} key
   * @private
   */
  , _proto.remove = function remove(key) {
    var _this = this;

    toArray(key).forEach(function (v) {
      return delete _this.cache[v];
    });
  }
  /**
   * Get cahce
   * @param {String|Array} key
   * @param {Boolean} isDataType
   * @return {*}
   * @private
   */
  , _proto.get = function get(key, isDataType) {
    if (isDataType === void 0 && (isDataType = !1), isDataType) {
      for (var id, targets = [], i = 0; id = key[i]; i++) id in this.cache && targets.push(this.cloneTarget(this.cache[id]));

      return targets;
    }

    return this.cache[key] || null;
  }
  /**
   * reset cached data
   * @param {Boolean} all true: reset all data, false: reset only '$' prefixed key data
   * @private
  	 */
  , _proto.reset = function reset(all) {
    var $$ = this;

    for (var x in $$.cache) (all || /^\$/.test(x)) && ($$.cache[x] = null);
  }, _proto.cloneTarget = function cloneTarget(target) {
    return {
      id: target.id,
      id_org: target.id_org,
      values: target.values.map(function (d) {
        return {
          x: d.x,
          value: d.value,
          id: d.id
        };
      })
    };
  }, Cache;
}();


// EXTERNAL MODULE: external {"commonjs":"d3-axis","commonjs2":"d3-axis","amd":"d3-axis","root":"d3"}
var external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_ = __webpack_require__(40);

// EXTERNAL MODULE: external {"commonjs":"d3-scale","commonjs2":"d3-scale","amd":"d3-scale","root":"d3"}
var external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_ = __webpack_require__(41);

// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRendererHelper.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */



var AxisRendererHelper_AxisRendererHelper =
/*#__PURE__*/
function () {
  function AxisRendererHelper(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "scale", void 0);
    var scale = Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])(),
        config = owner.config,
        params = owner.params;
    this.owner = owner, this.config = config, this.scale = scale, (config.noTransition || !params.config.transition_duration) && (config.withoutTransition = !0), config.range = this.scaleExtent((params.orgXScale || scale).range());
  }
  /**
   * Compute a character dimension
   * @param {d3.selection} node
   * @return {{w: number, h: number}}
   * @private
   */


  AxisRendererHelper.getSizeFor1Char = function getSizeFor1Char(node) {
    // default size for one character
    var size = {
      w: 5.5,
      h: 11.5
    };
    return node.empty() || node.select("text").text("0").call(function (el) {
      try {
        var _el$node$getBBox = el.node().getBBox(),
            width = _el$node$getBBox.width,
            height = _el$node$getBBox.height;

        width && height && (size.w = width, size.h = height), el.text("");
      } catch (e) {}
    }), this.getSizeFor1Char = function () {
      return size;
    }, size;
  };

  var _proto = AxisRendererHelper.prototype;
  return _proto.axisX = function axisX(selection, x) {
    var _this = this;

    selection.attr("transform", function (d) {
      return "translate(" + Math.ceil(x(d) + _this.config.tickOffset) + ",0)";
    });
  }, _proto.axisY = function axisY(selection, y) {
    selection.attr("transform", function (d) {
      return "translate(0," + Math.ceil(y(d)) + ")";
    });
  }, _proto.scaleExtent = function scaleExtent(domain) {
    var start = domain[0],
        stop = domain[domain.length - 1];
    return start < stop ? [start, stop] : [stop, start];
  }, _proto.generateTicks = function generateTicks(scale, isYAxes) {
    var tickStepSize = this.owner.params.tickStepSize,
        ticks = [];
    // When 'axis[y|y2].tick.stepSize' option is set
    if (isYAxes && tickStepSize) for (var _scale$domain = scale.domain(), start = _scale$domain[0], end = _scale$domain[1], interval = start; interval <= end;) ticks.push(interval), interval += tickStepSize;else if (scale.ticks) ticks = scale.ticks.apply(scale, this.config.tickArguments || []).map(function (v) {
      return (// round the tick value if is number
        isString(v) && isNumber(v) && !isNaN(v) && Math.round(v * 10) / 10 || v
      );
    });else {
      for (var domain = scale.domain(), i = Math.ceil(domain[0]); i < domain[1]; i++) ticks.push(i);

      ticks.length > 0 && ticks[0] > 0 && ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));
    }
    return ticks;
  }, _proto.copyScale = function copyScale() {
    var newScale = this.scale.copy();
    return newScale.domain().length || newScale.domain(this.scale.domain()), newScale;
  }, _proto.textFormatted = function textFormatted(v) {
    var tickFormat = this.config.tickFormat,
        value = /\d+\.\d+0{5,}\d$/.test(v) ? +(v + "").replace(/0+\d$/, "") : v,
        formatted = tickFormat ? tickFormat(value) : value; // to round float numbers from 'binary floating point'
    // https://en.wikipedia.org/wiki/Double-precision_floating-point_format
    // https://stackoverflow.com/questions/17849101/laymans-explanation-for-why-javascript-has-weird-floating-math-ieee-754-stand

    return isDefined(formatted) ? formatted : "";
  }, _proto.transitionise = function transitionise(selection) {
    var config = this.config;
    return config.withoutTransition ? selection.interrupt() : selection.transition(config.transition);
  }, AxisRendererHelper;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/AxisRenderer.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */




var AxisRenderer_AxisRenderer =
/*#__PURE__*/
function () {
  function AxisRenderer(params) {
    params === void 0 && (params = {}), _defineProperty(this, "helper", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "params", void 0), _defineProperty(this, "g", void 0);
    var config = {
      innerTickSize: 6,
      outerTickSize: params.outerTick ? 6 : 0,
      orient: "bottom",
      range: [],
      tickArguments: null,
      tickCentered: null,
      tickCulling: !0,
      tickFormat: null,
      tickLength: 9,
      tickOffset: 0,
      tickPadding: 3,
      tickValues: null,
      transition: null,
      noTransition: params.noTransition
    };
    config.tickLength = Math.max(config.innerTickSize, 0) + config.tickPadding, this.config = config, this.params = params, this.helper = new AxisRendererHelper_AxisRendererHelper(this);
  }
  /**
   * Create axis element
   * @param {d3.selection} g
   * @private
   */


  var _proto = AxisRenderer.prototype;
  return _proto.create = function create(g) {
    var ctx = this,
        config = this.config,
        params = this.params,
        helperInst = this.helper,
        scale = helperInst.scale,
        orient = config.orient,
        splitTickText = this.splitTickText.bind(this),
        isLeftRight = /^(left|right)$/.test(orient),
        isTopBottom = /^(top|bottom)$/.test(orient),
        tickTransform = helperInst[isTopBottom ? "axisX" : "axisY"],
        axisPx = tickTransform === helperInst.axisX ? "y" : "x",
        sign = /^(top|left)$/.test(orient) ? -1 : 1,
        rotate = params.tickTextRotate;
    this.config.range = scale.rangeExtent ? scale.rangeExtent() : helperInst.scaleExtent((params.orgXScale || scale).range());
    var $g,
        _config = config,
        innerTickSize = _config.innerTickSize,
        tickLength = _config.tickLength,
        range = _config.range,
        name = params.name,
        tickTextPos = name && /^(x|y|y2)$/.test(name) ? params.config["axis_" + name + "_tick_text_position"] : {
      x: 0,
      y: 0
    },
        prefix = name === "subX" ? "subchart_axis_x" : "axis_" + name,
        axisShow = params.config[prefix + "_show"],
        tickShow = {
      tick: !!axisShow && params.config[prefix + "_tick_show"],
      text: !!axisShow && params.config[prefix + "_tick_text_show"]
    }; // // get the axis' tick position configuration

    g.each(function () {
      var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          scale0 = this.__chart__ || scale,
          scale1 = helperInst.copyScale();
      $g = g, this.__chart__ = scale1, config.tickOffset = params.isCategory ? Math.ceil((scale1(1) - scale1(0)) / 2) : 0;
      // update selection - data join
      var path = g.selectAll(".domain").data([0]); // enter + update selection

      if (path.enter().append("path").attr("class", "domain").merge(helperInst.transitionise(path)).attr("d", function () {
        var outerTickSized = config.outerTickSize * sign;
        return isTopBottom ? "M" + range[0] + "," + outerTickSized + "V0H" + range[1] + "V" + outerTickSized : "M" + outerTickSized + "," + range[0] + "H0V" + range[1] + "H" + outerTickSized;
      }), tickShow.tick || tickShow.text) {
        // count of tick data in array
        var ticks = config.tickValues || helperInst.generateTicks(scale1, isLeftRight),
            tick = g.selectAll(".tick").data(ticks, scale1),
            tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", "1"),
            tickExit = tick.exit().remove(); // update selection

        tick = tickEnter.merge(tick), tickShow.tick && tickEnter.append("line"), tickShow.text && tickEnter.append("text");
        var sizeFor1Char = AxisRendererHelper_AxisRendererHelper.getSizeFor1Char(tick),
            counts = [],
            tspan = tick.select("text").selectAll("tspan").data(function (d, index) {
          var split = params.tickMultiline ? splitTickText(d, scale1, ticks, isLeftRight, sizeFor1Char.w) : isArray(helperInst.textFormatted(d)) ? helperInst.textFormatted(d).concat() : [helperInst.textFormatted(d)];
          return counts[index] = split.length, split.map(function (splitted) {
            return {
              index: index,
              splitted: splitted
            };
          });
        });
        tspan.exit().remove(), tspan = tspan.enter().append("tspan").merge(tspan).text(function (d) {
          return d.splitted;
        }), tspan.attr("x", isTopBottom ? 0 : tickLength * sign).attr("dx", function () {
          var dx = 0;
          return /(top|bottom)/.test(orient) && rotate && (dx = 8 * Math.sin(Math.PI * (rotate / 180)) * (orient === "top" ? -1 : 1)), dx + (tickTextPos.x || 0);
        }()).attr("dy", function (d, i) {
          var dy = 0;
          return orient !== "top" && (dy = sizeFor1Char.h, i === 0 && (dy = isLeftRight ? -((counts[d.index] - 1) * (sizeFor1Char.h / 2) - 3) : tickTextPos.y === 0 ? ".71em" : 0)), isNumber(dy) && tickTextPos.y ? dy + tickTextPos.y : dy || ".71em";
        });
        var lineUpdate = tick.select("line"),
            textUpdate = tick.select("text");

        if (tickEnter.select("line").attr(axisPx + "2", innerTickSize * sign), tickEnter.select("text").attr("" + axisPx, tickLength * sign), ctx.setTickLineTextPosition(lineUpdate, textUpdate), params.tickTitle && textUpdate.append && textUpdate.append("title").each(function (index) {
          Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).text(params.tickTitle[index]);
        }), scale1.bandwidth) {
          var x = scale1,
              dx = x.bandwidth() / 2;
          scale0 = function (d) {
            return x(d) + dx;
          }, scale1 = scale0;
        } else scale0.bandwidth ? scale0 = scale1 : tickTransform.call(helperInst, tickExit, scale1);

        tickTransform.call(helperInst, tickEnter, scale0), tickTransform.call(helperInst, helperInst.transitionise(tick).style("opacity", "1"), scale1);
      }
    }), this.g = $g;
  }
  /**
   * Get tick x/y coordinate
   * @return {{x: number, y: number}}
   * @private
   */
  , _proto.getTickXY = function getTickXY() {
    var config = this.config,
        pos = {
      x: 0,
      y: 0
    };
    return this.params.isCategory && (pos.x = config.tickCentered ? 0 : config.tickOffset, pos.y = config.tickCentered ? config.tickOffset : 0), pos;
  }
  /**
   * Get tick size
   * @param d
   * @return {number}
   * @private
   */
  , _proto.getTickSize = function getTickSize(d) {
    var scale = this.helper.scale,
        config = this.config,
        _config2 = config,
        innerTickSize = _config2.innerTickSize,
        range = _config2.range,
        tickPosition = scale(d) + (config.tickCentered ? 0 : config.tickOffset);
    return range[0] < tickPosition && tickPosition < range[1] ? innerTickSize : 0;
  }
  /**
   * Set tick's line & text position
   * @param lineUpdate
   * @param textUpdate
   * @param scale
   * @private
   */
  , _proto.setTickLineTextPosition = function setTickLineTextPosition(lineUpdate, textUpdate) {
    var tickPos = this.getTickXY(),
        _this$config = this.config,
        innerTickSize = _this$config.innerTickSize,
        orient = _this$config.orient,
        tickLength = _this$config.tickLength,
        tickOffset = _this$config.tickOffset,
        rotate = this.params.tickTextRotate,
        textAnchorForText = function (r) {
      var value = ["start", "end"];
      return orient === "top" && value.reverse(), r ? r > 0 ? value[0] : value[1] : "middle";
    },
        textTransform = function (r) {
      return r ? "rotate(" + r + ")" : null;
    },
        yForText = function (r) {
      var r2 = r / (orient === "bottom" ? 15 : 23);
      return r ? 11.5 - 2.5 * r2 * (r > 0 ? 1 : -1) : tickLength;
    };

    orient === "bottom" ? (lineUpdate.attr("x1", tickPos.x).attr("x2", tickPos.x).attr("y2", this.getTickSize.bind(this)), textUpdate.attr("x", 0).attr("y", yForText(rotate)).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "top" ? (lineUpdate.attr("x2", 0).attr("y2", -innerTickSize), textUpdate.attr("x", 0).attr("y", -yForText(rotate) * 2).style("text-anchor", textAnchorForText(rotate)).attr("transform", textTransform(rotate))) : orient === "left" ? (lineUpdate.attr("x2", -innerTickSize).attr("y1", tickPos.y).attr("y2", tickPos.y), textUpdate.attr("x", -tickLength).attr("y", tickOffset).style("text-anchor", "end")) : orient === "right" ? (lineUpdate.attr("x2", innerTickSize).attr("y2", 0), textUpdate.attr("x", tickLength).attr("y", 0).style("text-anchor", "start")) : void 0;
  } // this should be called only when category axis
  , _proto.splitTickText = function splitTickText(d, scale, ticks, isLeftRight, charWidth) {
    function split(splitted, text) {
      for (var subtext, spaceIndex, textWidth, i = 1; i < text.length; i++) // if text width gets over tick width, split by space index or current index
      if (text.charAt(i) === " " && (spaceIndex = i), subtext = text.substr(0, i + 1), textWidth = charWidth * subtext.length, tickWidth < textWidth) return split(splitted.concat(text.substr(0, spaceIndex || i)), text.slice(spaceIndex ? spaceIndex + 1 : i));

      return splitted.concat(text);
    }

    var params = this.params,
        tickText = this.helper.textFormatted(d),
        splitted = isString(tickText) && tickText.indexOf("\n") > -1 ? tickText.split("\n") : [];
    if (splitted.length) return splitted;
    if (isArray(tickText)) return tickText;
    var tickWidth = params.tickWidth;
    return (!tickWidth || tickWidth <= 0) && (tickWidth = isLeftRight ? 95 : params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110), split(splitted, tickText + "");
  }, _proto.scale = function scale(x) {
    return arguments.length ? (this.helper.scale = x, this) : this.helper.scale;
  }, _proto.orient = function orient(x) {
    return arguments.length ? (this.config.orient = x in {
      top: 1,
      right: 1,
      bottom: 1,
      left: 1
    } ? x + "" : "bottom", this) : this.config.orient;
  }, _proto.tickFormat = function tickFormat(format) {
    var config = this.config;
    return arguments.length ? (config.tickFormat = format, this) : config.tickFormat;
  }, _proto.tickCentered = function tickCentered(isCentered) {
    var config = this.config;
    return arguments.length ? (config.tickCentered = isCentered, this) : config.tickCentered;
  }
  /**
   * Return tick's offset value.
   * The value will be set for 'category' axis type.
   * @return {number}
   * @private
   */
  , _proto.tickOffset = function tickOffset() {
    return this.config.tickOffset;
  }
  /**
   * Get tick interval count
   * @private
   * @param {Number} size Total data size
   * @return {number}
   */
  , _proto.tickInterval = function tickInterval(size) {
    var interval;
    if (this.params.isCategory) interval = this.config.tickOffset * 2;else {
      var length = this.g.select("path.domain").node().getTotalLength() - this.config.outerTickSize * 2;
      interval = length / (size || this.g.selectAll("line").size());
    }
    return interval === Infinity ? 0 : interval;
  }, _proto.ticks = function ticks() {
    for (var config = this.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return args.length ? (config.tickArguments = toArray(args), this) : config.tickArguments;
  }, _proto.tickCulling = function tickCulling(culling) {
    var config = this.config;
    return arguments.length ? (config.tickCulling = culling, this) : config.tickCulling;
  }, _proto.tickValues = function tickValues(x) {
    var _this = this,
        config = this.config;

    if (isFunction(x)) config.tickValues = function () {
      return x(_this.helper.scale.domain());
    };else {
      if (!arguments.length) return config.tickValues;
      config.tickValues = x;
    }
    return this;
  }, _proto.setTransition = function setTransition(t) {
    return this.config.transition = t, this;
  }, AxisRenderer;
}();


// CONCATENATED MODULE: ./src/ChartInternal/Axis/Axis.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





var Axis_Axis =
/*#__PURE__*/
function () {
  function Axis(owner) {
    _defineProperty(this, "owner", void 0), _defineProperty(this, "axesList", {}), _defineProperty(this, "orient", {
      x: "bottom",
      y: "left",
      y2: "right",
      subX: "bottom"
    }), this.owner = owner, this.setOrient();
  }

  var _proto = Axis.prototype;
  return _proto.getAxisClassName = function getAxisClassName(id) {
    return config_classes.axis + " " + config_classes["axis" + capitalize(id)];
  }, _proto.isHorizontal = function isHorizontal($$, forHorizontal) {
    var isRotated = $$.config.axis_rotated;
    return forHorizontal ? isRotated : !isRotated;
  }, _proto.init = function init() {
    var _this = this,
        $$ = this.owner,
        config = $$.config,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        axis = _$$$$el.axis,
        clip = $$.state.clip,
        isRotated = config.axis_rotated,
        target = ["x", "y"];

    config.axis_y2_show && target.push("y2"), target.forEach(function (v) {
      var classAxis = _this.getAxisClassName(v),
          axisId = v.toUpperCase(),
          classLabel = config_classes["axis" + axisId + "Label"];

      axis[v] = main.append("g").attr("class", classAxis).attr("clip-path", function () {
        var res = null;
        return v === "x" ? res = clip.pathXAxis : v === "y" && config.axis_y_inner && (res = clip.pathYAxis), res;
      }).attr("transform", $$.getTranslate(v)).style("visibility", config["axis_" + v + "_show"] ? "visible" : "hidden"), axis[v].append("text").attr("class", classLabel).attr("transform", ["rotate(-90)", null][v === "x" ? +!isRotated : +isRotated]).style("text-anchor", _this["textAnchorFor" + axisId + "AxisLabel"].bind(_this)), _this.generateAxes(v);
    });
  }
  /**
   * Set axis orient according option value
   * @private
   */
  , _proto.setOrient = function setOrient() {
    var $$ = this.owner,
        _$$$config = $$.config,
        isRotated = _$$$config.axis_rotated,
        yInner = _$$$config.axis_y_inner,
        y2Inner = _$$$config.axis_y2_inner;
    this.orient = {
      x: isRotated ? "left" : "bottom",
      y: isRotated ? yInner ? "top" : "bottom" : yInner ? "right" : "left",
      y2: isRotated ? y2Inner ? "bottom" : "top" : y2Inner ? "left" : "right",
      subX: isRotated ? "left" : "bottom"
    };
  }
  /**
   * Generate axes
   * It's used when axis' axes option is set
   * @param {String} id Axis id
   * @private
   */
  , _proto.generateAxes = function generateAxes(id) {
    var d3Axis,
        $$ = this.owner,
        config = $$.config,
        axes = [],
        axesConfig = config["axis_" + id + "_axes"],
        isRotated = config.axis_rotated;
    id === "x" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : id === "y" ? d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisBottom"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisLeft"] : id === "y2" && (d3Axis = isRotated ? external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisTop"] : external_commonjs_d3_axis_commonjs2_d3_axis_amd_d3_axis_root_d3_["axisRight"]), axesConfig.length && axesConfig.forEach(function (v) {
      var tick = v.tick || {},
          scale = $$.scale[id].copy();
      v.domain && scale.domain(v.domain), axes.push(d3Axis(scale).ticks(tick.count).tickFormat(tick.format || function (x) {
        return x;
      }).tickValues(tick.values).tickSizeOuter(tick.outer === !1 ? 0 : 6));
    }), this.axesList[id] = axes;
  }
  /**
   * Update axes nodes
   * @private
   */
  , _proto.updateAxes = function updateAxes() {
    var _this2 = this,
        $$ = this.owner,
        config = $$.config,
        main = $$.$el.main;

    Object.keys(this.axesList).forEach(function (id) {
      var axesConfig = config["axis_" + id + "_axes"],
          scale = $$.scale[id].copy(),
          range = scale.range();

      _this2.axesList[id].forEach(function (v, i) {
        var axisRange = v.scale().range(); // adjust range value with the current
        // https://github.com/naver/billboard.js/issues/859

        range.every(function (v, i) {
          return v === axisRange[i];
        }) || v.scale().range(range);
        var className = _this2.getAxisClassName(id) + "-" + (i + 1),
            g = main.select("." + className.replace(/\s/, "."));
        g.empty() ? g = main.append("g").attr("class", className).style("visibility", config["axis_" + id + "_show"] ? "visible" : "hidden").call(v) : (axesConfig[i].domain && scale.domain(axesConfig[i].domain), $$.axis.x.helper.transitionise(g).call(v.scale(scale))), g.attr("transform", $$.getTranslate(id, i + 1));
      });
    });
  } // called from : updateScales() & getMaxTickWidth()
  , _proto.getAxis = function getAxis(name, scale, outerTick, noTransition, noTickTextRotate) {
    var $$ = this.owner,
        config = $$.config,
        isX = /^(x|subX)$/.test(name),
        type = isX ? "x" : name,
        isCategory = isX && $$.isCategorized(),
        orient = this.orient[name],
        tickFormat = isX ? $$.format.xAxisTick : config["axis_" + name + "_tick_format"],
        tickValues = isX ? $$.axis.xTickValues : $$[name + "AxisTickValues"],
        axisParams = mergeObj({
      outerTick: outerTick,
      noTransition: noTransition,
      config: config,
      name: name,
      tickTextRotate: noTickTextRotate ? 0 : config["axis_" + type + "_tick_rotate"]
    }, isX && {
      isCategory: isCategory,
      tickMultiline: config.axis_x_tick_multiline,
      tickWidth: config.axis_x_tick_width,
      tickTitle: isCategory && config.axis_x_tick_tooltip && $$.api.categories(),
      orgXScale: $$.scale.x
    });
    isX || (axisParams.tickStepSize = config["axis_" + type + "_tick_stepSize"]);
    var axis = new AxisRenderer_AxisRenderer(axisParams).scale(isX && $$.scale.zoom || scale).orient(orient);
    return isX && $$.isTimeSeries() && tickValues && !isFunction(tickValues) ? tickValues = tickValues.map(function (v) {
      return $$.parseDate(v);
    }) : !isX && $$.isTimeSeriesY() && (axis.ticks(config.axis_y_tick_time_value), tickValues = null), tickValues && axis.tickValues(tickValues), axis.tickFormat(tickFormat || !isX && $$.isStackNormalized() && function (x) {
      return x + "%";
    }), isCategory && (axis.tickCentered(config.axis_x_tick_centered), isEmpty(config.axis_x_tick_culling) && (config.axis_x_tick_culling = !1)), config["axis_" + type + "_tick_count"] && axis.ticks(config["axis_" + type + "_tick_count"]), axis;
  }, _proto.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {
    var values,
        $$ = this.owner,
        config = $$.config,
        fit = config.axis_x_tick_fit,
        count = config.axis_x_tick_count;
    return (fit || count && fit) && (values = this.generateTickValues($$.mapTargetsToUniqueXs(targets), count, $$.isTimeSeries())), axis ? axis.tickValues(values) : $$.axis.x && ($$.axis.x.tickValues(values), $$.axis.subX.tickValues(values)), values;
  }, _proto.getId = function getId(id) {
    var config = this.owner.config;
    return id in config.data_axes ? config.data_axes[id] : "y";
  }, _proto.getXAxisTickFormat = function getXAxisTickFormat() {
    var currFormat,
        $$ = this.owner,
        config = $$.config,
        format = $$.format,
        tickFormat = config.axis_x_tick_format,
        isTimeSeries = $$.isTimeSeries(),
        isCategorized = $$.isCategorized();
    return tickFormat ? isFunction(tickFormat) ? currFormat = tickFormat : isTimeSeries && (currFormat = function (date) {
      return date ? format.axisTime(tickFormat)(date) : "";
    }) : currFormat = isTimeSeries ? format.defaultAxisTime : isCategorized ? $$.categoryName : function (v) {
      return v < 0 ? v.toFixed(0) : v;
    }, isFunction(currFormat) ? function (v) {
      return currFormat.apply($$, isCategorized ? [v, $$.categoryName(v)] : [v]);
    } : currFormat;
  }, _proto.getTickValues = function getTickValues(id) {
    var $$ = this.owner,
        tickValues = $$.config["axis_" + id + "_tick_values"],
        axis = $$[id + "Axis"];
    return (isFunction(tickValues) ? tickValues() : tickValues) || (axis ? axis.tickValues() : undefined);
  }, _proto.getLabelOptionByAxisId = function getLabelOptionByAxisId(id) {
    return this.owner.config["axis_" + id + "_label"];
  }, _proto.getLabelText = function getLabelText(id) {
    var option = this.getLabelOptionByAxisId(id);
    return isString(option) ? option : option ? option.text : null;
  }, _proto.setLabelText = function setLabelText(id, text) {
    var $$ = this.owner,
        config = $$.config,
        option = this.getLabelOptionByAxisId(id);
    isString(option) ? config["axis_" + id + "_label"] = text : option && (option.text = text);
  }, _proto.getLabelPosition = function getLabelPosition(id, defaultPosition) {
    var isRotated = this.owner.config.axis_rotated,
        option = this.getLabelOptionByAxisId(id),
        position = isObjectType(option) && option.position ? option.position : defaultPosition[+!isRotated],
        has = function (v) {
      return !!~position.indexOf(v);
    };

    return {
      isInner: has("inner"),
      isOuter: has("outer"),
      isLeft: has("left"),
      isCenter: has("center"),
      isRight: has("right"),
      isTop: has("top"),
      isMiddle: has("middle"),
      isBottom: has("bottom")
    };
  }, _proto.getXAxisLabelPosition = function getXAxisLabelPosition() {
    return this.getLabelPosition("x", ["inner-top", "inner-right"]);
  }, _proto.getYAxisLabelPosition = function getYAxisLabelPosition() {
    return this.getLabelPosition("y", ["inner-right", "inner-top"]);
  }, _proto.getY2AxisLabelPosition = function getY2AxisLabelPosition() {
    return this.getLabelPosition("y2", ["inner-right", "inner-top"]);
  }, _proto.getLabelPositionById = function getLabelPositionById(id) {
    return this["get" + id.toUpperCase() + "AxisLabelPosition"]();
  }, _proto.textForXAxisLabel = function textForXAxisLabel() {
    return this.getLabelText("x");
  }, _proto.textForYAxisLabel = function textForYAxisLabel() {
    return this.getLabelText("y");
  }, _proto.textForY2AxisLabel = function textForY2AxisLabel() {
    return this.getLabelText("y2");
  }, _proto.xForAxisLabel = function xForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        x = position.isMiddle ? -height / 2 : 0;
    return this.isHorizontal($$, forHorizontal) ? x = position.isLeft ? 0 : position.isCenter ? width / 2 : width : position.isBottom && (x = -$$.state.height), x;
  }, _proto.dxForAxisLabel = function dxForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        dx = position.isBottom ? "0.5em" : "0";
    return this.isHorizontal($$, forHorizontal) ? dx = position.isLeft ? "0.5em" : position.isRight ? "-0.5em" : "0" : position.isTop && (dx = "-0.5em"), dx;
  }, _proto.textAnchorForAxisLabel = function textAnchorForAxisLabel(position, forHorizontal) {
    forHorizontal === void 0 && (forHorizontal = !0);
    var $$ = this.owner,
        anchor = position.isMiddle ? "middle" : "end";
    return this.isHorizontal($$, forHorizontal) ? anchor = position.isLeft ? "start" : position.isCenter ? "middle" : "end" : position.isBottom && (anchor = "start"), anchor;
  }, _proto.xForXAxisLabel = function xForXAxisLabel() {
    return this.xForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.xForYAxisLabel = function xForYAxisLabel() {
    return this.xForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.xForY2AxisLabel = function xForY2AxisLabel() {
    return this.xForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.dxForXAxisLabel = function dxForXAxisLabel() {
    return this.dxForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.dxForYAxisLabel = function dxForYAxisLabel() {
    return this.dxForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.dxForY2AxisLabel = function dxForY2AxisLabel() {
    return this.dxForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.dyForXAxisLabel = function dyForXAxisLabel() {
    var $$ = this.owner,
        config = $$.config,
        isInner = this.getXAxisLabelPosition().isInner,
        xHeight = config.axis_x_height;
    return config.axis_rotated ? isInner ? "1.2em" : -25 - this.getMaxTickWidth("x") : isInner ? "-0.5em" : xHeight ? xHeight - 10 : "3em";
  }, _proto.dyForYAxisLabel = function dyForYAxisLabel() {
    var $$ = this.owner,
        isInner = this.getYAxisLabelPosition().isInner;
    return $$.config.axis_rotated ? isInner ? "-0.5em" : "3em" : isInner ? "1.2em" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth("y") + 10);
  }, _proto.dyForY2AxisLabel = function dyForY2AxisLabel() {
    var $$ = this.owner,
        isInner = this.getY2AxisLabelPosition().isInner;
    return $$.config.axis_rotated ? isInner ? "1.2em" : "-2.2em" : isInner ? "-0.5em" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth("y2") + 15);
  }, _proto.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {
    return this.textAnchorForAxisLabel(this.getXAxisLabelPosition(), !1);
  }, _proto.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {
    return this.textAnchorForAxisLabel(this.getYAxisLabelPosition());
  }, _proto.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {
    return this.textAnchorForAxisLabel(this.getY2AxisLabelPosition());
  }, _proto.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {
    var $$ = this.owner,
        config = $$.config,
        _$$$$el2 = $$.$el,
        svg = _$$$$el2.svg,
        chart = _$$$$el2.chart,
        currentTickMax = $$.state.currentMaxTickWidths[id],
        maxWidth = 0;
    if (withoutRecompute || !config["axis_" + id + "_show"]) return currentTickMax.size;

    if (svg) {
      var isYAxis = /^y2?$/.test(id),
          targetsToShow = $$.filterTargetsToShow($$.data.targets),
          scale = $$.scale[id].copy().domain($$["get" + (isYAxis ? "Y" : "X") + "Domain"](targetsToShow, id)),
          domain = scale.domain();
      // do not compute if domain is same
      if (isArray(currentTickMax.domain) && currentTickMax.domain.every(function (v, i) {
        return v === domain[i];
      })) return currentTickMax.size;
      currentTickMax.domain = domain;
      var axis = this.getAxis(id, scale, !1, !1, !0),
          tickCount = config["axis_" + id + "_tick_count"];
      tickCount && axis.tickValues(this.generateTickValues(domain, tickCount, isYAxis ? $$.isTimeSeriesY() : $$.isTimeSeries())), isYAxis || this.updateXAxisTickValues(targetsToShow, axis);
      var dummy = chart.append("svg").style("visibility", "hidden").style("position", "fixed").style("top", "0px").style("left", "0px");
      axis.create(dummy), dummy.selectAll("text").each(function () {
        maxWidth = Math.max(maxWidth, this.getBoundingClientRect().width);
      }), dummy.remove();
    }

    return maxWidth > 0 && (currentTickMax.size = maxWidth), currentTickMax.size;
  }, _proto.updateLabels = function updateLabels(withTransition) {
    var _this3 = this,
        $$ = this.owner,
        main = $$.$el.main,
        labels = {
      X: main.select("." + config_classes.axisX + " ." + config_classes.axisXLabel),
      Y: main.select("." + config_classes.axisY + " ." + config_classes.axisYLabel),
      Y2: main.select("." + config_classes.axisY2 + " ." + config_classes.axisY2Label)
    };

    Object.keys(labels).filter(function (id) {
      return !labels[id].empty();
    }).forEach(function (v) {
      var node = labels[v],
          axisLabel = v + "AxisLabel";
      (withTransition ? node.transition() : node).attr("x", _this3["xFor" + axisLabel].bind(_this3)).attr("dx", _this3["dxFor" + axisLabel].bind(_this3)).attr("dy", _this3["dyFor" + axisLabel].bind(_this3)).text(_this3["textFor" + axisLabel].bind(_this3));
    });
  }, _proto.getPadding = function getPadding(padding, key, defaultValue, domainLength) {
    var p = isNumber(padding) ? padding : padding[key];
    return isValue(p) ? this.convertPixelsToAxisPadding(p, domainLength) : defaultValue;
  }, _proto.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {
    var $$ = this.owner,
        config = $$.config,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        length = config.axis_rotated ? width : height;
    return domainLength * (pixels / length);
  }, _proto.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {
    var start,
        end,
        count,
        interval,
        i,
        tickValue,
        tickValues = values;

    if (tickCount) {
      var targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount

      if (targetCount === 1) tickValues = [values[0]];else if (targetCount === 2) tickValues = [values[0], values[values.length - 1]];else if (targetCount > 2) {
        var isCategorized = this.owner.isCategorized();

        for (count = targetCount - 2, start = values[0], end = values[values.length - 1], interval = (end - start) / (count + 1), tickValues = [start], i = 0; i < count; i++) tickValue = +start + interval * (i + 1), tickValues.push(forTimeSeries ? new Date(tickValue) : isCategorized ? Math.round(tickValue) : tickValue);

        tickValues.push(end);
      }
    }

    return forTimeSeries || (tickValues = tickValues.sort(function (a, b) {
      return a - b;
    })), tickValues;
  }, _proto.generateTransitions = function generateTransitions(duration) {
    var $$ = this.owner,
        axis = $$.$el.axis,
        _map = ["x", "y", "y2", "subX"].map(function (v) {
      var ax = axis[v];
      return ax && duration && (ax = ax.transition().duration(duration)), ax;
    }),
        axisX = _map[0],
        axisY = _map[1],
        axisY2 = _map[2],
        axisSubX = _map[3];

    return {
      axisX: axisX,
      axisY: axisY,
      axisY2: axisY2,
      axisSubX: axisSubX
    };
  }, _proto.redraw = function redraw(transitions, isHidden, isInit) {
    var $$ = this.owner,
        config = $$.config,
        $el = $$.$el,
        opacity = isHidden ? "0" : "1";
    ["x", "y", "y2", "subX"].forEach(function (id) {
      var axis = $$.axis[id],
          $axis = $el.axis[id];
      axis && (!isInit && (axis.config.withoutTransition = !config.transition_duration), $axis.style("opacity", opacity), axis.create(transitions["axis" + capitalize(id)]));
    }), this.updateAxes();
  }
  /**
   * Redraw axis
   * @param {Object} targetsToShow targets data to be shown
   * @param {Object} wth
   * @param {Ojbect} transitions
   * @param {Object} flow
   * @private
   */
  , _proto.redrawAxis = function redrawAxis(targetsToShow, wth, transitions, flow, isInit) {
    var xDomainForZoom,
        _this4 = this,
        $$ = this.owner,
        config = $$.config,
        scale = $$.scale,
        $el = $$.$el,
        hasZoom = !!scale.zoom;

    !hasZoom && $$.isCategorized() && targetsToShow.length === 0 && scale.x.domain([0, $el.axis.x.selectAll(".tick").size()]), scale.x && targetsToShow.length ? (!hasZoom && $$.updateXDomain(targetsToShow, wth.UpdateXDomain, wth.UpdateOrgXDomain, wth.TrimXDomain), !config.axis_x_tick_values && this.updateXAxisTickValues(targetsToShow)) : $$.axis.x && ($$.axis.x.tickValues([]), $$.axis.subX.tickValues([])), config.zoom_rescale && !flow && (xDomainForZoom = scale.x.orgDomain()), ["y", "y2"].forEach(function (key) {
      var axis = scale[key];

      if (axis) {
        var tickValues = config["axis_" + key + "_tick_values"],
            tickCount = config["axis_" + key + "_tick_count"];

        if (axis.domain($$.getYDomain(targetsToShow, key, xDomainForZoom)), !tickValues && tickCount) {
          var domain = axis.domain();
          $$[key + "Axis"].tickValues(_this4.generateTickValues(domain, domain.every(function (v) {
            return v === 0;
          }) ? 1 : tickCount, $$.isTimeSeriesY()));
        }
      }
    }), this.redraw(transitions, $$.hasArcType(), isInit), this.updateLabels(wth.Transition), (wth.UpdateXDomain || wth.UpdateXAxis || wth.Y) && targetsToShow.length && this.setCulling(), wth.Y && (scale.subY && scale.subY.domain($$.getYDomain(targetsToShow, "y")), scale.subY2 && scale.subY2.domain($$.getYDomain(targetsToShow, "y2")));
  }
  /**
   * Set manual culling
   * @private
   */
  , _proto.setCulling = function setCulling() {
    var $$ = this.owner,
        config = $$.config,
        $el = $$.$el;
    ["subX", "x", "y", "y2"].forEach(function (type) {
      var axis = $el.axis[type],
          id = type === "subX" ? "x" : type,
          toCull = config["axis_" + id + "_tick_culling"]; // subchart x axis should be aligned with x axis culling

      if (axis && toCull) {
        var intervalForCulling,
            tickText = axis.selectAll(".tick text"),
            tickValues = util_sortValue(tickText.data()),
            tickSize = tickValues.length,
            cullingMax = config["axis_" + id + "_tick_culling_max"];

        if (tickSize) {
          for (var _i = 1; _i < tickSize; _i++) if (tickSize / _i < cullingMax) {
            intervalForCulling = _i;
            break;
          }

          tickText.each(function (d) {
            this.style.display = tickValues.indexOf(d) % intervalForCulling ? "none" : "block";
          });
        } else tickText.style("display", "block");
      }
    });
  }, Axis;
}();


// EXTERNAL MODULE: external {"commonjs":"d3-dsv","commonjs2":"d3-dsv","amd":"d3-dsv","root":"d3"}
var external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_ = __webpack_require__(42);

// CONCATENATED MODULE: ./src/ChartInternal/data/data.convert.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Data convert
 * @memberof ChartInternal
 * @private
 */

/* harmony default export */ var data_convert = ({
  /**
   * Convert data according its type
   * @param {Object} args data object
   * @param {Function} [callback] callback for url(XHR) type loading
   * @return {Object}
   * @private
   */
  convertData: function convertData(args, callback) {
    var data;
    if (args.bindto ? (data = {}, ["url", "mimeType", "headers", "keys", "json", "keys", "rows", "columns"].forEach(function (v) {
      var key = "data_" + v;
      key in args && (data[v] = args[key]);
    })) : data = args, data.url && callback) this.convertUrlToData(data.url, data.mimeType, data.headers, data.keys, callback);else if (data.json) data = this.convertJsonToData(data.json, data.keys);else if (data.rows) data = this.convertRowsToData(data.rows);else if (data.columns) data = this.convertColumnsToData(data.columns);else if (args.bindto) throw Error("url or json or rows or columns is required.");
    return isArray(data) && data;
  },

  /**
   * Convert URL data
   * @param {String} url Remote URL
   * @param {String} mimeType MIME type string: json | csv | tsv
   * @param {Object} headers Header object
   * @param {Object} keys Key object
   * @param {Function} done Callback function
   * @private
   */
  convertUrlToData: function convertUrlToData(url, mimeType, headers, keys, done) {
    var _this = this;

    mimeType === void 0 && (mimeType = "csv");
    var req = new XMLHttpRequest();
    req.open("GET", url), headers && Object.keys(headers).forEach(function (key) {
      req.setRequestHeader(key, headers[key]);
    }), req.onreadystatechange = function () {
      if (req.readyState === 4) if (req.status === 200) {
        var response = req.responseText;
        response && done.call(_this, _this["convert" + capitalize(mimeType) + "ToData"](mimeType === "json" ? JSON.parse(response) : response, keys));
      } else throw new Error(url + ": Something went wrong loading!");
    }, req.send();
  },

  /**
   * Convert CSV/TSV data
   * @param {Object} parser Parser object
   * @param {Object} xsv Data
   * @private
   * @return {Object}
   */
  convertCsvTsvToData: function convertCsvTsvToData(parser, xsv) {
    var d,
        rows = parser.rows(xsv);
    return rows.length === 1 ? (d = [{}], rows[0].forEach(function (id) {
      d[0][id] = null;
    })) : d = parser.parse(xsv), d;
  },
  convertCsvToData: function convertCsvToData(xsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["csvParse"]
    }, xsv);
  },
  convertTsvToData: function convertTsvToData(tsv) {
    return this.convertCsvTsvToData({
      rows: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParseRows"],
      parse: external_commonjs_d3_dsv_commonjs2_d3_dsv_amd_d3_dsv_root_d3_["tsvParse"]
    }, tsv);
  },
  convertJsonToData: function convertJsonToData(json, keysParam) {
    var targetKeys,
        data,
        _this2 = this,
        config = this.config,
        newRows = [];

    if (isArray(json)) {
      var keys = keysParam || config.data_keys;
      keys.x ? (targetKeys = keys.value.concat(keys.x), config.data_x = keys.x) : targetKeys = keys.value, newRows.push(targetKeys), json.forEach(function (o) {
        var newRow = targetKeys.map(function (key) {
          // convert undefined to null because undefined data will be removed in convertDataToTargets()
          var v = _this2.findValueInJson(o, key);

          return isUndefined(v) && (v = null), v;
        });
        newRows.push(newRow);
      }), data = this.convertRowsToData(newRows);
    } else Object.keys(json).forEach(function (key) {
      var tmp = json[key].concat();
      tmp.unshift(key), newRows.push(tmp);
    }), data = this.convertColumnsToData(newRows);

    return data;
  },
  findValueInJson: function findValueInJson(object, path) {
    if (object[path] !== undefined) return object[path];
    var convertedPath = path.replace(/\[(\w+)\]/g, ".$1"),
        pathArray = convertedPath.replace(/^\./, "").split("."),
        target = object; // convert indexes to properties (replace [] with .)

    return pathArray.some(function (k) {
      return !(target = target && k in target ? target[k] : undefined);
    }), target;
  },
  convertRowsToData: function convertRowsToData(rows) {
    var keys = rows[0],
        newRows = [];
    return rows.forEach(function (row, i) {
      if (i > 0) {
        var newRow = {};
        row.forEach(function (v, j) {
          if (isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRow[keys[j]] = v;
        }), newRows.push(newRow);
      }
    }), newRows;
  },
  convertColumnsToData: function convertColumnsToData(columns) {
    var newRows = [];
    return columns.forEach(function (col, i) {
      var key = col[0];
      col.forEach(function (v, j) {
        if (j > 0) {
          if (isUndefined(newRows[j - 1]) && (newRows[j - 1] = {}), isUndefined(v)) throw new Error("Source data is missing a component at (" + i + ", " + j + ")!");
          newRows[j - 1][key] = v;
        }
      });
    }), newRows;
  },
  convertDataToTargets: function convertDataToTargets(data, appendXs) {
    var xsData,
        _this3 = this,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isTimeSeries = $$.isTimeSeries(),
        dataKeys = Object.keys(data[0] || {}),
        ids = dataKeys.length ? dataKeys.filter($$.isNotX, $$) : [],
        xs = dataKeys.length ? dataKeys.filter($$.isX, $$) : [];

    ids.forEach(function (id) {
      var xKey = _this3.getXKey(id);

      _this3.isCustomX() || isTimeSeries ? xs.indexOf(xKey) >= 0 ? xsData = (appendXs && $$.data.xs[id] || []).concat(data.map(function (d) {
        return d[xKey];
      }).filter(isValue).map(function (rawX, i) {
        return $$.generateTargetX(rawX, id, i);
      })) : config.data_x ? xsData = _this3.getOtherTargetXs() : notEmpty(config.data_xs) && (xsData = $$.getXValuesOfXKey(xKey, $$.data.targets)) : xsData = data.map(function (d, i) {
        return i;
      }), xsData && (_this3.data.xs[id] = xsData);
    }), ids.forEach(function (id) {
      if (!_this3.data.xs[id]) throw new Error("x is not defined for id = \"" + id + "\".");
    });
    // convert to target
    var targets = ids.map(function (id, index) {
      var convertedId = config.data_idConverter(id),
          xKey = $$.getXKey(id),
          isCategorized = $$.isCustomX() && $$.isCategorized(),
          hasCategory = isCategorized && data.map(function (v) {
        return v.x;
      }).every(function (v) {
        return config.axis_x_categories.indexOf(v) > -1;
      });
      return {
        id: convertedId,
        id_org: id,
        values: data.map(function (d, i) {
          var x,
              rawX = d[xKey],
              value = d[id];
          return value = value === null || isNaN(value) || isObject(value) ? isArray(value) || isObject(value) ? value : null : +value, isCategorized && index === 0 && !isUndefined(rawX) ? (!hasCategory && index === 0 && i === 0 && (config.axis_x_categories = []), x = config.axis_x_categories.indexOf(rawX), x === -1 && (x = config.axis_x_categories.length, config.axis_x_categories.push(rawX))) : x = $$.generateTargetX(rawX, id, i), (isUndefined(value) || $$.data.xs[id].length <= i) && (x = undefined), {
            x: x,
            value: value,
            id: convertedId
          };
        }).filter(function (v) {
          return isDefined(v.x);
        })
      };
    }); // finish targets

    return targets.forEach(function (t) {
      config.data_xSort && (t.values = t.values.sort(function (v1, v2) {
        var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,
            x2 = v2.x || v2.x === 0 ? v2.x : Infinity;
        return x1 - x2;
      })), t.values.forEach(function (v, i) {
        return v.index = i;
      }), $$.data.xs[t.id].sort(function (v1, v2) {
        return v1 - v2;
      });
    }), state.hasNegativeValue = $$.hasNegativeValueInTargets(targets), state.hasPositiveValue = $$.hasPositiveValueInTargets(targets), config.data_type && $$.setTargetType($$.mapToIds(targets).filter(function (id) {
      return !(id in config.data_types);
    }), config.data_type), targets.forEach(function (d) {
      return $$.cache.add(d.id_org, d, !0);
    }), targets;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var ChartInternal_data_data = ({
  isX: function isX(key) {
    var $$ = this,
        config = $$.config,
        dataKey = config.data_x && key === config.data_x,
        existValue = notEmpty(config.data_xs) && util_hasValue(config.data_xs, key);
    return dataKey || existValue;
  },
  isNotX: function isNotX(key) {
    return !this.isX(key);
  },
  isStackNormalized: function isStackNormalized() {
    var config = this.config;
    return !!(config.data_stack_normalize && config.data_groups.length);
  },
  isGrouped: function isGrouped(id) {
    return this.config.data_groups.map(function (v) {
      return v.indexOf(id) >= 0;
    })[0];
  },
  getXKey: function getXKey(id) {
    var $$ = this,
        config = $$.config;
    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;
  },
  getXValuesOfXKey: function getXValuesOfXKey(key, targets) {
    var xValues,
        $$ = this,
        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];
    return ids.forEach(function (id) {
      $$.getXKey(id) === key && (xValues = $$.data.xs[id]);
    }), xValues;
  },

  /**
   * Get index number based on given x Axis value
   * @param {Date|Number|String} x x Axis to be compared
   * @param {Array} basedX x Axis list to be based on
   * @return {Number} index number
   * @private
   */
  getIndexByX: function getIndexByX(x, basedX) {
    var $$ = this;
    return basedX ? basedX.indexOf(isString(x) ? x : +x) : ($$.filterByX($$.data.targets, x)[0] || {
      index: null
    }).index;
  },
  getXValue: function getXValue(id, i) {
    var $$ = this;
    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;
  },
  getOtherTargetXs: function getOtherTargetXs() {
    var $$ = this,
        idsForX = Object.keys($$.data.xs);
    return idsForX.length ? $$.data.xs[idsForX[0]] : null;
  },
  getOtherTargetX: function getOtherTargetX(index) {
    var xs = this.getOtherTargetXs();
    return xs && index < xs.length ? xs[index] : null;
  },
  addXs: function addXs(xs) {
    var $$ = this,
        config = $$.config;
    Object.keys(xs).forEach(function (id) {
      config.data_xs[id] = xs[id];
    });
  },
  isMultipleX: function isMultipleX() {
    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType("bubble") || this.hasType("scatter");
  },
  addName: function addName(data) {
    var name,
        $$ = this,
        config = $$.config;
    return data && (name = config.data_names[data.id], data.name = name === undefined ? data.id : name), data;
  },
  getAllValuesOnIndex: function getAllValuesOnIndex(index) {
    var $$ = this;
    return $$.filterTargetsToShow($$.data.targets).map(function (t) {
      return $$.addName($$.getValueOnIndex(t.values, index));
    });
  },
  getValueOnIndex: function getValueOnIndex(values, index) {
    var valueOnIndex = values.filter(function (v) {
      return v.index === index;
    });
    return valueOnIndex.length ? valueOnIndex[0] : null;
  },
  updateTargetX: function updateTargetX(targets, x) {
    var $$ = this;
    targets.forEach(function (t) {
      t.values.forEach(function (v, i) {
        v.x = $$.generateTargetX(x[i], t.id, i);
      }), $$.data.xs[t.id] = x;
    });
  },
  updateTargetXs: function updateTargetXs(targets, xs) {
    var $$ = this;
    targets.forEach(function (t) {
      xs[t.id] && $$.updateTargetX([t], xs[t.id]);
    });
  },
  generateTargetX: function generateTargetX(rawX, id, index) {
    var $$ = this,
        x = $$.isCategorized() ? index : rawX || index;
    return $$.isTimeSeries() ? x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index)) : $$.isCustomX() && !$$.isCategorized() && (x = isValue(rawX) ? +rawX : $$.getXValue(id, index)), x;
  },
  updateXs: function updateXs(values) {
    values.length && (this.state.xs = values.map(function (v) {
      return v.x;
    }));
  },
  getPrevX: function getPrevX(i) {
    var x = this.state.xs[i - 1];
    return isDefined(x) ? x : null;
  },
  getNextX: function getNextX(i) {
    var x = this.state.xs[i + 1];
    return isDefined(x) ? x : null;
  },

  /**
   * Get base value isAreaRangeType
   * @param data Data object
   * @return {Number}
   * @private
   */
  getBaseValue: function getBaseValue(data) {
    var $$ = this,
        value = data.value;
    return value && ($$.isAreaRangeType(data) ? value = $$.getAreaRangeData(data, "mid") : $$.isBubbleZType(data) && (value = $$.getBubbleZData(value, "y"))), value;
  },

  /**
   * Get min/max value from the data
   * @private
   * @param {Array} data array data to be evaluated
   * @return {{min: {Number}, max: {Number}}}
   */
  getMinMaxValue: function getMinMaxValue(data) {
    var min,
        max,
        getBaseValue = this.getBaseValue.bind(this);
    return (data || this.data.targets.map(function (t) {
      return t.values;
    })).forEach(function (v, i) {
      var value = v.map(getBaseValue).filter(isNumber);
      min = Math.min.apply(Math, [i ? min : Infinity].concat(value)), max = Math.max.apply(Math, [i ? max : -Infinity].concat(value));
    }), {
      min: min,
      max: max
    };
  },

  /**
   * Get the min/max data
   * @private
   * @return {{min: Array, max: Array}}
   */
  getMinMaxData: function getMinMaxData() {
    var $$ = this,
        cacheKey = "$minMaxData",
        minMaxData = $$.cache.get(cacheKey);

    if (!minMaxData) {
      var data = $$.data.targets.map(function (t) {
        return t.values;
      }),
          minMax = $$.getMinMaxValue(data),
          min = [],
          max = [];
      // update the cached data
      data.forEach(function (v) {
        var minData = $$.getFilteredDataByValue(v, minMax.min),
            maxData = $$.getFilteredDataByValue(v, minMax.max);
        minData.length && (min = min.concat(minData)), maxData.length && (max = max.concat(maxData));
      }), $$.cache.add(cacheKey, minMaxData = {
        min: min,
        max: max
      });
    }

    return minMaxData;
  },

  /**
   * Get sum of data per index
   * @private
   * @return {Array}
   */
  getTotalPerIndex: function getTotalPerIndex() {
    var $$ = this,
        sum = $$.cache.get("$totalPerIndex");
    return $$.isStackNormalized() && !sum && (sum = [], $$.data.targets.forEach(function (row) {
      row.values.forEach(function (v, i) {
        sum[i] || (sum[i] = 0), sum[i] += isNumber(v.value) ? v.value : 0;
      });
    })), sum;
  },

  /**
   * Get total data sum
   * @return {Number}
  	 * @private
   */
  getTotalDataSum: function getTotalDataSum() {
    var $$ = this,
        cacheKey = "$totalDataSum",
        totalDataSum = $$.cache.get(cacheKey);

    if (!totalDataSum) {
      var total = mergeArray($$.data.targets.map(function (t) {
        return t.values;
      })).map(function (v) {
        return v.value;
      }).reduce(function (p, c) {
        return p + c;
      });
      $$.cache.add(cacheKey, totalDataSum = total);
    }

    return totalDataSum;
  },

  /**
   * Get filtered data by value
   * @param {Object} data
   * @param {Number} value
   * @return {Array} filtered array data
   * @private
   */
  getFilteredDataByValue: function getFilteredDataByValue(data, value) {
    var _this = this;

    return data.filter(function (t) {
      return _this.getBaseValue(t) === value;
    });
  },

  /**
   * Return the max length of the data
   * @return {Number} max data length
   * @private
   */
  getMaxDataCount: function getMaxDataCount() {
    return Math.max.apply(Math, this.data.targets.map(function (t) {
      return t.values.length;
    }));
  },
  getMaxDataCountTarget: function getMaxDataCountTarget() {
    var target = this.filterTargetsToShow() || [],
        length = target.length;
    return length > 1 ? (target = target.map(function (t) {
      return t.values;
    }).reduce(function (a, b) {
      return a.concat(b);
    }).map(function (v) {
      return v.x;
    }), target = util_sortValue(getUnique(target)).map(function (x, index) {
      return {
        x: x,
        index: index
      };
    })) : length && (target = target[0].values), target;
  },
  mapToIds: function mapToIds(targets) {
    return targets.map(function (d) {
      return d.id;
    });
  },
  mapToTargetIds: function mapToTargetIds(ids) {
    var $$ = this;
    return ids ? isArray(ids) ? ids.concat() : [ids] : $$.mapToIds($$.data.targets);
  },
  hasTarget: function hasTarget(targets, id) {
    var ids = this.mapToIds(targets);

    for (var val, i = 0; val = ids[i]; i++) if (val === id) return !0;

    return !1;
  },
  isTargetToShow: function isTargetToShow(targetId) {
    return this.state.hiddenTargetIds.indexOf(targetId) < 0;
  },
  isLegendToShow: function isLegendToShow(targetId) {
    return this.state.hiddenLegendIds.indexOf(targetId) < 0;
  },
  filterTargetsToShow: function filterTargetsToShow(targets) {
    var $$ = this;
    return (targets || $$.data.targets).filter(function (t) {
      return $$.isTargetToShow(t.id);
    });
  },
  mapTargetsToUniqueXs: function mapTargetsToUniqueXs(targets) {
    var $$ = this,
        xs = [];
    return targets && targets.length && (xs = getUnique(mergeArray(targets.map(function (t) {
      return t.values.map(function (v) {
        return +v.x;
      });
    }))), xs = $$.isTimeSeries() ? xs.map(function (x) {
      return new Date(+x);
    }) : xs.map(function (x) {
      return +x;
    })), util_sortValue(xs);
  },
  addHiddenTargetIds: function addHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.concat(targetIds);
  },
  removeHiddenTargetIds: function removeHiddenTargetIds(targetIds) {
    this.state.hiddenTargetIds = this.state.hiddenTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  addHiddenLegendIds: function addHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.concat(targetIds);
  },
  removeHiddenLegendIds: function removeHiddenLegendIds(targetIds) {
    this.state.hiddenLegendIds = this.state.hiddenLegendIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },
  getValuesAsIdKeyed: function getValuesAsIdKeyed(targets) {
    var $$ = this,
        ys = {},
        isMultipleX = $$.isMultipleX(),
        xs = isMultipleX ? $$.mapTargetsToUniqueXs(targets).map(function (v) {
      return isString(v) ? v : +v;
    }) : null;
    return targets.forEach(function (t) {
      var data = [];
      t.values.forEach(function (v) {
        var value = v.value;
        isArray(value) ? data.push.apply(data, value) : isObject(value) && "high" in value ? data.push.apply(data, Object.values(value)) : $$.isBubbleZType(v) ? data.push($$.getBubbleZData(value, "y")) : isMultipleX ? data[$$.getIndexByX(v.x, xs)] = value : data.push(value);
      }), ys[t.id] = data;
    }), ys;
  },
  checkValueInTargets: function checkValueInTargets(targets, checker) {
    var values,
        ids = Object.keys(targets);

    for (var i = 0; i < ids.length; i++) {
      values = targets[ids[i]].values;

      for (var j = 0; j < values.length; j++) if (checker(values[j].value)) return !0;
    }

    return !1;
  },
  hasMultiTargets: function hasMultiTargets() {
    return this.filterTargetsToShow().length > 1;
  },
  hasNegativeValueInTargets: function hasNegativeValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v < 0;
    });
  },
  hasPositiveValueInTargets: function hasPositiveValueInTargets(targets) {
    return this.checkValueInTargets(targets, function (v) {
      return v > 0;
    });
  },
  _checkOrder: function _checkOrder(type) {
    var config = this.config,
        order = config.data_order;
    return isString(order) && order.toLowerCase() === type;
  },
  isOrderDesc: function isOrderDesc() {
    return this._checkOrder("desc");
  },
  isOrderAsc: function isOrderAsc() {
    return this._checkOrder("asc");
  },

  /**
   * Sort targets data
   * @param {Array} targetsValue
   * @return {Array}
   * @private
   */
  orderTargets: function orderTargets(targetsValue) {
    var $$ = this,
        config = $$.config,
        targets = [].concat(targetsValue),
        orderAsc = $$.isOrderAsc(),
        orderDesc = $$.isOrderDesc();
    // TODO: accept name array for order
    return orderAsc || orderDesc ? targets.sort(function (t1, t2) {
      var reducer = function (p, c) {
        return p + Math.abs(c.value);
      },
          t1Sum = t1.values.reduce(reducer, 0),
          t2Sum = t2.values.reduce(reducer, 0);

      return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum;
    }) : isFunction(config.data_order) && targets.sort(config.data_order), targets;
  },
  filterByX: function filterByX(targets, x) {
    return mergeArray(targets.map(function (t) {
      return t.values;
    })).filter(function (v) {
      return v.x - x === 0;
    });
  },
  filterRemoveNull: function filterRemoveNull(data) {
    var _this2 = this;

    return data.filter(function (d) {
      return isValue(_this2.getBaseValue(d));
    });
  },
  filterByXDomain: function filterByXDomain(targets, xDomain) {
    return targets.map(function (t) {
      return {
        id: t.id,
        id_org: t.id_org,
        values: t.values.filter(function (v) {
          return xDomain[0] <= v.x && v.x <= xDomain[1];
        })
      };
    });
  },
  hasDataLabel: function hasDataLabel() {
    var dataLabels = this.config.data_labels;
    return isBoolean(dataLabels) && dataLabels || isObjectType(dataLabels) && notEmpty(dataLabels);
  },
  getDataLabelLength: function getDataLabelLength(min, max, key) {
    var $$ = this,
        lengths = [0, 0];
    return $$.$el.chart.select("svg").selectAll(".dummy").data([min, max]).enter().append("text").text(function (d) {
      return $$.dataLabelFormat(d.id)(d);
    }).each(function (d, i) {
      lengths[i] = this.getBoundingClientRect()[key] * 1.3;
    }).remove(), lengths;
  },
  isNoneArc: function isNoneArc(d) {
    return this.hasTarget(this.data.targets, d.id);
  },
  isArc: function isArc(d) {
    return "data" in d && this.hasTarget(this.data.targets, d.data.id);
  },
  findSameXOfValues: function findSameXOfValues(values, index) {
    var i,
        targetX = values[index].x,
        sames = [];

    for (i = index - 1; i >= 0 && !(targetX !== values[i].x); i--) sames.push(values[i]);

    for (i = index; i < values.length && !(targetX !== values[i].x); i++) sames.push(values[i]);

    return sames;
  },
  findClosestFromTargets: function findClosestFromTargets(targets, pos) {
    var $$ = this,
        candidates = targets.map(function (target) {
      return $$.findClosest(target.values, pos);
    });
    // map to array of closest points of each target
    // decide closest point and return
    return $$.findClosest(candidates, pos);
  },
  findClosest: function findClosest(values, pos) {
    var closest,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        data = values.filter(function (v) {
      return v && isValue(v.value);
    }),
        minDist = config.point_sensitivity;
    return data.filter(function (v) {
      return $$.isBarType(v.id);
    }).forEach(function (v) {
      var shape = main.select("." + config_classes.bars + $$.getTargetSelectorSuffix(v.id) + " ." + config_classes.bar + "-" + v.index).node();
      !closest && $$.isWithinBar(shape) && (closest = v);
    }), data.filter(function (v) {
      return !$$.isBarType(v.id);
    }).forEach(function (v) {
      var d = $$.dist(v, pos);
      d < minDist && (minDist = d, closest = v);
    }), closest;
  },
  dist: function dist(data, pos) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        scale = $$.scale,
        xIndex = isRotated ? 1 : 0,
        yIndex = isRotated ? 0 : 1,
        y = $$.circleY(data, data.index),
        x = (scale.zoom || scale.x)(data.x);
    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));
  },

  /**
   * Convert data for step type
   * @param {Array} values Object data values
   * @return {Array}
   * @private
   */
  convertValuesToStep: function convertValuesToStep(values) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        stepType = config.line_step_type,
        isCategorized = $$.isCategorized(),
        converted = isArray(values) ? values.concat() : [values];
    if (!isRotated && !isCategorized) return values; // insert & append cloning first/last value to be fully rendered covering on each gap sides

    var id = converted[0].id,
        x = converted[0].x - 1,
        value = converted[0].value; // insert

    return isCategorized && converted.unshift({
      x: x,
      value: value,
      id: id
    }), stepType === "step-after" && converted.unshift({
      x: x - 1,
      value: value,
      id: id
    }), x = converted.length, value = converted[x - 1].value, isCategorized && converted.push({
      x: x,
      value: value,
      id: id
    }), stepType === "step-before" && converted.push({
      x: x + 1,
      value: value,
      id: id
    }), converted;
  },
  convertValuesToRange: function convertValuesToRange(values) {
    var converted = isArray(values) ? values.concat() : [values],
        ranges = [];
    return converted.forEach(function (range) {
      var x = range.x,
          id = range.id;
      ranges.push({
        x: x,
        id: id,
        value: range.value[0]
      }), ranges.push({
        x: x,
        id: id,
        value: range.value[2]
      });
    }), ranges;
  },
  updateDataAttributes: function updateDataAttributes(name, attrs) {
    var $$ = this,
        config = $$.config,
        current = config["data_" + name];
    return isUndefined(attrs) ? current : (Object.keys(attrs).forEach(function (id) {
      current[id] = attrs[id];
    }), $$.redraw({
      withLegend: !0
    }), current);
  },
  getAreaRangeData: function getAreaRangeData(d, type) {
    var value = d.value;

    if (isArray(value)) {
      var index = ["high", "mid", "low"].indexOf(type);
      return index === -1 ? null : value[index];
    }

    return value[type];
  },

  /**
   * Get ratio value
   * @param {String} type Ratio for given type
   * @param {Object} d Data value object
   * @param {Boolean} asPercent Convert the return as percent or not
   * @return {Number} Ratio value
   * @private
   */
  getRatio: function getRatio(type, d, asPercent) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        api = $$.api,
        ratio = 0;

    if (d && api.data.shown().length) {
      var dataValues = api.data.values.bind(api);
      if (ratio = d.ratio || d.value, type === "arc") {
          // if has padAngle set, calculate rate based on value
          if ($$.pie.padAngle()()) {
            var total = $$.getTotalDataSum();
            state.hiddenTargetIds.length && (total -= dataValues(state.hiddenTargetIds).reduce(function (p, c) {
              return p + c;
            })), ratio = d.value / total;
          } else ratio = (d.endAngle - d.startAngle) / (Math.PI * ($$.hasType("gauge") && !config.gauge_fullCircle ? 1 : 2));
      } else if (type === "index") {
        var _total = this.getTotalPerIndex();

        if (state.hiddenTargetIds.length) {
          var hiddenSum = dataValues(state.hiddenTargetIds, !1);
          hiddenSum.length && (hiddenSum = hiddenSum.reduce(function (acc, curr) {
            return acc.map(function (v, i) {
              return (isNumber(v) ? v : 0) + curr[i];
            });
          }), _total = _total.map(function (v, i) {
            return v - hiddenSum[i];
          }));
        }

        d.ratio = isNumber(d.value) && _total && _total[d.index] > 0 ? d.value / _total[d.index] : 0, ratio = d.ratio;
      } else type === "radar" && (ratio = parseFloat(Math.max(d.value, 0) + "") / $$.maxValue * config.radar_size_ratio);
    }

    return asPercent && ratio ? ratio * 100 : ratio;
  },

  /**
   * Sort data index to be aligned with x axis.
   * @param {Array} tickValues Tick array values
   * @private
   */
  updateDataIndexByX: function updateDataIndexByX(tickValues) {
    var $$ = this,
        tickValueMap = tickValues.reduce(function (out, tick, index) {
      return out[+tick.x] = index, out;
    }, {});
    $$.data.targets.forEach(function (t) {
      t.values.forEach(function (value, valueIndex) {
        var index = tickValueMap[+value.x];
        index === undefined && (index = valueIndex), value.index = index;
      });
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/data/data.load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var data_load = ({
  load: function load(rawTargets, args) {
    var $$ = this,
        targets = rawTargets;
    // Set targets
    // Redraw with new targets
    targets && (args.filter && (targets = targets.filter(args.filter)), (args.type || args.types) && targets.forEach(function (t) {
      var type = args.types && args.types[t.id] || args.type;
      $$.setTargetType(t.id, type);
    }), $$.data.targets.forEach(function (d) {
      for (var i = 0; i < targets.length; i++) if (d.id === targets[i].id) {
        d.values = targets[i].values, targets.splice(i, 1);
        break;
      }
    }), $$.data.targets = $$.data.targets.concat(targets)), $$.updateTargets($$.data.targets), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0,
      withLegend: !0
    }), args.done && args.done();
  },
  loadFromArgs: function loadFromArgs(args) {
    var $$ = this; // prevent load when chart is already destroyed

    if ($$.config) {
      $$.cache.reset();
      var data = args.data || $$.convertData(args, function (d) {
        return $$.load($$.convertDataToTargets(d), args);
      });
      data && $$.load($$.convertDataToTargets(data), args);
    } // reset internally cached data

  },
  unload: function unload(rawTargetIds, customDoneCb) {
    var $$ = this,
        state = $$.state,
        $el = $$.$el,
        done = customDoneCb,
        targetIds = rawTargetIds;
    // If no target, call done and return
    return $$.cache.reset(), done || (done = function () {}), targetIds = targetIds.filter(function (id) {
      return $$.hasTarget($$.data.targets, id);
    }), targetIds && targetIds.length !== 0 ? void ($el.svg.selectAll(targetIds.map(function (id) {
      return $$.selectorTarget(id);
    })).transition().style("opacity", "0").remove().call($$.endall, done), targetIds.forEach(function (id) {
      state.withoutFadeIn[id] = !1, $el.legend && $el.legend.selectAll("." + config_classes.legendItem + $$.getTargetSelectorSuffix(id)).remove(), $$.data.targets = $$.data.targets.filter(function (t) {
        return t.id !== id;
      });
    })) : void done();
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/drag.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var interactions_drag = ({
  /**
   * Called when dragging.
   * Data points can be selected.
   * @private
   * @param {Object} mouse Object
   */
  drag: function drag(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;

    if (!$$.hasArcType() && config.data_selection_enabled && ( // do nothing if not selectable
    !config.zoom_enabled || $$.zoom.altDomain) && config.data_selection_multiple // skip when single selection because drag is used for multiple selection
    ) {
        var _state$dragStart = state.dragStart,
            sx = _state$dragStart[0],
            sy = _state$dragStart[1],
            mx = mouse[0],
            my = mouse[1],
            minX = Math.min(sx, mx),
            maxX = Math.max(sx, mx),
            minY = config.data_selection_grouped ? state.margin.top : Math.min(sy, my),
            maxY = config.data_selection_grouped ? state.height : Math.max(sy, my);
        main.select("." + config_classes.dragarea).attr("x", minX).attr("y", minY).attr("width", maxX - minX).attr("height", maxY - minY), main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).filter(function (d) {
          return config.data_selection_isselectable(d);
        }).each(function (d, i) {
          var toggle,
              shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
              isSelected = shape.classed(config_classes.SELECTED),
              isIncluded = shape.classed(config_classes.INCLUDED),
              isWithin = !1;

          if (shape.classed(config_classes.circle)) {
            var x = +shape.attr("cx") * 1,
                y = +shape.attr("cy") * 1;
            toggle = $$.togglePoint, isWithin = minX < x && x < maxX && minY < y && y < maxY;
          } else if (shape.classed(config_classes.bar)) {
            var _getPathBox = getPathBox(this),
                _x = _getPathBox.x,
                y = _getPathBox.y,
                width = _getPathBox.width,
                height = _getPathBox.height;

            toggle = $$.togglePath, isWithin = !(maxX < _x || _x + width < minX) && !(maxY < y || y + height < minY);
          } else // line/area selection not supported yet
            return; // @ts-ignore


          isWithin ^ isIncluded && (shape.classed(config_classes.INCLUDED, !isIncluded), shape.classed(config_classes.SELECTED, !isSelected), toggle.call($$, !isSelected, shape, d, i));
        });
      }
  },

  /**
   * Called when the drag starts.
   * Adds and Shows the drag area.
   * @private
   * @param {Object} mouse Object
   */
  dragstart: function dragstart(mouse) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (state.dragStart = mouse, main.select("." + config_classes.chart).append("rect").attr("class", config_classes.dragarea).style("opacity", "0.1"), $$.setDragStatus(!0));
  },

  /**
   * Called when the drag finishes.
   * Removes the drag area.
   * @private
   */
  dragend: function dragend() {
    var $$ = this,
        _$$$config = $$.config,
        config = _$$$config.config,
        main = _$$$config.$el.main;
    $$.hasArcType() || !config.data_selection_enabled || (main.select("." + config_classes.dragarea).transition().duration(100).style("opacity", "0").remove(), main.selectAll("." + config_classes.shape).classed(config_classes.INCLUDED, !1), $$.setDragStatus(!1));
  },
  setDragStatus: function setDragStatus(isDragging) {
    this.dragging = isDragging;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-ease","commonjs2":"d3-ease","amd":"d3-ease","root":"d3"}
var external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_ = __webpack_require__(43);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_flow = ({
  /**
   * Generate flow
   * @memberof ChartInternal
   * @private
   * @param {Object} args
   * @return {Function}
   */
  generateFlow: function generateFlow(args) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    return function () {
      var translateX,
          targets = args.targets,
          flow = args.flow,
          _args$shape$type = args.shape.type,
          drawBar = _args$shape$type.bar,
          drawLine = _args$shape$type.line,
          drawArea = _args$shape$type.area,
          _args$shape$pos = args.shape.pos,
          cx = _args$shape$pos.cx,
          cy = _args$shape$pos.cy,
          xForText = _args$shape$pos.xForText,
          yForText = _args$shape$pos.yForText,
          xv = args.xv,
          duration = args.duration,
          scaleX = 1,
          flowIndex = flow.index,
          flowLength = flow.length,
          flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),
          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),
          orgDomain = $$.scale.x.domain(),
          durationForFlow = flow.duration || duration,
          done = flow.done || function () {},
          wait = $$.generateWait(),
          xgrid = $el.grid.x,
          xgridLines = $el.grid.xLines,
          mainRegion = $el.region.list,
          mainText = $el.text,
          mainBar = $el.bar,
          mainLine = $el.line,
          mainArea = $el.area,
          mainCircle = $el.circle;

      state.flowing = !0, $$.data.targets.forEach(function (d) {
        d.values.splice(0, flowLength);
      });
      // update x domain to generate axis elements for flow
      var domain = $$.updateXDomain(targets, !0, !0); // update elements related to x scale

      $$.updateXGrid && $$.updateXGrid(!0);
      var x = $$.scale.x; // generate transform to flow

      flow.orgDataCount ? flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x) ? translateX = x(orgDomain[0]) - x(domain[0]) : $$.isTimeSeries() ? translateX = x(orgDomain[0]) - x(domain[0]) : translateX = x(flowStart.x) - x(flowEnd.x) : $$.data.targets[0].values.length === 1 ? $$.isTimeSeries() ? (flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0), flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1), translateX = x(flowStart.x) - x(flowEnd.x)) : translateX = diffDomain(domain) / 2 : translateX = x(orgDomain[0]) - x(domain[0]), scaleX = diffDomain(orgDomain) / diffDomain(domain);
      var transform = "translate(" + translateX + ",0) scale(" + scaleX + ",1)";
      $$.hideGridFocus();
      var gt = Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().ease(external_commonjs_d3_ease_commonjs2_d3_ease_amd_d3_ease_root_d3_["easeLinear"]).duration(durationForFlow);
      wait.add([$$.$el.axis.x.transition(gt).call(function (g) {
        return $$.axis.x.setTransition(gt).create(g);
      }), mainBar.transition(gt).attr("transform", transform), mainLine.transition(gt).attr("transform", transform), mainArea.transition(gt).attr("transform", transform), mainCircle.transition(gt).attr("transform", transform), mainText.transition(gt).attr("transform", transform), mainRegion.filter($$.isRegionOnX).transition(gt).attr("transform", transform), xgrid.transition(gt).attr("transform", transform), xgridLines.transition(gt).attr("transform", transform)]), gt.call(wait, function () {
        var isRotated = config.axis_rotated; // remove flowed elements

        if (flowLength) {
          for (var target = {
            shapes: [],
            texts: [],
            eventRects: []
          }, i = 0; i < flowLength; i++) target.shapes.push("." + config_classes.shape + "-" + i), target.texts.push("." + config_classes.text + "-" + i), target.eventRects.push("." + config_classes.eventRect + "-" + i);

          ["shapes", "texts", "eventRects"].forEach(function (v) {
            $el.svg.selectAll("." + config_classes[v]).selectAll(target[v]).remove();
          }), $el.svg.select("." + config_classes.xgrid).remove();
        } // draw again for removing flowed elements and reverting attr


        if (xgrid.size() && xgrid.attr("transform", null).attr(state.xgridAttr), xgridLines.attr("transform", null), xgridLines.select("line").attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? state.width : xv), xgridLines.select("text").attr("x", isRotated ? state.width : 0).attr("y", xv), mainBar.attr("transform", null).attr("d", drawBar), mainLine.attr("transform", null).attr("d", drawLine), mainArea.attr("transform", null).attr("d", drawArea), mainCircle.attr("transform", null), $$.isCirclePoint()) mainCircle.attr("cx", cx).attr("cy", cy);else {
          var xFunc = function (d) {
            return cx(d) - config.point_r;
          },
              yFunc = function (d) {
            return cy(d) - config.point_r;
          };

          mainCircle.attr("x", xFunc).attr("y", yFunc).attr("cx", cx) // when pattern is used, it possibly contain 'circle' also.
          .attr("cy", cy);
        }
        mainText.attr("transform", null).attr("x", xForText).attr("y", yForText).style("fill-opacity", $$.opacityForText.bind($$)), mainRegion.attr("transform", null), mainRegion.select("rect").filter($$.isRegionOnX).attr("x", $$.regionX.bind($$)).attr("width", $$.regionWidth.bind($$)), config.interaction_enabled && $$.redrawEventRect(), done(), state.flowing = !1;
      });
    };
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-drag","commonjs2":"d3-drag","amd":"d3-drag","root":"d3"}
var external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_ = __webpack_require__(44);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/interaction.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/* harmony default export */ var interactions_interaction = ({
  /**
   * Initialize the area that detects the event.
   * Add a container for the zone that detects the event.
   * @private
   */
  initEventRect: function initEventRect() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.eventRects).style("fill-opacity", "0");
  },

  /**
   * Redraws the area that detects the event.
   * @private
   */
  redrawEventRect: function redrawEventRect() {
    var eventRectUpdate,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        isMultipleX = $$.isMultipleX(),
        zoomEnabled = config.zoom_enabled,
        eventRects = $$.$el.main.select("." + config_classes.eventRects).style("cursor", zoomEnabled && zoomEnabled.type !== "drag" ? config.axis_rotated ? "ns-resize" : "ew-resize" : null).classed(config_classes.eventRectsMultiple, isMultipleX).classed(config_classes.eventRectsSingle, !isMultipleX);
    if (eventRects.selectAll("." + config_classes.eventRect).remove(), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), isMultipleX) eventRectUpdate = $el.eventRect.data([0]), eventRectUpdate = $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()).merge(eventRectUpdate);else {
      // Set data and update $el.eventRect
      var xAxisTickValues = $$.getMaxDataCountTarget(); // update data's index value to be alinged with the x Axis

      $$.updateDataIndexByX(xAxisTickValues), $$.updateXs(xAxisTickValues), $$.updatePointClass(!0), eventRects.datum(xAxisTickValues), $el.eventRect = eventRects.selectAll("." + config_classes.eventRect), eventRectUpdate = $el.eventRect.data(function (d) {
        return d;
      }), eventRectUpdate.exit().remove(), eventRectUpdate = $$.generateEventRectsForSingleX(eventRectUpdate.enter()).merge(eventRectUpdate);
    }
    $el.eventRect = eventRectUpdate, $$.updateEventRect(eventRectUpdate), $$.state.inputType !== "touch" || $el.svg.on("touchstart.eventRect") || $$.hasArcType() || $$.bindTouchOnEventRect(isMultipleX);
  },
  bindTouchOnEventRect: function bindTouchOnEventRect(isMultipleX) {
    var startPx,
        $$ = this,
        config = $$.config,
        state = $$.state,
        getEventRect = function () {
      var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0];
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
    },
        getIndex = function (eventRect) {
      var index = eventRect && eventRect.attr("class") && eventRect.attr("class").replace(new RegExp("(" + config_classes.eventRect + "-?|s)", "g"), "") * 1;
      return (isNaN(index) || index === null) && (index = -1), index;
    },
        selectRect = function (context) {
      if (isMultipleX) $$.selectRectForMultipleXs(context);else {
        var eventRect = getEventRect(),
            index = getIndex(eventRect);
        $$.callOverOutForTouch(index), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(context, eventRect, index);
      }
    },
        preventDefault = config.interaction_inputType_touch.preventDefault,
        isPrevented = isBoolean(preventDefault) && preventDefault || !1,
        preventThreshold = !isNaN(preventDefault) && preventDefault || null,
        preventEvent = function (event) {
      var eventType = event.type,
          touch = event.changedTouches[0],
          currentXY = touch["client" + (config.axis_rotated ? "Y" : "X")];
      eventType === "touchstart" ? isPrevented ? event.preventDefault() : preventThreshold !== null && (startPx = currentXY) : eventType === "touchmove" && (isPrevented || startPx === !0 || preventThreshold !== null && Math.abs(startPx - currentXY) >= preventThreshold) && (startPx = !0, event.preventDefault());
    };

    // bind touch events
    $$.$el.svg.on("touchstart.eventRect touchmove.eventRect", function () {
      var eventRect = getEventRect(),
          event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"];

      if (!eventRect.empty() && eventRect.classed(config_classes.eventRect)) {
        // if touch points are > 1, means doing zooming interaction. In this case do not execute tooltip codes.
        if (state.dragging || state.flowing || $$.hasArcType() || event.touches.length > 1) return;
        preventEvent(event), selectRect(this);
      } else $$.unselectRect(), $$.callOverOutForTouch();
    }, !0).on("touchend.eventRect", function () {
      var eventRect = getEventRect();
      !eventRect.empty() && eventRect.classed(config_classes.eventRect) && ($$.hasArcType() || !$$.toggleShape || state.cancelClick) && state.cancelClick && (state.cancelClick = !1);
    }, !0);
  },

  /**
   * Updates the location and size of the eventRect.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   */
  updateEventRect: function updateEventRect(eventRectUpdate) {
    var x,
        y,
        w,
        h,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        xScale = scale.zoom || scale.x,
        eventRectData = eventRectUpdate || $$.$el.eventRect.data(),
        isRotated = config.axis_rotated;
    if ($$.isMultipleX()) // TODO: rotated not supported yet
    x = 0, y = 0, w = state.width, h = state.height;else {
      var rectW, rectX;
      if ($$.isCategorized()) rectW = $$.getEventRectWidth(), rectX = function (d) {
        return xScale(d.x) - rectW / 2;
      };else {
        var getPrevNextX = function (d) {
          var index = d.index;
          return {
            prev: $$.getPrevX(index),
            next: $$.getNextX(index)
          };
        };

        rectW = function (d) {
          var x = getPrevNextX(d); // if there this is a single data point make the eventRect full width (or height)

          return x.prev === null && x.next === null ? isRotated ? state.height : state.width : (x.prev === null && (x.prev = xScale.domain()[0]), x.next === null && (x.next = xScale.domain()[1]), Math.max(0, (xScale(x.next) - xScale(x.prev)) / 2));
        }, rectX = function (d) {
          var x = getPrevNextX(d),
              thisX = d.x;
          // if there this is a single data point position the eventRect at 0
          return x.prev === null && x.next === null ? 0 : (x.prev === null && (x.prev = xScale.domain()[0]), (xScale(thisX) + xScale(x.prev)) / 2);
        };
      }
      x = isRotated ? 0 : rectX, y = isRotated ? rectX : 0, w = isRotated ? state.width : rectW, h = isRotated ? rectW : state.height;
    }
    eventRectData.attr("class", $$.classEvent.bind($$)).attr("x", x).attr("y", y).attr("width", w).attr("height", h);
  },
  selectRectForSingle: function selectRectForSingle(context, eventRect, index) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isSelectionEnabled = config.data_selection_enabled,
        isSelectionGrouped = config.data_selection_grouped,
        isTooltipGrouped = config.tooltip_grouped,
        selectedData = $$.getAllValuesOnIndex(index);
    isTooltipGrouped && ($$.showTooltip(selectedData, context), $$.showGridFocus(selectedData), !isSelectionEnabled || isSelectionGrouped) || main.selectAll("." + config_classes.shape + "-" + index).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED, !0), isSelectionEnabled && eventRect.style("cursor", isSelectionGrouped ? "pointer" : null), isTooltipGrouped || ($$.hideGridFocus(), $$.hideTooltip(), !isSelectionGrouped && $$.expandCirclesBars(index));
    }).filter(function (d) {
      return $$.isWithinShape(this, d);
    }).call(function (selected) {
      var d = selected.data();
      isSelectionEnabled && (isSelectionGrouped || config.data_selection_isselectable(d)) && eventRect.style("cursor", "pointer"), isTooltipGrouped || ($$.showTooltip(d, context), $$.showGridFocus(d), $$.unexpandCircles(), selected.each(function (d) {
        return $$.expandCirclesBars(index, d.id);
      }));
    });
  },
  expandCirclesBars: function expandCirclesBars(index, id, reset) {
    var $$ = this,
        config = $$.config;
    config.point_focus_expand_enabled && $$.expandCircles(index, id, reset), $$.expandBars(index, id, reset);
  },
  selectRectForMultipleXs: function selectRectForMultipleXs(context) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    // do nothing when dragging
    if (!($$.dragging || $$.hasArcType(targetsToShow))) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(context),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      if (state.mouseover && (!closest || closest.id !== state.mouseover.id) && (config.data_onout.call($$.api, state.mouseover), state.mouseover = undefined), !closest) return void $$.unselectRect();
      var sameXData = $$.isBubbleType(closest) || $$.isScatterType(closest) || !config.tooltip_grouped ? [closest] : $$.filterByX(targetsToShow, closest.x),
          selectedData = sameXData.map(function (d) {
        return $$.addName(d);
      }); // show tooltip when cursor is close to some point

      $$.showTooltip(selectedData, context), $$.expandCirclesBars(closest.index, closest.id, !0), $$.showGridFocus(selectedData), ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && ($$.$el.svg.select("." + config_classes.eventRect).style("cursor", "pointer"), !state.mouseover && (config.data_onover.call($$.api, closest), state.mouseover = closest));
    }
  },

  /**
   * Unselect EventRect.
   * @private
   */
  unselectRect: function unselectRect() {
    var $$ = this;
    $$.$el.svg.select("." + config_classes.eventRect).style("cursor", null), $$.hideGridFocus(), $$.hideTooltip(), $$._handleLinkedCharts(!1), $$.unexpandCircles(), $$.unexpandBars();
  },

  /**
   * Handle data.onover/out callback options
   * @param {Boolean} isOver
   * @param {Number|Object} d
   * @private
   */
  setOverOut: function setOverOut(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isArc = isObject(d);

    // Call event handler
    if (isArc || d !== -1) {
      var callback = config[isOver ? "data_onover" : "data_onout"].bind($$.api);
      if (config.color_onover && $$.setOverColor(isOver, d, isArc), isArc) callback(d, main.select("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).node());else if (!config.tooltip_grouped) {
        var callee = $$.setOverOut,
            last = callee.last || [],
            shape = main.selectAll("." + config_classes.shape + "-" + d).filter(function (d) {
          return $$.isWithinShape(this, d);
        });
        shape.each(function (d) {
          var _this = this;

          (last.length === 0 || last.every(function (v) {
            return v !== _this;
          })) && (callback(d, this), last.push(this));
        }), last.length > 0 && shape.empty() && (callback = config.data_onout.bind($$.api), last.forEach(function (v) {
          return callback(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(v).datum(), v);
        }), last = []), callee.last = last;
      } else isOver && $$.expandCirclesBars(d, null, !0), $$.isMultipleX() || main.selectAll("." + config_classes.shape + "-" + d).each(function (d) {
        callback(d, this);
      });
    }
  },

  /**
   * Call data.onover/out callback for touch event
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  callOverOutForTouch: function callOverOutForTouch(d) {
    var $$ = this,
        callee = $$.callOverOutForTouch,
        last = callee.last;
    (isObject(d) && last ? d.id !== last.id : d !== last) && ((last || isNumber(last)) && $$.setOverOut(!1, last), (d || isNumber(d)) && $$.setOverOut(!0, d), callee.last = d);
  },

  /**
   * Return draggable selection function
   * @return {Function}
   * @private
   */
  getDraggableSelection: function getDraggableSelection() {
    var $$ = this,
        config = $$.config;
    return config.interaction_enabled && config.data_selection_draggable && $$.drag ? Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().on("drag", function () {
      // @ts-ignore
      $$.drag(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("start", function () {
      // @ts-ignore
      $$.dragstart(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this));
    }).on("end", function () {
      $$.dragend();
    }) : function () {};
  },

  /**
   * Create eventRect for each data on the x-axis.
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForSingleX: function generateEventRectsForSingleX(eventRectEnter) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        rect = eventRectEnter.append("rect").attr("class", $$.classEvent.bind($$)).style("cursor", config.data_selection_enabled && config.data_selection_grouped ? "pointer" : null).on("click", function (d) {
      $$.clickHandlerForSingleX.bind(this)(d, $$);
    }).call($$.getDraggableSelection());
    return state.inputType === "mouse" && rect.on("mouseover", function (d) {
      state.dragging || state.flowing || $$.hasArcType() || config.tooltip_grouped && $$.setOverOut(!0, d.index);
    }).on("mousemove", function (d) {
      // do nothing while dragging/flowing
      if (!(state.dragging || state.flowing || $$.hasArcType())) {
        var index = d.index,
            eventRect = $$.$el.svg.select("." + config_classes.eventRect + "-" + index);
        $$.isStepType(d) && config.line_step_type === "step-after" && Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[0] < $$.scale.x($$.getXValue(d.id, index)) && (index -= 1), index === -1 ? $$.unselectRect() : $$.selectRectForSingle(this, eventRect, index), config.tooltip_grouped || $$.setOverOut(index !== -1, d.index);
      }
    }).on("mouseout", function (d) {
      !config || $$.hasArcType() || ($$.unselectRect(), $$.setOverOut(!1, d.index));
    }), rect;
  },
  clickHandlerForSingleX: function clickHandlerForSingleX(d, ctx) {
    var $$ = ctx,
        config = $$.config,
        state = $$.state;
    if ($$.hasArcType() || !$$.toggleShape || state.cancelClick) return void (state.cancelClick && (state.cancelClick = !1));
    var index = d.index;
    $$.$el.main.selectAll("." + config_classes.shape + "-" + index).each(function (d2) {
      (config.data_selection_grouped || $$.isWithinShape(this, d2)) && ($$.toggleShape(this, d2, index), config.data_onclick.call($$.api, d2, this));
    });
  },

  /**
   * Create an eventRect,
   * Register touch and drag events.
   * @private
   * @param {Object} d3.select(CLASS.eventRects) object.
   * @returns {Object} d3.select(CLASS.eventRects) object.
   */
  generateEventRectsForMultipleXs: function generateEventRectsForMultipleXs(eventRectEnter) {
    var $$ = this,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        inputType = _$$$state.inputType,
        rect = eventRectEnter.append("rect").attr("x", 0).attr("y", 0).attr("width", width).attr("height", height).attr("class", config_classes.eventRect).on("click", function () {
      $$.clickHandlerForMultipleXS.bind(this)($$);
    }).call($$.getDraggableSelection());
    return inputType === "mouse" && rect.on("mouseover mousemove", function () {
      $$.selectRectForMultipleXs(this);
    }).on("mouseout", function () {
      !$$.config || $$.hasArcType() || $$.unselectRect();
    }), rect;
  },
  clickHandlerForMultipleXS: function clickHandlerForMultipleXS(ctx) {
    var $$ = ctx,
        config = $$.config,
        targetsToShow = $$.filterTargetsToShow($$.data.targets);

    if (!$$.hasArcType(targetsToShow)) {
      var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this),
          closest = $$.findClosestFromTargets(targetsToShow, mouse);
      !closest || ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) && $$.$el.main.selectAll("." + config_classes.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll("." + config_classes.shape + "-" + closest.index).each(function () {
        (config.data_selection_grouped || $$.isWithinShape(this, closest)) && ($$.toggleShape(this, closest, closest.index), config.data_onclick.call($$.api, closest, this));
      });
    } // select if selection enabled

  },

  /**
   * Dispatch a mouse event.
   * @private
   * @param {String} type event type
   * @param {Number} index Index of eventRect
   * @param {Array} mouse x and y coordinate value
   */
  dispatchEvent: function dispatchEvent(type, index, mouse) {
    var $$ = this,
        isMultipleX = $$.isMultipleX(),
        selector = "." + (isMultipleX ? config_classes.eventRect : config_classes.eventRect + "-" + index),
        eventRect = $$.$el.main.select(selector).node(),
        _eventRect$getBoundin = eventRect.getBoundingClientRect(),
        width = _eventRect$getBoundin.width,
        left = _eventRect$getBoundin.left,
        top = _eventRect$getBoundin.top,
        x = left + (mouse ? mouse[0] : 0) + (isMultipleX || $$.config.axis_rotated ? 0 : width / 2),
        y = top + (mouse ? mouse[1] : 0);

    emulateEvent[/^(mouse|click)/.test(type) ? "mouse" : "touch"](eventRect, type, {
      screenX: x,
      screenY: y,
      clientX: x,
      clientY: y
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/interactions/subchart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var interactions_subchart = ({
  /**
   * Initialize the brush.
   * @private
   */
  initBrush: function initBrush() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        isRotated = config.axis_rotated;
    $$.brush = isRotated ? Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushY"])() : Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushX"])();

    // set "brush" event
    var lastDomain,
        timeout,
        brushHandler = function () {
      $$.redrawForBrush();
    },
        getBrushSize = function () {
      var brush = $$.$el.svg.select("." + config_classes.brush + " .overlay"),
          brushSize = {
        width: 0,
        height: 0
      };
      return brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), brushSize[isRotated ? "width" : "height"];
    };

    // set the brush extent
    $$.brush.on("start", function () {
      $$.state.inputType === "touch" && $$.hideTooltip(), brushHandler();
    }).on("brush", brushHandler).on("end", function () {
      lastDomain = scale.x.orgDomain();
    }), $$.brush.updateResize = function () {
      var _this = this;

      timeout && clearTimeout(timeout), timeout = setTimeout(function () {
        var selection = _this.getSelection();

        lastDomain && Object(external_commonjs_d3_brush_commonjs2_d3_brush_amd_d3_brush_root_d3_["brushSelection"])(selection.node()) && _this.move(selection, lastDomain.map(scale.subX.orgScale()));
      }, 0);
    }, $$.brush.update = function () {
      var extent = this.extent()();
      return extent[1].filter(function (v) {
        return isNaN(v);
      }).length === 0 && $$.context && $$.context.select("." + config_classes.brush).call(this), this;
    }, $$.brush.scale = function (scale) {
      var h = config.subchart_size_height || getBrushSize(),
          extent = $$.getExtent();
      // [[x0, y0], [x1, y1]], where [x0, y0] is the top-left corner and [x1, y1] is the bottom-right corner
      // when extent updates, brush selection also be re-applied
      // https://github.com/d3/d3/issues/2918
      !extent && scale.range ? extent = [[0, 0], [scale.range()[1], h]] : isArray(extent) && (extent = extent.map(function (v, i) {
        return [v, i > 0 ? h : i];
      })), isRotated && extent[1].reverse(), this.extent(extent), this.update();
    }, $$.brush.getSelection = function () {
      return (// @ts-ignore
        $$.context ? $$.context.select("." + config_classes.brush) : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])([])
      );
    };
  },

  /**
   * Initialize the subchart.
   * @private
   */
  initSubchart: function initSubchart() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el,
        visibility = config.subchart_show ? "visible" : "hidden",
        clipId = clip.id + "-subchart",
        clipPath = $$.getClipPath(clipId);
    clip.idSubchart = clipId, $$.appendClip($el.defs, clipId), $$.initBrush(), $$.context = $el.svg.append("g").attr("transform", $$.getTranslate("context"));
    var context = $$.context;
    // Define g for chart area
    // Define g for bar chart area
    // Define g for line chart area
    // Add extent rect for Brush
    // ATTENTION: This must be called AFTER chart added
    // Add Axis
    context.style("visibility", visibility), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.chart), $$.hasType("bar") && context.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars), context.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines), context.append("g").attr("clip-path", clipPath).attr("class", config_classes.brush).call($$.brush), $el.axis.subX = context.append("g").attr("class", config_classes.axisX).attr("transform", $$.getTranslate("subX")).attr("clip-path", config.axis_rotated ? "" : clip.pathXAxis).style("visibility", config.subchart_axis_x_show ? visibility : "hidden");
  },

  /**
   * Update sub chart
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForSubchart: function updateTargetsForSubchart(targets) {
    var $$ = this,
        config = $$.config,
        context = $$.context,
        state = $$.state,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$);

    if (config.subchart_show) {
      // -- Bar --//
      var contextBarUpdate = context.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", classChartBar),
          contextBarEnter = contextBarUpdate.enter().append("g").style("opacity", "0").attr("class", classChartBar).merge(contextBarUpdate);
      contextBarEnter.append("g").attr("class", classBars);
      // -- Line --//
      var contextLineUpdate = context.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", classChartLine),
          contextLineEnter = contextLineUpdate.enter().append("g").style("opacity", "0").attr("class", classChartLine).merge(contextLineUpdate);
      // Lines for each data
      // Area
      // -- Brush --//
      contextLineEnter.append("g").attr("class", classLines), $$.hasType("area") && contextLineEnter.append("g").attr("class", classAreas), context.selectAll("." + config_classes.brush + " rect").attr(config.axis_rotated ? "width" : "height", config.axis_rotated ? state.width2 : state.height2);
    }
  },

  /**
   * Update the bar of the sub chart
   * @private
   * @param {Object} durationForExit
   */
  updateBarForSubchart: function updateBarForSubchart(durationForExit) {
    var $$ = this;
    $$.contextBar = $$.context.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data($$.barData.bind($$)), $$.contextBar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextBar = $$.contextBar.enter().append("path").attr("class", $$.classBar.bind($$)).style("stroke", "none").style("fill", $$.color).merge($$.contextBar).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the bar of the subchart
   * @private
   * @param {String} path in subchart bar
   * @param {Boolean} whether or not to transition.
   * @param {Number} transition duration
   */
  redrawBarForSubchart: function redrawBarForSubchart(drawBarOnSub, withTransition, duration) {
    var contextBar = withTransition ? this.contextBar.transition(getRandom()).duration(duration) : this.contextBar;
    contextBar.attr("d", drawBarOnSub).style("opacity", "1");
  },

  /**
   * Update the line of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateLineForSubchart: function updateLineForSubchart(durationForExit) {
    var $$ = this;
    $$.contextLine = $$.context.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), $$.contextLine.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextLine = $$.contextLine.enter().append("path").attr("class", $$.classLine.bind($$)).style("stroke", $$.color).merge($$.contextLine).style("opacity", $$.initialOpacity.bind($$));
  },

  /**
   * Redraw the line of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawLineForSubchart: function redrawLineForSubchart(drawLineOnSub, withTransition, duration) {
    var contextLine = withTransition ? this.contextLine.transition(getRandom()).duration(duration) : this.contextLine;
    contextLine.attr("d", drawLineOnSub).style("opacity", "1");
  },

  /**
   * Update the area of the sub chart
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateAreaForSubchart: function updateAreaForSubchart(durationForExit) {
    var $$ = this;
    $$.contextArea = $$.context.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), $$.contextArea.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $$.contextArea = $$.contextArea.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.color).style("opacity", function () {
      return $$.state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($$.contextArea).style("opacity", "0");
  },

  /**
   * Redraw the area of the subchart
   * @private
   * @param {String} path in subchart line
   * @param {Boolean} whether or not to transition
   * @param {Number} transition duration
   */
  redrawAreaForSubchart: function redrawAreaForSubchart(drawAreaOnSub, withTransition, duration) {
    var contextArea = withTransition ? this.contextArea.transition(getRandom()).duration(duration) : this.contextArea;
    contextArea.attr("d", drawAreaOnSub).style("fill", this.color).style("opacity", this.state.orgAreaOpacity);
  },

  /**
   * Redraw subchart.
   * @private
   * @param {Boolean} withSubchart whether or not to show subchart
   * @param {Number} duration duration
   * @param {Object} shape Shape's info
   */
  redrawSubchart: function redrawSubchart(withSubchart, duration, shape) {
    var $$ = this,
        config = $$.config;
    $$.context.style("visibility", config.subchart_show ? "visible" : "hidden"), config.subchart_show && (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].type === "zoom" && $$.brush.update(), withSubchart && (!brushEmpty($$) && $$.brush.update(), Object.keys(shape.type).forEach(function (v) {
      var name = capitalize(v),
          draw = $$["generateDraw" + name](shape.indices[v], !0);
      $$["update" + name + "ForSubchart"](duration), $$["redraw" + name + "ForSubchart"](draw, duration, duration);
    })));
  },

  /**
   * Redraw the brush.
   * @private
   */
  redrawForBrush: function redrawForBrush() {
    var $$ = this,
        _$$$config = $$.config,
        subchart_onbrush = _$$$config.subchart_onbrush,
        withY = _$$$config.zoom_rescale;
    $$.redraw({
      withTransition: !1,
      withY: withY,
      withSubchart: !1,
      withUpdateXDomain: !0,
      withDimension: !1
    }), subchart_onbrush.call($$.api, $$.scale.x.orgDomain());
  },

  /**
   * Transform context
   * @private
   * @param {Boolean} indicates transition is enabled
   * @param {Object} The return value of the generateTransitions method of Axis.
   */
  transformContext: function transformContext(withTransition, transitions) {
    var subXAxis,
        $$ = this;
    transitions && transitions.axisSubX ? subXAxis = transitions.axisSubX : (subXAxis = $$.context.select("." + config_classes.axisX), withTransition && (subXAxis = subXAxis.transition())), $$.context.attr("transform", $$.getTranslate("context")), subXAxis.attr("transform", $$.getTranslate("subX"));
  },

  /**
   * Get extent value
   * @private
   * @returns {Array} default extent
   */
  getExtent: function getExtent() {
    var $$ = this,
        scale = $$.scale,
        extent = $$.config.axis_x_extent;
    return extent && (isFunction(extent) ? extent = extent($$.getXDomain($$.data.targets), scale.subX) : $$.isTimeSeries() && extent.every(isNaN) && (extent = extent.map(function (v) {
      return scale.subX($$.parseDate(v));
    }))), extent;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-zoom","commonjs2":"d3-zoom","amd":"d3-zoom","root":"d3"}
var external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_ = __webpack_require__(45);

// CONCATENATED MODULE: ./src/ChartInternal/interactions/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var interactions_zoom = ({
  /**
   * Initialize zoom.
   * @private
   */
  initZoom: function initZoom() {
    var $$ = this;
    $$.scale.zoom = null, $$.generateZoom(), $$.initZoomBehaviour();
  },

  /**
   * Bind zoom event
   * @param {Boolean} bind Weather bind or unbound
   * @private
   */
  bindZoomEvent: function bindZoomEvent(bind) {
    bind === void 0 && (bind = !0);
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        zoomEnabled = config.zoom_enabled;
    $$.redrawEventRect();
    var eventRects = main.select("." + config_classes.eventRects);
    zoomEnabled && bind ? !config.subchart_show && $$.bindZoomOnEventRect(eventRects, zoomEnabled.type) : bind === !1 && ($$.api.unzoom(), eventRects.on(".zoom", null).on(".drag", null));
  },

  /**
   * Generate zoom
   * @private
   */
  generateZoom: function generateZoom() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        scale = $$.scale,
        zoom = Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoom"])().duration(0).on("start", $$.onZoomStart.bind($$)).on("zoom", $$.onZoom.bind($$)).on("end", $$.onZoomEnd.bind($$));
    // get zoom extent
    // @ts-ignore
    // @ts-ignore

    /**
     * Update scale according zoom transform value
     * @param {Object} transform
     * @private
     */
    // @ts-ignore
    zoom.orgScaleExtent = function () {
      var extent = config.zoom_extent || [1, 10];
      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];
    }, zoom.updateScaleExtent = function () {
      var ratio = diffDomain($$.scale.x.orgDomain()) / diffDomain($$.getZoomDomain()),
          extent = this.orgScaleExtent();
      return this.scaleExtent([extent[0] * ratio, extent[1] * ratio]), this;
    }, zoom.updateTransformScale = function (transform) {
      org.xScale && org.xScale.range(scale.x.range());
      // rescale from the original scale
      var newScale = transform[config.axis_rotated ? "rescaleY" : "rescaleX"](org.xScale || scale.x),
          domain = $$.trimXDomain(newScale.domain()),
          rescale = config.zoom_rescale;
      newScale.domain(domain, org.xDomain), scale.zoom = $$.getCustomizedScale(newScale), $$.axis.x.scale(scale.zoom), rescale && (!org.xScale && (org.xScale = scale.x.copy()), scale.x.domain(domain));
    }, $$.zoom = zoom;
  },

  /**
   * 'start' event listener
   * @private
   */
  onZoomStart: function onZoomStart() {
    var $$ = this,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    event && ($$.zoom.startEvent = event, callFn($$.config.zoom_onzoomstart, $$.api, event));
  },

  /**
   * 'zoom' event listener
   * @private
   */
  onZoom: function onZoom() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        org = $$.org,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
        sourceEvent = event.sourceEvent;

    if (config.zoom_enabled && event.sourceEvent && $$.filterTargetsToShow($$.data.targets).length !== 0 && (scale.zoom || !(sourceEvent.type.indexOf("touch") > -1) || sourceEvent.touches.length !== 1)) {
      var isMousemove = sourceEvent.type === "mousemove",
          isZoomOut = sourceEvent.wheelDelta < 0,
          transform = event.transform;
      !isMousemove && isZoomOut && scale.x.domain().every(function (v, i) {
        return v !== org.xDomain[i];
      }) && scale.x.domain(org.xDomain), $$.zoom.updateTransformScale(transform), $$.isCategorized() && scale.x.orgDomain()[0] === org.xDomain[0] && scale.x.domain([org.xDomain[0] - 1e-10, scale.x.orgDomain()[1]]), $$.redraw({
        withTransition: !1,
        withY: config.zoom_rescale,
        withSubchart: !1,
        withEventRect: !1,
        withDimension: !1
      }), $$.state.cancelClick = isMousemove, callFn(config.zoom_onzoom, $$.api, scale.zoom.domain());
    }
  },

  /**
   * 'end' event listener
   * @private
   */
  onZoomEnd: function onZoomEnd() {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        startEvent = $$.zoom.startEvent,
        event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"] && external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent;
    startEvent && startEvent.type.indexOf("touch") > -1 && (startEvent = startEvent.changedTouches[0], event = event.changedTouches[0]);
    // if click, do nothing. otherwise, click interaction will be canceled.
    !startEvent || event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY || ($$.redrawEventRect(), $$.updateZoom(), callFn(config.zoom_onzoomend, $$.api, scale[scale.zoom ? "zoom" : "subX"].domain()));
  },

  /**
   * Get zoom domain
   * @returns {Array} zoom domain
  	 * @private
   */
  getZoomDomain: function getZoomDomain() {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        _org$xDomain = org.xDomain,
        min = _org$xDomain[0],
        max = _org$xDomain[1];
    return isDefined(config.zoom_x_min) && (min = getMinMax("min", [min, config.zoom_x_min])), isDefined(config.zoom_x_max) && (max = getMinMax("max", [max, config.zoom_x_max])), [min, max];
  },

  /**
   * Update zoom
   * @param {Boolean} force Force unzoom
   * @private
   */
  updateZoom: function updateZoom(force) {
    var $$ = this,
        _$$$scale = $$.scale,
        subX = _$$$scale.subX,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom;

    if (zoom) {
      var zoomDomain = zoom.domain(),
          xDomain = subX.domain(),
          delta = .015,
          isfullyShown = (zoomDomain[0] <= xDomain[0] || zoomDomain[0] - delta <= xDomain[0]) && (xDomain[1] <= zoomDomain[1] || xDomain[1] <= zoomDomain[1] - delta);
      (force || isfullyShown) && ($$.axis.x.scale(subX), x.domain(subX.orgDomain()), zoom = null);
    }
  },

  /**
   * Attach zoom event on <rect>
   * @private
   */
  bindZoomOnEventRect: function bindZoomOnEventRect(eventRects, type) {
    var $$ = this,
        behaviour = type === "drag" ? $$.zoomBehaviour : $$.zoom;
    eventRects.call(behaviour).on("dblclick.zoom", null);
  },

  /**
   * Initialize the drag behaviour used for zooming.
   * @private
   */
  initZoomBehaviour: function initZoomBehaviour() {
    var zoomRect,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        start = 0,
        end = 0,
        prop = {
      axis: isRotated ? "y" : "x",
      attr: isRotated ? "height" : "width",
      index: isRotated ? 1 : 0
    };
    $$.zoomBehaviour = Object(external_commonjs_d3_drag_commonjs2_d3_drag_amd_d3_drag_root_d3_["drag"])().clickDistance(4).on("start", function () {
      // @ts-ignore
      $$.setDragStatus(!0), zoomRect || (zoomRect = $$.$el.main.append("rect").attr("clip-path", state.clip.path).attr("class", config_classes.zoomBrush).attr("width", isRotated ? state.width : 0).attr("height", isRotated ? 0 : state.height)), start = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], end = start, zoomRect.attr(prop.axis, start).attr(prop.attr, 0), $$.onZoomStart();
    }).on("drag", function () {
      // @ts-ignore
      end = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(this)[prop.index], zoomRect.attr(prop.axis, Math.min(start, end)).attr(prop.attr, Math.abs(end - start));
    }).on("end", function () {
      var _ref,
          scale = $$.scale.zoom || $$.scale.x;

      if ($$.setDragStatus(!1), zoomRect.attr(prop.axis, 0).attr(prop.attr, 0), start > end && (_ref = [end, start], start = _ref[0], end = _ref[1], _ref), start < 0 && (end += Math.abs(start), start = 0), start !== end) $$.api.zoom([start, end].map(function (v) {
        return scale.invert(v);
      })), $$.onZoomEnd();else if ($$.isMultipleX()) $$.clickHandlerForMultipleXS.bind(this)($$);else {
        var _event = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].sourceEvent || external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"],
            _ref2 = "clientX" in _event ? [_event.clientX, _event.clientY] : [_event.x, _event.y],
            x = _ref2[0],
            y = _ref2[1],
            target = browser_doc.elementFromPoint(x, y);

        $$.clickHandlerForSingleX.bind(target)(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum(), $$);
      }
    });
  },
  setZoomResetButton: function setZoomResetButton() {
    var $$ = this,
        config = $$.config,
        resetButton = config.zoom_resetButton;
    resetButton && config.zoom_enabled.type === "drag" && ($$.zoom.resetBtn ? $$.zoom.resetBtn.style("display", null) : $$.zoom.resetBtn = $$.$el.chart.append("div").classed(config_classes.button, !0).append("span").on("click", function () {
      isFunction(resetButton.onclick) && resetButton.onclick(this), $$.api.unzoom();
    }).classed(config_classes.buttonZoomReset, !0).text(resetButton.text || "Reset Zoom"));
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var category = ({
  /**
   * Category Name
   * @private
   * @param {Number} index
   * @returns {String} gategory Name
   */
  categoryName: function categoryName(i) {
    var categories = this.config.axis_x_categories;
    return i < categories.length ? categories[i] : i;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/class.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_class = ({
  generateClass: function generateClass(prefix, targetId) {
    return " " + prefix + " " + (prefix + this.getTargetSelectorSuffix(targetId));
  },
  classText: function classText(d) {
    return this.generateClass(config_classes.text, d.index);
  },
  classTexts: function classTexts(d) {
    return this.generateClass(config_classes.texts, d.id);
  },
  classShape: function classShape(d) {
    return this.generateClass(config_classes.shape, d.index);
  },
  classShapes: function classShapes(d) {
    return this.generateClass(config_classes.shapes, d.id);
  },
  generateExtraLineClass: function generateExtraLineClass() {
    var $$ = this,
        classes = $$.config.line_classes || [],
        ids = [];
    return function (d) {
      var id = d.id || d.data && d.data.id || d;
      return ids.indexOf(id) < 0 && ids.push(id), classes[ids.indexOf(id) % classes.length];
    };
  },
  classLine: function classLine(d) {
    return this.classShape(d) + this.generateClass(config_classes.line, d.id);
  },
  classLines: function classLines(d) {
    return this.classShapes(d) + this.generateClass(config_classes.lines, d.id);
  },
  classCircle: function classCircle(d) {
    return this.classShape(d) + this.generateClass(config_classes.circle, d.index);
  },
  classCircles: function classCircles(d) {
    return this.classShapes(d) + this.generateClass(config_classes.circles, d.id);
  },
  classBar: function classBar(d) {
    return this.classShape(d) + this.generateClass(config_classes.bar, d.index);
  },
  classBars: function classBars(d) {
    return this.classShapes(d) + this.generateClass(config_classes.bars, d.id);
  },
  classArc: function classArc(d) {
    return this.classShape(d.data) + this.generateClass(config_classes.arc, d.data.id);
  },
  classArcs: function classArcs(d) {
    return this.classShapes(d.data) + this.generateClass(config_classes.arcs, d.data.id);
  },
  classArea: function classArea(d) {
    return this.classShape(d) + this.generateClass(config_classes.area, d.id);
  },
  classAreas: function classAreas(d) {
    return this.classShapes(d) + this.generateClass(config_classes.areas, d.id);
  },
  classRegion: function classRegion(d, i) {
    return this.generateClass(config_classes.region, i) + " " + ("class" in d ? d.class : "");
  },
  classEvent: function classEvent(d) {
    return this.generateClass(config_classes.eventRect, d.index);
  },
  classTarget: function classTarget(id) {
    var additionalClassSuffix = this.config.data_classes[id],
        additionalClass = "";
    return additionalClassSuffix && (additionalClass = " " + config_classes.target + "-" + additionalClassSuffix), this.generateClass(config_classes.target, id) + additionalClass;
  },
  classFocus: function classFocus(d) {
    return this.classFocused(d) + this.classDefocused(d);
  },
  classFocused: function classFocused(d) {
    return " " + (this.state.focusedTargetIds.indexOf(d.id) >= 0 ? config_classes.focused : "");
  },
  classDefocused: function classDefocused(d) {
    return " " + (this.state.defocusedTargetIds.indexOf(d.id) >= 0 ? config_classes.defocused : "");
  },
  classChartText: function classChartText(d) {
    return config_classes.chartText + this.classTarget(d.id);
  },
  classChartLine: function classChartLine(d) {
    return config_classes.chartLine + this.classTarget(d.id);
  },
  classChartBar: function classChartBar(d) {
    return config_classes.chartBar + this.classTarget(d.id);
  },
  classChartArc: function classChartArc(d) {
    return config_classes.chartArc + this.classTarget(d.data.id);
  },
  classChartRadar: function classChartRadar(d) {
    return config_classes.chartRadar + this.classTarget(d.id);
  },
  getTargetSelectorSuffix: function getTargetSelectorSuffix(targetId) {
    return targetId || targetId === 0 ? ("-" + targetId).replace(/[\s?!@#$%^&*()_=+,.<>'":;\[\]\/|~`{}\\]/g, "-") : "";
  },
  selectorTarget: function selectorTarget(id, prefix) {
    return (prefix || "") + "." + (config_classes.target + this.getTargetSelectorSuffix(id));
  },
  selectorTargets: function selectorTargets(idsValue, prefix) {
    var $$ = this,
        ids = idsValue || [];
    return ids.length ? ids.map(function (id) {
      return $$.selectorTarget(id, prefix);
    }) : null;
  },
  selectorLegend: function selectorLegend(id) {
    return "." + (config_classes.legendItem + this.getTargetSelectorSuffix(id));
  },
  selectorLegends: function selectorLegends(ids) {
    var $$ = this;
    return ids && ids.length ? ids.map(function (id) {
      return $$.selectorLegend(id);
    }) : null;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/clip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_clip = ({
  initClip: function initClip() {
    var $$ = this,
        clip = $$.state.clip;
    // MEMO: clipId needs to be unique because it conflicts when multiple charts exist
    // Define 'clip-path' attribute values
    clip.id = $$.state.datetimeId + "-clip", clip.idXAxis = clip.id + "-xaxis", clip.idYAxis = clip.id + "-yaxis", clip.idGrid = clip.id + "-grid", clip.path = $$.getClipPath(clip.id), clip.pathXAxis = $$.getClipPath(clip.idXAxis), clip.pathYAxis = $$.getClipPath(clip.idYAxis), clip.pathGrid = $$.getClipPath(clip.idGrid);
  },
  getClipPath: function getClipPath(id) {
    var $$ = this,
        config = $$.config;
    if (!config.clipPath && /-clip$/.test(id) || !config.axis_x_clipPath && /-clip-xaxis$/.test(id) || !config.axis_y_clipPath && /-clip-yaxis$/.test(id)) return null;
    var isIE9 = !!win.navigator && win.navigator.appVersion.toLowerCase().indexOf("msie 9.") >= 0;
    return "url(" + (isIE9 ? "" : browser_doc.URL.split("#")[0]) + "#" + id + ")";
  },
  appendClip: function appendClip(parent, id) {
    return parent.append("clipPath").attr("id", id).append("rect");
  },
  getAxisClipX: function getAxisClipX(forHorizontal) {
    var margin = this.state.margin,
        left = Math.max(30, margin.left); // axis line width + padding for left

    return forHorizontal ? -(1 + left) : -(left - 1);
  },
  getAxisClipY: function getAxisClipY(forHorizontal) {
    var margin = this.state.margin;
    return forHorizontal ? -20 : -margin.top;
  },
  getXAxisClipX: function getXAxisClipX() {
    var $$ = this;
    return $$.getAxisClipX(!$$.config.axis_rotated);
  },
  getXAxisClipY: function getXAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY(!$$.config.axis_rotated);
  },
  getYAxisClipX: function getYAxisClipX() {
    var $$ = this;
    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);
  },
  getYAxisClipY: function getYAxisClipY() {
    var $$ = this;
    return $$.getAxisClipY($$.config.axis_rotated);
  },
  getAxisClipWidth: function getAxisClipWidth(forHorizontal) {
    var $$ = this,
        _$$$state = $$.state,
        margin = _$$$state.margin,
        width = _$$$state.width,
        left = Math.max(30, margin.left),
        right = Math.max(30, margin.right);
    // width + axis line width + padding for left/right
    return forHorizontal ? width + 2 + left + right : margin.left + 20;
  },
  getAxisClipHeight: function getAxisClipHeight(forHorizontal) {
    var _this$state = this.state,
        margin = _this$state.margin,
        height = _this$state.height; // less than 20 is not enough to show the axis label 'outer' without legend

    return (forHorizontal ? margin.bottom : margin.top + height) + 20;
  },
  getXAxisClipWidth: function getXAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth(!$$.config.axis_rotated);
  },
  getXAxisClipHeight: function getXAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight(!$$.config.axis_rotated);
  },
  getYAxisClipWidth: function getYAxisClipWidth() {
    var $$ = this;
    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);
  },
  getYAxisClipHeight: function getYAxisClipHeight() {
    var $$ = this;
    return $$.getAxisClipHeight($$.config.axis_rotated);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */





/**
 * Set pattern's background color
 * (it adds a <rect> element to simulate bg-color)
 * @param {SVGPatternElement} pattern SVG pattern element
 * @param {String} color Color string
 * @param {String} id ID to be set
 * @return {{id: string, node: SVGPatternElement}}
 * @private
 */

var colorizePattern = function (pattern, color, id) {
  var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(pattern.cloneNode(!0));
  return node.attr("id", id).insert("rect", ":first-child").attr("width", node.attr("width")).attr("height", node.attr("height")).style("fill", color), {
    id: id,
    node: node.node()
  };
},
    schemeCategory10 = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"]; // Replacement of d3.schemeCategory10.
// Contained differently depend on d3 version: v4(d3-scale), v5(d3-scale-chromatic)


/* harmony default export */ var internals_color = ({
  /**
   * Get color pattern from CSS file
   * CSS should be defined as: background-image: url("#00c73c;#fa7171; ...");
   * @return {Array}
   * @private
   */
  getColorFromCss: function getColorFromCss() {
    var body = browser_doc.body,
        pattern = body["__colorPattern__"];

    if (!pattern) {
      var span = browser_doc.createElement("span");
      span.className = config_classes.colorPattern, span.style.display = "none", body.appendChild(span);
      var content = win.getComputedStyle(span).backgroundImage;
      span.parentNode.removeChild(span), content.indexOf(";") > -1 && (pattern = content.replace(/url[^#]*|["'()]|(\s|%20)/g, "").split(";").map(function (v) {
        return v.trim().replace(/[\"'\s]/g, "");
      }).filter(Boolean), body["__colorPattern__"] = pattern);
    }

    return pattern;
  },
  generateColor: function generateColor() {
    var $$ = this,
        config = $$.config,
        colors = config.data_colors,
        callback = config.data_color,
        ids = [],
        pattern = notEmpty(config.color_pattern) ? config.color_pattern : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleOrdinal"])($$.getColorFromCss() || schemeCategory10).range(),
        originalColorPattern = pattern;

    if (isFunction(config.color_tiles)) {
      var tiles = config.color_tiles(),
          colorizedPatterns = pattern.map(function (p, index) {
        var color = p.replace(/[#\(\)\s,]/g, ""),
            id = $$.state.datetimeId + "-pattern-" + color + "-" + index;
        return colorizePattern(tiles[index % tiles.length], p, id);
      }); // Add background color to patterns

      pattern = colorizedPatterns.map(function (p) {
        return "url(#" + p.id + ")";
      }), $$.patterns = colorizedPatterns;
    }

    return function (d) {
      var color,
          id = d.id || d.data && d.data.id || d,
          isLine = $$.isTypeOf(id, ["line", "spline", "step"]) || !config.data_types[id];
      return isFunction(colors[id]) ? color = colors[id](d) : colors[id] ? color = colors[id] : (ids.indexOf(id) < 0 && ids.push(id), color = isLine ? originalColorPattern[ids.indexOf(id) % originalColorPattern.length] : pattern[ids.indexOf(id) % pattern.length], colors[id] = color), isFunction(callback) ? callback(color, d) : color;
    };
  },
  generateLevelColor: function generateLevelColor() {
    var $$ = this,
        config = $$.config,
        colors = config.color_pattern,
        threshold = config.color_threshold,
        asValue = threshold.unit === "value",
        max = threshold.max || 100,
        values = threshold.values && threshold.values.length ? threshold.values : [];
    return notEmpty(threshold) ? function (value) {
      var v = asValue ? value : value * 100 / max,
          color = colors[colors.length - 1];

      for (var i = 0, l = values.length; i < l; i++) if (v <= values[i]) {
        color = colors[i];
        break;
      }

      return color;
    } : null;
  },

  /**
   * Set the data over color.
   * When is out, will restate in its previous color value
   * @param {Boolean} isOver true: set overed color, false: restore
   * @param {Number|Object} d target index or data object for Arc type
   * @private
   */
  setOverColor: function setOverColor(isOver, d) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        onover = config.color_onover,
        color = isOver ? onover : $$.color;
    isObject(color) ? color = function (_ref) {
      var id = _ref.id;
      return id in onover ? onover[id] : $$.color(id);
    } : isString(color) && (color = function () {
      return onover;
    }), isObject(d) ? main.selectAll("." + config_classes.arc + $$.getTargetSelectorSuffix(d.id)).style("fill", color(d)) : main.selectAll("." + config_classes.shape + "-" + d).style("fill", color);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/domain.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_domain = ({
  getYDomainMinMax: function getYDomainMinMax(targets, type) {
    var $$ = this,
        config = $$.config,
        isMin = type === "min",
        dataGroups = config.data_groups,
        ids = $$.mapToIds(targets),
        ys = $$.getValuesAsIdKeyed(targets);
    return dataGroups.length > 0 && function () {
      for (var idsInGroup, _ret, hasValue = $$["has" + (isMin ? "Negative" : "Positive") + "ValueInTargets"](targets), _loop = function (j, _idsInGroup) {
        if (_idsInGroup = _idsInGroup.filter(function (v) {
          return ids.indexOf(v) >= 0;
        }), _idsInGroup.length === 0) return idsInGroup = _idsInGroup, "continue";
        var baseId = _idsInGroup[0],
            baseAxisId = $$.axis.getId(baseId);
        hasValue && ys[baseId] && (ys[baseId] = ys[baseId].map(function (v) {
          return (isMin ? v < 0 : v > 0) ? v : 0;
        }));

        for (var id, _ret2, _loop2 = function (k, id) {
          if (!ys[id]) return "continue";
          var axisId = $$.axis.getId(id);
          ys[id].forEach(function (v, i) {
            var val = +v,
                meetCondition = isMin ? val > 0 : val < 0;
            axisId !== baseAxisId || hasValue && meetCondition || (ys[baseId][i] += val);
          });
        }, k = 1; id = _idsInGroup[k]; k++) _ret2 = _loop2(k, id), _ret2 === "continue";

        idsInGroup = _idsInGroup;
      }, j = 0; idsInGroup = dataGroups[j]; j++) _ret = _loop(j, idsInGroup), _ret === "continue";
    }(), getMinMax(type, Object.keys(ys).map(function (key) {
      return getMinMax(type, ys[key]);
    }));
  },
  getYDomainMin: function getYDomainMin(targets) {
    return this.getYDomainMinMax(targets, "min");
  },
  getYDomainMax: function getYDomainMax(targets) {
    return this.getYDomainMinMax(targets, "max");
  },
  getYDomain: function getYDomain(targets, axisId, xDomain) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale;
    if ($$.isStackNormalized()) return [0, 100];
    var targetsByAxisId = targets.filter(function (t) {
      return $$.axis.getId(t.id) === axisId;
    }),
        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId;
    if (yTargets.length === 0) // use domain of the other axis if target of axisId is none
      return axisId === "y2" ? scale.y.domain() : // When all data bounds to y2, y Axis domain is called prior y2.
      // So, it needs to call to get y2 domain here
      $$.getYDomain(targets, "y2", xDomain);
    var yMin = config["axis_" + axisId + "_min"],
        yMax = config["axis_" + axisId + "_max"],
        yDomainMin = $$.getYDomainMin(yTargets),
        yDomainMax = $$.getYDomainMax(yTargets),
        center = config["axis_" + axisId + "_center"],
        isZeroBased = ["area", "bar", "bubble", "line", "scatter"].some(function (v) {
      return $$.hasType(v, yTargets) && config[v + "_zerobased"];
    }),
        isInverted = config["axis_" + axisId + "_inverted"],
        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,
        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated;
    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin, yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax, isNaN(yDomainMin) && (yDomainMin = 0), isNaN(yDomainMax) && (yDomainMax = yDomainMin), yDomainMin === yDomainMax && (yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0);
    var isAllPositive = yDomainMin >= 0 && yDomainMax >= 0,
        isAllNegative = yDomainMin <= 0 && yDomainMax <= 0;
    (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) && (isZeroBased = !1), isZeroBased && (isAllPositive && (yDomainMin = 0), isAllNegative && (yDomainMax = 0));
    var domainLength = Math.abs(yDomainMax - yDomainMin),
        padding = {
      top: domainLength * .1,
      bottom: domainLength * .1
    };

    if (isDefined(center)) {
      var yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));
      yDomainMax = center + yDomainAbs, yDomainMin = center - yDomainAbs;
    } // add padding for data label


    if (showHorizontalDataLabel) {
      var diff = diffDomain(scale.y.range()),
          ratio = $$.getDataLabelLength(yDomainMin, yDomainMax, "width").map(function (v) {
        return v / diff;
      });
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += domainLength * (ratio[i] / (1 - ratio[0] - ratio[1]));
      });
    } else if (showVerticalDataLabel) {
      var lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, "height");
      ["bottom", "top"].forEach(function (v, i) {
        padding[v] += $$.axis.convertPixelsToAxisPadding(lengths[i], domainLength);
      });
    }

    if (/^y2?$/.test(axisId)) {
      var p = config["axis_" + axisId + "_padding"];
      notEmpty(p) && ["bottom", "top"].forEach(function (v) {
        padding[v] = $$.axis.getPadding(p, v, padding[v], domainLength);
      });
    } // Bar/Area chart should be 0-based if all positive|negative


    isZeroBased && (isAllPositive && (padding.bottom = yDomainMin), isAllNegative && (padding.top = -yDomainMax));
    var domain = [yDomainMin - padding.bottom, yDomainMax + padding.top];
    return isInverted ? domain.reverse() : domain;
  },
  getXDomainMinMax: function getXDomainMinMax(targets, type) {
    var $$ = this,
        value = $$.config["axis_x_" + type];
    return isDefined(value) ? $$.isTimeSeries() ? $$.parseDate(value) : value : getMinMax(type, targets.map(function (t) {
      return getMinMax(type, t.values.map(function (v) {
        return v.x;
      }));
    }));
  },
  getXDomainMin: function getXDomainMin(targets) {
    return this.getXDomainMinMax(targets, "min");
  },
  getXDomainMax: function getXDomainMax(targets) {
    return this.getXDomainMinMax(targets, "max");
  },
  getXDomainPadding: function getXDomainPadding(domain) {
    var maxDataCount,
        padding,
        $$ = this,
        config = $$.config,
        diff = domain[1] - domain[0],
        xPadding = config.axis_x_padding;
    $$.isCategorized() ? padding = 0 : $$.hasType("bar") ? (maxDataCount = $$.getMaxDataCount(), padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : .5) : padding = diff * .01;
    var left = padding,
        right = padding;
    return isObject(xPadding) && notEmpty(xPadding) ? (left = isValue(xPadding.left) ? xPadding.left : padding, right = isValue(xPadding.right) ? xPadding.right : padding) : isNumber(config.axis_x_padding) && (left = xPadding, right = xPadding), {
      left: left,
      right: right
    };
  },
  getXDomain: function getXDomain(targets) {
    var $$ = this,
        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],
        firstX = xDomain[0],
        lastX = xDomain[1],
        padding = $$.getXDomainPadding(xDomain),
        min = 0,
        max = 0;
    return firstX - lastX !== 0 || $$.isCategorized() || ($$.isTimeSeries() ? (firstX = new Date(firstX.getTime() * .5), lastX = new Date(lastX.getTime() * 1.5)) : (firstX = firstX === 0 ? 1 : firstX * .5, lastX = lastX === 0 ? -1 : lastX * 1.5)), (firstX || firstX === 0) && (min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left), (lastX || lastX === 0) && (max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right), [min, max];
  },
  updateXDomain: function updateXDomain(targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {
    var $$ = this,
        config = $$.config,
        org = $$.org,
        scale = $$.scale,
        zoomEnabled = config.zoom_enabled;

    if (withUpdateOrgXDomain && (scale.x.domain(domain || util_sortValue($$.getXDomain(targets))), org.xDomain = scale.x.domain(), zoomEnabled && $$.zoom.updateScaleExtent(), scale.subX.domain(scale.x.domain()), $$.brush && $$.brush.scale(scale.subX)), withUpdateXDomain) {
      var domainValue = domain || !$$.brush || brushEmpty($$) ? org.xDomain : getBrushSelection($$).map(scale.subX.invert);
      scale.x.domain(domainValue), zoomEnabled && $$.zoom.updateScaleExtent();
    } // Trim domain when too big by zoom mousemove event


    return withTrim && scale.x.domain($$.trimXDomain(scale.x.orgDomain())), scale.x.domain();
  },
  trimXDomain: function trimXDomain(domain) {
    var zoomDomain = this.getZoomDomain(),
        min = zoomDomain[0],
        max = zoomDomain[1];
    return domain[0] <= min && (domain[1] = +domain[1] + (min - domain[0]), domain[0] = min), max <= domain[1] && (domain[0] = +domain[0] - (domain[1] - max), domain[1] = max), domain;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/format.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


function getFormat($$, typeValue, v) {
  var config = $$.config,
      type = "axis_" + typeValue + "_tick_format",
      format = config[type] ? config[type] : $$.defaultValueFormat;
  return format(v);
}

/* harmony default export */ var internals_format = ({
  getYFormat: function getYFormat(forArc) {
    var $$ = this,
        formatForY = $$.yFormat,
        formatForY2 = $$.y2Format;
    return forArc && !$$.hasType("gauge") && (formatForY = $$.defaultArcValueFormat, formatForY2 = $$.defaultArcValueFormat), function (v, ratio, id) {
      var format = $$.axis.getId(id) === "y2" ? formatForY2 : formatForY;
      return format.call($$, v, ratio);
    };
  },
  yFormat: function yFormat(v) {
    return getFormat(this, "y", v);
  },
  y2Format: function y2Format(v) {
    return getFormat(this, "y2", v);
  },
  defaultValueFormat: function defaultValueFormat(v) {
    return isValue(v) ? +v : "";
  },
  defaultArcValueFormat: function defaultArcValueFormat(v, ratio) {
    return (ratio * 100).toFixed(1) + "%";
  },
  dataLabelFormat: function dataLabelFormat(targetId) {
    var $$ = this,
        dataLabels = $$.config.data_labels,
        defaultFormat = function (v) {
      return isValue(v) ? +v : "";
    },
        format = defaultFormat;

    return isFunction(dataLabels.format) ? format = dataLabels.format : isObjectType(dataLabels.format) && (dataLabels.format[targetId] ? format = dataLabels.format[targetId] === !0 ? defaultFormat : dataLabels.format[targetId] : format = function () {
      return "";
    }), format;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/grid.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


 // Grid position and text anchor helpers

var getGridTextAnchor = function (d) {
  return isValue(d.position) || "end";
},
    getGridTextDx = function (d) {
  return d.position === "start" ? 4 : d.position === "middle" ? 0 : -4;
},
    getGridTextX = function (isX, width, height) {
  return function (d) {
    var x = isX ? 0 : width;
    return d.position === "start" ? x = isX ? -height : 0 : d.position === "middle" && (x = (isX ? -height : width) / 2), x;
  };
};

/* harmony default export */ var internals_grid = ({
  initGrid: function initGrid() {
    var $$ = this;
    $$.initGridLines(), $$.initFocusGrid();
  },
  initGridLines: function initGridLines() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        grid = $$.$el.grid;
    (config.grid_x_lines.length || config.grid_y_lines.length) && ($$.gridLines = $$.$el.main.insert("g", "." + config_classes.chart + (config.grid_lines_front ? " + *" : "")).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid + " " + config_classes.gridLines), $$.gridLines.append("g").attr("class", config_classes.xgridLines), $$.gridLines.append("g").attr("class", config_classes.ygridLines), grid.xLines = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]));
  },
  updateXGrid: function updateXGrid(withoutUpdate) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        grid = _$$$$el.grid,
        isRotated = config.axis_rotated,
        xgridData = $$.generateGridData(config.grid_x_type, scale.x),
        tickOffset = $$.isCategorized() ? $$.axis.x.tickOffset() : 0,
        pos = function (d) {
      return ((scale.zoom || scale.x)(d) + tickOffset) * (isRotated ? -1 : 1);
    };

    state.xgridAttr = isRotated ? {
      "x1": 0,
      "x2": state.width,
      "y1": pos,
      "y2": pos
    } : {
      "x1": pos,
      "x2": pos,
      "y1": 0,
      "y2": state.height
    }, grid.x = main.select("." + config_classes.xgrids).selectAll("." + config_classes.xgrid).data(xgridData), grid.x.exit().remove(), grid.x = grid.x.enter().append("line").attr("class", config_classes.xgrid).merge(grid.x), withoutUpdate || grid.x.each(function () {
      var grid = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      Object.keys(state.xgridAttr).forEach(function (id) {
        grid.attr(id, state.xgridAttr[id]).style("opacity", function () {
          return grid.attr(isRotated ? "y1" : "x1") === (isRotated ? state.height : 0) ? "0" : "1";
        });
      });
    });
  },
  updateYGrid: function updateYGrid() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el2 = $$.$el,
        grid = _$$$$el2.grid,
        main = _$$$$el2.main,
        isRotated = config.axis_rotated,
        gridValues = $$.axis.y.tickValues() || $$.scale.y.ticks(config.grid_y_ticks),
        pos = function (d) {
      return Math.ceil($$.scale.y(d));
    };

    grid.y = main.select("." + config_classes.ygrids).selectAll("." + config_classes.ygrid).data(gridValues), grid.y.exit().remove(), grid.y = grid.y.enter().append("line").attr("class", config_classes.ygrid).merge(grid.y), grid.y.attr("x1", isRotated ? pos : 0).attr("x2", isRotated ? pos : state.width).attr("y1", isRotated ? 0 : pos).attr("y2", isRotated ? state.height : pos), $$.smoothLines(grid.y, "grid");
  },
  updateGrid: function updateGrid(duration) {
    var $$ = this;
    // hide if arc type
    $$.gridLines || $$.initGridLines(), $$.$el.grid.main.style("visibility", $$.hasArcType() ? "hidden" : "visible"), $$.hideGridFocus(), $$.updateXGridLines(duration), $$.updateYGridLines(duration);
  },

  /**
   * Update X Grid lines
   * @param {Number} duration
   * @private
   */
  updateXGridLines: function updateXGridLines(duration) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        isRotated = config.axis_rotated;
    config.grid_x_show && $$.updateXGrid();
    var xLines = $el.main.select("." + config_classes.xgridLines).selectAll("." + config_classes.xgridLine).data(config.grid_x_lines); // exit

    xLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var xgridLine = xLines.enter().append("g");
    xgridLine.append("line").style("opacity", "0"), xgridLine.append("text").attr("transform", isRotated ? "" : "rotate(-90)").attr("dy", -5).style("opacity", "0"), xLines = xgridLine.merge(xLines), xLines.attr("class", function (d) {
      return (config_classes.xgridLine + " " + (d.class || "")).trim();
    }).select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), $el.grid.xLines = xLines;
  },

  /**
   * Update Y Grid lines
   * @param {Number} duration
   * @private
   */
  updateYGridLines: function updateYGridLines(duration) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        $el = $$.$el,
        isRotated = config.axis_rotated;
    config.grid_y_show && $$.updateYGrid();
    var ygridLines = $el.main.select("." + config_classes.ygridLines).selectAll("." + config_classes.ygridLine).data(config.grid_y_lines); // exit

    ygridLines.exit().transition().duration(duration).style("opacity", "0").remove();
    // enter
    var ygridLine = ygridLines.enter().append("g");
    ygridLine.append("line").style("opacity", "0"), ygridLine.append("text").attr("transform", isRotated ? "rotate(-90)" : "").style("opacity", "0"), ygridLines = ygridLine.merge(ygridLines);
    // update
    var yv = $$.yv.bind($$);
    ygridLines.attr("class", function (d) {
      return (config_classes.ygridLine + " " + (d.class || "")).trim();
    }).select("line").transition().duration(duration).attr("x1", isRotated ? yv : 0).attr("x2", isRotated ? yv : width).attr("y1", isRotated ? 0 : yv).attr("y2", isRotated ? height : yv).transition().style("opacity", "1"), ygridLines.select("text").attr("text-anchor", getGridTextAnchor).attr("dx", getGridTextDx).transition().duration(duration).attr("dy", -5).attr("x", getGridTextX(isRotated, width, height)).attr("y", yv).text(function (d) {
      return d.text;
    }).transition().style("opacity", "1"), $el.grid.yLines = ygridLines;
  },
  redrawGrid: function redrawGrid(withTransition) {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        _$$$state2 = $$.state,
        width = _$$$state2.width,
        height = _$$$state2.height,
        grid = $$.$el.grid,
        xv = $$.xv.bind($$),
        lines = grid.xLines.select("line"),
        texts = grid.xLines.select("text");
    return lines = (withTransition ? lines.transition() : lines).attr("x1", isRotated ? 0 : xv).attr("x2", isRotated ? width : xv).attr("y1", isRotated ? xv : 0).attr("y2", isRotated ? xv : height), texts = (withTransition ? texts.transition() : texts).attr("x", getGridTextX(!isRotated, width, height)).attr("y", xv).text(function (d) {
      return d.text;
    }), [(withTransition ? lines.transition() : lines).style("opacity", "1"), (withTransition ? texts.transition() : texts).style("opacity", "1")];
  },
  initFocusGrid: function initFocusGrid() {
    var $$ = this,
        config = $$.config,
        clip = $$.state.clip,
        $el = $$.$el,
        isFront = config.grid_front,
        className = "." + config_classes[isFront && $$.gridLines ? "gridLines" : "chart"] + (isFront ? " + *" : ""),
        grid = $el.grid.main = $el.main.insert("g", className).attr("clip-path", clip.pathGrid).attr("class", config_classes.grid);
    config.grid_x_show && grid.append("g").attr("class", config_classes.xgrids), config.grid_y_show && grid.append("g").attr("class", config_classes.ygrids), config.grid_focus_show && (grid.append("g").attr("class", config_classes.xgridFocus).append("line").attr("class", config_classes.xgridFocus), config.grid_focus_y && !config.tooltip_grouped && grid.append("g").attr("class", config_classes.ygridFocus).append("line").attr("class", config_classes.ygridFocus));
  },

  /**
   * Show grid focus line
   * @param {Array} selectedData
   * @private
   */
  showGridFocus: function showGridFocus(selectedData) {
    var $$ = this,
        config = $$.config,
        _$$$state3 = $$.state,
        width = _$$$state3.width,
        height = _$$$state3.height,
        isRotated = config.axis_rotated,
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    });

    // Hide when bubble/scatter/stanford plot exists
    if (!(!config.tooltip_show || dataToShow.length === 0 || $$.hasType("bubble") || $$.hasArcType())) {
      var focusEl = $$.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus),
          isEdge = config.grid_focus_edge && !config.tooltip_grouped,
          xx = $$.xx.bind($$);
      focusEl.style("visibility", "visible").data(dataToShow.concat(dataToShow)).each(function (d) {
        var xy,
            el = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            pos = {
          x: xx(d),
          y: $$.getYScale(d.id)(d.value)
        };
        if (el.classed(config_classes.xgridFocus)) xy = isRotated ? [null, // x1
        pos.x, // y1
        isEdge ? pos.y : width, // x2
        pos.x // y2
        ] : [pos.x, isEdge ? pos.y : null, pos.x, height];else {
          var isY2 = $$.axis.getId(d.id) === "y2";
          xy = isRotated ? [pos.y, // x1
          isEdge && !isY2 ? pos.x : null, // y1
          pos.y, // x2
          isEdge && isY2 ? pos.x : height // y2
          ] : [isEdge && isY2 ? pos.x : null, pos.y, isEdge && !isY2 ? pos.x : width, pos.y];
        }
        ["x1", "y1", "x2", "y2"].forEach(function (v, i) {
          return el.attr(v, xy[i]);
        });
      }), $$.smoothLines(focusEl, "grid");
    }
  },
  hideGridFocus: function hideGridFocus() {
    this.$el.main.selectAll("line." + config_classes.xgridFocus + ", line." + config_classes.ygridFocus).style("visibility", "hidden");
  },
  updategridFocus: function updategridFocus() {
    var $$ = this,
        _$$$state4 = $$.state,
        width = _$$$state4.width,
        height = _$$$state4.height,
        isRotated = $$.config.axis_rotated;
    $$.$el.main.select("line." + config_classes.xgridFocus).attr("x1", isRotated ? 0 : -10).attr("x2", isRotated ? width : -10).attr("y1", isRotated ? -10 : 0).attr("y2", isRotated ? -10 : height);
  },
  generateGridData: function generateGridData(type, scale) {
    var $$ = this,
        tickNum = $$.$el.main.select("." + config_classes.axisX).selectAll(".tick").size(),
        gridData = [];

    if (type === "year") {
      var xDomain = $$.getXDomain(),
          firstYear = xDomain[0].getFullYear(),
          lastYear = xDomain[1].getFullYear();

      for (var i = firstYear; i <= lastYear; i++) gridData.push(new Date(i + "-01-01 00:00:00"));
    } else gridData = scale.ticks(10), gridData.length > tickNum && (gridData = gridData.filter(function (d) {
      return (d + "").indexOf(".") < 0;
    }));

    return gridData;
  },
  getGridFilterToRemove: function getGridFilterToRemove(params) {
    return params ? function (line) {
      var found = !1;
      return (isArray(params) ? params.concat() : [params]).forEach(function (param) {
        ("value" in param && line.value === param.value || "class" in param && line.class === param.class) && (found = !0);
      }), found;
    } : function () {
      return !0;
    };
  },
  removeGridLines: function removeGridLines(params, forX) {
    var $$ = this,
        config = $$.config,
        toRemove = $$.getGridFilterToRemove(params),
        classLines = forX ? config_classes.xgridLines : config_classes.ygridLines,
        classLine = forX ? config_classes.xgridLine : config_classes.ygridLine;
    $$.$el.main.select("." + classLines).selectAll("." + classLine).filter(toRemove).transition().duration(config.transition_duration).style("opacity", "0").remove();
    var gridLines = "grid_" + (forX ? "x" : "y") + "_lines";
    config[gridLines] = config[gridLines].filter(function toShow(line) {
      return !toRemove(line);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_legend = ({
  /**
   * Initialize the legend.
   * @private
   */
  initLegend: function initLegend() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.legendItemTextBox = {}, $$.state.legendHasRendered = !1, $el.legend = $$.$el.svg.append("g"), config.legend_show ? ($el.legend.attr("transform", $$.getTranslate("legend")), $$.updateLegend()) : ($$.$el.legend.style("visibility", "hidden"), $$.state.hiddenLegendIds = $$.mapToIds($$.data.targets));
  },

  /**
   * Update legend element
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
   * @param {Object} transitions Return value of the generateTransitions
   * @private
   */
  updateLegend: function updateLegend(targetIds, options, transitions) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        optionz = options || {
      withTransform: !1,
      withTransitionForTransform: !1,
      withTransition: !1
    };
    // toggle legend state
    // Update size and scale
    // Update g positions
    optionz.withTransition = getOption(optionz, "withTransition", !0), optionz.withTransitionForTransform = getOption(optionz, "withTransitionForTransform", !0), config.legend_contents_bindto && config.legend_contents_template ? $$.updateLegendTemplate() : $$.updateLegendElement(targetIds || $$.mapToIds($$.data.targets), optionz, transitions), $$.$el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemHidden, function (id) {
      return !$$.isTargetToShow(id);
    }), $$.updateScales(!1, !scale.zoom), $$.updateSvgSize(), $$.transformAll(optionz.withTransitionForTransform, transitions), $$.state.legendHasRendered = !0;
  },

  /**
   * Update legend using template option
   * @private
   */
  updateLegendTemplate: function updateLegendTemplate() {
    var $$ = this,
        config = $$.config,
        wrapper = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(config.legend_contents_bindto),
        template = config.legend_contents_template;

    if (!wrapper.empty()) {
      var targets = $$.mapToIds($$.data.targets),
          ids = [],
          html = "";
      targets.forEach(function (v) {
        var content = isFunction(template) ? template.call($$, v, $$.color(v), $$.api.data(v)[0].values) : tplProcess(template, {
          COLOR: $$.color(v),
          TITLE: v
        });
        content && (ids.push(v), html += content);
      });
      var legendItem = wrapper.html(html).selectAll(function () {
        return this.childNodes;
      }).data(ids);
      $$.setLegendItem(legendItem), $$.$el.legend = wrapper;
    }
  },

  /**
   * Update the size of the legend.
   * @private
   * @param {Obejct} size S
   */
  updateSizeForLegend: function updateSizeForLegend(size) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        isLegendTop = _$$$state.isLegendTop,
        isLegendLeft = _$$$state.isLegendLeft,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        currentWidth = _$$$state.currentWidth,
        currentHeight = _$$$state.currentHeight,
        width = size.width,
        height = size.height,
        insetLegendPosition = {
      top: isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : currentHeight - height - $$.getCurrentPaddingBottom() - config.legend_inset_y,
      left: isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + .5 : currentWidth - width - $$.getCurrentPaddingRight() - config.legend_inset_x + .5
    };
    $$.state.margin3 = {
      top: isLegendRight ? 0 : isLegendInset ? insetLegendPosition.top : currentHeight - height,
      right: NaN,
      bottom: 0,
      left: isLegendRight ? currentWidth - width : isLegendInset ? insetLegendPosition.left : 0
    };
  },

  /**
   * Transform Legend
   * @private
   * @param {Boolean} whether or not to transition.
   */
  transformLegend: function transformLegend(withTransition) {
    var $$ = this,
        legend = $$.$el.legend;
    (withTransition ? legend.transition() : legend).attr("transform", $$.getTranslate("legend"));
  },

  /**
   * Update the legend step
   * @private
   * @param {Number} step
   */
  updateLegendStep: function updateLegendStep(step) {
    this.state.legendStep = step;
  },

  /**
   * Update legend item width
   * @private
   * @param {Number} width
   */
  updateLegendItemWidth: function updateLegendItemWidth(w) {
    this.state.legendItemWidth = w;
  },

  /**
   * Update legend item height
   * @private
   * @param {Number} height
   */
  updateLegendItemHeight: function updateLegendItemHeight(h) {
    this.state.legendItemHeight = h;
  },

  /**
   * Update legend item color
   * @private
   * @param {String} id Corresponding data ID value
   * @param {String} color Color value
   */
  updateLegendItemColor: function updateLegendItemColor(id, color) {
    this.$el.legend.select("." + config_classes.legendItem + "-" + id + " line").style("stroke", color);
  },

  /**
   * Get the width of the legend
   * @private
   * @return {Number} width
   */
  getLegendWidth: function getLegendWidth() {
    var $$ = this,
        _$$$state2 = $$.state,
        currentWidth = _$$$state2.currentWidth,
        isLegendRight = _$$$state2.isLegendRight,
        isLegendInset = _$$$state2.isLegendInset,
        legendItemWidth = _$$$state2.legendItemWidth,
        legendStep = _$$$state2.legendStep;
    return $$.config.legend_show ? isLegendRight || isLegendInset ? legendItemWidth * (legendStep + 1) : currentWidth : 0;
  },

  /**
   * Get the height of the legend
   * @return {Number} height
   * @private
   */
  getLegendHeight: function getLegendHeight() {
    var $$ = this,
        _$$$state3 = $$.state,
        currentHeight = _$$$state3.currentHeight,
        isLegendRight = _$$$state3.isLegendRight,
        legendItemHeight = _$$$state3.legendItemHeight,
        legendStep = _$$$state3.legendStep;
    return $$.config.legend_show ? isLegendRight ? currentHeight : Math.max(20, legendItemHeight) * (legendStep + 1) : 0;
  },

  /**
   * Get the opacity of the legend
   * @private
   * @param {Object} d3.Select
   * @returns {Number} opacity
   */
  opacityForLegend: function opacityForLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "1";
  },

  /**
   * Get the opacity of the legend that is unfocused
   * @private
   * @param {Object} legendItem, d3.Select
   * @returns {Number} opacity
   */
  opacityForUnfocusedLegend: function opacityForUnfocusedLegend(legendItem) {
    return legendItem.classed(config_classes.legendItemHidden) ? null : "0.3";
  },

  /**
   * Toggles the focus of the legend
   * @private
   * @param {Array} ID's of target
   * @param {Boolean} whether or not to focus.
   */
  toggleFocusLegend: function toggleFocusLegend(targetIds, focus) {
    var $$ = this,
        targetIdz = $$.mapToTargetIds(targetIds);
    $$.$el.legend.selectAll("." + config_classes.legendItem).filter(function (id) {
      return targetIdz.indexOf(id) >= 0;
    }).classed(config_classes.legendItemFocused, focus).transition().duration(100).style("opacity", function () {
      return (focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend).call($$, Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Revert the legend to its default state
   * @private
   */
  revertLegend: function revertLegend() {
    var $$ = this;
    $$.$el.legend.selectAll("." + config_classes.legendItem).classed(config_classes.legendItemFocused, !1).transition().duration(100).style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Shows the legend
   * @private
   * @param {Array} ID's of target
   */
  showLegend: function showLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show || (config.legend_show = !0, legend.style("visibility", "visible"), !$$.state.legendHasRendered && $$.updateLegend()), $$.removeHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("visibility", "visible").transition().style("opacity", function () {
      return $$.opacityForLegend(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this));
    });
  },

  /**
   * Hide the legend
   * @private
   * @param {Array} ID's of target
   */
  hideLegend: function hideLegend(targetIds) {
    var $$ = this,
        config = $$.config,
        legend = $$.$el.legend;
    config.legend_show && isEmpty(targetIds) && (config.legend_show = !1, legend.style("visibility", "hidden")), $$.addHiddenLegendIds(targetIds), legend.selectAll($$.selectorLegends(targetIds)).style("opacity", "0").style("visibility", "hidden");
  },

  /**
   * Clear the LegendItemTextBox cache.
   * @private
   */
  clearLegendItemTextBoxcache: function clearLegendItemTextBoxcache() {
    this.legendItemTextBox = {};
  },

  /**
   * Set legend item style & bind events
   * @private
   * @param {d3.selection} item
   */
  setLegendItem: function setLegendItem(item) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        hasGauge = $$.hasType("gauge");
    item.attr("class", function (id) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          itemClass = !node.empty() && node.attr("class") || "";
      return itemClass + $$.generateClass(config_classes.legendItem, id);
    }).style("visibility", function (id) {
      return $$.isLegendToShow(id) ? "visible" : "hidden";
    }).style("cursor", "pointer").on("click", function (id) {
      callFn(config.legend_item_onclick, $$, id) || (external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].altKey ? ($$.api.hide(), $$.api.show(id)) : ($$.api.toggle(id), !isTouch && $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert())), isTouch && $$.hideTooltip();
    }), isTouch || item.on("mouseout", function (id) {
      callFn(config.legend_item_onout, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !1), hasGauge && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue), $$.api.revert());
    }).on("mouseover", function (id) {
      callFn(config.legend_item_onover, $$, id) || (Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused, !0), hasGauge && $$.markOverlapped(id, $$, "." + config_classes.gaugeValue), !state.transiting && $$.isTargetToShow(id) && $$.api.focus(id));
    });
  },

  /**
   * Update the legend
   * @param {Array} targetIds ID's of target
   * @param {Object} options withTransform : Whether to use the transform property / withTransitionForTransform: Whether transition is used when using the transform property / withTransition : whether or not to transition.
  	 * @private
   */
  updateLegendElement: function updateLegendElement(targetIds, options) {
    var xForLegend,
        yForLegend,
        background,
        $$ = this,
        config = $$.config,
        state = $$.state,
        posMin = 10,
        tileWidth = config.legend_item_tile_width + 5,
        maxWidth = 0,
        maxHeight = 0,
        totalLength = 0,
        offsets = {},
        widths = {},
        heights = {},
        margins = [0],
        steps = {},
        step = 0,
        isLegendRightOrInset = state.isLegendRight || state.isLegendInset,
        targetIdz = targetIds.filter(function (id) {
      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;
    }),
        withTransition = options.withTransition,
        getTextBox = function (textElement, id) {
      return $$.legendItemTextBox[id] || ($$.legendItemTextBox[id] = $$.getTextRect(textElement, config_classes.legendItem)), $$.legendItemTextBox[id];
    },
        updatePositions = function (textElement, id, index) {
      var margin,
          isLast = index === targetIdz.length - 1,
          box = getTextBox(textElement, id),
          itemWidth = box.width + tileWidth + (isLast && !isLegendRightOrInset ? 0 : 10) + config.legend_padding,
          itemHeight = box.height + 4,
          itemLength = isLegendRightOrInset ? itemHeight : itemWidth,
          areaLength = isLegendRightOrInset ? $$.getLegendHeight() : $$.getLegendWidth(),
          updateValues = function (id2, withoutStep) {
        withoutStep || (margin = (areaLength - totalLength - itemLength) / 2, margin < posMin && (margin = (areaLength - itemLength) / 2, totalLength = 0, step++)), steps[id2] = step, margins[step] = state.isLegendInset ? 10 : margin, offsets[id2] = totalLength, totalLength += itemLength;
      };

      if (index === 0 && (totalLength = 0, step = 0, maxWidth = 0, maxHeight = 0), config.legend_show && !$$.isLegendToShow(id)) return widths[id] = 0, heights[id] = 0, steps[id] = 0, void (offsets[id] = 0);
      widths[id] = itemWidth, heights[id] = itemHeight, (!maxWidth || itemWidth >= maxWidth) && (maxWidth = itemWidth), (!maxHeight || itemHeight >= maxHeight) && (maxHeight = itemHeight);
      var maxLength = isLegendRightOrInset ? maxHeight : maxWidth;
      config.legend_equally ? (Object.keys(widths).forEach(function (id2) {
        return widths[id2] = maxWidth;
      }), Object.keys(heights).forEach(function (id2) {
        return heights[id2] = maxHeight;
      }), margin = (areaLength - maxLength * targetIdz.length) / 2, margin < posMin ? (totalLength = 0, step = 0, targetIdz.forEach(function (id2) {
        return updateValues(id2);
      })) : updateValues(id, !0)) : updateValues(id);
    };

    state.isLegendInset && (step = config.legend_inset_step ? config.legend_inset_step : targetIdz.length, $$.updateLegendStep(step)), state.isLegendRight ? (xForLegend = function (id) {
      return maxWidth * steps[id];
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : state.isLegendInset ? (xForLegend = function (id) {
      return maxWidth * steps[id] + 10;
    }, yForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }) : (xForLegend = function (id) {
      return margins[steps[id]] + offsets[id];
    }, yForLegend = function (id) {
      return maxHeight * steps[id];
    });

    var xForLegendText = function (id, i) {
      return xForLegend(id, i) + 4 + config.legend_item_tile_width;
    },
        xForLegendRect = function (id, i) {
      return xForLegend(id, i);
    },
        x1ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2;
    },
        x2ForLegendTile = function (id, i) {
      return xForLegend(id, i) - 2 + config.legend_item_tile_width;
    },
        yForLegendText = function (id, i) {
      return yForLegend(id, i) + 9;
    },
        yForLegendRect = function (id, i) {
      return yForLegend(id, i) - 5;
    },
        yForLegendTile = function (id, i) {
      return yForLegend(id, i) + 4;
    },
        pos = -200,
        legend = $$.$el.legend,
        l = legend.selectAll("." + config_classes.legendItem).data(targetIdz).enter().append("g");

    $$.setLegendItem(l), l.append("text").text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }).each(function (id, i) {
      updatePositions(this, id, i);
    }).style("pointer-events", "none").attr("x", isLegendRightOrInset ? xForLegendText : pos).attr("y", isLegendRightOrInset ? pos : yForLegendText), l.append("rect").attr("class", config_classes.legendItemEvent).style("fill-opacity", "0").attr("x", isLegendRightOrInset ? xForLegendRect : pos).attr("y", isLegendRightOrInset ? pos : yForLegendRect);
    var usePoint = config.legend_usePoint;

    if (usePoint) {
      var ids = [];
      l.append(function (d) {
        var pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
        ids.indexOf(d) === -1 && ids.push(d);
        var point = pattern[ids.indexOf(d) % pattern.length];
        return point === "rectangle" && (point = "rect"), browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, $$.hasValidPointType(point) ? point : "use");
      }).attr("class", config_classes.legendItemPoint).style("fill", function (d) {
        return $$.color(d);
      }).style("pointer-events", "none").attr("href", function (data, idx, selection) {
        var node = selection[idx],
            nodeName = node.nodeName.toLowerCase();
        return nodeName === "use" ? "#" + state.datetimeId + "-point-" + data : undefined;
      });
    } else l.append("line").attr("class", config_classes.legendItemTile).style("stroke", $$.color).style("pointer-events", "none").attr("x1", isLegendRightOrInset ? x1ForLegendTile : pos).attr("y1", isLegendRightOrInset ? pos : yForLegendTile).attr("x2", isLegendRightOrInset ? x2ForLegendTile : pos).attr("y2", isLegendRightOrInset ? pos : yForLegendTile).attr("stroke-width", config.legend_item_tile_height); // Set background for inset legend


    background = legend.select("." + config_classes.legendBackground + " rect"), state.isLegendInset && maxWidth > 0 && background.size() === 0 && (background = legend.insert("g", "." + config_classes.legendItem).attr("class", config_classes.legendBackground).append("rect"));
    var texts = legend.selectAll("text").data(targetIdz).text(function (id) {
      return isDefined(config.data_names[id]) ? config.data_names[id] : id;
    }) // MEMO: needed for update
    .each(function (id, i) {
      updatePositions(this, id, i);
    });
    (withTransition ? texts.transition() : texts).attr("x", xForLegendText).attr("y", yForLegendText);
    var rects = legend.selectAll("rect." + config_classes.legendItemEvent).data(targetIdz);

    if ((withTransition ? rects.transition() : rects).attr("width", function (id) {
      return widths[id];
    }).attr("height", function (id) {
      return heights[id];
    }).attr("x", xForLegendRect).attr("y", yForLegendRect), usePoint) {
      var tiles = legend.selectAll("." + config_classes.legendItemPoint).data(targetIdz);
      (withTransition ? tiles.transition() : tiles).each(function () {
        var radius,
            width,
            height,
            nodeName = this.nodeName.toLowerCase(),
            pointR = config.point_r,
            x = "x",
            y = "y",
            xOffset = 2,
            yOffset = 2.5;

        if (nodeName === "circle") {
          var size = pointR * .2;
          x = "cx", y = "cy", radius = pointR + size, xOffset = pointR * 2, yOffset = -size;
        } else if (nodeName === "rect") {
          var _size = pointR * 2.5;

          width = _size, height = _size, yOffset = 3;
        }

        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr(x, function (d) {
          return x1ForLegendTile(d) + xOffset;
        }).attr(y, function (d) {
          return yForLegendTile(d) - yOffset;
        }).attr("r", radius).attr("width", width).attr("height", height);
      });
    } else {
      var _tiles = legend.selectAll("line." + config_classes.legendItemTile).data(targetIdz);

      (withTransition ? _tiles.transition() : _tiles).style("stroke", $$.levelColor ? function (id) {
        return $$.levelColor($$.cache.get(id).values[0].value);
      } : $$.color).attr("x1", x1ForLegendTile).attr("y1", yForLegendTile).attr("x2", x2ForLegendTile).attr("y2", yForLegendTile);
    }

    background && (withTransition ? background.transition() : background).attr("height", $$.getLegendHeight() - 12).attr("width", maxWidth * (step + 1) + 10), $$.updateLegendItemWidth(maxWidth), $$.updateLegendItemHeight(maxHeight), $$.updateLegendStep(step);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/region.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // selection



/* harmony default export */ var region = ({
  initRegion: function initRegion() {
    var $$ = this,
        $el = $$.$el;
    $el.region.main = $el.main.append("g").attr("clip-path", $$.state.clip.path).attr("class", config_classes.regions);
  },
  updateRegion: function updateRegion(duration) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $el.region.main.style("visibility", $$.hasArcType() ? "hidden" : "visible");
    // select <g> element
    var list = $el.main.select("." + config_classes.regions).selectAll("." + config_classes.region).data(config.regions);
    list.exit().transition().duration(duration).style("opacity", "0").remove(), list = list.enter().append("g").merge(list).attr("class", $$.classRegion.bind($$)), list.append("rect").style("fill-opacity", "0"), $el.region.list = list;
  },
  redrawRegion: function redrawRegion(withTransition) {
    var $$ = this,
        regions = $$.$el.region.list.select("rect");
    return regions = (withTransition ? regions.transition() : regions).attr("x", $$.regionX.bind($$)).attr("y", $$.regionY.bind($$)).attr("width", $$.regionWidth.bind($$)).attr("height", $$.regionHeight.bind($$)), [(withTransition ? regions.transition() : regions).style("fill-opacity", function (d) {
      return isValue(d.opacity) ? d.opacity : "0.1";
    }).on("end", function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this.parentNode).selectAll("rect:not([x])").remove();
    })];
  },
  getRegionXY: function getRegionXY(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        isRotated = config.axis_rotated,
        isX = type === "x",
        key = "start",
        pos = 0;
    return d.axis === "y" || d.axis === "y2" ? (!isX && (key = "end"), (isX ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], pos = currScale(d[key]))) : (isX ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, pos = currScale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), pos;
  },
  regionX: function regionX(d) {
    return this.getRegionXY("x", d);
  },
  regionY: function regionY(d) {
    return this.getRegionXY("y", d);
  },
  getRegionSize: function getRegionSize(type, d) {
    var currScale,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        state = $$.state,
        isRotated = config.axis_rotated,
        isWidth = type === "width",
        start = $$[isWidth ? "regionX" : "regionY"](d),
        key = "end",
        end = state[type];
    return d.axis === "y" || d.axis === "y2" ? (!isWidth && (key = "start"), (isWidth ? isRotated : !isRotated) && key in d && (currScale = scale[d.axis], end = currScale(d[key]))) : (isWidth ? !isRotated : isRotated) && key in d && (currScale = scale.zoom || scale.x, end = currScale($$.isTimeSeries() ? $$.parseDate(d[key]) : d[key])), end < start ? 0 : end - start;
  },
  regionWidth: function regionWidth(d) {
    return this.getRegionSize("width", d);
  },
  regionHeight: function regionHeight(d) {
    return this.getRegionSize("height", d);
  },
  isRegionOnX: function isRegionOnX(d) {
    return !d.axis || d.axis === "x";
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/scale.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var internals_scale = ({
  getScale: function getScale(min, max, forTimeseries) {
    return (forTimeseries ? Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleTime"])() : Object(external_commonjs_d3_scale_commonjs2_d3_scale_amd_d3_scale_root_d3_["scaleLinear"])()).range([min, max]);
  },

  /**
   * Get x Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @param {Function} offset The offset getter to be sum
   * @return {Function} scale
   * @private
   */
  getX: function getX(min, max, domain, offset) {
    var $$ = this,
        scale = $$.scale.zoom || $$.getScale(min, max, $$.isTimeSeries());
    return $$.getCustomizedScale(domain ? scale.domain(domain) : scale, offset);
  },

  /**
   * Get y Axis scale function
   * @param {Number} min
   * @param {Number} max
   * @param {Number} domain
   * @return {Function} scale
   * @private
   */
  getY: function getY(min, max, domain) {
    var scale = this.getScale(min, max, this.isTimeSeriesY());
    return domain && scale.domain(domain), scale;
  },

  /**
   * Get customized scale
   * @param {d3.scaleLinear|d3.scaleTime} scaleValue
   * @param {Function} offsetValue Offset getter to be sum
   * @return {} scale
   * @private
   */
  getCustomizedScale: function getCustomizedScale(scaleValue, offsetValue) {
    var $$ = this,
        offset = offsetValue || function () {
      return $$.axis.x.tickOffset();
    },
        scale = function (d, raw) {
      var v = scaleValue(d) + offset();
      return raw ? v : Math.ceil(v);
    };

    // copy original scale methods
    for (var key in scaleValue) scale[key] = scaleValue[key];

    return scale.orgDomain = function () {
      return scaleValue.domain();
    }, scale.orgScale = function () {
      return scaleValue;
    }, $$.isCategorized() && (scale.domain = function (domainValue) {
      var domain = domainValue;
      return arguments.length ? (scaleValue.domain(domain), scale) : (domain = this.orgDomain(), [domain[0], domain[1] + 1]);
    }), scale;
  },
  getYScale: function getYScale(id) {
    var _this$scale = this.scale,
        y = _this$scale.y,
        y2 = _this$scale.y2;
    return this.axis.getId(id) === "y2" ? y2 : y;
  },
  getSubYScale: function getSubYScale(id) {
    var _this$scale2 = this.scale,
        subY = _this$scale2.subY,
        subY2 = _this$scale2.subY2;
    return this.axis.getId(id) === "y2" ? subY2 : subY;
  },

  /**
   * Update scale
   * @private
   * @param {Boolean} isInit - param is given at the init rendering
   */
  updateScales: function updateScales(isInit, updateXDomain) {
    updateXDomain === void 0 && (updateXDomain = !0);
    var $$ = this,
        config = $$.config,
        org = $$.org,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        width2 = _$$$state.width2,
        height2 = _$$$state.height2,
        isRotated = config.axis_rotated,
        min = {
      x: isRotated ? 1 : 0,
      y: isRotated ? 0 : height,
      subX: isRotated ? 1 : 0,
      subY: isRotated ? 0 : height2
    },
        max = {
      x: isRotated ? height : width,
      y: isRotated ? width : 1,
      subX: isRotated ? height : width,
      subY: isRotated ? width2 : 1
    },
        xDomain = updateXDomain && scale.x && scale.x.orgDomain(),
        xSubDomain = updateXDomain && org.xDomain;
    // y Axis
    // update for arc
    scale.x = $$.getX(min.x, max.x, xDomain, function () {
      return $$.axis.x.tickOffset();
    }), scale.subX = $$.getX(min.x, max.x, xSubDomain, function (d) {
      return d % 1 ? 0 : $$.axis.subX.tickOffset();
    }), $$.format.xAxisTick = $$.axis.getXAxisTickFormat(), $$.axis.xTickValues = $$.axis.getTickValues("x"), $$.axis.x = $$.axis.getAxis("x", scale.x, config.axis_x_tick_outer, isInit), $$.axis.subX = $$.axis.getAxis("subX", scale.subX, config.axis_x_tick_outer, isInit), scale.y = $$.getY(min.y, max.y, scale.y ? scale.y.domain() : config.axis_y_default), scale.subY = $$.getY(min.subY, max.subY, scale.subY ? scale.subY.domain() : config.axis_y_default), $$.axis.yTickValues = $$.axis.getTickValues("y"), $$.axis.y = $$.axis.getAxis("y", scale.y, config.axis_y_tick_outer, isInit), config.axis_y2_show && (scale.y2 = $$.getY(min.y, max.y, scale.y2 ? scale.y2.domain() : config.axis_y2_default), scale.subY2 = $$.getY(min.subY, max.subY, scale.subY2 ? scale.subY2.domain() : config.axis_y2_default), $$.axis.y2TickValues = $$.axis.getTickValues("y2"), $$.axis.y2 = $$.axis.getAxis("y2", scale.y2, config.axis_y2_tick_outer, isInit)), $$.updateArc && $$.updateArc();
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-color","commonjs2":"d3-color","amd":"d3-color","root":"d3"}
var external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_ = __webpack_require__(46);

// CONCATENATED MODULE: ./src/ChartInternal/internals/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_selection = ({
  /**
   * Select a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  selectPoint: function selectPoint(target, d, i) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        isRotated = config.axis_rotated,
        cx = (isRotated ? $$.circleY : $$.circleX).bind($$),
        cy = (isRotated ? $$.circleX : $$.circleY).bind($$),
        r = $$.pointSelectR.bind($$);
    // add selected-circle on low layer g
    callFn(config.data_onselected, $$.api, d, target.node()), main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).data([d]).enter().append("circle").attr("class", function () {
      return $$.generateClass(config_classes.selectedCircle, i);
    }).attr("cx", cx).attr("cy", cy).attr("stroke", $$.color).attr("r", function (d2) {
      return $$.pointSelectR(d2) * 1.4;
    }).transition().duration(100).attr("r", r);
  },

  /**
   * Unelect a point
   * @private
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  unselectPoint: function unselectPoint(target, d, i) {
    var $$ = this;
    // remove selected-circle from low layer g
    callFn($$.config.data_onunselected, $$.api, d, target.node()), $$.$el.main.select("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll("." + config_classes.selectedCircle + "-" + i).transition().duration(100).attr("r", 0).remove();
  },

  /**
   * Toggles the selection of points
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target point
   * @param {Object} data
   * @param {Number} index
   */
  togglePoint: function togglePoint(selected, target, d, i) {
    var method = (selected ? "" : "un") + "selectPoint";
    this[method](target, d, i);
  },

  /**
   * Select a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  selectPath: function selectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return Object(external_commonjs_d3_color_commonjs2_d3_color_amd_d3_color_root_d3_["rgb"])($$.color(d)).brighter(.75);
    });
  },

  /**
   * Unelect a path
   * @private
   * @param {Object} target path
   * @param {Object} data
   */
  unselectPath: function unselectPath(target, d) {
    var $$ = this,
        config = $$.config;
    callFn(config.data_onunselected, $$, d, target.node()), config.interaction_brighten && target.transition().duration(100).style("fill", function () {
      return $$.color(d);
    });
  },

  /**
   * Toggles the selection of lines
   * @private
   * @param {Boolean} whether or not to select.
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  togglePath: function togglePath(selected, target, d, i) {
    this[(selected ? "" : "un") + "selectPath"](target, d, i);
  },

  /**
   * Returns the toggle method of the target
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @returns {Function} toggle method
   */
  getToggle: function getToggle(that, d) {
    var $$ = this;
    return that.nodeName === "path" ? $$.togglePath : $$.isStepType(d) ? function () {} : // circle is hidden in step chart, so treat as within the click area
    $$.togglePoint;
  },

  /**
   * Toggles the selection of shapes
   * @private
   * @param {Object} target shape
   * @param {Object} data
   * @param {Number} index
   */
  toggleShape: function toggleShape(that, d, i) {
    var toggledShape,
        $$ = this,
        config = $$.config,
        main = $$.$el.main,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that),
        isSelected = shape.classed(config_classes.SELECTED),
        toggle = $$.getToggle(that, d).bind($$);

    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {
      if (!config.data_selection_multiple) {
        var selector = "." + config_classes.shapes;
        config.data_selection_grouped && (selector += $$.getTargetSelectorSuffix(d.id)), main.selectAll(selector).selectAll("." + config_classes.shape).each(function (d, i) {
          var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
          shape.classed(config_classes.SELECTED) && (toggledShape = shape, toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
        });
      }

      toggledShape && toggledShape.node() === shape.node() || (shape.classed(config_classes.SELECTED, !isSelected), toggle(!isSelected, shape, d, i));
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/size.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_size = ({
  /**
   * Update container size
   * @private
   */
  setContainerSize: function setContainerSize() {
    var $$ = this,
        state = $$.state;
    state.currentWidth = $$.getCurrentWidth(), state.currentHeight = $$.getCurrentHeight();
  },
  getCurrentWidth: function getCurrentWidth() {
    var $$ = this;
    return $$.config.size_width || $$.getParentWidth();
  },
  getCurrentHeight: function getCurrentHeight() {
    var $$ = this,
        config = $$.config,
        h = config.size_height || $$.getParentHeight();
    return h > 0 ? h : 320 / ($$.hasType("gauge") && !config.gauge_fullCircle ? 2 : 1);
  },

  /**
   * Get Axis size according its position
   * @param {String} id Axis id value - x, y or y2
   * @return {number} size Axis size value
   * @private
   */
  getAxisSize: function getAxisSize(id) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;
    return isRotated && id === "x" || !isRotated && /y2?/.test(id) ? $$.getAxisWidthByAxisId(id, !0) : $$.getHorizontalAxisHeight(id);
  },
  getCurrentPaddingTop: function getCurrentPaddingTop() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        axesLen = config.axis_y2_axes.length,
        padding = isValue(config.padding_top) ? config.padding_top : 0;
    return $el.title && $el.title.node() && (padding += $$.getTitlePadding()), axesLen && config.axis_rotated && (padding += $$.getHorizontalAxisHeight("y2") * axesLen), padding;
  },
  getCurrentPaddingBottom: function getCurrentPaddingBottom() {
    var $$ = this,
        config = $$.config,
        axisId = config.axis_rotated ? "y" : "x",
        axesLen = config["axis_" + axisId + "_axes"].length,
        padding = isValue(config.padding_bottom) ? config.padding_bottom : 0;
    return padding + (axesLen ? $$.getHorizontalAxisHeight(axisId) * axesLen : 0);
  },
  getCurrentPaddingLeft: function getCurrentPaddingLeft(withoutRecompute) {
    var padding,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        axisId = isRotated ? "x" : "y",
        axesLen = config["axis_" + axisId + "_axes"].length,
        axisWidth = $$.getAxisWidthByAxisId(axisId, withoutRecompute);
    return padding = isValue(config.padding_left) ? config.padding_left : isRotated ? config.axis_x_show ? Math.max(ceil10(axisWidth), 40) : 1 : !config.axis_y_show || config.axis_y_inner ? $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1 : ceil10(axisWidth), padding + axisWidth * axesLen;
  },
  getCurrentPaddingRight: function getCurrentPaddingRight() {
    var padding,
        $$ = this,
        config = $$.config,
        legendWidthOnRight = $$.state.isLegendRight ? $$.getLegendWidth() + 20 : 0,
        axesLen = config.axis_y2_axes.length,
        axisWidth = $$.getAxisWidthByAxisId("y2");
    return padding = isValue(config.padding_right) ? config.padding_right + 1 : config.axis_rotated ? 10 + legendWidthOnRight : !config.axis_y2_show || config.axis_y2_inner ? 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0) : ceil10(axisWidth) + legendWidthOnRight, padding + axisWidth * axesLen;
  },

  /**
   * Get the parent rect element's size
   * @param {String} key property/attribute name
   * @private
   */
  getParentRectValue: function getParentRectValue(key) {
    for (var v, offsetName = "offset" + capitalize(key), parent = this.$el.chart.node(); !v && parent && parent.tagName !== "BODY";) {
      try {
        v = parent.getBoundingClientRect()[key];
      } catch (e) {
        offsetName in parent && (v = parent[offsetName]);
      }

      parent = parent.parentNode;
    }

    if (key === "width") {
      // Sometimes element's width value is incorrect(ex. flex container)
      // In this case, use body's offsetWidth instead.
      var bodyWidth = browser_doc.body.offsetWidth;
      v > bodyWidth && (v = bodyWidth);
    }

    return v;
  },
  getParentWidth: function getParentWidth() {
    return this.getParentRectValue("width");
  },
  getParentHeight: function getParentHeight() {
    var h = this.$el.chart.style("height");
    return h.indexOf("px") > 0 ? parseInt(h, 10) : 0;
  },
  getSvgLeft: function getSvgLeft(withoutRecompute) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,
        leftAxisClass = config.axis_rotated ? config_classes.axisX : config_classes.axisY,
        leftAxis = $el.main.select("." + leftAxisClass).node(),
        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {
      right: 0
    },
        chartRect = $el.chart.node().getBoundingClientRect(),
        hasArc = $$.hasArcType(),
        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));
    return svgLeft > 0 ? svgLeft : 0;
  },
  getAxisWidthByAxisId: function getAxisWidthByAxisId(id, withoutRecompute) {
    var $$ = this,
        position = $$.axis.getLabelPositionById(id);
    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);
  },
  getHorizontalAxisHeight: function getHorizontalAxisHeight(id) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        rotatedPadding = _$$$state.rotatedPadding,
        isLegendRight = _$$$state.isLegendRight,
        isLegendInset = _$$$state.isLegendInset,
        isRotated = config.axis_rotated,
        h = 30;
    if (id === "x" && !config.axis_x_show) return 8;
    if (id === "x" && config.axis_x_height) return config.axis_x_height;
    if (id === "y" && !config.axis_y_show) return !config.legend_show || isLegendRight || isLegendInset ? 1 : 10;
    if (id === "y2" && !config.axis_y2_show) return rotatedPadding.top;
    var rotate = config["axis_" + id + "_tick_rotate"]; // Calculate x/y axis height when tick rotated

    return (id === "x" && !isRotated || /y2?/.test(id) && isRotated) && rotate && (h = 30 + $$.axis.getMaxTickWidth(id) * Math.cos(Math.PI * (90 - rotate) / 180)), h + ($$.axis.getLabelPositionById(id).isInner ? 0 : 10) + (id !== "y2" || isRotated ? 0 : -10);
  },
  getEventRectWidth: function getEventRectWidth() {
    return Math.max(0, this.axis.x.tickInterval());
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/text.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var internals_text = ({
  /**
   * Initializes the text
   * @private
   */
  initText: function initText() {
    var $$ = this,
        $el = $$.$el;
    $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartTexts), $el.text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]);
  },

  /**
   * Update chartText
   * @private
   * @param {Object} $$.data.targets
   */
  updateTargetsForText: function updateTargetsForText(targets) {
    var $$ = this,
        classChartText = $$.classChartText.bind($$),
        classTexts = $$.classTexts.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainTextUpdate = $$.$el.main.select("." + config_classes.chartTexts).selectAll("." + config_classes.chartText).data(targets).attr("class", function (d) {
      return classChartText(d) + classFocus(d);
    }),
        mainTextEnter = mainTextUpdate.enter().append("g").attr("class", classChartText).style("opacity", "0").style("pointer-events", "none");
    mainTextEnter.append("g").attr("class", classTexts);
  },

  /**
   * Update text
   * @private
   * @param {Number} Fade-out transition duration
   */
  updateText: function updateText(durationForExit) {
    var _this = this,
        $$ = this,
        config = $$.config,
        $el = $$.$el,
        dataFn = $$.labelishData.bind($$),
        classText = $$.classText.bind($$);

    $el.text = $el.main.selectAll("." + config_classes.texts).selectAll("." + config_classes.text).data(function (d) {
      return _this.isRadarType(d) ? d.values : dataFn(d);
    }), $el.text.exit().transition().duration(durationForExit).style("fill-opacity", "0").remove(), $el.text = $el.text.enter().append("text").merge($$.$el.text).attr("class", classText).attr("text-anchor", function (d) {
      return config.axis_rotated ? d.value < 0 ? "end" : "start" : "middle";
    }).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", "0").text(function (d, i, j) {
      var value = $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value;
      return $$.dataLabelFormat(d.id)(value, d.id, i, j);
    });
  },
  updateTextColor: function updateTextColor(d) {
    var color,
        $$ = this,
        labelColors = $$.config.data_labels_colors;
    return isString(labelColors) ? color = labelColors : isObject(labelColors) && (color = labelColors[d.id]), color || $$.color(d);
  },

  /**
   * Redraw chartText
   * @param {Function} x Positioning function for x
   * @param {Function} y Positioning function for y
   * @param {Boolean} forFlow
   * @param {Boolean} withTransition transition is enabled
   * @private
   */
  redrawText: function redrawText(x, y, forFlow, withTransition) {
    var $$ = this,
        t = getRandom(),
        opacityForText = forFlow ? 0 : $$.opacityForText.bind($$);
    return [this.$el.text.each(function () {
      var text = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this); // do not apply transition for newly added text elements

      (withTransition && text.attr("x") ? text.transition(t) : text).attr("x", x).attr("y", y).style("fill", $$.updateTextColor.bind($$)).style("fill-opacity", opacityForText);
    })];
  },

  /**
   * Gets the getBoundingClientRect value of the element
   * @private
   * @param {HTMLElement|d3.selection} element
   * @param {String} className
   * @returns {Object} value of element.getBoundingClientRect()
   */
  getTextRect: function getTextRect(element, className) {
    var $$ = this,
        base = element.node ? element.node() : element;
    /text/i.test(base.tagName) || (base = base.querySelector("text"));
    var text = base.textContent,
        cacheKey = "$" + text.replace(/\W/g, "_"),
        rect = $$.cache.get(cacheKey);
    return rect || ($$.$el.svg.append("text").style("visibility", "hidden").style("font", Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(base).style("font")).classed(className, !0).text(text).call(function (v) {
      rect = getBoundingRect(v.node());
    }).remove(), $$.cache.add(cacheKey, rect)), rect;
  },

  /**
   * Gets the x or y coordinate of the text
   * @param {Object} indices Indices values
   * @param {Boolean} forX whether or not to x
   * @returns {Number} coordinates
   * @private
   */
  generateXYForText: function generateXYForText(indices, forX) {
    var $$ = this,
        types = Object.keys(indices),
        points = {},
        getter = forX ? $$.getXForText : $$.getYForText;
    return $$.hasType("radar") && types.push("radar"), types.forEach(function (v) {
      points[v] = $$["generateGet" + capitalize(v) + "Points"](indices[v], !1);
    }), function (d, i) {
      var type = $$.isAreaType(d) && "area" || $$.isBarType(d) && "bar" || $$.isRadarType(d) && "radar" || "line";
      return getter.call($$, points[type](d, i), d, this);
    };
  },

  /**
   * Get centerized text position for bar type data.label.text
   * @private
   * @param {Object} d Data object
   * @param {Array} points Data points position
   * @param {HTMLElement} textElement Data label text element
   * @returns {Number} Position value
   */
  getCenteredTextPos: function getCenteredTextPos(d, points, textElement) {
    var $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated;

    if (config.data_labels.centered && $$.isBarType(d)) {
      var rect = getBoundingRect(textElement),
          isPositive = d.value >= 0;

      if (isRotated) {
        var w = (isPositive ? points[1][1] - points[0][1] : points[0][1] - points[1][1]) / 2 + rect.width / 2;
        return isPositive ? -w - 3 : w + 2;
      }

      var h = (isPositive ? points[0][1] - points[1][1] : points[1][1] - points[0][1]) / 2 + rect.height / 2;
      return isPositive ? h : -h - 2;
    }

    return 0;
  },

  /**
   * Get data.labels.position value
   * @param {String} id Data id value
   * @param {String} type x | y
   * @return {Number} Position value
   * @private
   */
  getTextPos: function getTextPos(id, type) {
    var pos = this.config.data_labels_position;
    return (id in pos ? pos[id] : pos)[type] || 0;
  },

  /**
   * Gets the x coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} x coordinate
   */
  getXForText: function getXForText(points, d, textElement) {
    var xPos,
        padding,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated;
    // show labels regardless of the domain if value is null
    if (isRotated ? (padding = $$.isBarType(d) ? 4 : 6, xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)) : xPos = $$.hasType("bar") ? (points[2][0] + points[0][0]) / 2 : points[0][0], d.value === null) if (xPos > state.width) {
      var _getBoundingRect = getBoundingRect(textElement),
          width = _getBoundingRect.width;

      xPos = state.width - width;
    } else xPos < 0 && (xPos = 4);
    return isRotated && (xPos += $$.getCenteredTextPos(d, points, textElement)), xPos + $$.getTextPos(d.id, "x");
  },

  /**
   * Gets the y coordinate of the text
   * @private
   * @param {Object} points
   * @param {Object} data
   * @param {HTMLElement} element
   * @returns {Number} y coordinate
   */
  getYForText: function getYForText(points, d, textElement) {
    var yPos,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        r = config.point_r,
        rect = getBoundingRect(textElement),
        baseY = 3;
    if (isRotated) yPos = (points[0][0] + points[2][0] + rect.height * .6) / 2;else if (yPos = points[2][1], isNumber(r) && r > 5 && ($$.isLineType(d) || $$.isScatterType(d)) && (baseY += config.point_r / 2.3), d.value < 0 || d.value === 0 && !state.hasPositiveValue && state.hasNegativeValue) yPos += rect.height + ($$.isBarType(d) ? -baseY : baseY);else {
      var diff = -baseY * 2;
      $$.isBarType(d) ? diff = -baseY : $$.isBubbleType(d) && (diff = baseY), yPos += diff;
    } // show labels regardless of the domain if value is null

    if (d.value === null && !isRotated) {
      var boxHeight = rect.height;
      yPos < boxHeight ? yPos = boxHeight : yPos > this.height && (yPos = this.height - 4);
    }

    return isRotated || (yPos += $$.getCenteredTextPos(d, points, textElement)), yPos + $$.getTextPos(d.id, "y");
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Mark overlapping text nodes with "text-overlapping" class
   * @private
   * @param {number} id
   * @param {ChartInternal} $$
   * @param {string} selector
   */
  markOverlapped: function markOverlapped(id, $$, selector) {
    var textNodes = $$.$el.arcs.selectAll(selector),
        filteredTextNodes = textNodes.filter(function (node) {
      return node.data.id !== id;
    }),
        textNode = textNodes.filter(function (node) {
      return node.data.id === id;
    }),
        translate = getTranslation(textNode.node()),
        calcHypo = function (x, y) {
      return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
    };

    textNode.node() && filteredTextNodes.each(function () {
      var coordinate = getTranslation(this),
          filteredTextNode = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          nodeForWidth = calcHypo(translate.e, translate.f) > calcHypo(coordinate.e, coordinate.f) ? textNode : filteredTextNode,
          overlapsX = Math.ceil(Math.abs(translate.e - coordinate.e)) < Math.ceil(nodeForWidth.node().getComputedTextLength()),
          overlapsY = Math.ceil(Math.abs(translate.f - coordinate.f)) < parseInt(textNode.style("font-size"), 0);
      filteredTextNode.classed(config_classes.TextOverlapping, overlapsX && overlapsY);
    });
  },

  /**
   * Calculate if two or more text nodes are overlapping
   * Remove "text-overlapping" class on selected text nodes
   * @private
   * @param {ChartInternal} $$
   * @param {string} selector
   */
  undoMarkOverlapped: function undoMarkOverlapped($$, selector) {
    $$.$el.arcs.selectAll(selector).each(function () {
      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([this, this.previousSibling]).classed(config_classes.TextOverlapping, !1);
    });
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/title.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Get the text position
 * @param {String} pos right, left or center
 * @param {Number} width chart width
 * @return {String|Number} text-anchor value or position in pixel
 * @private
 */

function getTextPos(pos, width) {
  pos === void 0 && (pos = "left");
  var position,
      isNum = isNumber(width);
  return position = pos.indexOf("center") > -1 ? isNum ? width / 2 : "middle" : pos.indexOf("right") > -1 ? isNum ? width : "end" : isNum ? 0 : "start", position;
}

/* harmony default export */ var internals_title = ({
  /**
   * Initializes the title
   * @private
   */
  initTitle: function initTitle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.title_text) {
      $el.title = $el.svg.append("g");
      var text = $el.title.append("text").style("text-anchor", getTextPos(config.title_position)).attr("class", config_classes.title);
      setTextValue(text, config.title_text, [.3, 1.5]);
    }
  },

  /**
   * Redraw title
   * @private
   */
  redrawTitle: function redrawTitle() {
    var $$ = this,
        config = $$.config,
        currentWidth = $$.state.currentWidth,
        title = $$.$el.title;

    if (title) {
      var y = $$.yForTitle.call($$);
      /g/i.test(title.node().tagName) ? title.attr("transform", "translate(" + getTextPos(config.title_position, currentWidth) + ", " + y + ")") : title.attr("x", $$.xForTitle.call($$)).attr("y", y);
    }
  },

  /**
   * Returns the x attribute value of the title
   * @private
   * @returns {Number} x attribute value
   */
  xForTitle: function xForTitle() {
    var x,
        $$ = this,
        config = $$.config,
        currentWidth = $$.state.currentWidth,
        position = config.title_position || "left",
        textRectWidth = $$.getTextRect($$.$el.title, config_classes.title).width;
    return /(right|center)/.test(position) ? (x = currentWidth - textRectWidth, position.indexOf("right") >= 0 ? x = currentWidth - textRectWidth - config.title_padding.right : position.indexOf("center") >= 0 && (x = (currentWidth - textRectWidth) / 2)) : x = config.title_padding.left || 0, x;
  },

  /**
   * Returns the y attribute value of the title
   * @private
   * @returns {Number} y attribute value
   */
  yForTitle: function yForTitle() {
    var $$ = this;
    return ($$.config.title_padding.top || 0) + $$.getTextRect($$.$el.title, config_classes.title).height;
  },

  /**
   * Get title padding
   * @private
   * @returns {Number} padding value
   */
  getTitlePadding: function getTitlePadding() {
    var $$ = this;
    return $$.yForTitle() + ($$.config.title_padding.bottom || 0);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var internals_tooltip = ({
  /**
   * Initializes the tooltip
   * @private
   */
  initTooltip: function initTooltip() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el,
        bindto = config.tooltip_contents.bindto;

    // Show tooltip if needed
    if ($el.tooltip = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto), $el.tooltip.empty() && ($el.tooltip = $el.chart.style("position", "relative").append("div").attr("class", config_classes.tooltipContainer).style("position", "absolute").style("pointer-events", "none").style("display", "none")), config.tooltip_init_show) {
      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {
        var i,
            val,
            targets = $$.data.targets[0];

        for (config.tooltip_init_x = $$.parseDate(config.tooltip_init_x), i = 0; (val = targets.values[i]) && val.x - config.tooltip_init_x !== 0; i++);

        config.tooltip_init_x = i;
      }

      $el.tooltip.html($$.getTooltipHTML($$.data.targets.map(function (d) {
        return $$.addName(d.values[config.tooltip_init_x]);
      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType(null, ["radar"])), $$.color)), bindto || $el.tooltip.style("top", config.tooltip_init_position.top).style("left", config.tooltip_init_position.left).style("display", "block");
    }
  },

  /**
   * Get the tooltip HTML string
   * @param  {...any} args
   * @private
   * @return {String} Formatted HTML string
   */
  getTooltipHTML: function getTooltipHTML() {
    for (var _config$tooltip_conte, _$$2, $$ = this, config = $$.config, _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

    return isFunction(config.tooltip_contents) ? (_config$tooltip_conte = config.tooltip_contents).call.apply(_config$tooltip_conte, [$$].concat(args)) : (_$$2 = $$).getTooltipContent.apply(_$$2, args);
  },

  /**
   * Returns the tooltip content(HTML string)
   * @param {Object} d data
   * @param {Function} defaultTitleFormat Default title format
   * @param {Function} defaultValueFormat Default format for each data value in the tooltip.
   * @param {Function} color Color function
   * @returns {String} html
   * @private
   */
  getTooltipContent: function getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) {
    var $$ = this,
        config = $$.config,
        titleFormat = config.tooltip_format_title || defaultTitleFormat,
        nameFormat = config.tooltip_format_name || function (name) {
      return name;
    },
        valueFormat = config.tooltip_format_value || ($$.isStackNormalized() ? function (v, ratio) {
      return (ratio * 100).toFixed(2) + "%";
    } : defaultValueFormat),
        order = config.tooltip_order,
        getRowValue = function (row) {
      return $$.isBubbleZType(row) ? $$.getBubbleZData(row.value, "z") : $$.getBaseValue(row);
    },
        getBgColor = $$.levelColor ? function (row) {
      return $$.levelColor(row.value);
    } : function (row) {
      return color(row);
    },
        contents = config.tooltip_contents,
        tplStr = contents.template,
        targetIds = $$.mapToTargetIds();

    if (order === null && config.data_groups.length) {
      // for stacked data, order should aligned with the visually displayed data
      var ids = $$.orderTargets($$.data.targets).map(function (i2) {
        return i2.id;
      }).reverse();
      d.sort(function (a, b) {
        var v1 = a ? a.value : null,
            v2 = b ? b.value : null;
        return v1 > 0 && v2 > 0 && (v1 = a.id ? ids.indexOf(a.id) : null, v2 = b.id ? ids.indexOf(b.id) : null), v1 - v2;
      });
    } else if (/^(asc|desc)$/.test(order)) {
      d.sort(function (a, b) {
        var v1 = a ? getRowValue(a) : null,
            v2 = b ? getRowValue(b) : null;
        return order === "asc" ? v1 - v2 : v2 - v1;
      });
    } else isFunction(order) && d.sort(order);

    var text,
        row,
        param,
        value,
        i,
        tpl = $$.getTooltipContentTemplate(tplStr),
        len = d.length;

    for (i = 0; i < len; i++) if (row = d[i], row && (getRowValue(row) || getRowValue(row) === 0)) {
      if (isUndefined(text)) {
        var title = sanitise(titleFormat ? titleFormat(row.x) : row.x);
        text = tplProcess(tpl[0], {
          CLASS_TOOLTIP: config_classes.tooltip,
          TITLE: isValue(title) ? tplStr ? title : "<tr><th colspan=\"2\">" + title + "</th></tr>" : ""
        });
      }

      if (param = [row.ratio, row.id, row.index, d], value = sanitise(valueFormat.apply(void 0, [getRowValue(row)].concat(param))), $$.isAreaRangeType(row)) {
        var _map = ["high", "low"].map(function (v) {
          return sanitise(valueFormat.apply(void 0, [$$.getAreaRangeData(row, v)].concat(param)));
        }),
            high = _map[0],
            low = _map[1];

        value = "<b>Mid:</b> " + value + " <b>High:</b> " + high + " <b>Low:</b> " + low;
      }

      if (value !== undefined) {
        var _ret = function () {
          // Skip elements when their name is set to null
          if (row.name === null) return "continue";
          var name = sanitise(nameFormat.apply(void 0, [row.name].concat(param))),
              color = getBgColor(row),
              contentValue = {
            CLASS_TOOLTIP_NAME: config_classes.tooltipName + $$.getTargetSelectorSuffix(row.id),
            COLOR: tplStr || !$$.patterns ? color : "<svg><rect style=\"fill:" + color + "\" width=\"10\" height=\"10\"></rect></svg>",
            NAME: name,
            VALUE: value
          };

          if (tplStr && isObject(contents.text)) {
            var index = targetIds.indexOf(row.id);
            Object.keys(contents.text).forEach(function (key) {
              contentValue[key] = contents.text[key][index];
            });
          }

          text += tplProcess(tpl[1], contentValue);
        }();

        if (_ret === "continue") continue;
      }
    }

    return text + "</table>";
  },

  /**
   * Get the content template string
   * @param {String} tplStr
   * @return {String} Template string
   * @private
   */
  getTooltipContentTemplate: function getTooltipContentTemplate(tplStr) {
    return (tplStr || "<table class=\"{=CLASS_TOOLTIP}\"><tbody>\n\t\t\t\t{=TITLE}\n\t\t\t\t{{<tr class=\"{=CLASS_TOOLTIP_NAME}\">\n\t\t\t\t\t<td class=\"name\">" + (this.patterns ? "{=COLOR}" : "<span style=\"background-color:{=COLOR}\"></span>") + "{=NAME}</td>\n\t\t\t\t\t<td class=\"value\">{=VALUE}</td>\n\t\t\t\t</tr>}}\n\t\t\t</tbody></table>").replace(/(\r?\n|\t)/g, "").split(/{{(.*)}}/);
  },

  /**
   * Returns the position of the tooltip
   * @param {Object} dataToShow data
   * @param {String} tWidth Width value of tooltip element
   * @param {String} tHeight Height value of tooltip element
   * @param {HTMLElement} element
   * @returns {Object} top, left value
   * @private
   */
  tooltipPosition: function tooltipPosition(dataToShow, tWidth, tHeight, element) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        _$$$state = $$.state,
        width = _$$$state.width,
        height = _$$$state.height,
        currentWidth = _$$$state.currentWidth,
        currentHeight = _$$$state.currentHeight,
        isLegendRight = _$$$state.isLegendRight,
        inputType = _$$$state.inputType,
        hasGauge = $$.hasType("gauge") && !config.gauge_fullCircle,
        svgLeft = $$.getSvgLeft(!0),
        _d3Mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(element),
        left = _d3Mouse[0],
        top = _d3Mouse[1],
        chartRight = svgLeft + currentWidth - $$.getCurrentPaddingRight();

    // Determine tooltip position
    if (top += 20, $$.hasArcType()) {
      var raw = inputType === "touch" || $$.hasType("radar");
      raw || (top += hasGauge ? height : height / 2, left += (width - (isLegendRight ? $$.getLegendWidth() : 0)) / 2);
    } else {
      var dataScale = scale.x(dataToShow[0].x);
      config.axis_rotated ? (top = dataScale + 20, left += svgLeft + 100, chartRight -= svgLeft) : (top -= 5, left = svgLeft + $$.getCurrentPaddingLeft(!0) + 20 + (scale.zoom ? left : dataScale));
    }

    var right = left + tWidth;
    return right > chartRight && (left -= right - chartRight + 20), top + tHeight > currentHeight && (top -= hasGauge ? tHeight * 3 : tHeight + 30), top < 0 && (top = 0), {
      top: top,
      left: left
    };
  },

  /**
   * Show the tooltip
   * @private
   * @param {Object} selectedData
   * @param {HTMLElement} element
   */
  showTooltip: function showTooltip(selectedData, element) {
    var $$ = this,
        config = $$.config,
        tooltip = $$.$el.tooltip,
        bindto = config.tooltip_contents.bindto,
        forArc = $$.hasArcType(null, ["radar"]),
        dataToShow = selectedData.filter(function (d) {
      return d && isValue($$.getBaseValue(d));
    }),
        positionFunction = config.tooltip_position || $$.tooltipPosition;

    if (dataToShow.length !== 0 && config.tooltip_show) {
      var datum = tooltip.datum(),
          dataStr = JSON.stringify(selectedData),
          width = datum && datum.width || 0,
          height = datum && datum.height || 0;

      if (!datum || datum.current !== dataStr) {
        var index = selectedData.concat().sort()[0].index;
        callFn(config.tooltip_onshow, $$, $$.api, selectedData), tooltip.html($$.getTooltipHTML(selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style("display", null).style("visibility", null) // for IE9
        .datum({
          index: index,
          current: dataStr,
          width: width = tooltip.property("offsetWidth"),
          height: height = tooltip.property("offsetHeight")
        }), callFn(config.tooltip_onshown, $$, $$.api, selectedData), $$._handleLinkedCharts(!0, index);
      }

      if (!bindto) {
        // Get tooltip dimensions
        var position = positionFunction.call(this, dataToShow, width, height, element); // Set tooltip position

        tooltip.style("top", position.top + "px").style("left", position.left + "px");
      }
    }
  },

  /**
   * Hide the tooltip
   * @param {Boolean} force Force to hide
   * @private
   */
  hideTooltip: function hideTooltip(force) {
    var $$ = this,
        config = $$.config,
        tooltip = $$.$el.tooltip;

    if (tooltip.style("display") !== "none" && (!config.tooltip_doNotHide || force)) {
      var selectedData = JSON.parse(tooltip.datum().current);
      // hide tooltip
      callFn(config.tooltip_onhide, $$, $$.api, selectedData), tooltip.style("display", "none").style("visibility", "hidden") // for IE9
      .datum(null), callFn(config.tooltip_onhidden, $$, $$.api, selectedData);
    }
  },

  /**
   * Toggle display for linked chart instances
   * @param {Boolean} show true: show, false: hide
   * @param {Number} index x Axis index
   * @private
   */
  _handleLinkedCharts: function _handleLinkedCharts(show, index) {
    var $$ = this,
        config = $$.config,
        charts = $$.charts;

    if (config.tooltip_linked && charts.length > 1) {
      var linkedName = config.tooltip_linked_name;
      charts.forEach(function (c) {
        if (c !== $$.api) {
          var _config = c.internal.config,
              isLinked = _config.tooltip_linked,
              name = _config.tooltip_linked_name,
              isInDom = browser_doc.body.contains(c.element);

          if (isLinked && linkedName === name && isInDom) {
            var data = c.internal.$el.tooltip.data()[0],
                isNotSameIndex = index !== (data && data.index);

            // prevent throwing error for non-paired linked indexes
            try {
              show && isNotSameIndex ? c.tooltip.show({
                index: index
              }) : !show && c.tooltip.hide();
            } catch (e) {}
          }
        }
      });
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/internals/type.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
 // defined chart types as category

var TYPES = {
  Area: ["area", "area-spline", "area-spline-range", "area-line-range", "area-step"],
  AreaRange: ["area-spline-range", "area-line-range"],
  Arc: ["pie", "donut", "gauge", "radar"],
  Line: ["line", "spline", "area", "area-spline", "area-spline-range", "area-line-range", "step", "area-step"],
  Step: ["step", "area-step"],
  Spline: ["spline", "area-spline", "area-spline-range"]
};
/* harmony default export */ var internals_type = ({
  setTargetType: function setTargetType(targetIds, type) {
    var $$ = this,
        config = $$.config,
        withoutFadeIn = $$.state.withoutFadeIn;
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      withoutFadeIn[id] = type === config.data_types[id], config.data_types[id] = type;
    }), targetIds || (config.data_type = type);
  },
  hasType: function hasType(type, targetsValue) {
    var $$ = this,
        config = $$.config,
        types = config.data_types,
        targets = targetsValue || $$.data.targets,
        has = !1;
    return targets && targets.length ? targets.forEach(function (target) {
      var t = types[target.id];
      (t && t.indexOf(type) >= 0 || !t && type === "line") && (has = !0);
    }) : Object.keys(types).length ? Object.keys(types).forEach(function (id) {
      types[id] === type && (has = !0);
    }) : has = config.data_type === type, has;
  },

  /**
   * Check if contains given chart types
   * @parma {String} type Type key
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasTypeOf: function hasTypeOf(type, targets, exclude) {
    var _this = this;

    return exclude === void 0 && (exclude = []), !TYPES[type] // @ts-ignore
    .filter(function (v) {
      return exclude.indexOf(v) === -1;
    }).every(function (v) {
      return !_this.hasType(v, targets);
    });
  },

  /**
   * Check if given data is certain chart type
   * @param {Object} d Data object
   * @param {String|Array} type chart type
   * @return {Boolean}
   * @private
   */
  isTypeOf: function isTypeOf(d, type) {
    var id = isString(d) ? d : d.id,
        dataType = this.config.data_types[id];
    return isArray(type) ? type.indexOf(dataType) >= 0 : dataType === type;
  },

  /**
   * Check if contains arc types chart
   * @param {Object} targets
   * @param {Array} exclude Excluded types
   * @return {boolean}
   * @private
   */
  hasArcType: function hasArcType(targets, exclude) {
    return this.hasTypeOf("Arc", targets, exclude);
  },
  hasMultiArcGauge: function hasMultiArcGauge() {
    return this.hasType("gauge") && this.config.gauge_type === "multi";
  },
  isLineType: function isLineType(d) {
    var id = isString(d) ? d : d.id;
    return !this.config.data_types[id] || this.isTypeOf(id, TYPES.Line);
  },
  isStepType: function isStepType(d) {
    return this.isTypeOf(d, TYPES.Step);
  },
  isSplineType: function isSplineType(d) {
    return this.isTypeOf(d, TYPES.Spline);
  },
  isAreaType: function isAreaType(d) {
    return this.isTypeOf(d, TYPES.Area);
  },
  isAreaRangeType: function isAreaRangeType(d) {
    return this.isTypeOf(d, TYPES.AreaRange);
  },
  isBarType: function isBarType(d) {
    return this.isTypeOf(d, "bar");
  },
  isBubbleType: function isBubbleType(d) {
    return this.isTypeOf(d, "bubble");
  },
  isScatterType: function isScatterType(d) {
    return this.isTypeOf(d, "scatter");
  },
  isPieType: function isPieType(d) {
    return this.isTypeOf(d, "pie");
  },
  isGaugeType: function isGaugeType(d) {
    return this.isTypeOf(d, "gauge");
  },
  isDonutType: function isDonutType(d) {
    return this.isTypeOf(d, "donut");
  },
  isRadarType: function isRadarType(d) {
    return this.isTypeOf(d, "radar");
  },
  isArcType: function isArcType(d) {
    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d) || this.isRadarType(d);
  },
  // determine if is 'circle' data point
  isCirclePoint: function isCirclePoint() {
    var config = this.config,
        pattern = config.point_pattern;
    return config.point_type === "circle" && (!pattern || isArray(pattern) && pattern.length === 0);
  },
  lineData: function lineData(d) {
    return this.isLineType(d) ? [d] : [];
  },
  arcData: function arcData(d) {
    return this.isArcType(d.data) ? [d] : [];
  },
  barData: function barData(d) {
    return this.isBarType(d) ? d.values : [];
  },

  /**
   * Get data adapt for data label showing
   * @param {Object} d Data object
   * @return {Array}
   * @private
   */
  labelishData: function labelishData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isScatterType(d) || this.isBubbleType(d) || this.isRadarType(d) ? d.values : [];
  },
  barLineBubbleData: function barLineBubbleData(d) {
    return this.isBarType(d) || this.isLineType(d) || this.isBubbleType(d) ? d.values : [];
  },
  // https://github.com/d3/d3-shape#curves
  isInterpolationType: function isInterpolationType(type) {
    return ["basis", "basis-closed", "basis-open", "bundle", "cardinal", "cardinal-closed", "cardinal-open", "catmull-rom", "catmull-rom-closed", "catmull-rom-open", "linear", "linear-closed", "monotone-x", "monotone-y", "natural"].indexOf(type) >= 0;
  }
});
// EXTERNAL MODULE: external {"commonjs":"d3-shape","commonjs2":"d3-shape","amd":"d3-shape","root":"d3"}
var external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_ = __webpack_require__(47);

// EXTERNAL MODULE: external {"commonjs":"d3-interpolate","commonjs2":"d3-interpolate","amd":"d3-interpolate","root":"d3"}
var external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_ = __webpack_require__(48);

// CONCATENATED MODULE: ./src/ChartInternal/shape/arc.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






/* harmony default export */ var shape_arc = ({
  initPie: function initPie() {
    var $$ = this,
        config = $$.config,
        dataType = config.data_type,
        padding = config.pie_padding,
        startingAngle = config[dataType + "_startingAngle"] || 0,
        padAngle = ($$.hasType("pie") && padding ? padding * .01 : config[dataType + "_padAngle"]) || 0,
        sortValue = $$.isOrderAsc() || $$.isOrderDesc() ? function (a, b) {
      return $$.isOrderAsc() ? a - b : b - a;
    } : null;
    $$.pie = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["pie"])().startAngle(startingAngle).endAngle(startingAngle + 2 * Math.PI).padAngle(padAngle).sortValues(sortValue).value(function (d) {
      return d.values.reduce(function (a, b) {
        return a + b.value;
      }, 0);
    });
  },
  updateRadius: function updateRadius() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        radius = config.pie_innerRadius,
        padding = config.pie_padding,
        w = config.gauge_width || config.donut_width,
        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * config.gauge_arcs_minWidth;
    state.radiusExpanded = Math.min(state.arcWidth, state.arcHeight) / 2 * ($$.hasMultiArcGauge() ? .85 : 1), state.radius = state.radiusExpanded * .95, state.innerRadiusRatio = w ? (state.radius - w) / state.radius : .6, state.gaugeArcWidth = w || (gaugeArcWidth <= state.radius - state.innerRadius ? state.radius - state.innerRadius : gaugeArcWidth <= state.radius ? gaugeArcWidth : state.radius);
    var innerRadius = radius || (padding ? padding * (state.innerRadiusRatio + .1) : 0); // NOTE: innerRadius can be an object by user setting, only for 'pie' type

    state.innerRadius = $$.hasType("donut") || $$.hasType("gauge") ? state.radius * state.innerRadiusRatio : innerRadius;
  },
  getInnerRadius: function getInnerRadius(d) {
    var $$ = this,
        radius = $$.state.innerRadius;
    return !isNumber(radius) && d && (radius = radius[d.data.id] || 0), radius;
  },
  updateArc: function updateArc() {
    var $$ = this;
    $$.svgArc = $$.getSvgArc(), $$.svgArcExpanded = $$.getSvgArcExpanded();
  },
  updateAngle: function updateAngle(dValue) {
    var $$ = this,
        config = $$.config,
        pie = $$.pie,
        d = dValue,
        found = !1;
    if (!config) return null;
    var radius = Math.PI * (config.gauge_fullCircle ? 2 : 1),
        gStart = config.gauge_startingAngle;

    if (d.data && $$.isGaugeType(d.data)) {
      var totalSum = $$.getTotalDataSum(); // if gauge_max less than totalSum, make totalSum to max value

      totalSum > config.gauge_max && (config.gauge_max = totalSum);
      var gEnd = radius * (totalSum / (config.gauge_max - config.gauge_min));
      pie = pie.startAngle(gStart).endAngle(gEnd + gStart);
    }

    if (pie($$.filterTargetsToShow()).forEach(function (t, i) {
      found || t.data.id !== d.data.id || (found = !0, d = t, d.index = i);
    }), isNaN(d.startAngle) && (d.startAngle = 0), isNaN(d.endAngle) && (d.endAngle = d.startAngle), d.data && $$.hasMultiArcGauge()) {
      var maxValue = $$.getMinMaxData().max[0].value; // if gauge_max less than maxValue, make maxValue to max value

      maxValue > config.gauge_max && (config.gauge_max = maxValue);
      var gMin = config.gauge_min,
          gMax = config.gauge_max,
          gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;
      d.startAngle = gStart, d.endAngle = gStart + radius / (gMax - gMin) * gValue;
    }

    return found ? d : null;
  },
  getSvgArc: function getSvgArc() {
    var $$ = this,
        state = $$.state,
        ir = $$.getInnerRadius(),
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index : state.radius;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : isNumber(ir) ? ir : 0;
    }),
        newArc = function (d, withoutUpdate) {
      var path = "M 0 0";

      if (d.value || d.data) {
        isNumber(ir) || (arc = arc.innerRadius($$.getInnerRadius(d)));
        var updated = !withoutUpdate && $$.updateAngle(d);
        withoutUpdate ? path = arc(d) : updated && (path = arc(updated));
      }

      return path;
    };

    return newArc.centroid = arc.centroid, newArc;
  },
  getSvgArcExpanded: function getSvgArcExpanded(rate) {
    var $$ = this,
        state = $$.state,
        newRate = rate || 1,
        singleArcWidth = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,
        hasMultiArcGauge = $$.hasMultiArcGauge(),
        expandWidth = Math.min(state.radiusExpanded * newRate - state.radius, singleArcWidth * .8 - (1 - newRate) * 100),
        arc = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["arc"])().outerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * d.index + expandWidth : state.radiusExpanded * newRate;
    }).innerRadius(function (d) {
      return hasMultiArcGauge ? state.radius - singleArcWidth * (d.index + 1) : state.innerRadius;
    });
    return function (d) {
      var updated = $$.updateAngle(d);
      return updated ? (hasMultiArcGauge ? arc : arc.innerRadius($$.getInnerRadius(d)))(updated) : "M 0 0";
    };
  },
  getArc: function getArc(d, withoutUpdate, force) {
    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : "M 0 0";
  },
  transformForArcLabel: function transformForArcLabel(d) {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        radius = _$$$state.radius,
        radiusExpanded = _$$$state.radiusExpanded,
        updated = $$.updateAngle(d),
        translate = "";
    if (updated) if ($$.hasMultiArcGauge()) {
      var y1 = Math.sin(updated.endAngle - Math.PI / 2),
          x = Math.cos(updated.endAngle - Math.PI / 2) * (radiusExpanded + 25),
          y = y1 * (radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;
      translate = "translate(" + x + "," + y + ")";
    } else if (!$$.hasType("gauge") || $$.data.targets.length > 1) {
      var c = this.svgArc.centroid(updated),
          x = isNaN(c[0]) ? 0 : c[0],
          y = isNaN(c[1]) ? 0 : c[1],
          h = Math.sqrt(x * x + y * y),
          ratio = $$.hasType("donut") && config.donut_label_ratio || $$.hasType("pie") && config.pie_label_ratio;
      ratio = ratio ? isFunction(ratio) ? ratio(d, radius, h) : ratio : radius && (h ? (36 / radius > .375 ? 1.175 - 36 / radius : .8) * radius / h : 0), translate = "translate(" + x * ratio + "," + y * ratio + ")";
    }
    return translate;
  },
  convertToArcData: function convertToArcData(d) {
    return this.addName({
      id: d.data.id,
      value: d.value,
      ratio: this.getRatio("arc", d),
      index: d.index
    });
  },
  textForArcLabel: function textForArcLabel(selection) {
    var $$ = this;
    $$.shouldShowArcLabel() && selection.each(function (d) {
      var node = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          updated = $$.updateAngle(d),
          value = updated ? updated.value : d.value,
          ratio = $$.getRatio("arc", updated),
          id = d.data.id,
          hasGauge = $$.hasType("gauge"),
          isUnderThreshold = hasGauge || $$.meetsArcLabelThreshold(ratio);

      if (isUnderThreshold) {
        var text = ($$.getArcLabelFormat() || $$.defaultArcValueFormat)(value, ratio, id).toString();
        setTextValue(node, text, [-1, 1], hasGauge);
      }
    });
  },
  textForGaugeMinMax: function textForGaugeMinMax(value, isMax) {
    var format = this.getGaugeLabelExtents();
    return format ? format(value, isMax) : value;
  },
  expandArc: function expandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        $el = $$.$el;

    // MEMO: avoid to cancel transition
    if (transiting) {
      var interval = setInterval(function () {
        transiting || (clearInterval(interval), $el.legend.selectAll("." + config_classes.legendItemFocused).size() > 0 && $$.expandArc(targetIds));
      }, 10);
      return;
    }

    var newTargetIds = $$.mapToTargetIds(targetIds);
    $el.svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).each(function (d) {
      if ($$.shouldExpand(d.data.id)) {
        var expandDuration = $$.getExpandConfig(d.data.id, "duration"),
            svgArcExpandedSub = $$.getSvgArcExpanded($$.getExpandConfig(d.data.id, "rate"));
        Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).selectAll("path").transition().duration(expandDuration).attr("d", $$.svgArcExpanded).transition().duration(expandDuration * 2).attr("d", svgArcExpandedSub);
      }
    });
  },
  unexpandArc: function unexpandArc(targetIds) {
    var $$ = this,
        transiting = $$.state.transiting,
        svg = $$.$el.svg;

    if (!transiting) {
      var newTargetIds = $$.mapToTargetIds(targetIds);
      svg.selectAll($$.selectorTargets(newTargetIds, "." + config_classes.chartArc)).selectAll("path").transition().duration(function (d) {
        return $$.getExpandConfig(d.data.id, "duration");
      }).attr("d", $$.svgArc), svg.selectAll("" + config_classes.arc).style("opacity", "1");
    }
  },

  /**
   * Get expand config value
   * @param {String} id data ID
   * @param {String} key config key: 'duration | rate'
   * @return {Number}
   * @private
   */
  getExpandConfig: function getExpandConfig(id, key) {
    var type,
        $$ = this,
        config = $$.config;
    return $$.isDonutType(id) ? type = "donut" : $$.isGaugeType(id) ? type = "gauge" : $$.isPieType(id) && (type = "pie"), type ? config[type + "_expand_" + key] : {
      duration: 50,
      rate: .98
    }[key];
  },
  shouldExpand: function shouldExpand(id) {
    var $$ = this,
        config = $$.config;
    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;
  },
  shouldShowArcLabel: function shouldShowArcLabel() {
    var $$ = this,
        config = $$.config;
    return ["pie", "donut", "gauge"].some(function (v) {
      return $$.hasType(v) && config[v + "_label_show"];
    });
  },
  meetsArcLabelThreshold: function meetsArcLabelThreshold(ratio) {
    var $$ = this,
        config = $$.config,
        threshold = $$.hasType("donut") ? config.donut_label_threshold : config.pie_label_threshold;
    return ratio >= threshold;
  },
  getArcLabelFormat: function getArcLabelFormat() {
    var $$ = this,
        config = $$.config,
        format = config.pie_label_format;
    return $$.hasType("gauge") ? format = config.gauge_label_format : $$.hasType("donut") && (format = config.donut_label_format), format;
  },
  getGaugeLabelExtents: function getGaugeLabelExtents() {
    var config = this.config;
    return config.gauge_label_extents;
  },
  getArcTitle: function getArcTitle() {
    var $$ = this,
        type = $$.hasType("donut") && "donut" || $$.hasType("gauge") && "gauge";
    return type ? $$.config[type + "_title"] : "";
  },
  updateTargetsForArc: function updateTargetsForArc(targets) {
    var $$ = this,
        main = $$.$el.main,
        hasGauge = $$.hasType("gauge"),
        classChartArc = $$.classChartArc.bind($$),
        classArcs = $$.classArcs.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainPieUpdate = main.select("." + config_classes.chartArcs).selectAll("." + config_classes.chartArc).data($$.pie(targets)).attr("class", function (d) {
      return classChartArc(d) + classFocus(d.data);
    }),
        mainPieEnter = mainPieUpdate.enter().append("g").attr("class", classChartArc);
    mainPieEnter.append("g").attr("class", classArcs).merge(mainPieUpdate), mainPieEnter.append("text").attr("dy", hasGauge && !$$.hasMultiTargets() ? "-.1em" : ".35em").style("opacity", "0").style("text-anchor", "middle").style("pointer-events", "none");
  },
  initArc: function initArc() {
    var $$ = this,
        $el = $$.$el;
    $el.arcs = $el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartArcs).attr("transform", $$.getTranslate("arc")), $$.setArcTitle();
  },

  /**
   * Set arc title text
   * @private
   */
  setArcTitle: function setArcTitle() {
    var $$ = this,
        title = $$.getArcTitle(),
        hasGauge = $$.hasType("gauge");

    if (title) {
      var text = $$.$el.arcs.append("text").attr("class", config_classes[hasGauge ? "chartArcsGaugeTitle" : "chartArcsTitle"]).style("text-anchor", "middle");
      hasGauge && text.attr("dy", "-0.3em").style("font-size", "27px"), setTextValue(text, title, hasGauge ? undefined : [-.6, 1.35], !0);
    }
  },
  redrawArc: function redrawArc(duration, durationForExit, withTransform) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        main = $$.$el.main,
        hasInteraction = config.interaction_enabled,
        mainArc = main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arc).data($$.arcData.bind($$));
    // bind arc events
    mainArc.exit().transition().duration(durationForExit).style("opacity", "0").remove(), mainArc = mainArc.enter().append("path").attr("class", $$.classArc.bind($$)).style("fill", function (d) {
      return $$.color(d.data);
    }).style("cursor", function (d) {
      return hasInteraction && config.data_selection_isselectable(d) ? "pointer" : null;
    }).style("opacity", "0").each(function (d) {
      $$.isGaugeType(d.data) && (d.startAngle = config.gauge_startingAngle, d.endAngle = config.gauge_startingAngle), this._current = d;
    }).merge(mainArc), $$.hasMultiArcGauge() && $$.redrawMultiArcGauge(), mainArc.attr("transform", function (d) {
      return !$$.isGaugeType(d.data) && withTransform ? "scale(0)" : "";
    }).style("opacity", function (d) {
      return d === this._current ? "0" : "1";
    }).each(function () {
      state.transiting = !0;
    }).transition().duration(duration).attrTween("d", function (d) {
      var updated = $$.updateAngle(d);
      if (!updated) return function () {
        return "M 0 0";
      };
      isNaN(this._current.startAngle) && (this._current.startAngle = 0), isNaN(this._current.endAngle) && (this._current.endAngle = this._current.startAngle);
      var interpolate = Object(external_commonjs_d3_interpolate_commonjs2_d3_interpolate_amd_d3_interpolate_root_d3_["interpolate"])(this._current, updated);
      return this._current = interpolate(0), function (t) {
        var interpolated = interpolate(t);
        // data.id will be updated by interporator
        return interpolated.data = d.data, $$.getArc(interpolated, !0);
      };
    }).attr("transform", withTransform ? "scale(1)" : "").style("fill", function (d) {
      var color;
      return $$.levelColor ? (color = $$.levelColor(d.data.values[0].value), config.data_colors[d.data.id] = color) : color = $$.color(d.data.id), color;
    }) // Where gauge reading color would receive customization.
    .style("opacity", "1").call($$.endall, function () {
      if ($$.levelColor) {
        var path = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
            d = path.datum();
        $$.updateLegendItemColor(d.data.id, path.style("fill"));
      }

      state.transiting = !1, callFn(config.onrendered, $$, $$.api);
    }), hasInteraction && $$.bindArcEvent(mainArc), $$.redrawArcText(duration);
  },
  redrawMultiArcGauge: function redrawMultiArcGauge() {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        hiddenTargetIds = $$.state.hiddenTargetIds,
        arcLabelLines = $el.main.selectAll("." + config_classes.arcs).selectAll("." + config_classes.arcLabelLine).data($$.arcData.bind($$)),
        mainArcLabelLine = arcLabelLines.enter().append("rect").attr("class", function (d) {
      return config_classes.arcLabelLine + " " + config_classes.target + " " + config_classes.target + "-" + d.data.id;
    }).merge(arcLabelLines);
    mainArcLabelLine.style("fill", function (d) {
      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);
    }).style("display", config.gauge_label_show ? "" : "none").each(function (d) {
      var lineLength = 0,
          lineThickness = 2,
          x = 0,
          y = 0,
          transform = "";

      if (hiddenTargetIds.indexOf(d.data.id) < 0) {
        var updated = $$.updateAngle(d),
            innerLineLength = state.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),
            lineAngle = updated.endAngle - Math.PI / 2,
            arcInnerRadius = state.radius - innerLineLength,
            linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);
        lineLength = state.radiusExpanded - state.radius + innerLineLength, x = Math.cos(linePositioningAngle) * arcInnerRadius, y = Math.sin(linePositioningAngle) * arcInnerRadius, transform = "rotate(" + lineAngle * 180 / Math.PI + ", " + x + ", " + y + ")";
      }

      Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).attr("x", x).attr("y", y).attr("width", lineLength).attr("height", lineThickness).attr("transform", transform).style("stroke-dasharray", "0, " + (lineLength + lineThickness) + ", 0");
    });
  },
  bindArcEvent: function bindArcEvent(arc) {
    function selectArc(_this, arcData, id) {
      $$.expandArc(id), $$.api.focus(id), $$.toggleFocusLegend(id, !0), $$.showTooltip([arcData], _this);
    }

    function unselectArc(arcData) {
      var id = arcData && arcData.id || undefined;
      $$.unexpandArc(id), $$.api.revert(), $$.revertLegend(), $$.hideTooltip();
    }

    var $$ = this,
        config = $$.config,
        state = $$.state,
        isTouch = state.inputType === "touch",
        isMouse = state.inputType === "mouse";

    // touch events
    if (arc.on("click", function (d, i) {
      var arcData,
          updated = $$.updateAngle(d);
      updated && (arcData = $$.convertToArcData(updated), $$.toggleShape && $$.toggleShape(this, arcData, i), config.data_onclick.call($$.api, arcData, this));
    }), isMouse && arc.on("mouseover", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null,
              id = arcData && arcData.id || undefined;
          selectArc(this, arcData, id), $$.setOverOut(!0, arcData);
        }
    }).on("mouseout", function (d) {
      if (!state.transiting) // skip while transiting
        {
          var updated = $$.updateAngle(d),
              arcData = updated ? $$.convertToArcData(updated) : null;
          unselectArc(), $$.setOverOut(!1, arcData);
        }
    }).on("mousemove", function (d) {
      var updated = $$.updateAngle(d),
          arcData = updated ? $$.convertToArcData(updated) : null;
      $$.showTooltip([arcData], this);
    }), isTouch && $$.hasArcType() && !$$.radars) {
      var getEventArc = function () {
        var touch = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].changedTouches[0],
            eventArc = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.elementFromPoint(touch.clientX, touch.clientY));
        return eventArc;
      },
          handler = function () {
        if (!state.transiting) // skip while transiting
          {
            var eventArc = getEventArc(),
                datum = eventArc.datum(),
                updated = datum && datum.data && datum.data.id ? $$.updateAngle(datum) : null,
                arcData = updated ? $$.convertToArcData(updated) : null,
                id = arcData && arcData.id || undefined;
            $$.callOverOutForTouch(arcData), isUndefined(id) ? unselectArc() : selectArc(this, arcData, id);
          }
      };

      $$.$el.svg.on("touchstart", handler).on("touchmove", handler);
    }
  },
  redrawArcText: function redrawArcText(duration) {
    var text,
        $$ = this,
        config = $$.config,
        state = $$.state,
        _$$$$el = $$.$el,
        main = _$$$$el.main,
        arcs = _$$$$el.arcs,
        hasGauge = $$.hasType("gauge"),
        hasMultiArcGauge = $$.hasMultiArcGauge();

    if (hasGauge && $$.data.targets.length === 1 && config.gauge_title || (text = main.selectAll("." + config_classes.chartArc).select("text").style("opacity", "0").attr("class", function (d) {
      return $$.isGaugeType(d.data) ? config_classes.gaugeValue : null;
    }).call($$.textForArcLabel.bind($$)).attr("transform", $$.transformForArcLabel.bind($$)).style("font-size", function (d) {
      return $$.isGaugeType(d.data) && $$.data.targets.length === 1 && !hasMultiArcGauge ? Math.round(state.radius / 5) + "px" : null;
    }).transition().duration(duration).style("opacity", function (d) {
      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? "1" : "0";
    }), hasMultiArcGauge && text.attr("dy", "-.1em")), main.select("." + config_classes.chartArcsTitle).style("opacity", $$.hasType("donut") || hasGauge ? "1" : "0"), hasGauge) {
      var isFullCircle = config.gauge_fullCircle,
          startAngle = -1 * Math.PI / 2,
          endAngle = (isFullCircle ? -4 : -1) * startAngle;
      isFullCircle && text && text.attr("dy", "" + Math.round(state.radius / 14));
      var backgroundArc = $$.$el.arcs.select((hasMultiArcGauge ? "g" : "") + "." + config_classes.chartArcsBackground);

      if (hasMultiArcGauge) {
        var index = 0;
        backgroundArc = backgroundArc.selectAll("path." + config_classes.chartArcsBackground).data($$.data.targets), backgroundArc.enter().append("path").attr("class", function (d, i) {
          return config_classes.chartArcsBackground + " " + config_classes.chartArcsBackground + "-" + i;
        }).merge(backgroundArc).attr("d", function (d1) {
          if (state.hiddenTargetIds.indexOf(d1.id) >= 0) return "M 0 0";
          var d = {
            data: [{
              value: config.gauge_max
            }],
            startAngle: startAngle,
            endAngle: endAngle,
            index: index++
          };
          return $$.getArc(d, !0, !0);
        }), backgroundArc.exit().remove();
      } else backgroundArc.attr("d", function () {
        var d = {
          data: [{
            value: config.gauge_max
          }],
          startAngle: startAngle,
          endAngle: endAngle
        };
        return $$.getArc(d, !0, !0);
      });

      arcs.select("." + config_classes.chartArcsGaugeUnit).attr("dy", ".75em").text(config.gauge_label_show ? config.gauge_units : ""), config.gauge_label_show && (arcs.select("." + config_classes.chartArcsGaugeMin).attr("dx", -1 * (state.innerRadius + (state.radius - state.innerRadius) / (isFullCircle ? 1 : 2)) + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_min, !1)), !isFullCircle && arcs.select("." + config_classes.chartArcsGaugeMax).attr("dx", state.innerRadius + (state.radius - state.innerRadius) / 2 + "px").attr("dy", "1.2em").text($$.textForGaugeMinMax(config.gauge_max, !0)));
    }
  },
  initGauge: function initGauge() {
    var $$ = this,
        config = $$.config,
        arcs = $$.$el.arcs,
        appendText = function (className) {
      arcs.append("text").attr("class", className).style("text-anchor", "middle").style("pointer-events", "none");
    };

    $$.hasType("gauge") && (arcs.append($$.hasMultiArcGauge() ? "g" : "path").attr("class", config_classes.chartArcsBackground), config.gauge_units && appendText(config_classes.chartArcsGaugeUnit), config.gauge_label_show && (appendText(config_classes.chartArcsGaugeMin), !config.gauge_fullCircle && appendText(config_classes.chartArcsGaugeMax)));
  },
  getGaugeLabelHeight: function getGaugeLabelHeight() {
    return this.config.gauge_label_show ? 20 : 0;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var ChartInternal_shape_bar = ({
  initBar: function initBar() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartBars);
  },
  updateTargetsForBar: function updateTargetsForBar(targets) {
    var $$ = this,
        config = $$.config,
        classChartBar = $$.classChartBar.bind($$),
        classBars = $$.classBars.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainBarUpdate = $$.$el.main.select("." + config_classes.chartBars).selectAll("." + config_classes.chartBar).data(targets).attr("class", function (d) {
      return classChartBar(d) + classFocus(d);
    }),
        mainBarEnter = mainBarUpdate.enter().append("g").attr("class", classChartBar).style("opacity", "0").style("pointer-events", "none");
    // Bars for each data
    mainBarEnter.append("g").attr("class", classBars).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    });
  },
  updateBar: function updateBar(durationForExit) {
    var $$ = this,
        $el = $$.$el,
        barData = $$.barData.bind($$),
        classBar = $$.classBar.bind($$),
        initialOpacity = $$.initialOpacity.bind($$);
    $el.bar = $el.main.selectAll("." + config_classes.bars).selectAll("." + config_classes.bar).data(barData), $el.bar.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.bar = $el.bar.enter().append("path").attr("class", classBar).style("fill", $$.color).merge($el.bar).style("opacity", initialOpacity);
  },
  redrawBar: function redrawBar(drawBar, withTransition) {
    var bar = this.$el.bar;
    return [(withTransition ? bar.transition(getRandom()) : bar).attr("d", drawBar).style("fill", this.color).style("opacity", "1")];
  },
  getBarW: function getBarW(axis, barTargetsNum) {
    var result,
        $$ = this,
        config = $$.config,
        scale = $$.scale,
        maxDataCount = $$.getMaxDataCount(),
        isGrouped = config.data_groups.length,
        tickInterval = (scale.zoom || $$) && !$$.isCategorized() ? $$.xx(scale.subX.domain()[1]) / maxDataCount : axis.tickInterval(maxDataCount),
        getWidth = function (id) {
      var width = id ? config.bar_width[id] : config.bar_width,
          ratio = id ? width.ratio : config.bar_width_ratio,
          max = id ? width.max : config.bar_width_max,
          w = isNumber(width) ? width : barTargetsNum ? tickInterval * ratio / barTargetsNum : 0;
      return max && w > max ? max : w;
    };

    return result = getWidth(), !isGrouped && isObjectType(config.bar_width) && (result = {
      width: result,
      total: []
    }, $$.filterTargetsToShow($$.data.targets).forEach(function (v) {
      config.bar_width[v.id] && (result[v.id] = getWidth(v.id), result.total.push(result[v.id] || result.width));
    })), result;
  },
  getBars: function getBars(i, id) {
    var $$ = this,
        main = $$.$el.main,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? main.selectAll("." + config_classes.bars + $$.getTargetSelectorSuffix(id)) : main).selectAll("." + config_classes.bar + suffix);
  },
  expandBars: function expandBars(i, id, reset) {
    var $$ = this;
    reset && $$.unexpandBars(), $$.getBars(i, id).classed(config_classes.EXPANDED, !0);
  },
  unexpandBars: function unexpandBars(i) {
    this.getBars(i).classed(config_classes.EXPANDED, !1);
  },
  generateDrawBar: function generateDrawBar(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        getPoints = $$.generateGetBarPoints(barIndices, isSub),
        isRotated = config.axis_rotated,
        isGrouped = config.data_groups.length,
        barRadius = config.bar_radius,
        barRadiusRatio = config.bar_radius_ratio,
        getRadius = isNumber(barRadius) && barRadius > 0 ? function () {
      return barRadius;
    } : isNumber(barRadiusRatio) ? function (w) {
      return w * barRadiusRatio;
    } : null;
    return function (d, i) {
      // 4 points that make a bar
      var points = getPoints(d, i),
          indexX = +isRotated,
          indexY = +!indexX,
          isNegative = d.value < 0,
          pathRadius = ["", ""],
          radius = 0; // switch points if axis is rotated, not applicable for sub chart

      if (getRadius && !isGrouped) {
        var index = isRotated ? indexY : indexX,
            barW = points[2][index] - points[0][index];
        radius = getRadius(barW);
        var arc = "a" + radius + "," + radius + " " + (isNegative ? "1 0 0" : "0 0 1") + " ";
        pathRadius[+!isRotated] = "" + arc + radius + "," + radius, pathRadius[+isRotated] = "" + arc + [-radius, radius][isRotated ? "sort" : "reverse"](), isNegative && pathRadius.reverse();
      } // path string data shouldn't be containing new line chars
      // https://github.com/naver/billboard.js/issues/530


      var path = isRotated ? "H" + (points[1][indexX] - radius) + " " + pathRadius[0] + "V" + (points[2][indexY] - radius) + " " + pathRadius[1] + "H" + points[3][indexX] : "V" + (points[1][indexY] + (isNegative ? -radius : radius)) + " " + pathRadius[0] + "H" + (points[2][indexX] - radius) + " " + pathRadius[1] + "V" + points[3][indexY];
      return "M" + points[0][indexX] + "," + points[0][indexY] + path + "z";
    };
  },
  generateGetBarPoints: function generateGetBarPoints(barIndices, isSub) {
    var $$ = this,
        config = $$.config,
        axis = isSub ? $$.axis.subX : $$.axis.x,
        barTargetsNum = $$.getIndicesMax(barIndices) + 1,
        barW = $$.getBarW(axis, barTargetsNum),
        barX = $$.getShapeX(barW, barIndices, !!isSub),
        barY = $$.getShapeY(!!isSub),
        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = barOffset(d, i) || y0,
          width = isNumber(barW) ? barW : barW[d.id] || barW.width,
          posX = barX(d),
          posY = barY(d);
      // 4 points that make a bar
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), posY -= y0 - offset, [[posX, offset], [posX, posY], [posX + width, posY], [posX + width, offset]];
    };
  },
  isWithinBar: function isWithinBar(that) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that),
        list = getRectSegList(that),
        _list = list,
        seg0 = _list[0],
        seg1 = _list[1],
        x = Math.min(seg0.x, seg1.x),
        y = Math.min(seg0.y, seg1.y),
        offset = this.config.bar_sensitivity,
        _that$getBBox = that.getBBox(),
        width = _that$getBBox.width,
        height = _that$getBBox.height;

    return x - offset < mouse[0] && mouse[0] < x + width + offset && y - offset < mouse[1] && mouse[1] < y + height + offset;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/bubble.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var shape_bubble = ({
  /**
   * Initializer
   * @private
   */
  initBubble: function initBubble() {
    var $$ = this,
        config = $$.config;
    $$.hasType("bubble") && (config.point_show = !0, config.point_type = "circle", config.point_sensitivity = 25);
  },

  /**
   * Get user agent's computed value for the total length of the path in user units
   * https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
   * @return {Number}
   * @private
   */
  getBaseLength: function getBaseLength() {
    var $$ = this,
        axis = $$.$el.axis,
        cacheKey = "$baseLength",
        baseLength = $$.cache.get(cacheKey);
    return baseLength || $$.cache.add(cacheKey, baseLength = getMinMax("min", [axis.x.select("path").node().getTotalLength(), axis.y.select("path").node().getTotalLength()])), baseLength;
  },

  /**
   * Get the radius value for bubble circle
   * @param {Object} d
   * @return {Number}
   * @private
  	 */
  getBubbleR: function getBubbleR(d) {
    var $$ = this,
        maxR = $$.config.bubble_maxR;
    isFunction(maxR) ? maxR = maxR(d) : !isNumber(maxR) && (maxR = $$.getBaseLength() / ($$.getMaxDataCount() * 2) + 12);
    var max = getMinMax("max", $$.getMinMaxData().max.map(function (d) {
      return $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : isObject(d.value) ? d.value.mid : d.value;
    })),
        maxArea = maxR * maxR * Math.PI,
        area = ($$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "z") : d.value) * (maxArea / max);
    return Math.sqrt(area / Math.PI);
  },

  /**
   * Get bubble dimension data
   * @param {Object|Array} d data value
   * @param {String} type - y or z
   * @return {Number}
   * @private
   */
  getBubbleZData: function getBubbleZData(d, type) {
    return isObject(d) ? d[type] : d[type === "y" ? 0 : 1];
  },

  /**
   * Determine if bubble has dimension data
   * @param {Object|array} d data value
   * @return {Boolean}
   * @private
   */
  isBubbleZType: function isBubbleZType(d) {
    var $$ = this;
    return $$.isBubbleType(d) && (isObject(d.value) && ("z" in d.value || "y" in d.value) || isArray(d.value) && d.value.length === 2);
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/line.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var ChartInternal_shape_line = ({
  initLine: function initLine() {
    var $$ = this;
    $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartLines);
  },
  updateTargetsForLine: function updateTargetsForLine(targets) {
    var $$ = this,
        config = $$.config,
        main = $$.$el.main,
        classChartLine = $$.classChartLine.bind($$),
        classLines = $$.classLines.bind($$),
        classAreas = $$.classAreas.bind($$),
        classCircles = $$.classCircles.bind($$),
        classFocus = $$.classFocus.bind($$),
        mainLineUpdate = main.select("." + config_classes.chartLines).selectAll("." + config_classes.chartLine).data(targets).attr("class", function (d) {
      return classChartLine(d) + classFocus(d);
    }),
        mainLineEnter = mainLineUpdate.enter().append("g").attr("class", classChartLine).style("opacity", "0").style("pointer-events", "none");
    // Lines for each data
    // Areas
    // Update date for selected circles
    mainLineEnter.append("g").attr("class", classLines), mainLineEnter.append("g").attr("class", classAreas), config.point_show && (config.data_selection_enabled && mainLineEnter.append("g").attr("class", function (d) {
      return $$.generateClass(config_classes.selectedCircles, d.id);
    }), mainLineEnter.append("g").attr("class", classCircles).style("cursor", function (d) {
      return config.data_selection_isselectable(d) ? "pointer" : null;
    })), targets.forEach(function (t) {
      main.selectAll("." + config_classes.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll("" + config_classes.selectedCircle).each(function (d) {
        d.value = t.values[d.index].value;
      });
    });
  },
  updateLine: function updateLine(durationForExit) {
    var $$ = this,
        extraLineClasses = $$.format.extraLineClasses,
        $el = $$.$el;
    $el.line = $el.main.selectAll("." + config_classes.lines).selectAll("." + config_classes.line).data($$.lineData.bind($$)), $el.line.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.line = $el.line.enter().append("path").attr("class", function (d) {
      return $$.classLine.bind($$)(d) + " " + (extraLineClasses(d) || "");
    }).style("stroke", $$.color).merge($el.line).style("opacity", $$.initialOpacity.bind($$)).style("shape-rendering", function (d) {
      return $$.isStepType(d) ? "crispEdges" : "";
    }).attr("transform", null);
  },
  redrawLine: function redrawLine(drawLine, withTransition) {
    var line = this.$el.line;
    return [(withTransition ? line.transition(getRandom()) : line).attr("d", drawLine).style("stroke", this.color).style("opacity", "1")];
  },

  /**
   * Get the curve interpolate
   * @param {Array} d Data object
   * @return {Function}
   * @private
   */
  getCurve: function getCurve(d) {
    var $$ = this,
        isRotatedStepType = $$.config.axis_rotated && $$.isStepType(d);
    // when is step & rotated, should be computed in different way
    // https://github.com/naver/billboard.js/issues/471
    return isRotatedStepType ? function (context) {
      var step = $$.getInterpolate(d)(context); // keep the original method

      return step.orgPoint = step.point, step.pointRotated = function (x, y) {
        this._point === 1 && (this._point = 2);
        var y1 = this._y * (1 - this._t) + y * this._t;
        this._context.lineTo(this._x, y1), this._context.lineTo(x, y1), this._x = x, this._y = y;
      }, step.point = function (x, y) {
        this._point === 0 ? this.orgPoint(x, y) : this.pointRotated(x, y);
      }, step;
    } : $$.getInterpolate(d);
  },
  generateDrawLine: function generateDrawLine(lineIndices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetLinePoints(lineIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        yValue = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getBaseValue(d));
    },
        line = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["line"])();

    line = isRotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue), lineConnectNull || (line = line.defined(function (d) {
      return $$.getBaseValue(d) !== null;
    }));
    var x = isSub ? scale.subX : scale.x;
    return function (d) {
      var path,
          y = yScaleGetter.call($$, d.id),
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isLineType(d)) {
        var regions = config.data_regions[d.id];
        regions ? path = $$.lineWithRegions(values, x, y, regions) : ($$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = line.curve($$.getCurve(d))(values));
      } else values[0] && (x0 = x(values[0].x), y0 = y(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetLinePoints: function generateGetLinePoints(lineIndices, isSubValue) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        isSub = !!isSubValue,
        x = $$.getShapeX(0, lineIndices, isSub),
        y = $$.getShapeY(isSub),
        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = lineOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0);
      // 1 point that marks the line position
      var point = [posX, posY - (y0 - offset)];
      return [point, point, // from here and below, needed for compatibility
      point, point];
    };
  },
  lineWithRegions: function lineWithRegions(d, x, y, _regions) {
    var xp,
        yp,
        diff,
        diffx2,
        $$ = this,
        config = $$.config,
        isRotated = config.axis_rotated,
        isTimeSeries = $$.isTimeSeries(),
        xOffset = $$.isCategorized() ? .5 : 0,
        regions = [],
        dasharray = "2 2",
        isWithinRegions = function (withinX, withinRegions) {
      for (var reg, i = 0; reg = withinRegions[i]; i++) if (reg.start < withinX && withinX <= reg.end) return reg.style;

      return !1;
    };

    // Check start/end of regions
    if (isDefined(_regions)) {
      var getValue = function (v, def) {
        return isUndefined(v) ? def : isTimeSeries ? $$.parseDate(v) : v;
      };

      for (var reg, i = 0; reg = _regions[i]; i++) {
        var start = getValue(reg.start, d[0].x),
            end = getValue(reg.end, d[d.length - 1].x),
            style = reg.style || {
          dasharray: dasharray
        };
        regions[i] = {
          start: start,
          end: end,
          style: style
        };
      }
    } // Set scales


    var xValue = isRotated ? function (dt) {
      return y(dt.value);
    } : function (dt) {
      return x(dt.x);
    },
        yValue = isRotated ? function (dt) {
      return x(dt.x);
    } : function (dt) {
      return y(dt.value);
    },
        generateM = function (points) {
      return "M" + points[0][0] + "," + points[0][1] + "L" + points[1][0] + "," + points[1][1];
    },
        sWithRegion = isTimeSeries ? function (d0, d1, k, timeseriesDiff) {
      var x0 = d0.x.getTime(),
          xDiff = d1.x - d0.x,
          xv0 = new Date(x0 + xDiff * k),
          xv1 = new Date(x0 + xDiff * (k + timeseriesDiff)),
          points = isRotated ? [[y(yp(k)), x(xv0)], [y(yp(k + diff)), x(xv1)]] : [[x(xv0), y(yp(k))], [x(xv1), y(yp(k + diff))]];
      return generateM(points);
    } : function (d0, d1, k, otherDiff) {
      var points = isRotated ? [[y(yp(k), !0), x(xp(k))], [y(yp(k + otherDiff), !0), x(xp(k + otherDiff))]] : [[x(xp(k), !0), y(yp(k))], [x(xp(k + otherDiff), !0), y(yp(k + otherDiff))]];
      return generateM(points);
    },
        path = "";

    for (var data, _i = 0; data = d[_i]; _i++) {
      var prevData = d[_i - 1],
          hasPrevData = prevData && isValue(prevData.value),
          style = isWithinRegions(data.x, regions);
      // https://github.com/naver/billboard.js/issues/1172
      if (isValue(data.value)) // Draw as normal
        if (isUndefined(regions) || !style || !hasPrevData) path += "" + (_i && hasPrevData ? "L" : "M") + xValue(data) + "," + yValue(data);else if (hasPrevData) {
          try {
            style = style.dasharray.split(" ");
          } catch (e) {
            style = dasharray.split(" ");
          } // Draw with region // TODO: Fix for horizotal charts


          xp = $$.getScale(prevData.x + xOffset, data.x + xOffset, isTimeSeries), yp = $$.getScale(prevData.value, data.value);
          var dx = x(data.x) - x(prevData.x),
              dy = y(data.value) - y(prevData.value),
              dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
          diff = style[0] / dd, diffx2 = diff * style[1];

          for (var _j = diff; _j <= 1; _j += diffx2) path += sWithRegion(prevData, data, _j, diff), _j + diffx2 >= 1 && (path += sWithRegion(prevData, data, 1, 0));
        }
    }

    return path;
  },
  updateAreaGradient: function updateAreaGradient() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        defs = $$.$el.defs;
    $$.data.targets.forEach(function (d) {
      var id = datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id);

      if ($$.isAreaType(d) && defs.select("#" + id).empty()) {
        var color = $$.color(d),
            _config$area_linearGr = config.area_linearGradient,
            _config$area_linearGr2 = _config$area_linearGr.x,
            x = _config$area_linearGr2 === void 0 ? [0, 0] : _config$area_linearGr2,
            _config$area_linearGr3 = _config$area_linearGr.y,
            y = _config$area_linearGr3 === void 0 ? [0, 1] : _config$area_linearGr3,
            _config$area_linearGr4 = _config$area_linearGr.stops,
            stops = _config$area_linearGr4 === void 0 ? [[0, color, 1], [1, color, 0]] : _config$area_linearGr4,
            linearGradient = defs.append("linearGradient").attr("id", "" + id).attr("x1", x[0]).attr("x2", x[1]).attr("y1", y[0]).attr("y2", y[1]);
        stops.forEach(function (v) {
          var stopColor = isFunction(v[1]) ? v[1](d.id) : v[1];
          linearGradient.append("stop").attr("offset", v[0]).attr("stop-color", stopColor || color).attr("stop-opacity", v[2]);
        });
      }
    });
  },
  updateAreaColor: function updateAreaColor(d) {
    var $$ = this;
    return $$.config.area_linearGradient ? "url(#" + $$.state.datetimeId + "-areaGradient" + $$.getTargetSelectorSuffix(d.id) + ")" : $$.color(d);
  },
  updateArea: function updateArea(durationForExit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el;
    config.area_linearGradient && $$.updateAreaGradient(), $el.area = $el.main.selectAll("." + config_classes.areas).selectAll("." + config_classes.area).data($$.lineData.bind($$)), $el.area.exit().transition().duration(durationForExit).style("opacity", "0").remove(), $el.area = $el.area.enter().append("path").attr("class", $$.classArea.bind($$)).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function () {
      return state.orgAreaOpacity = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).style("opacity"), "0";
    }).merge($el.area), $el.area.style("opacity", state.orgAreaOpacity);
  },
  redrawArea: function redrawArea(drawArea, withTransition) {
    var $$ = this,
        orgAreaOpacity = $$.state.orgAreaOpacity;
    return [(withTransition ? $$.$el.area.transition(getRandom()) : $$.$el.area).attr("d", drawArea).style("fill", $$.updateAreaColor.bind($$)).style("opacity", function (d) {
      return ($$.isAreaRangeType(d) ? orgAreaOpacity / 1.75 : orgAreaOpacity) + "";
    })];
  },

  /**
   * Generate area path data
   * @param areaIndices
   * @param isSub
   * @return {function(*=): (*|string)}
   * @private
   */
  generateDrawArea: function generateDrawArea(areaIndices, isSub) {
    var $$ = this,
        config = $$.config,
        lineConnectNull = config.line_connectNull,
        isRotated = config.axis_rotated,
        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),
        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,
        xValue = function (d) {
      return (isSub ? $$.subxx : $$.xx).call($$, d);
    },
        value0 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "high") : 0);
    },
        value1 = function (d, i) {
      return $$.isGrouped(d.id) ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)($$.isAreaRangeType(d) ? $$.getAreaRangeData(d, "low") : d.value);
    };

    return function (d) {
      var path,
          values = lineConnectNull ? $$.filterRemoveNull(d.values) : d.values,
          x0 = 0,
          y0 = 0;

      if ($$.isAreaType(d)) {
        var area = Object(external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["area"])();
        area = isRotated ? area.y(xValue).x0(value0).x1(value1) : area.x(xValue) // @ts-ignore
        .y0(config.area_above ? 0 : value0).y1(value1), lineConnectNull || (area = area.defined(function (d) {
          return $$.getBaseValue(d) !== null;
        })), $$.isStepType(d) && (values = $$.convertValuesToStep(values)), path = area.curve($$.getCurve(d))(values);
      } else values[0] && (x0 = $$.scale.x(values[0].x), y0 = $$.getYScale(d.id)(values[0].value)), path = isRotated ? "M " + y0 + " " + x0 : "M " + x0 + " " + y0;

      return path || "M 0 0";
    };
  },
  generateGetAreaPoints: function generateGetAreaPoints(areaIndices, isSub) {
    // partial duplication of generateGetBarPoints
    var $$ = this,
        config = $$.config,
        x = $$.getShapeX(0, areaIndices, !!isSub),
        y = $$.getShapeY(!!isSub),
        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),
        yScale = isSub ? $$.getSubYScale : $$.getYScale;
    return function (d, i) {
      var y0 = yScale.call($$, d.id)(0),
          offset = areaOffset(d, i) || y0,
          posX = x(d),
          posY = y(d);
      // 1 point that marks the area position
      return config.axis_rotated && (d.value > 0 && posY < y0 || d.value < 0 && y0 < posY) && (posY = y0), [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility
      [posX, offset] // needed for compatibility
      ];
    };
  },
  updateCircle: function updateCircle() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;

    if (config.point_show) {
      $el.circle = $el.main.selectAll("." + config_classes.circles).selectAll("." + config_classes.circle).data(function (d) {
        return !$$.isBarType(d) && (!$$.isLineType(d) || $$.shouldDrawPointsForLine(d)) && $$.labelishData(d);
      }), $el.circle.exit().remove();
      var fn = $$.point("create", this, $$.pointR.bind($$), $$.color);
      $el.circle = $el.circle.enter().append(fn).merge($el.circle).style("stroke", $$.color).style("opacity", $$.initialOpacityForCircle.bind($$));
    }
  },
  redrawCircle: function redrawCircle(cx, cy, withTransition, flow) {
    var $$ = this,
        selectedCircles = $$.$el.main.selectAll("." + config_classes.selectedCircle);
    if (!$$.config.point_show) return [];
    var mainCircles = [];
    $$.$el.circle.each(function (d) {
      var fn = $$.point("update", $$, cx, cy, $$.opacityForCircle.bind($$), $$.color, withTransition, flow, selectedCircles).bind(this),
          result = fn(d);
      mainCircles.push(result);
    });
    var posAttr = $$.isCirclePoint() ? "c" : "";
    return [mainCircles, selectedCircles.attr(posAttr + "x", cx).attr(posAttr + "y", cy)];
  },
  circleX: function circleX(d) {
    var $$ = this,
        _$$$scale = $$.scale,
        x = _$$$scale.x,
        zoom = _$$$scale.zoom,
        hasValue = isValue(d.x);
    return $$.config.zoom_enabled && zoom ? hasValue ? zoom(d.x) : null : hasValue ? x(d.x) : null;
  },
  updateCircleY: function updateCircleY() {
    var $$ = this,
        getPoints = $$.generateGetLinePoints($$.getShapeIndices($$.isLineType), !1);

    $$.circleY = function (d, i) {
      var id = d.id;
      return $$.isGrouped(id) ? getPoints(d, i)[0][1] : $$.getYScale(id)($$.getBaseValue(d));
    };
  },
  getCircles: function getCircles(i, id) {
    var $$ = this,
        suffix = isValue(i) ? "-" + i : "";
    return (id ? $$.$el.main.selectAll("." + config_classes.circles + $$.getTargetSelectorSuffix(id)) : $$.$el.main).selectAll("." + config_classes.circle + suffix);
  },
  expandCircles: function expandCircles(i, id, reset) {
    var $$ = this,
        r = $$.pointExpandedR.bind($$);
    reset && $$.unexpandCircles();
    var circles = $$.getCircles(i, id).classed(config_classes.EXPANDED, !0),
        scale = r(circles) / $$.config.point_r,
        ratio = 1 - scale;
    $$.isCirclePoint() ? circles.attr("r", r) : circles.each(function () {
      var point = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      if (this.tagName === "circle") point.attr("r", r);else {
        var _this$getBBox = this.getBBox(),
            width = _this$getBBox.width,
            height = _this$getBBox.height,
            x = ratio * (+point.attr("x") + width / 2),
            y = ratio * (+point.attr("y") + height / 2);

        point.attr("transform", "translate(" + x + " " + y + ") scale(" + scale + ")");
      }
    });
  },
  unexpandCircles: function unexpandCircles(i) {
    var $$ = this,
        r = $$.pointR.bind($$),
        circles = $$.getCircles(i).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.EXPANDED);
    }).classed(config_classes.EXPANDED, !1);
    circles.attr("r", r), $$.isCirclePoint() || circles.attr("transform", "scale(" + r(circles) / $$.config.point_r + ")");
  },
  pointR: function (d) {
    var $$ = this,
        config = $$.config,
        pointR = config.point_r,
        r = pointR;
    return $$.isStepType(d) ? r = 0 : $$.isBubbleType(d) ? r = $$.getBubbleR(d) : isFunction(pointR) && (r = pointR(d)), r;
  },
  pointExpandedR: function pointExpandedR(d) {
    var $$ = this,
        config = $$.config,
        scale = $$.isBubbleType(d) ? 1.15 : 1.75;
    return config.point_focus_expand_enabled ? config.point_focus_expand_r || $$.pointR(d) * scale : $$.pointR(d);
  },
  pointSelectR: function pointSelectR(d) {
    var $$ = this,
        selectR = $$.config.point_select_r;
    return isFunction(selectR) ? selectR(d) : selectR || $$.pointR(d) * 4;
  },
  isWithinCircle: function isWithinCircle(node, r) {
    var mouse = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(node),
        element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(node),
        prefix = this.isCirclePoint() ? "c" : "",
        cx = +element.attr(prefix + "x"),
        cy = +element.attr(prefix + "y");

    // if node don't have cx/y or x/y attribute value
    if (!(cx || cy) && node.nodeType === 1) {
      var _ref = node.getBBox ? node.getBBox() : node.getBoundingClientRect(),
          x = _ref.x,
          y = _ref.y;

      cx = x, cy = y;
    }

    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < (r || this.config.point_sensitivity);
  },
  isWithinStep: function isWithinStep(that, y) {
    return Math.abs(y - Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["mouse"])(that)[1]) < 30;
  },
  shouldDrawPointsForLine: function shouldDrawPointsForLine(d) {
    var linePoint = this.config.line_point;
    return linePoint === !0 || isArray(linePoint) && linePoint.indexOf(d.id) !== -1;
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/point.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var shape_point = ({
  hasValidPointType: function hasValidPointType(type) {
    return /^(circle|rect(angle)?|polygon|ellipse|use)$/i.test(type || this.config.point_type);
  },
  hasValidPointDrawMethods: function hasValidPointDrawMethods(type) {
    var pointType = type || this.config.point_type;
    return isObjectType(pointType) && isFunction(pointType.create) && isFunction(pointType.update);
  },
  insertPointInfoDefs: function insertPointInfoDefs(point, id) {
    var $$ = this,
        copyAttr = function (from, target) {
      for (var name, attribs = from.attributes, i = 0; name = attribs[i]; i++) name = name.name, target.setAttribute(name, from.getAttribute(name));
    },
        doc = new DOMParser().parseFromString(point, "image/svg+xml"),
        node = doc.documentElement,
        clone = browser_doc.createElementNS(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg, node.nodeName.toLowerCase());

    if (clone.id = id, clone.style.fill = "inherit", clone.style.stroke = "inherit", copyAttr(node, clone), node.childNodes && node.childNodes.length) {
      var parent = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(clone);
      "innerHTML" in clone ? parent.html(node.innerHTML) : toArray(node.childNodes).forEach(function (v) {
        copyAttr(v, parent.append(v.tagName).node());
      });
    }

    $$.$el.defs.node().appendChild(clone);
  },
  pointFromDefs: function pointFromDefs(id) {
    return this.$el.defs.select("#" + id);
  },
  updatePointClass: function updatePointClass(d) {
    var $$ = this,
        circle = $$.$el.circle,
        pointClass = !1;
    return (isObject(d) || circle) && (pointClass = d === !0 ? circle.attr("class", $$.classCircle.bind($$)) : $$.classCircle(d)), pointClass;
  },
  generatePoint: function generatePoint() {
    var $$ = this,
        config = $$.config,
        datetimeId = $$.state.datetimeId,
        ids = [],
        pattern = notEmpty(config.point_pattern) ? config.point_pattern : [config.point_type];
    return function (method, context) {
      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];

      return function (d) {
        var id = d.id || d.data && d.data.id || d,
            element = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
        ids.indexOf(id) < 0 && ids.push(id);
        var point = pattern[ids.indexOf(id) % pattern.length];
        if ($$.hasValidPointType(point)) point = $$[point];else if (!$$.hasValidPointDrawMethods(point)) {
          var pointId = datetimeId + "-point-" + id,
              pointFromDefs = $$.pointFromDefs(pointId);
          if (pointFromDefs.size() < 1 && $$.insertPointInfoDefs(point, pointId), method === "create") return $$.custom.create.bind(context).apply(void 0, [element, pointId].concat(args));
          if (method === "update") return $$.custom.update.bind(context).apply(void 0, [element].concat(args));
        }
        return point[method].bind(context).apply(void 0, [element].concat(args));
      };
    };
  },
  getTransitionName: function getTransitionName() {
    return getRandom();
  },
  custom: {
    create: function create(element, id, sizeFn, fillStyleFn) {
      return element.append("use").attr("xlink:href", "#" + id).attr("class", this.updatePointClass.bind(this)).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          _element$node$getBBox = element.node().getBBox(),
          width = _element$node$getBBox.width,
          height = _element$node$getBBox.height,
          xPosFn2 = function (d) {
        return xPosFn(d) - width / 2;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", xPosFn2), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", xPosFn2).attr("y", function yPosFn2(d) {
        return yPosFn(d) - height / 2;
      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'circle' data point
  circle: {
    create: function create(element, sizeFn, fillStyleFn) {
      return element.append("circle").attr("class", this.updatePointClass.bind(this)).attr("r", sizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          mainCircles = element;

      if ($$.hasType("bubble") && mainCircles.attr("r", $$.pointR.bind($$)), withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("cx", xPosFn), mainCircles.attr("cx") && (mainCircles = mainCircles.transition(transitionName)), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("cx", xPosFn).attr("cy", yPosFn).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  },
  // 'rectangle' data point
  rectangle: {
    create: function create(element, sizeFn, fillStyleFn) {
      var rectSizeFn = function (d) {
        return sizeFn(d) * 2;
      };

      return element.append("rect").attr("class", this.updatePointClass.bind(this)).attr("width", rectSizeFn).attr("height", rectSizeFn).style("fill", fillStyleFn).node();
    },
    update: function update(element, xPosFn, yPosFn, opacityStyleFn, fillStyleFn, withTransition, flow, selectedCircles) {
      var $$ = this,
          r = $$.config.point_r,
          rectXPosFn = function (d) {
        return xPosFn(d) - r;
      },
          mainCircles = element;

      if (withTransition) {
        var transitionName = $$.getTransitionName();
        flow && mainCircles.attr("x", rectXPosFn), mainCircles = mainCircles.transition(transitionName), selectedCircles.transition($$.getTransitionName());
      }

      return mainCircles.attr("x", rectXPosFn).attr("y", function rectYPosFn(d) {
        return yPosFn(d) - r;
      }).style("opacity", opacityStyleFn).style("fill", fillStyleFn);
    }
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/radar.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Get the position value
 * @param {Boolean} isClockwise If the direction is clockwise
 * @param {String} type Coordinate type 'x' or 'y'
 * @param {Number} edge Number of edge
 * @param {Number} pos The indexed position
 * @param {Number} range
 * @param {Number} ratio
 * @return {number}
 * @private
 */

function getPosition(isClockwise, type, edge, pos, range, ratio) {
  var index = isClockwise && pos > 0 ? edge - pos : pos,
      r = 2 * Math.PI,
      func = type === "x" ? Math.sin : Math.cos;
  return range * (1 - ratio * func(index * r / edge));
} // cache key


var radar_cacheKey = "$radarPoints";
/* harmony default export */ var shape_radar = ({
  initRadar: function initRadar() {
    var $$ = this,
        config = $$.config;
    $$.hasType("radar") && ($$.radars = $$.$el.main.select("." + config_classes.chart).append("g").attr("class", config_classes.chartRadars), $$.radars.levels = $$.radars.append("g").attr("class", config_classes.levels), $$.radars.axes = $$.radars.append("g").attr("class", config_classes.axis), $$.radars.shapes = $$.radars.append("g").attr("class", config_classes.shapes), $$.maxValue = config.radar_axis_max || $$.getMinMaxData().max[0].value);
  },
  getRadarSize: function getRadarSize() {
    var $$ = this,
        config = $$.config,
        _$$$state = $$.state,
        arcWidth = _$$$state.arcWidth,
        arcHeight = _$$$state.arcHeight,
        padding = config.axis_x_categories.length < 4 ? -20 : 10,
        size = (Math.min(arcWidth, arcHeight) - padding) / 2;
    return [size, size];
  },
  updateTargetsForRadar: function updateTargetsForRadar(targets) {
    var $$ = this,
        config = $$.config;
    isEmpty(config.axis_x_categories) && (config.axis_x_categories = getRange(0, getMinMax("max", targets.map(function (v) {
      return v.values.length;
    })))), $$.generateRadarPoints();
  },
  getRadarPosition: function getRadarPosition(type, index, range, ratio) {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize = $$.getRadarSize(),
        width = _$$$getRadarSize[0],
        height = _$$$getRadarSize[1],
        edge = config.axis_x_categories.length,
        isClockwise = config.radar_direction_clockwise,
        pos = toArray(type).map(function (v) {
      return getPosition(isClockwise, v, edge, index, isDefined(range) ? range : type === "x" ? width : height, isNumber(ratio) ? ratio : config.radar_size_ratio);
    });

    return pos.length === 1 ? pos[0] : pos;
  },

  /**
   * Generate data points
   * @private
   */
  generateRadarPoints: function generateRadarPoints() {
    var $$ = this,
        targets = $$.data.targets,
        _$$$getRadarSize2 = $$.getRadarSize(),
        width = _$$$getRadarSize2[0],
        height = _$$$getRadarSize2[1],
        points = $$.cache.get(radar_cacheKey) || {},
        size = points._size;

    size && (size.width === width || size.height === height) || (targets.forEach(function (d) {
      points[d.id] = d.values.map(function (v, i) {
        return $$.getRadarPosition(["x", "y"], i, undefined, $$.getRatio("radar", v));
      });
    }), points._size = {
      width: width,
      height: height
    }, $$.cache.add(radar_cacheKey, points));
  },
  redrawRadar: function redrawRadar(duration, durationForExit) {
    var $$ = this,
        main = $$.$el.main,
        translate = $$.getTranslate("radar");
    translate && ($$.radars.attr("transform", translate), main.selectAll("." + config_classes.circles).attr("transform", translate), main.select("." + config_classes.chartTexts).attr("transform", translate), $$.generateRadarPoints(), $$.updateRadarLevel(), $$.updateRadarAxes(), $$.updateRadarShape(duration, durationForExit));
  },
  generateGetRadarPoints: function generateGetRadarPoints() {
    var points = this.cache.get(radar_cacheKey);
    return function (d, i) {
      var point = points[d.id][i];
      return [point, point, point, point];
    };
  },
  updateRadarLevel: function updateRadarLevel() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize3 = $$.getRadarSize(),
        width = _$$$getRadarSize3[0],
        height = _$$$getRadarSize3[1],
        depth = config.radar_level_depth,
        edge = config.axis_x_categories.length,
        showText = config.radar_level_text_show,
        radarLevels = $$.radars.levels,
        levelData = getRange(0, depth),
        radius = config.radar_size_ratio * Math.min(width, height),
        levelRatio = levelData.map(function (l) {
      return radius * ((l + 1) / depth);
    }),
        levelTextFormat = config.radar_level_text_format,
        points = levelData.map(function (v) {
      var range = levelRatio[v],
          pos = getRange(0, edge).map(function (i) {
        return $$.getRadarPosition(["x", "y"], i, range, 1).join(",");
      });
      return pos.join(" ");
    }),
        level = radarLevels.selectAll("." + config_classes.level).data(levelData);

    level.exit().remove();
    var levelEnter = level.enter().append("g").attr("class", function (d, i) {
      return config_classes.level + " " + config_classes.level + "-" + i;
    });
    levelEnter.append("polygon").style("visibility", config.radar_level_show ? null : "hidden"), showText && (radarLevels.select("text").empty() && radarLevels.append("text").attr("dx", "-.5em").attr("dy", "-.7em").style("text-anchor", "end").text(function () {
      return levelTextFormat(0);
    }), levelEnter.append("text").attr("dx", "-.5em").style("text-anchor", "end").text(function (d) {
      return levelTextFormat($$.maxValue / levelData.length * (d + 1));
    })), levelEnter.merge(level).attr("transform", function (d) {
      return "translate(" + (width - levelRatio[d]) + ", " + (height - levelRatio[d]) + ")";
    }).selectAll("polygon").attr("points", function (d) {
      return points[d];
    }), showText && radarLevels.selectAll("text").attr("x", function (d) {
      return isUndefined(d) ? width : points[d].split(",")[0];
    }).attr("y", function (d) {
      return isUndefined(d) ? height : 0;
    });
  },
  updateRadarAxes: function updateRadarAxes() {
    var $$ = this,
        config = $$.config,
        _$$$getRadarSize4 = $$.getRadarSize(),
        width = _$$$getRadarSize4[0],
        height = _$$$getRadarSize4[1],
        categories = config.axis_x_categories,
        axis = $$.radars.axes.selectAll("g").data(categories);

    axis.exit().remove();
    var axisEnter = axis.enter().append("g").attr("class", function (d, i) {
      return config_classes.axis + "-" + i;
    });

    // axis text
    if (config.radar_axis_line_show && axisEnter.append("line"), config.radar_axis_text_show && axisEnter.append("text"), axis = axisEnter.merge(axis), config.radar_axis_line_show && axis.select("line").attr("x1", width).attr("y1", height).attr("x2", function (d, i) {
      return $$.getRadarPosition("x", i);
    }).attr("y2", function (d, i) {
      return $$.getRadarPosition("y", i);
    }), config.radar_axis_text_show) {
      var _config$radar_axis_te = config.radar_axis_text_position,
          _config$radar_axis_te2 = _config$radar_axis_te.x,
          x = _config$radar_axis_te2 === void 0 ? 0 : _config$radar_axis_te2,
          _config$radar_axis_te3 = _config$radar_axis_te.y,
          y = _config$radar_axis_te3 === void 0 ? 0 : _config$radar_axis_te3;
      axis.select("text").style("text-anchor", "middle").attr("dy", ".5em").call(function (selection) {
        selection.each(function (d) {
          setTextValue(Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this), d + "", [-.6, 1.2]);
        });
      }).datum(function (d, i) {
        return {
          index: i
        };
      }).attr("transform", function (d) {
        isUndefined(this.width) && (this.width = this.getBoundingClientRect().width / 2);
        var posX = $$.getRadarPosition("x", d.index, undefined, 1),
            posY = Math.round($$.getRadarPosition("y", d.index, undefined, 1));
        return posX > width ? posX += this.width + x : Math.round(posX) < width && (posX -= this.width + x), posY > height ? (posY / 2 === height && this.firstChild.tagName === "tspan" && this.firstChild.setAttribute("dy", "0em"), posY += y) : posY < height && (posY -= y), "translate(" + posX + " " + posY + ")";
      });
    }

    $$.bindEvent();
  },
  bindEvent: function bindEvent() {
    var _this = this,
        $$ = this,
        config = $$.config,
        _$$$state2 = $$.state,
        inputType = _$$$state2.inputType,
        transiting = _$$$state2.transiting,
        svg = $$.$el.svg;

    if (config.interaction_enabled) {
      var isMouse = inputType === "mouse",
          getIndex = function () {
        var target = external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["event"].target; // in case of multilined axis text

        /tspan/i.test(target.tagName) && (target = target.parentNode);
        var d = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(target).datum();
        return d && Object.keys(d).length === 1 ? d.index : undefined;
      },
          hide = function () {
        var index = getIndex(),
            noIndex = isUndefined(index);
        (isMouse || noIndex) && (_this.hideTooltip(), _this.unexpandCircles(), isMouse ? $$.setOverOut(!1, index) : noIndex && $$.callOverOutForTouch());
      };

      $$.radars.select("." + config_classes.axis).on(isMouse ? "mouseover " : "touchstart", function () {
        if (!transiting) // skip while transiting
          {
            var index = getIndex();
            $$.selectRectForSingle(svg.node(), null, index), isMouse ? $$.setOverOut(!0, index) : $$.callOverOutForTouch(index);
          }
      }).on("mouseout", isMouse ? hide : null), isMouse || svg.on("touchstart", hide);
    }
  },
  updateRadarShape: function updateRadarShape(duration, durationForExit) {
    var $$ = this,
        targets = $$.data.targets,
        points = $$.cache.get(radar_cacheKey),
        areas = $$.radars.shapes.selectAll("polygon").data(targets),
        areasEnter = areas.enter().append("g").attr("class", $$.classChartRadar.bind($$));
    areas.exit().transition().duration(durationForExit).remove(), areasEnter.append("polygon").merge(areas).style("fill", function (d) {
      return $$.color(d);
    }).style("stroke", function (d) {
      return $$.color(d);
    }).attr("points", function (d) {
      return points[d.id].join(" ");
    });
  },

  /**
   * Get data point x coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleX: function radarCircleX(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][0];
  },

  /**
   * Get data point y coordinate
   * @param {Object} d Data object
   * @return {Number}
   * @private
   */
  radarCircleY: function radarCircleY(d) {
    return this.cache.get(radar_cacheKey)[d.id][d.index][1];
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/shape/shape.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */




/* harmony default export */ var shape_shape = ({
  getShapeIndices: function getShapeIndices(typeFilter) {
    var $$ = this,
        config = $$.config,
        xs = config.data_xs,
        hasXs = notEmpty(xs),
        indices = {},
        i = hasXs ? {} : 0;
    return hasXs && getUnique(Object.keys(xs).map(function (v) {
      return xs[v];
    })).forEach(function (v) {
      i[v] = 0, indices[v] = {};
    }), $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {
      for (var groups, xKey = (d.id in xs) ? xs[d.id] : "", ind = xKey ? indices[xKey] : indices, j = 0; groups = config.data_groups[j]; j++) if (!(groups.indexOf(d.id) < 0)) for (var _row4, _k4 = 0; _row4 = groups[_k4]; _k4++) if (_row4 in ind) {
        ind[d.id] = ind[_row4];
        break;
      }

      isUndefined(ind[d.id]) && (ind[d.id] = xKey ? i[xKey]++ : i++, ind.__max__ = (xKey ? i[xKey] : i) - 1);
    }), indices;
  },

  /**
   * Get indices value based on data ID value
   * @param {Object} indices Indices object
   * @param {String} id Data id value
   * @return {Object} Indices object
   * @private
   */
  getIndices: function getIndices(indices, id) {
    var xs = this.config.data_xs;
    return notEmpty(xs) ? indices[xs[id]] : indices;
  },

  /**
   * Get indices max number
   * @param {Object} indices Indices object
   * @return {Number} Max number
   * @private
   */
  getIndicesMax: function getIndicesMax(indices) {
    return notEmpty(this.config.data_xs) ? // if is multiple xs, return total sum of xs' __max__ value
    Object.keys(indices).map(function (v) {
      return indices[v].__max__ || 0;
    }).reduce(function (acc, curr) {
      return acc + curr;
    }) : indices.__max__;
  },
  getShapeX: function getShapeX(offset, indices, isSub) {
    var $$ = this,
        config = $$.config,
        scale = $$.scale,
        currScale = isSub ? scale.subX : scale.zoom || scale.x,
        barPadding = config.bar_padding,
        sum = function (p, c) {
      return p + c;
    },
        halfWidth = isObjectType(offset) && offset.total.length ? offset.total.reduce(sum) / 2 : 0;

    return function (d) {
      var ind = $$.getIndices(indices, d.id),
          index = d.id in ind ? ind[d.id] : 0,
          targetsNum = (ind.__max__ || 0) + 1,
          x = 0;

      if (notEmpty(d.x)) {
        var xPos = currScale(d.x);
        x = halfWidth ? xPos - (offset[d.id] || offset.width) + offset.total.slice(0, index + 1).reduce(sum) - halfWidth : xPos - (isNumber(offset) ? offset : offset.width) * (targetsNum / 2 - index);
      } // adjust x position for bar.padding optionq


      return offset && x && targetsNum > 1 && barPadding && (index && (x += barPadding * index), targetsNum > 2 ? x -= (targetsNum - 1) * barPadding / 2 : targetsNum === 2 && (x -= barPadding / 2)), x;
    };
  },
  getShapeY: function getShapeY(isSub) {
    var $$ = this,
        isStackNormalized = $$.isStackNormalized();
    return function (d) {
      var value = isStackNormalized ? $$.getRatio("index", d, !0) : $$.isBubbleZType(d) ? $$.getBubbleZData(d.value, "y") : d.value;
      return (isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id))(value);
    };
  },

  /**
   * Get Shape's offset data
   * @param {function(Object): boolean} typeFilter
   * @return {{shapeOffsetTargets: ShapeOffsetTarget[], indexMapByTargetId: object}}
   * @private
   */
  getShapeOffsetData: function getShapeOffsetData(typeFilter) {
    var $$ = this,
        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),
        shapeOffsetTargets = targets.map(function (target) {
      var rowValues = target.values;
      $$.isStepType(target) && (rowValues = $$.convertValuesToStep(rowValues));
      var values,
          rowValueMapByXValue = rowValues.reduce(function (out, value) {
        return out[+value.x] = value, out;
      }, {});
      return values = $$.isStackNormalized() ? rowValues.map(function (v) {
        return $$.getRatio("index", v, !0);
      }) : rowValues.map(function (_ref) {
        var value = _ref.value;
        return value;
      }), {
        id: target.id,
        rowValues: rowValues,
        rowValueMapByXValue: rowValueMapByXValue,
        values: values
      };
    }),
        indexMapByTargetId = targets.reduce(function (out, _ref2, index) {
      var id = _ref2.id;
      return out[id] = index, out;
    }, {});
    return {
      indexMapByTargetId: indexMapByTargetId,
      shapeOffsetTargets: shapeOffsetTargets
    };
  },
  getShapeOffset: function getShapeOffset(typeFilter, indices, isSub) {
    var $$ = this,
        _$$$getShapeOffsetDat = $$.getShapeOffsetData(typeFilter),
        shapeOffsetTargets = _$$$getShapeOffsetDat.shapeOffsetTargets,
        indexMapByTargetId = _$$$getShapeOffsetDat.indexMapByTargetId;

    return function (d, idx) {
      var ind = $$.getIndices(indices, d.id),
          scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),
          y0 = scale(0),
          dataXAsNumber = +d.x,
          offset = y0;
      return shapeOffsetTargets.forEach(function (t) {
        var rowValues = t.rowValues,
            values = t.values;

        if (t.id !== d.id && ind[t.id] === ind[d.id] && indexMapByTargetId[t.id] < indexMapByTargetId[d.id]) {
          var _rowValue = rowValues[idx]; // check if the x values line up

          _rowValue && +_rowValue.x === dataXAsNumber || (_rowValue = t.rowValueMapByXValue[dataXAsNumber]), _rowValue && _rowValue.value * d.value >= 0 && (offset += scale(values[_rowValue.index]) - y0);
        }
      }), offset;
    };
  },
  isWithinShape: function isWithinShape(that, d) {
    var isWithin,
        $$ = this,
        shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(that);
    return $$.isTargetToShow(d.id) ? $$.hasValidPointType(that.nodeName) ? isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.isBubbleType(d) ? $$.pointSelectR(d) * 1.5 : 0) : that.nodeName === "path" && (isWithin = !shape.classed(config_classes.bar) || $$.isWithinBar(that)) : isWithin = !1, isWithin;
  },
  getInterpolate: function getInterpolate(d) {
    var $$ = this,
        interpolation = $$.getInterpolateType(d);
    return {
      "basis": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasis"],
      "basis-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisClosed"],
      "basis-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBasisOpen"],
      "bundle": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveBundle"],
      "cardinal": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinal"],
      "cardinal-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalClosed"],
      "cardinal-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCardinalOpen"],
      "catmull-rom": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRom"],
      "catmull-rom-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomClosed"],
      "catmull-rom-open": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveCatmullRomOpen"],
      "monotone-x": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneX"],
      "monotone-y": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveMonotoneY"],
      "natural": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveNatural"],
      "linear-closed": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinearClosed"],
      "linear": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveLinear"],
      "step": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStep"],
      "step-after": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepAfter"],
      "step-before": external_commonjs_d3_shape_commonjs2_d3_shape_amd_d3_shape_root_d3_["curveStepBefore"]
    }[interpolation];
  },
  getInterpolateType: function getInterpolateType(d) {
    var $$ = this,
        config = $$.config,
        type = config.spline_interpolation_type,
        interpolation = $$.isInterpolationType(type) ? type : "cardinal";
    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? config.line_step_type : "linear";
  }
});
// CONCATENATED MODULE: ./src/ChartInternal/ChartInternal.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 * @ignore
 */








 // Axis

 // data



 // interactions





 // internals
















 // shape








/**
 * Internal chart class.
 * - Note: Instantiated internally, not exposed for public.
 * @class ChartInternal
 * @ignore
 * @private
 */

var ChartInternal_ChartInternal =
/*#__PURE__*/
function () {
  // API interface
  // config object
  // cache instance
  // state variables
  // all Chart instances array within page (equivalent of 'bb.instances')
  // data object
  // selections
  // Axis
  // Axis
  // scales
  // original values
  // formatter function
  // format function
  function ChartInternal(api) {
    _defineProperty(this, "api", void 0), _defineProperty(this, "config", void 0), _defineProperty(this, "cache", void 0), _defineProperty(this, "state", void 0), _defineProperty(this, "charts", void 0), _defineProperty(this, "data", {
      xs: {},
      targets: []
    }), _defineProperty(this, "$el", {
      chart: null,
      //$el.chart,
      main: null,
      svg: null,
      axis: {
        // axes
        x: null,
        y: null,
        y2: null,
        subX: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([])
      },
      defs: null,
      tooltip: null,
      legend: null,
      title: null,
      arcs: null,
      bar: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
      //mainBar,
      line: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
      //mainLine,
      area: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
      //mainArea,
      circle: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
      //mainCircle,
      text: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
      //mainText,
      grid: {
        main: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
        //grid
        x: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
        //xgrid,
        y: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
        //ygrid,
        xLines: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
        //xgridLines,
        yLines: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]) //ygridLines,

      },
      region: {
        main: Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["selectAll"])([]),
        //region
        list: null // mainRegion

      },
      eventRect: null
    }), _defineProperty(this, "axis", void 0), _defineProperty(this, "scale", {
      x: null,
      y: null,
      y2: null,
      subX: null,
      subY: null,
      subY2: null,
      zoom: null
    }), _defineProperty(this, "org", {
      xScale: null,
      xDomain: null
    }), _defineProperty(this, "color", void 0), _defineProperty(this, "patterns", void 0), _defineProperty(this, "levelColor", void 0), _defineProperty(this, "point", void 0), _defineProperty(this, "format", {
      extraLineClasses: null,
      xAxisTick: null,
      dataTime: null,
      // dataTimeFormat
      defaultAxisTime: function defaultAxisTime() {},
      // defaultAxisTimeFormat
      axisTime: function axisTime() {} // axisTimeFormat

    });
    var $$ = this;
    $$.api = api, $$.config = new Options(), $$.cache = new Cache_Cache(), $$.state = new Store_state();
  }

  var _proto = ChartInternal.prototype;
  return _proto.beforeInit = function beforeInit() {
    var $$ = this;
    $$.callPluginHook("$beforeInit"), callFn($$.config.onbeforeinit, $$, $$.api);
  }, _proto.afterInit = function afterInit() {
    var $$ = this;
    $$.callPluginHook("$afterInit"), callFn($$.config.onafterinit, $$, $$.api);
  }, _proto.init = function init() {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.initParams();
    var bindto = {
      element: config.bindto,
      classname: "bb"
    };
    isObject(config.bindto) && (bindto.element = config.bindto.element || "#chart", bindto.classname = config.bindto.classname || bindto.classname), $el.chart = isFunction(bindto.element.node) ? config.bindto.element : Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(bindto.element || []), $el.chart.empty() && ($el.chart = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(browser_doc.body.appendChild(browser_doc.createElement("div")))), $el.chart.html("").classed(bindto.classname, !0), $$.initToRender();
  }
  /**
   * Initialize the rendering process
   * @param {Boolean} forced Force to render process
   * @private
   */
  , _proto.initToRender = function initToRender(forced) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        chart = $$.$el.chart,
        isHidden = function () {
      return chart.style("display") === "none" || chart.style("visibility") === "hidden";
    },
        isLazy = config.render.lazy || isHidden(),
        MutationObserver = win.MutationObserver;

    if (isLazy && MutationObserver && config.render.observe !== !1 && !forced && new MutationObserver(function (mutation, observer) {
      isHidden() || (observer.disconnect(), !state.rendered && $$.initToRender(!0));
    }).observe(chart.node(), {
      attributes: !0,
      attributeFilter: ["class", "style"]
    }), !isLazy || forced) {
      var convertedData = $$.convertData(config, $$.initWithData);
      convertedData && $$.initWithData(convertedData);
    }
  }, _proto.initParams = function initParams() {
    var $$ = this,
        config = $$.config,
        format = $$.format,
        state = $$.state,
        isRotated = config.axis_rotated;
    state.datetimeId = "bb-" + +new Date(), $$.initClip(), $$.color = $$.generateColor(), $$.levelColor = $$.generateLevelColor(), $$.point = $$.generatePoint(), format.extraLineClasses = $$.generateExtraLineClass(), format.dataTime = config.data_xLocaltime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeParse"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcParse"], format.axisTime = config.axis_x_localtime ? external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["timeFormat"] : external_commonjs_d3_time_format_commonjs2_d3_time_format_amd_d3_time_format_root_d3_["utcFormat"];
    var isDragZoom = $$.config.zoom_enabled && $$.config.zoom_enabled.type === "drag";
    format.defaultAxisTime = function (d) {
      var _$$$scale = $$.scale,
          x = _$$$scale.x,
          zoom = _$$$scale.zoom,
          isZoomed = isDragZoom ? zoom : zoom && x.orgDomain().toString() !== zoom.domain().toString(),
          specifier = d.getMilliseconds() && ".%L" || d.getSeconds() && ".:%S" || d.getMinutes() && "%I:%M" || d.getHours() && "%I %p" || d.getDate() !== 1 && "%b %d" || isZoomed && d.getDate() === 1 && "%b\'%y" || d.getMonth() && "%-m/%-d" || "%Y";
      return format.axisTime(specifier)(d);
    }, state.isLegendRight = config.legend_position === "right", state.isLegendInset = config.legend_position === "inset", state.isLegendTop = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "top-right", state.isLegendLeft = config.legend_inset_anchor === "top-left" || config.legend_inset_anchor === "bottom-left", state.rotatedPaddingRight = isRotated && !config.axis_x_show ? 0 : 30, state.inputType = $$.convertInputType();
  }, _proto.initWithData = function initWithData(data) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        _$$$scale2 = $$.scale,
        x = _$$$scale2.x,
        y = _$$$scale2.y,
        y2 = _$$$scale2.y2,
        subX = _$$$scale2.subX,
        subY = _$$$scale2.subY,
        subY2 = _$$$scale2.subY2,
        org = $$.org;

    if ($$.axis = new Axis_Axis($$), config.zoom_enabled && $$.initZoom(), $$.data.xs = {}, $$.data.targets = $$.convertDataToTargets(data), config.data_filter && ($$.data.targets = $$.data.targets.filter(config.data_filter)), config.data_hide && $$.addHiddenTargetIds(config.data_hide === !0 ? $$.mapToIds($$.data.targets) : config.data_hide), config.legend_hide && $$.addHiddenLegendIds(config.legend_hide === !0 ? $$.mapToIds($$.data.targets) : config.legend_hide), $$.updateSizes(), $$.updateScales(!0), x && (x.domain(util_sortValue($$.getXDomain($$.data.targets))), subX.domain(x.domain()), org.xDomain = x.domain()), y && (y.domain($$.getYDomain($$.data.targets, "y")), subY.domain(y.domain())), y2 && (y2.domain($$.getYDomain($$.data.targets, "y2")), subY2 && subY2.domain(y2.domain())), $el.svg = $el.chart.append("svg").style("overflow", "hidden").style("display", "block"), config.interaction_enabled && state.inputType) {
      var isTouch = state.inputType === "touch";
      $el.svg.on(isTouch ? "touchstart" : "mouseenter", function () {
        return callFn(config.onover, $$, $$.api);
      }).on(isTouch ? "touchend" : "mouseleave", function () {
        return callFn(config.onout, $$, $$.api);
      });
    }

    config.svg_classname && $$.$el.svg.attr("class", config.svg_classname), $el.defs = $el.svg.append("defs"), $$.appendClip($el.defs, state.clip.id), $$.appendClip($el.defs, state.clip.idXAxis), $$.appendClip($el.defs, state.clipYAxis), $$.appendClip($el.defs, state.clip.idGrid), isFunction(config.color_tiles) && $$.patterns && $$.patterns.forEach(function (p) {
      return $el.defs.append(function () {
        return p.node;
      });
    }), $$.updateSvgSize();
    // Define regions
    var main = $el.svg.append("g").attr("transform", $$.getTranslate("main"));

    // data.onmin/max callback
    if ($el.main = main, config.subchart_show && $$.initSubchart(), $$.initTooltip && $$.initTooltip(), $$.initLegend && $$.initLegend(), $$.initTitle && $$.initTitle(), config.data_empty_label_text && main.append("text").attr("class", config_classes.text + " " + config_classes.empty).attr("text-anchor", "middle") // horizontal centering of text at x position in all browsers.
    .attr("dominant-baseline", "middle"), $$.initRegion(), config.clipPath || $$.axis.init(), main.append("g").attr("class", config_classes.chart).attr("clip-path", state.clip.path), $$.callPluginHook("$init"), $$.initEventRect(), $$.initChartElements(), $$.initGrid(), main.insert("rect", config.zoom_privileged ? null : "g." + config_classes.regions).attr("class", config_classes.zoomRect).attr("width", $$.state.width).attr("height", $$.state.height).style("opacity", "0").on("dblclick.zoom", null), config.clipPath && $$.axis.init(), $$.updateTargets($$.data.targets), $$.updateDimension(), callFn(config.oninit, $$, $$.api), $$.setBackground(), $$.redraw({
      withTransition: !1,
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withTransitionForAxis: !1,
      initializing: !0
    }), config.data_onmin || config.data_onmax) {
      var minMax = $$.getMinMaxData();
      callFn(config.data_onmin, $$, minMax.min), callFn(config.data_onmax, $$, minMax.max);
    } // Bind resize event


    $$.bindResize(), $$.api.element = $el.chart.node(), state.rendered = !0;
  }, _proto.initChartElements = function initChartElements() {
    var $$ = this;
    ["Bar", "Radar", "Line", "Bubble", "Arc", "Gauge", "Pie"].forEach(function (v) {
      $$["init" + v]();
    }), notEmpty($$.config.data_labels) && $$.initText();
  }, _proto.setChartElements = function setChartElements() {
    var $$ = this,
        $el = $$.$el;
    $$.api.$ = {
      chart: $el.chart,
      svg: $el.svg,
      defs: $el.defs,
      main: $el.main,
      tooltip: $el.tooltip,
      legend: $el.legend,
      title: $el.title,
      grid: $el.grid,
      arc: $el.arcs,
      bar: {
        bars: $el.bar
      },
      line: {
        lines: $el.line,
        areas: $el.area,
        circles: $el.circle
      },
      text: {
        texts: $el.text
      }
    };
  }
  /**
   * Set background element/image
   * @private
   */
  , _proto.setBackground = function setBackground() {
    var $$ = this,
        bg = $$.config.background,
        svg = $$.$el.svg;

    if (notEmpty(bg)) {
      var element = svg.select("." + config_classes[$$.hasArcType() ? "chart" : "regions"]).insert(bg.imgUrl ? "image" : "rect", ":first-child");
      bg.imgUrl ? element.attr("href", bg.imgUrl) : bg.color && element.style("fill", bg.color), element.attr("class", bg.class || null).attr("width", "100%").attr("height", "100%");
    }
  }, _proto.smoothLines = function smoothLines(el, type) {
    type === "grid" && el.each(function () {
      var g = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this);
      ["x1", "x2", "y1", "y2"].forEach(function (v) {
        return g.attr(v, Math.ceil(+g.attr(v)));
      });
    });
  }
  /**
   * Update size values
   * @param {Boolean} isInit If is called at initialization
   * @private
   */
  , _proto.updateSizes = function updateSizes(isInit) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        legend = $$.$el.legend,
        isRotated = config.axis_rotated,
        hasArc = $$.hasArcType(),
        currLegend = {
      width: legend ? $$.getLegendWidth() : 0,
      height: legend ? $$.getLegendHeight() : 0
    },
        legendHeightForBottom = state.isLegendRight || state.isLegendInset ? 0 : currLegend.height,
        xAxisHeight = isRotated || hasArc ? 0 : $$.getHorizontalAxisHeight("x"),
        subchartXAxisHeight = config.subchart_axis_x_show && config.subchart_axis_x_tick_text_show ? xAxisHeight : 30,
        subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + subchartXAxisHeight : 0;
    isInit || $$.setContainerSize(), state.margin = isRotated ? {
      top: $$.getHorizontalAxisHeight("y2") + $$.getCurrentPaddingTop(),
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: $$.getHorizontalAxisHeight("y") + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())
    } : {
      top: 4 + $$.getCurrentPaddingTop(),
      // for top tick text
      right: hasArc ? 0 : $$.getCurrentPaddingRight(),
      bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),
      left: hasArc ? 0 : $$.getCurrentPaddingLeft()
    }, state.margin2 = isRotated ? {
      top: state.margin.top,
      right: NaN,
      bottom: 20 + legendHeightForBottom,
      left: $$.state.rotatedPadding.left
    } : {
      top: state.currentHeight - subchartHeight - legendHeightForBottom,
      right: NaN,
      bottom: subchartXAxisHeight + legendHeightForBottom,
      left: state.margin.left
    }, state.margin3 = {
      top: 0,
      right: NaN,
      bottom: 0,
      left: 0
    }, $$.updateSizeForLegend && $$.updateSizeForLegend(currLegend), state.width = state.currentWidth - state.margin.left - state.margin.right, state.height = state.currentHeight - state.margin.top - state.margin.bottom, state.width < 0 && (state.width = 0), state.height < 0 && (state.height = 0), state.width2 = isRotated ? state.margin.left - state.rotatedPadding.left - state.rotatedPadding.right : state.width, state.height2 = isRotated ? state.height : state.currentHeight - state.margin2.top - state.margin2.bottom, state.width2 < 0 && (state.width2 = 0), state.height2 < 0 && (state.height2 = 0), state.arcWidth = state.width - (state.isLegendRight ? currLegend.width + 10 : 0), state.arcHeight = state.height - (state.isLegendRight ? 0 : 10), $$.hasType("gauge") && !config.gauge_fullCircle && (state.arcHeight += state.height - $$.getGaugeLabelHeight()), $$.updateRadius && $$.updateRadius(), state.isLegendRight && hasArc && (state.margin3.left = state.arcWidth / 2 + state.radiusExpanded * 1.1);
  }
  /**
   * Update targeted element with given data
   * @param {Object} targets Data object formatted as 'target'
   * @private
   */
  , _proto.updateTargets = function updateTargets(targets) {
    var $$ = this; // Text

    $$.updateTargetsForText(targets), $$.updateTargetsForBar(targets), $$.updateTargetsForLine(targets), $$.hasArcType(targets) && ($$.hasType("radar") ? $$.updateTargetsForRadar(targets) : $$.updateTargetsForArc(targets)), $$.updateTargetsForSubchart && $$.updateTargetsForSubchart(targets), $$.showTargets();
  }
  /**
   * Display targeted elements
   * @private
   */
  , _proto.showTargets = function showTargets() {
    var $$ = this;
    $$.$el.svg.selectAll("." + config_classes.target).filter(function (d) {
      return $$.isTargetToShow(d.id);
    }).transition().duration($$.config.transition_duration).style("opacity", "1");
  }, _proto.getWithOption = function getWithOption(options) {
    var withOptions = {
      Y: !0,
      Subchart: !0,
      Transition: !0,
      EventRect: !0,
      Dimension: !0,
      TrimXDomain: !0,
      Transform: !1,
      UpdateXDomain: !1,
      UpdateOrgXDomain: !1,
      Legend: !1,
      UpdateXAxis: "UpdateXDomain",
      TransitionForExit: "Transition",
      TransitionForAxis: "Transition"
    };
    return Object.keys(withOptions).forEach(function (key) {
      var defVal = withOptions[key];
      isString(defVal) && (defVal = withOptions[defVal]), withOptions[key] = getOption(options, "with" + key, defVal);
    }), withOptions;
  }, _proto.redraw = function redraw(options, transitionsValue) {
    options === void 0 && (options = {});
    var $$ = this,
        config = $$.config,
        state = $$.state,
        $el = $$.$el,
        main = $el.main,
        targetsToShow = $$.filterTargetsToShow($$.data.targets),
        initializing = options.initializing,
        flow = options.flow,
        wth = $$.getWithOption(options),
        duration = wth.Transition ? config.transition_duration : 0,
        durationForExit = wth.TransitionForExit ? duration : 0,
        durationForAxis = wth.TransitionForAxis ? duration : 0,
        transitions = transitionsValue || $$.axis.generateTransitions(durationForAxis);
    initializing && config.tooltip_init_show || state.inputType !== "touch" || $$.hideTooltip(), $$.updateSizes(initializing), wth.Legend && config.legend_show ? $$.updateLegend($$.mapToIds($$.data.targets), options, transitions) : wth.Dimension && $$.updateDimension(!0), $$.axis.redrawAxis(targetsToShow, wth, transitions, flow, initializing), $$.updateCircleY(), $$.updategridFocus(), config.data_empty_label_text && main.select("text." + config_classes.text + "." + config_classes.empty).attr("x", state.width / 2).attr("y", state.height / 2).text(config.data_empty_label_text).style("display", targetsToShow.length ? "none" : null), $$.updateGrid(duration), $$.updateRegion(duration), $$.updateBar(durationForExit), $$.updateLine(durationForExit), $$.updateArea(durationForExit), $$.updateCircle(), $$.hasDataLabel() && $$.updateText(durationForExit), $$.redrawTitle && $$.redrawTitle(), $el.arcs && $$.redrawArc(duration, durationForExit, wth.Transform), $$.radars && $$.redrawRadar(duration, durationForExit), $el.text && main.selectAll("." + config_classes.selectedCircles).filter($$.isBarType.bind($$)).selectAll("circle").remove(), config.interaction_enabled && !flow && wth.EventRect && $$.bindZoomEvent(), initializing && $$.setChartElements(), $$.generateRedrawList(targetsToShow, flow, duration, wth.Subchart), $$.callPluginHook("$redraw", options, duration);
  }
  /**
   * Generate redraw list
   * @param {Object} targets targets data to be shown
   * @param {Object} flow
   * @param {Object} duration
   * @param {Boolean} withSubchart whether or not to show subchart
   * @private
   */
  , _proto.generateRedrawList = function generateRedrawList(targets, flow, duration, withSubchart) {
    var $$ = this,
        config = $$.config,
        state = $$.state,
        shape = $$.getDrawShape();
    config.subchart_show && $$.redrawSubchart(withSubchart, duration, shape);
    // generate flow
    var flowFn = flow && $$.generateFlow({
      targets: targets,
      flow: flow,
      duration: flow.duration,
      shape: shape,
      xv: $$.xv.bind($$)
    }),
        isTransition = (duration || flowFn) && $$.isTabVisible(),
        redrawList = $$.getRedrawList(shape, flow, flowFn, isTransition),
        afterRedraw = flow || config.onrendered ? function () {
      flowFn && flowFn(), callFn(config.onrendered, $$, $$.api);
    } : null;
    if (afterRedraw) // Only use transition when current tab is visible.
      if (isTransition && redrawList.length) {
        // Wait for end of transitions for callback
        var waitForDraw = $$.generateWait(); // transition should be derived from one transition

        Object(external_commonjs_d3_transition_commonjs2_d3_transition_amd_d3_transition_root_d3_["transition"])().duration(duration).each(function () {
          redrawList.reduce(function (acc, t1) {
            return acc.concat(t1);
          }, []).forEach(function (t) {
            return waitForDraw.add(t);
          });
        }).call(waitForDraw, afterRedraw);
      } else state.transiting || afterRedraw(); // update fadein condition

    $$.mapToIds($$.data.targets).forEach(function (id) {
      state.withoutFadeIn[id] = !0;
    });
  }
  /**
   * Get the shape draw function
   * @return {Object}
   * @private
   */
  , _proto.getDrawShape = function getDrawShape() {
    var $$ = this,
        isRotated = $$.config.axis_rotated,
        hasRadar = $$.hasType("radar"),
        shape = {
      type: {},
      indices: {},
      pos: {}
    };

    // setup drawer - MEMO: these must be called after axis updated
    if ($$.hasTypeOf("Line") || $$.hasType("bubble") || $$.hasType("scatter")) {
      var indices = $$.getShapeIndices($$.isLineType);

      if (shape.indices.line = indices, shape.type.line = $$.generateDrawLine ? $$.generateDrawLine(indices, !1) : undefined, $$.hasTypeOf("Area")) {
        var _indices = $$.getShapeIndices($$.isAreaType);

        shape.indices.area = _indices, shape.type.area = $$.generateDrawArea ? $$.generateDrawArea(_indices, !1) : undefined;
      }
    }

    if ($$.hasType("bar")) {
      var _indices2 = $$.getShapeIndices($$.isBarType);

      shape.indices.bar = _indices2, shape.type.bar = $$.generateDrawBar ? $$.generateDrawBar(_indices2) : undefined;
    }

    return shape.pos = {
      xForText: $$.generateXYForText(shape.indices, !0),
      yForText: $$.generateXYForText(shape.indices, !1),
      // generate circle x/y functions depending on updated params
      cx: (hasRadar ? $$.radarCircleX : isRotated ? $$.circleY : $$.circleX).bind($$),
      cy: (hasRadar ? $$.radarCircleY : isRotated ? $$.circleX : $$.circleY).bind($$)
    }, shape;
  }, _proto.getRedrawList = function getRedrawList(shape, flow, flowFn, isTransition) {
    var $$ = this,
        config = $$.config,
        hasArcType = $$.hasArcType(),
        _shape$pos = shape.pos,
        cx = _shape$pos.cx,
        cy = _shape$pos.cy,
        xForText = _shape$pos.xForText,
        yForText = _shape$pos.yForText,
        list = [];

    if (!hasArcType) {
      var _shape$type = shape.type,
          area = _shape$type.area,
          _bar = _shape$type.bar,
          _line = _shape$type.line;
      (config.grid_x_lines.length || config.grid_y_lines.length) && list.push($$.redrawGrid(isTransition)), config.regions.length && list.push($$.redrawRegion(isTransition)), $$.hasTypeOf("Line") && (list.push($$.redrawLine(_line, isTransition)), $$.hasTypeOf("Area") && list.push($$.redrawArea(area, isTransition))), $$.hasType("bar") && list.push($$.redrawBar(_bar, isTransition)), notEmpty(config.data_labels) && list.push($$.redrawText(xForText, yForText, flow, isTransition));
    }

    return (!hasArcType || $$.hasType("radar")) && list.push($$.redrawCircle(cx, cy, isTransition, flowFn)), list;
  }, _proto.updateAndRedraw = function updateAndRedraw(options) {
    options === void 0 && (options = {});
    var transitions,
        $$ = this,
        config = $$.config;
    options.withTransition = getOption(options, "withTransition", !0), options.withTransform = getOption(options, "withTransform", !1), options.withLegend = getOption(options, "withLegend", !1), options.withUpdateXDomain = !0, options.withUpdateOrgXDomain = !0, options.withTransitionForExit = !1, options.withTransitionForTransform = getOption(options, "withTransitionForTransform", options.withTransition), options.withLegend && config.legend_show || (transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0), $$.updateScales(), $$.updateSvgSize(), $$.transformAll(options.withTransitionForTransform, transitions)), $$.redraw(options, transitions);
  }, _proto.redrawWithoutRescale = function redrawWithoutRescale() {
    this.redraw({
      withY: !1,
      withSubchart: !1,
      withEventRect: !1,
      withTransitionForAxis: !1
    });
  }, _proto.isTimeSeries = function isTimeSeries() {
    return this.config.axis_x_type === "timeseries";
  }, _proto.isCategorized = function isCategorized() {
    return this.config.axis_x_type.indexOf("category") >= 0 || this.hasType("radar");
  }, _proto.isCustomX = function isCustomX() {
    var $$ = this,
        config = $$.config;
    return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));
  }, _proto.isTimeSeriesY = function isTimeSeriesY() {
    return this.config.axis_y_type === "timeseries";
  }, _proto.getTranslate = function getTranslate(target, index) {
    index === void 0 && (index = 0);
    var x,
        y,
        $$ = this,
        config = $$.config,
        state = $$.state,
        isRotated = config.axis_rotated,
        hasGauge = $$.hasType("gauge"),
        padding = 0;
    if (index && /^(x|y2?)$/.test(target) && (padding = $$.getAxisSize(target) * index), target === "main") x = asHalfPixel(state.margin.left), y = asHalfPixel(state.margin.top);else if (target === "context") x = asHalfPixel(state.margin2.left), y = asHalfPixel(state.margin2.top);else if (target === "legend") x = state.margin3.left, y = state.margin3.top + (hasGauge ? 10 : 0);else if (target === "x") x = isRotated ? -padding : 0, y = isRotated ? 0 : state.height + padding;else if (target === "y") x = isRotated ? 0 : -padding, y = isRotated ? state.height + padding : 0;else if (target === "y2") x = isRotated ? 0 : state.width + padding, y = isRotated ? 1 - padding : 0;else if (target === "subX") x = 0, y = isRotated ? 0 : state.height2;else if (target === "arc") x = state.arcWidth / 2, y = state.arcHeight / 2;else if (target === "radar") {
      var _$$$getRadarSize = $$.getRadarSize(),
          width = _$$$getRadarSize[0];

      x = state.width / 2 - width, y = asHalfPixel(state.margin.top);
    }
    return "translate(" + x + ", " + y + ")";
  }, _proto.initialOpacity = function initialOpacity(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? "1" : "0";
  }, _proto.initialOpacityForCircle = function initialOpacityForCircle(d) {
    var withoutFadeIn = this.state.withoutFadeIn;
    return this.getBaseValue(d) !== null && withoutFadeIn[d.id] ? this.opacityForCircle(d) : "0";
  }, _proto.opacityForCircle = function opacityForCircle(d) {
    var opacity = this.config.point_show ? "1" : "0";
    return isValue(this.getBaseValue(d)) ? this.isBubbleType(d) || this.isScatterType(d) ? "0.5" : opacity : "0";
  }, _proto.opacityForText = function opacityForText() {
    return this.hasDataLabel() ? "1" : "0";
  }
  /**
   * Get the zoom or unzoomed scaled value
   * @param {Date|Number|Object} d Data value
   * @private
   */
  , _proto.xx = function xx(d) {
    var $$ = this,
        config = $$.config,
        _$$$scale3 = $$.scale,
        x = _$$$scale3.x,
        zoom = _$$$scale3.zoom,
        fn = config.zoom_enabled && zoom ? zoom : x;
    return d ? fn(isValue(d.x) ? d.x : d) : null;
  }, _proto.xv = function xv(d) {
    var $$ = this,
        config = $$.config,
        x = $$.scale.x,
        value = $$.getBaseValue(d);
    return $$.isTimeSeries() ? value = $$.parseDate(value) : $$.isCategorized() && isString(value) && (value = config.axis_x_categories.indexOf(value)), Math.ceil(x(value));
  }, _proto.yv = function yv(d) {
    var $$ = this,
        _$$$scale4 = $$.scale,
        y = _$$$scale4.y,
        y2 = _$$$scale4.y2,
        yScale = d.axis && d.axis === "y2" ? y2 : y;
    return Math.ceil(yScale($$.getBaseValue(d)));
  }, _proto.subxx = function subxx(d) {
    return d ? this.scale.subX(d.x) : null;
  }, _proto.transformMain = function transformMain(withTransition, transitions) {
    var xAxis,
        yAxis,
        y2Axis,
        $$ = this,
        main = $$.$el.main;
    transitions && transitions.axisX ? xAxis = transitions.axisX : (xAxis = main.select("." + config_classes.axisX), withTransition && (xAxis = xAxis.transition())), transitions && transitions.axisY ? yAxis = transitions.axisY : (yAxis = main.select("." + config_classes.axisY), withTransition && (yAxis = yAxis.transition())), transitions && transitions.axisY2 ? y2Axis = transitions.axisY2 : (y2Axis = main.select("." + config_classes.axisY2), withTransition && (y2Axis = y2Axis.transition())), (withTransition ? main.transition() : main).attr("transform", $$.getTranslate("main")), xAxis.attr("transform", $$.getTranslate("x")), yAxis.attr("transform", $$.getTranslate("y")), y2Axis.attr("transform", $$.getTranslate("y2")), main.select("." + config_classes.chartArcs).attr("transform", $$.getTranslate("arc"));
  }, _proto.transformAll = function transformAll(withTransition, transitions) {
    var $$ = this,
        config = $$.config,
        $el = $$.$el;
    $$.transformMain(withTransition, transitions), config.subchart_show && $$.transformContext(withTransition, transitions), $el.legend && $$.transformLegend(withTransition);
  }, _proto.updateSvgSize = function updateSvgSize() {
    var $$ = this,
        state = $$.state,
        svg = $$.$el.svg,
        brush = svg.select("." + config_classes.brush + " .overlay"),
        brushSize = {
      width: 0,
      height: 0
    };
    brush.size() && (brushSize.width = +brush.attr("width"), brushSize.height = +brush.attr("height")), svg.attr("width", state.currentWidth).attr("height", state.currentHeight), svg.selectAll(["#" + state.clip.id, "#" + state.clip.idGrid]).select("rect").attr("width", state.width).attr("height", state.height), svg.select("#" + state.clip.idXAxis).select("rect").attr("x", $$.getXAxisClipX.bind($$)).attr("y", $$.getXAxisClipY.bind($$)).attr("width", $$.getXAxisClipWidth.bind($$)).attr("height", $$.getXAxisClipHeight.bind($$)), svg.select("#" + state.clip.idYAxis).select("rect").attr("x", $$.getYAxisClipX.bind($$)).attr("y", $$.getYAxisClipY.bind($$)).attr("width", $$.getYAxisClipWidth.bind($$)).attr("height", $$.getYAxisClipHeight.bind($$)), state.clip.idSubchart && svg.select("#" + state.clip.idSubchart).select("rect").attr("width", state.width).attr("height", brushSize.height), svg.select("." + config_classes.zoomRect).attr("width", state.width).attr("height", state.height);
  }, _proto.updateDimension = function updateDimension(withoutAxis) {
    var $$ = this,
        config = $$.config,
        axis = $$.$el.axis;
    withoutAxis || ($$.axis.x && config.axis_rotated ? ($$.axis.x.create(axis.x), $$.axis.subX.create(axis.subX)) : ($$.axis.y && $$.axis.y.create(axis.y), $$.axis.y2 && $$.axis.y2.create(axis.y2))), $$.updateScales(withoutAxis), $$.updateSvgSize(), $$.transformAll(!1);
  }, _proto.bindResize = function bindResize() {
    var $$ = this,
        config = $$.config;
    $$.resizeFunction = $$.generateResize(), $$.resizeFunction.add(function () {
      return callFn(config.onresize, $$, $$.api);
    }), config.resize_auto && $$.resizeFunction.add(function () {
      $$.resizeTimeout && (win.clearTimeout($$.resizeTimeout), $$.resizeTimeout = null), $$.resizeTimeout = win.setTimeout(function () {
        $$.api.flush(!1, !0);
      }, 200);
    }), $$.resizeFunction.add(function () {
      return callFn(config.onresized, $$, $$.api);
    }), win.addEventListener("resize", $$.resizeFunction);
  }, _proto.generateResize = function generateResize() {
    function callResizeFunctions() {
      resizeFunctions.forEach(function (f) {
        return f();
      });
    }

    var resizeFunctions = [];
    return callResizeFunctions.add = function (f) {
      return resizeFunctions.push(f);
    }, callResizeFunctions.remove = function (f) {
      return resizeFunctions.splice(resizeFunctions.indexOf(f), 1);
    }, callResizeFunctions;
  }, _proto.endall = function endall(transition, callback) {
    var n = 0;
    transition.each(function () {
      return ++n;
    }).on("end", function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];

      --n || callback.apply.apply(callback, [this].concat(args));
    });
  }, _proto.generateWait = function generateWait() {
    var transitionsToWait = [],
        f = function (t, callback) {
      function loop() {
        for (var _t, done = 0, i = 0; _t = transitionsToWait[i]; i++) {
          if (_t.empty()) {
            done++;
            continue;
          }

          try {
            _t.transition();
          } catch (e) {
            done++;
          }
        }

        timer && clearTimeout(timer), done === transitionsToWait.length ? callback && callback() : timer = setTimeout(loop, 50);
      }

      var timer;
      loop();
    };

    return f.add = function (t) {
      isArray(t) ? transitionsToWait = transitionsToWait.concat(t) : transitionsToWait.push(t);
    }, f;
  }, _proto.parseDate = function parseDate(date) {
    var parsedDate,
        $$ = this;
    return date instanceof Date ? parsedDate = date : isString(date) ? parsedDate = $$.format.dataTime($$.config.data_xFormat)(date) : isNumber(date) && !isNaN(date) && (parsedDate = new Date(+date)), (!parsedDate || isNaN(+parsedDate)) && console && console.error && console.error("Failed to parse x '" + date + "' to Date object"), parsedDate;
  }, _proto.isTabVisible = function isTabVisible() {
    return !browser_doc.hidden;
  }, _proto.convertInputType = function convertInputType() {
    var $$ = this,
        config = $$.config,
        isMobile = !1;

    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#Mobile_Tablet_or_Desktop
    if (/Mobi/.test(win.navigator.userAgent) && config.interaction_inputType_touch) {
      // Some Edge desktop return true: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/20417074/
      var hasTouchPoints = win.navigator && "maxTouchPoints" in win.navigator && win.navigator.maxTouchPoints > 0,
          hasTouch = "ontouchmove" in win || win.DocumentTouch && browser_doc instanceof win.DocumentTouch; // Ref: https://github.com/Modernizr/Modernizr/blob/master/feature-detects/touchevents.js
      // On IE11 with IE9 emulation mode, ('ontouchstart' in window) is returning true

      isMobile = hasTouchPoints || hasTouch;
    }

    var hasMouse = config.interaction_inputType_mouse && !isMobile && "onmouseover" in win;
    return hasMouse && "mouse" || isMobile && "touch" || null;
  }
  /**
   * Call plugin hook
   * @param {String} phase The lifecycle phase
   * @private
   */
  , _proto.callPluginHook = function callPluginHook(phase) {
    for (var _this = this, _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) args[_key2 - 1] = arguments[_key2];

    this.config.plugins.forEach(function (v) {
      phase === "$beforeInit" && (v.$$ = _this, _this.api.plugins.push(v)), v[phase].apply(v, args);
    });
  }, ChartInternal;
}();


extend(ChartInternal_ChartInternal.prototype, [data_convert, ChartInternal_data_data, data_load, interactions_drag, interactions_flow, interactions_interaction, interactions_subchart, interactions_zoom, category, internals_class, internals_clip, internals_color, internals_domain, internals_format, internals_grid, internals_legend, region, internals_scale, internals_selection, internals_size, internals_text, internals_title, internals_tooltip, internals_type, shape_arc, ChartInternal_shape_bar, shape_bubble, ChartInternal_shape_line, shape_point, shape_radar, shape_shape]);
// CONCATENATED MODULE: ./src/config/config.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Load configuration option
 * @param {Object} config User's generation config value
 * @private
 */

function loadConfig(config) {
  var target,
      keys,
      read,
      thisConfig = this.config,
      find = function () {
    var key = keys.shift();
    return key && target && isObjectType(target) && key in target ? (target = target[key], find()) : key ? undefined : target;
  };

  Object.keys(thisConfig).forEach(function (key) {
    target = config, keys = key.split("_"), read = find(), isDefined(read) && (thisConfig[key] = read);
  });
}
// CONCATENATED MODULE: ./src/chart/api/axis.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Set the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @param {Object} value
 * @return {undefined}
 * @private
 */

function setMinMax($$, type, value) {
  var config = $$.config,
      axisY = "axis_y_" + type,
      axisY2 = "axis_y2_" + type;
  return isDefined(value) && (isObjectType(value) ? (isValue(value.x) && (config["axis_x_" + type] = value.x), isValue(value.y) && (config[axisY] = value.y), isValue(value.y2) && (config[axisY2] = value.y2)) : (config[axisY] = value, config[axisY2] = value), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0
  })), undefined;
}
/**
 * Get the min/max value
 * @param {Chart} $$
 * @param {String} type
 * @return {{x, y, y2}}
 * @private
 */


function axis_getMinMax($$, type) {
  var config = $$.config;
  return {
    x: config["axis_x_" + type],
    y: config["axis_y_" + type],
    y2: config["axis_y2_" + type]
  };
}
/**
 * Define axis
 * @ignore
 */


var api_axis_axis = {
  /**
   * Get and set axis labels.
   * @method axis․labels
   * @instance
   * @memberof Chart
   * @param {Object} labels specified axis' label to be updated.
   * @example
   * // Update axis' label
   * chart.axis.labels({
   *   x: "New X Axis Label",
   *   y: "New Y Axis Label"
   * });
   */
  labels: function labels(_labels) {
    var $$ = this.internal;
    arguments.length && (Object.keys(_labels).forEach(function (axisId) {
      $$.axis.setLabelText(axisId, _labels[axisId]);
    }), $$.axis.updateLabels());
  },

  /**
   * Get and set axis min value.
   * @method axis․min
   * @instance
   * @memberof Chart
   * @param {Object} min If min is given, specified axis' min value will be updated.<br>
   *     If no argument is given, the min values set on generating option for each axis will be returned.
   *     If not set any min values on generation, it will return `undefined`.
   * @example
   * // Update axis' min
   * chart.axis.min({
   *   x: -10,
   *   y: 1000,
   *   y2: 100
   * });
   */
  min: function min(_min) {
    var $$ = this.internal;
    return isValue(_min) ? setMinMax($$, "min", _min) : axis_getMinMax($$, "min");
  },

  /**
   * Get and set axis max value.
   * @method axis․max
   * @instance
   * @memberof Chart
   * @param {Object} max If max is given, specified axis' max value will be updated.<br>
   *     If no argument is given, the max values set on generating option for each axis will be returned.
   *     If not set any max values on generation, it will return `undefined`.
   * @example
   * // Update axis' label
   * chart.axis.max({
   *    x: 100,
   *    y: 1000,
   *    y2: 10000
   * });
   */
  max: function max(_max) {
    var $$ = this.internal;
    return arguments.length ? setMinMax($$, "max", _max) : axis_getMinMax($$, "max");
  },

  /**
   * Get and set axis min and max value.
   * @method axis․range
   * @instance
   * @memberof Chart
   * @param {Object} range If range is given, specified axis' min and max value will be updated. If no argument is given, the current min and max values for each axis will be returned.
   * @example
   * // Update axis' label
   * chart.axis.range({
   *   min: {
   *     x: -10,
   *     y: -1000,
   *     y2: -10000
   *   },
   *   max: {
   *     x: 100,
   *     y: 1000,
   *     y2: 10000
   *   },
   * });
   */
  range: function range(_range) {
    var axis = this.axis;
    if (arguments.length) isDefined(_range.max) && axis.max(_range.max), isDefined(_range.min) && axis.min(_range.min);else return {
      max: axis.max(),
      min: axis.min()
    };
    return undefined;
  }
};
/* harmony default export */ var api_axis = ({
  axis: api_axis_axis
});
// CONCATENATED MODULE: ./src/chart/api/category.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_category = ({
  /**
   * Set specified category name on category axis.
   * @method category
   * @instance
   * @memberof Chart
   * @param {Number} i index of category to be changed
   * @param {String} category category value to be changed
   * @example
   * chart.category(2, "Category 3");
   */
  category: function category(i, _category) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length > 1 && (config.axis_x_categories[i] = _category, $$.redraw()), config.axis_x_categories[i];
  },

  /**
   * Set category names on category axis.
   * @method categories
   * @instance
   * @memberof Chart
   * @param {Array} categories This must be an array that includes category names in string. If category names are included in the date by data.x option, this is not required.
   * @example
   * chart.categories([
   *      "Category 1", "Category 2", ...
   * ]);
   */
  categories: function categories(_categories) {
    var $$ = this.internal,
        config = $$.config;
    return arguments.length ? (config.axis_x_categories = _categories, $$.redraw(), config.axis_x_categories) : config.axis_x_categories;
  }
});
// CONCATENATED MODULE: ./src/chart/api/chart.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_chart = ({
  /**
   * Resize the chart.
   * @method resize
   * @instance
   * @memberof Chart
   * @param {Object} size This argument should include width and height in pixels.
   * @example
   * // Resize to 640x480
   * chart.resize({
   *    width: 640,
   *    height: 480
   * });
   */
  resize: function resize(size) {
    var config = this.internal.config;
    config.size_width = size ? size.width : null, config.size_height = size ? size.height : null, this.flush(!1, !0);
  },

  /**
   * Force to redraw.
   * @method flush
   * @instance
   * @memberof Chart
   * @param {Boolean} [soft] For soft redraw.
   * @example
   * chart.flush();
   *
   * // for soft redraw
   * chart.flush(true);
   */
  flush: function flush(soft, _isFromResize) {
    var $$ = this.internal;
    $$.state.rendered ? (_isFromResize ? $$.brush && $$.brush.updateResize() : $$.axis && $$.axis.setOrient(), $$.scale.zoom = null, soft ? $$.redraw({
      withTransform: !0,
      withUpdateXDomain: !0,
      withUpdateOrgXDomain: !0,
      withLegend: !0
    }) : $$.updateAndRedraw({
      withLegend: !0,
      withTransition: !1,
      withTransitionForTransform: !1
    })) : $$.initToRender(!0);
  },

  /**
   * Reset the chart object and remove element and events completely.
   * @method destroy
   * @instance
   * @memberof Chart
   * @example
   * chart.destroy();
   */
  destroy: function destroy() {
    var _this = this,
        $$ = this.internal,
        $el = $$.$el;

    return notEmpty($$) && ($$.callPluginHook("$willDestroy"), $$.charts.splice($$.charts.indexOf(this), 1), $el.svg.select("*").interrupt(), isDefined($$.resizeTimeout) && win.clearTimeout($$.resizeTimeout), win.removeEventListener("resize", $$.resizeFunction), $el.chart.classed("bb", !1).html(""), Object.keys(this).forEach(function (key) {
      key === "internal" && Object.keys($$).forEach(function (k) {
        $$[k] = null;
      }), _this[key] = null, delete _this[key];
    })), null;
  },

  /**
   * Get or set single config option value.
   * @method config
   * @instance
   * @memberof Chart
   * @param {String} name The option key name.
   * @param {*} [value] The value accepted for indicated option.
   * @param {Boolean} [redraw] Set to redraw with the new option changes.
   * - **NOTE:** Doesn't guarantee work in all circumstances. It can be applied for limited options only.
   * @example
   * // Getter
   * chart.config("gauge.max");
   *
   * // Setter
   * chart.config("gauge.max", 100);
   *
   * // Setter & redraw with the new option
   * chart.config("gauge.max", 100, true);
   */
  config: function (name, value, redraw) {
    var res,
        $$ = this.internal,
        config = $$.config,
        key = name && name.replace(/\./g, "_");
    return key in config && (isDefined(value) ? (config[key] = value, res = value, redraw && this.flush()) : res = config[key]), res;
  }
});
// CONCATENATED MODULE: ./src/chart/api/color.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */
/* harmony default export */ var api_color = ({
  /**
   * Get the color
   * @method color
   * @instance
   * @memberof Chart
   * @param {String} id id to get the color
   * @example
   * chart.color("data1");
   */
  color: function color(id) {
    return this.internal.color(id); // more patterns
  }
});
// CONCATENATED MODULE: ./src/chart/api/data.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Get data loaded in the chart.
 * @method data
 * @instance
 * @memberof Chart
 * @param {String|Array} targetIds If this argument is given, this API returns the specified target data. If this argument is not given, all of data will be returned.
 * @return {Array} Data objects
 * @example
 * // Get only data1 data
 * chart.data("data1");
 * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
 *
 * // Get data1 and data2 data
 * chart.data(["data1", "data2"]);
 *
 * // Get all data
 * chart.data();
 */

function api_data_data(targetIds) {
  var targets = this.internal.data.targets;

  if (!isUndefined(targetIds)) {
    var ids = isArray(targetIds) ? targetIds : [targetIds];
    return targets.filter(function (t) {
      return ids.some(function (v) {
        return v === t.id;
      });
    });
  }

  return targets;
}

extend(api_data_data, {
  /**
   * Get data shown in the chart.
   * @method data․shown
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds If this argument is given, this API filters the data with specified target ids. If this argument is not given, all shown data will be returned.
   * @return {Array} Data objects
   * @example
   * // Get shown data by filtering to include only data1 data
   * chart.data.shown("data1");
   * // --> [{id: "data1", id_org: "data1", values: Array(6)}, ...]
   *
   * // Get shown data by filtering to include data1 and data2 data
   * chart.data.shown(["data1", "data2"]);
   *
   * // Get all shown data
   * chart.data.shown();
   */
  shown: function shown(targetIds) {
    return this.internal.filterTargetsToShow(this.data(targetIds));
  },

  /**
   * Get values of the data loaded in the chart.
   * @method data․values
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds This API returns the values of specified target. If this argument is not given, null will be retruned
   * @return {Array} Data values
   * @example
   * // Get data1 values
   * chart.data.values("data1");
   * // --> [10, 20, 30, 40]
   */
  values: function (targetId, flat) {
    flat === void 0 && (flat = !0);
    var values;

    if (targetId) {
      var targets = this.data(targetId);
      targets && isArray(targets) && (values = [], targets.forEach(function (v) {
        var dataValue = v.values.map(function (d) {
          return d.value;
        });
        flat ? values = values.concat(dataValue) : values.push(dataValue);
      }));
    }

    return values;
  },

  /**
   * Get and set names of the data loaded in the chart.
   * @method data․names
   * @instance
   * @memberof Chart
   * @param {Object} names If this argument is given, the names of data will be updated. If not given, the current names will be returned. The format of this argument is the same as
   * @return {Object} Corresponding names according its key value, if specified names values.
   * @example
   * // Get current names
   * chart.data.names();
   * // --> {data1: "test1", data2: "test2"}
   *
   * // Update names
   * chart.data.names({
   *  data1: "New Name 1",
   *  data2: "New Name 2"
   *});
   */
  names: function names(_names) {
    return this.internal.clearLegendItemTextBoxcache(), this.internal.updateDataAttributes("names", _names);
  },

  /**
   * Get and set colors of the data loaded in the chart.
   * @method data․colors
   * @instance
   * @memberof Chart
   * @param {Object} colors If this argument is given, the colors of data will be updated. If not given, the current colors will be returned. The format of this argument is the same as [data.colors](./Options.html#.data%25E2%2580%25A4colors).
   * @return {Object} Corresponding data color value according its key value.
   * @example
   * // Get current colors
   * chart.data.colors();
   * // --> {data1: "#00c73c", data2: "#fa7171"}
   *
   * // Update colors
   * chart.data.colors({
   *  data1: "#FFFFFF",
   *  data2: "#000000"
   * });
   */
  colors: function colors(_colors) {
    return this.internal.updateDataAttributes("colors", _colors);
  },

  /**
   * Get and set axes of the data loaded in the chart.
   * - **NOTE:** If all data is related to one of the axes, the domain of axis without related data will be replaced by the domain from the axis with related data
   * @method data․axes
   * @instance
   * @memberof Chart
   * @param {Object} axes If this argument is given, the axes of data will be updated. If not given, the current axes will be returned. The format of this argument is the same as
   * @return {Object} Corresponding axes value for data, if specified axes value.
   * @example
   * // Get current axes
   * chart.data.axes();
   * // --> {data1: "y"}
   *
   * // Update axes
   * chart.data.axes({
   *  data1: "y",
   *  data2: "y2"
   * });
   */
  axes: function axes(_axes) {
    return this.internal.updateDataAttributes("axes", _axes);
  },

  /**
   * Get the minimum data value bound to the chart
   * @method data․min
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.min();
   * // --> [{x: 0, value: 30, id: "data1", index: 0}, ...]
   */
  min: function min() {
    return this.internal.getMinMaxData().min;
  },

  /**
   * Get the maximum data value bound to the chart
   * @method data․max
   * @instance
   * @memberof Chart
   * @return {Array} Data objects
   * @example
   * // Get current axes
   * chart.data.max();
   * // --> [{x: 3, value: 400, id: "data1", index: 3}, ...]
   */
  max: function max() {
    return this.internal.getMinMaxData().max;
  }
});
/* harmony default export */ var api_data = ({
  data: api_data_data
});
// CONCATENATED MODULE: ./src/chart/api/export.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Encode to base64
 * @param {String} str
 * @return {String}
 * @private
 * @see https://developer.mozilla.org/ko/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 */

var b64EncodeUnicode = function (str) {
  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function (match, p) {
    return String.fromCharCode(+("0x" + p));
  }));
};
/**
 * Convert svg node to data url
 * @param {HTMLElement} node
 * @param {object} size
 * @return {String}
 * @private
 */


function nodeToSvgDataUrl(node, size) {
  var serializer = new XMLSerializer(),
      clone = node.cloneNode(!0),
      cssText = getCssRules(toArray(browser_doc.styleSheets)).filter(function (r) {
    return r.cssText;
  }).map(function (r) {
    return r.cssText;
  });
  clone.setAttribute("xmlns", external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].xhtml);
  var nodeXml = serializer.serializeToString(clone),
      style = browser_doc.createElement("style"); // escape css for XML

  style.appendChild(browser_doc.createTextNode(cssText.join("\n")));
  var styleXml = serializer.serializeToString(style),
      dataStr = ("<svg xmlns=\"" + external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["namespaces"].svg + "\" width=\"" + size.width + "\" height=\"" + size.height + "\">\n\t\t\t<foreignObject width=\"100%\" height=\"100%\">\n\t\t\t\t" + styleXml + "\n\t\t\t\t" + nodeXml.replace(/(url\()[^#]+/g, "$1") + "\n\t\t\t</foreignObject></svg>").replace("/\n/g", "%0A"); // foreignObject not supported in IE11 and below
  // https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx

  return "data:image/svg+xml;base64," + b64EncodeUnicode(dataStr);
}

/* harmony default export */ var api_export = ({
  /**
   * Export chart as an image.
   * - **NOTE:**
   *   - IE11 and below not work properly due to the lack of the feature(<a href="https://msdn.microsoft.com/en-us/library/hh834675(v=vs.85).aspx">foreignObject</a>) support
   *   - The basic CSS file(ex. billboard.css) should be at same domain as API call context to get correct styled export image.
   * @method export
   * @instance
   * @memberof Chart
   * @param {String} [mimeType=image/png] The desired output image format. (ex. 'image/png' for png, 'image/jpeg' for jpeg format)
   * @param {Function} [callback] The callback to be invoked when export is ready.
   * @return {String} dataURI
   * @example
   *  chart.export();
   *  // --> "data:image/svg+xml;base64,PHN..."
   *
   *  // Initialize the download automatically
   *  chart.export("image/png", dataUrl => {
   *     const link = document.createElement("a");
   *
   *     link.download = `${Date.now()}.png`;
   *     link.href = dataUrl;
   *     link.innerHTML = "Download chart as image";
   *
   *     document.body.appendChild(link);
   *  });
   */
  export: function _export(mimeType, callback) {
    var $$ = this.internal,
        _$$$state = $$.state,
        currentWidth = _$$$state.currentWidth,
        currentHeight = _$$$state.currentHeight,
        size = {
      width: currentWidth,
      height: currentHeight
    },
        svgDataUrl = nodeToSvgDataUrl(this.element, size);

    if (callback && isFunction(callback)) {
      var img = new Image();
      img.crossOrigin = "Anonymous", img.onload = function () {
        var canvas = browser_doc.createElement("canvas"),
            ctx = canvas.getContext("2d");
        canvas.width = size.width, canvas.height = size.height, ctx.drawImage(img, 0, 0), callback(canvas.toDataURL(mimeType));
      }, img.src = svgDataUrl;
    }

    return svgDataUrl;
  }
});
// CONCATENATED MODULE: ./src/chart/api/flow.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_flow = ({
  /**
   * Flow data to the chart.<br><br>
   * By this API, you can append new data points to the chart.
   * @method flow
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | json | Object | Data as JSON format (@see [data․json](Options.html#.data%25E2%2580%25A4json)) |
   *    | rows | Array | Data in array as row format (@see [data․rows](Options.html#.data%25E2%2580%25A4json)) |
   *    | columns | Array | Data in array as column format (@see [data․columns](Options.html#.data%25E2%2580%25A4columns)) |
   *    | to | String | The lower x edge will move to that point. If not given, the lower x edge will move by the number of given data points |
   *    | length | Number | The lower x edge will move by the number of this argument |
   *    | duration | Number | The duration of the transition will be specified value. If not given, transition.duration will be used as default |
   *    | done | Function | The specified function will be called when flow ends |
   *
   * - **NOTE:**
   *   - If json, rows and columns given, the data will be loaded.
   *   - If data that has the same target id is given, the chart will be appended.
   *   - Otherwise, new target will be added. One of these is required when calling.
   *   - If json specified, keys is required as well as data.json.
   * 	 - If tab isn't visible(by evaluating `document.hidden`), will not be executed to prevent unnecessary work.
   * @example
   * // 2 data points will be apprended to the tail and popped from the head.
   * // After that, 4 data points will be appended and no data points will be poppoed.
   * chart.flow({
   *  columns: [
   *    ["x", "2018-01-11", "2018-01-21"],
   *    ["data1", 500, 200],
   *    ["data2", 100, 300],
   *    ["data3", 200, 120]
   *  ],
   *  to: "2013-01-11",
   *  done: function () {
   *    chart.flow({
   *      columns: [
   *        ["x", "2018-02-11", "2018-02-12", "2018-02-13", "2018-02-14"],
   *        ["data1", 200, 300, 100, 250],
   *        ["data2", 100, 90, 40, 120],
   *        ["data3", 100, 100, 300, 500]
   *      ],
   *      length: 2,
      *      duration: 1500
   *    });
   *  }
   * });
   */
  flow: function flow(args) {
    var data,
        domain,
        diff,
        to,
        $$ = this.internal,
        length = 0,
        tail = 0;

    if ((args.json || args.rows || args.columns) && (data = $$.convertData(args)), data && $$.isTabVisible()) {
      var notfoundIds = [],
          orgDataCount = $$.getMaxDataCount(),
          targets = $$.convertDataToTargets(data, !0);
      $$.data.targets.forEach(function (t) {
        for (var found = !1, i = 0; i < targets.length; i++) if (t.id === targets[i].id) {
          found = !0, t.values[t.values.length - 1] && (tail = t.values[t.values.length - 1].index + 1), length = targets[i].values.length;

          for (var _j3 = 0; _j3 < length; _j3++) targets[i].values[_j3].index = tail + _j3, $$.isTimeSeries() || (targets[i].values[_j3].x = tail + _j3);

          t.values = t.values.concat(targets[i].values), targets.splice(i, 1);
          break;
        }

        found || notfoundIds.push(t.id);
      }), $$.data.targets.forEach(function (t) {
        for (var _i = 0; _i < notfoundIds.length; _i++) if (t.id === notfoundIds[_i]) {
          tail = t.values[t.values.length - 1].index + 1;

          for (var _j4 = 0; _j4 < length; _j4++) t.values.push({
            id: t.id,
            index: tail + _j4,
            x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + _j4) : tail + _j4,
            value: null
          });
        }
      }), $$.data.targets.length && targets.forEach(function (t) {
        for (var missing = [], i = $$.data.targets[0].values[0].index; i < tail; i++) missing.push({
          id: t.id,
          index: i,
          x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,
          value: null
        });

        t.values.forEach(function (v) {
          v.index += tail, $$.isTimeSeries() || (v.x += tail);
        }), t.values = missing.concat(t.values);
      }), $$.data.targets = $$.data.targets.concat(targets);
      // add remained
      // check data count because behavior needs to change when it"s only one
      // const dataCount = $$.getMaxDataCount();
      var baseTarget = $$.data.targets[0],
          baseValue = baseTarget.values[0];
      isDefined(args.to) ? (length = 0, to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to, baseTarget.values.forEach(function (v) {
        v.x < to && length++;
      })) : isDefined(args.length) && (length = args.length), orgDataCount ? orgDataCount === 1 && $$.isTimeSeries() && (diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2, domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]) : (diff = $$.isTimeSeries() ? baseTarget.values.length > 1 ? baseTarget.values[baseTarget.values.length - 1].x - baseValue.x : baseValue.x - $$.getXDomain($$.data.targets)[0] : 1, domain = [baseValue.x - diff, baseValue.x]), domain && $$.updateXDomain(null, !0, !0, !1, domain), $$.updateTargets($$.data.targets), $$.redraw({
        flow: {
          index: baseValue.index,
          length: length,
          duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,
          done: args.done,
          orgDataCount: orgDataCount
        },
        withLegend: !0,
        withTransition: orgDataCount > 1,
        withTrimXDomain: !1,
        withUpdateXAxis: !0
      });
    }
  }
});
// CONCATENATED MODULE: ./src/chart/api/focus.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/* harmony default export */ var api_focus = ({
  /**
   * This API highlights specified targets and fade out the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be highlighted.
   * @method focus
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIdsValue Target ids to be highlighted.
   * @example
   *  // data1 will be highlighted and the others will be faded out
   *  chart.focus("data1");
   *
   * // data1 and data2 will be highlighted and the others will be faded out
   * chart.focus(["data1", "data2"]);
   *
   * // all targets will be highlighted
   * chart.focus();
   */
  focus: function focus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    this.revert(), this.defocus(), candidates.classed(config_classes.focused, !0).classed(config_classes.defocused, !1), $$.hasArcType() && ($$.expandArc(targetIds), $$.hasType("gauge") && $$.markOverlapped(targetIdsValue, $$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !0), state.focusedTargetIds = targetIds, state.defocusedTargetIds = state.defocusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    });
  },

  /**
   * This API fades out specified targets and reverts the others.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be faded out.
   * @method defocus
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be faded out.
   * @example
   * // data1 will be faded out and the others will be reverted.
   * chart.defocus("data1");
   *
   * // data1 and data2 will be faded out and the others will be reverted.
   * chart.defocus(["data1", "data2"]);
   *
   * // all targets will be faded out.
   * chart.defocus();
   */
  defocus: function defocus(targetIdsValue) {
    var $$ = this.internal,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)));
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !0), $$.hasArcType() && ($$.unexpandArc(targetIds), $$.hasType("gauge") && $$.undoMarkOverlapped($$, "." + config_classes.gaugeValue)), $$.toggleFocusLegend(targetIds, !1), state.focusedTargetIds = state.focusedTargetIds.filter(function (id) {
      return targetIds.indexOf(id) < 0;
    }), state.defocusedTargetIds = targetIds;
  },

  /**
   * This API reverts specified targets.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be reverted.
   * @method revert
   * @instance
   * @memberof Chart
   * @param {String|Array} Target ids to be reverted
   * @example
   * // data1 will be reverted.
   * chart.revert("data1");
   *
   * // data1 and data2 will be reverted.
   * chart.revert(["data1", "data2"]);
   *
   * // all targets will be reverted.
   * chart.revert();
   */
  revert: function revert(targetIdsValue) {
    var $$ = this.internal,
        config = $$.config,
        state = $$.state,
        targetIds = $$.mapToTargetIds(targetIdsValue),
        candidates = $$.$el.svg.selectAll($$.selectorTargets(targetIds));
    // should be for all targets
    candidates.classed(config_classes.focused, !1).classed(config_classes.defocused, !1), $$.hasArcType() && $$.unexpandArc(targetIds), config.legend_show && ($$.showLegend(targetIds.filter($$.isLegendToShow.bind($$))), $$.$el.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.legendItemFocused);
    }).classed(config_classes.legendItemFocused, !1)), state.focusedTargetIds = [], state.defocusedTargetIds = [];
  }
});
// CONCATENATED MODULE: ./src/chart/api/grid.x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update x grid lines.
 * @method xgrids
 * @instance
 * @memberof Chart
 * @param {Array} grids X grid lines will be replaced with this argument. The format of this argument is the same as grid.x.lines.
 * @example
 *  // Show 2 x grid lines
 * chart.xgrids([
 *    {value: 1, text: "Label 1"},
 *    {value: 4, text: "Label 4"}
 * ]);
 */

function xgrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  return grids ? (config.grid_x_lines = grids, $$.redrawWithoutRescale(), config.grid_x_lines) : config.grid_x_lines;
}

extend(xgrids, {
  /**
   * Add x grid lines.<br>
   * This API adds new x grid lines instead of replacing like xgrids.
   * @method xgrids․add
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New x grid lines will be added. The format of this argument is the same as grid.x.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.xgrids.add(
   *   {value: 4, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.xgrids.add([
   *   {value: 2, text: "Label 2"},
   *   {value: 4, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.xgrids(this.internal.config.grid_x_lines.concat(grids || []));
  },

  /**
   * Remove x grid lines.<br>
   * This API removes x grid lines.
   * @method xgrids․remove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the x grid lines that have specified x value will be removed. If class is given, the x grid lines that have specified class will be removed. If args is not given, all of x grid lines will be removed.
   * @example
   * // x grid line on x = 2 will be removed
   * chart.xgrids.remove({value: 2});
   *
   * // x grid lines that have 'grid-A' will be removed
   * chart.xgrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of x grid lines will be removed
   * chart.xgrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !0);
  }
});
/* harmony default export */ var grid_x = ({
  xgrids: xgrids
});
// CONCATENATED MODULE: ./src/chart/api/grid.y.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Update y grid lines.
 * @method ygrids
 * @instance
 * @memberof Chart
 * @param {Array} grids Y grid lines will be replaced with this argument. The format of this argument is the same as grid.y.lines.
 * @example
 *  // Show 2 y grid lines
 * chart.ygrids([
 *    {value: 100, text: "Label 1"},
 *    {value: 400, text: "Label 4"}
 * ]);
 */

function ygrids(grids) {
  var $$ = this.internal,
      config = $$.config;
  if (!grids) return config.grid_y_lines;
  config.grid_y_lines = grids;

  http: //jindo.com/git/billboard.js/demo/work/chart.html
  $$.redrawWithoutRescale();

  return config.grid_y_lines;
}

extend(ygrids, {
  /**
   * Add y grid lines.<br>
   * This API adds new y grid lines instead of replacing like ygrids.
   * @method ygrids․add
   * @instance
   * @memberof Chart
   * @param {Array|Object} grids New y grid lines will be added. The format of this argument is the same as grid.y.lines and it's possible to give an Object if only one line will be added.
   * @example
   *  // Add a new x grid line
   * chart.ygrids.add(
   *   {value: 400, text: "Label 4"}
   * );
   *
   * // Add new x grid lines
   * chart.ygrids.add([
   *   {value: 200, text: "Label 2"},
   *   {value: 400, text: "Label 4"}
   * ]);
   */
  add: function add(grids) {
    return this.ygrids(this.internal.config.grid_y_lines.concat(grids || []));
  },

  /**
   * Remove y grid lines.<br>
   * This API removes x grid lines.
   * @method ygrids․remove
   * @instance
   * @memberof Chart
   * @param {Object} params This argument should include value or class. If value is given, the y grid lines that have specified y value will be removed. If class is given, the y grid lines that have specified class will be removed. If args is not given, all of y grid lines will be removed.
   * @example
   * // y grid line on y = 200 will be removed
   * chart.ygrids.remove({value: 200});
   *
   * // y grid lines that have 'grid-A' will be removed
   * chart.ygrids.remove({
   *   class: "grid-A"
   * });
   *
   * // all of y grid lines will be removed
   * chart.ygrids.remove();
   */
  remove: function remove(params) {
    // TODO: multiple
    this.internal.removeGridLines(params, !1);
  }
});
/* harmony default export */ var grid_y = ({
  ygrids: ygrids
});
// CONCATENATED MODULE: ./src/chart/api/group.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var group = ({
  /**
   * Update groups for the targets.
   * @method groups
   * @instance
   * @memberof Chart
   * @param {Array} groups This argument needs to be an Array that includes one or more Array that includes target ids to be grouped.
   * @return {Array} Grouped data names array
   * @example
   *  // data1 and data2 will be a new group.
   *  chart.groups([
   *     ["data1", "data2"]
   *  ]);
   */
  groups: function groups(_groups) {
    var $$ = this.internal,
        config = $$.config;
    return isUndefined(_groups) ? config.data_groups : (config.data_groups = _groups, $$.redraw(), config.data_groups);
  }
});
// CONCATENATED MODULE: ./src/chart/api/legend.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define legend
 * @ignore
 */
var legend_legend = {
  /**
   * Show legend for each target.
   * @method legend․show
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be shown.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be shown.
   * @example
   * // Show legend for data1.
   * chart.legend.show("data1");
   *
   * // Show legend for data1 and data2.
   * chart.legend.show(["data1", "data2"]);
   *
   * // Show all legend.
   * chart.legend.show();
   */
  show: function show(targetIds) {
    var $$ = this.internal;
    $$.showLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  },

  /**
   * Hide legend for each target.
   * @method legend․hide
   * @instance
   * @memberof Chart
   * @param {String|Array} targetIds
   * - If targetIds is given, specified target's legend will be hidden.
   * - If only one target is the candidate, String can be passed.
   * - If no argument is given, all of target's legend will be hidden.
   * @example
   * // Hide legend for data1.
   * chart.legend.hide("data1");
   *
   * // Hide legend for data1 and data2.
   * chart.legend.hide(["data1", "data2"]);
   *
   * // Hide all legend.
   * chart.legend.hide();
   */
  hide: function hide(targetIds) {
    var $$ = this.internal;
    $$.hideLegend($$.mapToTargetIds(targetIds)), $$.updateAndRedraw({
      withLegend: !0
    });
  }
};
/* harmony default export */ var api_legend = ({
  legend: legend_legend
});
// CONCATENATED MODULE: ./src/chart/api/load.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var load = ({
  /**
   * Load data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   *   - unload should be used if some data needs to be unloaded simultaneously.
   *     If you call unload API soon after/before load instead of unload param, chart will not be rendered properly because of cancel of animation.<br>
   *   - done will be called after data loaded, but it's not after rendering.
   *     It's because rendering will finish after some transition and there is some time lag between loading and rendering
   * @method load
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Description |
   *    | --- | --- |
   *    | - url<br>- json<br>- rows<br>- columns | The data will be loaded. If data that has the same target id is given, the chart will be updated. Otherwise, new target will be added |
   *    | data | Data objects to be loaded. Checkout the example. |
   *    | names | Same as data.names() |
   *    | xs | Same as data.xs option  |
   *    | classes | The classes specified by data.classes will be updated. classes must be Object that has target id as keys. |
   *    | categories | The categories specified by axis.x.categories or data.x will be updated. categories must be Array. |
   *    | axes | The axes specified by data.axes will be updated. axes must be Object that has target id as keys. |
   *    | colors | The colors specified by data.colors will be updated. colors must be Object that has target id as keys. |
   *    | headers |  Set request header if loading via `data.url`.<br>@see [data․headers](Options.html#.data%25E2%2580%25A4headers) |
   *    | keys |  Choose which JSON objects keys correspond to desired data.<br>**NOTE:** Only for JSON object given as array.<br>@see [data․keys](Options.html#.data%25E2%2580%25A4keys) |
   *    | mimeType |  Set 'json' if loading JSON via url.<br>@see [data․mimeType](Options.html#.data%25E2%2580%25A4mimeType) |
   *    | - type<br>- types | The type of targets will be updated. type must be String and types must be Object. |
   *    | unload | Specify the data will be unloaded before loading new data. If true given, all of data will be unloaded. If target ids given as String or Array, specified targets will be unloaded. If absent or false given, unload will not occur. |
   *    | done | The specified function will be called after data loaded.|
   * @see [Demo](https://naver.github.io/billboard.js/demo/#Data.DataFromURL)
   * @example
   * // Load data1 and unload data2 and data3
   * chart.load({
   *     columns: [
   *        ["data1", 100, 200, 150, ...],
   *        ...
   *    ],
   *    unload: ["data2", "data3"],
   *    url: "...",
   *    done: function() { ... }
   * });
   * @example
   * // myAPI.json
   * // {
   * //   "data1": [220, 240, 270, 250, 280],
   * //   "data2": [180, 150, 300, 70, 120]
   * // }
   *
   * chart.load({
   *     url: './data/myAPI.json',
   *     mimeType: "json",
   *
   *     // set request header if is needed
   *     headers: {
   *       "Content-Type": "text/json"
   *     }
   * });
   * @example
   * chart.load({
   *     data: [
   *       // equivalent as: columns: [["data1", 30, 200, 100]]
   *       {"data1": 30}, {"data1": 200}, {"data1": 100}
   *
   *       // or
   *       // equivalent as: columns: [["data1", 10, 20], ["data2", 13, 30]]
   *       // {"data1": 10, "data2": 13}, {"data1": 20, "data2": 30}}
   *     ]
   * });
   */
  load: function load(args) {
    var $$ = this.internal,
        config = $$.config;
    // update xs if specified
    // update names if exists
    // update classes if exists
    // update axes if exists
    // update colors if exists
    args.xs && $$.addXs(args.xs), "names" in args && this.data.names(args.names), "classes" in args && Object.keys(args.classes).forEach(function (id) {
      config.data_classes[id] = args.classes[id];
    }), "categories" in args && $$.isCategorized() && (config.axis_x_categories = args.categories), "axes" in args && Object.keys(args.axes).forEach(function (id) {
      config.data_axes[id] = args.axes[id];
    }), "colors" in args && Object.keys(args.colors).forEach(function (id) {
      config.data_colors[id] = args.colors[id];
    }), "unload" in args && args.unload !== !1 ? $$.unload($$.mapToTargetIds(args.unload === !0 ? null : args.unload), function () {
      return $$.loadFromArgs(args);
    }) : $$.loadFromArgs(args);
  },

  /**
   * Unload data to the chart.<br><br>
   * You can specify multiple targets by giving an array that includes id as String. If no argument is given, all of targets will be toggles.
   * - <b>Note:</b>
   * If you call load API soon after/before unload, unload param of load should be used. Otherwise chart will not be rendered properly because of cancel of animation.<br>
   * `done` will be called after data loaded, but it's not after rendering. It's because rendering will finish after some transition and there is some time lag between loading and rendering.
   * @method unload
   * @instance
   * @memberof Chart
   * @param {Object} args
   *  | key | Type | Description |
   *  | --- | --- | --- |
   *  | ids | String &vert; Array | Target id data to be unloaded. If not given, all data will be unloaded. |
   *  | done | Fuction | Callback after data is unloaded. |
   * @example
   *  // Unload data2 and data3
   *  chart.unload({
   *    ids: ["data2", "data3"],
   *    done: function() {
   *       // called after the unloaded
   *    }
   *  });
   */
  unload: function unload(argsValue) {
    var $$ = this.internal,
        args = argsValue || {};
    isArray(args) ? args = {
      ids: args
    } : isString(args) && (args = {
      ids: [args]
    });
    var ids = $$.mapToTargetIds(args.ids);
    $$.unload(ids, function () {
      $$.redraw({
        withUpdateOrgXDomain: !0,
        withUpdateXDomain: !0,
        withLegend: !0
      }), $$.cache.remove(ids), args.done && args.done();
    });
  }
});
// CONCATENATED MODULE: ./src/chart/api/regions.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */


/**
 * Update regions.
 * @method regions
 * @instance
 * @memberof Chart
 * @param {Array} regions Regions will be replaced with this argument. The format of this argument is the same as regions.
 * @return {Array} regions
 * @example
 * // Show 2 regions
 * chart.regions([
 *    {axis: "x", start: 5, class: "regionX"},
 *    {axis: "y", end: 50, class: "regionY"}
 * ]);
 */

function regions_regions(regions) {
  var $$ = this.internal,
      config = $$.config;
  return regions ? (config.regions = regions, $$.redrawWithoutRescale(), regions) : config.regions;
}

extend(regions_regions, {
  /**
   * Add new region.<br><br>
   * This API adds new region instead of replacing like regions.
   * @method regions․add
   * @instance
   * @memberof Chart
   * @param {Array|Object} regions New region will be added. The format of this argument is the same as regions and it's possible to give an Object if only one region will be added.
   * @return {Array} regions
   * @example
   * // Add a new region
   * chart.regions.add(
   *    {axis: "x", start: 5, class: "regionX"}
   * );
   *
   * // Add new regions
   * chart.regions.add([
   *    {axis: "x", start: 5, class: "regionX"},
   *    {axis: "y", end: 50, class: "regionY"}
   *]);
   */
  add: function add(regions) {
    var $$ = this.internal,
        config = $$.config;
    return regions ? (config.regions = config.regions.concat(regions), $$.redrawWithoutRescale(), config.regions) : config.regions;
  },

  /**
   * Remove regions.<br><br>
   * This API removes regions.
   * @method regions․remove
   * @instance
   * @memberof Chart
   * @param {Object} regions This argument should include classes. If classes is given, the regions that have one of the specified classes will be removed. If args is not given, all of regions will be removed.
   * @return {Array} regions Removed regions
   * @example
   * // regions that have 'region-A' or 'region-B' will be removed.
   * chart.regions.remove({
   *   classes: [
   *     "region-A", "region-B"
   *   ]
   * });
   *
   * // all of regions will be removed.
   * chart.regions.remove();
   */
  remove: function remove(optionsValue) {
    var $$ = this.internal,
        config = $$.config,
        options = optionsValue || {},
        duration = getOption(options, "duration", config.transition_duration),
        classes = getOption(options, "classes", [config_classes.region]),
        regions = $$.$el.main.select("." + config_classes.regions).selectAll(classes.map(function (c) {
      return "." + c;
    }));
    return (duration ? regions.transition().duration(duration) : regions).style("opacity", "0").remove(), regions = config.regions, Object.keys(options).length ? (regions = regions.filter(function (region) {
      var found = !1;
      return !region.class || (region.class.split(" ").forEach(function (c) {
        classes.indexOf(c) >= 0 && (found = !0);
      }), !found);
    }), config.regions = regions) : config.regions = [], regions;
  }
});
/* harmony default export */ var api_regions = ({
  regions: regions_regions
});
// CONCATENATED MODULE: ./src/chart/api/selection.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/* harmony default export */ var api_selection = ({
  /**
   * Get selected data points.<br><br>
   * By this API, you can get selected data points information. To use this API, data.selection.enabled needs to be set true.
   * @method selected
   * @instance
   * @memberof Chart
   * @param {String} [targetId] You can filter the result by giving target id that you want to get. If not given, all of data points will be returned.
   * @return {Array} dataPoint Array of the data points.<br>ex.) `[{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ...]`
   * @example
   *  // all selected data points will be returned.
   *  chart.selected();
   *  // --> ex.) [{x: 1, value: 200, id: "data1", index: 1, name: "data1"}, ... ]
   *
   *  // all selected data points of data1 will be returned.
   *  chart.selected("data1");
   */
  selected: function selected(targetId) {
    var $$ = this.internal,
        dataPoint = [];
    return $$.$el.main.selectAll("." + (config_classes.shapes + $$.getTargetSelectorSuffix(targetId))).selectAll("." + config_classes.shape).filter(function () {
      return Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this).classed(config_classes.SELECTED);
    }).each(function (d) {
      return dataPoint.push(d);
    }), dataPoint;
  },

  /**
   * Set data points to be selected. (`[data.selection.enabled](Options.html#.data%25E2%2580%25A4selection%25E2%2580%25A4enabled) option should be set true to use this method)`
   * @method select
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to get selected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @param {Boolean} [resetOther] Unselect already selected.
   * @example
   *  // select all data points
   *  chart.select();
   *
   *  // select all from 'data2'
   *  chart.select("data2");
   *
   *  // select all from 'data1' and 'data2'
   *  chart.select(["data1", "data2"]);
   *
   *  // select from 'data1', indices 2 and unselect others selected
   *  chart.select("data1", [2], true);
   *
   *  // select from 'data1', indices 0, 3 and 5
   *  chart.select("data1", [0, 3, 5]);
   */
  select: function select(ids, indices, resetOther) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.$el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || (isTargetId && isTargetIndex ? config.data_selection_isselectable(d) && !isSelected && toggle(!0, shape.classed(config_classes.SELECTED, !0), d, i) : isDefined(resetOther) && resetOther && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i));
    });
  },

  /**
   * Set data points to be un-selected.
   * @method unselect
   * @instance
   * @memberof Chart
   * @param {String|Array} [ids] id value to be unselected.
   * @param {Array} [indices] The index array of data points. If falsy value given, will select all data points.
   * @example
   *  // unselect all data points
   *  chart.unselect();
   *
   *  // unselect all from 'data1'
   *  chart.unselect("data1");
   *
   *  // unselect from 'data1', indices 2
   *  chart.unselect("data1", [2]);
   */
  unselect: function unselect(ids, indices) {
    var $$ = this.internal,
        config = $$.config;
    config.data_selection_enabled && $$.$el.main.selectAll("." + config_classes.shapes).selectAll("." + config_classes.shape).each(function (d, i) {
      var shape = Object(external_commonjs_d3_selection_commonjs2_d3_selection_amd_d3_selection_root_d3_["select"])(this),
          id = d.data ? d.data.id : d.id,
          toggle = $$.getToggle(this, d).bind($$),
          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,
          isTargetIndex = !indices || indices.indexOf(i) >= 0,
          isSelected = shape.classed(config_classes.SELECTED);
      // line/area selection not supported yet
      shape.classed(config_classes.line) || shape.classed(config_classes.area) || isTargetId && isTargetIndex && config.data_selection_isselectable(d) && isSelected && toggle(!1, shape.classed(config_classes.SELECTED, !1), d, i);
    });
  }
});
// CONCATENATED MODULE: ./src/chart/api/show.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Show/Hide data series
 * @private
 */
function showHide(show, targetIdsValue, options) {
  var $$ = this.internal,
      targetIds = $$.mapToTargetIds(targetIdsValue);
  $$[(show ? "remove" : "add") + "HiddenTargetIds"](targetIds);
  var targets = $$.$el.svg.selectAll($$.selectorTargets(targetIds)),
      opacity = show ? "1" : "0";
  targets.transition().style("opacity", opacity, "important").call($$.endall, function () {
    targets.style("opacity", null).style("opacity", opacity);
  }), options.withLegend && $$[(show ? "show" : "hide") + "Legend"](targetIds), $$.redraw({
    withUpdateOrgXDomain: !0,
    withUpdateXDomain: !0,
    withLegend: !0
  });
}

/* harmony default export */ var api_show = ({
  /**
   * Show data series on chart
   * @method show
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // show 'data1'
   * chart.show("data1");
   *
   * // show 'data1' and 'data3'
   * chart.show(["data1", "data3"]);
   */
  show: function show(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !0, targetIdsValue, options);
  },

  /**
   * Hide data series from chart
   * @method hide
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // hide 'data1'
   * chart.hide("data1");
   *
   * // hide 'data1' and 'data3'
   * chart.hide(["data1", "data3"]);
   */
  hide: function hide(targetIdsValue, options) {
    options === void 0 && (options = {}), showHide.call(this, !1, targetIdsValue, options);
  },

  /**
   * Toggle data series on chart. When target data is hidden, it will show. If is shown, it will hide in vice versa.
   * @method toggle
   * @instance
   * @memberof Chart
   * @param {String|Array} [targetIdsValue=all] The target id value.
   * @param {Object} [options] The object can consist with following members:<br>
   *
   *    | Key | Type | default | Description |
   *    | --- | --- | --- | --- |
   *    | withLegend | Boolean | false | whether or not display legend |
   *
   * @example
   * // toggle 'data1'
   * chart.toggle("data1");
   *
   * // toggle 'data1' and 'data3'
   * chart.toggle(["data1", "data3"]);
   */
  toggle: function toggle(targetIds, options) {
    var _this = this;

    options === void 0 && (options = {});
    var $$ = this.internal,
        targets = {
      show: [],
      hide: []
    };
    // sort show & hide target ids
    // perform show & hide task separately
    // https://github.com/naver/billboard.js/issues/454
    $$.mapToTargetIds(targetIds).forEach(function (id) {
      return targets[$$.isTargetToShow(id) ? "hide" : "show"].push(id);
    }), targets.show.length && this.show(targets.show, options), targets.hide.length && setTimeout(function () {
      return _this.hide(targets.hide, options);
    }, 0);
  }
});
// CONCATENATED MODULE: ./src/chart/api/tooltip.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/**
 * Define tooltip
 * @ignore
 */

var tooltip_tooltip = {
  /**
   * Show tooltip
   * @method tooltip․show
   * @instance
   * @memberof Chart
   * @param {Object} args The object can consist with following members:<br>
   *
   *    | Key | Type | Description |
   *    | --- | --- | --- |
   *    | index | Number | Determine focus by index |
   *    | x | Number &vert; Date | Determine focus by x Axis index |
   *    | mouse | Array | Determine x and y coordinate value relative the targeted '.bb-event-rect' x Axis.<br>It should be used along with `data`, `index` or `x` value. The default value is set as `[0,0]` |
   *    | data | Object | When [data.xs](Options.html#.data%25E2%2580%25A4xs) option is used or [tooltip.grouped](Options.html#.tooltip) set to 'false', `should be used giving this param`.<br><br>**Key:**<br>- x {Number &verbar; Date}: x Axis value<br>- index {Number}: x Axis index (useless for data.xs)<br>- id {String}: data id<br>- value {Number}: The corresponding value for tooltip. |
   *
   * @example
   *  // show the 2nd x Axis coordinate tooltip
   *  chart.tooltip.show({
   *    index: 1
   *  });
   *
   *  // show tooltip for the 3rd x Axis in x:50 and y:100 coordinate of '.bb-event-rect' of the x Axis.
   *  chart.tooltip.show({
   *    x: 2,
   *    mouse: [50, 100]
   *  });
   *
   *  // show tooltip for timeseries x axis
   *  chart.tooltip.show({
   *    x: new Date("2018-01-02 00:00")
   *  });
   *
   *  // when data.xs is used
   *  chart.tooltip.show({
   *    data: {
   *        x: 3,  // x Axis value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   *
   *  // when data.xs isn't used, but tooltip.grouped=false is set
   *  chart.tooltip.show({
   *    data: {
   *        index: 3,  // or 'x' key value
   *        id: "data1",  // data id
   *        value: 500  // data value
   *    }
   *  });
   */
  show: function show(args) {
    var index,
        mouse,
        $$ = this.internal,
        config = $$.config,
        inputType = $$.state.inputType;

    // determine focus data
    if (args.mouse && (mouse = args.mouse), args.data) {
      var y = $$.getYScale(args.data.id)(args.data.value);
      $$.isMultipleX() ? mouse = [$$.scale.x(args.data.x), y] : (!config.tooltip_grouped && (mouse = [0, y]), index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x));
    } else isDefined(args.x) ? index = $$.getIndexByX(args.x) : isDefined(args.index) && (index = args.index); // emulate events to show


    (inputType === "mouse" ? ["mouseover", "mousemove"] : ["touchstart"]).forEach(function (eventName) {
      $$.dispatchEvent(eventName, index, mouse);
    });
  },

  /**
   * Hide tooltip
   * @method tooltip․hide
   * @instance
   * @memberof Chart
   */
  hide: function hide() {
    var $$ = this.internal;
    $$.hideTooltip(!0), $$.hideGridFocus(), $$.unexpandCircles(), $$.unexpandBars();
  }
};
/* harmony default export */ var api_tooltip = ({
  tooltip: tooltip_tooltip
});
// CONCATENATED MODULE: ./src/chart/api/x.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */

/* harmony default export */ var api_x = ({
  /**
   * Get and set x values for the chart.
   * @method x
   * @instance
   * @memberof Chart
   * @param {Array} x If x is given, x values of every target will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.x();
   *
   *  // Update x values for all targets
   *  chart.x([100, 200, 300, 400, ...]);
   */
  x: function x(_x) {
    var $$ = this.internal,
        isCategorized = $$.isCustomX() && $$.isCategorized();
    return isArray(_x) && (isCategorized ? this.categories(_x) : ($$.updateTargetX($$.data.targets, _x), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    }))), isCategorized ? this.categories() : $$.data.xs;
  },

  /**
   * Get and set x values for the chart.
   * @method xs
   * @instance
   * @memberof Chart
   * @param {Array} xs If xs is given, specified target's x values will be updated. If no argument is given, current x values will be returned as an Object whose keys are the target ids.
   * @return {Object} xs
   * @example
   *  // Get current x values
   *  chart.xs();
   *
   *  // Update x values for all targets
   *  chart.xs({
   *    data1: [10, 20, 30, 40, ...],
   *    data2: [100, 200, 300, 400, ...]
   *  });
   */
  xs: function xs(_xs) {
    var $$ = this.internal;
    return isObject(_xs) && ($$.updateTargetXs($$.data.targets, _xs), $$.redraw({
      withUpdateOrgXDomain: !0,
      withUpdateXDomain: !0
    })), $$.data.xs;
  }
});
// CONCATENATED MODULE: ./src/chart/api/zoom.ts
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */



/**
 * Check if the given domain is within zoom range
 * @param {Array} domain
 * @return {Boolean}
 * @private
 */

function withinRange(domain, range) {
  var min = range[0],
      max = range[1];
  return domain.every(function (v, i) {
    return i === 0 ? v >= min : v <= max;
  });
}

/**
 * Zoom by giving x domain.
 * - **NOTE:**
 *  - For `wheel` type zoom, the minimum zoom range will be set as the given domain. To get the initial state, [.unzoom()](#unzoom) should be called.
 *  - To be used [zoom.enabled](Options.html#.zoom) option should be set as `truthy`.
 * @method zoom
 * @instance
 * @memberof Chart
 * @param {Array} domainValue If domain is given, the chart will be zoomed to the given domain. If no argument is given, the current zoomed domain will be returned.
 * @return {Array} domain value in array
 * @example
 *  // Zoom to specified domain
 *  chart.zoom([10, 20]);
 *
 *  // Get the current zoomed domain
 *  chart.zoom();
 */
var zoom_zoom = function (domainValue) {
  var resultDomain,
      $$ = this.internal,
      config = $$.config,
      scale = $$.scale,
      domain = domainValue;

  if (config.zoom_enabled && domain && withinRange(domain, $$.getZoomDomain())) {
    var isTimeSeries = $$.isTimeSeries();

    if (isTimeSeries && (domain = domain.map(function (x) {
      return $$.parseDate(x);
    })), config.subchart_show) {
      var xScale = scale.zoom || scale.x;
      $$.brush.getSelection().call($$.brush.move, [xScale(domain[0]), xScale(domain[1])]), resultDomain = domain;
    } else scale.x.domain(domain), scale.zoom = scale.x, $$.axis.x.scale(scale.zoom), resultDomain = scale.zoom.orgDomain();

    $$.redraw({
      withTransition: !0,
      withY: config.zoom_rescale,
      withDimension: !1
    }), $$.setZoomResetButton(), callFn(config.zoom_onzoom, this, resultDomain);
  } else resultDomain = scale.zoom ? scale.zoom.domain() : scale.x.orgDomain();

  return resultDomain;
};

extend(zoom_zoom, {
  /**
   * Enable and disable zooming.
   * @method zoom․enable
   * @instance
   * @memberof Chart
   * @param {String|Boolean} enabled Possible string values are "wheel" or "drag". If enabled is true, "wheel" will be used. If false is given, zooming will be disabled.<br>When set to false, the current zooming status will be reset.
   * @example
   *  // Enable zooming using the mouse wheel
   *  chart.zoom.enable(true);
   *  // Or
   *  chart.zoom.enable("wheel");
   *
   *  // Enable zooming by dragging
   *  chart.zoom.enable("drag");
   *
   *  // Disable zooming
   *  chart.zoom.enable(false);
   */
  enable: function enable(enabled) {
    var $$ = this.internal,
        config = $$.config,
        enableType = enabled;
    enabled && (enableType = isString(enabled) && /^(drag|wheel)$/.test(enabled) ? {
      type: enabled
    } : enabled), config.zoom_enabled = enableType, $$.zoom ? enabled === !1 && $$.bindZoomEvent(!1) : ($$.initZoom(), $$.bindZoomEvent()), $$.updateAndRedraw();
  },

  /**
   * Set or get x Axis maximum zoom range value
   * @method zoom․max
   * @instance
   * @memberof Chart
   * @param {Number} [max] maximum value to set for zoom
   * @return {Number} zoom max value
   * @example
   *  // Set maximum range value
   *  chart.zoom.max(20);
   */
  max: function max(_max) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_max === 0 || _max) && (config.zoom_x_max = getMinMax("max", [xDomain[1], _max])), config.zoom_x_max;
  },

  /**
   * Set or get x Axis minimum zoom range value
   * @method zoom․min
   * @instance
   * @memberof Chart
   * @param {Number} [min] minimum value to set for zoom
   * @return {Number} zoom min value
   * @example
   *  // Set minimum range value
   *  chart.zoom.min(-1);
   */
  min: function min(_min) {
    var $$ = this.internal,
        config = $$.config,
        xDomain = $$.org.xDomain;
    return (_min === 0 || _min) && (config.zoom_x_min = getMinMax("min", [xDomain[0], _min])), config.zoom_x_min;
  },

  /**
   * Set zoom range
   * @method zoom․range
   * @instance
   * @memberof Chart
   * @param {Object} [range]
   * @return {Object} zoom range value
   * {
   *   min: 0,
   *   max: 100
   * }
   * @example
   *  chart.zoom.range({
   *      min: 10,
   *      max: 100
   *  });
   */
  range: function range(_range) {
    var zoom = this.zoom;

    if (isObject(_range)) {
      var min = _range.min,
          max = _range.max;
      isDefined(min) && zoom.min(min), isDefined(max) && zoom.max(max);
    }

    return {
      min: zoom.min(),
      max: zoom.max()
    };
  }
});
/* harmony default export */ var api_zoom = ({
  zoom: zoom_zoom,

  /**
   * Unzoom zoomed area
   * @method unzoom
   * @instance
   * @memberof Chart
   * @example
   *  chart.unzoom();
   */
  unzoom: function unzoom() {
    var $$ = this.internal,
        config = $$.config;

    if ($$.scale.zoom) {
      config.subchart_show ? $$.brush.getSelection().call($$.brush.move, null) : $$.zoom.updateTransformScale(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.updateZoom(!0), $$.zoom.resetBtn && $$.zoom.resetBtn.style("display", "none");
      // reset transform
      var eventRects = $$.$el.main.select("." + config_classes.eventRects);
      Object(external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomTransform"])(eventRects.node()) !== external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"] && $$.zoom.transform(eventRects, external_commonjs_d3_zoom_commonjs2_d3_zoom_amd_d3_zoom_root_d3_["zoomIdentity"]), $$.redraw({
        withTransition: !0,
        withUpdateXDomain: !0,
        withUpdateOrgXDomain: !0,
        withY: config.zoom_rescale
      });
    }
  }
});
// CONCATENATED MODULE: ./src/chart/Chart.ts


/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard.js project is licensed under the MIT license
 */






















/**
 * Main chart class.
 * - Note: Instantiated via `bb.generate()`.
 * @class Chart
 * @example
 * var chart = bb.generate({
 *  data: {
 *    columns: [
 *	    ["x", "2015-11-02", "2015-12-01", "2016-01-01", "2016-02-01", "2016-03-01"],
 * 	    ["count1", 11, 8, 7, 6, 5 ],
 *	    ["count2", 9, 3, 6, 2, 8 ]
 *   ]}
 * }
 * @see {@link bb.generate} for the initialization.
*/

/**
 * Access instance's primary node elements
 * @member {Object} $
 * @property {Object} $
 * @property {d3.selection} $.chart Wrapper element
 * @property {d3.selection} $.svg Main svg element
 * @property {d3.selection} $.defs Definition element
 * @property {d3.selection} $.main Main grouping element
 * @property {d3.selection} $.tooltip Tooltip element
 * @property {d3.selection} $.legend Legend element
 * @property {d3.selection} $.title Title element
 * @property {d3.selection} $.grid Grid element
 * @property {d3.selection} $.arc Arc element
 * @property {Object} $.bar
 * @property {d3.selection} $.bar.bars Bar elements
 * @property {Object} $.line
 * @property {d3.selection} $.line.lines Line elements
 * @property {d3.selection} $.line.areas Areas elements
 * @property {d3.selection} $.line.circles Data point circle elements
 * @property {Object} $.text
 * @property {d3.selection} $.text.texts Data label text elements
 * @memberof Chart
 * @example
 * var chart = bb.generate({ ... });
 *
 * chart.$.chart; // wrapper element
 * chart.$.line.circles;  // all data point circle elements
 */

var Chart_Chart =
/**
 * Plugin instance array
 * @member {Array} plugins
 * @memberof Chart
 * @instance
 * @example
 *  var chart = bb.generate({
 *     ...
 *     plugins: [
 *        new bb.plugin.stanford({ ... }),
 *        new PluginA()
 *     ]
 *  });
 *
 *  chart.plugins; // [Stanford, PluginA] - instance array
 */
function Chart(options) {
  _defineProperty(this, "plugins", []), _defineProperty(this, "internal", void 0);
  var ctx = this,
      $$ = new ChartInternal_ChartInternal(ctx);
  this.internal = $$, bindThis(Chart.prototype, this, this), loadConfig.call($$, options), $$.beforeInit(), $$.init(), $$.afterInit();
}; // bind to namespaced APIs




function bindThis(fn, target, argThis) {
  Object.keys(fn).forEach(function (key) {
    var isFunc = isFunction(fn[key]),
        isChild = target !== argThis,
        hasChild = Object.keys(fn[key]).length > 0;
    isFunc && (!isChild && hasChild || isChild) ? target[key] = fn[key].bind(argThis) : !isFunc && (target[key] = {}), hasChild && bindThis(fn[key], target[key], argThis);
  });
}

// extend API as part of Chart class
extend(Chart_Chart.prototype, [api_axis, api_category, api_chart, api_color, api_data, api_export, api_flow, api_focus, grid_x, grid_y, group, api_legend, load, api_regions, api_selection, api_show, api_tooltip, api_x, api_zoom]);
// CONCATENATED MODULE: ./src/index.ts
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bb", function() { return bb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return bb; });
/**
 * Copyright (c) 2017 ~ present NAVER Corp.
 * billboard project is licensed under the MIT license
 */



var _defaults = {},
    bb = {
  /**
   * Version information
   * @property {String} version version
   * @example
   *    bb.version;  // "1.0.0"
   * @memberof bb
   */
  version: "2.0.0-alpha",

  /**
   * Generate chart
   * @param {Options} options chart options
   * @memberof bb
   * @return {Chart}
   * @see {@link Options} for different generation options
   * @see {@link Chart} for different methods API
   * @example
   *  <!-- chart holder -->
   * <div id="LineChart"></div>
   * @example
   *   // generate chart with options
   *  var chart = bb.generate({
   *      "bindto": "#LineChart"
   *      "data": {
   *          "columns": [
   *              ["data1", 30, 200, 100, 400, 150, 250],
   *              ["data2", 50, 20, 10, 40, 15, 25]
   *           ]
   *      }
   *  });
   *
   *  // call some API
   *  // ex) get the data of 'data1'
   *  chart.data("data1");
   */
  generate: function generate(config) {
    var options = mergeObj({}, _defaults, config),
        inst = new Chart_Chart(options);
    return inst.internal.charts = this.instance, this.instance.push(inst), inst;
  },

  /**
   * Set or get global default options.
   * - **NOTE:**
   *   - The options values settings are valid within page context only.
   *   - If is called multiple times, will override the last value.
   * @param {Options} options chart options
   * @memberof bb
   * @return {Options}
   * @see {@link Options}
   * @example
   * // Set same option value as for `.generate()`
   * bb.defaults({
   *   data: {
   *     type: "bar"
   *   }
   * });
   *
   * bb.defaults();  // {data:{type: "bar"}}
   *
   * // data.type defaults to 'bar'
   * var chart = bb.generate({ ... });
   */
  defaults: function defaults(options) {
    return isObject(options) && (_defaults = options), _defaults;
  },

  /**
   * An array containing instance created
   * @property {Array} instance instance array
   * @example
   *  // generate charts
   *  var chart1 = bb.generate(...);
   *  var chart2 = bb.generate(...);
   *
   *  bb.instance;  // [ chart1, chart2, ... ]
   * @memberof bb
   */
  instance: [],

  /**
   * Namespace for plugins
   * @property {Object} plugin plugin namespace
   * @example
   *  // Stanford diagram plugin
   *  bb.plugin.stanford;
   * @memberof bb
   */
  plugin: {}
};
/**
 * @namespace bb
 * @version 2.0.0-alpha
 */

/***/ })
/******/ ]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLXJlZ2V4L2luZGV4LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvc29ja2V0LmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvY2xpZW50cy9Tb2NrSlNDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NvY2tqcy1jbGllbnQvZGlzdC9zb2NranMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9jbGllbnRzL0Jhc2VDbGllbnQuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC9vdmVybGF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hbnNpLWh0bWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL3htbC1lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHRtbC1lbnRpdGllcy9saWIvaHRtbDQtZW50aXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2h0bWwtZW50aXRpZXMvbGliL2h0bWw1LWVudGl0aWVzLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvbG9nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9zZW5kTWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spLWRldi1zZXJ2ZXIvY2xpZW50L3V0aWxzL3JlbG9hZEFwcC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2hvdC9lbWl0dGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwid2VicGFjazovLy8od2VicGFjayktZGV2LXNlcnZlci9jbGllbnQvdXRpbHMvY3JlYXRlU29ja2V0VXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZGVjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS1kZXYtc2VydmVyL2NsaWVudC91dGlscy9nZXRDdXJyZW50U2NyaXB0U291cmNlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvaG90IHN5bmMgbm9ucmVjdXJzaXZlIF5cXC5cXC9sb2ckIiwid2VicGFjazovLy8od2VicGFjaykvaG90L2xvZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2Nzcz8xYjVkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvc2Nzcy9iaWxsYm9hcmQuc2NzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdGltZS1mb3JtYXRcIixcImNvbW1vbmpzMlwiOlwiZDMtdGltZS1mb3JtYXRcIixcImFtZFwiOlwiZDMtdGltZS1mb3JtYXRcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2VsZWN0aW9uXCIsXCJjb21tb25qczJcIjpcImQzLXNlbGVjdGlvblwiLFwiYW1kXCI6XCJkMy1zZWxlY3Rpb25cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtdHJhbnNpdGlvblwiLFwiY29tbW9uanMyXCI6XCJkMy10cmFuc2l0aW9uXCIsXCJhbWRcIjpcImQzLXRyYW5zaXRpb25cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYnJ1c2hcIixcImNvbW1vbmpzMlwiOlwiZDMtYnJ1c2hcIixcImFtZFwiOlwiZDMtYnJ1c2hcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtYXhpc1wiLFwiY29tbW9uanMyXCI6XCJkMy1heGlzXCIsXCJhbWRcIjpcImQzLWF4aXNcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2NhbGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2NhbGVcIixcImFtZFwiOlwiZDMtc2NhbGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHN2XCIsXCJjb21tb25qczJcIjpcImQzLWRzdlwiLFwiYW1kXCI6XCJkMy1kc3ZcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZWFzZVwiLFwiY29tbW9uanMyXCI6XCJkMy1lYXNlXCIsXCJhbWRcIjpcImQzLWVhc2VcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtZHJhZ1wiLFwiY29tbW9uanMyXCI6XCJkMy1kcmFnXCIsXCJhbWRcIjpcImQzLWRyYWdcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtem9vbVwiLFwiY29tbW9uanMyXCI6XCJkMy16b29tXCIsXCJhbWRcIjpcImQzLXpvb21cIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtY29sb3JcIixcImNvbW1vbmpzMlwiOlwiZDMtY29sb3JcIixcImFtZFwiOlwiZDMtY29sb3JcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtc2hhcGVcIixcImNvbW1vbmpzMlwiOlwiZDMtc2hhcGVcIixcImFtZFwiOlwiZDMtc2hhcGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy9leHRlcm5hbCB7XCJjb21tb25qc1wiOlwiZDMtaW50ZXJwb2xhdGVcIixcImNvbW1vbmpzMlwiOlwiZDMtaW50ZXJwb2xhdGVcIixcImFtZFwiOlwiZDMtaW50ZXJwb2xhdGVcIixcInJvb3RcIjpcImQzXCJ9Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NsYXNzZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9TdG9yZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvZGF0YS9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZS9icm93c2VyLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvdXRpbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvZGF0YS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9heGlzL3gudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2F4aXMveS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy95Mi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvYXhpcy9heGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9ncmlkLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vaW50ZXJhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9sZWdlbmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi9wb2ludC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvY29tbW9uL3N1YmNoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vdGl0bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL2NvbW1vbi90b29sdGlwLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9jb21tb24vem9vbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvYXJlYS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvYmFyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9idWJibGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZy9PcHRpb25zL3NoYXBlL2RvbnV0LnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9nYXVnZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvbGluZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvcGllLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9zaGFwZS9yYWRhci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL09wdGlvbnMvc2hhcGUvc3BsaW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9jb25maWcvT3B0aW9ucy9PcHRpb25zLnRzIiwid2VicGFjazovLy8uL3NyYy9tb2R1bGUvQ2FjaGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzUmVuZGVyZXJIZWxwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzUmVuZGVyZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQXhpcy9BeGlzLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvZGF0YS5jb252ZXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2RhdGEvZGF0YS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9kYXRhL2RhdGEubG9hZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZHJhZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvZmxvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcmFjdGlvbnMvaW50ZXJhY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJhY3Rpb25zL3N1YmNoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVyYWN0aW9ucy96b29tLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvY2xhc3MudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NsaXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2NvbG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9kb21haW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL2Zvcm1hdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvZ3JpZC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9pbnRlcm5hbHMvbGVnZW5kLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9yZWdpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3NjYWxlLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy9zZWxlY3Rpb24udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3NpemUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3RleHQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvaW50ZXJuYWxzL3RpdGxlLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy90b29sdGlwLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL2ludGVybmFscy90eXBlLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL2FyYy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvQ2hhcnRJbnRlcm5hbC9zaGFwZS9iYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvYnViYmxlLnRzIiwid2VicGFjazovLy8uL3NyYy9DaGFydEludGVybmFsL3NoYXBlL2xpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcG9pbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvcmFkYXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvc2hhcGUvc2hhcGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL0NoYXJ0SW50ZXJuYWwvQ2hhcnRJbnRlcm5hbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnL2NvbmZpZy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL2F4aXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS9jYXRlZ29yeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL2NoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvY29sb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS9kYXRhLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvZXhwb3J0LnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvZmxvdy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL2ZvY3VzLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvZ3JpZC54LnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvZ3JpZC55LnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvZ3JvdXAudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS9sZWdlbmQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS9sb2FkLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkvcmVnaW9ucy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL3NlbGVjdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL3Nob3cudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L2FwaS90b29sdGlwLnRzIiwid2VicGFjazovLy8uL3NyYy9jaGFydC9hcGkveC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY2hhcnQvYXBpL3pvb20udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NoYXJ0L0NoYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6WyJhcmMiLCJhcmNMYWJlbExpbmUiLCJhcmNzIiwiYXJlYSIsImFyZWFzIiwiYXhpcyIsImF4aXNYIiwiYXhpc1hMYWJlbCIsImF4aXNZIiwiYXhpc1kyIiwiYXhpc1kyTGFiZWwiLCJheGlzWUxhYmVsIiwiYmFyIiwiYmFycyIsImJydXNoIiwiYnV0dG9uIiwiYnV0dG9uWm9vbVJlc2V0IiwiY2hhcnQiLCJjaGFydEFyYyIsImNoYXJ0QXJjcyIsImNoYXJ0QXJjc0JhY2tncm91bmQiLCJjaGFydEFyY3NHYXVnZU1heCIsImNoYXJ0QXJjc0dhdWdlTWluIiwiY2hhcnRBcmNzR2F1Z2VVbml0IiwiY2hhcnRBcmNzVGl0bGUiLCJjaGFydEFyY3NHYXVnZVRpdGxlIiwiY2hhcnRCYXIiLCJjaGFydEJhcnMiLCJjaGFydExpbmUiLCJjaGFydExpbmVzIiwiY2hhcnRSYWRhciIsImNoYXJ0UmFkYXJzIiwiY2hhcnRUZXh0IiwiY2hhcnRUZXh0cyIsImNpcmNsZSIsImNpcmNsZXMiLCJjb2xvclBhdHRlcm4iLCJjb2xvclNjYWxlIiwiZGVmb2N1c2VkIiwiZHJhZ2FyZWEiLCJlbXB0eSIsImV2ZW50UmVjdCIsImV2ZW50UmVjdHMiLCJldmVudFJlY3RzTXVsdGlwbGUiLCJldmVudFJlY3RzU2luZ2xlIiwiZm9jdXNlZCIsImdhdWdlVmFsdWUiLCJncmlkIiwiZ3JpZExpbmVzIiwibGVnZW5kQmFja2dyb3VuZCIsImxlZ2VuZEl0ZW0iLCJsZWdlbmRJdGVtRXZlbnQiLCJsZWdlbmRJdGVtRm9jdXNlZCIsImxlZ2VuZEl0ZW1IaWRkZW4iLCJsZWdlbmRJdGVtUG9pbnQiLCJsZWdlbmRJdGVtVGlsZSIsImxldmVsIiwibGV2ZWxzIiwibGluZSIsImxpbmVzIiwicmVnaW9uIiwicmVnaW9ucyIsInNlbGVjdGVkQ2lyY2xlIiwic2VsZWN0ZWRDaXJjbGVzIiwic2hhcGUiLCJzaGFwZXMiLCJzdGFuZm9yZEVsZW1lbnRzIiwic3RhbmZvcmRMaW5lIiwic3RhbmZvcmRMaW5lcyIsInN0YW5mb3JkUmVnaW9uIiwic3RhbmZvcmRSZWdpb25zIiwidGFyZ2V0IiwidGV4dCIsInRleHRzIiwidGl0bGUiLCJ0b29sdGlwIiwidG9vbHRpcENvbnRhaW5lciIsInRvb2x0aXBOYW1lIiwieGdyaWQiLCJ4Z3JpZEZvY3VzIiwieGdyaWRMaW5lIiwieGdyaWRMaW5lcyIsInhncmlkcyIsInlncmlkIiwieWdyaWRGb2N1cyIsInlncmlkTGluZSIsInlncmlkTGluZXMiLCJ5Z3JpZHMiLCJ6b29tQnJ1c2giLCJ6b29tUmVjdCIsIkVYUEFOREVEIiwiU0VMRUNURUQiLCJJTkNMVURFRCIsIlRleHRPdmVybGFwcGluZyIsInN0YXRlIiwid2lkdGgiLCJ3aWR0aDIiLCJoZWlnaHQiLCJoZWlnaHQyIiwibWFyZ2luIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwibWFyZ2luMiIsIm1hcmdpbjMiLCJhcmNXaWR0aCIsImFyY0hlaWdodCIsImN1cnJlbnRXaWR0aCIsImN1cnJlbnRIZWlnaHQiLCJpc0xlZ2VuZFJpZ2h0IiwiaXNMZWdlbmRJbnNldCIsImlzTGVnZW5kVG9wIiwiaXNMZWdlbmRMZWZ0IiwibGVnZW5kU3RlcCIsImxlZ2VuZEl0ZW1XaWR0aCIsImxlZ2VuZEl0ZW1IZWlnaHQiLCJsZWdlbmRIYXNSZW5kZXJlZCIsImN1cnJlbnRNYXhUaWNrV2lkdGhzIiwieCIsInNpemUiLCJkb21haW4iLCJ5IiwieTIiLCJyb3RhdGVkUGFkZGluZyIsIndpdGhvdXRGYWRlSW4iLCJpbnB1dFR5cGUiLCJkYXRldGltZUlkIiwiY2xpcCIsImlkIiwiaWRYQXhpcyIsImlkWUF4aXMiLCJpZEdyaWQiLCJpZFN1YmNoYXJ0IiwicGF0aCIsInBhdGhYQXhpcyIsInBhdGhZQXhpcyIsInBhdGhHcmlkIiwiZHJhZ1N0YXJ0IiwiZHJhZ2dpbmciLCJmbG93aW5nIiwiY2FuY2VsQ2xpY2siLCJtb3VzZW92ZXIiLCJyZW5kZXJlZCIsInRyYW5zaXRpbmciLCJoYXNOZWdhdGl2ZVZhbHVlIiwiaGFzUG9zaXRpdmVWYWx1ZSIsIm9yZ0FyZWFPcGFjaXR5IiwiaGlkZGVuVGFyZ2V0SWRzIiwiaGlkZGVuTGVnZW5kSWRzIiwiZm9jdXNlZFRhcmdldElkcyIsImRlZm9jdXNlZFRhcmdldElkcyIsInJhZGl1cyIsImlubmVyUmFkaXVzIiwiaW5uZXJSYWRpdXNSYXRpbyIsImdhdWdlQXJjV2lkdGgiLCJyYWRpdXNFeHBhbmRlZCIsInhncmlkQXR0ciIsIngxIiwieDIiLCJ5MSIsImRhdGFfc2VsZWN0aW9uX2VuYWJsZWQiLCJkYXRhX3NlbGVjdGlvbl9ncm91cGVkIiwiZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlIiwiZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUiLCJkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUiLCJ3aW4iLCJkZWYiLCJvIiwic2VsZiIsIndpbmRvdyIsImdsb2JhbCIsImdsb2JhbFRoaXMiLCJGdW5jdGlvbiIsImRvYyIsImRvY3VtZW50IiwiaXNWYWx1ZSIsInYiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzVW5kZWZpbmVkIiwiaXNEZWZpbmVkIiwiaXNCb29sZWFuIiwiY2VpbDEwIiwiTWF0aCIsImNlaWwiLCJhc0hhbGZQaXhlbCIsIm4iLCJkaWZmRG9tYWluIiwiZCIsImlzT2JqZWN0VHlwZSIsImlzRW1wdHkiLCJsZW5ndGgiLCJEYXRlIiwiT2JqZWN0Iiwia2V5cyIsImlzTmFOIiwibm90RW1wdHkiLCJpc0FycmF5IiwiYXJyIiwiQXJyYXkiLCJpc09iamVjdCIsIm9iaiIsIm5vZGVUeXBlIiwiZ2V0T3B0aW9uIiwib3B0aW9ucyIsImtleSIsImRlZmF1bHRWYWx1ZSIsImhhc1ZhbHVlIiwiZGljdCIsInZhbHVlIiwiZm91bmQiLCJmb3JFYWNoIiwiY2FsbEZuIiwiZm4iLCJpc0ZuIiwiYXJncyIsImNhbGwiLCJzYW5pdGlzZSIsInN0ciIsInJlcGxhY2UiLCJzZXRUZXh0VmFsdWUiLCJub2RlIiwiZHkiLCJ0b01pZGRsZSIsImluZGV4T2YiLCJkaWZmIiwibWFwIiwibXVsdGlsaW5lIiwic3BsaXQiLCJsZW4iLCJodG1sIiwiaSIsImFwcGVuZCIsImF0dHIiLCJnZXRSZWN0U2VnTGlzdCIsImdldEJCb3giLCJnZXRQYXRoQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaXRlbXMiLCJtaW4iLCJnZXRCcnVzaFNlbGVjdGlvbiIsImN0eCIsInNlbGVjdGlvbiIsImV2ZW50IiwiZDNFdmVudCIsIm1haW4iLCJjb250ZXh0IiwiY29uc3RydWN0b3IiLCJuYW1lIiwic2VsZWN0IiwiQ0xBU1MiLCJkM0JydXNoU2VsZWN0aW9uIiwiZ2V0Qm91bmRpbmdSZWN0IiwicmVjdCIsImdldFJhbmRvbSIsImFzU3RyIiwicmFuZCIsInJhbmRvbSIsImJydXNoRW1wdHkiLCJleHRlbmQiLCJzb3VyY2UiLCJwIiwidGVzdCIsImNhcGl0YWxpemUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwidG9BcnJheSIsImdldENzc1J1bGVzIiwic3R5bGVTaGVldHMiLCJydWxlcyIsInNoZWV0IiwiY3NzUnVsZXMiLCJjb25jYXQiLCJlIiwiY29uc29sZSIsImVycm9yIiwiaHJlZiIsInRvU3RyaW5nIiwiZ2V0VHJhbnNsYXRpb24iLCJ0cmFuc2Zvcm0iLCJiYXNlVmFsIiwiZ2V0SXRlbSIsIm1hdHJpeCIsImEiLCJiIiwiYyIsImYiLCJnZXRVbmlxdWUiLCJkYXRhIiwiaXNEYXRlIiwiTnVtYmVyIiwiZmlsdGVyIiwibWVyZ2VBcnJheSIsInJlZHVjZSIsIm1lcmdlT2JqIiwib2JqZWN0TiIsInNoaWZ0Iiwic29ydFZhbHVlIiwiaXNBc2MiLCJldmVyeSIsInNvcnQiLCJnZXRNaW5NYXgiLCJ0eXBlIiwicmVzIiwidW5kZWZpbmVkIiwiZ2V0UmFuZ2UiLCJzdGFydCIsImVuZCIsInB1c2giLCJlbXVsYXRlRXZlbnQiLCJtb3VzZSIsImdldFBhcmFtcyIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwic2NyZWVuWCIsInNjcmVlblkiLCJjbGllbnRYIiwiY2xpZW50WSIsIk1vdXNlRXZlbnQiLCJlbCIsImV2ZW50VHlwZSIsInBhcmFtcyIsImRpc3BhdGNoRXZlbnQiLCJtb3VzZUV2ZW50IiwiY3JlYXRlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsInRvdWNoIiwidG91Y2hPYmoiLCJUb3VjaCIsImlkZW50aWZpZXIiLCJub3ciLCJyYWRpdXNYIiwicmFkaXVzWSIsInJvdGF0aW9uQW5nbGUiLCJmb3JjZSIsIlRvdWNoRXZlbnQiLCJzaGlmdEtleSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJ0cGxQcm9jZXNzIiwidHBsIiwiUmVnRXhwIiwiZGF0YV94IiwiZGF0YV94cyIsImRhdGFfeEZvcm1hdCIsImRhdGFfeExvY2FsdGltZSIsImRhdGFfeFNvcnQiLCJkYXRhX2lkQ29udmVydGVyIiwiZGF0YV9uYW1lcyIsImRhdGFfY2xhc3NlcyIsImRhdGFfZ3JvdXBzIiwiZGF0YV9heGVzIiwiZGF0YV90eXBlIiwiZGF0YV90eXBlcyIsImRhdGFfbGFiZWxzIiwiZGF0YV9sYWJlbHNfY29sb3JzIiwiZGF0YV9sYWJlbHNfcG9zaXRpb24iLCJkYXRhX29yZGVyIiwiZGF0YV9yZWdpb25zIiwiZGF0YV9jb2xvciIsImRhdGFfY29sb3JzIiwiZGF0YV9oaWRlIiwiZGF0YV9maWx0ZXIiLCJkYXRhX3N0YWNrX25vcm1hbGl6ZSIsImRhdGFfb25jbGljayIsImRhdGFfb25vdmVyIiwiZGF0YV9vbm91dCIsImRhdGFfb25zZWxlY3RlZCIsImRhdGFfb251bnNlbGVjdGVkIiwiZGF0YV9vbm1pbiIsImRhdGFfb25tYXgiLCJkYXRhX3VybCIsImRhdGFfaGVhZGVycyIsImRhdGFfanNvbiIsImRhdGFfcm93cyIsImRhdGFfY29sdW1ucyIsImRhdGFfbWltZVR5cGUiLCJkYXRhX2tleXMiLCJkYXRhX2VtcHR5X2xhYmVsX3RleHQiLCJkYXRhU2VsZWN0aW9uIiwiYXhpc194X2NsaXBQYXRoIiwiYXhpc194X3Nob3ciLCJheGlzX3hfdHlwZSIsImF4aXNfeF9sb2NhbHRpbWUiLCJheGlzX3hfY2F0ZWdvcmllcyIsImF4aXNfeF90aWNrX2NlbnRlcmVkIiwiYXhpc194X3RpY2tfZm9ybWF0IiwiYXhpc194X3RpY2tfY3VsbGluZyIsImF4aXNfeF90aWNrX2N1bGxpbmdfbWF4IiwiYXhpc194X3RpY2tfY291bnQiLCJheGlzX3hfdGlja19zaG93IiwiYXhpc194X3RpY2tfdGV4dF9zaG93IiwiYXhpc194X3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeF90aWNrX2ZpdCIsImF4aXNfeF90aWNrX3ZhbHVlcyIsImF4aXNfeF90aWNrX3JvdGF0ZSIsImF4aXNfeF90aWNrX291dGVyIiwiYXhpc194X3RpY2tfbXVsdGlsaW5lIiwiYXhpc194X3RpY2tfd2lkdGgiLCJheGlzX3hfdGlja190b29sdGlwIiwiYXhpc194X21heCIsImF4aXNfeF9taW4iLCJheGlzX3hfcGFkZGluZyIsImF4aXNfeF9oZWlnaHQiLCJheGlzX3hfZXh0ZW50IiwiYXhpc194X2xhYmVsIiwiYXhpc194X2F4ZXMiLCJheGlzX3lfY2xpcFBhdGgiLCJheGlzX3lfc2hvdyIsImF4aXNfeV90eXBlIiwiYXhpc195X21heCIsImF4aXNfeV9taW4iLCJheGlzX3lfaW52ZXJ0ZWQiLCJheGlzX3lfY2VudGVyIiwiYXhpc195X2lubmVyIiwiYXhpc195X2xhYmVsIiwiYXhpc195X3RpY2tfZm9ybWF0IiwiYXhpc195X3RpY2tfY3VsbGluZyIsImF4aXNfeV90aWNrX2N1bGxpbmdfbWF4IiwiYXhpc195X3RpY2tfb3V0ZXIiLCJheGlzX3lfdGlja192YWx1ZXMiLCJheGlzX3lfdGlja19yb3RhdGUiLCJheGlzX3lfdGlja19jb3VudCIsImF4aXNfeV90aWNrX3Nob3ciLCJheGlzX3lfdGlja19zdGVwU2l6ZSIsImF4aXNfeV90aWNrX3RleHRfc2hvdyIsImF4aXNfeV90aWNrX3RleHRfcG9zaXRpb24iLCJheGlzX3lfdGlja190aW1lX3ZhbHVlIiwiYXhpc195X3BhZGRpbmciLCJheGlzX3lfZGVmYXVsdCIsImF4aXNfeV9heGVzIiwiYXhpc195Ml9zaG93IiwiYXhpc195Ml9tYXgiLCJheGlzX3kyX21pbiIsImF4aXNfeTJfaW52ZXJ0ZWQiLCJheGlzX3kyX2NlbnRlciIsImF4aXNfeTJfaW5uZXIiLCJheGlzX3kyX2xhYmVsIiwiYXhpc195Ml90aWNrX2Zvcm1hdCIsImF4aXNfeTJfdGlja19jdWxsaW5nIiwiYXhpc195Ml90aWNrX2N1bGxpbmdfbWF4IiwiYXhpc195Ml90aWNrX291dGVyIiwiYXhpc195Ml90aWNrX3ZhbHVlcyIsImF4aXNfeTJfdGlja19yb3RhdGUiLCJheGlzX3kyX3RpY2tfY291bnQiLCJheGlzX3kyX3RpY2tfc2hvdyIsImF4aXNfeTJfdGlja19zdGVwU2l6ZSIsImF4aXNfeTJfdGlja190ZXh0X3Nob3ciLCJheGlzX3kyX3RpY2tfdGV4dF9wb3NpdGlvbiIsImF4aXNfeTJfcGFkZGluZyIsImF4aXNfeTJfZGVmYXVsdCIsImF4aXNfeTJfYXhlcyIsImF4aXNfcm90YXRlZCIsImNvbG9yX3BhdHRlcm4iLCJjb2xvcl90aWxlcyIsImNvbG9yX3RocmVzaG9sZCIsImNvbG9yX29ub3ZlciIsImdyaWRfeF9zaG93IiwiZ3JpZF94X3R5cGUiLCJncmlkX3hfbGluZXMiLCJncmlkX3lfc2hvdyIsImdyaWRfeV9saW5lcyIsImdyaWRfeV90aWNrcyIsImdyaWRfZm9jdXNfZWRnZSIsImdyaWRfZm9jdXNfc2hvdyIsImdyaWRfZm9jdXNfeSIsImdyaWRfZnJvbnQiLCJncmlkX2xpbmVzX2Zyb250IiwiaW50ZXJhY3Rpb25fZW5hYmxlZCIsImludGVyYWN0aW9uX2JyaWdodGVuIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlIiwiaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoIiwibGVnZW5kX3Nob3ciLCJsZWdlbmRfaGlkZSIsImxlZ2VuZF9jb250ZW50c19iaW5kdG8iLCJsZWdlbmRfY29udGVudHNfdGVtcGxhdGUiLCJsZWdlbmRfcG9zaXRpb24iLCJsZWdlbmRfaW5zZXRfYW5jaG9yIiwibGVnZW5kX2luc2V0X3giLCJsZWdlbmRfaW5zZXRfeSIsImxlZ2VuZF9pbnNldF9zdGVwIiwibGVnZW5kX2l0ZW1fb25jbGljayIsImxlZ2VuZF9pdGVtX29ub3ZlciIsImxlZ2VuZF9pdGVtX29ub3V0IiwibGVnZW5kX2VxdWFsbHkiLCJsZWdlbmRfcGFkZGluZyIsImxlZ2VuZF9pdGVtX3RpbGVfd2lkdGgiLCJsZWdlbmRfaXRlbV90aWxlX2hlaWdodCIsImxlZ2VuZF91c2VQb2ludCIsInBvaW50X3Nob3ciLCJwb2ludF9yIiwicG9pbnRfc2Vuc2l0aXZpdHkiLCJwb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCIsInBvaW50X2ZvY3VzX2V4cGFuZF9yIiwicG9pbnRfcGF0dGVybiIsInBvaW50X3NlbGVjdF9yIiwicG9pbnRfdHlwZSIsInN1YmNoYXJ0X3Nob3ciLCJzdWJjaGFydF9zaXplX2hlaWdodCIsInN1YmNoYXJ0X2F4aXNfeF9zaG93Iiwic3ViY2hhcnRfYXhpc194X3RpY2tfc2hvdyIsInN1YmNoYXJ0X2F4aXNfeF90aWNrX3RleHRfc2hvdyIsInN1YmNoYXJ0X29uYnJ1c2giLCJ0aXRsZV90ZXh0IiwidGl0bGVfcGFkZGluZyIsInRpdGxlX3Bvc2l0aW9uIiwidG9vbHRpcF9zaG93IiwidG9vbHRpcF9kb05vdEhpZGUiLCJ0b29sdGlwX2dyb3VwZWQiLCJ0b29sdGlwX2Zvcm1hdF90aXRsZSIsInRvb2x0aXBfZm9ybWF0X25hbWUiLCJ0b29sdGlwX2Zvcm1hdF92YWx1ZSIsInRvb2x0aXBfcG9zaXRpb24iLCJ0b29sdGlwX2NvbnRlbnRzIiwidG9vbHRpcF9pbml0X3Nob3ciLCJ0b29sdGlwX2luaXRfeCIsInRvb2x0aXBfaW5pdF9wb3NpdGlvbiIsInRvb2x0aXBfbGlua2VkIiwidG9vbHRpcF9saW5rZWRfbmFtZSIsInRvb2x0aXBfb25zaG93IiwidG9vbHRpcF9vbmhpZGUiLCJ0b29sdGlwX29uc2hvd24iLCJ0b29sdGlwX29uaGlkZGVuIiwidG9vbHRpcF9vcmRlciIsInpvb21fZW5hYmxlZCIsInpvb21fZXh0ZW50Iiwiem9vbV9wcml2aWxlZ2VkIiwiem9vbV9yZXNjYWxlIiwiem9vbV9vbnpvb20iLCJ6b29tX29uem9vbXN0YXJ0Iiwiem9vbV9vbnpvb21lbmQiLCJ6b29tX3Jlc2V0QnV0dG9uIiwiem9vbV94X21pbiIsInpvb21feF9tYXgiLCJhcmVhX3plcm9iYXNlZCIsImFyZWFfYWJvdmUiLCJhcmVhX2xpbmVhckdyYWRpZW50IiwiYmFyX3BhZGRpbmciLCJiYXJfcmFkaXVzIiwiYmFyX3JhZGl1c19yYXRpbyIsImJhcl9zZW5zaXRpdml0eSIsImJhcl93aWR0aCIsImJhcl93aWR0aF9yYXRpbyIsImJhcl93aWR0aF9tYXgiLCJiYXJfemVyb2Jhc2VkIiwiYnViYmxlX21heFIiLCJidWJibGVfemVyb2Jhc2VkIiwiZG9udXRfbGFiZWxfc2hvdyIsImRvbnV0X2xhYmVsX2Zvcm1hdCIsImRvbnV0X2xhYmVsX3RocmVzaG9sZCIsImRvbnV0X2xhYmVsX3JhdGlvIiwiZG9udXRfd2lkdGgiLCJkb251dF90aXRsZSIsImRvbnV0X2V4cGFuZCIsImRvbnV0X2V4cGFuZF9yYXRlIiwiZG9udXRfZXhwYW5kX2R1cmF0aW9uIiwiZG9udXRfcGFkQW5nbGUiLCJkb251dF9zdGFydGluZ0FuZ2xlIiwiZ2F1Z2VfZnVsbENpcmNsZSIsImdhdWdlX2xhYmVsX3Nob3ciLCJnYXVnZV9sYWJlbF9mb3JtYXQiLCJnYXVnZV9taW4iLCJnYXVnZV9tYXgiLCJnYXVnZV90eXBlIiwiZ2F1Z2Vfc3RhcnRpbmdBbmdsZSIsIlBJIiwiZ2F1Z2VfbGFiZWxfZXh0ZW50cyIsImdhdWdlX3RpdGxlIiwiZ2F1Z2VfdW5pdHMiLCJnYXVnZV93aWR0aCIsImdhdWdlX2FyY3NfbWluV2lkdGgiLCJnYXVnZV9leHBhbmQiLCJnYXVnZV9leHBhbmRfcmF0ZSIsImdhdWdlX2V4cGFuZF9kdXJhdGlvbiIsImxpbmVfY29ubmVjdE51bGwiLCJsaW5lX3N0ZXBfdHlwZSIsImxpbmVfemVyb2Jhc2VkIiwibGluZV9jbGFzc2VzIiwibGluZV9wb2ludCIsInBpZV9sYWJlbF9zaG93IiwicGllX2xhYmVsX2Zvcm1hdCIsInBpZV9sYWJlbF90aHJlc2hvbGQiLCJwaWVfbGFiZWxfcmF0aW8iLCJwaWVfZXhwYW5kIiwicGllX2V4cGFuZF9yYXRlIiwicGllX2V4cGFuZF9kdXJhdGlvbiIsInBpZV9pbm5lclJhZGl1cyIsInBpZV9wYWRBbmdsZSIsInBpZV9wYWRkaW5nIiwicGllX3N0YXJ0aW5nQW5nbGUiLCJyYWRhcl9heGlzX21heCIsInJhZGFyX2F4aXNfbGluZV9zaG93IiwicmFkYXJfYXhpc190ZXh0X3Nob3ciLCJyYWRhcl9heGlzX3RleHRfcG9zaXRpb24iLCJyYWRhcl9sZXZlbF9kZXB0aCIsInJhZGFyX2xldmVsX3Nob3ciLCJyYWRhcl9sZXZlbF90ZXh0X2Zvcm1hdCIsInRvRml4ZWQiLCJyYWRhcl9sZXZlbF90ZXh0X3Nob3ciLCJyYWRhcl9zaXplX3JhdGlvIiwicmFkYXJfZGlyZWN0aW9uX2Nsb2Nrd2lzZSIsInNwbGluZV9pbnRlcnBvbGF0aW9uX3R5cGUiLCJPcHRpb25zIiwiY29tbW9uQ29uZmlnIiwiY29sb3IiLCJpbnRlcmFjdGlvbiIsImxlZ2VuZCIsInBvaW50Iiwic3ViY2hhcnQiLCJ6b29tIiwic2hhcGVDb25maWciLCJidWJibGUiLCJkb251dCIsImdhdWdlIiwicGllIiwicmFkYXIiLCJzcGxpbmUiLCJiaW5kdG8iLCJiYWNrZ3JvdW5kIiwiY2xpcFBhdGgiLCJzdmdfY2xhc3NuYW1lIiwic2l6ZV93aWR0aCIsInNpemVfaGVpZ2h0IiwicGFkZGluZ19sZWZ0IiwicGFkZGluZ19yaWdodCIsInBhZGRpbmdfdG9wIiwicGFkZGluZ19ib3R0b20iLCJyZXNpemVfYXV0byIsIm9ub3ZlciIsIm9ub3V0Iiwib25yZXNpemUiLCJvbnJlc2l6ZWQiLCJvbmJlZm9yZWluaXQiLCJvbmluaXQiLCJvbmFmdGVyaW5pdCIsIm9ucmVuZGVyZWQiLCJ0cmFuc2l0aW9uX2R1cmF0aW9uIiwic2NhdHRlcl96ZXJvYmFzZWQiLCJwbHVnaW5zIiwicmVuZGVyIiwiQ2FjaGUiLCJhZGQiLCJpc0RhdGFUeXBlIiwiY2FjaGUiLCJjbG9uZVRhcmdldCIsInJlbW92ZSIsImdldCIsInRhcmdldHMiLCJyZXNldCIsImFsbCIsIiQkIiwiaWRfb3JnIiwidmFsdWVzIiwiQXhpc1JlbmRlcmVySGVscGVyIiwib3duZXIiLCJzY2FsZSIsImQzU2NhbGVMaW5lYXIiLCJjb25maWciLCJub1RyYW5zaXRpb24iLCJ3aXRob3V0VHJhbnNpdGlvbiIsInJhbmdlIiwic2NhbGVFeHRlbnQiLCJvcmdYU2NhbGUiLCJnZXRTaXplRm9yMUNoYXIiLCJ3IiwiaCIsInRpY2tPZmZzZXQiLCJzdG9wIiwiZ2VuZXJhdGVUaWNrcyIsImlzWUF4ZXMiLCJ0aWNrU3RlcFNpemUiLCJ0aWNrcyIsImludGVydmFsIiwidGlja0FyZ3VtZW50cyIsInJvdW5kIiwidW5zaGlmdCIsImNvcHlTY2FsZSIsIm5ld1NjYWxlIiwiY29weSIsInRleHRGb3JtYXR0ZWQiLCJ0aWNrRm9ybWF0IiwiZm9ybWF0dGVkIiwidHJhbnNpdGlvbmlzZSIsImludGVycnVwdCIsInRyYW5zaXRpb24iLCJBeGlzUmVuZGVyZXIiLCJpbm5lclRpY2tTaXplIiwib3V0ZXJUaWNrU2l6ZSIsIm91dGVyVGljayIsIm9yaWVudCIsInRpY2tDZW50ZXJlZCIsInRpY2tDdWxsaW5nIiwidGlja0xlbmd0aCIsInRpY2tQYWRkaW5nIiwidGlja1ZhbHVlcyIsIm1heCIsImhlbHBlciIsIkhlbHBlciIsImNyZWF0ZSIsImciLCJoZWxwZXJJbnN0Iiwic3BsaXRUaWNrVGV4dCIsImJpbmQiLCJpc0xlZnRSaWdodCIsImlzVG9wQm90dG9tIiwidGlja1RyYW5zZm9ybSIsImF4aXNQeCIsInNpZ24iLCJyb3RhdGUiLCJ0aWNrVGV4dFJvdGF0ZSIsInJhbmdlRXh0ZW50IiwiJGciLCJ0aWNrVGV4dFBvcyIsInByZWZpeCIsImF4aXNTaG93IiwidGlja1Nob3ciLCJ0aWNrIiwiZWFjaCIsImQzU2VsZWN0Iiwic2NhbGUwIiwiX19jaGFydF9fIiwic2NhbGUxIiwiaXNDYXRlZ29yeSIsInNlbGVjdEFsbCIsImVudGVyIiwibWVyZ2UiLCJvdXRlclRpY2tTaXplZCIsInRpY2tFbnRlciIsImluc2VydCIsInN0eWxlIiwidGlja0V4aXQiLCJleGl0Iiwic2l6ZUZvcjFDaGFyIiwiY291bnRzIiwidHNwYW4iLCJpbmRleCIsInRpY2tNdWx0aWxpbmUiLCJzcGxpdHRlZCIsImR4Iiwic2luIiwibGluZVVwZGF0ZSIsInRleHRVcGRhdGUiLCJzZXRUaWNrTGluZVRleHRQb3NpdGlvbiIsInRpY2tUaXRsZSIsImJhbmR3aWR0aCIsImdldFRpY2tYWSIsInBvcyIsImdldFRpY2tTaXplIiwidGlja1Bvc2l0aW9uIiwidGlja1BvcyIsInRleHRBbmNob3JGb3JUZXh0IiwiciIsInJldmVyc2UiLCJ0ZXh0VHJhbnNmb3JtIiwieUZvclRleHQiLCJyMiIsImNoYXJXaWR0aCIsInN1YnRleHQiLCJzcGFjZUluZGV4IiwidGV4dFdpZHRoIiwic3Vic3RyIiwidGlja1dpZHRoIiwidGlja1RleHQiLCJhcmd1bWVudHMiLCJmb3JtYXQiLCJpc0NlbnRlcmVkIiwidGlja0ludGVydmFsIiwiZ2V0VG90YWxMZW5ndGgiLCJJbmZpbml0eSIsImN1bGxpbmciLCJzZXRUcmFuc2l0aW9uIiwidCIsIkF4aXMiLCJzdWJYIiwic2V0T3JpZW50IiwiZ2V0QXhpc0NsYXNzTmFtZSIsImlzSG9yaXpvbnRhbCIsImZvckhvcml6b250YWwiLCJpc1JvdGF0ZWQiLCJpbml0IiwiJGVsIiwiY2xhc3NBeGlzIiwiYXhpc0lkIiwiY2xhc3NMYWJlbCIsImdldFRyYW5zbGF0ZSIsImdlbmVyYXRlQXhlcyIsInlJbm5lciIsInkySW5uZXIiLCJkM0F4aXMiLCJheGVzIiwiYXhlc0NvbmZpZyIsImQzQXhpc0xlZnQiLCJkM0F4aXNCb3R0b20iLCJkM0F4aXNUb3AiLCJkM0F4aXNSaWdodCIsImNvdW50IiwidGlja1NpemVPdXRlciIsIm91dGVyIiwiYXhlc0xpc3QiLCJ1cGRhdGVBeGVzIiwiYXhpc1JhbmdlIiwiY2xhc3NOYW1lIiwiZ2V0QXhpcyIsIm5vVGlja1RleHRSb3RhdGUiLCJpc1giLCJpc0NhdGVnb3JpemVkIiwieEF4aXNUaWNrIiwieFRpY2tWYWx1ZXMiLCJheGlzUGFyYW1zIiwiYXBpIiwiY2F0ZWdvcmllcyIsImlzVGltZVNlcmllcyIsInBhcnNlRGF0ZSIsImlzVGltZVNlcmllc1kiLCJpc1N0YWNrTm9ybWFsaXplZCIsInVwZGF0ZVhBeGlzVGlja1ZhbHVlcyIsImZpdCIsImdlbmVyYXRlVGlja1ZhbHVlcyIsIm1hcFRhcmdldHNUb1VuaXF1ZVhzIiwiZ2V0SWQiLCJnZXRYQXhpc1RpY2tGb3JtYXQiLCJjdXJyRm9ybWF0IiwiZGF0ZSIsImF4aXNUaW1lIiwiZGVmYXVsdEF4aXNUaW1lIiwiY2F0ZWdvcnlOYW1lIiwiYXBwbHkiLCJnZXRUaWNrVmFsdWVzIiwiZ2V0TGFiZWxPcHRpb25CeUF4aXNJZCIsImdldExhYmVsVGV4dCIsIm9wdGlvbiIsInNldExhYmVsVGV4dCIsImdldExhYmVsUG9zaXRpb24iLCJkZWZhdWx0UG9zaXRpb24iLCJwb3NpdGlvbiIsImhhcyIsImlzSW5uZXIiLCJpc091dGVyIiwiaXNMZWZ0IiwiaXNDZW50ZXIiLCJpc1JpZ2h0IiwiaXNUb3AiLCJpc01pZGRsZSIsImlzQm90dG9tIiwiZ2V0WEF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0WUF4aXNMYWJlbFBvc2l0aW9uIiwiZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbiIsImdldExhYmVsUG9zaXRpb25CeUlkIiwidGV4dEZvclhBeGlzTGFiZWwiLCJ0ZXh0Rm9yWUF4aXNMYWJlbCIsInRleHRGb3JZMkF4aXNMYWJlbCIsInhGb3JBeGlzTGFiZWwiLCJkeEZvckF4aXNMYWJlbCIsInRleHRBbmNob3JGb3JBeGlzTGFiZWwiLCJhbmNob3IiLCJ4Rm9yWEF4aXNMYWJlbCIsInhGb3JZQXhpc0xhYmVsIiwieEZvclkyQXhpc0xhYmVsIiwiZHhGb3JYQXhpc0xhYmVsIiwiZHhGb3JZQXhpc0xhYmVsIiwiZHhGb3JZMkF4aXNMYWJlbCIsImR5Rm9yWEF4aXNMYWJlbCIsInhIZWlnaHQiLCJnZXRNYXhUaWNrV2lkdGgiLCJkeUZvcllBeGlzTGFiZWwiLCJkeUZvclkyQXhpc0xhYmVsIiwidGV4dEFuY2hvckZvclhBeGlzTGFiZWwiLCJ0ZXh0QW5jaG9yRm9yWUF4aXNMYWJlbCIsInRleHRBbmNob3JGb3JZMkF4aXNMYWJlbCIsIndpdGhvdXRSZWNvbXB1dGUiLCJzdmciLCJjdXJyZW50VGlja01heCIsIm1heFdpZHRoIiwiaXNZQXhpcyIsInRhcmdldHNUb1Nob3ciLCJmaWx0ZXJUYXJnZXRzVG9TaG93IiwidGlja0NvdW50IiwiZHVtbXkiLCJ1cGRhdGVMYWJlbHMiLCJ3aXRoVHJhbnNpdGlvbiIsImxhYmVscyIsIlgiLCJZIiwiWTIiLCJheGlzTGFiZWwiLCJnZXRQYWRkaW5nIiwicGFkZGluZyIsImRvbWFpbkxlbmd0aCIsImNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nIiwicGl4ZWxzIiwiZm9yVGltZVNlcmllcyIsInRpY2tWYWx1ZSIsInRhcmdldENvdW50IiwiZ2VuZXJhdGVUcmFuc2l0aW9ucyIsImR1cmF0aW9uIiwiYXgiLCJheGlzU3ViWCIsInJlZHJhdyIsInRyYW5zaXRpb25zIiwiaXNIaWRkZW4iLCJpc0luaXQiLCJvcGFjaXR5IiwiJGF4aXMiLCJyZWRyYXdBeGlzIiwid3RoIiwiZmxvdyIsInhEb21haW5Gb3Jab29tIiwiaGFzWm9vbSIsInVwZGF0ZVhEb21haW4iLCJVcGRhdGVYRG9tYWluIiwiVXBkYXRlT3JnWERvbWFpbiIsIlRyaW1YRG9tYWluIiwib3JnRG9tYWluIiwiZ2V0WURvbWFpbiIsImhhc0FyY1R5cGUiLCJUcmFuc2l0aW9uIiwiVXBkYXRlWEF4aXMiLCJzZXRDdWxsaW5nIiwic3ViWSIsInN1YlkyIiwidG9DdWxsIiwiaW50ZXJ2YWxGb3JDdWxsaW5nIiwidGlja1NpemUiLCJjdWxsaW5nTWF4IiwiZGlzcGxheSIsImNvbnZlcnREYXRhIiwiY2FsbGJhY2siLCJ1cmwiLCJjb252ZXJ0VXJsVG9EYXRhIiwibWltZVR5cGUiLCJoZWFkZXJzIiwianNvbiIsImNvbnZlcnRKc29uVG9EYXRhIiwicm93cyIsImNvbnZlcnRSb3dzVG9EYXRhIiwiY29sdW1ucyIsImNvbnZlcnRDb2x1bW5zVG9EYXRhIiwiRXJyb3IiLCJkb25lIiwicmVxIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2V0UmVxdWVzdEhlYWRlciIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsInJlYWR5U3RhdGUiLCJzdGF0dXMiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsIkpTT04iLCJwYXJzZSIsInNlbmQiLCJjb252ZXJ0Q3N2VHN2VG9EYXRhIiwicGFyc2VyIiwieHN2IiwiY29udmVydENzdlRvRGF0YSIsImQzQ3N2UGFyc2VSb3dzIiwiZDNDc3ZQYXJzZSIsImNvbnZlcnRUc3ZUb0RhdGEiLCJ0c3YiLCJkM1RzdlBhcnNlUm93cyIsImQzVHN2UGFyc2UiLCJrZXlzUGFyYW0iLCJ0YXJnZXRLZXlzIiwibmV3Um93cyIsIm5ld1JvdyIsImZpbmRWYWx1ZUluSnNvbiIsInRtcCIsIm9iamVjdCIsImNvbnZlcnRlZFBhdGgiLCJwYXRoQXJyYXkiLCJzb21lIiwiayIsInJvdyIsImoiLCJjb2wiLCJjb252ZXJ0RGF0YVRvVGFyZ2V0cyIsImFwcGVuZFhzIiwieHNEYXRhIiwiZGF0YUtleXMiLCJpZHMiLCJpc05vdFgiLCJ4cyIsInhLZXkiLCJnZXRYS2V5IiwiaXNDdXN0b21YIiwicmF3WCIsImdlbmVyYXRlVGFyZ2V0WCIsImdldE90aGVyVGFyZ2V0WHMiLCJnZXRYVmFsdWVzT2ZYS2V5IiwiY29udmVydGVkSWQiLCJoYXNDYXRlZ29yeSIsInYxIiwidjIiLCJoYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzIiwiaGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyIsInNldFRhcmdldFR5cGUiLCJtYXBUb0lkcyIsImRhdGFLZXkiLCJleGlzdFZhbHVlIiwiaXNHcm91cGVkIiwieFZhbHVlcyIsImdldEluZGV4QnlYIiwiYmFzZWRYIiwiZmlsdGVyQnlYIiwiZ2V0WFZhbHVlIiwiaWRzRm9yWCIsImdldE90aGVyVGFyZ2V0WCIsImFkZFhzIiwiaXNNdWx0aXBsZVgiLCJoYXNUeXBlIiwiYWRkTmFtZSIsImdldEFsbFZhbHVlc09uSW5kZXgiLCJnZXRWYWx1ZU9uSW5kZXgiLCJ2YWx1ZU9uSW5kZXgiLCJ1cGRhdGVUYXJnZXRYIiwidXBkYXRlVGFyZ2V0WHMiLCJ1cGRhdGVYcyIsImdldFByZXZYIiwiZ2V0TmV4dFgiLCJnZXRCYXNlVmFsdWUiLCJpc0FyZWFSYW5nZVR5cGUiLCJnZXRBcmVhUmFuZ2VEYXRhIiwiaXNCdWJibGVaVHlwZSIsImdldEJ1YmJsZVpEYXRhIiwiZ2V0TWluTWF4VmFsdWUiLCJnZXRNaW5NYXhEYXRhIiwiY2FjaGVLZXkiLCJtaW5NYXhEYXRhIiwibWluTWF4IiwibWluRGF0YSIsImdldEZpbHRlcmVkRGF0YUJ5VmFsdWUiLCJtYXhEYXRhIiwiZ2V0VG90YWxQZXJJbmRleCIsInN1bSIsImdldFRvdGFsRGF0YVN1bSIsInRvdGFsRGF0YVN1bSIsInRvdGFsIiwiZ2V0TWF4RGF0YUNvdW50IiwiZ2V0TWF4RGF0YUNvdW50VGFyZ2V0IiwibWFwVG9UYXJnZXRJZHMiLCJoYXNUYXJnZXQiLCJ2YWwiLCJpc1RhcmdldFRvU2hvdyIsInRhcmdldElkIiwiaXNMZWdlbmRUb1Nob3ciLCJhZGRIaWRkZW5UYXJnZXRJZHMiLCJ0YXJnZXRJZHMiLCJyZW1vdmVIaWRkZW5UYXJnZXRJZHMiLCJhZGRIaWRkZW5MZWdlbmRJZHMiLCJyZW1vdmVIaWRkZW5MZWdlbmRJZHMiLCJnZXRWYWx1ZXNBc0lkS2V5ZWQiLCJ5cyIsImNoZWNrVmFsdWVJblRhcmdldHMiLCJjaGVja2VyIiwiaGFzTXVsdGlUYXJnZXRzIiwiX2NoZWNrT3JkZXIiLCJvcmRlciIsInRvTG93ZXJDYXNlIiwiaXNPcmRlckRlc2MiLCJpc09yZGVyQXNjIiwib3JkZXJUYXJnZXRzIiwidGFyZ2V0c1ZhbHVlIiwib3JkZXJBc2MiLCJvcmRlckRlc2MiLCJ0MSIsInQyIiwicmVkdWNlciIsImFicyIsInQxU3VtIiwidDJTdW0iLCJmaWx0ZXJSZW1vdmVOdWxsIiwiZmlsdGVyQnlYRG9tYWluIiwieERvbWFpbiIsImhhc0RhdGFMYWJlbCIsImRhdGFMYWJlbHMiLCJnZXREYXRhTGFiZWxMZW5ndGgiLCJsZW5ndGhzIiwiZGF0YUxhYmVsRm9ybWF0IiwiaXNOb25lQXJjIiwiaXNBcmMiLCJmaW5kU2FtZVhPZlZhbHVlcyIsInRhcmdldFgiLCJzYW1lcyIsImZpbmRDbG9zZXN0RnJvbVRhcmdldHMiLCJjYW5kaWRhdGVzIiwiZmluZENsb3Nlc3QiLCJjbG9zZXN0IiwibWluRGlzdCIsImlzQmFyVHlwZSIsImdldFRhcmdldFNlbGVjdG9yU3VmZml4IiwiaXNXaXRoaW5CYXIiLCJkaXN0IiwieEluZGV4IiwieUluZGV4IiwiY2lyY2xlWSIsInNxcnQiLCJwb3ciLCJjb252ZXJ0VmFsdWVzVG9TdGVwIiwic3RlcFR5cGUiLCJjb252ZXJ0ZWQiLCJjb252ZXJ0VmFsdWVzVG9SYW5nZSIsInJhbmdlcyIsInVwZGF0ZURhdGFBdHRyaWJ1dGVzIiwiYXR0cnMiLCJjdXJyZW50Iiwid2l0aExlZ2VuZCIsImdldFJhdGlvIiwiYXNQZXJjZW50IiwicmF0aW8iLCJzaG93biIsImRhdGFWYWx1ZXMiLCJwYWRBbmdsZSIsImVuZEFuZ2xlIiwic3RhcnRBbmdsZSIsImhpZGRlblN1bSIsImFjYyIsImN1cnIiLCJwYXJzZUZsb2F0IiwibWF4VmFsdWUiLCJ1cGRhdGVEYXRhSW5kZXhCeVgiLCJ0aWNrVmFsdWVNYXAiLCJvdXQiLCJ2YWx1ZUluZGV4IiwibG9hZCIsInJhd1RhcmdldHMiLCJ0eXBlcyIsInNwbGljZSIsInVwZGF0ZVRhcmdldHMiLCJ3aXRoVXBkYXRlT3JnWERvbWFpbiIsIndpdGhVcGRhdGVYRG9tYWluIiwibG9hZEZyb21BcmdzIiwidW5sb2FkIiwicmF3VGFyZ2V0SWRzIiwiY3VzdG9tRG9uZUNiIiwic2VsZWN0b3JUYXJnZXQiLCJlbmRhbGwiLCJkcmFnIiwiYWx0RG9tYWluIiwic3giLCJzeSIsIm14IiwibXkiLCJtaW5YIiwibWF4WCIsIm1pblkiLCJtYXhZIiwidG9nZ2xlIiwiaXNTZWxlY3RlZCIsImNsYXNzZWQiLCJpc0luY2x1ZGVkIiwiaXNXaXRoaW4iLCJ0b2dnbGVQb2ludCIsInRvZ2dsZVBhdGgiLCJkcmFnc3RhcnQiLCJzZXREcmFnU3RhdHVzIiwiZHJhZ2VuZCIsImlzRHJhZ2dpbmciLCJnZW5lcmF0ZUZsb3ciLCJ0cmFuc2xhdGVYIiwiZHJhd0JhciIsImRyYXdMaW5lIiwiZHJhd0FyZWEiLCJjeCIsImN5IiwieEZvclRleHQiLCJ4diIsInNjYWxlWCIsImZsb3dJbmRleCIsImZsb3dMZW5ndGgiLCJmbG93U3RhcnQiLCJmbG93RW5kIiwiZHVyYXRpb25Gb3JGbG93Iiwid2FpdCIsImdlbmVyYXRlV2FpdCIsInhMaW5lcyIsIm1haW5SZWdpb24iLCJsaXN0IiwibWFpblRleHQiLCJtYWluQmFyIiwibWFpbkxpbmUiLCJtYWluQXJlYSIsIm1haW5DaXJjbGUiLCJ1cGRhdGVYR3JpZCIsIm9yZ0RhdGFDb3VudCIsImhpZGVHcmlkRm9jdXMiLCJndCIsImQzVHJhbnNpdGlvbiIsImVhc2UiLCJkM0Vhc2VMaW5lYXIiLCJpc1JlZ2lvbk9uWCIsImlzQ2lyY2xlUG9pbnQiLCJ4RnVuYyIsInlGdW5jIiwib3BhY2l0eUZvclRleHQiLCJyZWdpb25YIiwicmVnaW9uV2lkdGgiLCJyZWRyYXdFdmVudFJlY3QiLCJpbml0RXZlbnRSZWN0IiwiZXZlbnRSZWN0VXBkYXRlIiwiem9vbUVuYWJsZWQiLCJnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzIiwieEF4aXNUaWNrVmFsdWVzIiwidXBkYXRlUG9pbnRDbGFzcyIsImRhdHVtIiwiZ2VuZXJhdGVFdmVudFJlY3RzRm9yU2luZ2xlWCIsInVwZGF0ZUV2ZW50UmVjdCIsIm9uIiwiYmluZFRvdWNoT25FdmVudFJlY3QiLCJzdGFydFB4IiwiZ2V0RXZlbnRSZWN0IiwiZWxlbWVudEZyb21Qb2ludCIsImdldEluZGV4Iiwic2VsZWN0UmVjdCIsInNlbGVjdFJlY3RGb3JNdWx0aXBsZVhzIiwiY2FsbE92ZXJPdXRGb3JUb3VjaCIsInVuc2VsZWN0UmVjdCIsInNlbGVjdFJlY3RGb3JTaW5nbGUiLCJwcmV2ZW50RGVmYXVsdCIsImlzUHJldmVudGVkIiwicHJldmVudFRocmVzaG9sZCIsInByZXZlbnRFdmVudCIsImN1cnJlbnRYWSIsInRvZ2dsZVNoYXBlIiwieFNjYWxlIiwiZXZlbnRSZWN0RGF0YSIsInJlY3RXIiwicmVjdFgiLCJnZXRFdmVudFJlY3RXaWR0aCIsImdldFByZXZOZXh0WCIsInByZXYiLCJuZXh0IiwidGhpc1giLCJjbGFzc0V2ZW50IiwiaXNTZWxlY3Rpb25FbmFibGVkIiwiaXNTZWxlY3Rpb25Hcm91cGVkIiwiaXNUb29sdGlwR3JvdXBlZCIsInNlbGVjdGVkRGF0YSIsInNob3dUb29sdGlwIiwic2hvd0dyaWRGb2N1cyIsImhpZGVUb29sdGlwIiwiZXhwYW5kQ2lyY2xlc0JhcnMiLCJpc1dpdGhpblNoYXBlIiwic2VsZWN0ZWQiLCJ1bmV4cGFuZENpcmNsZXMiLCJleHBhbmRDaXJjbGVzIiwiZXhwYW5kQmFycyIsImQzTW91c2UiLCJzYW1lWERhdGEiLCJpc0J1YmJsZVR5cGUiLCJpc1NjYXR0ZXJUeXBlIiwiX2hhbmRsZUxpbmtlZENoYXJ0cyIsInVuZXhwYW5kQmFycyIsInNldE92ZXJPdXQiLCJpc092ZXIiLCJzZXRPdmVyQ29sb3IiLCJjYWxsZWUiLCJsYXN0IiwiZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uIiwiZDNEcmFnIiwiZXZlbnRSZWN0RW50ZXIiLCJjbGlja0hhbmRsZXJGb3JTaW5nbGVYIiwiaXNTdGVwVHlwZSIsImQyIiwiY2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUyIsInNlbGVjdG9yIiwiaW5pdEJydXNoIiwiZDNCcnVzaFkiLCJkM0JydXNoWCIsImxhc3REb21haW4iLCJ0aW1lb3V0IiwiYnJ1c2hIYW5kbGVyIiwicmVkcmF3Rm9yQnJ1c2giLCJnZXRCcnVzaFNpemUiLCJicnVzaFNpemUiLCJ1cGRhdGVSZXNpemUiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZ2V0U2VsZWN0aW9uIiwibW92ZSIsIm9yZ1NjYWxlIiwidXBkYXRlIiwiZXh0ZW50IiwiZ2V0RXh0ZW50IiwiaW5pdFN1YmNoYXJ0IiwidmlzaWJpbGl0eSIsImNsaXBJZCIsImdldENsaXBQYXRoIiwiYXBwZW5kQ2xpcCIsImRlZnMiLCJ1cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQiLCJjbGFzc0NoYXJ0QmFyIiwiY2xhc3NCYXJzIiwiY2xhc3NDaGFydExpbmUiLCJjbGFzc0xpbmVzIiwiY2xhc3NBcmVhcyIsImNvbnRleHRCYXJVcGRhdGUiLCJjb250ZXh0QmFyRW50ZXIiLCJjb250ZXh0TGluZVVwZGF0ZSIsImNvbnRleHRMaW5lRW50ZXIiLCJ1cGRhdGVCYXJGb3JTdWJjaGFydCIsImR1cmF0aW9uRm9yRXhpdCIsImNvbnRleHRCYXIiLCJiYXJEYXRhIiwiY2xhc3NCYXIiLCJpbml0aWFsT3BhY2l0eSIsInJlZHJhd0JhckZvclN1YmNoYXJ0IiwiZHJhd0Jhck9uU3ViIiwidXBkYXRlTGluZUZvclN1YmNoYXJ0IiwiY29udGV4dExpbmUiLCJsaW5lRGF0YSIsImNsYXNzTGluZSIsInJlZHJhd0xpbmVGb3JTdWJjaGFydCIsImRyYXdMaW5lT25TdWIiLCJ1cGRhdGVBcmVhRm9yU3ViY2hhcnQiLCJjb250ZXh0QXJlYSIsImNsYXNzQXJlYSIsInJlZHJhd0FyZWFGb3JTdWJjaGFydCIsImRyYXdBcmVhT25TdWIiLCJyZWRyYXdTdWJjaGFydCIsIndpdGhTdWJjaGFydCIsImRyYXciLCJpbmRpY2VzIiwid2l0aFkiLCJ3aXRoRGltZW5zaW9uIiwidHJhbnNmb3JtQ29udGV4dCIsInN1YlhBeGlzIiwiZ2V0WERvbWFpbiIsImluaXRab29tIiwiZ2VuZXJhdGVab29tIiwiaW5pdFpvb21CZWhhdmlvdXIiLCJiaW5kWm9vbUV2ZW50IiwiYmluZFpvb21PbkV2ZW50UmVjdCIsInVuem9vbSIsIm9yZyIsImQzWm9vbSIsIm9uWm9vbVN0YXJ0Iiwib25ab29tIiwib25ab29tRW5kIiwib3JnU2NhbGVFeHRlbnQiLCJ1cGRhdGVTY2FsZUV4dGVudCIsImdldFpvb21Eb21haW4iLCJ1cGRhdGVUcmFuc2Zvcm1TY2FsZSIsInRyaW1YRG9tYWluIiwicmVzY2FsZSIsImdldEN1c3RvbWl6ZWRTY2FsZSIsInNvdXJjZUV2ZW50Iiwic3RhcnRFdmVudCIsImlzTW91c2Vtb3ZlIiwiaXNab29tT3V0Iiwid2hlZWxEZWx0YSIsIndpdGhFdmVudFJlY3QiLCJ1cGRhdGVab29tIiwiem9vbURvbWFpbiIsImRlbHRhIiwiaXNmdWxseVNob3duIiwiYmVoYXZpb3VyIiwiem9vbUJlaGF2aW91ciIsInByb3AiLCJjbGlja0Rpc3RhbmNlIiwiaW52ZXJ0Iiwic2V0Wm9vbVJlc2V0QnV0dG9uIiwicmVzZXRCdXR0b24iLCJyZXNldEJ0biIsIm9uY2xpY2siLCJnZW5lcmF0ZUNsYXNzIiwiY2xhc3NUZXh0IiwiY2xhc3NUZXh0cyIsImNsYXNzU2hhcGUiLCJjbGFzc1NoYXBlcyIsImdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MiLCJjbGFzc2VzIiwiY2xhc3NDaXJjbGUiLCJjbGFzc0NpcmNsZXMiLCJjbGFzc0FyYyIsImNsYXNzQXJjcyIsImNsYXNzUmVnaW9uIiwiY2xhc3MiLCJjbGFzc1RhcmdldCIsImFkZGl0aW9uYWxDbGFzc1N1ZmZpeCIsImFkZGl0aW9uYWxDbGFzcyIsImNsYXNzRm9jdXMiLCJjbGFzc0ZvY3VzZWQiLCJjbGFzc0RlZm9jdXNlZCIsImNsYXNzQ2hhcnRUZXh0IiwiY2xhc3NDaGFydEFyYyIsImNsYXNzQ2hhcnRSYWRhciIsInNlbGVjdG9yVGFyZ2V0cyIsImlkc1ZhbHVlIiwic2VsZWN0b3JMZWdlbmQiLCJzZWxlY3RvckxlZ2VuZHMiLCJpbml0Q2xpcCIsImlzSUU5IiwibmF2aWdhdG9yIiwiYXBwVmVyc2lvbiIsIlVSTCIsInBhcmVudCIsImdldEF4aXNDbGlwWCIsImdldEF4aXNDbGlwWSIsImdldFhBeGlzQ2xpcFgiLCJnZXRYQXhpc0NsaXBZIiwiZ2V0WUF4aXNDbGlwWCIsImdldFlBeGlzQ2xpcFkiLCJnZXRBeGlzQ2xpcFdpZHRoIiwiZ2V0QXhpc0NsaXBIZWlnaHQiLCJnZXRYQXhpc0NsaXBXaWR0aCIsImdldFhBeGlzQ2xpcEhlaWdodCIsImdldFlBeGlzQ2xpcFdpZHRoIiwiZ2V0WUF4aXNDbGlwSGVpZ2h0IiwiY29sb3JpemVQYXR0ZXJuIiwicGF0dGVybiIsImNsb25lTm9kZSIsInNjaGVtZUNhdGVnb3J5MTAiLCJnZXRDb2xvckZyb21Dc3MiLCJib2R5Iiwic3BhbiIsImNyZWF0ZUVsZW1lbnQiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiYmFja2dyb3VuZEltYWdlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwidHJpbSIsIkJvb2xlYW4iLCJnZW5lcmF0ZUNvbG9yIiwiY29sb3JzIiwiZDNTY2FsZU9yZGluYWwiLCJvcmlnaW5hbENvbG9yUGF0dGVybiIsInRpbGVzIiwiY29sb3JpemVkUGF0dGVybnMiLCJwYXR0ZXJucyIsImlzTGluZSIsImlzVHlwZU9mIiwiZ2VuZXJhdGVMZXZlbENvbG9yIiwidGhyZXNob2xkIiwiYXNWYWx1ZSIsInVuaXQiLCJsIiwiZ2V0WURvbWFpbk1pbk1heCIsImlzTWluIiwiZGF0YUdyb3VwcyIsImlkc0luR3JvdXAiLCJiYXNlSWQiLCJiYXNlQXhpc0lkIiwibWVldENvbmRpdGlvbiIsImdldFlEb21haW5NaW4iLCJnZXRZRG9tYWluTWF4IiwidGFyZ2V0c0J5QXhpc0lkIiwieVRhcmdldHMiLCJ5TWluIiwieU1heCIsInlEb21haW5NaW4iLCJ5RG9tYWluTWF4IiwiY2VudGVyIiwiaXNaZXJvQmFzZWQiLCJpc0ludmVydGVkIiwic2hvd0hvcml6b250YWxEYXRhTGFiZWwiLCJzaG93VmVydGljYWxEYXRhTGFiZWwiLCJpc0FsbFBvc2l0aXZlIiwiaXNBbGxOZWdhdGl2ZSIsInlEb21haW5BYnMiLCJnZXRYRG9tYWluTWluTWF4IiwiZ2V0WERvbWFpbk1pbiIsImdldFhEb21haW5NYXgiLCJnZXRYRG9tYWluUGFkZGluZyIsIm1heERhdGFDb3VudCIsInhQYWRkaW5nIiwiZmlyc3RYIiwibGFzdFgiLCJnZXRUaW1lIiwid2l0aFRyaW0iLCJkb21haW5WYWx1ZSIsImdldEZvcm1hdCIsInR5cGVWYWx1ZSIsImRlZmF1bHRWYWx1ZUZvcm1hdCIsImdldFlGb3JtYXQiLCJmb3JBcmMiLCJmb3JtYXRGb3JZIiwieUZvcm1hdCIsImZvcm1hdEZvclkyIiwieTJGb3JtYXQiLCJkZWZhdWx0QXJjVmFsdWVGb3JtYXQiLCJkZWZhdWx0Rm9ybWF0IiwiZ2V0R3JpZFRleHRBbmNob3IiLCJnZXRHcmlkVGV4dER4IiwiZ2V0R3JpZFRleHRYIiwiaW5pdEdyaWQiLCJpbml0R3JpZExpbmVzIiwiaW5pdEZvY3VzR3JpZCIsImQzU2VsZWN0QWxsIiwid2l0aG91dFVwZGF0ZSIsInhncmlkRGF0YSIsImdlbmVyYXRlR3JpZERhdGEiLCJ1cGRhdGVZR3JpZCIsImdyaWRWYWx1ZXMiLCJzbW9vdGhMaW5lcyIsInVwZGF0ZUdyaWQiLCJ1cGRhdGVYR3JpZExpbmVzIiwidXBkYXRlWUdyaWRMaW5lcyIsInl2IiwieUxpbmVzIiwicmVkcmF3R3JpZCIsImlzRnJvbnQiLCJkYXRhVG9TaG93IiwiZm9jdXNFbCIsImlzRWRnZSIsInh4IiwieHkiLCJnZXRZU2NhbGUiLCJpc1kyIiwidXBkYXRlZ3JpZEZvY3VzIiwidGlja051bSIsImdyaWREYXRhIiwiZmlyc3RZZWFyIiwiZ2V0RnVsbFllYXIiLCJsYXN0WWVhciIsImdldEdyaWRGaWx0ZXJUb1JlbW92ZSIsInBhcmFtIiwicmVtb3ZlR3JpZExpbmVzIiwiZm9yWCIsInRvUmVtb3ZlIiwiaW5pdExlZ2VuZCIsImxlZ2VuZEl0ZW1UZXh0Qm94IiwidXBkYXRlTGVnZW5kIiwib3B0aW9ueiIsIndpdGhUcmFuc2Zvcm0iLCJ3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSIsInVwZGF0ZUxlZ2VuZFRlbXBsYXRlIiwidXBkYXRlTGVnZW5kRWxlbWVudCIsInVwZGF0ZVNjYWxlcyIsInVwZGF0ZVN2Z1NpemUiLCJ0cmFuc2Zvcm1BbGwiLCJ3cmFwcGVyIiwidGVtcGxhdGUiLCJDT0xPUiIsIlRJVExFIiwiY2hpbGROb2RlcyIsInNldExlZ2VuZEl0ZW0iLCJ1cGRhdGVTaXplRm9yTGVnZW5kIiwiaW5zZXRMZWdlbmRQb3NpdGlvbiIsImdldEN1cnJlbnRQYWRkaW5nVG9wIiwiZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20iLCJnZXRDdXJyZW50UGFkZGluZ0xlZnQiLCJnZXRDdXJyZW50UGFkZGluZ1JpZ2h0IiwiTmFOIiwidHJhbnNmb3JtTGVnZW5kIiwidXBkYXRlTGVnZW5kU3RlcCIsInN0ZXAiLCJ1cGRhdGVMZWdlbmRJdGVtV2lkdGgiLCJ1cGRhdGVMZWdlbmRJdGVtSGVpZ2h0IiwidXBkYXRlTGVnZW5kSXRlbUNvbG9yIiwiZ2V0TGVnZW5kV2lkdGgiLCJnZXRMZWdlbmRIZWlnaHQiLCJvcGFjaXR5Rm9yTGVnZW5kIiwib3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZCIsInRvZ2dsZUZvY3VzTGVnZW5kIiwiZm9jdXMiLCJ0YXJnZXRJZHoiLCJyZXZlcnRMZWdlbmQiLCJzaG93TGVnZW5kIiwiaGlkZUxlZ2VuZCIsImNsZWFyTGVnZW5kSXRlbVRleHRCb3hjYWNoZSIsIml0ZW0iLCJpc1RvdWNoIiwiaGFzR2F1Z2UiLCJpdGVtQ2xhc3MiLCJhbHRLZXkiLCJoaWRlIiwic2hvdyIsInJldmVydCIsInVuZG9NYXJrT3ZlcmxhcHBlZCIsIm1hcmtPdmVybGFwcGVkIiwieEZvckxlZ2VuZCIsInlGb3JMZWdlbmQiLCJwb3NNaW4iLCJ0aWxlV2lkdGgiLCJtYXhIZWlnaHQiLCJ0b3RhbExlbmd0aCIsIm9mZnNldHMiLCJ3aWR0aHMiLCJoZWlnaHRzIiwibWFyZ2lucyIsInN0ZXBzIiwiaXNMZWdlbmRSaWdodE9ySW5zZXQiLCJnZXRUZXh0Qm94IiwidGV4dEVsZW1lbnQiLCJnZXRUZXh0UmVjdCIsInVwZGF0ZVBvc2l0aW9ucyIsImlzTGFzdCIsImJveCIsIml0ZW1XaWR0aCIsIml0ZW1IZWlnaHQiLCJpdGVtTGVuZ3RoIiwiYXJlYUxlbmd0aCIsInVwZGF0ZVZhbHVlcyIsImlkMiIsIndpdGhvdXRTdGVwIiwibWF4TGVuZ3RoIiwieEZvckxlZ2VuZFRleHQiLCJ4Rm9yTGVnZW5kUmVjdCIsIngxRm9yTGVnZW5kVGlsZSIsIngyRm9yTGVnZW5kVGlsZSIsInlGb3JMZWdlbmRUZXh0IiwieUZvckxlZ2VuZFJlY3QiLCJ5Rm9yTGVnZW5kVGlsZSIsInVzZVBvaW50IiwiY3JlYXRlRWxlbWVudE5TIiwiZDNOYW1lc3BhY2VzIiwiaGFzVmFsaWRQb2ludFR5cGUiLCJpZHgiLCJub2RlTmFtZSIsInJlY3RzIiwicG9pbnRSIiwieE9mZnNldCIsInlPZmZzZXQiLCJsZXZlbENvbG9yIiwiaW5pdFJlZ2lvbiIsInVwZGF0ZVJlZ2lvbiIsInJlZHJhd1JlZ2lvbiIsInJlZ2lvblkiLCJyZWdpb25IZWlnaHQiLCJnZXRSZWdpb25YWSIsImN1cnJTY2FsZSIsImdldFJlZ2lvblNpemUiLCJpc1dpZHRoIiwiZ2V0U2NhbGUiLCJmb3JUaW1lc2VyaWVzIiwiZDNTY2FsZVRpbWUiLCJnZXRYIiwib2Zmc2V0IiwiZ2V0WSIsInNjYWxlVmFsdWUiLCJvZmZzZXRWYWx1ZSIsInJhdyIsImdldFN1YllTY2FsZSIsInhTdWJEb21haW4iLCJ5VGlja1ZhbHVlcyIsInkyVGlja1ZhbHVlcyIsInVwZGF0ZUFyYyIsInNlbGVjdFBvaW50IiwiY2lyY2xlWCIsInBvaW50U2VsZWN0UiIsInVuc2VsZWN0UG9pbnQiLCJtZXRob2QiLCJzZWxlY3RQYXRoIiwiZDNSZ2IiLCJicmlnaHRlciIsInVuc2VsZWN0UGF0aCIsImdldFRvZ2dsZSIsInRoYXQiLCJ0b2dnbGVkU2hhcGUiLCJzZXRDb250YWluZXJTaXplIiwiZ2V0Q3VycmVudFdpZHRoIiwiZ2V0Q3VycmVudEhlaWdodCIsImdldFBhcmVudFdpZHRoIiwiZ2V0UGFyZW50SGVpZ2h0IiwiZ2V0QXhpc1NpemUiLCJnZXRBeGlzV2lkdGhCeUF4aXNJZCIsImdldEhvcml6b250YWxBeGlzSGVpZ2h0IiwiYXhlc0xlbiIsImdldFRpdGxlUGFkZGluZyIsImF4aXNXaWR0aCIsImxlZ2VuZFdpZHRoT25SaWdodCIsImdldFBhcmVudFJlY3RWYWx1ZSIsIm9mZnNldE5hbWUiLCJ0YWdOYW1lIiwiYm9keVdpZHRoIiwib2Zmc2V0V2lkdGgiLCJwYXJzZUludCIsImdldFN2Z0xlZnQiLCJoYXNMZWZ0QXhpc1JlY3QiLCJsZWZ0QXhpc0NsYXNzIiwibGVmdEF4aXMiLCJzdmdSZWN0IiwiY2hhcnRSZWN0IiwiaGFzQXJjIiwic3ZnTGVmdCIsImNvcyIsImluaXRUZXh0IiwidXBkYXRlVGFyZ2V0c0ZvclRleHQiLCJtYWluVGV4dFVwZGF0ZSIsIm1haW5UZXh0RW50ZXIiLCJ1cGRhdGVUZXh0IiwiZGF0YUZuIiwibGFiZWxpc2hEYXRhIiwiaXNSYWRhclR5cGUiLCJ1cGRhdGVUZXh0Q29sb3IiLCJsYWJlbENvbG9ycyIsInJlZHJhd1RleHQiLCJmb3JGbG93IiwiZWxlbWVudCIsImJhc2UiLCJxdWVyeVNlbGVjdG9yIiwidGV4dENvbnRlbnQiLCJnZW5lcmF0ZVhZRm9yVGV4dCIsInBvaW50cyIsImdldHRlciIsImdldFhGb3JUZXh0IiwiZ2V0WUZvclRleHQiLCJpc0FyZWFUeXBlIiwiZ2V0Q2VudGVyZWRUZXh0UG9zIiwiY2VudGVyZWQiLCJpc1Bvc2l0aXZlIiwiZ2V0VGV4dFBvcyIsInhQb3MiLCJ5UG9zIiwiYmFzZVkiLCJpc0xpbmVUeXBlIiwiYm94SGVpZ2h0IiwidGV4dE5vZGVzIiwiZmlsdGVyZWRUZXh0Tm9kZXMiLCJ0ZXh0Tm9kZSIsInRyYW5zbGF0ZSIsImNhbGNIeXBvIiwiY29vcmRpbmF0ZSIsImZpbHRlcmVkVGV4dE5vZGUiLCJub2RlRm9yV2lkdGgiLCJvdmVybGFwc1giLCJnZXRDb21wdXRlZFRleHRMZW5ndGgiLCJvdmVybGFwc1kiLCJwcmV2aW91c1NpYmxpbmciLCJpc051bSIsImluaXRUaXRsZSIsInJlZHJhd1RpdGxlIiwieUZvclRpdGxlIiwieEZvclRpdGxlIiwidGV4dFJlY3RXaWR0aCIsImluaXRUb29sdGlwIiwiZ2V0VG9vbHRpcEhUTUwiLCJnZXRUb29sdGlwQ29udGVudCIsImRlZmF1bHRUaXRsZUZvcm1hdCIsInRpdGxlRm9ybWF0IiwibmFtZUZvcm1hdCIsInZhbHVlRm9ybWF0IiwiZ2V0Um93VmFsdWUiLCJnZXRCZ0NvbG9yIiwiY29udGVudHMiLCJ0cGxTdHIiLCJpMiIsImdldFRvb2x0aXBDb250ZW50VGVtcGxhdGUiLCJDTEFTU19UT09MVElQIiwiaGlnaCIsImxvdyIsImNvbnRlbnRWYWx1ZSIsIkNMQVNTX1RPT0xUSVBfTkFNRSIsIk5BTUUiLCJWQUxVRSIsInRvb2x0aXBQb3NpdGlvbiIsInRXaWR0aCIsInRIZWlnaHQiLCJjaGFydFJpZ2h0IiwiZGF0YVNjYWxlIiwicG9zaXRpb25GdW5jdGlvbiIsImRhdGFTdHIiLCJzdHJpbmdpZnkiLCJwcm9wZXJ0eSIsImNoYXJ0cyIsImxpbmtlZE5hbWUiLCJpbnRlcm5hbCIsImlzTGlua2VkIiwiaXNJbkRvbSIsImNvbnRhaW5zIiwiaXNOb3RTYW1lSW5kZXgiLCJUWVBFUyIsIkFyZWEiLCJBcmVhUmFuZ2UiLCJBcmMiLCJMaW5lIiwiU3RlcCIsIlNwbGluZSIsImhhc1R5cGVPZiIsImV4Y2x1ZGUiLCJkYXRhVHlwZSIsImhhc011bHRpQXJjR2F1Z2UiLCJpc1NwbGluZVR5cGUiLCJpc1BpZVR5cGUiLCJpc0dhdWdlVHlwZSIsImlzRG9udXRUeXBlIiwiaXNBcmNUeXBlIiwiYXJjRGF0YSIsImJhckxpbmVCdWJibGVEYXRhIiwiaXNJbnRlcnBvbGF0aW9uVHlwZSIsImluaXRQaWUiLCJzdGFydGluZ0FuZ2xlIiwiZDNQaWUiLCJzb3J0VmFsdWVzIiwidXBkYXRlUmFkaXVzIiwiZ2V0SW5uZXJSYWRpdXMiLCJzdmdBcmMiLCJnZXRTdmdBcmMiLCJzdmdBcmNFeHBhbmRlZCIsImdldFN2Z0FyY0V4cGFuZGVkIiwidXBkYXRlQW5nbGUiLCJkVmFsdWUiLCJnU3RhcnQiLCJ0b3RhbFN1bSIsImdFbmQiLCJnTWluIiwiZ01heCIsImdWYWx1ZSIsImlyIiwic2luZ2xlQXJjV2lkdGgiLCJkM0FyYyIsIm91dGVyUmFkaXVzIiwibmV3QXJjIiwidXBkYXRlZCIsImNlbnRyb2lkIiwicmF0ZSIsIm5ld1JhdGUiLCJleHBhbmRXaWR0aCIsImdldEFyYyIsInRyYW5zZm9ybUZvckFyY0xhYmVsIiwiY29udmVydFRvQXJjRGF0YSIsInRleHRGb3JBcmNMYWJlbCIsInNob3VsZFNob3dBcmNMYWJlbCIsImlzVW5kZXJUaHJlc2hvbGQiLCJtZWV0c0FyY0xhYmVsVGhyZXNob2xkIiwiZ2V0QXJjTGFiZWxGb3JtYXQiLCJ0ZXh0Rm9yR2F1Z2VNaW5NYXgiLCJpc01heCIsImdldEdhdWdlTGFiZWxFeHRlbnRzIiwiZXhwYW5kQXJjIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwibmV3VGFyZ2V0SWRzIiwic2hvdWxkRXhwYW5kIiwiZXhwYW5kRHVyYXRpb24iLCJnZXRFeHBhbmRDb25maWciLCJzdmdBcmNFeHBhbmRlZFN1YiIsInVuZXhwYW5kQXJjIiwiZ2V0QXJjVGl0bGUiLCJ1cGRhdGVUYXJnZXRzRm9yQXJjIiwibWFpblBpZVVwZGF0ZSIsIm1haW5QaWVFbnRlciIsImluaXRBcmMiLCJzZXRBcmNUaXRsZSIsInJlZHJhd0FyYyIsImhhc0ludGVyYWN0aW9uIiwibWFpbkFyYyIsIl9jdXJyZW50IiwicmVkcmF3TXVsdGlBcmNHYXVnZSIsImF0dHJUd2VlbiIsImludGVycG9sYXRlIiwiZDNJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImJpbmRBcmNFdmVudCIsInJlZHJhd0FyY1RleHQiLCJhcmNMYWJlbExpbmVzIiwibWFpbkFyY0xhYmVsTGluZSIsImxpbmVMZW5ndGgiLCJsaW5lVGhpY2tuZXNzIiwiaW5uZXJMaW5lTGVuZ3RoIiwibGluZUFuZ2xlIiwiYXJjSW5uZXJSYWRpdXMiLCJsaW5lUG9zaXRpb25pbmdBbmdsZSIsInNlbGVjdEFyYyIsIl90aGlzIiwidW5zZWxlY3RBcmMiLCJpc01vdXNlIiwicmFkYXJzIiwiZ2V0RXZlbnRBcmMiLCJldmVudEFyYyIsImhhbmRsZXIiLCJpc0Z1bGxDaXJjbGUiLCJiYWNrZ3JvdW5kQXJjIiwiZDEiLCJpbml0R2F1Z2UiLCJhcHBlbmRUZXh0IiwiZ2V0R2F1Z2VMYWJlbEhlaWdodCIsImluaXRCYXIiLCJ1cGRhdGVUYXJnZXRzRm9yQmFyIiwibWFpbkJhclVwZGF0ZSIsIm1haW5CYXJFbnRlciIsInVwZGF0ZUJhciIsInJlZHJhd0JhciIsImdldEJhclciLCJiYXJUYXJnZXRzTnVtIiwicmVzdWx0IiwiZ2V0V2lkdGgiLCJnZXRCYXJzIiwic3VmZml4IiwiZ2VuZXJhdGVEcmF3QmFyIiwiYmFySW5kaWNlcyIsImlzU3ViIiwiZ2V0UG9pbnRzIiwiZ2VuZXJhdGVHZXRCYXJQb2ludHMiLCJiYXJSYWRpdXMiLCJiYXJSYWRpdXNSYXRpbyIsImdldFJhZGl1cyIsImluZGV4WCIsImluZGV4WSIsImlzTmVnYXRpdmUiLCJwYXRoUmFkaXVzIiwiYmFyVyIsImdldEluZGljZXNNYXgiLCJiYXJYIiwiZ2V0U2hhcGVYIiwiYmFyWSIsImdldFNoYXBlWSIsImJhck9mZnNldCIsImdldFNoYXBlT2Zmc2V0IiwieVNjYWxlIiwieTAiLCJwb3NYIiwicG9zWSIsInNlZzAiLCJzZWcxIiwiaW5pdEJ1YmJsZSIsImdldEJhc2VMZW5ndGgiLCJiYXNlTGVuZ3RoIiwiZ2V0QnViYmxlUiIsIm1heFIiLCJtaWQiLCJtYXhBcmVhIiwiaW5pdExpbmUiLCJ1cGRhdGVUYXJnZXRzRm9yTGluZSIsIm1haW5MaW5lVXBkYXRlIiwibWFpbkxpbmVFbnRlciIsInVwZGF0ZUxpbmUiLCJleHRyYUxpbmVDbGFzc2VzIiwicmVkcmF3TGluZSIsImdldEN1cnZlIiwiaXNSb3RhdGVkU3RlcFR5cGUiLCJnZXRJbnRlcnBvbGF0ZSIsIm9yZ1BvaW50IiwicG9pbnRSb3RhdGVkIiwiX3BvaW50IiwiX3kiLCJfdCIsIl9jb250ZXh0IiwibGluZVRvIiwiX3giLCJnZW5lcmF0ZURyYXdMaW5lIiwibGluZUluZGljZXMiLCJsaW5lQ29ubmVjdE51bGwiLCJnZW5lcmF0ZUdldExpbmVQb2ludHMiLCJ5U2NhbGVHZXR0ZXIiLCJ4VmFsdWUiLCJzdWJ4eCIsInlWYWx1ZSIsImQzTGluZSIsImRlZmluZWQiLCJ4MCIsImxpbmVXaXRoUmVnaW9ucyIsImN1cnZlIiwiaXNTdWJWYWx1ZSIsImxpbmVPZmZzZXQiLCJfcmVnaW9ucyIsInhwIiwieXAiLCJkaWZmeDIiLCJkYXNoYXJyYXkiLCJpc1dpdGhpblJlZ2lvbnMiLCJ3aXRoaW5YIiwid2l0aGluUmVnaW9ucyIsInJlZyIsImdldFZhbHVlIiwiZHQiLCJnZW5lcmF0ZU0iLCJzV2l0aFJlZ2lvbiIsImQwIiwidGltZXNlcmllc0RpZmYiLCJ4RGlmZiIsInh2MCIsInh2MSIsIm90aGVyRGlmZiIsInByZXZEYXRhIiwiaGFzUHJldkRhdGEiLCJkZCIsInVwZGF0ZUFyZWFHcmFkaWVudCIsInN0b3BzIiwibGluZWFyR3JhZGllbnQiLCJzdG9wQ29sb3IiLCJ1cGRhdGVBcmVhQ29sb3IiLCJ1cGRhdGVBcmVhIiwicmVkcmF3QXJlYSIsImdlbmVyYXRlRHJhd0FyZWEiLCJhcmVhSW5kaWNlcyIsImdlbmVyYXRlR2V0QXJlYVBvaW50cyIsInZhbHVlMCIsInZhbHVlMSIsImQzQXJlYSIsImFyZWFPZmZzZXQiLCJ1cGRhdGVDaXJjbGUiLCJzaG91bGREcmF3UG9pbnRzRm9yTGluZSIsImluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlIiwicmVkcmF3Q2lyY2xlIiwibWFpbkNpcmNsZXMiLCJvcGFjaXR5Rm9yQ2lyY2xlIiwicG9zQXR0ciIsInVwZGF0ZUNpcmNsZVkiLCJnZXRTaGFwZUluZGljZXMiLCJnZXRDaXJjbGVzIiwicG9pbnRFeHBhbmRlZFIiLCJzZWxlY3RSIiwiaXNXaXRoaW5DaXJjbGUiLCJpc1dpdGhpblN0ZXAiLCJsaW5lUG9pbnQiLCJoYXNWYWxpZFBvaW50RHJhd01ldGhvZHMiLCJwb2ludFR5cGUiLCJpbnNlcnRQb2ludEluZm9EZWZzIiwiY29weUF0dHIiLCJmcm9tIiwiYXR0cmlicyIsImF0dHJpYnV0ZXMiLCJzZXRBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJET01QYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJjbG9uZSIsImZpbGwiLCJzdHJva2UiLCJpbm5lckhUTUwiLCJwb2ludEZyb21EZWZzIiwicG9pbnRDbGFzcyIsImdlbmVyYXRlUG9pbnQiLCJwb2ludElkIiwiY3VzdG9tIiwiZ2V0VHJhbnNpdGlvbk5hbWUiLCJzaXplRm4iLCJmaWxsU3R5bGVGbiIsInhQb3NGbiIsInlQb3NGbiIsIm9wYWNpdHlTdHlsZUZuIiwieFBvc0ZuMiIsInRyYW5zaXRpb25OYW1lIiwicmVjdGFuZ2xlIiwicmVjdFNpemVGbiIsInJlY3RYUG9zRm4iLCJnZXRQb3NpdGlvbiIsImlzQ2xvY2t3aXNlIiwiZWRnZSIsImZ1bmMiLCJpbml0UmFkYXIiLCJnZXRSYWRhclNpemUiLCJ1cGRhdGVUYXJnZXRzRm9yUmFkYXIiLCJnZW5lcmF0ZVJhZGFyUG9pbnRzIiwiZ2V0UmFkYXJQb3NpdGlvbiIsIl9zaXplIiwicmVkcmF3UmFkYXIiLCJ1cGRhdGVSYWRhckxldmVsIiwidXBkYXRlUmFkYXJBeGVzIiwidXBkYXRlUmFkYXJTaGFwZSIsImdlbmVyYXRlR2V0UmFkYXJQb2ludHMiLCJkZXB0aCIsInNob3dUZXh0IiwicmFkYXJMZXZlbHMiLCJsZXZlbERhdGEiLCJsZXZlbFJhdGlvIiwibGV2ZWxUZXh0Rm9ybWF0Iiwiam9pbiIsImxldmVsRW50ZXIiLCJheGlzRW50ZXIiLCJmaXJzdENoaWxkIiwiYmluZEV2ZW50Iiwibm9JbmRleCIsImFyZWFzRW50ZXIiLCJyYWRhckNpcmNsZVgiLCJyYWRhckNpcmNsZVkiLCJ0eXBlRmlsdGVyIiwiaGFzWHMiLCJncm91cHMiLCJpbmQiLCJfX21heF9fIiwiZ2V0SW5kaWNlcyIsImJhclBhZGRpbmciLCJoYWxmV2lkdGgiLCJ0YXJnZXRzTnVtIiwiZ2V0U2hhcGVPZmZzZXREYXRhIiwic2hhcGVPZmZzZXRUYXJnZXRzIiwicm93VmFsdWVzIiwicm93VmFsdWVNYXBCeVhWYWx1ZSIsImluZGV4TWFwQnlUYXJnZXRJZCIsImRhdGFYQXNOdW1iZXIiLCJyb3dWYWx1ZSIsImludGVycG9sYXRpb24iLCJnZXRJbnRlcnBvbGF0ZVR5cGUiLCJkM0N1cnZlQmFzaXMiLCJkM0N1cnZlQmFzaXNDbG9zZWQiLCJkM0N1cnZlQmFzaXNPcGVuIiwiZDNDdXJ2ZUJ1bmRsZSIsImQzQ3VydmVDYXJkaW5hbCIsImQzQ3VydmVDYXJkaW5hbENsb3NlZCIsImQzQ3VydmVDYXJkaW5hbE9wZW4iLCJkM0N1cnZlQ2F0bXVsbFJvbSIsImQzQ3VydmVDYXRtdWxsUm9tQ2xvc2VkIiwiZDNDdXJ2ZUNhdG11bGxSb21PcGVuIiwiZDNDdXJ2ZU1vbm90b25lWCIsImQzQ3VydmVNb25vdG9uZVkiLCJkM0N1cnZlTmF0dXJhbCIsImQzQ3VydmVMaW5lYXJDbG9zZWQiLCJkM0N1cnZlTGluZWFyIiwiZDNDdXJ2ZVN0ZXAiLCJkM0N1cnZlU3RlcEFmdGVyIiwiZDNDdXJ2ZVN0ZXBCZWZvcmUiLCJDaGFydEludGVybmFsIiwiZGF0YVRpbWUiLCJTdG9yZSIsImJlZm9yZUluaXQiLCJjYWxsUGx1Z2luSG9vayIsImFmdGVySW5pdCIsImluaXRQYXJhbXMiLCJjbGFzc25hbWUiLCJpbml0VG9SZW5kZXIiLCJmb3JjZWQiLCJpc0xhenkiLCJsYXp5IiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJtdXRhdGlvbiIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsImF0dHJpYnV0ZUZpbHRlciIsImNvbnZlcnRlZERhdGEiLCJpbml0V2l0aERhdGEiLCJkM1RpbWVQYXJzZSIsImQzVXRjUGFyc2UiLCJkM1RpbWVGb3JtYXQiLCJkM1V0Y0Zvcm1hdCIsImlzRHJhZ1pvb20iLCJpc1pvb21lZCIsInNwZWNpZmllciIsImdldE1pbGxpc2Vjb25kcyIsImdldFNlY29uZHMiLCJnZXRNaW51dGVzIiwiZ2V0SG91cnMiLCJnZXREYXRlIiwiZ2V0TW9udGgiLCJyb3RhdGVkUGFkZGluZ1JpZ2h0IiwiY29udmVydElucHV0VHlwZSIsInVwZGF0ZVNpemVzIiwiY2xpcFlBeGlzIiwiaW5pdENoYXJ0RWxlbWVudHMiLCJ1cGRhdGVEaW1lbnNpb24iLCJzZXRCYWNrZ3JvdW5kIiwid2l0aFRyYW5zaXRpb25Gb3JBeGlzIiwiaW5pdGlhbGl6aW5nIiwiYmluZFJlc2l6ZSIsInNldENoYXJ0RWxlbWVudHMiLCIkIiwiYmciLCJpbWdVcmwiLCJjdXJyTGVnZW5kIiwibGVnZW5kSGVpZ2h0Rm9yQm90dG9tIiwieEF4aXNIZWlnaHQiLCJzdWJjaGFydFhBeGlzSGVpZ2h0Iiwic3ViY2hhcnRIZWlnaHQiLCJzaG93VGFyZ2V0cyIsImdldFdpdGhPcHRpb24iLCJ3aXRoT3B0aW9ucyIsIlN1YmNoYXJ0IiwiRXZlbnRSZWN0IiwiRGltZW5zaW9uIiwiVHJhbnNmb3JtIiwiTGVnZW5kIiwiVHJhbnNpdGlvbkZvckV4aXQiLCJUcmFuc2l0aW9uRm9yQXhpcyIsImRlZlZhbCIsInRyYW5zaXRpb25zVmFsdWUiLCJkdXJhdGlvbkZvckF4aXMiLCJnZW5lcmF0ZVJlZHJhd0xpc3QiLCJnZXREcmF3U2hhcGUiLCJmbG93Rm4iLCJpc1RyYW5zaXRpb24iLCJpc1RhYlZpc2libGUiLCJyZWRyYXdMaXN0IiwiZ2V0UmVkcmF3TGlzdCIsImFmdGVyUmVkcmF3Iiwid2FpdEZvckRyYXciLCJoYXNSYWRhciIsInVwZGF0ZUFuZFJlZHJhdyIsIndpdGhUcmFuc2l0aW9uRm9yRXhpdCIsInJlZHJhd1dpdGhvdXRSZXNjYWxlIiwidHJhbnNmb3JtTWFpbiIsInhBeGlzIiwieUF4aXMiLCJ5MkF4aXMiLCJ3aXRob3V0QXhpcyIsInJlc2l6ZUZ1bmN0aW9uIiwiZ2VuZXJhdGVSZXNpemUiLCJyZXNpemVUaW1lb3V0IiwiZmx1c2giLCJhZGRFdmVudExpc3RlbmVyIiwiY2FsbFJlc2l6ZUZ1bmN0aW9ucyIsInJlc2l6ZUZ1bmN0aW9ucyIsInRyYW5zaXRpb25zVG9XYWl0IiwibG9vcCIsInRpbWVyIiwicGFyc2VkRGF0ZSIsImhpZGRlbiIsImlzTW9iaWxlIiwidXNlckFnZW50IiwiaGFzVG91Y2hQb2ludHMiLCJtYXhUb3VjaFBvaW50cyIsImhhc1RvdWNoIiwiRG9jdW1lbnRUb3VjaCIsImhhc01vdXNlIiwicGhhc2UiLCJwcm90b3R5cGUiLCJkYXRhQ29udmVydCIsImRhdGFMb2FkIiwiY2F0ZWdvcnkiLCJjbGFzc01vZHVsZSIsImxvYWRDb25maWciLCJyZWFkIiwidGhpc0NvbmZpZyIsImZpbmQiLCJzZXRNaW5NYXgiLCJyZXNpemUiLCJzb2Z0IiwiX2lzRnJvbVJlc2l6ZSIsImRlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZmxhdCIsImRhdGFWYWx1ZSIsIm5hbWVzIiwiYjY0RW5jb2RlVW5pY29kZSIsImJ0b2EiLCJlbmNvZGVVUklDb21wb25lbnQiLCJtYXRjaCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm5vZGVUb1N2Z0RhdGFVcmwiLCJzZXJpYWxpemVyIiwiWE1MU2VyaWFsaXplciIsImNzc1RleHQiLCJ4aHRtbCIsIm5vZGVYbWwiLCJzZXJpYWxpemVUb1N0cmluZyIsImNyZWF0ZVRleHROb2RlIiwic3R5bGVYbWwiLCJleHBvcnQiLCJzdmdEYXRhVXJsIiwiaW1nIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9ubG9hZCIsImNhbnZhcyIsImdldENvbnRleHQiLCJkcmF3SW1hZ2UiLCJ0b0RhdGFVUkwiLCJzcmMiLCJ0byIsInRhaWwiLCJub3Rmb3VuZElkcyIsIm1pc3NpbmciLCJiYXNlVGFyZ2V0IiwiYmFzZVZhbHVlIiwid2l0aFRyaW1YRG9tYWluIiwid2l0aFVwZGF0ZVhBeGlzIiwidGFyZ2V0SWRzVmFsdWUiLCJkZWZvY3VzIiwiZ3JpZHMiLCJodHRwIiwiYXJnc1ZhbHVlIiwib3B0aW9uc1ZhbHVlIiwiZGF0YVBvaW50IiwicmVzZXRPdGhlciIsImlzVGFyZ2V0SWQiLCJpc1RhcmdldEluZGV4IiwidW5zZWxlY3QiLCJzaG93SGlkZSIsImV2ZW50TmFtZSIsIndpdGhpblJhbmdlIiwicmVzdWx0RG9tYWluIiwiZW5hYmxlIiwiZW5hYmxlZCIsImVuYWJsZVR5cGUiLCJkM1pvb21JZGVudGl0eSIsImQzWm9vbVRyYW5zZm9ybSIsIkNoYXJ0IiwiYmluZFRoaXMiLCJhcmdUaGlzIiwiaXNGdW5jIiwiaXNDaGlsZCIsImhhc0NoaWxkIiwiYXBpQXhpcyIsImFwaUNhdGVnb3J5IiwiYXBpQ2hhcnQiLCJhcGlDb2xvciIsImFwaURhdGEiLCJhcGlFeHBvcnQiLCJhcGlGbG93IiwiYXBpRm9jdXMiLCJhcGlYR3JpZCIsImFwaVlHcmlkIiwiYXBpR3JvdXAiLCJhcGlMZWdlbmQiLCJhcGlMb2FkIiwiYXBpUmVnaW9uIiwiYXBpU2VsZWN0aW9uIiwiYXBpU2hvdyIsImFwaVRvb2x0aXAiLCJhcGlYIiwiYXBpWm9vbSIsImRlZmF1bHRzIiwiYmIiLCJ2ZXJzaW9uIiwiZ2VuZXJhdGUiLCJpbnN0IiwiaW5zdGFuY2UiLCJwbHVnaW4iXSwibWFwcGluZ3MiOiJBQUFBO0FB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LFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsdUlBQXVJO0FBQzFJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxtRUFBbUU7QUFDdEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsc0ZBQXNGO0FBQ3pGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSxzSEFBc0g7QUFDekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSx3TkFBd047QUFDM047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0QsV0FBVztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLDhYQUE4WDtBQUNqWTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFNBQVM7QUFDekM7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsZ0ZBQWdGO0FBQ25GO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLENBQUMscUlBQXFJOztBQUV0SSxDQUFDLEdBQUc7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsd0dBQXdHO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUMsRUFBRSxxRkFBcUY7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRTs7QUFFeEIsQ0FBQyxFQUFFLCtJQUErSTtBQUNsSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxxREFBcUQ7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFLDBIQUEwSDs7QUFFbEosQ0FBQyxFQUFFLHlHQUF5RztBQUM1RztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMEJBQTBCLHFEQUFxRCxtQkFBbUIsV0FBVztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsa0lBQWtJO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUU7O0FBRXhCLENBQUMsRUFBRSxvQ0FBb0M7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMsYUFBYSxRQUFRLEVBQUUsMEhBQTBIOztBQUVsSixDQUFDLEVBQUUsd0RBQXdEO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxhQUFhLFFBQVEsRUFBRSwwSEFBMEg7O0FBRWxKLENBQUMsRUFBRSx5R0FBeUc7QUFDNUc7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUsaUNBQWlDO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7QUFDaEMsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDLEVBQUUseUJBQXlCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsQ0FBQyxFQUFFLGlDQUFpQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDLGFBQWEsUUFBUSxFQUFFOztBQUV4QixDQUFDLEVBQUUsa0dBQWtHO0FBQ3JHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsQ0FBQyxFQUFFLCtGQUErRjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQzs7QUFFQSxDQUFDLEVBQUUsMEVBQTBFO0FBQzdFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7O0FBRUEsQ0FBQyxFQUFFLHVHQUF1RztBQUMxRztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsRUFBRSw2SEFBNkg7QUFDaEk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQyxxSUFBcUk7O0FBRXRJLENBQUMsR0FBRztBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxHQUFHO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUMsRUFBRSxXQUFXO0FBQ2Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDLHFJQUFxSTs7QUFFdEksQ0FBQyxFQUFFLGNBQWM7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWU7QUFDZjtBQUNB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QUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDM3RCQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxtQkFBbUIsS0FBMEI7QUFDN0M7QUFDQSxrQkFBa0IsS0FBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVB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Rkc7QUFRaEIsV0FIQWtqRSxJQUFJLENBQUM5aEIsUUFBTCxDQUFjRixNQUFkLEdBQXVCLEtBQUtpaUIsUUFHNUIsRUFGQSxLQUFLQSxRQUFMLENBQWMxOEQsSUFBZCxDQUFtQnk4RCxJQUFuQixDQUVBLEVBQU9BLElBQVA7QUFDQSxHQTdDUzs7QUErQ1Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkFKLFVBckVVLG9CQXFFRDlpRSxPQXJFQyxFQXFFUTtBQUtqQixXQUpJSixRQUFRLENBQUNJLE9BQUQsQ0FJWixLQUhDOGlFLFNBQVEsR0FBRzlpRSxPQUdaLEdBQU84aUUsU0FBUDtBQUNBLEdBM0VTOztBQTZFVjs7Ozs7Ozs7Ozs7QUFXQUssVUFBUSxFQUFFLEVBeEZBOztBQTBGVjs7Ozs7Ozs7QUFRQUMsUUFBTSxFQUFFO0FBbEdFLEM7QUFKWCIsImZpbGUiOiJiaWxsYm9hcmQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJkMy10aW1lLWZvcm1hdFwiKSwgcmVxdWlyZShcImQzLXNlbGVjdGlvblwiKSwgcmVxdWlyZShcImQzLXRyYW5zaXRpb25cIiksIHJlcXVpcmUoXCJkMy1icnVzaFwiKSwgcmVxdWlyZShcImQzLWF4aXNcIiksIHJlcXVpcmUoXCJkMy1zY2FsZVwiKSwgcmVxdWlyZShcImQzLWRzdlwiKSwgcmVxdWlyZShcImQzLWVhc2VcIiksIHJlcXVpcmUoXCJkMy1kcmFnXCIpLCByZXF1aXJlKFwiZDMtem9vbVwiKSwgcmVxdWlyZShcImQzLWNvbG9yXCIpLCByZXF1aXJlKFwiZDMtc2hhcGVcIiksIHJlcXVpcmUoXCJkMy1pbnRlcnBvbGF0ZVwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJkMy10aW1lLWZvcm1hdFwiLCBcImQzLXNlbGVjdGlvblwiLCBcImQzLXRyYW5zaXRpb25cIiwgXCJkMy1icnVzaFwiLCBcImQzLWF4aXNcIiwgXCJkMy1zY2FsZVwiLCBcImQzLWRzdlwiLCBcImQzLWVhc2VcIiwgXCJkMy1kcmFnXCIsIFwiZDMtem9vbVwiLCBcImQzLWNvbG9yXCIsIFwiZDMtc2hhcGVcIiwgXCJkMy1pbnRlcnBvbGF0ZVwiXSwgZmFjdG9yeSk7XG5cdGVsc2Uge1xuXHRcdHZhciBhID0gdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZmFjdG9yeShyZXF1aXJlKFwiZDMtdGltZS1mb3JtYXRcIiksIHJlcXVpcmUoXCJkMy1zZWxlY3Rpb25cIiksIHJlcXVpcmUoXCJkMy10cmFuc2l0aW9uXCIpLCByZXF1aXJlKFwiZDMtYnJ1c2hcIiksIHJlcXVpcmUoXCJkMy1heGlzXCIpLCByZXF1aXJlKFwiZDMtc2NhbGVcIiksIHJlcXVpcmUoXCJkMy1kc3ZcIiksIHJlcXVpcmUoXCJkMy1lYXNlXCIpLCByZXF1aXJlKFwiZDMtZHJhZ1wiKSwgcmVxdWlyZShcImQzLXpvb21cIiksIHJlcXVpcmUoXCJkMy1jb2xvclwiKSwgcmVxdWlyZShcImQzLXNoYXBlXCIpLCByZXF1aXJlKFwiZDMtaW50ZXJwb2xhdGVcIikpIDogZmFjdG9yeShyb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0sIHJvb3RbXCJkM1wiXSwgcm9vdFtcImQzXCJdLCByb290W1wiZDNcIl0pO1xuXHRcdGZvcih2YXIgaSBpbiBhKSAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnID8gZXhwb3J0cyA6IHJvb3QpW2ldID0gYVtpXTtcblx0fVxufSkodGhpcywgZnVuY3Rpb24oX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzZfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzhfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzlfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDFfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDJfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDNfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDRfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDVfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDZfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDhfXykge1xucmV0dXJuICIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxKTtcbiIsIid1c2Ugc3RyaWN0Jztcbi8qIGdsb2JhbCBfX3Jlc291cmNlUXVlcnkgV29ya2VyR2xvYmFsU2NvcGUgc2VsZiAqL1xuXG4vKiBlc2xpbnQgcHJlZmVyLWRlc3RydWN0dXJpbmc6IG9mZiAqL1xuXG52YXIgc3RyaXBBbnNpID0gcmVxdWlyZSgnc3RyaXAtYW5zaScpO1xuXG52YXIgc29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxudmFyIG92ZXJsYXkgPSByZXF1aXJlKCcuL292ZXJsYXknKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKSxcbiAgICBsb2cgPSBfcmVxdWlyZS5sb2csXG4gICAgc2V0TG9nTGV2ZWwgPSBfcmVxdWlyZS5zZXRMb2dMZXZlbDtcblxudmFyIHNlbmRNZXNzYWdlID0gcmVxdWlyZSgnLi91dGlscy9zZW5kTWVzc2FnZScpO1xuXG52YXIgcmVsb2FkQXBwID0gcmVxdWlyZSgnLi91dGlscy9yZWxvYWRBcHAnKTtcblxudmFyIGNyZWF0ZVNvY2tldFVybCA9IHJlcXVpcmUoJy4vdXRpbHMvY3JlYXRlU29ja2V0VXJsJyk7XG5cbnZhciBzdGF0dXMgPSB7XG4gIGlzVW5sb2FkaW5nOiBmYWxzZSxcbiAgY3VycmVudEhhc2g6ICcnXG59O1xudmFyIG9wdGlvbnMgPSB7XG4gIGhvdDogZmFsc2UsXG4gIGhvdFJlbG9hZDogdHJ1ZSxcbiAgbGl2ZVJlbG9hZDogZmFsc2UsXG4gIGluaXRpYWw6IHRydWUsXG4gIHVzZVdhcm5pbmdPdmVybGF5OiBmYWxzZSxcbiAgdXNlRXJyb3JPdmVybGF5OiBmYWxzZSxcbiAgdXNlUHJvZ3Jlc3M6IGZhbHNlXG59O1xudmFyIHNvY2tldFVybCA9IGNyZWF0ZVNvY2tldFVybChfX3Jlc291cmNlUXVlcnkpO1xuc2VsZi5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gIHN0YXR1cy5pc1VubG9hZGluZyA9IHRydWU7XG59KTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHZhciBxcyA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2gudG9Mb3dlckNhc2UoKTtcbiAgb3B0aW9ucy5ob3RSZWxvYWQgPSBxcy5pbmRleE9mKCdob3RyZWxvYWQ9ZmFsc2UnKSA9PT0gLTE7XG59XG5cbnZhciBvblNvY2tldE1lc3NhZ2UgPSB7XG4gIGhvdDogZnVuY3Rpb24gaG90KCkge1xuICAgIG9wdGlvbnMuaG90ID0gdHJ1ZTtcbiAgICBsb2cuaW5mbygnW1dEU10gSG90IE1vZHVsZSBSZXBsYWNlbWVudCBlbmFibGVkLicpO1xuICB9LFxuICBsaXZlUmVsb2FkOiBmdW5jdGlvbiBsaXZlUmVsb2FkKCkge1xuICAgIG9wdGlvbnMubGl2ZVJlbG9hZCA9IHRydWU7XG4gICAgbG9nLmluZm8oJ1tXRFNdIExpdmUgUmVsb2FkaW5nIGVuYWJsZWQuJyk7XG4gIH0sXG4gIGludmFsaWQ6IGZ1bmN0aW9uIGludmFsaWQoKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIEFwcCB1cGRhdGVkLiBSZWNvbXBpbGluZy4uLicpOyAvLyBmaXhlcyAjMTA0Mi4gb3ZlcmxheSBkb2Vzbid0IGNsZWFyIGlmIGVycm9ycyBhcmUgZml4ZWQgYnV0IHdhcm5pbmdzIHJlbWFpbi5cblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ0ludmFsaWQnKTtcbiAgfSxcbiAgaGFzaDogZnVuY3Rpb24gaGFzaChfaGFzaCkge1xuICAgIHN0YXR1cy5jdXJyZW50SGFzaCA9IF9oYXNoO1xuICB9LFxuICAnc3RpbGwtb2snOiBmdW5jdGlvbiBzdGlsbE9rKCkge1xuICAgIGxvZy5pbmZvKCdbV0RTXSBOb3RoaW5nIGNoYW5nZWQuJyk7XG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSB8fCBvcHRpb25zLnVzZUVycm9yT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5jbGVhcigpO1xuICAgIH1cblxuICAgIHNlbmRNZXNzYWdlKCdTdGlsbE9rJyk7XG4gIH0sXG4gICdsb2ctbGV2ZWwnOiBmdW5jdGlvbiBsb2dMZXZlbChsZXZlbCkge1xuICAgIHZhciBob3RDdHggPSByZXF1aXJlLmNvbnRleHQoJ3dlYnBhY2svaG90JywgZmFsc2UsIC9eXFwuXFwvbG9nJC8pO1xuXG4gICAgaWYgKGhvdEN0eC5rZXlzKCkuaW5kZXhPZignLi9sb2cnKSAhPT0gLTEpIHtcbiAgICAgIGhvdEN0eCgnLi9sb2cnKS5zZXRMb2dMZXZlbChsZXZlbCk7XG4gICAgfVxuXG4gICAgc2V0TG9nTGV2ZWwobGV2ZWwpO1xuICB9LFxuICBvdmVybGF5OiBmdW5jdGlvbiBvdmVybGF5KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICBvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5ID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMudXNlRXJyb3JPdmVybGF5ID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnMudXNlV2FybmluZ092ZXJsYXkgPSB2YWx1ZS53YXJuaW5ncztcbiAgICAgICAgb3B0aW9ucy51c2VFcnJvck92ZXJsYXkgPSB2YWx1ZS5lcnJvcnM7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwcm9ncmVzczogZnVuY3Rpb24gcHJvZ3Jlc3MoX3Byb2dyZXNzKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIG9wdGlvbnMudXNlUHJvZ3Jlc3MgPSBfcHJvZ3Jlc3M7XG4gICAgfVxuICB9LFxuICAncHJvZ3Jlc3MtdXBkYXRlJzogZnVuY3Rpb24gcHJvZ3Jlc3NVcGRhdGUoZGF0YSkge1xuICAgIGlmIChvcHRpb25zLnVzZVByb2dyZXNzKSB7XG4gICAgICBsb2cuaW5mbyhcIltXRFNdIFwiLmNvbmNhdChkYXRhLnBlcmNlbnQsIFwiJSAtIFwiKS5jb25jYXQoZGF0YS5tc2csIFwiLlwiKSk7XG4gICAgfVxuXG4gICAgc2VuZE1lc3NhZ2UoJ1Byb2dyZXNzJywgZGF0YSk7XG4gIH0sXG4gIG9rOiBmdW5jdGlvbiBvaygpIHtcbiAgICBzZW5kTWVzc2FnZSgnT2snKTtcblxuICAgIGlmIChvcHRpb25zLnVzZVdhcm5pbmdPdmVybGF5IHx8IG9wdGlvbnMudXNlRXJyb3JPdmVybGF5KSB7XG4gICAgICBvdmVybGF5LmNsZWFyKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5pdGlhbCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbCA9IGZhbHNlO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1yZXR1cm4tYXNzaWduXG5cblxuICAgIHJlbG9hZEFwcChvcHRpb25zLCBzdGF0dXMpO1xuICB9LFxuICAnY29udGVudC1jaGFuZ2VkJzogZnVuY3Rpb24gY29udGVudENoYW5nZWQoKSB7XG4gICAgbG9nLmluZm8oJ1tXRFNdIENvbnRlbnQgYmFzZSBjaGFuZ2VkLiBSZWxvYWRpbmcuLi4nKTtcbiAgICBzZWxmLmxvY2F0aW9uLnJlbG9hZCgpO1xuICB9LFxuICB3YXJuaW5nczogZnVuY3Rpb24gd2FybmluZ3MoX3dhcm5pbmdzKSB7XG4gICAgbG9nLndhcm4oJ1tXRFNdIFdhcm5pbmdzIHdoaWxlIGNvbXBpbGluZy4nKTtcblxuICAgIHZhciBzdHJpcHBlZFdhcm5pbmdzID0gX3dhcm5pbmdzLm1hcChmdW5jdGlvbiAod2FybmluZykge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaSh3YXJuaW5nKTtcbiAgICB9KTtcblxuICAgIHNlbmRNZXNzYWdlKCdXYXJuaW5ncycsIHN0cmlwcGVkV2FybmluZ3MpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZFdhcm5pbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2cud2FybihzdHJpcHBlZFdhcm5pbmdzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51c2VXYXJuaW5nT3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5zaG93TWVzc2FnZShfd2FybmluZ3MpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluaXRpYWwpIHtcbiAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWwgPSBmYWxzZTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmV0dXJuLWFzc2lnblxuXG5cbiAgICByZWxvYWRBcHAob3B0aW9ucywgc3RhdHVzKTtcbiAgfSxcbiAgZXJyb3JzOiBmdW5jdGlvbiBlcnJvcnMoX2Vycm9ycykge1xuICAgIGxvZy5lcnJvcignW1dEU10gRXJyb3JzIHdoaWxlIGNvbXBpbGluZy4gUmVsb2FkIHByZXZlbnRlZC4nKTtcblxuICAgIHZhciBzdHJpcHBlZEVycm9ycyA9IF9lcnJvcnMubWFwKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIHN0cmlwQW5zaShlcnJvcik7XG4gICAgfSk7XG5cbiAgICBzZW5kTWVzc2FnZSgnRXJyb3JzJywgc3RyaXBwZWRFcnJvcnMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpcHBlZEVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgbG9nLmVycm9yKHN0cmlwcGVkRXJyb3JzW2ldKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51c2VFcnJvck92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuc2hvd01lc3NhZ2UoX2Vycm9ycyk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5pbml0aWFsID0gZmFsc2U7XG4gIH0sXG4gIGVycm9yOiBmdW5jdGlvbiBlcnJvcihfZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoX2Vycm9yKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGxvZy5lcnJvcignW1dEU10gRGlzY29ubmVjdGVkIScpO1xuICAgIHNlbmRNZXNzYWdlKCdDbG9zZScpO1xuICB9XG59O1xuc29ja2V0KHNvY2tldFVybCwgb25Tb2NrZXRNZXNzYWdlKTsiLCIndXNlIHN0cmljdCc7XG52YXIgYW5zaVJlZ2V4ID0gcmVxdWlyZSgnYW5zaS1yZWdleCcpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBzdHIucmVwbGFjZShhbnNpUmVnZXgsICcnKSA6IHN0cjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIC9bXFx1MDAxYlxcdTAwOWJdW1soKSM7P10qKD86WzAtOV17MSw0fSg/OjtbMC05XXswLDR9KSopP1swLTlBLVBSWmNmLW5xcnk9PjxdL2c7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fd2VicGFja19kZXZfc2VydmVyX2NsaWVudF9fICovXG5cbi8qIGVzbGludC1kaXNhYmxlXG4gIGNhbWVsY2FzZVxuKi9cbi8vIHRoaXMgU29ja0pTQ2xpZW50IGlzIGhlcmUgYXMgYSBkZWZhdWx0IGZhbGxiYWNrLCBpbiBjYXNlIGlubGluZSBtb2RlXG4vLyBpcyBvZmYgb3IgdGhlIGNsaWVudCBpcyBub3QgaW5qZWN0ZWQuIFRoaXMgd2lsbCBiZSBzd2l0Y2hlZCB0b1xuLy8gV2Vic29ja2V0Q2xpZW50IHdoZW4gaXQgYmVjb21lcyB0aGUgZGVmYXVsdFxuLy8gaW1wb3J0YW50OiB0aGUgcGF0aCB0byBTb2NrSlNDbGllbnQgaGVyZSBpcyBtYWRlIHRvIHdvcmsgaW4gdGhlICdjbGllbnQnXG4vLyBkaXJlY3RvcnksIGJ1dCBpcyB1cGRhdGVkIHZpYSB0aGUgd2VicGFjayBjb21waWxhdGlvbiB3aGVuIGNvbXBpbGVkIGZyb21cbi8vIHRoZSAnY2xpZW50LXNyYycgZGlyZWN0b3J5XG5cbnZhciBDbGllbnQgPSB0eXBlb2YgX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX2Rldl9zZXJ2ZXJfY2xpZW50X18gOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbnJlcXVpcmUoJy4vY2xpZW50cy9Tb2NrSlNDbGllbnQnKTtcbnZhciByZXRyaWVzID0gMDtcbnZhciBjbGllbnQgPSBudWxsO1xuXG52YXIgc29ja2V0ID0gZnVuY3Rpb24gaW5pdFNvY2tldCh1cmwsIGhhbmRsZXJzKSB7XG4gIGNsaWVudCA9IG5ldyBDbGllbnQodXJsKTtcbiAgY2xpZW50Lm9uT3BlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0cmllcyA9IDA7XG4gIH0pO1xuICBjbGllbnQub25DbG9zZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJldHJpZXMgPT09IDApIHtcbiAgICAgIGhhbmRsZXJzLmNsb3NlKCk7XG4gICAgfSAvLyBUcnkgdG8gcmVjb25uZWN0LlxuXG5cbiAgICBjbGllbnQgPSBudWxsOyAvLyBBZnRlciAxMCByZXRyaWVzIHN0b3AgdHJ5aW5nLCB0byBwcmV2ZW50IGxvZ3NwYW0uXG5cbiAgICBpZiAocmV0cmllcyA8PSAxMCkge1xuICAgICAgLy8gRXhwb25lbnRpYWxseSBpbmNyZWFzZSB0aW1lb3V0IHRvIHJlY29ubmVjdC5cbiAgICAgIC8vIFJlc3BlY3RmdWxseSBjb3BpZWQgZnJvbSB0aGUgcGFja2FnZSBgZ290YC5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1taXhlZC1vcGVyYXRvcnMsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuICAgICAgdmFyIHJldHJ5SW5NcyA9IDEwMDAgKiBNYXRoLnBvdygyLCByZXRyaWVzKSArIE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICByZXRyaWVzICs9IDE7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc29ja2V0KHVybCwgaGFuZGxlcnMpO1xuICAgICAgfSwgcmV0cnlJbk1zKTtcbiAgICB9XG4gIH0pO1xuICBjbGllbnQub25NZXNzYWdlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICBpZiAoaGFuZGxlcnNbbXNnLnR5cGVdKSB7XG4gICAgICBoYW5kbGVyc1ttc2cudHlwZV0obXNnLmRhdGEpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvY2tldDsiLCIndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZVxuICBuby11bnVzZWQtdmFyc1xuKi9cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbnZhciBTb2NrSlMgPSByZXF1aXJlKCdzb2NranMtY2xpZW50L2Rpc3Qvc29ja2pzJyk7XG5cbnZhciBCYXNlQ2xpZW50ID0gcmVxdWlyZSgnLi9CYXNlQ2xpZW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZUNsaWVudCkge1xuICBfaW5oZXJpdHMoU29ja0pTQ2xpZW50LCBfQmFzZUNsaWVudCk7XG5cbiAgZnVuY3Rpb24gU29ja0pTQ2xpZW50KHVybCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb2NrSlNDbGllbnQpO1xuXG4gICAgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoU29ja0pTQ2xpZW50KS5jYWxsKHRoaXMpKTtcbiAgICBfdGhpcy5zb2NrID0gbmV3IFNvY2tKUyh1cmwpO1xuXG4gICAgX3RoaXMuc29jay5vbmVycm9yID0gZnVuY3Rpb24gKGVycikgey8vIFRPRE86IHVzZSBsb2dnZXIgdG8gbG9nIHRoZSBlcnJvciBldmVudCBvbmNlIGNsaWVudCBhbmQgY2xpZW50LXNyY1xuICAgICAgLy8gYXJlIHJlb3JnYW5pemVkIHRvIGhhdmUgdGhlIHNhbWUgZGlyZWN0b3J5IHN0cnVjdHVyZVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU29ja0pTQ2xpZW50LCBbe1xuICAgIGtleTogXCJvbk9wZW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25PcGVuKGYpIHtcbiAgICAgIHRoaXMuc29jay5vbm9wZW4gPSBmO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkNsb3NlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQ2xvc2UoZikge1xuICAgICAgdGhpcy5zb2NrLm9uY2xvc2UgPSBmO1xuICAgIH0gLy8gY2FsbCBmIHdpdGggdGhlIG1lc3NhZ2Ugc3RyaW5nIGFzIHRoZSBmaXJzdCBhcmd1bWVudFxuXG4gIH0sIHtcbiAgICBrZXk6IFwib25NZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uTWVzc2FnZShmKSB7XG4gICAgICB0aGlzLnNvY2sub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgZihlLmRhdGEpO1xuICAgICAgfTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZXRDbGllbnRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWVudFBhdGgob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHJlcXVpcmUucmVzb2x2ZSgnLi9Tb2NrSlNDbGllbnQnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU29ja0pTQ2xpZW50O1xufShCYXNlQ2xpZW50KTsiLCIvKiBzb2NranMtY2xpZW50IHYxLjQuMCB8IGh0dHA6Ly9zb2NranMub3JnIHwgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbihmKXtpZih0eXBlb2YgZXhwb3J0cz09PVwib2JqZWN0XCImJnR5cGVvZiBtb2R1bGUhPT1cInVuZGVmaW5lZFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoW10sZil9ZWxzZXt2YXIgZztpZih0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIil7Zz13aW5kb3d9ZWxzZSBpZih0eXBlb2YgZ2xvYmFsIT09XCJ1bmRlZmluZWRcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCIpe2c9c2VsZn1lbHNle2c9dGhpc31nLlNvY2tKUyA9IGYoKX19KShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkoezE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhbnNwb3J0TGlzdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0LWxpc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21haW4nKSh0cmFuc3BvcnRMaXN0KTtcblxuLy8gVE9ETyBjYW4ndCBnZXQgcmlkIG9mIHRoaXMgdW50aWwgYWxsIHNlcnZlcnMgZG9cbmlmICgnX3NvY2tqc19vbmxvYWQnIGluIGdsb2JhbCkge1xuICBzZXRUaW1lb3V0KGdsb2JhbC5fc29ja2pzX29ubG9hZCwgMSk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vbWFpblwiOjE0LFwiLi90cmFuc3BvcnQtbGlzdFwiOjE2fV0sMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICA7XG5cbmZ1bmN0aW9uIENsb3NlRXZlbnQoKSB7XG4gIEV2ZW50LmNhbGwodGhpcyk7XG4gIHRoaXMuaW5pdEV2ZW50KCdjbG9zZScsIGZhbHNlLCBmYWxzZSk7XG4gIHRoaXMud2FzQ2xlYW4gPSBmYWxzZTtcbiAgdGhpcy5jb2RlID0gMDtcbiAgdGhpcy5yZWFzb24gPSAnJztcbn1cblxuaW5oZXJpdHMoQ2xvc2VFdmVudCwgRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb3NlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjQsXCJpbmhlcml0c1wiOjU3fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnR0YXJnZXQnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbn1cblxuaW5oZXJpdHMoRXZlbnRFbWl0dGVyLCBFdmVudFRhcmdldCk7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodHlwZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub24odHlwZSwgZyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF07XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGVxdWl2YWxlbnQgb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShsIC0gMSk7XG4gIGZvciAodmFyIGFpID0gMTsgYWkgPCBsOyBhaSsrKSB7XG4gICAgYXJnc1thaSAtIDFdID0gYXJndW1lbnRzW2FpXTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG59LHtcIi4vZXZlbnR0YXJnZXRcIjo1LFwiaW5oZXJpdHNcIjo1N31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBFdmVudChldmVudFR5cGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xufVxuXG5FdmVudC5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xuICB0aGlzLmJ1YmJsZXMgPSBjYW5CdWJibGU7XG4gIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge307XG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHt9O1xuXG5FdmVudC5DQVBUVVJJTkdfUEhBU0UgPSAxO1xuRXZlbnQuQVRfVEFSR0VUID0gMjtcbkV2ZW50LkJVQkJMSU5HX1BIQVNFID0gMztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxufSx7fV0sNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIFNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgRE9NMiBFdmVudFRhcmdldC5cbiAqICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldFxuICovXG5cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbn1cblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghKGV2ZW50VHlwZSBpbiB0aGlzLl9saXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBbXTtcbiAgfVxuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIC8vICM0XG4gIGlmIChhcnIuaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgIGFyciA9IGFyci5jb25jYXQoW2xpc3RlbmVyXSk7XG4gIH1cbiAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnI7XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICBpZiAoIWFycikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaWR4ID0gYXJyLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnIuc2xpY2UoMCwgaWR4KS5jb25jYXQoYXJyLnNsaWNlKGlkeCArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBldmVudCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIHQgPSBldmVudC50eXBlO1xuICAvLyBlcXVpdmFsZW50IG9mIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IFtldmVudF0gOiBBcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgbWF0Y2ggdGhlIHJlYWwgYmVoYXZpb3I7IHBlciBzcGVjLCBvbmZvbyBnZXRcbiAgLy8gdGhlaXIgcGxhY2UgaW4gbGluZSBmcm9tIHRoZSAvZmlyc3QvIHRpbWUgdGhleSdyZSBzZXQgZnJvbVxuICAvLyBub24tbnVsbC4gQWx0aG91Z2ggV2ViS2l0IGJ1bXBzIGl0IHRvIHRoZSBlbmQgZXZlcnkgdGltZSBpdCdzXG4gIC8vIHNldC5cbiAgaWYgKHRoaXNbJ29uJyArIHRdKSB7XG4gICAgdGhpc1snb24nICsgdF0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbiAgaWYgKHQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byB0aGUgbGlzdGVuZXJzIGxpc3QuIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWF5IGFsdGVyIHRoZSBsaXN0LlxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG5cbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBUcmFuc3BvcnRNZXNzYWdlRXZlbnQoZGF0YSkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnbWVzc2FnZScsIGZhbHNlLCBmYWxzZSk7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cbmluaGVyaXRzKFRyYW5zcG9ydE1lc3NhZ2VFdmVudCwgRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydE1lc3NhZ2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6NCxcImluaGVyaXRzXCI6NTd9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICA7XG5cbmZ1bmN0aW9uIEZhY2FkZUpTKHRyYW5zcG9ydCkge1xuICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIHRyYW5zcG9ydC5vbignY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbn1cblxuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgnYycsIEpTT04zLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSkpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCd0JywgZnJhbWUpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZGF0YSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNhZGVKUztcblxufSx7XCIuL3V0aWxzL2lmcmFtZVwiOjQ3LFwianNvbjNcIjo1OH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBGYWNhZGVKUyA9IHJlcXVpcmUoJy4vZmFjYWRlJylcbiAgLCBJbmZvSWZyYW1lUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmlmcmFtZS1ib290c3RyYXAnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdmFyIHRyYW5zcG9ydE1hcCA9IHt9O1xuICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24oYXQpIHtcbiAgICBpZiAoYXQuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICB0cmFuc3BvcnRNYXBbYXQuZmFjYWRlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdID0gYXQuZmFjYWRlVHJhbnNwb3J0O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaGFyZC1jb2RlZCBmb3IgdGhlIGluZm8gaWZyYW1lXG4gIC8vIFRPRE8gc2VlIGlmIHdlIGNhbiBtYWtlIHRoaXMgbW9yZSBkeW5hbWljXG4gIHRyYW5zcG9ydE1hcFtJbmZvSWZyYW1lUmVjZWl2ZXIudHJhbnNwb3J0TmFtZV0gPSBJbmZvSWZyYW1lUmVjZWl2ZXI7XG4gIHZhciBwYXJlbnRPcmlnaW47XG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIFNvY2tKUy5ib290c3RyYXBfaWZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB2YXIgZmFjYWRlO1xuICAgIGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCA9IGxvYy5oYXNoLnNsaWNlKDEpO1xuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5zb3VyY2UgIT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudE9yaWdpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyZW50T3JpZ2luID0gZS5vcmlnaW47XG4gICAgICB9XG4gICAgICBpZiAoZS5vcmlnaW4gIT09IHBhcmVudE9yaWdpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZnJhbWVNZXNzYWdlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIHZhciBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVyc2lvbiA9IHBbMF07XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSBwWzFdO1xuICAgICAgICB2YXIgdHJhbnNVcmwgPSBwWzJdO1xuICAgICAgICB2YXIgYmFzZVVybCA9IHBbM107XG4gICAgICAgIGRlYnVnKHZlcnNpb24sIHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICAgICAgICAvLyBjaGFuZ2UgdGhpcyB0byBzZW12ZXIgbG9naWNcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IFNvY2tKUy52ZXJzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGlibGUgU29ja0pTISBNYWluIHNpdGUgdXNlczonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyB2ZXJzaW9uICsgJ1wiLCB0aGUgaWZyYW1lOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIFNvY2tKUy52ZXJzaW9uICsgJ1wiLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRyYW5zVXJsLCBsb2MuaHJlZikgfHxcbiAgICAgICAgICAgICF1cmxVdGlscy5pc09yaWdpbkVxdWFsKGJhc2VVcmwsIGxvYy5ocmVmKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBjb25uZWN0IHRvIGRpZmZlcmVudCBkb21haW4gZnJvbSB3aXRoaW4gYW4gJyArXG4gICAgICAgICAgICAgICAgICAgICdpZnJhbWUuICgnICsgbG9jLmhyZWYgKyAnLCAnICsgdHJhbnNVcmwgKyAnLCAnICsgYmFzZVVybCArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKG5ldyB0cmFuc3BvcnRNYXBbdHJhbnNwb3J0XSh0cmFuc1VybCwgYmFzZVVybCkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ20nOlxuICAgICAgICBmYWNhZGUuX3NlbmQoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgaWYgKGZhY2FkZSkge1xuICAgICAgICAgIGZhY2FkZS5fY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIG9uTWVzc2FnZSk7XG5cbiAgICAvLyBTdGFydFxuICAgIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdzJyk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi9mYWNhZGVcIjo3LFwiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjEwLFwiLi9sb2NhdGlvblwiOjEzLFwiLi91dGlscy9ldmVudFwiOjQ2LFwiLi91dGlscy9pZnJhbWVcIjo0NyxcIi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwianNvbjNcIjo1OH1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1hamF4Jyk7XG59XG5cbmZ1bmN0aW9uIEluZm9BamF4KHVybCwgQWpheE9iamVjdCkge1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0MCA9ICtuZXcgRGF0ZSgpO1xuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ0dFVCcsIHVybCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICB2YXIgaW5mbywgcnR0O1xuICAgIGlmIChzdGF0dXMgPT09IDIwMCkge1xuICAgICAgcnR0ID0gKCtuZXcgRGF0ZSgpKSAtIHQwO1xuICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbmZvID0gSlNPTjMucGFyc2UodGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW9iamVjdFV0aWxzLmlzT2JqZWN0KGluZm8pKSB7XG4gICAgICAgIGluZm8gPSB7fTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhJbmZvQWpheCwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0FqYXgucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMueG8uY2xvc2UoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0FqYXg7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCIuL3V0aWxzL29iamVjdFwiOjQ5LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxuZnVuY3Rpb24gSW5mb1JlY2VpdmVySWZyYW1lKHRyYW5zVXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5pciA9IG5ldyBJbmZvQWpheCh0cmFuc1VybCwgWEhSTG9jYWxPYmplY3QpO1xuICB0aGlzLmlyLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgIHNlbGYuaXIgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIEpTT04zLnN0cmluZ2lmeShbaW5mbywgcnR0XSkpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb1JlY2VpdmVySWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtaW5mby1yZWNlaXZlcic7XG5cbkluZm9SZWNlaXZlcklmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXIpIHtcbiAgICB0aGlzLmlyLmNsb3NlKCk7XG4gICAgdGhpcy5pciA9IG51bGw7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVySWZyYW1lO1xuXG59LHtcIi4vaW5mby1hamF4XCI6OSxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjozNyxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9pZnJhbWUnKVxuICAsIEluZm9SZWNlaXZlcklmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1pZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWZyID0gc2VsZi5pZnIgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KEluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lLCB1cmwsIGJhc2VVcmwpO1xuXG4gICAgaWZyLm9uY2UoJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZCA9IEpTT04zLnBhcnNlKG1zZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBtc2cpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gZFswXSwgcnR0ID0gZFsxXTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgICAgfVxuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaWZyLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE8gdGhpcyBzZWVtcyB0aGUgc2FtZSBhcyB0aGUgJ25lZWRCb2R5JyBmcm9tIHRyYW5zcG9ydHNcbiAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSkge1xuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgZ28pO1xuICB9IGVsc2Uge1xuICAgIGdvKCk7XG4gIH1cbn1cblxuaW5oZXJpdHMoSW5mb0lmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0lmcmFtZS5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuSW5mb0lmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaWZyKSB7XG4gICAgdGhpcy5pZnIuY2xvc2UoKTtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLmlmciA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9JZnJhbWU7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjoxMCxcIi4vdHJhbnNwb3J0L2lmcmFtZVwiOjIyLFwiLi91dGlscy9ldmVudFwiOjQ2LFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3LFwianNvbjNcIjo1OH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBYRFIgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGRyJylcbiAgLCBYSFJDb3JzID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIFhIUkZha2UgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2UnKVxuICAsIEluZm9JZnJhbWUgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lJylcbiAgLCBJbmZvQWpheCA9IHJlcXVpcmUoJy4vaW5mby1hamF4JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tcmVjZWl2ZXInKTtcbn1cblxuZnVuY3Rpb24gSW5mb1JlY2VpdmVyKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgZGVidWcoYmFzZVVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmRvWGhyKGJhc2VVcmwsIHVybEluZm8pO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoSW5mb1JlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG4vLyBUT0RPIHRoaXMgaXMgY3VycmVudGx5IGlnbm9yaW5nIHRoZSBsaXN0IG9mIGF2YWlsYWJsZSB0cmFuc3BvcnRzIGFuZCB0aGUgd2hpdGVsaXN0XG5cbkluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmwsIHVybEluZm8pIHtcbiAgLy8gZGV0ZXJtaW5lIG1ldGhvZCBvZiBDT1JTIHN1cHBvcnQgKGlmIG5lZWRlZClcbiAgaWYgKHVybEluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJMb2NhbCk7XG4gIH1cbiAgaWYgKFhIUkNvcnMuZW5hYmxlZCkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJDb3JzKTtcbiAgfVxuICBpZiAoWERSLmVuYWJsZWQgJiYgdXJsSW5mby5zYW1lU2NoZW1lKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhEUik7XG4gIH1cbiAgaWYgKEluZm9JZnJhbWUuZW5hYmxlZCgpKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkZha2UpO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5kb1hociA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybEluZm8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaW5mbycpXG4gICAgO1xuICBkZWJ1ZygnZG9YaHInLCB1cmwpO1xuXG4gIHRoaXMueG8gPSBJbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyKGJhc2VVcmwsIHVybCwgdXJsSW5mbyk7XG5cbiAgdGhpcy50aW1lb3V0UmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gIH0sIEluZm9SZWNlaXZlci50aW1lb3V0KTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICB9KTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbih3YXNDbGVhbikge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dFJlZik7XG4gIHRoaXMudGltZW91dFJlZiA9IG51bGw7XG4gIGlmICghd2FzQ2xlYW4gJiYgdGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgfVxuICB0aGlzLnhvID0gbnVsbDtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuSW5mb1JlY2VpdmVyLnRpbWVvdXQgPSA4MDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vaW5mby1hamF4XCI6OSxcIi4vaW5mby1pZnJhbWVcIjoxMSxcIi4vdHJhbnNwb3J0L3NlbmRlci94ZHJcIjozNCxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItY29yc1wiOjM1LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlXCI6MzYsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6MzcsXCIuL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5sb2NhdGlvbiB8fCB7XG4gIG9yaWdpbjogJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAnXG4sIHByb3RvY29sOiAnaHR0cDonXG4sIGhvc3Q6ICdsb2NhbGhvc3QnXG4sIHBvcnQ6IDgwXG4sIGhyZWY6ICdodHRwOi8vbG9jYWxob3N0LydcbiwgaGFzaDogJydcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi9zaGltcycpO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuL3V0aWxzL3JhbmRvbScpXG4gICwgZXNjYXBlID0gcmVxdWlyZSgnLi91dGlscy9lc2NhcGUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCB0cmFuc3BvcnQgPSByZXF1aXJlKCcuL3V0aWxzL3RyYW5zcG9ydCcpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vdXRpbHMvYnJvd3NlcicpXG4gICwgbG9nID0gcmVxdWlyZSgnLi91dGlscy9sb2cnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudCcpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50dGFyZ2V0JylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgLCBDbG9zZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC9jbG9zZScpXG4gICwgVHJhbnNwb3J0TWVzc2FnZUV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudC90cmFucy1tZXNzYWdlJylcbiAgLCBJbmZvUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8tcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6bWFpbicpO1xufVxuXG52YXIgdHJhbnNwb3J0cztcblxuLy8gZm9sbG93IGNvbnN0cnVjdG9yIHN0ZXBzIGRlZmluZWQgYXQgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbmZ1bmN0aW9uIFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja0pTKSkge1xuICAgIHJldHVybiBuZXcgU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnU29ja0pTOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnRcIik7XG4gIH1cbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgdGhpcy5leHRlbnNpb25zID0gJyc7XG4gIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAvLyBub24tc3RhbmRhcmQgZXh0ZW5zaW9uXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgbG9nLndhcm4oXCIncHJvdG9jb2xzX3doaXRlbGlzdCcgaXMgREVQUkVDQVRFRC4gVXNlICd0cmFuc3BvcnRzJyBpbnN0ZWFkLlwiKTtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0ID0gb3B0aW9ucy50cmFuc3BvcnRzO1xuICB0aGlzLl90cmFuc3BvcnRPcHRpb25zID0gb3B0aW9ucy50cmFuc3BvcnRPcHRpb25zIHx8IHt9O1xuICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucy50aW1lb3V0IHx8IDA7XG5cbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XG4gIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmRvbS5zdHJpbmcoc2Vzc2lvbklkKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lmIHNlc3Npb25JZCBpcyB1c2VkIGluIHRoZSBvcHRpb25zLCBpdCBuZWVkcyB0byBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgfHwgcmFuZG9tLm51bWJlclN0cmluZygxMDAwKTtcblxuICAvLyBTdGVwIDEgb2YgV1Mgc3BlYyAtIHBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgdXJsLiBJc3N1ZSAjOFxuICB2YXIgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMICdcIiArIHVybCArIFwiJyBpcyBpbnZhbGlkXCIpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCdzIHNjaGVtZSBtdXN0IGJlIGVpdGhlciAnaHR0cDonIG9yICdodHRwczonLiAnXCIgKyBwYXJzZWRVcmwucHJvdG9jb2wgKyBcIicgaXMgbm90IGFsbG93ZWQuXCIpO1xuICB9XG5cbiAgdmFyIHNlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxuICBpZiAobG9jLnByb3RvY29sID09PSAnaHR0cHM6JyAmJiAhc2VjdXJlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTZWN1cml0eUVycm9yOiBBbiBpbnNlY3VyZSBTb2NrSlMgY29ubmVjdGlvbiBtYXkgbm90IGJlIGluaXRpYXRlZCBmcm9tIGEgcGFnZSBsb2FkZWQgb3ZlciBIVFRQUycpO1xuICB9XG5cbiAgLy8gU3RlcCAzIC0gY2hlY2sgcG9ydCBhY2Nlc3MgLSBubyBuZWVkIGhlcmVcbiAgLy8gU3RlcCA0IC0gcGFyc2UgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIGlmICghcHJvdG9jb2xzKSB7XG4gICAgcHJvdG9jb2xzID0gW107XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkocHJvdG9jb2xzKSkge1xuICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICB9XG5cbiAgLy8gU3RlcCA1IC0gY2hlY2sgcHJvdG9jb2xzIGFyZ3VtZW50XG4gIHZhciBzb3J0ZWRQcm90b2NvbHMgPSBwcm90b2NvbHMuc29ydCgpO1xuICBzb3J0ZWRQcm90b2NvbHMuZm9yRWFjaChmdW5jdGlvbihwcm90bywgaSkge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgaW52YWxpZC5cIik7XG4gICAgfVxuICAgIGlmIChpIDwgKHNvcnRlZFByb3RvY29scy5sZW5ndGggLSAxKSAmJiBwcm90byA9PT0gc29ydGVkUHJvdG9jb2xzW2kgKyAxXSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBkdXBsaWNhdGVkLlwiKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFN0ZXAgNiAtIGNvbnZlcnQgb3JpZ2luXG4gIHZhciBvID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGxvYy5ocmVmKTtcbiAgdGhpcy5fb3JpZ2luID0gbyA/IG8udG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgLy8gcmVtb3ZlIHRoZSB0cmFpbGluZyBzbGFzaFxuICBwYXJzZWRVcmwuc2V0KCdwYXRobmFtZScsIHBhcnNlZFVybC5wYXRobmFtZS5yZXBsYWNlKC9cXC8rJC8sICcnKSk7XG5cbiAgLy8gc3RvcmUgdGhlIHNhbml0aXplZCB1cmxcbiAgdGhpcy51cmwgPSBwYXJzZWRVcmwuaHJlZjtcbiAgZGVidWcoJ3VzaW5nIHVybCcsIHRoaXMudXJsKTtcblxuICAvLyBTdGVwIDcgLSBzdGFydCBjb25uZWN0aW9uIGluIGJhY2tncm91bmRcbiAgLy8gb2J0YWluIHNlcnZlciBpbmZvXG4gIC8vIGh0dHA6Ly9zb2NranMuZ2l0aHViLmlvL3NvY2tqcy1wcm90b2NvbC9zb2NranMtcHJvdG9jb2wtMC4zLjMuaHRtbCNzZWN0aW9uLTI2XG4gIHRoaXMuX3VybEluZm8gPSB7XG4gICAgbnVsbE9yaWdpbjogIWJyb3dzZXIuaGFzRG9tYWluKClcbiAgLCBzYW1lT3JpZ2luOiB1cmxVdGlscy5pc09yaWdpbkVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgLCBzYW1lU2NoZW1lOiB1cmxVdGlscy5pc1NjaGVtZUVxdWFsKHRoaXMudXJsLCBsb2MuaHJlZilcbiAgfTtcblxuICB0aGlzLl9pciA9IG5ldyBJbmZvUmVjZWl2ZXIodGhpcy51cmwsIHRoaXMuX3VybEluZm8pO1xuICB0aGlzLl9pci5vbmNlKCdmaW5pc2gnLCB0aGlzLl9yZWNlaXZlSW5mby5iaW5kKHRoaXMpKTtcbn1cblxuaW5oZXJpdHMoU29ja0pTLCBFdmVudFRhcmdldCk7XG5cbmZ1bmN0aW9uIHVzZXJTZXRDb2RlKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufVxuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIC8vIFN0ZXAgMVxuICBpZiAoY29kZSAmJiAhdXNlclNldENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRBY2Nlc3NFcnJvcjogSW52YWxpZCBjb2RlJyk7XG4gIH1cbiAgLy8gU3RlcCAyLjQgc3RhdGVzIHRoZSBtYXggaXMgMTIzIGJ5dGVzLCBidXQgd2UgYXJlIGp1c3QgY2hlY2tpbmcgbGVuZ3RoXG4gIGlmIChyZWFzb24gJiYgcmVhc29uLmxlbmd0aCA+IDEyMykge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcigncmVhc29uIGFyZ3VtZW50IGhhcyBhbiBpbnZhbGlkIGxlbmd0aCcpO1xuICB9XG5cbiAgLy8gU3RlcCAzLjFcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETyBsb29rIGF0IGRvY3MgdG8gZGV0ZXJtaW5lIGhvdyB0byBzZXQgdGhpc1xuICB2YXIgd2FzQ2xlYW4gPSB0cnVlO1xuICB0aGlzLl9jbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCAnTm9ybWFsIGNsb3N1cmUnLCB3YXNDbGVhbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIC8vICMxMyAtIGNvbnZlcnQgYW55dGhpbmcgbm9uLXN0cmluZyB0byBzdHJpbmdcbiAgLy8gVE9ETyB0aGlzIGN1cnJlbnRseSB0dXJucyBvYmplY3RzIGludG8gW29iamVjdCBPYmplY3RdXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogVGhlIGNvbm5lY3Rpb24gaGFzIG5vdCBiZWVuIGVzdGFibGlzaGVkIHlldCcpO1xuICB9XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydC5zZW5kKGVzY2FwZS5xdW90ZShkYXRhKSk7XG59O1xuXG5Tb2NrSlMudmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fcmVjZWl2ZUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgZGVidWcoJ19yZWNlaXZlSW5mbycsIHJ0dCk7XG4gIHRoaXMuX2lyID0gbnVsbDtcbiAgaWYgKCFpbmZvKSB7XG4gICAgdGhpcy5fY2xvc2UoMTAwMiwgJ0Nhbm5vdCBjb25uZWN0IHRvIHNlcnZlcicpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGVzdGFibGlzaCBhIHJvdW5kLXRyaXAgdGltZW91dCAoUlRPKSBiYXNlZCBvbiB0aGVcbiAgLy8gcm91bmQtdHJpcCB0aW1lIChSVFQpXG4gIHRoaXMuX3J0byA9IHRoaXMuY291bnRSVE8ocnR0KTtcbiAgLy8gYWxsb3cgc2VydmVyIHRvIG92ZXJyaWRlIHVybCB1c2VkIGZvciB0aGUgYWN0dWFsIHRyYW5zcG9ydFxuICB0aGlzLl90cmFuc1VybCA9IGluZm8uYmFzZV91cmwgPyBpbmZvLmJhc2VfdXJsIDogdGhpcy51cmw7XG4gIGluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoaW5mbywgdGhpcy5fdXJsSW5mbyk7XG4gIGRlYnVnKCdpbmZvJywgaW5mbyk7XG4gIC8vIGRldGVybWluZSBsaXN0IG9mIGRlc2lyZWQgYW5kIHN1cHBvcnRlZCB0cmFuc3BvcnRzXG4gIHZhciBlbmFibGVkVHJhbnNwb3J0cyA9IHRyYW5zcG9ydHMuZmlsdGVyVG9FbmFibGVkKHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pO1xuICB0aGlzLl90cmFuc3BvcnRzID0gZW5hYmxlZFRyYW5zcG9ydHMubWFpbjtcbiAgZGVidWcodGhpcy5fdHJhbnNwb3J0cy5sZW5ndGggKyAnIGVuYWJsZWQgdHJhbnNwb3J0cycpO1xuXG4gIHRoaXMuX2Nvbm5lY3QoKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpOyBUcmFuc3BvcnQ7IFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKSkge1xuICAgIGRlYnVnKCdhdHRlbXB0JywgVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUpO1xuICAgIGlmIChUcmFuc3BvcnQubmVlZEJvZHkpIHtcbiAgICAgIGlmICghZ2xvYmFsLmRvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAodHlwZW9mIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnaW50ZXJhY3RpdmUnKSkge1xuICAgICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgYm9keScpO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzLnVuc2hpZnQoVHJhbnNwb3J0KTtcbiAgICAgICAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIHRoaXMuX2Nvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGltZW91dCBiYXNlZCBvbiBSVE8gYW5kIHJvdW5kIHRyaXBzLiBEZWZhdWx0IHRvIDVzXG4gICAgdmFyIHRpbWVvdXRNcyA9IE1hdGgubWF4KHRoaXMuX3RpbWVvdXQsICh0aGlzLl9ydG8gKiBUcmFuc3BvcnQucm91bmRUcmlwcykgfHwgNTAwMCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0LmJpbmQodGhpcyksIHRpbWVvdXRNcyk7XG4gICAgZGVidWcoJ3VzaW5nIHRpbWVvdXQnLCB0aW1lb3V0TXMpO1xuXG4gICAgdmFyIHRyYW5zcG9ydFVybCA9IHVybFV0aWxzLmFkZFBhdGgodGhpcy5fdHJhbnNVcmwsICcvJyArIHRoaXMuX3NlcnZlciArICcvJyArIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkKCkpO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5fdHJhbnNwb3J0T3B0aW9uc1tUcmFuc3BvcnQudHJhbnNwb3J0TmFtZV07XG4gICAgZGVidWcoJ3RyYW5zcG9ydCB1cmwnLCB0cmFuc3BvcnRVcmwpO1xuICAgIHZhciB0cmFuc3BvcnRPYmogPSBuZXcgVHJhbnNwb3J0KHRyYW5zcG9ydFVybCwgdGhpcy5fdHJhbnNVcmwsIG9wdGlvbnMpO1xuICAgIHRyYW5zcG9ydE9iai5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgdHJhbnNwb3J0T2JqLm9uY2UoJ2Nsb3NlJywgdGhpcy5fdHJhbnNwb3J0Q2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdHJhbnNwb3J0T2JqLnRyYW5zcG9ydE5hbWUgPSBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnRPYmo7XG5cbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fY2xvc2UoMjAwMCwgJ0FsbCB0cmFuc3BvcnRzIGZhaWxlZCcsIGZhbHNlKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRUaW1lb3V0Jyk7XG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJhbnNwb3J0Q2xvc2UoMjAwNywgJ1RyYW5zcG9ydCB0aW1lZCBvdXQnKTtcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICBkZWJ1ZygnX3RyYW5zcG9ydE1lc3NhZ2UnLCBtc2cpO1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHR5cGUgPSBtc2cuc2xpY2UoMCwgMSlcbiAgICAsIGNvbnRlbnQgPSBtc2cuc2xpY2UoMSlcbiAgICAsIHBheWxvYWRcbiAgICA7XG5cbiAgLy8gZmlyc3QgY2hlY2sgZm9yIG1lc3NhZ2VzIHRoYXQgZG9uJ3QgbmVlZCBhIHBheWxvYWRcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnbyc6XG4gICAgICB0aGlzLl9vcGVuKCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnaCc6XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdoZWFydGJlYXQnKSk7XG4gICAgICBkZWJ1ZygnaGVhcnRiZWF0JywgdGhpcy50cmFuc3BvcnQpO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICB0cnkge1xuICAgICAgcGF5bG9hZCA9IEpTT04zLnBhcnNlKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGRlYnVnKCdiYWQganNvbicsIGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBkZWJ1ZygnZW1wdHkgcGF5bG9hZCcsIGNvbnRlbnQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2EnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgICAgcGF5bG9hZC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICBkZWJ1ZygnbWVzc2FnZScsIHNlbGYudHJhbnNwb3J0LCBwKTtcbiAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwKSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbSc6XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIHRoaXMudHJhbnNwb3J0LCBwYXlsb2FkKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHBheWxvYWQpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2MnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkgJiYgcGF5bG9hZC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdGhpcy5fY2xvc2UocGF5bG9hZFswXSwgcGF5bG9hZFsxXSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0Q2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgZGVidWcoJ190cmFuc3BvcnRDbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24pO1xuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgaWYgKCF1c2VyU2V0Q29kZShjb2RlKSAmJiBjb2RlICE9PSAyMDAwICYmIHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLl9jb25uZWN0KCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5fY2xvc2UoY29kZSwgcmVhc29uKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX29wZW4gPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19vcGVuJywgdGhpcy5fdHJhbnNwb3J0ICYmIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAvLyBjb25uZWN0aW9uLlxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4sIHRoaXMucmVhZHlTdGF0ZSk7XG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5faXIpIHtcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xuICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgdGhpcy5faXIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBTb2NrSlMgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQnKTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKTtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpO1xuICAgIGUud2FzQ2xlYW4gPSB3YXNDbGVhbiB8fCBmYWxzZTtcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgZS5yZWFzb24gPSByZWFzb247XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgdGhpcy5vbm1lc3NhZ2UgPSB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cblNvY2tKUy5wcm90b3R5cGUuY291bnRSVE8gPSBmdW5jdGlvbihydHQpIHtcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAvLyB0cmFuc3BvcnQgdGhlIHRpbWUgbmVlZGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gKHRoZSB0aW1lIHRoYXQgcGFzc1xuICAvLyBmcm9tIHRoZSBvcGVuaW5nIG9mIHRoZSB0cmFuc3BvcnQgdG8gdGhlIGNhbGwgb2YgYF9kaXNwYXRjaE9wZW5gKSBpc1xuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gIC8vIGNhdXNlcyBzcHVyaW91cyB0aW1lb3V0cy4gRm9yIHRoaXMgcmVhc29uIHdlIGNhbGN1bGF0ZSBhIHZhbHVlIHNsaWdodGx5XG4gIC8vIGxhcmdlciB0aGFuIHRoYXQgdXNlZCBpbiB0aGUgYXJ0aWNsZS5cbiAgaWYgKHJ0dCA+IDEwMCkge1xuICAgIHJldHVybiA0ICogcnR0OyAvLyBydG8gPiA0MDBtc2VjXG4gIH1cbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmVxdWlyZSgnLi9pZnJhbWUtYm9vdHN0cmFwJykoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmV0dXJuIFNvY2tKUztcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4vZXZlbnQvY2xvc2VcIjoyLFwiLi9ldmVudC9ldmVudFwiOjQsXCIuL2V2ZW50L2V2ZW50dGFyZ2V0XCI6NSxcIi4vZXZlbnQvdHJhbnMtbWVzc2FnZVwiOjYsXCIuL2lmcmFtZS1ib290c3RyYXBcIjo4LFwiLi9pbmZvLXJlY2VpdmVyXCI6MTIsXCIuL2xvY2F0aW9uXCI6MTMsXCIuL3NoaW1zXCI6MTUsXCIuL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4vdXRpbHMvZXNjYXBlXCI6NDUsXCIuL3V0aWxzL2V2ZW50XCI6NDYsXCIuL3V0aWxzL2xvZ1wiOjQ4LFwiLi91dGlscy9vYmplY3RcIjo0OSxcIi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuL3V0aWxzL3RyYW5zcG9ydFwiOjUxLFwiLi91dGlscy91cmxcIjo1MixcIi4vdmVyc2lvblwiOjUzLFwiZGVidWdcIjo1NSxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4LFwidXJsLXBhcnNlXCI6NjF9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoganNjczogZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG59XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbmZ1bmN0aW9uIEVtcHR5KCkge31cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cblxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5leHRlbmRlZCAgID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvci5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHZvaWQgMCA/XG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG59LHt9XSwxNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBzdHJlYW1pbmcgdHJhbnNwb3J0c1xuICByZXF1aXJlKCcuL3RyYW5zcG9ydC93ZWJzb2NrZXQnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAvLyBwb2xsaW5nIHRyYW5zcG9ydHNcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXG5dO1xuXG59LHtcIi4vdHJhbnNwb3J0L2V2ZW50c291cmNlXCI6MjAsXCIuL3RyYW5zcG9ydC9odG1sZmlsZVwiOjIxLFwiLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZ1wiOjIzLFwiLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwXCI6MjYsXCIuL3RyYW5zcG9ydC93ZWJzb2NrZXRcIjozOCxcIi4vdHJhbnNwb3J0L3hkci1wb2xsaW5nXCI6MzksXCIuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nXCI6NDAsXCIuL3RyYW5zcG9ydC94aHItcG9sbGluZ1wiOjQxLFwiLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZ1wiOjQyfV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgWEhSID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0XG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xufVxuXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLnhociA9IG5ldyBYSFIoKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxuXG4gIGlmICghdGhpcy54aHIpIHtcbiAgICBkZWJ1Zygnbm8geGhyJyk7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnbm8geGhyIHN1cHBvcnQnKTtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgLy8gdGFiIGdldHMgY2xvc2VkOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC81MjgwXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQgY2xlYW51cCcpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIHRoaXMueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICB0aGlzLnhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcbiAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCghb3B0cyB8fCAhb3B0cy5ub0NyZWRlbnRpYWxzKSAmJiBBYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMpIHtcbiAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxuICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnhocikge1xuICAgICAgdmFyIHggPSBzZWxmLnhocjtcbiAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgLy8gb24gTWljcm9zb2Z0LlhNTEhUVFAgYW5kIHJlYWR5c3RhdGU9M1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgIHRleHQgPSB4LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlYnVnKCdjaHVuaycpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzODM3NzAodj12cy44NSkuYXNweFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjAwNSB8fCBzdGF0dXMgPT09IDEyMDI5KSB7XG4gICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfVxufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgaWYgKCF0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICB9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XG4vLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2Lzdcbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIChheG8gaW4gZ2xvYmFsKSkge1xuICBkZWJ1Zygnb3ZlcnJpZGluZyB4bWxodHRwcmVxdWVzdCcpO1xuICBYSFIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIW5ldyBYSFIoKTtcbn1cblxudmFyIGNvcnMgPSBmYWxzZTtcbnRyeSB7XG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XG59IGNhdGNoIChpZ25vcmVkKSB7XG4gIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbn1cblxuQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFhIUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9LHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG5cbn0se1wiLi4vLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuRXZlbnRTb3VyY2U7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwxOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBEcml2ZXIgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5pZiAoRHJpdmVyKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckRyaXZlcih1cmwpIHtcblx0XHRyZXR1cm4gbmV3IERyaXZlcih1cmwpO1xuXHR9O1xufSBlbHNlIHtcblx0bW9kdWxlLmV4cG9ydHMgPSB1bmRlZmluZWQ7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjoyNCxcIi4vcmVjZWl2ZXIvZXZlbnRzb3VyY2VcIjoyOSxcIi4vc2VuZGVyL3hoci1jb3JzXCI6MzUsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEh0bWxmaWxlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2h0bWxmaWxlJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gIDtcblxuZnVuY3Rpb24gSHRtbEZpbGVUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIFhIUkxvY2FsT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkh0bWxGaWxlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIHJldHVybiBIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luO1xufTtcblxuSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sRmlsZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6MzAsXCIuL3NlbmRlci94aHItbG9jYWxcIjozNyxcImluaGVyaXRzXCI6NTd9XSwyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XG4vLyAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MxOTcwMTUodj1WUy44NSkuYXNweFxuLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICBpZiAoIUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub3JpZ2luID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGJhc2VVcmwpO1xuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcblxuICB2YXIgaWZyYW1lVXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2lmcmFtZS5odG1sJykgKyAnIycgKyB0aGlzLndpbmRvd0lkO1xuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xuXG4gIHRoaXMuaWZyYW1lT2JqID0gaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lKGlmcmFtZVVybCwgZnVuY3Rpb24ocikge1xuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1VuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoJyArIHIgKyAnKScpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xufVxuXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICB9IGNhdGNoICh4KSB7XG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgfVxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gICAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgIGRlYnVnKCdub3Qgc2FtZSBvcmlnaW4nLCBlLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xuICB0cnkge1xuICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gIGNhc2UgJ3MnOlxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIC8vIHdpbmRvdyBnbG9iYWwgZGVwZW5kZW5jeVxuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ3MnLCBKU09OMy5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNkYXRhWzBdLCBjZGF0YVsxXSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcbiAgdGhpcy5pZnJhbWVPYmoucG9zdChKU09OMy5zdHJpbmdpZnkoe1xuICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICwgdHlwZTogdHlwZVxuICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgfSksIHRoaXMub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5wb3N0TWVzc2FnZSgnbScsIG1lc3NhZ2UpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vdXRpbHMvdXJsXCI6NTIsXCIuLi92ZXJzaW9uXCI6NTMsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTcsXCJqc29uM1wiOjU4fV0sMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1lc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3Rcbi8vIGV2ZXJ5d2hlcmUuXG4vLyBLbm93biBsaW1pdGF0aW9uczpcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3Jcbi8vICAgbyBmb3IgS29ucXVlcm9yIGEgZHVtYiB0aW1lciBpcyBuZWVkZWQgdG8gZGV0ZWN0IGVycm9yc1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgU2VuZGVyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2xpYi9zZW5kZXItcmVjZWl2ZXInKVxuICAsIEpzb25wUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2pzb25wJylcbiAgLCBqc29ucFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyL2pzb25wJylcbiAgO1xuXG5mdW5jdGlvbiBKc29uUFRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUpzb25QVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsICcvanNvbnAnLCBqc29ucFNlbmRlciwgSnNvbnBSZWNlaXZlcik7XG59XG5cbmluaGVyaXRzKEpzb25QVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50O1xufTtcblxuSnNvblBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdqc29ucC1wb2xsaW5nJztcbkpzb25QVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAxO1xuSnNvblBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25QVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcIi4vcmVjZWl2ZXIvanNvbnBcIjozMSxcIi4vc2VuZGVyL2pzb25wXCI6MzMsXCJpbmhlcml0c1wiOjU3fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmFqYXgtYmFzZWQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ2NyZWF0ZSBhamF4IHNlbmRlcicsIHVybCwgcGF5bG9hZCk7XG4gICAgdmFyIG9wdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5oZWFkZXJzID0geydDb250ZW50LXR5cGUnOiAndGV4dC9wbGFpbid9O1xuICAgIH1cbiAgICB2YXIgYWpheFVybCA9IHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL3hocl9zZW5kJyk7XG4gICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCBhamF4VXJsLCBwYXlsb2FkLCBvcHQpO1xuICAgIHhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cyk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIGlmIChzdGF0dXMgIT09IDIwMCAmJiBzdGF0dXMgIT09IDIwNCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdodHRwIHN0YXR1cyAnICsgc3RhdHVzKSk7XG4gICAgICB9XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdhYm9ydCcpO1xuICAgICAgeG8uY2xvc2UoKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQWJvcnRlZCcpO1xuICAgICAgZXJyLmNvZGUgPSAxMDAwO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiBBamF4QmFzZWRUcmFuc3BvcnQodHJhbnNVcmwsIHVybFN1ZmZpeCwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpIHtcbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgdXJsU3VmZml4LCBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpLCBSZWNlaXZlciwgQWpheE9iamVjdCk7XG59XG5cbmluaGVyaXRzKEFqYXhCYXNlZFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFqYXhCYXNlZFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3VybFwiOjUyLFwiLi9zZW5kZXItcmVjZWl2ZXJcIjoyOCxcImRlYnVnXCI6NTUsXCJpbmhlcml0c1wiOjU3fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnVmZmVyZWQtc2VuZGVyJyk7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkU2VuZGVyKHVybCwgc2VuZGVyKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gIHRoaXMudXJsID0gdXJsO1xufVxuXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICBpZiAoIXRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xuICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmVmO1xuICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3NlbmRTdG9wJyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICB9O1xuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XG4gIH0sIDI1KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZScsIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhpcy5zZW5kQnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSB8fCAxMDA2LCAnU2VuZGluZyBlcnJvcjogJyArIGVycik7XG4gICAgICAgIHNlbGYuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2VuZFNjaGVkdWxlV2FpdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTdG9wKCk7XG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL29iamVjdFwiOjQ5LFwiLi4vaWZyYW1lXCI6MjIsXCJpbmhlcml0c1wiOjU3fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJpbmhlcml0c1wiOjU3fV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBCdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuY2xvc2UuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgICB0aGlzLnBvbGwgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCIuL2J1ZmZlcmVkLXNlbmRlclwiOjI1LFwiLi9wb2xsaW5nXCI6MjcsXCJkZWJ1Z1wiOjU1LFwiaW5oZXJpdHNcIjo1N31dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcImV2ZW50c1wiOjMsXCJldmVudHNvdXJjZVwiOjE4LFwiaW5oZXJpdHNcIjo1N31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgfVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjQ3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6NTAsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG59XG5cbmZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB2YXIgdXJsV2l0aElkID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgdGhpcy5fY3JlYXRlU2NyaXB0KHVybFdpdGhJZCk7XG5cbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XG4gIH0sIEpzb25wUmVjZWl2ZXIudGltZW91dCk7XG59XG5cbmluaGVyaXRzKEpzb25wUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAoZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgdGhpcy5fYWJvcnQoZXJyKTtcbiAgfVxufTtcblxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XG5Kc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGVidWcoJ19jYWxsYmFjaycsIGRhdGEpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgaWYgKHRoaXMuYWJvcnRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5hYm9ydGluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcbiAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgIHRoaXMuc2NyaXB0MiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcbiAgICAvLyB0aGUgc2NyaXB0LlxuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9zY3JpcHRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjcmlwdEVycm9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyb3JUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKScpKTtcbiAgICB9XG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgZGVidWcoJ19jcmVhdGVTY3JpcHQnLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIHNjcmlwdDI7ICAvLyBPcGVyYSBzeW5jaHJvbm91cyBsb2FkIHRyaWNrLlxuXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpJykpO1xuICB9O1xuXG4gIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgLy8gVXNlIGxvYWRlZE9rYXkgdG8gZGV0ZXJtaW5lIGlmIGFjdHVhbGx5IGVycm9yZWRcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBzY3JpcHQucmVhZHlTdGF0ZSk7XG4gICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICBzZWxmLmxvYWRlZE9rYXkgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIC8vIGludGVudGlvbmFsbHkgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgIGlmICghYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICB0cnkge1xuICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIiArIHNjcmlwdC5pZCArIFwiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIH1cblxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIGlmIChzY3JpcHQyKSB7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NDQsXCIuLi8uLi91dGlscy9pZnJhbWVcIjo0NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjp4aHInKTtcbn1cblxuZnVuY3Rpb24gWGhyUmVjZWl2ZXIodXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5idWZmZXJQb3NpdGlvbiA9IDA7XG5cbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsLCBudWxsKTtcbiAgdGhpcy54by5vbignY2h1bmsnLCB0aGlzLl9jaHVua0hhbmRsZXIuYmluZCh0aGlzKSk7XG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi5fY2h1bmtIYW5kbGVyKHN0YXR1cywgdGV4dCk7XG4gICAgc2VsZi54byA9IG51bGw7XG4gICAgdmFyIHJlYXNvbiA9IHN0YXR1cyA9PT0gMjAwID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCc7XG4gICAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhYaHJSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jaHVua0hhbmRsZXIgPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgZGVidWcoJ19jaHVua0hhbmRsZXInLCBzdGF0dXMpO1xuICBpZiAoc3RhdHVzICE9PSAyMDAgfHwgIXRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpZHggPSAtMTsgOyB0aGlzLmJ1ZmZlclBvc2l0aW9uICs9IGlkeCArIDEpIHtcbiAgICB2YXIgYnVmID0gdGV4dC5zbGljZSh0aGlzLmJ1ZmZlclBvc2l0aW9uKTtcbiAgICBpZHggPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIGlkeCk7XG4gICAgaWYgKG1zZykge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgICB9XG4gIH1cbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgaWYgKHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gICAgZGVidWcoJ2Nsb3NlJyk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICd1c2VyJyk7XG4gICAgdGhpcy54byA9IG51bGw7XG4gIH1cbiAgdGhpcy5fY2xlYW51cCgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbn1cblxudmFyIGZvcm0sIGFyZWE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShpZCkge1xuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICB0cnkge1xuICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9ybSgpIHtcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgZm9ybSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcblxuICBhcmVhID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGFyZWEubmFtZSA9ICdkJztcbiAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIGRlYnVnKHVybCwgcGF5bG9hZCk7XG4gIGlmICghZm9ybSkge1xuICAgIGNyZWF0ZUZvcm0oKTtcbiAgfVxuICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBmb3JtLnRhcmdldCA9IGlkO1xuICBmb3JtLmFjdGlvbiA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL2pzb25wX3NlbmQnKSwgJ2k9JyArIGlkKTtcblxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcbiAgaWZyYW1lLmlkID0gaWQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgfVxuICBmb3JtLnN1Ym1pdCgpO1xuXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgaWYgKCFpZnJhbWUub25lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUgPSBudWxsO1xuICAgIH0sIDUwMCk7XG4gICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgaWYgdGhlIGlmcmFtZSBzdWNjZWVkZWQgb3JcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XG4gICAgY29tcGxldGVkKG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjUwLFwiLi4vLi4vdXRpbHMvdXJsXCI6NTIsXCJkZWJ1Z1wiOjU1fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi8uLi91dGlscy9icm93c2VyJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6eGRyJyk7XG59XG5cbi8vIFJlZmVyZW5jZXM6XG4vLyAgIGh0dHA6Ly9hamF4aWFuLmNvbS9hcmNoaXZlcy8xMDAtbGluZS1hamF4LXdyYXBwZXJcbi8vICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMjg4MDYwKHY9VlMuODUpLmFzcHhcblxuZnVuY3Rpb24gWERST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX3N0YXJ0KG1ldGhvZCwgdXJsLCBwYXlsb2FkKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKFhEUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZygnX3N0YXJ0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHhkciA9IG5ldyBnbG9iYWwuWERvbWFpblJlcXVlc3QoKTtcbiAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb250aW1lb3V0Jyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygncHJvZ3Jlc3MnLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLmVtaXQoJ2NodW5rJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgfTtcbiAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdsb2FkJyk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICB9O1xuICB0aGlzLnhkciA9IHhkcjtcbiAgdGhpcy51bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgIHRoaXMueGRyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMueGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gICAgfVxuICAgIHRoaXMueGRyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICB0aGlzLl9lcnJvcigpO1xuICB9XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9lcnJvciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnLCBhYm9ydCk7XG4gIGlmICghdGhpcy54ZHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgZXZlbnRVdGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIHRoaXMueGRyLm9udGltZW91dCA9IHRoaXMueGRyLm9uZXJyb3IgPSB0aGlzLnhkci5vbnByb2dyZXNzID0gdGhpcy54ZHIub25sb2FkID0gbnVsbDtcbiAgaWYgKGFib3J0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGRyLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBlbXB0eVxuICAgIH1cbiAgfVxuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMueGRyID0gbnVsbDtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG4vLyBJRSA4LzkgaWYgdGhlIHJlcXVlc3QgdGFyZ2V0IHVzZXMgdGhlIHNhbWUgc2NoZW1lIC0gIzc5XG5YRFJPYmplY3QuZW5hYmxlZCA9ICEhKGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiBicm93c2VyLmhhc0RvbWFpbigpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBYRFJPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo0NCxcIi4uLy4uL3V0aWxzL2V2ZW50XCI6NDYsXCIuLi8uLi91dGlscy91cmxcIjo1MixcImRlYnVnXCI6NTUsXCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjE3LFwiaW5oZXJpdHNcIjo1N31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkZha2UoLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XG4gIH0sIFhIUkZha2UudGltZW91dCk7XG59XG5cbmluaGVyaXRzKFhIUkZha2UsIEV2ZW50RW1pdHRlcik7XG5cblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcbn07XG5cblhIUkZha2UudGltZW91dCA9IDIwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcblxufSx7XCJldmVudHNcIjozLFwiaW5oZXJpdHNcIjo1N31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkxvY2FsT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkIC8qLCBvcHRzICovKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCB7XG4gICAgbm9DcmVkZW50aWFsczogdHJ1ZVxuICB9KTtcbn1cblxuaW5oZXJpdHMoWEhSTG9jYWxPYmplY3QsIFhockRyaXZlcik7XG5cblhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJMb2NhbE9iamVjdDtcblxufSx7XCIuLi9kcml2ZXIveGhyXCI6MTcsXCJpbmhlcml0c1wiOjU3fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBXZWJzb2NrZXREcml2ZXIgPSByZXF1aXJlKCcuL2RyaXZlci93ZWJzb2NrZXQnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6d2Vic29ja2V0Jyk7XG59XG5cbmZ1bmN0aW9uIFdlYlNvY2tldFRyYW5zcG9ydCh0cmFuc1VybCwgaWdub3JlLCBvcHRpb25zKSB7XG4gIGlmICghV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjb25zdHJ1Y3RvcicsIHRyYW5zVXJsKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCAnL3dlYnNvY2tldCcpO1xuICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgfVxuICB0aGlzLnVybCA9IHVybDtcblxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCwgW10sIG9wdGlvbnMpO1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZSBldmVudCcsIGUuZGF0YSk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgfTtcbiAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gIC8vIGNyZWF0ZWQgYWZ0ZXIgb251bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gIC8vIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2UuIEluIHN1Y2ggc2l0dWF0aW9uIGxldCdzIGxpZSAtXG4gIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NjA4NVxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkJyk7XG4gICAgc2VsZi53cy5jbG9zZSgpO1xuICB9KTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdjbG9zZSBldmVudCcsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3IgZXZlbnQnLCBlKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1dlYlNvY2tldCBjb25uZWN0aW9uIGJyb2tlbicpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbn1cblxuaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBFdmVudEVtaXR0ZXIpO1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciBtc2cgPSAnWycgKyBkYXRhICsgJ10nO1xuICBkZWJ1Zygnc2VuZCcsIG1zZyk7XG4gIHRoaXMud3Muc2VuZChtc2cpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdmFyIHdzID0gdGhpcy53cztcbiAgdGhpcy5fY2xlYW51cCgpO1xuICBpZiAod3MpIHtcbiAgICB3cy5jbG9zZSgpO1xuICB9XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo0NixcIi4uL3V0aWxzL3VybFwiOjUyLFwiLi9kcml2ZXIvd2Vic29ja2V0XCI6MTksXCJkZWJ1Z1wiOjU1LFwiZXZlbnRzXCI6MyxcImluaGVyaXRzXCI6NTd9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3hkci1zdHJlYW1pbmcnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuZnVuY3Rpb24gWGRyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1wb2xsaW5nJztcblhkclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiLi94ZHItc3RyZWFtaW5nXCI6NDAsXCJpbmhlcml0c1wiOjU3fV0sNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5mdW5jdGlvbiBYZHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8uY29va2llX25lZWRlZCB8fCBpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIFhEUk9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZVNjaGVtZTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hkci1zdHJlYW1pbmcnO1xuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjI0LFwiLi9yZWNlaXZlci94aHJcIjozMixcIi4vc2VuZGVyL3hkclwiOjM0LFwiaW5oZXJpdHNcIjo1N31dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICA7XG5cbmZ1bmN0aW9uIFhoclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclBvbGxpbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmIGluZm8uc2FtZU9yaWdpbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXBvbGxpbmcnO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhIUkNvcnNPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWxPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94aHItbG9jYWwnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuLi91dGlscy9icm93c2VyJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJTdHJlYW1pbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYSFJMb2NhbE9iamVjdC5lbmFibGVkICYmICFYSFJDb3JzT2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9wZXJhIGRvZXNuJ3Qgc3VwcG9ydCB4aHItc3RyZWFtaW5nICM2MFxuICAvLyBCdXQgaXQgbWlnaHQgYmUgYWJsZSB0byAjOTJcbiAgaWYgKGJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1zdHJlYW1pbmcnO1xuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuLy8gYmVmb3JlIG9ubG9hZC4gVGhpcyBjYXVzZXMgdGhlIGxvYWQgaW5kaWNhdG9yIHRvIHNwaW4gaW5kZWZpbmV0ZWx5LlxuLy8gT25seSByZXF1aXJlIGJvZHkgd2hlbiB1c2VkIGluIGEgYnJvd3NlclxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRCb2R5ID0gISFnbG9iYWwuZG9jdW1lbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuLi91dGlscy9icm93c2VyXCI6NDQsXCIuL2xpYi9hamF4LWJhc2VkXCI6MjQsXCIuL3JlY2VpdmVyL3hoclwiOjMyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjozNSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjM3LFwiaW5oZXJpdHNcIjo1N31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHt9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJyk7XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcbiAgLCBleHRyYUxvb2t1cDtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxMb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgdmFyIGk7XG4gIHZhciB1bnJvbGxlZCA9IHt9O1xuICB2YXIgYyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICB9XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OMy5zdHJpbmdpZnkoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYUVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFFc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcbiAgICB9KTtcbiAgfVxufTtcblxufSx7XCJqc29uM1wiOjU4fV0sNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL3JhbmRvbVwiOjUwfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBldmVudFV0aWxzID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4vYnJvd3NlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczppZnJhbWUnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIFdQcmVmaXg6ICdfanAnXG4sIGN1cnJlbnRXaW5kb3dJZDogbnVsbFxuXG4sIHBvbGx1dGVHbG9iYWxOYW1lc3BhY2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKG1vZHVsZS5leHBvcnRzLldQcmVmaXggaW4gZ2xvYmFsKSkge1xuICAgICAgZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0ge307XG4gICAgfVxuICB9XG5cbiwgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICBpZiAoZ2xvYmFsLnBhcmVudCAhPT0gZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwucGFyZW50LnBvc3RNZXNzYWdlKEpTT04zLnN0cmluZ2lmeSh7XG4gICAgICAgIHdpbmRvd0lkOiBtb2R1bGUuZXhwb3J0cy5jdXJyZW50V2luZG93SWRcbiAgICAgICwgdHlwZTogdHlwZVxuICAgICAgLCBkYXRhOiBkYXRhIHx8ICcnXG4gICAgICB9KSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ0Nhbm5vdCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy4nLCB0eXBlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuLCBjcmVhdGVJZnJhbWU6IGZ1bmN0aW9uKGlmcmFtZVVybCwgZXJyb3JDYWxsYmFjaykge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZFJlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCd1bmF0dGFjaCcpO1xuICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgLy8gRXhwbG9yZXIgaGFkIHByb2JsZW1zIHdpdGggdGhhdC5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cblxuLyogZXNsaW50IG5vLXVuZGVmOiBcIm9mZlwiLCBuZXctY2FwOiBcIm9mZlwiICovXG4sIGNyZWF0ZUh0bWxmaWxlOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XG4gICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgIGRlYnVnKCdvbmVycm9yJywgcik7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGVtcHR5XG4gICAgICB9XG4gICAgfTtcblxuICAgIGRvYy5vcGVuKCk7XG4gICAgZG9jLndyaXRlKCc8aHRtbD48cycgKyAnY3JpcHQ+JyArXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcbiAgICAgICAgICAgICAgJzwvcycgKyAnY3JpcHQ+PC9odG1sPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XG4gICAgdmFyIGMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGMuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIC8vIHBvc3RNZXNzYWdlIG1pc2JlaGF2ZXMgaW4ga29ucXVlcm9yIDQuNi41IC0gdGhlIG1lc3NhZ2VzIGFyZSBkZWxpdmVyZWQgd2l0aFxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxuICBtb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gKHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFicm93c2VyLmlzS29ucXVlcm9yKCkpO1xufVxuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0sdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7XCIuL2Jyb3dzZXJcIjo0NCxcIi4vZXZlbnRcIjo0NixcImRlYnVnXCI6NTUsXCJqc29uM1wiOjU4fV0sNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbG9nT2JqZWN0ID0ge307XG5bJ2xvZycsICdkZWJ1ZycsICd3YXJuJ10uZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgdmFyIGxldmVsRXhpc3RzO1xuXG4gIHRyeSB7XG4gICAgbGV2ZWxFeGlzdHMgPSBnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0gJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5O1xuICB9IGNhdGNoKGUpIHtcbiAgICAvLyBkbyBub3RoaW5nXG4gIH1cblxuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfSA6IChsZXZlbCA9PT0gJ2xvZycgPyBmdW5jdGlvbiAoKSB7fSA6IGxvZ09iamVjdC5sb2cpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nT2JqZWN0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxufSx7fV0sNTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgY3J5cHRvOnRydWUgKi9cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLy8gVGhpcyBzdHJpbmcgaGFzIGxlbmd0aCAzMiwgYSBwb3dlciBvZiAyLCBzbyB0aGUgbW9kdWx1cyBkb2Vzbid0IGludHJvZHVjZSBhXG4vLyBiaWFzLlxudmFyIF9yYW5kb21TdHJpbmdDaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NSc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgbWF4ID0gX3JhbmRvbVN0cmluZ0NoYXJzLmxlbmd0aDtcbiAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmV0LnB1c2goX3JhbmRvbVN0cmluZ0NoYXJzLnN1YnN0cihieXRlc1tpXSAlIG1heCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiwgbnVtYmVyOiBmdW5jdGlvbihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbiAgfVxuXG4sIG51bWJlclN0cmluZzogZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcbiAgICB2YXIgcCA9IG5ldyBBcnJheSh0ICsgMSkuam9pbignMCcpO1xuICAgIHJldHVybiAocCArIHRoaXMubnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbiAgfVxufTtcblxufSx7XCJjcnlwdG9cIjo0M31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyx7IGVudjoge30gfSlcblxufSx7XCJkZWJ1Z1wiOjU1fV0sNTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnVybCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0T3JpZ2luOiBmdW5jdGlvbih1cmwpIHtcbiAgICBpZiAoIXVybCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgVVJMKHVybCk7XG4gICAgaWYgKHAucHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwb3J0ID0gcC5wb3J0O1xuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IChwLnByb3RvY29sID09PSAnaHR0cHM6JykgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAucHJvdG9jb2wgKyAnLy8nICsgcC5ob3N0bmFtZSArICc6JyArIHBvcnQ7XG4gIH1cblxuLCBpc09yaWdpbkVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHJlcyA9IHRoaXMuZ2V0T3JpZ2luKGEpID09PSB0aGlzLmdldE9yaWdpbihiKTtcbiAgICBkZWJ1Zygnc2FtZScsIGEsIGIsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4sIGlzU2NoZW1lRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuc3BsaXQoJzonKVswXSA9PT0gYi5zcGxpdCgnOicpWzBdKTtcbiAgfVxuXG4sIGFkZFBhdGg6IGZ1bmN0aW9uICh1cmwsIHBhdGgpIHtcbiAgICB2YXIgcXMgPSB1cmwuc3BsaXQoJz8nKTtcbiAgICByZXR1cm4gcXNbMF0gKyBwYXRoICsgKHFzWzFdID8gJz8nICsgcXNbMV0gOiAnJyk7XG4gIH1cblxuLCBhZGRRdWVyeTogZnVuY3Rpb24gKHVybCwgcSkge1xuICAgIHJldHVybiB1cmwgKyAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAoJz8nICsgcSkgOiAoJyYnICsgcSkpO1xuICB9XG59O1xuXG59KS5jYWxsKHRoaXMseyBlbnY6IHt9IH0pXG5cbn0se1wiZGVidWdcIjo1NSxcInVybC1wYXJzZVwiOjYxfV0sNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAnMS40LjAnO1xuXG59LHt9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLT9cXGQ/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG5cbn0se31dLDU1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG5cInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFsnIzAwMDBDQycsICcjMDAwMEZGJywgJyMwMDMzQ0MnLCAnIzAwMzNGRicsICcjMDA2NkNDJywgJyMwMDY2RkYnLCAnIzAwOTlDQycsICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJywgJyMzMzAwQ0MnLCAnIzMzMDBGRicsICcjMzMzM0NDJywgJyMzMzMzRkYnLCAnIzMzNjZDQycsICcjMzM2NkZGJywgJyMzMzk5Q0MnLCAnIzMzOTlGRicsICcjMzNDQzAwJywgJyMzM0NDMzMnLCAnIzMzQ0M2NicsICcjMzNDQzk5JywgJyMzM0NDQ0MnLCAnIzMzQ0NGRicsICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJywgJyM5OTAwRkYnLCAnIzk5MzNDQycsICcjOTkzM0ZGJywgJyM5OUNDMDAnLCAnIzk5Q0MzMycsICcjQ0MwMDAwJywgJyNDQzAwMzMnLCAnI0NDMDA2NicsICcjQ0MwMDk5JywgJyNDQzAwQ0MnLCAnI0NDMDBGRicsICcjQ0MzMzAwJywgJyNDQzMzMzMnLCAnI0NDMzM2NicsICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJywgJyNDQ0NDMDAnLCAnI0NDQ0MzMycsICcjRkYwMDAwJywgJyNGRjAwMzMnLCAnI0ZGMDA2NicsICcjRkYwMDk5JywgJyNGRjAwQ0MnLCAnI0ZGMDBGRicsICcjRkYzMzAwJywgJyNGRjMzMzMnLCAnI0ZGMzM2NicsICcjRkYzMzk5JywgJyNGRjMzQ0MnLCAnI0ZGMzNGRicsICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMyddO1xuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG4gIC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG4gIC8vIGV4cGxpY2l0bHlcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cblxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblxuXG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSB8fCAvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pO1xufVxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuICBhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArIHRoaXMubmFtZXNwYWNlICsgKHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICsgYXJnc1swXSArICh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArICcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF0aGlzLnVzZUNvbG9ycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7IC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIGlmIChtYXRjaCA9PT0gJyUlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluZGV4Kys7XG5cbiAgICBpZiAobWF0Y2ggPT09ICclYycpIHtcbiAgICAgIC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgdmFyIF9jb25zb2xlO1xuXG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAodHlwZW9mIGNvbnNvbGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihjb25zb2xlKSkgPT09ICdvYmplY3QnICYmIGNvbnNvbGUubG9nICYmIChfY29uc29sZSA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZSwgYXJndW1lbnRzKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG5cbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7fSAvLyBTd2FsbG93XG4gIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cblxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcbiAgICByID0gcHJvY2Vzcy5lbnYuREVCVUc7XG4gIH1cblxuICByZXR1cm4gcjtcbn1cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgLy8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuICAgIC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTd2FsbG93XG4gICAgLy8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG4gIH1cbn07XG5cblxufSkuY2FsbCh0aGlzLHsgZW52OiB7fSB9KVxuXG59LHtcIi4vY29tbW9uXCI6NTZ9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gRGlzYWJsZWQ/XG4gICAgICBpZiAoIWRlYnVnLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuXG59LHtcIm1zXCI6NTR9XSw1NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxufSx7fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAoKSB7XG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBBIHNldCBvZiB0eXBlcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIG9iamVjdHMgZnJvbSBwcmltaXRpdmVzLlxuICB2YXIgb2JqZWN0VHlwZXMgPSB7XG4gICAgXCJmdW5jdGlvblwiOiB0cnVlLFxuICAgIFwib2JqZWN0XCI6IHRydWVcbiAgfTtcblxuICAvLyBEZXRlY3QgdGhlIGBleHBvcnRzYCBvYmplY3QgZXhwb3NlZCBieSBDb21tb25KUyBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgLy8gVXNlIHRoZSBgZ2xvYmFsYCBvYmplY3QgZXhwb3NlZCBieSBOb2RlIChpbmNsdWRpbmcgQnJvd3NlcmlmeSB2aWFcbiAgLy8gYGluc2VydC1tb2R1bGUtZ2xvYmFsc2ApLCBOYXJ3aGFsLCBhbmQgUmluZ28gYXMgdGhlIGRlZmF1bHQgY29udGV4dCxcbiAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuICAvLyBpbnN0ZWFkLlxuICB2YXIgcm9vdCA9IG9iamVjdFR5cGVzW3R5cGVvZiB3aW5kb3ddICYmIHdpbmRvdyB8fCB0aGlzLFxuICAgICAgZnJlZUdsb2JhbCA9IGZyZWVFeHBvcnRzICYmIG9iamVjdFR5cGVzW3R5cGVvZiBtb2R1bGVdICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWw7XG5cbiAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcbiAgICByb290ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8vIFB1YmxpYzogSW5pdGlhbGl6ZXMgSlNPTiAzIHVzaW5nIHRoZSBnaXZlbiBgY29udGV4dGAgb2JqZWN0LCBhdHRhY2hpbmcgdGhlXG4gIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG4gIGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0LCBleHBvcnRzKSB7XG4gICAgY29udGV4dCB8fCAoY29udGV4dCA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG4gICAgZXhwb3J0cyB8fCAoZXhwb3J0cyA9IHJvb3RbXCJPYmplY3RcIl0oKSk7XG5cbiAgICAvLyBOYXRpdmUgY29uc3RydWN0b3IgYWxpYXNlcy5cbiAgICB2YXIgTnVtYmVyID0gY29udGV4dFtcIk51bWJlclwiXSB8fCByb290W1wiTnVtYmVyXCJdLFxuICAgICAgICBTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG4gICAgICAgIE9iamVjdCA9IGNvbnRleHRbXCJPYmplY3RcIl0gfHwgcm9vdFtcIk9iamVjdFwiXSxcbiAgICAgICAgRGF0ZSA9IGNvbnRleHRbXCJEYXRlXCJdIHx8IHJvb3RbXCJEYXRlXCJdLFxuICAgICAgICBTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG4gICAgICAgIFR5cGVFcnJvciA9IGNvbnRleHRbXCJUeXBlRXJyb3JcIl0gfHwgcm9vdFtcIlR5cGVFcnJvclwiXSxcbiAgICAgICAgTWF0aCA9IGNvbnRleHRbXCJNYXRoXCJdIHx8IHJvb3RbXCJNYXRoXCJdLFxuICAgICAgICBuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cbiAgICAvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cbiAgICBpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG4gICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgICAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgICB2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgICAgICBnZXRDbGFzcyA9IG9iamVjdFByb3RvLnRvU3RyaW5nLFxuICAgICAgICBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAgIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgICB0cnkge1xuICAgICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gICAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgICB2YXIgcGFyc2UgPSBleHBvcnRzLnBhcnNlO1xuICAgICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICAgIH1cblxuICAgIGlmICghaGFzKFwianNvblwiKSkge1xuICAgICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLFxuICAgICAgICAgIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiLFxuICAgICAgICAgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcbiAgICAgICAgICBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCIsXG4gICAgICAgICAgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIixcbiAgICAgICAgICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBzaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG4gICAgICAgICAgdmFyIHN5bWJvbHMgPSB1c2VDaGFySW5kZXggJiYgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuc3BsaXQoXCJcIikgOiB2YWx1ZSk7XG4gICAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdXNlQ2hhckluZGV4ID8gc3ltYm9sc1tpbmRleF0gOiB2YWx1ZS5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgICAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXhwb3J0c1tcInJ1bkluQ29udGV4dFwiXSA9IHJ1bkluQ29udGV4dDtcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfVxuXG4gIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcbiAgICAvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzIGFuZCBKYXZhU2NyaXB0IGVuZ2luZXMuXG4gICAgdmFyIG5hdGl2ZUpTT04gPSByb290LkpTT04sXG4gICAgICAgIHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcbiAgICAgICAgaXNSZXN0b3JlZCA9IGZhbHNlO1xuXG4gICAgdmFyIEpTT04zID0gcnVuSW5Db250ZXh0KHJvb3QsIChyb290W1wiSlNPTjNcIl0gPSB7XG4gICAgICAvLyBQdWJsaWM6IFJlc3RvcmVzIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgYW5kXG4gICAgICAvLyByZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBgSlNPTjNgIG9iamVjdC5cbiAgICAgIFwibm9Db25mbGljdFwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXN0b3JlZCkge1xuICAgICAgICAgIGlzUmVzdG9yZWQgPSB0cnVlO1xuICAgICAgICAgIHJvb3QuSlNPTiA9IG5hdGl2ZUpTT047XG4gICAgICAgICAgcm9vdFtcIkpTT04zXCJdID0gcHJldmlvdXNKU09OO1xuICAgICAgICAgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OMztcbiAgICAgIH1cbiAgICB9KSk7XG5cbiAgICByb290LkpTT04gPSB7XG4gICAgICBcInBhcnNlXCI6IEpTT04zLnBhcnNlLFxuICAgICAgXCJzdHJpbmdpZnlcIjogSlNPTjMuc3RyaW5naWZ5XG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KS5jYWxsKHRoaXMpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcblxufSx7fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoaW5wdXQucmVwbGFjZSgvXFwrL2csICcgJykpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPT8oW14mXSopL2dcbiAgICAsIHJlc3VsdCA9IHt9XG4gICAgLCBwYXJ0O1xuXG4gIHdoaWxlIChwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpKSB7XG4gICAgdmFyIGtleSA9IGRlY29kZShwYXJ0WzFdKVxuICAgICAgLCB2YWx1ZSA9IGRlY29kZShwYXJ0WzJdKTtcblxuICAgIC8vXG4gICAgLy8gUHJldmVudCBvdmVycmlkaW5nIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMuIFRoaXMgZW5zdXJlcyB0aGF0IGJ1aWxkLWluXG4gICAgLy8gbWV0aG9kcyBsaWtlIGB0b1N0cmluZ2Agb3IgX19wcm90b19fIGFyZSBub3Qgb3ZlcnJpZGVuIGJ5IG1hbGljaW91c1xuICAgIC8vIHF1ZXJ5c3RyaW5ncy5cbiAgICAvL1xuICAgIGlmIChrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG5cbn0se31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuXG59LHt9XSw2MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhcXC9cXC8pPyhbXFxTXFxzXSopL2lcbiAgLCBzbGFzaGVzID0gL15bQS1aYS16XVtBLVphLXowLTkrLS5dKjpcXC9cXC8vO1xuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzKSB7ICAgICAgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoJ1xcXFwnLCAnLycpO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGxvY2F0aW9uID0gZ2xvYmFsICYmIGdsb2JhbC5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICB2YXIgbWF0Y2ggPSBwcm90b2NvbHJlLmV4ZWMoYWRkcmVzcyk7XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgc2xhc2hlczogISFtYXRjaFsyXSxcbiAgICByZXN0OiBtYXRjaFszXVxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVcmwpKSB7XG4gICAgcmV0dXJuIG5ldyBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUsIGV4dHJhY3RlZCwgcGFyc2UsIGluc3RydWN0aW9uLCBpbmRleCwga2V5XG4gICAgLCBpbnN0cnVjdGlvbnMgPSBydWxlcy5zbGljZSgpXG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY2F0aW9uXG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBpID0gMDtcblxuICAvL1xuICAvLyBUaGUgZm9sbG93aW5nIGlmIHN0YXRlbWVudHMgYWxsb3dzIHRoaXMgbW9kdWxlIHR3byBoYXZlIGNvbXBhdGliaWxpdHkgd2l0aFxuICAvLyAyIGRpZmZlcmVudCBBUEk6XG4gIC8vXG4gIC8vIDEuIE5vZGUuanMncyBgdXJsLnBhcnNlYCBhcGkgd2hpY2ggYWNjZXB0cyBhIFVSTCwgYm9vbGVhbiBhcyBhcmd1bWVudHNcbiAgLy8gICAgd2hlcmUgdGhlIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHF1ZXJ5IHN0cmluZyBzaG91bGQgYWxzbyBiZSBwYXJzZWQuXG4gIC8vXG4gIC8vIDIuIFRoZSBgVVJMYCBpbnRlcmZhY2Ugb2YgdGhlIGJyb3dzZXIgd2hpY2ggYWNjZXB0cyBhIFVSTCwgb2JqZWN0IGFzXG4gIC8vICAgIGFyZ3VtZW50cy4gVGhlIHN1cHBsaWVkIG9iamVjdCB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB2YWx1ZXMgLyBmYWxsLWJhY2tcbiAgLy8gICAgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICAvL1xuICBpZiAoJ29iamVjdCcgIT09IHR5cGUgJiYgJ3N0cmluZycgIT09IHR5cGUpIHtcbiAgICBwYXJzZXIgPSBsb2NhdGlvbjtcbiAgICBsb2NhdGlvbiA9IG51bGw7XG4gIH1cblxuICBpZiAocGFyc2VyICYmICdmdW5jdGlvbicgIT09IHR5cGVvZiBwYXJzZXIpIHBhcnNlciA9IHFzLnBhcnNlO1xuXG4gIGxvY2F0aW9uID0gbG9sY2F0aW9uKGxvY2F0aW9uKTtcblxuICAvL1xuICAvLyBFeHRyYWN0IHByb3RvY29sIGluZm9ybWF0aW9uIGJlZm9yZSBydW5uaW5nIHRoZSBpbnN0cnVjdGlvbnMuXG4gIC8vXG4gIGV4dHJhY3RlZCA9IGV4dHJhY3RQcm90b2NvbChhZGRyZXNzIHx8ICcnKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmICghZXh0cmFjdGVkLnNsYXNoZXMpIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG5cbiAgICBpZiAodHlwZW9mIGluc3RydWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhZGRyZXNzID0gaW5zdHJ1Y3Rpb24oYWRkcmVzcyk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwucXMgPSBxcztcblxubW9kdWxlLmV4cG9ydHMgPSBVcmw7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxuXG59LHtcInF1ZXJ5c3RyaW5naWZ5XCI6NTksXCJyZXF1aXJlcy1wb3J0XCI6NjB9XX0se30sWzFdKSgxKVxufSk7XG5cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ja2pzLmpzLm1hcFxuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGVcbiAgbm8tdW51c2VkLXZhcnNcbiovXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlQ2xpZW50KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlQ2xpZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlQ2xpZW50LCBudWxsLCBbe1xuICAgIGtleTogXCJnZXRDbGllbnRQYXRoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENsaWVudFBhdGgob3B0aW9ucykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDbGllbnQgbmVlZHMgaW1wbGVtZW50YXRpb24nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZUNsaWVudDtcbn0oKTsiLCIndXNlIHN0cmljdCc7IC8vIFRoZSBlcnJvciBvdmVybGF5IGlzIGluc3BpcmVkIChhbmQgbW9zdGx5IGNvcGllZCkgZnJvbSBDcmVhdGUgUmVhY3QgQXBwIChodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2tpbmN1YmF0b3IvY3JlYXRlLXJlYWN0LWFwcClcbi8vIFRoZXksIGluIHR1cm4sIGdvdCBpbnNwaXJlZCBieSB3ZWJwYWNrLWhvdC1taWRkbGV3YXJlIChodHRwczovL2dpdGh1Yi5jb20vZ2xlbmphbWluL3dlYnBhY2staG90LW1pZGRsZXdhcmUpLlxuXG52YXIgYW5zaUhUTUwgPSByZXF1aXJlKCdhbnNpLWh0bWwnKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnaHRtbC1lbnRpdGllcycpLFxuICAgIEFsbEh0bWxFbnRpdGllcyA9IF9yZXF1aXJlLkFsbEh0bWxFbnRpdGllcztcblxudmFyIGVudGl0aWVzID0gbmV3IEFsbEh0bWxFbnRpdGllcygpO1xudmFyIGNvbG9ycyA9IHtcbiAgcmVzZXQ6IFsndHJhbnNwYXJlbnQnLCAndHJhbnNwYXJlbnQnXSxcbiAgYmxhY2s6ICcxODE4MTgnLFxuICByZWQ6ICdFMzYwNDknLFxuICBncmVlbjogJ0IzQ0I3NCcsXG4gIHllbGxvdzogJ0ZGRDA4MCcsXG4gIGJsdWU6ICc3Q0FGQzInLFxuICBtYWdlbnRhOiAnN0ZBQ0NBJyxcbiAgY3lhbjogJ0MzQzJFRicsXG4gIGxpZ2h0Z3JleTogJ0VCRTdFMycsXG4gIGRhcmtncmV5OiAnNkQ3ODkxJ1xufTtcbnZhciBvdmVybGF5SWZyYW1lID0gbnVsbDtcbnZhciBvdmVybGF5RGl2ID0gbnVsbDtcbnZhciBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xuYW5zaUhUTUwuc2V0Q29sb3JzKGNvbG9ycyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZU92ZXJsYXlJZnJhbWUob25JZnJhbWVMb2FkKSB7XG4gIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgaWZyYW1lLmlkID0gJ3dlYnBhY2stZGV2LXNlcnZlci1jbGllbnQtb3ZlcmxheSc7XG4gIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICBpZnJhbWUuc3R5bGUubGVmdCA9IDA7XG4gIGlmcmFtZS5zdHlsZS50b3AgPSAwO1xuICBpZnJhbWUuc3R5bGUucmlnaHQgPSAwO1xuICBpZnJhbWUuc3R5bGUuYm90dG9tID0gMDtcbiAgaWZyYW1lLnN0eWxlLndpZHRoID0gJzEwMHZ3JztcbiAgaWZyYW1lLnN0eWxlLmhlaWdodCA9ICcxMDB2aCc7XG4gIGlmcmFtZS5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gIGlmcmFtZS5zdHlsZS56SW5kZXggPSA5OTk5OTk5OTk5O1xuICBpZnJhbWUub25sb2FkID0gb25JZnJhbWVMb2FkO1xuICByZXR1cm4gaWZyYW1lO1xufVxuXG5mdW5jdGlvbiBhZGRPdmVybGF5RGl2VG8oaWZyYW1lKSB7XG4gIHZhciBkaXYgPSBpZnJhbWUuY29udGVudERvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaWQgPSAnd2VicGFjay1kZXYtc2VydmVyLWNsaWVudC1vdmVybGF5LWRpdic7XG4gIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIGRpdi5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gIGRpdi5zdHlsZS5sZWZ0ID0gMDtcbiAgZGl2LnN0eWxlLnRvcCA9IDA7XG4gIGRpdi5zdHlsZS5yaWdodCA9IDA7XG4gIGRpdi5zdHlsZS5ib3R0b20gPSAwO1xuICBkaXYuc3R5bGUud2lkdGggPSAnMTAwdncnO1xuICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMHZoJztcbiAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsIDAsIDAsIDAuODUpJztcbiAgZGl2LnN0eWxlLmNvbG9yID0gJyNFOEU4RTgnO1xuICBkaXYuc3R5bGUuZm9udEZhbWlseSA9ICdNZW5sbywgQ29uc29sYXMsIG1vbm9zcGFjZSc7XG4gIGRpdi5zdHlsZS5mb250U2l6ZSA9ICdsYXJnZSc7XG4gIGRpdi5zdHlsZS5wYWRkaW5nID0gJzJyZW0nO1xuICBkaXYuc3R5bGUubGluZUhlaWdodCA9ICcxLjInO1xuICBkaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gIGRpdi5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gIHJldHVybiBkaXY7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZU92ZXJsYXlEaXZFeGlzdHMob25PdmVybGF5RGl2UmVhZHkpIHtcbiAgaWYgKG92ZXJsYXlEaXYpIHtcbiAgICAvLyBFdmVyeXRoaW5nIGlzIHJlYWR5LCBjYWxsIHRoZSBjYWxsYmFjayByaWdodCBhd2F5LlxuICAgIG9uT3ZlcmxheURpdlJlYWR5KG92ZXJsYXlEaXYpO1xuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGluZyBhbiBpZnJhbWUgbWF5IGJlIGFzeW5jaHJvbm91cyBzbyB3ZSdsbCBzY2hlZHVsZSB0aGUgY2FsbGJhY2suXG4gIC8vIEluIGNhc2Ugb2YgbXVsdGlwbGUgY2FsbHMsIGxhc3QgY2FsbGJhY2sgd2lucy5cblxuXG4gIGxhc3RPbk92ZXJsYXlEaXZSZWFkeSA9IG9uT3ZlcmxheURpdlJlYWR5O1xuXG4gIGlmIChvdmVybGF5SWZyYW1lKSB7XG4gICAgLy8gV2UndmUgYWxyZWFkeSBjcmVhdGVkIGl0LlxuICAgIHJldHVybjtcbiAgfSAvLyBDcmVhdGUgaWZyYW1lIGFuZCwgd2hlbiBpdCBpcyByZWFkeSwgYSBkaXYgaW5zaWRlIGl0LlxuXG5cbiAgb3ZlcmxheUlmcmFtZSA9IGNyZWF0ZU92ZXJsYXlJZnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIG92ZXJsYXlEaXYgPSBhZGRPdmVybGF5RGl2VG8ob3ZlcmxheUlmcmFtZSk7IC8vIE5vdyB3ZSBjYW4gdGFsayFcblxuICAgIGxhc3RPbk92ZXJsYXlEaXZSZWFkeShvdmVybGF5RGl2KTtcbiAgfSk7IC8vIFphbGdvIGFsZXJ0OiBvbklmcmFtZUxvYWQoKSB3aWxsIGJlIGNhbGxlZCBlaXRoZXIgc3luY2hyb25vdXNseVxuICAvLyBvciBhc3luY2hyb25vdXNseSBkZXBlbmRpbmcgb24gdGhlIGJyb3dzZXIuXG4gIC8vIFdlIGRlbGF5IGFkZGluZyBpdCBzbyBgb3ZlcmxheUlmcmFtZWAgaXMgc2V0IHdoZW4gYG9uSWZyYW1lTG9hZGAgZmlyZXMuXG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdmVybGF5SWZyYW1lKTtcbn0gLy8gU3VjY2Vzc2Z1bCBjb21waWxhdGlvbi5cblxuXG5mdW5jdGlvbiBjbGVhcigpIHtcbiAgaWYgKCFvdmVybGF5RGl2KSB7XG4gICAgLy8gSXQgaXMgbm90IHRoZXJlIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAgICByZXR1cm47XG4gIH0gLy8gQ2xlYW4gdXAgYW5kIHJlc2V0IGludGVybmFsIHN0YXRlLlxuXG5cbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChvdmVybGF5SWZyYW1lKTtcbiAgb3ZlcmxheURpdiA9IG51bGw7XG4gIG92ZXJsYXlJZnJhbWUgPSBudWxsO1xuICBsYXN0T25PdmVybGF5RGl2UmVhZHkgPSBudWxsO1xufSAvLyBDb21waWxhdGlvbiB3aXRoIGVycm9ycyAoZS5nLiBzeW50YXggZXJyb3Igb3IgbWlzc2luZyBtb2R1bGVzKS5cblxuXG5mdW5jdGlvbiBzaG93TWVzc2FnZShtZXNzYWdlcykge1xuICBlbnN1cmVPdmVybGF5RGl2RXhpc3RzKGZ1bmN0aW9uIChkaXYpIHtcbiAgICAvLyBNYWtlIGl0IGxvb2sgc2ltaWxhciB0byBvdXIgdGVybWluYWwuXG4gICAgZGl2LmlubmVySFRNTCA9IFwiPHNwYW4gc3R5bGU9XFxcImNvbG9yOiAjXCIuY29uY2F0KGNvbG9ycy5yZWQsIFwiXFxcIj5GYWlsZWQgdG8gY29tcGlsZS48L3NwYW4+PGJyPjxicj5cIikuY29uY2F0KGFuc2lIVE1MKGVudGl0aWVzLmVuY29kZShtZXNzYWdlc1swXSkpKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjbGVhcjogY2xlYXIsXG4gIHNob3dNZXNzYWdlOiBzaG93TWVzc2FnZVxufTsiLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBhbnNpSFRNTFxuXG4vLyBSZWZlcmVuY2UgdG8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9hbnNpLXJlZ2V4XG52YXIgX3JlZ0FOU0kgPSAvKD86KD86XFx1MDAxYlxcWyl8XFx1MDA5YikoPzooPzpbMC05XXsxLDN9KT8oPzooPzo7WzAtOV17MCwzfSkqKT9bQS1NfGYtbV0pfFxcdTAwMWJbQS1NXS9cblxudmFyIF9kZWZDb2xvcnMgPSB7XG4gIHJlc2V0OiBbJ2ZmZicsICcwMDAnXSwgLy8gW0ZPUkVHUk9VRF9DT0xPUiwgQkFDS0dST1VORF9DT0xPUl1cbiAgYmxhY2s6ICcwMDAnLFxuICByZWQ6ICdmZjAwMDAnLFxuICBncmVlbjogJzIwOTgwNScsXG4gIHllbGxvdzogJ2U4YmYwMycsXG4gIGJsdWU6ICcwMDAwZmYnLFxuICBtYWdlbnRhOiAnZmYwMGZmJyxcbiAgY3lhbjogJzAwZmZlZScsXG4gIGxpZ2h0Z3JleTogJ2YwZjBmMCcsXG4gIGRhcmtncmV5OiAnODg4J1xufVxudmFyIF9zdHlsZXMgPSB7XG4gIDMwOiAnYmxhY2snLFxuICAzMTogJ3JlZCcsXG4gIDMyOiAnZ3JlZW4nLFxuICAzMzogJ3llbGxvdycsXG4gIDM0OiAnYmx1ZScsXG4gIDM1OiAnbWFnZW50YScsXG4gIDM2OiAnY3lhbicsXG4gIDM3OiAnbGlnaHRncmV5J1xufVxudmFyIF9vcGVuVGFncyA9IHtcbiAgJzEnOiAnZm9udC13ZWlnaHQ6Ym9sZCcsIC8vIGJvbGRcbiAgJzInOiAnb3BhY2l0eTowLjUnLCAvLyBkaW1cbiAgJzMnOiAnPGk+JywgLy8gaXRhbGljXG4gICc0JzogJzx1PicsIC8vIHVuZGVyc2NvcmVcbiAgJzgnOiAnZGlzcGxheTpub25lJywgLy8gaGlkZGVuXG4gICc5JzogJzxkZWw+JyAvLyBkZWxldGVcbn1cbnZhciBfY2xvc2VUYWdzID0ge1xuICAnMjMnOiAnPC9pPicsIC8vIHJlc2V0IGl0YWxpY1xuICAnMjQnOiAnPC91PicsIC8vIHJlc2V0IHVuZGVyc2NvcmVcbiAgJzI5JzogJzwvZGVsPicgLy8gcmVzZXQgZGVsZXRlXG59XG5cbjtbMCwgMjEsIDIyLCAyNywgMjgsIDM5LCA0OV0uZm9yRWFjaChmdW5jdGlvbiAobikge1xuICBfY2xvc2VUYWdzW25dID0gJzwvc3Bhbj4nXG59KVxuXG4vKipcbiAqIENvbnZlcnRzIHRleHQgd2l0aCBBTlNJIGNvbG9yIGNvZGVzIHRvIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHtTdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBhbnNpSFRNTCAodGV4dCkge1xuICAvLyBSZXR1cm5zIHRoZSB0ZXh0IGlmIHRoZSBzdHJpbmcgaGFzIG5vIEFOU0kgZXNjYXBlIGNvZGUuXG4gIGlmICghX3JlZ0FOU0kudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICAvLyBDYWNoZSBvcGVuZWQgc2VxdWVuY2UuXG4gIHZhciBhbnNpQ29kZXMgPSBbXVxuICAvLyBSZXBsYWNlIHdpdGggbWFya3VwLlxuICB2YXIgcmV0ID0gdGV4dC5yZXBsYWNlKC9cXDAzM1xcWyhcXGQrKSptL2csIGZ1bmN0aW9uIChtYXRjaCwgc2VxKSB7XG4gICAgdmFyIG90ID0gX29wZW5UYWdzW3NlcV1cbiAgICBpZiAob3QpIHtcbiAgICAgIC8vIElmIGN1cnJlbnQgc2VxdWVuY2UgaGFzIGJlZW4gb3BlbmVkLCBjbG9zZSBpdC5cbiAgICAgIGlmICghIX5hbnNpQ29kZXMuaW5kZXhPZihzZXEpKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0cmEtYm9vbGVhbi1jYXN0XG4gICAgICAgIGFuc2lDb2Rlcy5wb3AoKVxuICAgICAgICByZXR1cm4gJzwvc3Bhbj4nXG4gICAgICB9XG4gICAgICAvLyBPcGVuIHRhZy5cbiAgICAgIGFuc2lDb2Rlcy5wdXNoKHNlcSlcbiAgICAgIHJldHVybiBvdFswXSA9PT0gJzwnID8gb3QgOiAnPHNwYW4gc3R5bGU9XCInICsgb3QgKyAnO1wiPidcbiAgICB9XG5cbiAgICB2YXIgY3QgPSBfY2xvc2VUYWdzW3NlcV1cbiAgICBpZiAoY3QpIHtcbiAgICAgIC8vIFBvcCBzZXF1ZW5jZVxuICAgICAgYW5zaUNvZGVzLnBvcCgpXG4gICAgICByZXR1cm4gY3RcbiAgICB9XG4gICAgcmV0dXJuICcnXG4gIH0pXG5cbiAgLy8gTWFrZSBzdXJlIHRhZ3MgYXJlIGNsb3NlZC5cbiAgdmFyIGwgPSBhbnNpQ29kZXMubGVuZ3RoXG4gIDsobCA+IDApICYmIChyZXQgKz0gQXJyYXkobCArIDEpLmpvaW4oJzwvc3Bhbj4nKSlcblxuICByZXR1cm4gcmV0XG59XG5cbi8qKlxuICogQ3VzdG9taXplIGNvbG9ycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgcmVmZXJlbmNlIHRvIF9kZWZDb2xvcnNcbiAqL1xuYW5zaUhUTUwuc2V0Q29sb3JzID0gZnVuY3Rpb24gKGNvbG9ycykge1xuICBpZiAodHlwZW9mIGNvbG9ycyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bjb2xvcnNgIHBhcmFtZXRlciBtdXN0IGJlIGFuIE9iamVjdC4nKVxuICB9XG5cbiAgdmFyIF9maW5hbENvbG9ycyA9IHt9XG4gIGZvciAodmFyIGtleSBpbiBfZGVmQ29sb3JzKSB7XG4gICAgdmFyIGhleCA9IGNvbG9ycy5oYXNPd25Qcm9wZXJ0eShrZXkpID8gY29sb3JzW2tleV0gOiBudWxsXG4gICAgaWYgKCFoZXgpIHtcbiAgICAgIF9maW5hbENvbG9yc1trZXldID0gX2RlZkNvbG9yc1trZXldXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoJ3Jlc2V0JyA9PT0ga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaGV4ID0gW2hleF1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShoZXgpIHx8IGhleC5sZW5ndGggPT09IDAgfHwgaGV4LnNvbWUoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBoICE9PSAnc3RyaW5nJ1xuICAgICAgfSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdmFsdWUgb2YgYCcgKyBrZXkgKyAnYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIEFycmF5IGFuZCBlYWNoIGl0ZW0gY291bGQgb25seSBiZSBhIGhleCBzdHJpbmcsIGUuZy46IEZGMDAwMCcpXG4gICAgICB9XG4gICAgICB2YXIgZGVmSGV4Q29sb3IgPSBfZGVmQ29sb3JzW2tleV1cbiAgICAgIGlmICghaGV4WzBdKSB7XG4gICAgICAgIGhleFswXSA9IGRlZkhleENvbG9yWzBdXG4gICAgICB9XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMSB8fCAhaGV4WzFdKSB7XG4gICAgICAgIGhleCA9IFtoZXhbMF1dXG4gICAgICAgIGhleC5wdXNoKGRlZkhleENvbG9yWzFdKVxuICAgICAgfVxuXG4gICAgICBoZXggPSBoZXguc2xpY2UoMCwgMilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSB2YWx1ZSBvZiBgJyArIGtleSArICdgIHByb3BlcnR5IG11c3QgYmUgYSBoZXggc3RyaW5nLCBlLmcuOiBGRjAwMDAnKVxuICAgIH1cbiAgICBfZmluYWxDb2xvcnNba2V5XSA9IGhleFxuICB9XG4gIF9zZXRUYWdzKF9maW5hbENvbG9ycylcbn1cblxuLyoqXG4gKiBSZXNldCBjb2xvcnMuXG4gKi9cbmFuc2lIVE1MLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBfc2V0VGFncyhfZGVmQ29sb3JzKVxufVxuXG4vKipcbiAqIEV4cG9zZSB0YWdzLCBpbmNsdWRpbmcgb3BlbiBhbmQgY2xvc2UuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5hbnNpSFRNTC50YWdzID0ge31cblxuaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ29wZW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBfb3BlblRhZ3MgfVxuICB9KVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5zaUhUTUwudGFncywgJ2Nsb3NlJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gX2Nsb3NlVGFncyB9XG4gIH0pXG59IGVsc2Uge1xuICBhbnNpSFRNTC50YWdzLm9wZW4gPSBfb3BlblRhZ3NcbiAgYW5zaUhUTUwudGFncy5jbG9zZSA9IF9jbG9zZVRhZ3Ncbn1cblxuZnVuY3Rpb24gX3NldFRhZ3MgKGNvbG9ycykge1xuICAvLyByZXNldCBhbGxcbiAgX29wZW5UYWdzWycwJ10gPSAnZm9udC13ZWlnaHQ6bm9ybWFsO29wYWNpdHk6MTtjb2xvcjojJyArIGNvbG9ycy5yZXNldFswXSArICc7YmFja2dyb3VuZDojJyArIGNvbG9ycy5yZXNldFsxXVxuICAvLyBpbnZlcnNlXG4gIF9vcGVuVGFnc1snNyddID0gJ2NvbG9yOiMnICsgY29sb3JzLnJlc2V0WzFdICsgJztiYWNrZ3JvdW5kOiMnICsgY29sb3JzLnJlc2V0WzBdXG4gIC8vIGRhcmsgZ3JleVxuICBfb3BlblRhZ3NbJzkwJ10gPSAnY29sb3I6IycgKyBjb2xvcnMuZGFya2dyZXlcblxuICBmb3IgKHZhciBjb2RlIGluIF9zdHlsZXMpIHtcbiAgICB2YXIgY29sb3IgPSBfc3R5bGVzW2NvZGVdXG4gICAgdmFyIG9yaUNvbG9yID0gY29sb3JzW2NvbG9yXSB8fCAnMDAwJ1xuICAgIF9vcGVuVGFnc1tjb2RlXSA9ICdjb2xvcjojJyArIG9yaUNvbG9yXG4gICAgY29kZSA9IHBhcnNlSW50KGNvZGUpXG4gICAgX29wZW5UYWdzWyhjb2RlICsgMTApLnRvU3RyaW5nKCldID0gJ2JhY2tncm91bmQ6IycgKyBvcmlDb2xvclxuICB9XG59XG5cbmFuc2lIVE1MLnJlc2V0KClcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBYbWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIveG1sLWVudGl0aWVzLmpzJyksXG4gIEh0bWw0RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw0LWVudGl0aWVzLmpzJyksXG4gIEh0bWw1RW50aXRpZXM6IHJlcXVpcmUoJy4vbGliL2h0bWw1LWVudGl0aWVzLmpzJyksXG4gIEFsbEh0bWxFbnRpdGllczogcmVxdWlyZSgnLi9saWIvaHRtbDUtZW50aXRpZXMuanMnKVxufTtcbiIsInZhciBBTFBIQV9JTkRFWCA9IHtcbiAgICAnJmx0JzogJzwnLFxuICAgICcmZ3QnOiAnPicsXG4gICAgJyZxdW90JzogJ1wiJyxcbiAgICAnJmFwb3MnOiAnXFwnJyxcbiAgICAnJmFtcCc6ICcmJyxcbiAgICAnJmx0Oyc6ICc8JyxcbiAgICAnJmd0Oyc6ICc+JyxcbiAgICAnJnF1b3Q7JzogJ1wiJyxcbiAgICAnJmFwb3M7JzogJ1xcJycsXG4gICAgJyZhbXA7JzogJyYnXG59O1xuXG52YXIgQ0hBUl9JTkRFWCA9IHtcbiAgICA2MDogJ2x0JyxcbiAgICA2MjogJ2d0JyxcbiAgICAzNDogJ3F1b3QnLFxuICAgIDM5OiAnYXBvcycsXG4gICAgMzg6ICdhbXAnXG59O1xuXG52YXIgQ0hBUl9TX0lOREVYID0ge1xuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgICdcXCcnOiAnJmFwb3M7JyxcbiAgICAnJic6ICcmYW1wOydcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFhtbEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLzx8PnxcInwnfCYvZywgZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gQ0hBUl9TX0lOREVYW3NdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gWG1sRW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZShzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuWG1sRW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mIz9bMC05YS16QS1aXSs7Py9nLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIGlmIChzLmNoYXJBdCgxKSA9PT0gJyMnKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IHMuY2hhckF0KDIpLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMyksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQocy5zdWJzdHIoMikpO1xuXG4gICAgICAgICAgICBpZiAoaXNOYU4oY29kZSkgfHwgY29kZSA8IC0zMjc2OCB8fCBjb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQUxQSEFfSU5ERVhbc10gfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgWG1sRW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblhtbEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGFscGhhID0gQ0hBUl9JTkRFWFtjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBYbWxFbnRpdGllcy5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IFhtbEVudGl0aWVzKCkuZW5jb2RlTm9uVVRGKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5YbWxFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5naHQgPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5naHQpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIFhtbEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBYbWxFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxubW9kdWxlLmV4cG9ydHMgPSBYbWxFbnRpdGllcztcbiIsInZhciBIVE1MX0FMUEhBID0gWydhcG9zJywgJ25ic3AnLCAnaWV4Y2wnLCAnY2VudCcsICdwb3VuZCcsICdjdXJyZW4nLCAneWVuJywgJ2JydmJhcicsICdzZWN0JywgJ3VtbCcsICdjb3B5JywgJ29yZGYnLCAnbGFxdW8nLCAnbm90JywgJ3NoeScsICdyZWcnLCAnbWFjcicsICdkZWcnLCAncGx1c21uJywgJ3N1cDInLCAnc3VwMycsICdhY3V0ZScsICdtaWNybycsICdwYXJhJywgJ21pZGRvdCcsICdjZWRpbCcsICdzdXAxJywgJ29yZG0nLCAncmFxdW8nLCAnZnJhYzE0JywgJ2ZyYWMxMicsICdmcmFjMzQnLCAnaXF1ZXN0JywgJ0FncmF2ZScsICdBYWN1dGUnLCAnQWNpcmMnLCAnQXRpbGRlJywgJ0F1bWwnLCAnQXJpbmcnLCAnQWVsaWcnLCAnQ2NlZGlsJywgJ0VncmF2ZScsICdFYWN1dGUnLCAnRWNpcmMnLCAnRXVtbCcsICdJZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjJywgJ0l1bWwnLCAnRVRIJywgJ050aWxkZScsICdPZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjJywgJ090aWxkZScsICdPdW1sJywgJ3RpbWVzJywgJ09zbGFzaCcsICdVZ3JhdmUnLCAnVWFjdXRlJywgJ1VjaXJjJywgJ1V1bWwnLCAnWWFjdXRlJywgJ1RIT1JOJywgJ3N6bGlnJywgJ2FncmF2ZScsICdhYWN1dGUnLCAnYWNpcmMnLCAnYXRpbGRlJywgJ2F1bWwnLCAnYXJpbmcnLCAnYWVsaWcnLCAnY2NlZGlsJywgJ2VncmF2ZScsICdlYWN1dGUnLCAnZWNpcmMnLCAnZXVtbCcsICdpZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjJywgJ2l1bWwnLCAnZXRoJywgJ250aWxkZScsICdvZ3JhdmUnLCAnb2FjdXRlJywgJ29jaXJjJywgJ290aWxkZScsICdvdW1sJywgJ2RpdmlkZScsICdvc2xhc2gnLCAndWdyYXZlJywgJ3VhY3V0ZScsICd1Y2lyYycsICd1dW1sJywgJ3lhY3V0ZScsICd0aG9ybicsICd5dW1sJywgJ3F1b3QnLCAnYW1wJywgJ2x0JywgJ2d0JywgJ09FbGlnJywgJ29lbGlnJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWXVtbCcsICdjaXJjJywgJ3RpbGRlJywgJ2Vuc3AnLCAnZW1zcCcsICd0aGluc3AnLCAnenduaicsICd6d2onLCAnbHJtJywgJ3JsbScsICduZGFzaCcsICdtZGFzaCcsICdsc3F1bycsICdyc3F1bycsICdzYnF1bycsICdsZHF1bycsICdyZHF1bycsICdiZHF1bycsICdkYWdnZXInLCAnRGFnZ2VyJywgJ3Blcm1pbCcsICdsc2FxdW8nLCAncnNhcXVvJywgJ2V1cm8nLCAnZm5vZicsICdBbHBoYScsICdCZXRhJywgJ0dhbW1hJywgJ0RlbHRhJywgJ0Vwc2lsb24nLCAnWmV0YScsICdFdGEnLCAnVGhldGEnLCAnSW90YScsICdLYXBwYScsICdMYW1iZGEnLCAnTXUnLCAnTnUnLCAnWGknLCAnT21pY3JvbicsICdQaScsICdSaG8nLCAnU2lnbWEnLCAnVGF1JywgJ1Vwc2lsb24nLCAnUGhpJywgJ0NoaScsICdQc2knLCAnT21lZ2EnLCAnYWxwaGEnLCAnYmV0YScsICdnYW1tYScsICdkZWx0YScsICdlcHNpbG9uJywgJ3pldGEnLCAnZXRhJywgJ3RoZXRhJywgJ2lvdGEnLCAna2FwcGEnLCAnbGFtYmRhJywgJ211JywgJ251JywgJ3hpJywgJ29taWNyb24nLCAncGknLCAncmhvJywgJ3NpZ21hZicsICdzaWdtYScsICd0YXUnLCAndXBzaWxvbicsICdwaGknLCAnY2hpJywgJ3BzaScsICdvbWVnYScsICd0aGV0YXN5bScsICd1cHNpaCcsICdwaXYnLCAnYnVsbCcsICdoZWxsaXAnLCAncHJpbWUnLCAnUHJpbWUnLCAnb2xpbmUnLCAnZnJhc2wnLCAnd2VpZXJwJywgJ2ltYWdlJywgJ3JlYWwnLCAndHJhZGUnLCAnYWxlZnN5bScsICdsYXJyJywgJ3VhcnInLCAncmFycicsICdkYXJyJywgJ2hhcnInLCAnY3JhcnInLCAnbEFycicsICd1QXJyJywgJ3JBcnInLCAnZEFycicsICdoQXJyJywgJ2ZvcmFsbCcsICdwYXJ0JywgJ2V4aXN0JywgJ2VtcHR5JywgJ25hYmxhJywgJ2lzaW4nLCAnbm90aW4nLCAnbmknLCAncHJvZCcsICdzdW0nLCAnbWludXMnLCAnbG93YXN0JywgJ3JhZGljJywgJ3Byb3AnLCAnaW5maW4nLCAnYW5nJywgJ2FuZCcsICdvcicsICdjYXAnLCAnY3VwJywgJ2ludCcsICd0aGVyZTQnLCAnc2ltJywgJ2NvbmcnLCAnYXN5bXAnLCAnbmUnLCAnZXF1aXYnLCAnbGUnLCAnZ2UnLCAnc3ViJywgJ3N1cCcsICduc3ViJywgJ3N1YmUnLCAnc3VwZScsICdvcGx1cycsICdvdGltZXMnLCAncGVycCcsICdzZG90JywgJ2xjZWlsJywgJ3JjZWlsJywgJ2xmbG9vcicsICdyZmxvb3InLCAnbGFuZycsICdyYW5nJywgJ2xveicsICdzcGFkZXMnLCAnY2x1YnMnLCAnaGVhcnRzJywgJ2RpYW1zJ107XG52YXIgSFRNTF9DT0RFUyA9IFszOSwgMTYwLCAxNjEsIDE2MiwgMTYzLCAxNjQsIDE2NSwgMTY2LCAxNjcsIDE2OCwgMTY5LCAxNzAsIDE3MSwgMTcyLCAxNzMsIDE3NCwgMTc1LCAxNzYsIDE3NywgMTc4LCAxNzksIDE4MCwgMTgxLCAxODIsIDE4MywgMTg0LCAxODUsIDE4NiwgMTg3LCAxODgsIDE4OSwgMTkwLCAxOTEsIDE5MiwgMTkzLCAxOTQsIDE5NSwgMTk2LCAxOTcsIDE5OCwgMTk5LCAyMDAsIDIwMSwgMjAyLCAyMDMsIDIwNCwgMjA1LCAyMDYsIDIwNywgMjA4LCAyMDksIDIxMCwgMjExLCAyMTIsIDIxMywgMjE0LCAyMTUsIDIxNiwgMjE3LCAyMTgsIDIxOSwgMjIwLCAyMjEsIDIyMiwgMjIzLCAyMjQsIDIyNSwgMjI2LCAyMjcsIDIyOCwgMjI5LCAyMzAsIDIzMSwgMjMyLCAyMzMsIDIzNCwgMjM1LCAyMzYsIDIzNywgMjM4LCAyMzksIDI0MCwgMjQxLCAyNDIsIDI0MywgMjQ0LCAyNDUsIDI0NiwgMjQ3LCAyNDgsIDI0OSwgMjUwLCAyNTEsIDI1MiwgMjUzLCAyNTQsIDI1NSwgMzQsIDM4LCA2MCwgNjIsIDMzOCwgMzM5LCAzNTIsIDM1MywgMzc2LCA3MTAsIDczMiwgODE5NCwgODE5NSwgODIwMSwgODIwNCwgODIwNSwgODIwNiwgODIwNywgODIxMSwgODIxMiwgODIxNiwgODIxNywgODIxOCwgODIyMCwgODIyMSwgODIyMiwgODIyNCwgODIyNSwgODI0MCwgODI0OSwgODI1MCwgODM2NCwgNDAyLCA5MTMsIDkxNCwgOTE1LCA5MTYsIDkxNywgOTE4LCA5MTksIDkyMCwgOTIxLCA5MjIsIDkyMywgOTI0LCA5MjUsIDkyNiwgOTI3LCA5MjgsIDkyOSwgOTMxLCA5MzIsIDkzMywgOTM0LCA5MzUsIDkzNiwgOTM3LCA5NDUsIDk0NiwgOTQ3LCA5NDgsIDk0OSwgOTUwLCA5NTEsIDk1MiwgOTUzLCA5NTQsIDk1NSwgOTU2LCA5NTcsIDk1OCwgOTU5LCA5NjAsIDk2MSwgOTYyLCA5NjMsIDk2NCwgOTY1LCA5NjYsIDk2NywgOTY4LCA5NjksIDk3NywgOTc4LCA5ODIsIDgyMjYsIDgyMzAsIDgyNDIsIDgyNDMsIDgyNTQsIDgyNjAsIDg0NzIsIDg0NjUsIDg0NzYsIDg0ODIsIDg1MDEsIDg1OTIsIDg1OTMsIDg1OTQsIDg1OTUsIDg1OTYsIDg2MjksIDg2NTYsIDg2NTcsIDg2NTgsIDg2NTksIDg2NjAsIDg3MDQsIDg3MDYsIDg3MDcsIDg3MDksIDg3MTEsIDg3MTIsIDg3MTMsIDg3MTUsIDg3MTksIDg3MjEsIDg3MjIsIDg3MjcsIDg3MzAsIDg3MzMsIDg3MzQsIDg3MzYsIDg3NDMsIDg3NDQsIDg3NDUsIDg3NDYsIDg3NDcsIDg3NTYsIDg3NjQsIDg3NzMsIDg3NzYsIDg4MDAsIDg4MDEsIDg4MDQsIDg4MDUsIDg4MzQsIDg4MzUsIDg4MzYsIDg4MzgsIDg4MzksIDg4NTMsIDg4NTUsIDg4NjksIDg5MDEsIDg5NjgsIDg5NjksIDg5NzAsIDg5NzEsIDkwMDEsIDkwMDIsIDk2NzQsIDk4MjQsIDk4MjcsIDk4MjksIDk4MzBdO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIG51bUluZGV4ID0ge307XG5cbnZhciBpID0gMDtcbnZhciBsZW5ndGggPSBIVE1MX0FMUEhBLmxlbmd0aDtcbndoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgdmFyIGEgPSBIVE1MX0FMUEhBW2ldO1xuICAgIHZhciBjID0gSFRNTF9DT0RFU1tpXTtcbiAgICBhbHBoYUluZGV4W2FdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjKTtcbiAgICBudW1JbmRleFtjXSA9IGE7XG4gICAgaSsrO1xufVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBIdG1sNEVudGl0aWVzKCkge31cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJigjP1tcXHdcXGRdKyk7Py9nLCBmdW5jdGlvbihzLCBlbnRpdHkpIHtcbiAgICAgICAgdmFyIGNocjtcbiAgICAgICAgaWYgKGVudGl0eS5jaGFyQXQoMCkgPT09IFwiI1wiKSB7XG4gICAgICAgICAgICB2YXIgY29kZSA9IGVudGl0eS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLCAxNikgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KGVudGl0eS5zdWJzdHIoMSkpO1xuXG4gICAgICAgICAgICBpZiAoIShpc05hTihjb2RlKSB8fCBjb2RlIDwgLTMyNzY4IHx8IGNvZGUgPiA2NTUzNSkpIHtcbiAgICAgICAgICAgICAgICBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyID0gYWxwaGFJbmRleFtlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHIgfHwgcztcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw0RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDRFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgIXN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB2YXIgc3RyTGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgc3RyTGVuZ3RoKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICAgICAgcmVzdWx0ICs9IGFscGhhID8gXCImXCIgKyBhbHBoYSArIFwiO1wiIDogc3RyLmNoYXJBdChpKTtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZShzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGNjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBhbHBoYSA9IG51bUluZGV4W2NjXTtcbiAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCImXCIgKyBhbHBoYSArIFwiO1wiO1xuICAgICAgICB9IGVsc2UgaWYgKGNjIDwgMzIgfHwgY2MgPiAxMjYpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiYjXCIgKyBjYyArIFwiO1wiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDRFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8PSAyNTUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzdHJbaSsrXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnJiMnICsgYyArICc7JztcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNEVudGl0aWVzLmVuY29kZU5vbkFTQ0lJID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNEVudGl0aWVzKCkuZW5jb2RlTm9uQVNDSUkoc3RyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDRFbnRpdGllcztcbiIsInZhciBFTlRJVElFUyA9IFtbJ0FhY3V0ZScsIFsxOTNdXSwgWydhYWN1dGUnLCBbMjI1XV0sIFsnQWJyZXZlJywgWzI1OF1dLCBbJ2FicmV2ZScsIFsyNTldXSwgWydhYycsIFs4NzY2XV0sIFsnYWNkJywgWzg3NjddXSwgWydhY0UnLCBbODc2NiwgODE5XV0sIFsnQWNpcmMnLCBbMTk0XV0sIFsnYWNpcmMnLCBbMjI2XV0sIFsnYWN1dGUnLCBbMTgwXV0sIFsnQWN5JywgWzEwNDBdXSwgWydhY3knLCBbMTA3Ml1dLCBbJ0FFbGlnJywgWzE5OF1dLCBbJ2FlbGlnJywgWzIzMF1dLCBbJ2FmJywgWzgyODldXSwgWydBZnInLCBbMTIwMDY4XV0sIFsnYWZyJywgWzEyMDA5NF1dLCBbJ0FncmF2ZScsIFsxOTJdXSwgWydhZ3JhdmUnLCBbMjI0XV0sIFsnYWxlZnN5bScsIFs4NTAxXV0sIFsnYWxlcGgnLCBbODUwMV1dLCBbJ0FscGhhJywgWzkxM11dLCBbJ2FscGhhJywgWzk0NV1dLCBbJ0FtYWNyJywgWzI1Nl1dLCBbJ2FtYWNyJywgWzI1N11dLCBbJ2FtYWxnJywgWzEwODE1XV0sIFsnYW1wJywgWzM4XV0sIFsnQU1QJywgWzM4XV0sIFsnYW5kYW5kJywgWzEwODM3XV0sIFsnQW5kJywgWzEwODM1XV0sIFsnYW5kJywgWzg3NDNdXSwgWydhbmRkJywgWzEwODQ0XV0sIFsnYW5kc2xvcGUnLCBbMTA4NDBdXSwgWydhbmR2JywgWzEwODQyXV0sIFsnYW5nJywgWzg3MzZdXSwgWydhbmdlJywgWzEwNjYwXV0sIFsnYW5nbGUnLCBbODczNl1dLCBbJ2FuZ21zZGFhJywgWzEwNjY0XV0sIFsnYW5nbXNkYWInLCBbMTA2NjVdXSwgWydhbmdtc2RhYycsIFsxMDY2Nl1dLCBbJ2FuZ21zZGFkJywgWzEwNjY3XV0sIFsnYW5nbXNkYWUnLCBbMTA2NjhdXSwgWydhbmdtc2RhZicsIFsxMDY2OV1dLCBbJ2FuZ21zZGFnJywgWzEwNjcwXV0sIFsnYW5nbXNkYWgnLCBbMTA2NzFdXSwgWydhbmdtc2QnLCBbODczN11dLCBbJ2FuZ3J0JywgWzg3MzVdXSwgWydhbmdydHZiJywgWzg4OTRdXSwgWydhbmdydHZiZCcsIFsxMDY1M11dLCBbJ2FuZ3NwaCcsIFs4NzM4XV0sIFsnYW5nc3QnLCBbMTk3XV0sIFsnYW5nemFycicsIFs5MDg0XV0sIFsnQW9nb24nLCBbMjYwXV0sIFsnYW9nb24nLCBbMjYxXV0sIFsnQW9wZicsIFsxMjAxMjBdXSwgWydhb3BmJywgWzEyMDE0Nl1dLCBbJ2FwYWNpcicsIFsxMDg2M11dLCBbJ2FwJywgWzg3NzZdXSwgWydhcEUnLCBbMTA4NjRdXSwgWydhcGUnLCBbODc3OF1dLCBbJ2FwaWQnLCBbODc3OV1dLCBbJ2Fwb3MnLCBbMzldXSwgWydBcHBseUZ1bmN0aW9uJywgWzgyODldXSwgWydhcHByb3gnLCBbODc3Nl1dLCBbJ2FwcHJveGVxJywgWzg3NzhdXSwgWydBcmluZycsIFsxOTddXSwgWydhcmluZycsIFsyMjldXSwgWydBc2NyJywgWzExOTk2NF1dLCBbJ2FzY3InLCBbMTE5OTkwXV0sIFsnQXNzaWduJywgWzg3ODhdXSwgWydhc3QnLCBbNDJdXSwgWydhc3ltcCcsIFs4Nzc2XV0sIFsnYXN5bXBlcScsIFs4NzgxXV0sIFsnQXRpbGRlJywgWzE5NV1dLCBbJ2F0aWxkZScsIFsyMjddXSwgWydBdW1sJywgWzE5Nl1dLCBbJ2F1bWwnLCBbMjI4XV0sIFsnYXdjb25pbnQnLCBbODc1NV1dLCBbJ2F3aW50JywgWzEwNzY5XV0sIFsnYmFja2NvbmcnLCBbODc4MF1dLCBbJ2JhY2tlcHNpbG9uJywgWzEwMTRdXSwgWydiYWNrcHJpbWUnLCBbODI0NV1dLCBbJ2JhY2tzaW0nLCBbODc2NV1dLCBbJ2JhY2tzaW1lcScsIFs4OTA5XV0sIFsnQmFja3NsYXNoJywgWzg3MjZdXSwgWydCYXJ2JywgWzEwOTgzXV0sIFsnYmFydmVlJywgWzg4OTNdXSwgWydiYXJ3ZWQnLCBbODk2NV1dLCBbJ0JhcndlZCcsIFs4OTY2XV0sIFsnYmFyd2VkZ2UnLCBbODk2NV1dLCBbJ2JicmsnLCBbOTE0MV1dLCBbJ2Jicmt0YnJrJywgWzkxNDJdXSwgWydiY29uZycsIFs4NzgwXV0sIFsnQmN5JywgWzEwNDFdXSwgWydiY3knLCBbMTA3M11dLCBbJ2JkcXVvJywgWzgyMjJdXSwgWydiZWNhdXMnLCBbODc1N11dLCBbJ2JlY2F1c2UnLCBbODc1N11dLCBbJ0JlY2F1c2UnLCBbODc1N11dLCBbJ2JlbXB0eXYnLCBbMTA2NzJdXSwgWydiZXBzaScsIFsxMDE0XV0sIFsnYmVybm91JywgWzg0OTJdXSwgWydCZXJub3VsbGlzJywgWzg0OTJdXSwgWydCZXRhJywgWzkxNF1dLCBbJ2JldGEnLCBbOTQ2XV0sIFsnYmV0aCcsIFs4NTAyXV0sIFsnYmV0d2VlbicsIFs4ODEyXV0sIFsnQmZyJywgWzEyMDA2OV1dLCBbJ2JmcicsIFsxMjAwOTVdXSwgWydiaWdjYXAnLCBbODg5OF1dLCBbJ2JpZ2NpcmMnLCBbOTcxMV1dLCBbJ2JpZ2N1cCcsIFs4ODk5XV0sIFsnYmlnb2RvdCcsIFsxMDc1Ml1dLCBbJ2JpZ29wbHVzJywgWzEwNzUzXV0sIFsnYmlnb3RpbWVzJywgWzEwNzU0XV0sIFsnYmlnc3FjdXAnLCBbMTA3NThdXSwgWydiaWdzdGFyJywgWzk3MzNdXSwgWydiaWd0cmlhbmdsZWRvd24nLCBbOTY2MV1dLCBbJ2JpZ3RyaWFuZ2xldXAnLCBbOTY1MV1dLCBbJ2JpZ3VwbHVzJywgWzEwNzU2XV0sIFsnYmlndmVlJywgWzg4OTddXSwgWydiaWd3ZWRnZScsIFs4ODk2XV0sIFsnYmthcm93JywgWzEwNTA5XV0sIFsnYmxhY2tsb3plbmdlJywgWzEwNzMxXV0sIFsnYmxhY2tzcXVhcmUnLCBbOTY0Ml1dLCBbJ2JsYWNrdHJpYW5nbGUnLCBbOTY1Ml1dLCBbJ2JsYWNrdHJpYW5nbGVkb3duJywgWzk2NjJdXSwgWydibGFja3RyaWFuZ2xlbGVmdCcsIFs5NjY2XV0sIFsnYmxhY2t0cmlhbmdsZXJpZ2h0JywgWzk2NTZdXSwgWydibGFuaycsIFs5MjUxXV0sIFsnYmxrMTInLCBbOTYxOF1dLCBbJ2JsazE0JywgWzk2MTddXSwgWydibGszNCcsIFs5NjE5XV0sIFsnYmxvY2snLCBbOTYwOF1dLCBbJ2JuZScsIFs2MSwgODQyMV1dLCBbJ2JuZXF1aXYnLCBbODgwMSwgODQyMV1dLCBbJ2JOb3QnLCBbMTA5ODldXSwgWydibm90JywgWzg5NzZdXSwgWydCb3BmJywgWzEyMDEyMV1dLCBbJ2JvcGYnLCBbMTIwMTQ3XV0sIFsnYm90JywgWzg4NjldXSwgWydib3R0b20nLCBbODg2OV1dLCBbJ2Jvd3RpZScsIFs4OTA0XV0sIFsnYm94Ym94JywgWzEwNjk3XV0sIFsnYm94ZGwnLCBbOTQ4OF1dLCBbJ2JveGRMJywgWzk1NTddXSwgWydib3hEbCcsIFs5NTU4XV0sIFsnYm94REwnLCBbOTU1OV1dLCBbJ2JveGRyJywgWzk0ODRdXSwgWydib3hkUicsIFs5NTU0XV0sIFsnYm94RHInLCBbOTU1NV1dLCBbJ2JveERSJywgWzk1NTZdXSwgWydib3hoJywgWzk0NzJdXSwgWydib3hIJywgWzk1NTJdXSwgWydib3hoZCcsIFs5NTE2XV0sIFsnYm94SGQnLCBbOTU3Ml1dLCBbJ2JveGhEJywgWzk1NzNdXSwgWydib3hIRCcsIFs5NTc0XV0sIFsnYm94aHUnLCBbOTUyNF1dLCBbJ2JveEh1JywgWzk1NzVdXSwgWydib3hoVScsIFs5NTc2XV0sIFsnYm94SFUnLCBbOTU3N11dLCBbJ2JveG1pbnVzJywgWzg4NjNdXSwgWydib3hwbHVzJywgWzg4NjJdXSwgWydib3h0aW1lcycsIFs4ODY0XV0sIFsnYm94dWwnLCBbOTQ5Nl1dLCBbJ2JveHVMJywgWzk1NjNdXSwgWydib3hVbCcsIFs5NTY0XV0sIFsnYm94VUwnLCBbOTU2NV1dLCBbJ2JveHVyJywgWzk0OTJdXSwgWydib3h1UicsIFs5NTYwXV0sIFsnYm94VXInLCBbOTU2MV1dLCBbJ2JveFVSJywgWzk1NjJdXSwgWydib3h2JywgWzk0NzRdXSwgWydib3hWJywgWzk1NTNdXSwgWydib3h2aCcsIFs5NTMyXV0sIFsnYm94dkgnLCBbOTU3OF1dLCBbJ2JveFZoJywgWzk1NzldXSwgWydib3hWSCcsIFs5NTgwXV0sIFsnYm94dmwnLCBbOTUwOF1dLCBbJ2JveHZMJywgWzk1NjldXSwgWydib3hWbCcsIFs5NTcwXV0sIFsnYm94VkwnLCBbOTU3MV1dLCBbJ2JveHZyJywgWzk1MDBdXSwgWydib3h2UicsIFs5NTY2XV0sIFsnYm94VnInLCBbOTU2N11dLCBbJ2JveFZSJywgWzk1NjhdXSwgWydicHJpbWUnLCBbODI0NV1dLCBbJ2JyZXZlJywgWzcyOF1dLCBbJ0JyZXZlJywgWzcyOF1dLCBbJ2JydmJhcicsIFsxNjZdXSwgWydic2NyJywgWzExOTk5MV1dLCBbJ0JzY3InLCBbODQ5Ml1dLCBbJ2JzZW1pJywgWzgyNzFdXSwgWydic2ltJywgWzg3NjVdXSwgWydic2ltZScsIFs4OTA5XV0sIFsnYnNvbGInLCBbMTA2OTNdXSwgWydic29sJywgWzkyXV0sIFsnYnNvbGhzdWInLCBbMTAxODRdXSwgWydidWxsJywgWzgyMjZdXSwgWydidWxsZXQnLCBbODIyNl1dLCBbJ2J1bXAnLCBbODc4Ml1dLCBbJ2J1bXBFJywgWzEwOTI2XV0sIFsnYnVtcGUnLCBbODc4M11dLCBbJ0J1bXBlcScsIFs4NzgyXV0sIFsnYnVtcGVxJywgWzg3ODNdXSwgWydDYWN1dGUnLCBbMjYyXV0sIFsnY2FjdXRlJywgWzI2M11dLCBbJ2NhcGFuZCcsIFsxMDgyMF1dLCBbJ2NhcGJyY3VwJywgWzEwODI1XV0sIFsnY2FwY2FwJywgWzEwODI3XV0sIFsnY2FwJywgWzg3NDVdXSwgWydDYXAnLCBbODkxNF1dLCBbJ2NhcGN1cCcsIFsxMDgyM11dLCBbJ2NhcGRvdCcsIFsxMDgxNl1dLCBbJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJywgWzg1MTddXSwgWydjYXBzJywgWzg3NDUsIDY1MDI0XV0sIFsnY2FyZXQnLCBbODI1N11dLCBbJ2Nhcm9uJywgWzcxMV1dLCBbJ0NheWxleXMnLCBbODQ5M11dLCBbJ2NjYXBzJywgWzEwODI5XV0sIFsnQ2Nhcm9uJywgWzI2OF1dLCBbJ2NjYXJvbicsIFsyNjldXSwgWydDY2VkaWwnLCBbMTk5XV0sIFsnY2NlZGlsJywgWzIzMV1dLCBbJ0NjaXJjJywgWzI2NF1dLCBbJ2NjaXJjJywgWzI2NV1dLCBbJ0Njb25pbnQnLCBbODc1Ml1dLCBbJ2NjdXBzJywgWzEwODI4XV0sIFsnY2N1cHNzbScsIFsxMDgzMl1dLCBbJ0Nkb3QnLCBbMjY2XV0sIFsnY2RvdCcsIFsyNjddXSwgWydjZWRpbCcsIFsxODRdXSwgWydDZWRpbGxhJywgWzE4NF1dLCBbJ2NlbXB0eXYnLCBbMTA2NzRdXSwgWydjZW50JywgWzE2Ml1dLCBbJ2NlbnRlcmRvdCcsIFsxODNdXSwgWydDZW50ZXJEb3QnLCBbMTgzXV0sIFsnY2ZyJywgWzEyMDA5Nl1dLCBbJ0NmcicsIFs4NDkzXV0sIFsnQ0hjeScsIFsxMDYzXV0sIFsnY2hjeScsIFsxMDk1XV0sIFsnY2hlY2snLCBbMTAwMDNdXSwgWydjaGVja21hcmsnLCBbMTAwMDNdXSwgWydDaGknLCBbOTM1XV0sIFsnY2hpJywgWzk2N11dLCBbJ2NpcmMnLCBbNzEwXV0sIFsnY2lyY2VxJywgWzg3OTFdXSwgWydjaXJjbGVhcnJvd2xlZnQnLCBbODYzNF1dLCBbJ2NpcmNsZWFycm93cmlnaHQnLCBbODYzNV1dLCBbJ2NpcmNsZWRhc3QnLCBbODg1OV1dLCBbJ2NpcmNsZWRjaXJjJywgWzg4NThdXSwgWydjaXJjbGVkZGFzaCcsIFs4ODYxXV0sIFsnQ2lyY2xlRG90JywgWzg4NTddXSwgWydjaXJjbGVkUicsIFsxNzRdXSwgWydjaXJjbGVkUycsIFs5NDE2XV0sIFsnQ2lyY2xlTWludXMnLCBbODg1NF1dLCBbJ0NpcmNsZVBsdXMnLCBbODg1M11dLCBbJ0NpcmNsZVRpbWVzJywgWzg4NTVdXSwgWydjaXInLCBbOTY3NV1dLCBbJ2NpckUnLCBbMTA2OTFdXSwgWydjaXJlJywgWzg3OTFdXSwgWydjaXJmbmludCcsIFsxMDc2OF1dLCBbJ2Npcm1pZCcsIFsxMDk5MV1dLCBbJ2NpcnNjaXInLCBbMTA2OTBdXSwgWydDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnLCBbODc1NF1dLCBbJ2NsdWJzJywgWzk4MjddXSwgWydjbHVic3VpdCcsIFs5ODI3XV0sIFsnY29sb24nLCBbNThdXSwgWydDb2xvbicsIFs4NzU5XV0sIFsnQ29sb25lJywgWzEwODY4XV0sIFsnY29sb25lJywgWzg3ODhdXSwgWydjb2xvbmVxJywgWzg3ODhdXSwgWydjb21tYScsIFs0NF1dLCBbJ2NvbW1hdCcsIFs2NF1dLCBbJ2NvbXAnLCBbODcwNV1dLCBbJ2NvbXBmbicsIFs4NzI4XV0sIFsnY29tcGxlbWVudCcsIFs4NzA1XV0sIFsnY29tcGxleGVzJywgWzg0NTBdXSwgWydjb25nJywgWzg3NzNdXSwgWydjb25nZG90JywgWzEwODYxXV0sIFsnQ29uZ3J1ZW50JywgWzg4MDFdXSwgWydjb25pbnQnLCBbODc1MF1dLCBbJ0NvbmludCcsIFs4NzUxXV0sIFsnQ29udG91ckludGVncmFsJywgWzg3NTBdXSwgWydjb3BmJywgWzEyMDE0OF1dLCBbJ0NvcGYnLCBbODQ1MF1dLCBbJ2NvcHJvZCcsIFs4NzIwXV0sIFsnQ29wcm9kdWN0JywgWzg3MjBdXSwgWydjb3B5JywgWzE2OV1dLCBbJ0NPUFknLCBbMTY5XV0sIFsnY29weXNyJywgWzg0NzFdXSwgWydDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJywgWzg3NTVdXSwgWydjcmFycicsIFs4NjI5XV0sIFsnY3Jvc3MnLCBbMTAwMDddXSwgWydDcm9zcycsIFsxMDc5OV1dLCBbJ0NzY3InLCBbMTE5OTY2XV0sIFsnY3NjcicsIFsxMTk5OTJdXSwgWydjc3ViJywgWzEwOTU5XV0sIFsnY3N1YmUnLCBbMTA5NjFdXSwgWydjc3VwJywgWzEwOTYwXV0sIFsnY3N1cGUnLCBbMTA5NjJdXSwgWydjdGRvdCcsIFs4OTQzXV0sIFsnY3VkYXJybCcsIFsxMDU1Ml1dLCBbJ2N1ZGFycnInLCBbMTA1NDldXSwgWydjdWVwcicsIFs4OTI2XV0sIFsnY3Vlc2MnLCBbODkyN11dLCBbJ2N1bGFycicsIFs4NjMwXV0sIFsnY3VsYXJycCcsIFsxMDU1N11dLCBbJ2N1cGJyY2FwJywgWzEwODI0XV0sIFsnY3VwY2FwJywgWzEwODIyXV0sIFsnQ3VwQ2FwJywgWzg3ODFdXSwgWydjdXAnLCBbODc0Nl1dLCBbJ0N1cCcsIFs4OTE1XV0sIFsnY3VwY3VwJywgWzEwODI2XV0sIFsnY3VwZG90JywgWzg4NDVdXSwgWydjdXBvcicsIFsxMDgyMV1dLCBbJ2N1cHMnLCBbODc0NiwgNjUwMjRdXSwgWydjdXJhcnInLCBbODYzMV1dLCBbJ2N1cmFycm0nLCBbMTA1NTZdXSwgWydjdXJseWVxcHJlYycsIFs4OTI2XV0sIFsnY3VybHllcXN1Y2MnLCBbODkyN11dLCBbJ2N1cmx5dmVlJywgWzg5MTBdXSwgWydjdXJseXdlZGdlJywgWzg5MTFdXSwgWydjdXJyZW4nLCBbMTY0XV0sIFsnY3VydmVhcnJvd2xlZnQnLCBbODYzMF1dLCBbJ2N1cnZlYXJyb3dyaWdodCcsIFs4NjMxXV0sIFsnY3V2ZWUnLCBbODkxMF1dLCBbJ2N1d2VkJywgWzg5MTFdXSwgWydjd2NvbmludCcsIFs4NzU0XV0sIFsnY3dpbnQnLCBbODc1M11dLCBbJ2N5bGN0eScsIFs5MDA1XV0sIFsnZGFnZ2VyJywgWzgyMjRdXSwgWydEYWdnZXInLCBbODIyNV1dLCBbJ2RhbGV0aCcsIFs4NTA0XV0sIFsnZGFycicsIFs4NTk1XV0sIFsnRGFycicsIFs4NjA5XV0sIFsnZEFycicsIFs4NjU5XV0sIFsnZGFzaCcsIFs4MjA4XV0sIFsnRGFzaHYnLCBbMTA5ODBdXSwgWydkYXNodicsIFs4ODY3XV0sIFsnZGJrYXJvdycsIFsxMDUxMV1dLCBbJ2RibGFjJywgWzczM11dLCBbJ0RjYXJvbicsIFsyNzBdXSwgWydkY2Fyb24nLCBbMjcxXV0sIFsnRGN5JywgWzEwNDRdXSwgWydkY3knLCBbMTA3Nl1dLCBbJ2RkYWdnZXInLCBbODIyNV1dLCBbJ2RkYXJyJywgWzg2NTBdXSwgWydERCcsIFs4NTE3XV0sIFsnZGQnLCBbODUxOF1dLCBbJ0REb3RyYWhkJywgWzEwNTEzXV0sIFsnZGRvdHNlcScsIFsxMDg3MV1dLCBbJ2RlZycsIFsxNzZdXSwgWydEZWwnLCBbODcxMV1dLCBbJ0RlbHRhJywgWzkxNl1dLCBbJ2RlbHRhJywgWzk0OF1dLCBbJ2RlbXB0eXYnLCBbMTA2NzNdXSwgWydkZmlzaHQnLCBbMTA2MjNdXSwgWydEZnInLCBbMTIwMDcxXV0sIFsnZGZyJywgWzEyMDA5N11dLCBbJ2RIYXInLCBbMTA1OTddXSwgWydkaGFybCcsIFs4NjQzXV0sIFsnZGhhcnInLCBbODY0Ml1dLCBbJ0RpYWNyaXRpY2FsQWN1dGUnLCBbMTgwXV0sIFsnRGlhY3JpdGljYWxEb3QnLCBbNzI5XV0sIFsnRGlhY3JpdGljYWxEb3VibGVBY3V0ZScsIFs3MzNdXSwgWydEaWFjcml0aWNhbEdyYXZlJywgWzk2XV0sIFsnRGlhY3JpdGljYWxUaWxkZScsIFs3MzJdXSwgWydkaWFtJywgWzg5MDBdXSwgWydkaWFtb25kJywgWzg5MDBdXSwgWydEaWFtb25kJywgWzg5MDBdXSwgWydkaWFtb25kc3VpdCcsIFs5ODMwXV0sIFsnZGlhbXMnLCBbOTgzMF1dLCBbJ2RpZScsIFsxNjhdXSwgWydEaWZmZXJlbnRpYWxEJywgWzg1MThdXSwgWydkaWdhbW1hJywgWzk4OV1dLCBbJ2Rpc2luJywgWzg5NDZdXSwgWydkaXYnLCBbMjQ3XV0sIFsnZGl2aWRlJywgWzI0N11dLCBbJ2RpdmlkZW9udGltZXMnLCBbODkwM11dLCBbJ2Rpdm9ueCcsIFs4OTAzXV0sIFsnREpjeScsIFsxMDI2XV0sIFsnZGpjeScsIFsxMTA2XV0sIFsnZGxjb3JuJywgWzg5OTBdXSwgWydkbGNyb3AnLCBbODk3M11dLCBbJ2RvbGxhcicsIFszNl1dLCBbJ0RvcGYnLCBbMTIwMTIzXV0sIFsnZG9wZicsIFsxMjAxNDldXSwgWydEb3QnLCBbMTY4XV0sIFsnZG90JywgWzcyOV1dLCBbJ0RvdERvdCcsIFs4NDEyXV0sIFsnZG90ZXEnLCBbODc4NF1dLCBbJ2RvdGVxZG90JywgWzg3ODVdXSwgWydEb3RFcXVhbCcsIFs4Nzg0XV0sIFsnZG90bWludXMnLCBbODc2MF1dLCBbJ2RvdHBsdXMnLCBbODcyNF1dLCBbJ2RvdHNxdWFyZScsIFs4ODY1XV0sIFsnZG91YmxlYmFyd2VkZ2UnLCBbODk2Nl1dLCBbJ0RvdWJsZUNvbnRvdXJJbnRlZ3JhbCcsIFs4NzUxXV0sIFsnRG91YmxlRG90JywgWzE2OF1dLCBbJ0RvdWJsZURvd25BcnJvdycsIFs4NjU5XV0sIFsnRG91YmxlTGVmdEFycm93JywgWzg2NTZdXSwgWydEb3VibGVMZWZ0UmlnaHRBcnJvdycsIFs4NjYwXV0sIFsnRG91YmxlTGVmdFRlZScsIFsxMDk4MF1dLCBbJ0RvdWJsZUxvbmdMZWZ0QXJyb3cnLCBbMTAyMzJdXSwgWydEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnLCBbMTAyMzRdXSwgWydEb3VibGVMb25nUmlnaHRBcnJvdycsIFsxMDIzM11dLCBbJ0RvdWJsZVJpZ2h0QXJyb3cnLCBbODY1OF1dLCBbJ0RvdWJsZVJpZ2h0VGVlJywgWzg4NzJdXSwgWydEb3VibGVVcEFycm93JywgWzg2NTddXSwgWydEb3VibGVVcERvd25BcnJvdycsIFs4NjYxXV0sIFsnRG91YmxlVmVydGljYWxCYXInLCBbODc0MV1dLCBbJ0Rvd25BcnJvd0JhcicsIFsxMDUxNV1dLCBbJ2Rvd25hcnJvdycsIFs4NTk1XV0sIFsnRG93bkFycm93JywgWzg1OTVdXSwgWydEb3duYXJyb3cnLCBbODY1OV1dLCBbJ0Rvd25BcnJvd1VwQXJyb3cnLCBbODY5M11dLCBbJ0Rvd25CcmV2ZScsIFs3ODVdXSwgWydkb3duZG93bmFycm93cycsIFs4NjUwXV0sIFsnZG93bmhhcnBvb25sZWZ0JywgWzg2NDNdXSwgWydkb3duaGFycG9vbnJpZ2h0JywgWzg2NDJdXSwgWydEb3duTGVmdFJpZ2h0VmVjdG9yJywgWzEwNTc2XV0sIFsnRG93bkxlZnRUZWVWZWN0b3InLCBbMTA1OTBdXSwgWydEb3duTGVmdFZlY3RvckJhcicsIFsxMDU4Ml1dLCBbJ0Rvd25MZWZ0VmVjdG9yJywgWzg2MzddXSwgWydEb3duUmlnaHRUZWVWZWN0b3InLCBbMTA1OTFdXSwgWydEb3duUmlnaHRWZWN0b3JCYXInLCBbMTA1ODNdXSwgWydEb3duUmlnaHRWZWN0b3InLCBbODY0MV1dLCBbJ0Rvd25UZWVBcnJvdycsIFs4NjE1XV0sIFsnRG93blRlZScsIFs4ODY4XV0sIFsnZHJia2Fyb3cnLCBbMTA1MTJdXSwgWydkcmNvcm4nLCBbODk5MV1dLCBbJ2RyY3JvcCcsIFs4OTcyXV0sIFsnRHNjcicsIFsxMTk5NjddXSwgWydkc2NyJywgWzExOTk5M11dLCBbJ0RTY3knLCBbMTAyOV1dLCBbJ2RzY3knLCBbMTEwOV1dLCBbJ2Rzb2wnLCBbMTA3NDJdXSwgWydEc3Ryb2snLCBbMjcyXV0sIFsnZHN0cm9rJywgWzI3M11dLCBbJ2R0ZG90JywgWzg5NDVdXSwgWydkdHJpJywgWzk2NjNdXSwgWydkdHJpZicsIFs5NjYyXV0sIFsnZHVhcnInLCBbODY5M11dLCBbJ2R1aGFyJywgWzEwNjA3XV0sIFsnZHdhbmdsZScsIFsxMDY2Ml1dLCBbJ0RaY3knLCBbMTAzOV1dLCBbJ2R6Y3knLCBbMTExOV1dLCBbJ2R6aWdyYXJyJywgWzEwMjM5XV0sIFsnRWFjdXRlJywgWzIwMV1dLCBbJ2VhY3V0ZScsIFsyMzNdXSwgWydlYXN0ZXInLCBbMTA4NjJdXSwgWydFY2Fyb24nLCBbMjgyXV0sIFsnZWNhcm9uJywgWzI4M11dLCBbJ0VjaXJjJywgWzIwMl1dLCBbJ2VjaXJjJywgWzIzNF1dLCBbJ2VjaXInLCBbODc5MF1dLCBbJ2Vjb2xvbicsIFs4Nzg5XV0sIFsnRWN5JywgWzEwNjldXSwgWydlY3knLCBbMTEwMV1dLCBbJ2VERG90JywgWzEwODcxXV0sIFsnRWRvdCcsIFsyNzhdXSwgWydlZG90JywgWzI3OV1dLCBbJ2VEb3QnLCBbODc4NV1dLCBbJ2VlJywgWzg1MTldXSwgWydlZkRvdCcsIFs4Nzg2XV0sIFsnRWZyJywgWzEyMDA3Ml1dLCBbJ2VmcicsIFsxMjAwOThdXSwgWydlZycsIFsxMDkwNl1dLCBbJ0VncmF2ZScsIFsyMDBdXSwgWydlZ3JhdmUnLCBbMjMyXV0sIFsnZWdzJywgWzEwOTAyXV0sIFsnZWdzZG90JywgWzEwOTA0XV0sIFsnZWwnLCBbMTA5MDVdXSwgWydFbGVtZW50JywgWzg3MTJdXSwgWydlbGludGVycycsIFs5MTkxXV0sIFsnZWxsJywgWzg0NjddXSwgWydlbHMnLCBbMTA5MDFdXSwgWydlbHNkb3QnLCBbMTA5MDNdXSwgWydFbWFjcicsIFsyNzRdXSwgWydlbWFjcicsIFsyNzVdXSwgWydlbXB0eScsIFs4NzA5XV0sIFsnZW1wdHlzZXQnLCBbODcwOV1dLCBbJ0VtcHR5U21hbGxTcXVhcmUnLCBbOTcyM11dLCBbJ2VtcHR5dicsIFs4NzA5XV0sIFsnRW1wdHlWZXJ5U21hbGxTcXVhcmUnLCBbOTY0M11dLCBbJ2Vtc3AxMycsIFs4MTk2XV0sIFsnZW1zcDE0JywgWzgxOTddXSwgWydlbXNwJywgWzgxOTVdXSwgWydFTkcnLCBbMzMwXV0sIFsnZW5nJywgWzMzMV1dLCBbJ2Vuc3AnLCBbODE5NF1dLCBbJ0VvZ29uJywgWzI4MF1dLCBbJ2VvZ29uJywgWzI4MV1dLCBbJ0VvcGYnLCBbMTIwMTI0XV0sIFsnZW9wZicsIFsxMjAxNTBdXSwgWydlcGFyJywgWzg5MTddXSwgWydlcGFyc2wnLCBbMTA3MjNdXSwgWydlcGx1cycsIFsxMDg2NV1dLCBbJ2Vwc2knLCBbOTQ5XV0sIFsnRXBzaWxvbicsIFs5MTddXSwgWydlcHNpbG9uJywgWzk0OV1dLCBbJ2Vwc2l2JywgWzEwMTNdXSwgWydlcWNpcmMnLCBbODc5MF1dLCBbJ2VxY29sb24nLCBbODc4OV1dLCBbJ2Vxc2ltJywgWzg3NzBdXSwgWydlcXNsYW50Z3RyJywgWzEwOTAyXV0sIFsnZXFzbGFudGxlc3MnLCBbMTA5MDFdXSwgWydFcXVhbCcsIFsxMDg2OV1dLCBbJ2VxdWFscycsIFs2MV1dLCBbJ0VxdWFsVGlsZGUnLCBbODc3MF1dLCBbJ2VxdWVzdCcsIFs4Nzk5XV0sIFsnRXF1aWxpYnJpdW0nLCBbODY1Ml1dLCBbJ2VxdWl2JywgWzg4MDFdXSwgWydlcXVpdkREJywgWzEwODcyXV0sIFsnZXF2cGFyc2wnLCBbMTA3MjVdXSwgWydlcmFycicsIFsxMDYwOV1dLCBbJ2VyRG90JywgWzg3ODddXSwgWydlc2NyJywgWzg0OTVdXSwgWydFc2NyJywgWzg0OTZdXSwgWydlc2RvdCcsIFs4Nzg0XV0sIFsnRXNpbScsIFsxMDg2N11dLCBbJ2VzaW0nLCBbODc3MF1dLCBbJ0V0YScsIFs5MTldXSwgWydldGEnLCBbOTUxXV0sIFsnRVRIJywgWzIwOF1dLCBbJ2V0aCcsIFsyNDBdXSwgWydFdW1sJywgWzIwM11dLCBbJ2V1bWwnLCBbMjM1XV0sIFsnZXVybycsIFs4MzY0XV0sIFsnZXhjbCcsIFszM11dLCBbJ2V4aXN0JywgWzg3MDddXSwgWydFeGlzdHMnLCBbODcwN11dLCBbJ2V4cGVjdGF0aW9uJywgWzg0OTZdXSwgWydleHBvbmVudGlhbGUnLCBbODUxOV1dLCBbJ0V4cG9uZW50aWFsRScsIFs4NTE5XV0sIFsnZmFsbGluZ2RvdHNlcScsIFs4Nzg2XV0sIFsnRmN5JywgWzEwNjBdXSwgWydmY3knLCBbMTA5Ml1dLCBbJ2ZlbWFsZScsIFs5NzkyXV0sIFsnZmZpbGlnJywgWzY0MjU5XV0sIFsnZmZsaWcnLCBbNjQyNTZdXSwgWydmZmxsaWcnLCBbNjQyNjBdXSwgWydGZnInLCBbMTIwMDczXV0sIFsnZmZyJywgWzEyMDA5OV1dLCBbJ2ZpbGlnJywgWzY0MjU3XV0sIFsnRmlsbGVkU21hbGxTcXVhcmUnLCBbOTcyNF1dLCBbJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZScsIFs5NjQyXV0sIFsnZmpsaWcnLCBbMTAyLCAxMDZdXSwgWydmbGF0JywgWzk4MzddXSwgWydmbGxpZycsIFs2NDI1OF1dLCBbJ2ZsdG5zJywgWzk2NDldXSwgWydmbm9mJywgWzQwMl1dLCBbJ0ZvcGYnLCBbMTIwMTI1XV0sIFsnZm9wZicsIFsxMjAxNTFdXSwgWydmb3JhbGwnLCBbODcwNF1dLCBbJ0ZvckFsbCcsIFs4NzA0XV0sIFsnZm9yaycsIFs4OTE2XV0sIFsnZm9ya3YnLCBbMTA5NjldXSwgWydGb3VyaWVydHJmJywgWzg0OTddXSwgWydmcGFydGludCcsIFsxMDc2NV1dLCBbJ2ZyYWMxMicsIFsxODldXSwgWydmcmFjMTMnLCBbODUzMV1dLCBbJ2ZyYWMxNCcsIFsxODhdXSwgWydmcmFjMTUnLCBbODUzM11dLCBbJ2ZyYWMxNicsIFs4NTM3XV0sIFsnZnJhYzE4JywgWzg1MzldXSwgWydmcmFjMjMnLCBbODUzMl1dLCBbJ2ZyYWMyNScsIFs4NTM0XV0sIFsnZnJhYzM0JywgWzE5MF1dLCBbJ2ZyYWMzNScsIFs4NTM1XV0sIFsnZnJhYzM4JywgWzg1NDBdXSwgWydmcmFjNDUnLCBbODUzNl1dLCBbJ2ZyYWM1NicsIFs4NTM4XV0sIFsnZnJhYzU4JywgWzg1NDFdXSwgWydmcmFjNzgnLCBbODU0Ml1dLCBbJ2ZyYXNsJywgWzgyNjBdXSwgWydmcm93bicsIFs4OTk0XV0sIFsnZnNjcicsIFsxMTk5OTVdXSwgWydGc2NyJywgWzg0OTddXSwgWydnYWN1dGUnLCBbNTAxXV0sIFsnR2FtbWEnLCBbOTE1XV0sIFsnZ2FtbWEnLCBbOTQ3XV0sIFsnR2FtbWFkJywgWzk4OF1dLCBbJ2dhbW1hZCcsIFs5ODldXSwgWydnYXAnLCBbMTA4ODZdXSwgWydHYnJldmUnLCBbMjg2XV0sIFsnZ2JyZXZlJywgWzI4N11dLCBbJ0djZWRpbCcsIFsyOTBdXSwgWydHY2lyYycsIFsyODRdXSwgWydnY2lyYycsIFsyODVdXSwgWydHY3knLCBbMTA0M11dLCBbJ2djeScsIFsxMDc1XV0sIFsnR2RvdCcsIFsyODhdXSwgWydnZG90JywgWzI4OV1dLCBbJ2dlJywgWzg4MDVdXSwgWydnRScsIFs4ODA3XV0sIFsnZ0VsJywgWzEwODkyXV0sIFsnZ2VsJywgWzg5MjNdXSwgWydnZXEnLCBbODgwNV1dLCBbJ2dlcXEnLCBbODgwN11dLCBbJ2dlcXNsYW50JywgWzEwODc4XV0sIFsnZ2VzY2MnLCBbMTA5MjFdXSwgWydnZXMnLCBbMTA4NzhdXSwgWydnZXNkb3QnLCBbMTA4ODBdXSwgWydnZXNkb3RvJywgWzEwODgyXV0sIFsnZ2VzZG90b2wnLCBbMTA4ODRdXSwgWydnZXNsJywgWzg5MjMsIDY1MDI0XV0sIFsnZ2VzbGVzJywgWzEwOTAwXV0sIFsnR2ZyJywgWzEyMDA3NF1dLCBbJ2dmcicsIFsxMjAxMDBdXSwgWydnZycsIFs4ODExXV0sIFsnR2cnLCBbODkyMV1dLCBbJ2dnZycsIFs4OTIxXV0sIFsnZ2ltZWwnLCBbODUwM11dLCBbJ0dKY3knLCBbMTAyN11dLCBbJ2dqY3knLCBbMTEwN11dLCBbJ2dsYScsIFsxMDkxN11dLCBbJ2dsJywgWzg4MjNdXSwgWydnbEUnLCBbMTA4OThdXSwgWydnbGonLCBbMTA5MTZdXSwgWydnbmFwJywgWzEwODkwXV0sIFsnZ25hcHByb3gnLCBbMTA4OTBdXSwgWydnbmUnLCBbMTA4ODhdXSwgWydnbkUnLCBbODgwOV1dLCBbJ2duZXEnLCBbMTA4ODhdXSwgWydnbmVxcScsIFs4ODA5XV0sIFsnZ25zaW0nLCBbODkzNV1dLCBbJ0dvcGYnLCBbMTIwMTI2XV0sIFsnZ29wZicsIFsxMjAxNTJdXSwgWydncmF2ZScsIFs5Nl1dLCBbJ0dyZWF0ZXJFcXVhbCcsIFs4ODA1XV0sIFsnR3JlYXRlckVxdWFsTGVzcycsIFs4OTIzXV0sIFsnR3JlYXRlckZ1bGxFcXVhbCcsIFs4ODA3XV0sIFsnR3JlYXRlckdyZWF0ZXInLCBbMTA5MTRdXSwgWydHcmVhdGVyTGVzcycsIFs4ODIzXV0sIFsnR3JlYXRlclNsYW50RXF1YWwnLCBbMTA4NzhdXSwgWydHcmVhdGVyVGlsZGUnLCBbODgxOV1dLCBbJ0dzY3InLCBbMTE5OTcwXV0sIFsnZ3NjcicsIFs4NDU4XV0sIFsnZ3NpbScsIFs4ODE5XV0sIFsnZ3NpbWUnLCBbMTA4OTRdXSwgWydnc2ltbCcsIFsxMDg5Nl1dLCBbJ2d0Y2MnLCBbMTA5MTldXSwgWydndGNpcicsIFsxMDg3NF1dLCBbJ2d0JywgWzYyXV0sIFsnR1QnLCBbNjJdXSwgWydHdCcsIFs4ODExXV0sIFsnZ3Rkb3QnLCBbODkxOV1dLCBbJ2d0bFBhcicsIFsxMDY0NV1dLCBbJ2d0cXVlc3QnLCBbMTA4NzZdXSwgWydndHJhcHByb3gnLCBbMTA4ODZdXSwgWydndHJhcnInLCBbMTA2MTZdXSwgWydndHJkb3QnLCBbODkxOV1dLCBbJ2d0cmVxbGVzcycsIFs4OTIzXV0sIFsnZ3RyZXFxbGVzcycsIFsxMDg5Ml1dLCBbJ2d0cmxlc3MnLCBbODgyM11dLCBbJ2d0cnNpbScsIFs4ODE5XV0sIFsnZ3ZlcnRuZXFxJywgWzg4MDksIDY1MDI0XV0sIFsnZ3ZuRScsIFs4ODA5LCA2NTAyNF1dLCBbJ0hhY2VrJywgWzcxMV1dLCBbJ2hhaXJzcCcsIFs4MjAyXV0sIFsnaGFsZicsIFsxODldXSwgWydoYW1pbHQnLCBbODQ1OV1dLCBbJ0hBUkRjeScsIFsxMDY2XV0sIFsnaGFyZGN5JywgWzEwOThdXSwgWydoYXJyY2lyJywgWzEwNTY4XV0sIFsnaGFycicsIFs4NTk2XV0sIFsnaEFycicsIFs4NjYwXV0sIFsnaGFycncnLCBbODYyMV1dLCBbJ0hhdCcsIFs5NF1dLCBbJ2hiYXInLCBbODQ2M11dLCBbJ0hjaXJjJywgWzI5Ml1dLCBbJ2hjaXJjJywgWzI5M11dLCBbJ2hlYXJ0cycsIFs5ODI5XV0sIFsnaGVhcnRzdWl0JywgWzk4MjldXSwgWydoZWxsaXAnLCBbODIzMF1dLCBbJ2hlcmNvbicsIFs4ODg5XV0sIFsnaGZyJywgWzEyMDEwMV1dLCBbJ0hmcicsIFs4NDYwXV0sIFsnSGlsYmVydFNwYWNlJywgWzg0NTldXSwgWydoa3NlYXJvdycsIFsxMDUzM11dLCBbJ2hrc3dhcm93JywgWzEwNTM0XV0sIFsnaG9hcnInLCBbODcwM11dLCBbJ2hvbXRodCcsIFs4NzYzXV0sIFsnaG9va2xlZnRhcnJvdycsIFs4NjE3XV0sIFsnaG9va3JpZ2h0YXJyb3cnLCBbODYxOF1dLCBbJ2hvcGYnLCBbMTIwMTUzXV0sIFsnSG9wZicsIFs4NDYxXV0sIFsnaG9yYmFyJywgWzgyMTNdXSwgWydIb3Jpem9udGFsTGluZScsIFs5NDcyXV0sIFsnaHNjcicsIFsxMTk5OTddXSwgWydIc2NyJywgWzg0NTldXSwgWydoc2xhc2gnLCBbODQ2M11dLCBbJ0hzdHJvaycsIFsyOTRdXSwgWydoc3Ryb2snLCBbMjk1XV0sIFsnSHVtcERvd25IdW1wJywgWzg3ODJdXSwgWydIdW1wRXF1YWwnLCBbODc4M11dLCBbJ2h5YnVsbCcsIFs4MjU5XV0sIFsnaHlwaGVuJywgWzgyMDhdXSwgWydJYWN1dGUnLCBbMjA1XV0sIFsnaWFjdXRlJywgWzIzN11dLCBbJ2ljJywgWzgyOTFdXSwgWydJY2lyYycsIFsyMDZdXSwgWydpY2lyYycsIFsyMzhdXSwgWydJY3knLCBbMTA0OF1dLCBbJ2ljeScsIFsxMDgwXV0sIFsnSWRvdCcsIFszMDRdXSwgWydJRWN5JywgWzEwNDVdXSwgWydpZWN5JywgWzEwNzddXSwgWydpZXhjbCcsIFsxNjFdXSwgWydpZmYnLCBbODY2MF1dLCBbJ2lmcicsIFsxMjAxMDJdXSwgWydJZnInLCBbODQ2NV1dLCBbJ0lncmF2ZScsIFsyMDRdXSwgWydpZ3JhdmUnLCBbMjM2XV0sIFsnaWknLCBbODUyMF1dLCBbJ2lpaWludCcsIFsxMDc2NF1dLCBbJ2lpaW50JywgWzg3NDldXSwgWydpaW5maW4nLCBbMTA3MTZdXSwgWydpaW90YScsIFs4NDg5XV0sIFsnSUpsaWcnLCBbMzA2XV0sIFsnaWpsaWcnLCBbMzA3XV0sIFsnSW1hY3InLCBbMjk4XV0sIFsnaW1hY3InLCBbMjk5XV0sIFsnaW1hZ2UnLCBbODQ2NV1dLCBbJ0ltYWdpbmFyeUknLCBbODUyMF1dLCBbJ2ltYWdsaW5lJywgWzg0NjRdXSwgWydpbWFncGFydCcsIFs4NDY1XV0sIFsnaW1hdGgnLCBbMzA1XV0sIFsnSW0nLCBbODQ2NV1dLCBbJ2ltb2YnLCBbODg4N11dLCBbJ2ltcGVkJywgWzQzN11dLCBbJ0ltcGxpZXMnLCBbODY1OF1dLCBbJ2luY2FyZScsIFs4NDUzXV0sIFsnaW4nLCBbODcxMl1dLCBbJ2luZmluJywgWzg3MzRdXSwgWydpbmZpbnRpZScsIFsxMDcxN11dLCBbJ2lub2RvdCcsIFszMDVdXSwgWydpbnRjYWwnLCBbODg5MF1dLCBbJ2ludCcsIFs4NzQ3XV0sIFsnSW50JywgWzg3NDhdXSwgWydpbnRlZ2VycycsIFs4NDg0XV0sIFsnSW50ZWdyYWwnLCBbODc0N11dLCBbJ2ludGVyY2FsJywgWzg4OTBdXSwgWydJbnRlcnNlY3Rpb24nLCBbODg5OF1dLCBbJ2ludGxhcmhrJywgWzEwNzc1XV0sIFsnaW50cHJvZCcsIFsxMDgxMl1dLCBbJ0ludmlzaWJsZUNvbW1hJywgWzgyOTFdXSwgWydJbnZpc2libGVUaW1lcycsIFs4MjkwXV0sIFsnSU9jeScsIFsxMDI1XV0sIFsnaW9jeScsIFsxMTA1XV0sIFsnSW9nb24nLCBbMzAyXV0sIFsnaW9nb24nLCBbMzAzXV0sIFsnSW9wZicsIFsxMjAxMjhdXSwgWydpb3BmJywgWzEyMDE1NF1dLCBbJ0lvdGEnLCBbOTIxXV0sIFsnaW90YScsIFs5NTNdXSwgWydpcHJvZCcsIFsxMDgxMl1dLCBbJ2lxdWVzdCcsIFsxOTFdXSwgWydpc2NyJywgWzExOTk5OF1dLCBbJ0lzY3InLCBbODQ2NF1dLCBbJ2lzaW4nLCBbODcxMl1dLCBbJ2lzaW5kb3QnLCBbODk0OV1dLCBbJ2lzaW5FJywgWzg5NTNdXSwgWydpc2lucycsIFs4OTQ4XV0sIFsnaXNpbnN2JywgWzg5NDddXSwgWydpc2ludicsIFs4NzEyXV0sIFsnaXQnLCBbODI5MF1dLCBbJ0l0aWxkZScsIFsyOTZdXSwgWydpdGlsZGUnLCBbMjk3XV0sIFsnSXVrY3knLCBbMTAzMF1dLCBbJ2l1a2N5JywgWzExMTBdXSwgWydJdW1sJywgWzIwN11dLCBbJ2l1bWwnLCBbMjM5XV0sIFsnSmNpcmMnLCBbMzA4XV0sIFsnamNpcmMnLCBbMzA5XV0sIFsnSmN5JywgWzEwNDldXSwgWydqY3knLCBbMTA4MV1dLCBbJ0pmcicsIFsxMjAwNzddXSwgWydqZnInLCBbMTIwMTAzXV0sIFsnam1hdGgnLCBbNTY3XV0sIFsnSm9wZicsIFsxMjAxMjldXSwgWydqb3BmJywgWzEyMDE1NV1dLCBbJ0pzY3InLCBbMTE5OTczXV0sIFsnanNjcicsIFsxMTk5OTldXSwgWydKc2VyY3knLCBbMTAzMl1dLCBbJ2pzZXJjeScsIFsxMTEyXV0sIFsnSnVrY3knLCBbMTAyOF1dLCBbJ2p1a2N5JywgWzExMDhdXSwgWydLYXBwYScsIFs5MjJdXSwgWydrYXBwYScsIFs5NTRdXSwgWydrYXBwYXYnLCBbMTAwOF1dLCBbJ0tjZWRpbCcsIFszMTBdXSwgWydrY2VkaWwnLCBbMzExXV0sIFsnS2N5JywgWzEwNTBdXSwgWydrY3knLCBbMTA4Ml1dLCBbJ0tmcicsIFsxMjAwNzhdXSwgWydrZnInLCBbMTIwMTA0XV0sIFsna2dyZWVuJywgWzMxMl1dLCBbJ0tIY3knLCBbMTA2MV1dLCBbJ2toY3knLCBbMTA5M11dLCBbJ0tKY3knLCBbMTAzNl1dLCBbJ2tqY3knLCBbMTExNl1dLCBbJ0tvcGYnLCBbMTIwMTMwXV0sIFsna29wZicsIFsxMjAxNTZdXSwgWydLc2NyJywgWzExOTk3NF1dLCBbJ2tzY3InLCBbMTIwMDAwXV0sIFsnbEFhcnInLCBbODY2Nl1dLCBbJ0xhY3V0ZScsIFszMTNdXSwgWydsYWN1dGUnLCBbMzE0XV0sIFsnbGFlbXB0eXYnLCBbMTA2NzZdXSwgWydsYWdyYW4nLCBbODQ2Nl1dLCBbJ0xhbWJkYScsIFs5MjNdXSwgWydsYW1iZGEnLCBbOTU1XV0sIFsnbGFuZycsIFsxMDIxNl1dLCBbJ0xhbmcnLCBbMTAyMThdXSwgWydsYW5nZCcsIFsxMDY0MV1dLCBbJ2xhbmdsZScsIFsxMDIxNl1dLCBbJ2xhcCcsIFsxMDg4NV1dLCBbJ0xhcGxhY2V0cmYnLCBbODQ2Nl1dLCBbJ2xhcXVvJywgWzE3MV1dLCBbJ2xhcnJiJywgWzg2NzZdXSwgWydsYXJyYmZzJywgWzEwNTI3XV0sIFsnbGFycicsIFs4NTkyXV0sIFsnTGFycicsIFs4NjA2XV0sIFsnbEFycicsIFs4NjU2XV0sIFsnbGFycmZzJywgWzEwNTI1XV0sIFsnbGFycmhrJywgWzg2MTddXSwgWydsYXJybHAnLCBbODYxOV1dLCBbJ2xhcnJwbCcsIFsxMDU1M11dLCBbJ2xhcnJzaW0nLCBbMTA2MTFdXSwgWydsYXJydGwnLCBbODYxMF1dLCBbJ2xhdGFpbCcsIFsxMDUyMV1dLCBbJ2xBdGFpbCcsIFsxMDUyM11dLCBbJ2xhdCcsIFsxMDkyM11dLCBbJ2xhdGUnLCBbMTA5MjVdXSwgWydsYXRlcycsIFsxMDkyNSwgNjUwMjRdXSwgWydsYmFycicsIFsxMDUwOF1dLCBbJ2xCYXJyJywgWzEwNTEwXV0sIFsnbGJicmsnLCBbMTAwOThdXSwgWydsYnJhY2UnLCBbMTIzXV0sIFsnbGJyYWNrJywgWzkxXV0sIFsnbGJya2UnLCBbMTA2MzVdXSwgWydsYnJrc2xkJywgWzEwNjM5XV0sIFsnbGJya3NsdScsIFsxMDYzN11dLCBbJ0xjYXJvbicsIFszMTddXSwgWydsY2Fyb24nLCBbMzE4XV0sIFsnTGNlZGlsJywgWzMxNV1dLCBbJ2xjZWRpbCcsIFszMTZdXSwgWydsY2VpbCcsIFs4OTY4XV0sIFsnbGN1YicsIFsxMjNdXSwgWydMY3knLCBbMTA1MV1dLCBbJ2xjeScsIFsxMDgzXV0sIFsnbGRjYScsIFsxMDU1MF1dLCBbJ2xkcXVvJywgWzgyMjBdXSwgWydsZHF1b3InLCBbODIyMl1dLCBbJ2xkcmRoYXInLCBbMTA1OTldXSwgWydsZHJ1c2hhcicsIFsxMDU3MV1dLCBbJ2xkc2gnLCBbODYyNl1dLCBbJ2xlJywgWzg4MDRdXSwgWydsRScsIFs4ODA2XV0sIFsnTGVmdEFuZ2xlQnJhY2tldCcsIFsxMDIxNl1dLCBbJ0xlZnRBcnJvd0JhcicsIFs4Njc2XV0sIFsnbGVmdGFycm93JywgWzg1OTJdXSwgWydMZWZ0QXJyb3cnLCBbODU5Ml1dLCBbJ0xlZnRhcnJvdycsIFs4NjU2XV0sIFsnTGVmdEFycm93UmlnaHRBcnJvdycsIFs4NjQ2XV0sIFsnbGVmdGFycm93dGFpbCcsIFs4NjEwXV0sIFsnTGVmdENlaWxpbmcnLCBbODk2OF1dLCBbJ0xlZnREb3VibGVCcmFja2V0JywgWzEwMjE0XV0sIFsnTGVmdERvd25UZWVWZWN0b3InLCBbMTA1OTNdXSwgWydMZWZ0RG93blZlY3RvckJhcicsIFsxMDU4NV1dLCBbJ0xlZnREb3duVmVjdG9yJywgWzg2NDNdXSwgWydMZWZ0Rmxvb3InLCBbODk3MF1dLCBbJ2xlZnRoYXJwb29uZG93bicsIFs4NjM3XV0sIFsnbGVmdGhhcnBvb251cCcsIFs4NjM2XV0sIFsnbGVmdGxlZnRhcnJvd3MnLCBbODY0N11dLCBbJ2xlZnRyaWdodGFycm93JywgWzg1OTZdXSwgWydMZWZ0UmlnaHRBcnJvdycsIFs4NTk2XV0sIFsnTGVmdHJpZ2h0YXJyb3cnLCBbODY2MF1dLCBbJ2xlZnRyaWdodGFycm93cycsIFs4NjQ2XV0sIFsnbGVmdHJpZ2h0aGFycG9vbnMnLCBbODY1MV1dLCBbJ2xlZnRyaWdodHNxdWlnYXJyb3cnLCBbODYyMV1dLCBbJ0xlZnRSaWdodFZlY3RvcicsIFsxMDU3NF1dLCBbJ0xlZnRUZWVBcnJvdycsIFs4NjEyXV0sIFsnTGVmdFRlZScsIFs4ODY3XV0sIFsnTGVmdFRlZVZlY3RvcicsIFsxMDU4Nl1dLCBbJ2xlZnR0aHJlZXRpbWVzJywgWzg5MDddXSwgWydMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDNdXSwgWydMZWZ0VHJpYW5nbGUnLCBbODg4Ml1dLCBbJ0xlZnRUcmlhbmdsZUVxdWFsJywgWzg4ODRdXSwgWydMZWZ0VXBEb3duVmVjdG9yJywgWzEwNTc3XV0sIFsnTGVmdFVwVGVlVmVjdG9yJywgWzEwNTkyXV0sIFsnTGVmdFVwVmVjdG9yQmFyJywgWzEwNTg0XV0sIFsnTGVmdFVwVmVjdG9yJywgWzg2MzldXSwgWydMZWZ0VmVjdG9yQmFyJywgWzEwNTc4XV0sIFsnTGVmdFZlY3RvcicsIFs4NjM2XV0sIFsnbEVnJywgWzEwODkxXV0sIFsnbGVnJywgWzg5MjJdXSwgWydsZXEnLCBbODgwNF1dLCBbJ2xlcXEnLCBbODgwNl1dLCBbJ2xlcXNsYW50JywgWzEwODc3XV0sIFsnbGVzY2MnLCBbMTA5MjBdXSwgWydsZXMnLCBbMTA4NzddXSwgWydsZXNkb3QnLCBbMTA4NzldXSwgWydsZXNkb3RvJywgWzEwODgxXV0sIFsnbGVzZG90b3InLCBbMTA4ODNdXSwgWydsZXNnJywgWzg5MjIsIDY1MDI0XV0sIFsnbGVzZ2VzJywgWzEwODk5XV0sIFsnbGVzc2FwcHJveCcsIFsxMDg4NV1dLCBbJ2xlc3Nkb3QnLCBbODkxOF1dLCBbJ2xlc3NlcWd0cicsIFs4OTIyXV0sIFsnbGVzc2VxcWd0cicsIFsxMDg5MV1dLCBbJ0xlc3NFcXVhbEdyZWF0ZXInLCBbODkyMl1dLCBbJ0xlc3NGdWxsRXF1YWwnLCBbODgwNl1dLCBbJ0xlc3NHcmVhdGVyJywgWzg4MjJdXSwgWydsZXNzZ3RyJywgWzg4MjJdXSwgWydMZXNzTGVzcycsIFsxMDkxM11dLCBbJ2xlc3NzaW0nLCBbODgxOF1dLCBbJ0xlc3NTbGFudEVxdWFsJywgWzEwODc3XV0sIFsnTGVzc1RpbGRlJywgWzg4MThdXSwgWydsZmlzaHQnLCBbMTA2MjBdXSwgWydsZmxvb3InLCBbODk3MF1dLCBbJ0xmcicsIFsxMjAwNzldXSwgWydsZnInLCBbMTIwMTA1XV0sIFsnbGcnLCBbODgyMl1dLCBbJ2xnRScsIFsxMDg5N11dLCBbJ2xIYXInLCBbMTA1OTRdXSwgWydsaGFyZCcsIFs4NjM3XV0sIFsnbGhhcnUnLCBbODYzNl1dLCBbJ2xoYXJ1bCcsIFsxMDYwMl1dLCBbJ2xoYmxrJywgWzk2MDRdXSwgWydMSmN5JywgWzEwMzNdXSwgWydsamN5JywgWzExMTNdXSwgWydsbGFycicsIFs4NjQ3XV0sIFsnbGwnLCBbODgxMF1dLCBbJ0xsJywgWzg5MjBdXSwgWydsbGNvcm5lcicsIFs4OTkwXV0sIFsnTGxlZnRhcnJvdycsIFs4NjY2XV0sIFsnbGxoYXJkJywgWzEwNjAzXV0sIFsnbGx0cmknLCBbOTcyMl1dLCBbJ0xtaWRvdCcsIFszMTldXSwgWydsbWlkb3QnLCBbMzIwXV0sIFsnbG1vdXN0YWNoZScsIFs5MTM2XV0sIFsnbG1vdXN0JywgWzkxMzZdXSwgWydsbmFwJywgWzEwODg5XV0sIFsnbG5hcHByb3gnLCBbMTA4ODldXSwgWydsbmUnLCBbMTA4ODddXSwgWydsbkUnLCBbODgwOF1dLCBbJ2xuZXEnLCBbMTA4ODddXSwgWydsbmVxcScsIFs4ODA4XV0sIFsnbG5zaW0nLCBbODkzNF1dLCBbJ2xvYW5nJywgWzEwMjIwXV0sIFsnbG9hcnInLCBbODcwMV1dLCBbJ2xvYnJrJywgWzEwMjE0XV0sIFsnbG9uZ2xlZnRhcnJvdycsIFsxMDIyOV1dLCBbJ0xvbmdMZWZ0QXJyb3cnLCBbMTAyMjldXSwgWydMb25nbGVmdGFycm93JywgWzEwMjMyXV0sIFsnbG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjMxXV0sIFsnTG9uZ0xlZnRSaWdodEFycm93JywgWzEwMjMxXV0sIFsnTG9uZ2xlZnRyaWdodGFycm93JywgWzEwMjM0XV0sIFsnbG9uZ21hcHN0bycsIFsxMDIzNl1dLCBbJ2xvbmdyaWdodGFycm93JywgWzEwMjMwXV0sIFsnTG9uZ1JpZ2h0QXJyb3cnLCBbMTAyMzBdXSwgWydMb25ncmlnaHRhcnJvdycsIFsxMDIzM11dLCBbJ2xvb3BhcnJvd2xlZnQnLCBbODYxOV1dLCBbJ2xvb3BhcnJvd3JpZ2h0JywgWzg2MjBdXSwgWydsb3BhcicsIFsxMDYyOV1dLCBbJ0xvcGYnLCBbMTIwMTMxXV0sIFsnbG9wZicsIFsxMjAxNTddXSwgWydsb3BsdXMnLCBbMTA3OTddXSwgWydsb3RpbWVzJywgWzEwODA0XV0sIFsnbG93YXN0JywgWzg3MjddXSwgWydsb3diYXInLCBbOTVdXSwgWydMb3dlckxlZnRBcnJvdycsIFs4NjAxXV0sIFsnTG93ZXJSaWdodEFycm93JywgWzg2MDBdXSwgWydsb3onLCBbOTY3NF1dLCBbJ2xvemVuZ2UnLCBbOTY3NF1dLCBbJ2xvemYnLCBbMTA3MzFdXSwgWydscGFyJywgWzQwXV0sIFsnbHBhcmx0JywgWzEwNjQzXV0sIFsnbHJhcnInLCBbODY0Nl1dLCBbJ2xyY29ybmVyJywgWzg5OTFdXSwgWydscmhhcicsIFs4NjUxXV0sIFsnbHJoYXJkJywgWzEwNjA1XV0sIFsnbHJtJywgWzgyMDZdXSwgWydscnRyaScsIFs4ODk1XV0sIFsnbHNhcXVvJywgWzgyNDldXSwgWydsc2NyJywgWzEyMDAwMV1dLCBbJ0xzY3InLCBbODQ2Nl1dLCBbJ2xzaCcsIFs4NjI0XV0sIFsnTHNoJywgWzg2MjRdXSwgWydsc2ltJywgWzg4MThdXSwgWydsc2ltZScsIFsxMDg5M11dLCBbJ2xzaW1nJywgWzEwODk1XV0sIFsnbHNxYicsIFs5MV1dLCBbJ2xzcXVvJywgWzgyMTZdXSwgWydsc3F1b3InLCBbODIxOF1dLCBbJ0xzdHJvaycsIFszMjFdXSwgWydsc3Ryb2snLCBbMzIyXV0sIFsnbHRjYycsIFsxMDkxOF1dLCBbJ2x0Y2lyJywgWzEwODczXV0sIFsnbHQnLCBbNjBdXSwgWydMVCcsIFs2MF1dLCBbJ0x0JywgWzg4MTBdXSwgWydsdGRvdCcsIFs4OTE4XV0sIFsnbHRocmVlJywgWzg5MDddXSwgWydsdGltZXMnLCBbODkwNV1dLCBbJ2x0bGFycicsIFsxMDYxNF1dLCBbJ2x0cXVlc3QnLCBbMTA4NzVdXSwgWydsdHJpJywgWzk2NjddXSwgWydsdHJpZScsIFs4ODg0XV0sIFsnbHRyaWYnLCBbOTY2Nl1dLCBbJ2x0clBhcicsIFsxMDY0Nl1dLCBbJ2x1cmRzaGFyJywgWzEwNTcwXV0sIFsnbHVydWhhcicsIFsxMDU5OF1dLCBbJ2x2ZXJ0bmVxcScsIFs4ODA4LCA2NTAyNF1dLCBbJ2x2bkUnLCBbODgwOCwgNjUwMjRdXSwgWydtYWNyJywgWzE3NV1dLCBbJ21hbGUnLCBbOTc5NF1dLCBbJ21hbHQnLCBbMTAwMTZdXSwgWydtYWx0ZXNlJywgWzEwMDE2XV0sIFsnTWFwJywgWzEwNTAxXV0sIFsnbWFwJywgWzg2MTRdXSwgWydtYXBzdG8nLCBbODYxNF1dLCBbJ21hcHN0b2Rvd24nLCBbODYxNV1dLCBbJ21hcHN0b2xlZnQnLCBbODYxMl1dLCBbJ21hcHN0b3VwJywgWzg2MTNdXSwgWydtYXJrZXInLCBbOTY0Nl1dLCBbJ21jb21tYScsIFsxMDc5M11dLCBbJ01jeScsIFsxMDUyXV0sIFsnbWN5JywgWzEwODRdXSwgWydtZGFzaCcsIFs4MjEyXV0sIFsnbUREb3QnLCBbODc2Ml1dLCBbJ21lYXN1cmVkYW5nbGUnLCBbODczN11dLCBbJ01lZGl1bVNwYWNlJywgWzgyODddXSwgWydNZWxsaW50cmYnLCBbODQ5OV1dLCBbJ01mcicsIFsxMjAwODBdXSwgWydtZnInLCBbMTIwMTA2XV0sIFsnbWhvJywgWzg0ODddXSwgWydtaWNybycsIFsxODFdXSwgWydtaWRhc3QnLCBbNDJdXSwgWydtaWRjaXInLCBbMTA5OTJdXSwgWydtaWQnLCBbODczOV1dLCBbJ21pZGRvdCcsIFsxODNdXSwgWydtaW51c2InLCBbODg2M11dLCBbJ21pbnVzJywgWzg3MjJdXSwgWydtaW51c2QnLCBbODc2MF1dLCBbJ21pbnVzZHUnLCBbMTA3OTRdXSwgWydNaW51c1BsdXMnLCBbODcyM11dLCBbJ21sY3AnLCBbMTA5NzFdXSwgWydtbGRyJywgWzgyMzBdXSwgWydtbnBsdXMnLCBbODcyM11dLCBbJ21vZGVscycsIFs4ODcxXV0sIFsnTW9wZicsIFsxMjAxMzJdXSwgWydtb3BmJywgWzEyMDE1OF1dLCBbJ21wJywgWzg3MjNdXSwgWydtc2NyJywgWzEyMDAwMl1dLCBbJ01zY3InLCBbODQ5OV1dLCBbJ21zdHBvcycsIFs4NzY2XV0sIFsnTXUnLCBbOTI0XV0sIFsnbXUnLCBbOTU2XV0sIFsnbXVsdGltYXAnLCBbODg4OF1dLCBbJ211bWFwJywgWzg4ODhdXSwgWyduYWJsYScsIFs4NzExXV0sIFsnTmFjdXRlJywgWzMyM11dLCBbJ25hY3V0ZScsIFszMjRdXSwgWyduYW5nJywgWzg3MzYsIDg0MDJdXSwgWyduYXAnLCBbODc3N11dLCBbJ25hcEUnLCBbMTA4NjQsIDgyNF1dLCBbJ25hcGlkJywgWzg3NzksIDgyNF1dLCBbJ25hcG9zJywgWzMyOV1dLCBbJ25hcHByb3gnLCBbODc3N11dLCBbJ25hdHVyYWwnLCBbOTgzOF1dLCBbJ25hdHVyYWxzJywgWzg0NjldXSwgWyduYXR1cicsIFs5ODM4XV0sIFsnbmJzcCcsIFsxNjBdXSwgWyduYnVtcCcsIFs4NzgyLCA4MjRdXSwgWyduYnVtcGUnLCBbODc4MywgODI0XV0sIFsnbmNhcCcsIFsxMDgxOV1dLCBbJ05jYXJvbicsIFszMjddXSwgWyduY2Fyb24nLCBbMzI4XV0sIFsnTmNlZGlsJywgWzMyNV1dLCBbJ25jZWRpbCcsIFszMjZdXSwgWyduY29uZycsIFs4Nzc1XV0sIFsnbmNvbmdkb3QnLCBbMTA4NjEsIDgyNF1dLCBbJ25jdXAnLCBbMTA4MThdXSwgWydOY3knLCBbMTA1M11dLCBbJ25jeScsIFsxMDg1XV0sIFsnbmRhc2gnLCBbODIxMV1dLCBbJ25lYXJoaycsIFsxMDUzMl1dLCBbJ25lYXJyJywgWzg1OTldXSwgWyduZUFycicsIFs4NjYzXV0sIFsnbmVhcnJvdycsIFs4NTk5XV0sIFsnbmUnLCBbODgwMF1dLCBbJ25lZG90JywgWzg3ODQsIDgyNF1dLCBbJ05lZ2F0aXZlTWVkaXVtU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVGhpY2tTcGFjZScsIFs4MjAzXV0sIFsnTmVnYXRpdmVUaGluU3BhY2UnLCBbODIwM11dLCBbJ05lZ2F0aXZlVmVyeVRoaW5TcGFjZScsIFs4MjAzXV0sIFsnbmVxdWl2JywgWzg4MDJdXSwgWyduZXNlYXInLCBbMTA1MzZdXSwgWyduZXNpbScsIFs4NzcwLCA4MjRdXSwgWydOZXN0ZWRHcmVhdGVyR3JlYXRlcicsIFs4ODExXV0sIFsnTmVzdGVkTGVzc0xlc3MnLCBbODgxMF1dLCBbJ25leGlzdCcsIFs4NzA4XV0sIFsnbmV4aXN0cycsIFs4NzA4XV0sIFsnTmZyJywgWzEyMDA4MV1dLCBbJ25mcicsIFsxMjAxMDddXSwgWyduZ0UnLCBbODgwNywgODI0XV0sIFsnbmdlJywgWzg4MTddXSwgWyduZ2VxJywgWzg4MTddXSwgWyduZ2VxcScsIFs4ODA3LCA4MjRdXSwgWyduZ2Vxc2xhbnQnLCBbMTA4NzgsIDgyNF1dLCBbJ25nZXMnLCBbMTA4NzgsIDgyNF1dLCBbJ25HZycsIFs4OTIxLCA4MjRdXSwgWyduZ3NpbScsIFs4ODIxXV0sIFsnbkd0JywgWzg4MTEsIDg0MDJdXSwgWyduZ3QnLCBbODgxNV1dLCBbJ25ndHInLCBbODgxNV1dLCBbJ25HdHYnLCBbODgxMSwgODI0XV0sIFsnbmhhcnInLCBbODYyMl1dLCBbJ25oQXJyJywgWzg2NTRdXSwgWyduaHBhcicsIFsxMDk5NF1dLCBbJ25pJywgWzg3MTVdXSwgWyduaXMnLCBbODk1Nl1dLCBbJ25pc2QnLCBbODk1NF1dLCBbJ25pdicsIFs4NzE1XV0sIFsnTkpjeScsIFsxMDM0XV0sIFsnbmpjeScsIFsxMTE0XV0sIFsnbmxhcnInLCBbODYwMl1dLCBbJ25sQXJyJywgWzg2NTNdXSwgWydubGRyJywgWzgyMjldXSwgWydubEUnLCBbODgwNiwgODI0XV0sIFsnbmxlJywgWzg4MTZdXSwgWydubGVmdGFycm93JywgWzg2MDJdXSwgWyduTGVmdGFycm93JywgWzg2NTNdXSwgWydubGVmdHJpZ2h0YXJyb3cnLCBbODYyMl1dLCBbJ25MZWZ0cmlnaHRhcnJvdycsIFs4NjU0XV0sIFsnbmxlcScsIFs4ODE2XV0sIFsnbmxlcXEnLCBbODgwNiwgODI0XV0sIFsnbmxlcXNsYW50JywgWzEwODc3LCA4MjRdXSwgWydubGVzJywgWzEwODc3LCA4MjRdXSwgWydubGVzcycsIFs4ODE0XV0sIFsnbkxsJywgWzg5MjAsIDgyNF1dLCBbJ25sc2ltJywgWzg4MjBdXSwgWyduTHQnLCBbODgxMCwgODQwMl1dLCBbJ25sdCcsIFs4ODE0XV0sIFsnbmx0cmknLCBbODkzOF1dLCBbJ25sdHJpZScsIFs4OTQwXV0sIFsnbkx0dicsIFs4ODEwLCA4MjRdXSwgWydubWlkJywgWzg3NDBdXSwgWydOb0JyZWFrJywgWzgyODhdXSwgWydOb25CcmVha2luZ1NwYWNlJywgWzE2MF1dLCBbJ25vcGYnLCBbMTIwMTU5XV0sIFsnTm9wZicsIFs4NDY5XV0sIFsnTm90JywgWzEwOTg4XV0sIFsnbm90JywgWzE3Ml1dLCBbJ05vdENvbmdydWVudCcsIFs4ODAyXV0sIFsnTm90Q3VwQ2FwJywgWzg4MTNdXSwgWydOb3REb3VibGVWZXJ0aWNhbEJhcicsIFs4NzQyXV0sIFsnTm90RWxlbWVudCcsIFs4NzEzXV0sIFsnTm90RXF1YWwnLCBbODgwMF1dLCBbJ05vdEVxdWFsVGlsZGUnLCBbODc3MCwgODI0XV0sIFsnTm90RXhpc3RzJywgWzg3MDhdXSwgWydOb3RHcmVhdGVyJywgWzg4MTVdXSwgWydOb3RHcmVhdGVyRXF1YWwnLCBbODgxN11dLCBbJ05vdEdyZWF0ZXJGdWxsRXF1YWwnLCBbODgwNywgODI0XV0sIFsnTm90R3JlYXRlckdyZWF0ZXInLCBbODgxMSwgODI0XV0sIFsnTm90R3JlYXRlckxlc3MnLCBbODgyNV1dLCBbJ05vdEdyZWF0ZXJTbGFudEVxdWFsJywgWzEwODc4LCA4MjRdXSwgWydOb3RHcmVhdGVyVGlsZGUnLCBbODgyMV1dLCBbJ05vdEh1bXBEb3duSHVtcCcsIFs4NzgyLCA4MjRdXSwgWydOb3RIdW1wRXF1YWwnLCBbODc4MywgODI0XV0sIFsnbm90aW4nLCBbODcxM11dLCBbJ25vdGluZG90JywgWzg5NDksIDgyNF1dLCBbJ25vdGluRScsIFs4OTUzLCA4MjRdXSwgWydub3RpbnZhJywgWzg3MTNdXSwgWydub3RpbnZiJywgWzg5NTFdXSwgWydub3RpbnZjJywgWzg5NTBdXSwgWydOb3RMZWZ0VHJpYW5nbGVCYXInLCBbMTA3MDMsIDgyNF1dLCBbJ05vdExlZnRUcmlhbmdsZScsIFs4OTM4XV0sIFsnTm90TGVmdFRyaWFuZ2xlRXF1YWwnLCBbODk0MF1dLCBbJ05vdExlc3MnLCBbODgxNF1dLCBbJ05vdExlc3NFcXVhbCcsIFs4ODE2XV0sIFsnTm90TGVzc0dyZWF0ZXInLCBbODgyNF1dLCBbJ05vdExlc3NMZXNzJywgWzg4MTAsIDgyNF1dLCBbJ05vdExlc3NTbGFudEVxdWFsJywgWzEwODc3LCA4MjRdXSwgWydOb3RMZXNzVGlsZGUnLCBbODgyMF1dLCBbJ05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywgWzEwOTE0LCA4MjRdXSwgWydOb3ROZXN0ZWRMZXNzTGVzcycsIFsxMDkxMywgODI0XV0sIFsnbm90bmknLCBbODcxNl1dLCBbJ25vdG5pdmEnLCBbODcxNl1dLCBbJ25vdG5pdmInLCBbODk1OF1dLCBbJ25vdG5pdmMnLCBbODk1N11dLCBbJ05vdFByZWNlZGVzJywgWzg4MzJdXSwgWydOb3RQcmVjZWRlc0VxdWFsJywgWzEwOTI3LCA4MjRdXSwgWydOb3RQcmVjZWRlc1NsYW50RXF1YWwnLCBbODkyOF1dLCBbJ05vdFJldmVyc2VFbGVtZW50JywgWzg3MTZdXSwgWydOb3RSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0LCA4MjRdXSwgWydOb3RSaWdodFRyaWFuZ2xlJywgWzg5MzldXSwgWydOb3RSaWdodFRyaWFuZ2xlRXF1YWwnLCBbODk0MV1dLCBbJ05vdFNxdWFyZVN1YnNldCcsIFs4ODQ3LCA4MjRdXSwgWydOb3RTcXVhcmVTdWJzZXRFcXVhbCcsIFs4OTMwXV0sIFsnTm90U3F1YXJlU3VwZXJzZXQnLCBbODg0OCwgODI0XV0sIFsnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCcsIFs4OTMxXV0sIFsnTm90U3Vic2V0JywgWzg4MzQsIDg0MDJdXSwgWydOb3RTdWJzZXRFcXVhbCcsIFs4ODQwXV0sIFsnTm90U3VjY2VlZHMnLCBbODgzM11dLCBbJ05vdFN1Y2NlZWRzRXF1YWwnLCBbMTA5MjgsIDgyNF1dLCBbJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCcsIFs4OTI5XV0sIFsnTm90U3VjY2VlZHNUaWxkZScsIFs4ODMxLCA4MjRdXSwgWydOb3RTdXBlcnNldCcsIFs4ODM1LCA4NDAyXV0sIFsnTm90U3VwZXJzZXRFcXVhbCcsIFs4ODQxXV0sIFsnTm90VGlsZGUnLCBbODc2OV1dLCBbJ05vdFRpbGRlRXF1YWwnLCBbODc3Ml1dLCBbJ05vdFRpbGRlRnVsbEVxdWFsJywgWzg3NzVdXSwgWydOb3RUaWxkZVRpbGRlJywgWzg3NzddXSwgWydOb3RWZXJ0aWNhbEJhcicsIFs4NzQwXV0sIFsnbnBhcmFsbGVsJywgWzg3NDJdXSwgWyducGFyJywgWzg3NDJdXSwgWyducGFyc2wnLCBbMTEwMDUsIDg0MjFdXSwgWyducGFydCcsIFs4NzA2LCA4MjRdXSwgWyducG9saW50JywgWzEwNzcyXV0sIFsnbnByJywgWzg4MzJdXSwgWyducHJjdWUnLCBbODkyOF1dLCBbJ25wcmVjJywgWzg4MzJdXSwgWyducHJlY2VxJywgWzEwOTI3LCA4MjRdXSwgWyducHJlJywgWzEwOTI3LCA4MjRdXSwgWyducmFycmMnLCBbMTA1NDcsIDgyNF1dLCBbJ25yYXJyJywgWzg2MDNdXSwgWyduckFycicsIFs4NjU1XV0sIFsnbnJhcnJ3JywgWzg2MDUsIDgyNF1dLCBbJ25yaWdodGFycm93JywgWzg2MDNdXSwgWyduUmlnaHRhcnJvdycsIFs4NjU1XV0sIFsnbnJ0cmknLCBbODkzOV1dLCBbJ25ydHJpZScsIFs4OTQxXV0sIFsnbnNjJywgWzg4MzNdXSwgWyduc2NjdWUnLCBbODkyOV1dLCBbJ25zY2UnLCBbMTA5MjgsIDgyNF1dLCBbJ05zY3InLCBbMTE5OTc3XV0sIFsnbnNjcicsIFsxMjAwMDNdXSwgWyduc2hvcnRtaWQnLCBbODc0MF1dLCBbJ25zaG9ydHBhcmFsbGVsJywgWzg3NDJdXSwgWyduc2ltJywgWzg3NjldXSwgWyduc2ltZScsIFs4NzcyXV0sIFsnbnNpbWVxJywgWzg3NzJdXSwgWyduc21pZCcsIFs4NzQwXV0sIFsnbnNwYXInLCBbODc0Ml1dLCBbJ25zcXN1YmUnLCBbODkzMF1dLCBbJ25zcXN1cGUnLCBbODkzMV1dLCBbJ25zdWInLCBbODgzNl1dLCBbJ25zdWJFJywgWzEwOTQ5LCA4MjRdXSwgWyduc3ViZScsIFs4ODQwXV0sIFsnbnN1YnNldCcsIFs4ODM0LCA4NDAyXV0sIFsnbnN1YnNldGVxJywgWzg4NDBdXSwgWyduc3Vic2V0ZXFxJywgWzEwOTQ5LCA4MjRdXSwgWyduc3VjYycsIFs4ODMzXV0sIFsnbnN1Y2NlcScsIFsxMDkyOCwgODI0XV0sIFsnbnN1cCcsIFs4ODM3XV0sIFsnbnN1cEUnLCBbMTA5NTAsIDgyNF1dLCBbJ25zdXBlJywgWzg4NDFdXSwgWyduc3Vwc2V0JywgWzg4MzUsIDg0MDJdXSwgWyduc3Vwc2V0ZXEnLCBbODg0MV1dLCBbJ25zdXBzZXRlcXEnLCBbMTA5NTAsIDgyNF1dLCBbJ250Z2wnLCBbODgyNV1dLCBbJ050aWxkZScsIFsyMDldXSwgWydudGlsZGUnLCBbMjQxXV0sIFsnbnRsZycsIFs4ODI0XV0sIFsnbnRyaWFuZ2xlbGVmdCcsIFs4OTM4XV0sIFsnbnRyaWFuZ2xlbGVmdGVxJywgWzg5NDBdXSwgWydudHJpYW5nbGVyaWdodCcsIFs4OTM5XV0sIFsnbnRyaWFuZ2xlcmlnaHRlcScsIFs4OTQxXV0sIFsnTnUnLCBbOTI1XV0sIFsnbnUnLCBbOTU3XV0sIFsnbnVtJywgWzM1XV0sIFsnbnVtZXJvJywgWzg0NzBdXSwgWydudW1zcCcsIFs4MTk5XV0sIFsnbnZhcCcsIFs4NzgxLCA4NDAyXV0sIFsnbnZkYXNoJywgWzg4NzZdXSwgWydudkRhc2gnLCBbODg3N11dLCBbJ25WZGFzaCcsIFs4ODc4XV0sIFsnblZEYXNoJywgWzg4NzldXSwgWydudmdlJywgWzg4MDUsIDg0MDJdXSwgWydudmd0JywgWzYyLCA4NDAyXV0sIFsnbnZIYXJyJywgWzEwNTAwXV0sIFsnbnZpbmZpbicsIFsxMDcxOF1dLCBbJ252bEFycicsIFsxMDQ5OF1dLCBbJ252bGUnLCBbODgwNCwgODQwMl1dLCBbJ252bHQnLCBbNjAsIDg0MDJdXSwgWydudmx0cmllJywgWzg4ODQsIDg0MDJdXSwgWydudnJBcnInLCBbMTA0OTldXSwgWydudnJ0cmllJywgWzg4ODUsIDg0MDJdXSwgWydudnNpbScsIFs4NzY0LCA4NDAyXV0sIFsnbndhcmhrJywgWzEwNTMxXV0sIFsnbndhcnInLCBbODU5OF1dLCBbJ253QXJyJywgWzg2NjJdXSwgWydud2Fycm93JywgWzg1OThdXSwgWydud25lYXInLCBbMTA1MzVdXSwgWydPYWN1dGUnLCBbMjExXV0sIFsnb2FjdXRlJywgWzI0M11dLCBbJ29hc3QnLCBbODg1OV1dLCBbJ09jaXJjJywgWzIxMl1dLCBbJ29jaXJjJywgWzI0NF1dLCBbJ29jaXInLCBbODg1OF1dLCBbJ09jeScsIFsxMDU0XV0sIFsnb2N5JywgWzEwODZdXSwgWydvZGFzaCcsIFs4ODYxXV0sIFsnT2RibGFjJywgWzMzNl1dLCBbJ29kYmxhYycsIFszMzddXSwgWydvZGl2JywgWzEwODA4XV0sIFsnb2RvdCcsIFs4ODU3XV0sIFsnb2Rzb2xkJywgWzEwNjg0XV0sIFsnT0VsaWcnLCBbMzM4XV0sIFsnb2VsaWcnLCBbMzM5XV0sIFsnb2ZjaXInLCBbMTA2ODddXSwgWydPZnInLCBbMTIwMDgyXV0sIFsnb2ZyJywgWzEyMDEwOF1dLCBbJ29nb24nLCBbNzMxXV0sIFsnT2dyYXZlJywgWzIxMF1dLCBbJ29ncmF2ZScsIFsyNDJdXSwgWydvZ3QnLCBbMTA2ODldXSwgWydvaGJhcicsIFsxMDY3N11dLCBbJ29obScsIFs5MzddXSwgWydvaW50JywgWzg3NTBdXSwgWydvbGFycicsIFs4NjM0XV0sIFsnb2xjaXInLCBbMTA2ODZdXSwgWydvbGNyb3NzJywgWzEwNjgzXV0sIFsnb2xpbmUnLCBbODI1NF1dLCBbJ29sdCcsIFsxMDY4OF1dLCBbJ09tYWNyJywgWzMzMl1dLCBbJ29tYWNyJywgWzMzM11dLCBbJ09tZWdhJywgWzkzN11dLCBbJ29tZWdhJywgWzk2OV1dLCBbJ09taWNyb24nLCBbOTI3XV0sIFsnb21pY3JvbicsIFs5NTldXSwgWydvbWlkJywgWzEwNjc4XV0sIFsnb21pbnVzJywgWzg4NTRdXSwgWydPb3BmJywgWzEyMDEzNF1dLCBbJ29vcGYnLCBbMTIwMTYwXV0sIFsnb3BhcicsIFsxMDY3OV1dLCBbJ09wZW5DdXJseURvdWJsZVF1b3RlJywgWzgyMjBdXSwgWydPcGVuQ3VybHlRdW90ZScsIFs4MjE2XV0sIFsnb3BlcnAnLCBbMTA2ODFdXSwgWydvcGx1cycsIFs4ODUzXV0sIFsnb3JhcnInLCBbODYzNV1dLCBbJ09yJywgWzEwODM2XV0sIFsnb3InLCBbODc0NF1dLCBbJ29yZCcsIFsxMDg0NV1dLCBbJ29yZGVyJywgWzg1MDBdXSwgWydvcmRlcm9mJywgWzg1MDBdXSwgWydvcmRmJywgWzE3MF1dLCBbJ29yZG0nLCBbMTg2XV0sIFsnb3JpZ29mJywgWzg4ODZdXSwgWydvcm9yJywgWzEwODM4XV0sIFsnb3JzbG9wZScsIFsxMDgzOV1dLCBbJ29ydicsIFsxMDg0M11dLCBbJ29TJywgWzk0MTZdXSwgWydPc2NyJywgWzExOTk3OF1dLCBbJ29zY3InLCBbODUwMF1dLCBbJ09zbGFzaCcsIFsyMTZdXSwgWydvc2xhc2gnLCBbMjQ4XV0sIFsnb3NvbCcsIFs4ODU2XV0sIFsnT3RpbGRlJywgWzIxM11dLCBbJ290aWxkZScsIFsyNDVdXSwgWydvdGltZXNhcycsIFsxMDgwNl1dLCBbJ090aW1lcycsIFsxMDgwN11dLCBbJ290aW1lcycsIFs4ODU1XV0sIFsnT3VtbCcsIFsyMTRdXSwgWydvdW1sJywgWzI0Nl1dLCBbJ292YmFyJywgWzkwMjFdXSwgWydPdmVyQmFyJywgWzgyNTRdXSwgWydPdmVyQnJhY2UnLCBbOTE4Ml1dLCBbJ092ZXJCcmFja2V0JywgWzkxNDBdXSwgWydPdmVyUGFyZW50aGVzaXMnLCBbOTE4MF1dLCBbJ3BhcmEnLCBbMTgyXV0sIFsncGFyYWxsZWwnLCBbODc0MV1dLCBbJ3BhcicsIFs4NzQxXV0sIFsncGFyc2ltJywgWzEwOTk1XV0sIFsncGFyc2wnLCBbMTEwMDVdXSwgWydwYXJ0JywgWzg3MDZdXSwgWydQYXJ0aWFsRCcsIFs4NzA2XV0sIFsnUGN5JywgWzEwNTVdXSwgWydwY3knLCBbMTA4N11dLCBbJ3BlcmNudCcsIFszN11dLCBbJ3BlcmlvZCcsIFs0Nl1dLCBbJ3Blcm1pbCcsIFs4MjQwXV0sIFsncGVycCcsIFs4ODY5XV0sIFsncGVydGVuaycsIFs4MjQxXV0sIFsnUGZyJywgWzEyMDA4M11dLCBbJ3BmcicsIFsxMjAxMDldXSwgWydQaGknLCBbOTM0XV0sIFsncGhpJywgWzk2Nl1dLCBbJ3BoaXYnLCBbOTgxXV0sIFsncGhtbWF0JywgWzg0OTldXSwgWydwaG9uZScsIFs5NzQyXV0sIFsnUGknLCBbOTI4XV0sIFsncGknLCBbOTYwXV0sIFsncGl0Y2hmb3JrJywgWzg5MTZdXSwgWydwaXYnLCBbOTgyXV0sIFsncGxhbmNrJywgWzg0NjNdXSwgWydwbGFuY2toJywgWzg0NjJdXSwgWydwbGFua3YnLCBbODQ2M11dLCBbJ3BsdXNhY2lyJywgWzEwNzg3XV0sIFsncGx1c2InLCBbODg2Ml1dLCBbJ3BsdXNjaXInLCBbMTA3ODZdXSwgWydwbHVzJywgWzQzXV0sIFsncGx1c2RvJywgWzg3MjRdXSwgWydwbHVzZHUnLCBbMTA3ODldXSwgWydwbHVzZScsIFsxMDg2Nl1dLCBbJ1BsdXNNaW51cycsIFsxNzddXSwgWydwbHVzbW4nLCBbMTc3XV0sIFsncGx1c3NpbScsIFsxMDc5MF1dLCBbJ3BsdXN0d28nLCBbMTA3OTFdXSwgWydwbScsIFsxNzddXSwgWydQb2luY2FyZXBsYW5lJywgWzg0NjBdXSwgWydwb2ludGludCcsIFsxMDc3M11dLCBbJ3BvcGYnLCBbMTIwMTYxXV0sIFsnUG9wZicsIFs4NDczXV0sIFsncG91bmQnLCBbMTYzXV0sIFsncHJhcCcsIFsxMDkzNV1dLCBbJ1ByJywgWzEwOTM5XV0sIFsncHInLCBbODgyNl1dLCBbJ3ByY3VlJywgWzg4MjhdXSwgWydwcmVjYXBwcm94JywgWzEwOTM1XV0sIFsncHJlYycsIFs4ODI2XV0sIFsncHJlY2N1cmx5ZXEnLCBbODgyOF1dLCBbJ1ByZWNlZGVzJywgWzg4MjZdXSwgWydQcmVjZWRlc0VxdWFsJywgWzEwOTI3XV0sIFsnUHJlY2VkZXNTbGFudEVxdWFsJywgWzg4MjhdXSwgWydQcmVjZWRlc1RpbGRlJywgWzg4MzBdXSwgWydwcmVjZXEnLCBbMTA5MjddXSwgWydwcmVjbmFwcHJveCcsIFsxMDkzN11dLCBbJ3ByZWNuZXFxJywgWzEwOTMzXV0sIFsncHJlY25zaW0nLCBbODkzNl1dLCBbJ3ByZScsIFsxMDkyN11dLCBbJ3ByRScsIFsxMDkzMV1dLCBbJ3ByZWNzaW0nLCBbODgzMF1dLCBbJ3ByaW1lJywgWzgyNDJdXSwgWydQcmltZScsIFs4MjQzXV0sIFsncHJpbWVzJywgWzg0NzNdXSwgWydwcm5hcCcsIFsxMDkzN11dLCBbJ3BybkUnLCBbMTA5MzNdXSwgWydwcm5zaW0nLCBbODkzNl1dLCBbJ3Byb2QnLCBbODcxOV1dLCBbJ1Byb2R1Y3QnLCBbODcxOV1dLCBbJ3Byb2ZhbGFyJywgWzkwMDZdXSwgWydwcm9mbGluZScsIFs4OTc4XV0sIFsncHJvZnN1cmYnLCBbODk3OV1dLCBbJ3Byb3AnLCBbODczM11dLCBbJ1Byb3BvcnRpb25hbCcsIFs4NzMzXV0sIFsnUHJvcG9ydGlvbicsIFs4NzU5XV0sIFsncHJvcHRvJywgWzg3MzNdXSwgWydwcnNpbScsIFs4ODMwXV0sIFsncHJ1cmVsJywgWzg4ODBdXSwgWydQc2NyJywgWzExOTk3OV1dLCBbJ3BzY3InLCBbMTIwMDA1XV0sIFsnUHNpJywgWzkzNl1dLCBbJ3BzaScsIFs5NjhdXSwgWydwdW5jc3AnLCBbODIwMF1dLCBbJ1FmcicsIFsxMjAwODRdXSwgWydxZnInLCBbMTIwMTEwXV0sIFsncWludCcsIFsxMDc2NF1dLCBbJ3FvcGYnLCBbMTIwMTYyXV0sIFsnUW9wZicsIFs4NDc0XV0sIFsncXByaW1lJywgWzgyNzldXSwgWydRc2NyJywgWzExOTk4MF1dLCBbJ3FzY3InLCBbMTIwMDA2XV0sIFsncXVhdGVybmlvbnMnLCBbODQ2MV1dLCBbJ3F1YXRpbnQnLCBbMTA3NzRdXSwgWydxdWVzdCcsIFs2M11dLCBbJ3F1ZXN0ZXEnLCBbODc5OV1dLCBbJ3F1b3QnLCBbMzRdXSwgWydRVU9UJywgWzM0XV0sIFsnckFhcnInLCBbODY2N11dLCBbJ3JhY2UnLCBbODc2NSwgODE3XV0sIFsnUmFjdXRlJywgWzM0MF1dLCBbJ3JhY3V0ZScsIFszNDFdXSwgWydyYWRpYycsIFs4NzMwXV0sIFsncmFlbXB0eXYnLCBbMTA2NzVdXSwgWydyYW5nJywgWzEwMjE3XV0sIFsnUmFuZycsIFsxMDIxOV1dLCBbJ3JhbmdkJywgWzEwNjQyXV0sIFsncmFuZ2UnLCBbMTA2NjFdXSwgWydyYW5nbGUnLCBbMTAyMTddXSwgWydyYXF1bycsIFsxODddXSwgWydyYXJyYXAnLCBbMTA2MTNdXSwgWydyYXJyYicsIFs4Njc3XV0sIFsncmFycmJmcycsIFsxMDUyOF1dLCBbJ3JhcnJjJywgWzEwNTQ3XV0sIFsncmFycicsIFs4NTk0XV0sIFsnUmFycicsIFs4NjA4XV0sIFsnckFycicsIFs4NjU4XV0sIFsncmFycmZzJywgWzEwNTI2XV0sIFsncmFycmhrJywgWzg2MThdXSwgWydyYXJybHAnLCBbODYyMF1dLCBbJ3JhcnJwbCcsIFsxMDU2NV1dLCBbJ3JhcnJzaW0nLCBbMTA2MTJdXSwgWydSYXJydGwnLCBbMTA1MThdXSwgWydyYXJydGwnLCBbODYxMV1dLCBbJ3JhcnJ3JywgWzg2MDVdXSwgWydyYXRhaWwnLCBbMTA1MjJdXSwgWydyQXRhaWwnLCBbMTA1MjRdXSwgWydyYXRpbycsIFs4NzU4XV0sIFsncmF0aW9uYWxzJywgWzg0NzRdXSwgWydyYmFycicsIFsxMDUwOV1dLCBbJ3JCYXJyJywgWzEwNTExXV0sIFsnUkJhcnInLCBbMTA1MTJdXSwgWydyYmJyaycsIFsxMDA5OV1dLCBbJ3JicmFjZScsIFsxMjVdXSwgWydyYnJhY2snLCBbOTNdXSwgWydyYnJrZScsIFsxMDYzNl1dLCBbJ3JicmtzbGQnLCBbMTA2MzhdXSwgWydyYnJrc2x1JywgWzEwNjQwXV0sIFsnUmNhcm9uJywgWzM0NF1dLCBbJ3JjYXJvbicsIFszNDVdXSwgWydSY2VkaWwnLCBbMzQyXV0sIFsncmNlZGlsJywgWzM0M11dLCBbJ3JjZWlsJywgWzg5NjldXSwgWydyY3ViJywgWzEyNV1dLCBbJ1JjeScsIFsxMDU2XV0sIFsncmN5JywgWzEwODhdXSwgWydyZGNhJywgWzEwNTUxXV0sIFsncmRsZGhhcicsIFsxMDYwMV1dLCBbJ3JkcXVvJywgWzgyMjFdXSwgWydyZHF1b3InLCBbODIyMV1dLCBbJ0Nsb3NlQ3VybHlEb3VibGVRdW90ZScsIFs4MjIxXV0sIFsncmRzaCcsIFs4NjI3XV0sIFsncmVhbCcsIFs4NDc2XV0sIFsncmVhbGluZScsIFs4NDc1XV0sIFsncmVhbHBhcnQnLCBbODQ3Nl1dLCBbJ3JlYWxzJywgWzg0NzddXSwgWydSZScsIFs4NDc2XV0sIFsncmVjdCcsIFs5NjQ1XV0sIFsncmVnJywgWzE3NF1dLCBbJ1JFRycsIFsxNzRdXSwgWydSZXZlcnNlRWxlbWVudCcsIFs4NzE1XV0sIFsnUmV2ZXJzZUVxdWlsaWJyaXVtJywgWzg2NTFdXSwgWydSZXZlcnNlVXBFcXVpbGlicml1bScsIFsxMDYwN11dLCBbJ3JmaXNodCcsIFsxMDYyMV1dLCBbJ3JmbG9vcicsIFs4OTcxXV0sIFsncmZyJywgWzEyMDExMV1dLCBbJ1JmcicsIFs4NDc2XV0sIFsnckhhcicsIFsxMDU5Nl1dLCBbJ3JoYXJkJywgWzg2NDFdXSwgWydyaGFydScsIFs4NjQwXV0sIFsncmhhcnVsJywgWzEwNjA0XV0sIFsnUmhvJywgWzkyOV1dLCBbJ3JobycsIFs5NjFdXSwgWydyaG92JywgWzEwMDldXSwgWydSaWdodEFuZ2xlQnJhY2tldCcsIFsxMDIxN11dLCBbJ1JpZ2h0QXJyb3dCYXInLCBbODY3N11dLCBbJ3JpZ2h0YXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0QXJyb3cnLCBbODU5NF1dLCBbJ1JpZ2h0YXJyb3cnLCBbODY1OF1dLCBbJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnLCBbODY0NF1dLCBbJ3JpZ2h0YXJyb3d0YWlsJywgWzg2MTFdXSwgWydSaWdodENlaWxpbmcnLCBbODk2OV1dLCBbJ1JpZ2h0RG91YmxlQnJhY2tldCcsIFsxMDIxNV1dLCBbJ1JpZ2h0RG93blRlZVZlY3RvcicsIFsxMDU4OV1dLCBbJ1JpZ2h0RG93blZlY3RvckJhcicsIFsxMDU4MV1dLCBbJ1JpZ2h0RG93blZlY3RvcicsIFs4NjQyXV0sIFsnUmlnaHRGbG9vcicsIFs4OTcxXV0sIFsncmlnaHRoYXJwb29uZG93bicsIFs4NjQxXV0sIFsncmlnaHRoYXJwb29udXAnLCBbODY0MF1dLCBbJ3JpZ2h0bGVmdGFycm93cycsIFs4NjQ0XV0sIFsncmlnaHRsZWZ0aGFycG9vbnMnLCBbODY1Ml1dLCBbJ3JpZ2h0cmlnaHRhcnJvd3MnLCBbODY0OV1dLCBbJ3JpZ2h0c3F1aWdhcnJvdycsIFs4NjA1XV0sIFsnUmlnaHRUZWVBcnJvdycsIFs4NjE0XV0sIFsnUmlnaHRUZWUnLCBbODg2Nl1dLCBbJ1JpZ2h0VGVlVmVjdG9yJywgWzEwNTg3XV0sIFsncmlnaHR0aHJlZXRpbWVzJywgWzg5MDhdXSwgWydSaWdodFRyaWFuZ2xlQmFyJywgWzEwNzA0XV0sIFsnUmlnaHRUcmlhbmdsZScsIFs4ODgzXV0sIFsnUmlnaHRUcmlhbmdsZUVxdWFsJywgWzg4ODVdXSwgWydSaWdodFVwRG93blZlY3RvcicsIFsxMDU3NV1dLCBbJ1JpZ2h0VXBUZWVWZWN0b3InLCBbMTA1ODhdXSwgWydSaWdodFVwVmVjdG9yQmFyJywgWzEwNTgwXV0sIFsnUmlnaHRVcFZlY3RvcicsIFs4NjM4XV0sIFsnUmlnaHRWZWN0b3JCYXInLCBbMTA1NzldXSwgWydSaWdodFZlY3RvcicsIFs4NjQwXV0sIFsncmluZycsIFs3MzBdXSwgWydyaXNpbmdkb3RzZXEnLCBbODc4N11dLCBbJ3JsYXJyJywgWzg2NDRdXSwgWydybGhhcicsIFs4NjUyXV0sIFsncmxtJywgWzgyMDddXSwgWydybW91c3RhY2hlJywgWzkxMzddXSwgWydybW91c3QnLCBbOTEzN11dLCBbJ3JubWlkJywgWzEwOTkwXV0sIFsncm9hbmcnLCBbMTAyMjFdXSwgWydyb2FycicsIFs4NzAyXV0sIFsncm9icmsnLCBbMTAyMTVdXSwgWydyb3BhcicsIFsxMDYzMF1dLCBbJ3JvcGYnLCBbMTIwMTYzXV0sIFsnUm9wZicsIFs4NDc3XV0sIFsncm9wbHVzJywgWzEwNzk4XV0sIFsncm90aW1lcycsIFsxMDgwNV1dLCBbJ1JvdW5kSW1wbGllcycsIFsxMDYwOF1dLCBbJ3JwYXInLCBbNDFdXSwgWydycGFyZ3QnLCBbMTA2NDRdXSwgWydycHBvbGludCcsIFsxMDc3MF1dLCBbJ3JyYXJyJywgWzg2NDldXSwgWydScmlnaHRhcnJvdycsIFs4NjY3XV0sIFsncnNhcXVvJywgWzgyNTBdXSwgWydyc2NyJywgWzEyMDAwN11dLCBbJ1JzY3InLCBbODQ3NV1dLCBbJ3JzaCcsIFs4NjI1XV0sIFsnUnNoJywgWzg2MjVdXSwgWydyc3FiJywgWzkzXV0sIFsncnNxdW8nLCBbODIxN11dLCBbJ3JzcXVvcicsIFs4MjE3XV0sIFsnQ2xvc2VDdXJseVF1b3RlJywgWzgyMTddXSwgWydydGhyZWUnLCBbODkwOF1dLCBbJ3J0aW1lcycsIFs4OTA2XV0sIFsncnRyaScsIFs5NjU3XV0sIFsncnRyaWUnLCBbODg4NV1dLCBbJ3J0cmlmJywgWzk2NTZdXSwgWydydHJpbHRyaScsIFsxMDcwMl1dLCBbJ1J1bGVEZWxheWVkJywgWzEwNzQwXV0sIFsncnVsdWhhcicsIFsxMDYwMF1dLCBbJ3J4JywgWzg0NzhdXSwgWydTYWN1dGUnLCBbMzQ2XV0sIFsnc2FjdXRlJywgWzM0N11dLCBbJ3NicXVvJywgWzgyMThdXSwgWydzY2FwJywgWzEwOTM2XV0sIFsnU2Nhcm9uJywgWzM1Ml1dLCBbJ3NjYXJvbicsIFszNTNdXSwgWydTYycsIFsxMDk0MF1dLCBbJ3NjJywgWzg4MjddXSwgWydzY2N1ZScsIFs4ODI5XV0sIFsnc2NlJywgWzEwOTI4XV0sIFsnc2NFJywgWzEwOTMyXV0sIFsnU2NlZGlsJywgWzM1MF1dLCBbJ3NjZWRpbCcsIFszNTFdXSwgWydTY2lyYycsIFszNDhdXSwgWydzY2lyYycsIFszNDldXSwgWydzY25hcCcsIFsxMDkzOF1dLCBbJ3NjbkUnLCBbMTA5MzRdXSwgWydzY25zaW0nLCBbODkzN11dLCBbJ3NjcG9saW50JywgWzEwNzcxXV0sIFsnc2NzaW0nLCBbODgzMV1dLCBbJ1NjeScsIFsxMDU3XV0sIFsnc2N5JywgWzEwODldXSwgWydzZG90YicsIFs4ODY1XV0sIFsnc2RvdCcsIFs4OTAxXV0sIFsnc2RvdGUnLCBbMTA4NTRdXSwgWydzZWFyaGsnLCBbMTA1MzNdXSwgWydzZWFycicsIFs4NjAwXV0sIFsnc2VBcnInLCBbODY2NF1dLCBbJ3NlYXJyb3cnLCBbODYwMF1dLCBbJ3NlY3QnLCBbMTY3XV0sIFsnc2VtaScsIFs1OV1dLCBbJ3Nlc3dhcicsIFsxMDUzN11dLCBbJ3NldG1pbnVzJywgWzg3MjZdXSwgWydzZXRtbicsIFs4NzI2XV0sIFsnc2V4dCcsIFsxMDAzOF1dLCBbJ1NmcicsIFsxMjAwODZdXSwgWydzZnInLCBbMTIwMTEyXV0sIFsnc2Zyb3duJywgWzg5OTRdXSwgWydzaGFycCcsIFs5ODM5XV0sIFsnU0hDSGN5JywgWzEwNjVdXSwgWydzaGNoY3knLCBbMTA5N11dLCBbJ1NIY3knLCBbMTA2NF1dLCBbJ3NoY3knLCBbMTA5Nl1dLCBbJ1Nob3J0RG93bkFycm93JywgWzg1OTVdXSwgWydTaG9ydExlZnRBcnJvdycsIFs4NTkyXV0sIFsnc2hvcnRtaWQnLCBbODczOV1dLCBbJ3Nob3J0cGFyYWxsZWwnLCBbODc0MV1dLCBbJ1Nob3J0UmlnaHRBcnJvdycsIFs4NTk0XV0sIFsnU2hvcnRVcEFycm93JywgWzg1OTNdXSwgWydzaHknLCBbMTczXV0sIFsnU2lnbWEnLCBbOTMxXV0sIFsnc2lnbWEnLCBbOTYzXV0sIFsnc2lnbWFmJywgWzk2Ml1dLCBbJ3NpZ21hdicsIFs5NjJdXSwgWydzaW0nLCBbODc2NF1dLCBbJ3NpbWRvdCcsIFsxMDg1OF1dLCBbJ3NpbWUnLCBbODc3MV1dLCBbJ3NpbWVxJywgWzg3NzFdXSwgWydzaW1nJywgWzEwOTEwXV0sIFsnc2ltZ0UnLCBbMTA5MTJdXSwgWydzaW1sJywgWzEwOTA5XV0sIFsnc2ltbEUnLCBbMTA5MTFdXSwgWydzaW1uZScsIFs4Nzc0XV0sIFsnc2ltcGx1cycsIFsxMDc4OF1dLCBbJ3NpbXJhcnInLCBbMTA2MTBdXSwgWydzbGFycicsIFs4NTkyXV0sIFsnU21hbGxDaXJjbGUnLCBbODcyOF1dLCBbJ3NtYWxsc2V0bWludXMnLCBbODcyNl1dLCBbJ3NtYXNocCcsIFsxMDgwM11dLCBbJ3NtZXBhcnNsJywgWzEwNzI0XV0sIFsnc21pZCcsIFs4NzM5XV0sIFsnc21pbGUnLCBbODk5NV1dLCBbJ3NtdCcsIFsxMDkyMl1dLCBbJ3NtdGUnLCBbMTA5MjRdXSwgWydzbXRlcycsIFsxMDkyNCwgNjUwMjRdXSwgWydTT0ZUY3knLCBbMTA2OF1dLCBbJ3NvZnRjeScsIFsxMTAwXV0sIFsnc29sYmFyJywgWzkwMjNdXSwgWydzb2xiJywgWzEwNjkyXV0sIFsnc29sJywgWzQ3XV0sIFsnU29wZicsIFsxMjAxMzhdXSwgWydzb3BmJywgWzEyMDE2NF1dLCBbJ3NwYWRlcycsIFs5ODI0XV0sIFsnc3BhZGVzdWl0JywgWzk4MjRdXSwgWydzcGFyJywgWzg3NDFdXSwgWydzcWNhcCcsIFs4ODUxXV0sIFsnc3FjYXBzJywgWzg4NTEsIDY1MDI0XV0sIFsnc3FjdXAnLCBbODg1Ml1dLCBbJ3NxY3VwcycsIFs4ODUyLCA2NTAyNF1dLCBbJ1NxcnQnLCBbODczMF1dLCBbJ3Nxc3ViJywgWzg4NDddXSwgWydzcXN1YmUnLCBbODg0OV1dLCBbJ3Nxc3Vic2V0JywgWzg4NDddXSwgWydzcXN1YnNldGVxJywgWzg4NDldXSwgWydzcXN1cCcsIFs4ODQ4XV0sIFsnc3FzdXBlJywgWzg4NTBdXSwgWydzcXN1cHNldCcsIFs4ODQ4XV0sIFsnc3FzdXBzZXRlcScsIFs4ODUwXV0sIFsnc3F1YXJlJywgWzk2MzNdXSwgWydTcXVhcmUnLCBbOTYzM11dLCBbJ1NxdWFyZUludGVyc2VjdGlvbicsIFs4ODUxXV0sIFsnU3F1YXJlU3Vic2V0JywgWzg4NDddXSwgWydTcXVhcmVTdWJzZXRFcXVhbCcsIFs4ODQ5XV0sIFsnU3F1YXJlU3VwZXJzZXQnLCBbODg0OF1dLCBbJ1NxdWFyZVN1cGVyc2V0RXF1YWwnLCBbODg1MF1dLCBbJ1NxdWFyZVVuaW9uJywgWzg4NTJdXSwgWydzcXVhcmYnLCBbOTY0Ml1dLCBbJ3NxdScsIFs5NjMzXV0sIFsnc3F1ZicsIFs5NjQyXV0sIFsnc3JhcnInLCBbODU5NF1dLCBbJ1NzY3InLCBbMTE5OTgyXV0sIFsnc3NjcicsIFsxMjAwMDhdXSwgWydzc2V0bW4nLCBbODcyNl1dLCBbJ3NzbWlsZScsIFs4OTk1XV0sIFsnc3N0YXJmJywgWzg5MDJdXSwgWydTdGFyJywgWzg5MDJdXSwgWydzdGFyJywgWzk3MzRdXSwgWydzdGFyZicsIFs5NzMzXV0sIFsnc3RyYWlnaHRlcHNpbG9uJywgWzEwMTNdXSwgWydzdHJhaWdodHBoaScsIFs5ODFdXSwgWydzdHJucycsIFsxNzVdXSwgWydzdWInLCBbODgzNF1dLCBbJ1N1YicsIFs4OTEyXV0sIFsnc3ViZG90JywgWzEwOTQxXV0sIFsnc3ViRScsIFsxMDk0OV1dLCBbJ3N1YmUnLCBbODgzOF1dLCBbJ3N1YmVkb3QnLCBbMTA5NDddXSwgWydzdWJtdWx0JywgWzEwOTQ1XV0sIFsnc3VibkUnLCBbMTA5NTVdXSwgWydzdWJuZScsIFs4ODQyXV0sIFsnc3VicGx1cycsIFsxMDk0M11dLCBbJ3N1YnJhcnInLCBbMTA2MTddXSwgWydzdWJzZXQnLCBbODgzNF1dLCBbJ1N1YnNldCcsIFs4OTEyXV0sIFsnc3Vic2V0ZXEnLCBbODgzOF1dLCBbJ3N1YnNldGVxcScsIFsxMDk0OV1dLCBbJ1N1YnNldEVxdWFsJywgWzg4MzhdXSwgWydzdWJzZXRuZXEnLCBbODg0Ml1dLCBbJ3N1YnNldG5lcXEnLCBbMTA5NTVdXSwgWydzdWJzaW0nLCBbMTA5NTFdXSwgWydzdWJzdWInLCBbMTA5NjVdXSwgWydzdWJzdXAnLCBbMTA5NjNdXSwgWydzdWNjYXBwcm94JywgWzEwOTM2XV0sIFsnc3VjYycsIFs4ODI3XV0sIFsnc3VjY2N1cmx5ZXEnLCBbODgyOV1dLCBbJ1N1Y2NlZWRzJywgWzg4MjddXSwgWydTdWNjZWVkc0VxdWFsJywgWzEwOTI4XV0sIFsnU3VjY2VlZHNTbGFudEVxdWFsJywgWzg4MjldXSwgWydTdWNjZWVkc1RpbGRlJywgWzg4MzFdXSwgWydzdWNjZXEnLCBbMTA5MjhdXSwgWydzdWNjbmFwcHJveCcsIFsxMDkzOF1dLCBbJ3N1Y2NuZXFxJywgWzEwOTM0XV0sIFsnc3VjY25zaW0nLCBbODkzN11dLCBbJ3N1Y2NzaW0nLCBbODgzMV1dLCBbJ1N1Y2hUaGF0JywgWzg3MTVdXSwgWydzdW0nLCBbODcyMV1dLCBbJ1N1bScsIFs4NzIxXV0sIFsnc3VuZycsIFs5ODM0XV0sIFsnc3VwMScsIFsxODVdXSwgWydzdXAyJywgWzE3OF1dLCBbJ3N1cDMnLCBbMTc5XV0sIFsnc3VwJywgWzg4MzVdXSwgWydTdXAnLCBbODkxM11dLCBbJ3N1cGRvdCcsIFsxMDk0Ml1dLCBbJ3N1cGRzdWInLCBbMTA5NjhdXSwgWydzdXBFJywgWzEwOTUwXV0sIFsnc3VwZScsIFs4ODM5XV0sIFsnc3VwZWRvdCcsIFsxMDk0OF1dLCBbJ1N1cGVyc2V0JywgWzg4MzVdXSwgWydTdXBlcnNldEVxdWFsJywgWzg4MzldXSwgWydzdXBoc29sJywgWzEwMTg1XV0sIFsnc3VwaHN1YicsIFsxMDk2N11dLCBbJ3N1cGxhcnInLCBbMTA2MTldXSwgWydzdXBtdWx0JywgWzEwOTQ2XV0sIFsnc3VwbkUnLCBbMTA5NTZdXSwgWydzdXBuZScsIFs4ODQzXV0sIFsnc3VwcGx1cycsIFsxMDk0NF1dLCBbJ3N1cHNldCcsIFs4ODM1XV0sIFsnU3Vwc2V0JywgWzg5MTNdXSwgWydzdXBzZXRlcScsIFs4ODM5XV0sIFsnc3Vwc2V0ZXFxJywgWzEwOTUwXV0sIFsnc3Vwc2V0bmVxJywgWzg4NDNdXSwgWydzdXBzZXRuZXFxJywgWzEwOTU2XV0sIFsnc3Vwc2ltJywgWzEwOTUyXV0sIFsnc3Vwc3ViJywgWzEwOTY0XV0sIFsnc3Vwc3VwJywgWzEwOTY2XV0sIFsnc3dhcmhrJywgWzEwNTM0XV0sIFsnc3dhcnInLCBbODYwMV1dLCBbJ3N3QXJyJywgWzg2NjVdXSwgWydzd2Fycm93JywgWzg2MDFdXSwgWydzd253YXInLCBbMTA1MzhdXSwgWydzemxpZycsIFsyMjNdXSwgWydUYWInLCBbOV1dLCBbJ3RhcmdldCcsIFs4OTgyXV0sIFsnVGF1JywgWzkzMl1dLCBbJ3RhdScsIFs5NjRdXSwgWyd0YnJrJywgWzkxNDBdXSwgWydUY2Fyb24nLCBbMzU2XV0sIFsndGNhcm9uJywgWzM1N11dLCBbJ1RjZWRpbCcsIFszNTRdXSwgWyd0Y2VkaWwnLCBbMzU1XV0sIFsnVGN5JywgWzEwNThdXSwgWyd0Y3knLCBbMTA5MF1dLCBbJ3Rkb3QnLCBbODQxMV1dLCBbJ3RlbHJlYycsIFs4OTgxXV0sIFsnVGZyJywgWzEyMDA4N11dLCBbJ3RmcicsIFsxMjAxMTNdXSwgWyd0aGVyZTQnLCBbODc1Nl1dLCBbJ3RoZXJlZm9yZScsIFs4NzU2XV0sIFsnVGhlcmVmb3JlJywgWzg3NTZdXSwgWydUaGV0YScsIFs5MjBdXSwgWyd0aGV0YScsIFs5NTJdXSwgWyd0aGV0YXN5bScsIFs5NzddXSwgWyd0aGV0YXYnLCBbOTc3XV0sIFsndGhpY2thcHByb3gnLCBbODc3Nl1dLCBbJ3RoaWNrc2ltJywgWzg3NjRdXSwgWydUaGlja1NwYWNlJywgWzgyODcsIDgyMDJdXSwgWydUaGluU3BhY2UnLCBbODIwMV1dLCBbJ3RoaW5zcCcsIFs4MjAxXV0sIFsndGhrYXAnLCBbODc3Nl1dLCBbJ3Roa3NpbScsIFs4NzY0XV0sIFsnVEhPUk4nLCBbMjIyXV0sIFsndGhvcm4nLCBbMjU0XV0sIFsndGlsZGUnLCBbNzMyXV0sIFsnVGlsZGUnLCBbODc2NF1dLCBbJ1RpbGRlRXF1YWwnLCBbODc3MV1dLCBbJ1RpbGRlRnVsbEVxdWFsJywgWzg3NzNdXSwgWydUaWxkZVRpbGRlJywgWzg3NzZdXSwgWyd0aW1lc2JhcicsIFsxMDgwMV1dLCBbJ3RpbWVzYicsIFs4ODY0XV0sIFsndGltZXMnLCBbMjE1XV0sIFsndGltZXNkJywgWzEwODAwXV0sIFsndGludCcsIFs4NzQ5XV0sIFsndG9lYScsIFsxMDUzNl1dLCBbJ3RvcGJvdCcsIFs5MDE0XV0sIFsndG9wY2lyJywgWzEwOTkzXV0sIFsndG9wJywgWzg4NjhdXSwgWydUb3BmJywgWzEyMDEzOV1dLCBbJ3RvcGYnLCBbMTIwMTY1XV0sIFsndG9wZm9yaycsIFsxMDk3MF1dLCBbJ3Rvc2EnLCBbMTA1MzddXSwgWyd0cHJpbWUnLCBbODI0NF1dLCBbJ3RyYWRlJywgWzg0ODJdXSwgWydUUkFERScsIFs4NDgyXV0sIFsndHJpYW5nbGUnLCBbOTY1M11dLCBbJ3RyaWFuZ2xlZG93bicsIFs5NjYzXV0sIFsndHJpYW5nbGVsZWZ0JywgWzk2NjddXSwgWyd0cmlhbmdsZWxlZnRlcScsIFs4ODg0XV0sIFsndHJpYW5nbGVxJywgWzg3OTZdXSwgWyd0cmlhbmdsZXJpZ2h0JywgWzk2NTddXSwgWyd0cmlhbmdsZXJpZ2h0ZXEnLCBbODg4NV1dLCBbJ3RyaWRvdCcsIFs5NzA4XV0sIFsndHJpZScsIFs4Nzk2XV0sIFsndHJpbWludXMnLCBbMTA4MTBdXSwgWydUcmlwbGVEb3QnLCBbODQxMV1dLCBbJ3RyaXBsdXMnLCBbMTA4MDldXSwgWyd0cmlzYicsIFsxMDcwMV1dLCBbJ3RyaXRpbWUnLCBbMTA4MTFdXSwgWyd0cnBleml1bScsIFs5MTg2XV0sIFsnVHNjcicsIFsxMTk5ODNdXSwgWyd0c2NyJywgWzEyMDAwOV1dLCBbJ1RTY3knLCBbMTA2Ml1dLCBbJ3RzY3knLCBbMTA5NF1dLCBbJ1RTSGN5JywgWzEwMzVdXSwgWyd0c2hjeScsIFsxMTE1XV0sIFsnVHN0cm9rJywgWzM1OF1dLCBbJ3RzdHJvaycsIFszNTldXSwgWyd0d2l4dCcsIFs4ODEyXV0sIFsndHdvaGVhZGxlZnRhcnJvdycsIFs4NjA2XV0sIFsndHdvaGVhZHJpZ2h0YXJyb3cnLCBbODYwOF1dLCBbJ1VhY3V0ZScsIFsyMThdXSwgWyd1YWN1dGUnLCBbMjUwXV0sIFsndWFycicsIFs4NTkzXV0sIFsnVWFycicsIFs4NjA3XV0sIFsndUFycicsIFs4NjU3XV0sIFsnVWFycm9jaXInLCBbMTA1NjldXSwgWydVYnJjeScsIFsxMDM4XV0sIFsndWJyY3knLCBbMTExOF1dLCBbJ1VicmV2ZScsIFszNjRdXSwgWyd1YnJldmUnLCBbMzY1XV0sIFsnVWNpcmMnLCBbMjE5XV0sIFsndWNpcmMnLCBbMjUxXV0sIFsnVWN5JywgWzEwNTldXSwgWyd1Y3knLCBbMTA5MV1dLCBbJ3VkYXJyJywgWzg2NDVdXSwgWydVZGJsYWMnLCBbMzY4XV0sIFsndWRibGFjJywgWzM2OV1dLCBbJ3VkaGFyJywgWzEwNjA2XV0sIFsndWZpc2h0JywgWzEwNjIyXV0sIFsnVWZyJywgWzEyMDA4OF1dLCBbJ3VmcicsIFsxMjAxMTRdXSwgWydVZ3JhdmUnLCBbMjE3XV0sIFsndWdyYXZlJywgWzI0OV1dLCBbJ3VIYXInLCBbMTA1OTVdXSwgWyd1aGFybCcsIFs4NjM5XV0sIFsndWhhcnInLCBbODYzOF1dLCBbJ3VoYmxrJywgWzk2MDBdXSwgWyd1bGNvcm4nLCBbODk4OF1dLCBbJ3VsY29ybmVyJywgWzg5ODhdXSwgWyd1bGNyb3AnLCBbODk3NV1dLCBbJ3VsdHJpJywgWzk3MjBdXSwgWydVbWFjcicsIFszNjJdXSwgWyd1bWFjcicsIFszNjNdXSwgWyd1bWwnLCBbMTY4XV0sIFsnVW5kZXJCYXInLCBbOTVdXSwgWydVbmRlckJyYWNlJywgWzkxODNdXSwgWydVbmRlckJyYWNrZXQnLCBbOTE0MV1dLCBbJ1VuZGVyUGFyZW50aGVzaXMnLCBbOTE4MV1dLCBbJ1VuaW9uJywgWzg4OTldXSwgWydVbmlvblBsdXMnLCBbODg0Nl1dLCBbJ1VvZ29uJywgWzM3MF1dLCBbJ3VvZ29uJywgWzM3MV1dLCBbJ1VvcGYnLCBbMTIwMTQwXV0sIFsndW9wZicsIFsxMjAxNjZdXSwgWydVcEFycm93QmFyJywgWzEwNTE0XV0sIFsndXBhcnJvdycsIFs4NTkzXV0sIFsnVXBBcnJvdycsIFs4NTkzXV0sIFsnVXBhcnJvdycsIFs4NjU3XV0sIFsnVXBBcnJvd0Rvd25BcnJvdycsIFs4NjQ1XV0sIFsndXBkb3duYXJyb3cnLCBbODU5N11dLCBbJ1VwRG93bkFycm93JywgWzg1OTddXSwgWydVcGRvd25hcnJvdycsIFs4NjYxXV0sIFsnVXBFcXVpbGlicml1bScsIFsxMDYwNl1dLCBbJ3VwaGFycG9vbmxlZnQnLCBbODYzOV1dLCBbJ3VwaGFycG9vbnJpZ2h0JywgWzg2MzhdXSwgWyd1cGx1cycsIFs4ODQ2XV0sIFsnVXBwZXJMZWZ0QXJyb3cnLCBbODU5OF1dLCBbJ1VwcGVyUmlnaHRBcnJvdycsIFs4NTk5XV0sIFsndXBzaScsIFs5NjVdXSwgWydVcHNpJywgWzk3OF1dLCBbJ3Vwc2loJywgWzk3OF1dLCBbJ1Vwc2lsb24nLCBbOTMzXV0sIFsndXBzaWxvbicsIFs5NjVdXSwgWydVcFRlZUFycm93JywgWzg2MTNdXSwgWydVcFRlZScsIFs4ODY5XV0sIFsndXB1cGFycm93cycsIFs4NjQ4XV0sIFsndXJjb3JuJywgWzg5ODldXSwgWyd1cmNvcm5lcicsIFs4OTg5XV0sIFsndXJjcm9wJywgWzg5NzRdXSwgWydVcmluZycsIFszNjZdXSwgWyd1cmluZycsIFszNjddXSwgWyd1cnRyaScsIFs5NzIxXV0sIFsnVXNjcicsIFsxMTk5ODRdXSwgWyd1c2NyJywgWzEyMDAxMF1dLCBbJ3V0ZG90JywgWzg5NDRdXSwgWydVdGlsZGUnLCBbMzYwXV0sIFsndXRpbGRlJywgWzM2MV1dLCBbJ3V0cmknLCBbOTY1M11dLCBbJ3V0cmlmJywgWzk2NTJdXSwgWyd1dWFycicsIFs4NjQ4XV0sIFsnVXVtbCcsIFsyMjBdXSwgWyd1dW1sJywgWzI1Ml1dLCBbJ3V3YW5nbGUnLCBbMTA2NjNdXSwgWyd2YW5ncnQnLCBbMTA2NTJdXSwgWyd2YXJlcHNpbG9uJywgWzEwMTNdXSwgWyd2YXJrYXBwYScsIFsxMDA4XV0sIFsndmFybm90aGluZycsIFs4NzA5XV0sIFsndmFycGhpJywgWzk4MV1dLCBbJ3ZhcnBpJywgWzk4Ml1dLCBbJ3ZhcnByb3B0bycsIFs4NzMzXV0sIFsndmFycicsIFs4NTk3XV0sIFsndkFycicsIFs4NjYxXV0sIFsndmFycmhvJywgWzEwMDldXSwgWyd2YXJzaWdtYScsIFs5NjJdXSwgWyd2YXJzdWJzZXRuZXEnLCBbODg0MiwgNjUwMjRdXSwgWyd2YXJzdWJzZXRuZXFxJywgWzEwOTU1LCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcScsIFs4ODQzLCA2NTAyNF1dLCBbJ3ZhcnN1cHNldG5lcXEnLCBbMTA5NTYsIDY1MDI0XV0sIFsndmFydGhldGEnLCBbOTc3XV0sIFsndmFydHJpYW5nbGVsZWZ0JywgWzg4ODJdXSwgWyd2YXJ0cmlhbmdsZXJpZ2h0JywgWzg4ODNdXSwgWyd2QmFyJywgWzEwOTg0XV0sIFsnVmJhcicsIFsxMDk4N11dLCBbJ3ZCYXJ2JywgWzEwOTg1XV0sIFsnVmN5JywgWzEwNDJdXSwgWyd2Y3knLCBbMTA3NF1dLCBbJ3ZkYXNoJywgWzg4NjZdXSwgWyd2RGFzaCcsIFs4ODcyXV0sIFsnVmRhc2gnLCBbODg3M11dLCBbJ1ZEYXNoJywgWzg4NzVdXSwgWydWZGFzaGwnLCBbMTA5ODJdXSwgWyd2ZWViYXInLCBbODg5MV1dLCBbJ3ZlZScsIFs4NzQ0XV0sIFsnVmVlJywgWzg4OTddXSwgWyd2ZWVlcScsIFs4Nzk0XV0sIFsndmVsbGlwJywgWzg5NDJdXSwgWyd2ZXJiYXInLCBbMTI0XV0sIFsnVmVyYmFyJywgWzgyMTRdXSwgWyd2ZXJ0JywgWzEyNF1dLCBbJ1ZlcnQnLCBbODIxNF1dLCBbJ1ZlcnRpY2FsQmFyJywgWzg3MzldXSwgWydWZXJ0aWNhbExpbmUnLCBbMTI0XV0sIFsnVmVydGljYWxTZXBhcmF0b3InLCBbMTAwNzJdXSwgWydWZXJ0aWNhbFRpbGRlJywgWzg3NjhdXSwgWydWZXJ5VGhpblNwYWNlJywgWzgyMDJdXSwgWydWZnInLCBbMTIwMDg5XV0sIFsndmZyJywgWzEyMDExNV1dLCBbJ3ZsdHJpJywgWzg4ODJdXSwgWyd2bnN1YicsIFs4ODM0LCA4NDAyXV0sIFsndm5zdXAnLCBbODgzNSwgODQwMl1dLCBbJ1ZvcGYnLCBbMTIwMTQxXV0sIFsndm9wZicsIFsxMjAxNjddXSwgWyd2cHJvcCcsIFs4NzMzXV0sIFsndnJ0cmknLCBbODg4M11dLCBbJ1ZzY3InLCBbMTE5OTg1XV0sIFsndnNjcicsIFsxMjAwMTFdXSwgWyd2c3VibkUnLCBbMTA5NTUsIDY1MDI0XV0sIFsndnN1Ym5lJywgWzg4NDIsIDY1MDI0XV0sIFsndnN1cG5FJywgWzEwOTU2LCA2NTAyNF1dLCBbJ3ZzdXBuZScsIFs4ODQzLCA2NTAyNF1dLCBbJ1Z2ZGFzaCcsIFs4ODc0XV0sIFsndnppZ3phZycsIFsxMDY1MF1dLCBbJ1djaXJjJywgWzM3Ml1dLCBbJ3djaXJjJywgWzM3M11dLCBbJ3dlZGJhcicsIFsxMDg0N11dLCBbJ3dlZGdlJywgWzg3NDNdXSwgWydXZWRnZScsIFs4ODk2XV0sIFsnd2VkZ2VxJywgWzg3OTNdXSwgWyd3ZWllcnAnLCBbODQ3Ml1dLCBbJ1dmcicsIFsxMjAwOTBdXSwgWyd3ZnInLCBbMTIwMTE2XV0sIFsnV29wZicsIFsxMjAxNDJdXSwgWyd3b3BmJywgWzEyMDE2OF1dLCBbJ3dwJywgWzg0NzJdXSwgWyd3cicsIFs4NzY4XV0sIFsnd3JlYXRoJywgWzg3NjhdXSwgWydXc2NyJywgWzExOTk4Nl1dLCBbJ3dzY3InLCBbMTIwMDEyXV0sIFsneGNhcCcsIFs4ODk4XV0sIFsneGNpcmMnLCBbOTcxMV1dLCBbJ3hjdXAnLCBbODg5OV1dLCBbJ3hkdHJpJywgWzk2NjFdXSwgWydYZnInLCBbMTIwMDkxXV0sIFsneGZyJywgWzEyMDExN11dLCBbJ3hoYXJyJywgWzEwMjMxXV0sIFsneGhBcnInLCBbMTAyMzRdXSwgWydYaScsIFs5MjZdXSwgWyd4aScsIFs5NThdXSwgWyd4bGFycicsIFsxMDIyOV1dLCBbJ3hsQXJyJywgWzEwMjMyXV0sIFsneG1hcCcsIFsxMDIzNl1dLCBbJ3huaXMnLCBbODk1NV1dLCBbJ3hvZG90JywgWzEwNzUyXV0sIFsnWG9wZicsIFsxMjAxNDNdXSwgWyd4b3BmJywgWzEyMDE2OV1dLCBbJ3hvcGx1cycsIFsxMDc1M11dLCBbJ3hvdGltZScsIFsxMDc1NF1dLCBbJ3hyYXJyJywgWzEwMjMwXV0sIFsneHJBcnInLCBbMTAyMzNdXSwgWydYc2NyJywgWzExOTk4N11dLCBbJ3hzY3InLCBbMTIwMDEzXV0sIFsneHNxY3VwJywgWzEwNzU4XV0sIFsneHVwbHVzJywgWzEwNzU2XV0sIFsneHV0cmknLCBbOTY1MV1dLCBbJ3h2ZWUnLCBbODg5N11dLCBbJ3h3ZWRnZScsIFs4ODk2XV0sIFsnWWFjdXRlJywgWzIyMV1dLCBbJ3lhY3V0ZScsIFsyNTNdXSwgWydZQWN5JywgWzEwNzFdXSwgWyd5YWN5JywgWzExMDNdXSwgWydZY2lyYycsIFszNzRdXSwgWyd5Y2lyYycsIFszNzVdXSwgWydZY3knLCBbMTA2N11dLCBbJ3ljeScsIFsxMDk5XV0sIFsneWVuJywgWzE2NV1dLCBbJ1lmcicsIFsxMjAwOTJdXSwgWyd5ZnInLCBbMTIwMTE4XV0sIFsnWUljeScsIFsxMDMxXV0sIFsneWljeScsIFsxMTExXV0sIFsnWW9wZicsIFsxMjAxNDRdXSwgWyd5b3BmJywgWzEyMDE3MF1dLCBbJ1lzY3InLCBbMTE5OTg4XV0sIFsneXNjcicsIFsxMjAwMTRdXSwgWydZVWN5JywgWzEwNzBdXSwgWyd5dWN5JywgWzExMDJdXSwgWyd5dW1sJywgWzI1NV1dLCBbJ1l1bWwnLCBbMzc2XV0sIFsnWmFjdXRlJywgWzM3N11dLCBbJ3phY3V0ZScsIFszNzhdXSwgWydaY2Fyb24nLCBbMzgxXV0sIFsnemNhcm9uJywgWzM4Ml1dLCBbJ1pjeScsIFsxMDQ3XV0sIFsnemN5JywgWzEwNzldXSwgWydaZG90JywgWzM3OV1dLCBbJ3pkb3QnLCBbMzgwXV0sIFsnemVldHJmJywgWzg0ODhdXSwgWydaZXJvV2lkdGhTcGFjZScsIFs4MjAzXV0sIFsnWmV0YScsIFs5MThdXSwgWyd6ZXRhJywgWzk1MF1dLCBbJ3pmcicsIFsxMjAxMTldXSwgWydaZnInLCBbODQ4OF1dLCBbJ1pIY3knLCBbMTA0Nl1dLCBbJ3poY3knLCBbMTA3OF1dLCBbJ3ppZ3JhcnInLCBbODY2OV1dLCBbJ3pvcGYnLCBbMTIwMTcxXV0sIFsnWm9wZicsIFs4NDg0XV0sIFsnWnNjcicsIFsxMTk5ODldXSwgWyd6c2NyJywgWzEyMDAxNV1dLCBbJ3p3aicsIFs4MjA1XV0sIFsnenduaicsIFs4MjA0XV1dO1xuXG52YXIgYWxwaGFJbmRleCA9IHt9O1xudmFyIGNoYXJJbmRleCA9IHt9O1xuXG5jcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEh0bWw1RW50aXRpZXMoKSB7fVxuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC8mKCM/W1xcd1xcZF0rKTs/L2csIGZ1bmN0aW9uKHMsIGVudGl0eSkge1xuICAgICAgICB2YXIgY2hyO1xuICAgICAgICBpZiAoZW50aXR5LmNoYXJBdCgwKSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gZW50aXR5LmNoYXJBdCgxKSA9PT0gJ3gnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludChlbnRpdHkuc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCksIDE2KSA6XG4gICAgICAgICAgICAgICAgcGFyc2VJbnQoZW50aXR5LnN1YnN0cigxKSk7XG5cbiAgICAgICAgICAgIGlmICghKGlzTmFOKGNvZGUpIHx8IGNvZGUgPCAtMzI3NjggfHwgY29kZSA+IDY1NTM1KSkge1xuICAgICAgICAgICAgICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIgPSBhbHBoYUluZGV4W2VudGl0eV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNociB8fCBzO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5kZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICByZXR1cm4gbmV3IEh0bWw1RW50aXRpZXMoKS5kZWNvZGUoc3RyKTtcbiB9O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbkh0bWw1RW50aXRpZXMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIGlmICghc3RyIHx8ICFzdHIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgdmFyIHN0ckxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ckxlbmd0aCkge1xuICAgICAgICB2YXIgY2hhckluZm8gPSBjaGFySW5kZXhbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuIEh0bWw1RW50aXRpZXMuZW5jb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgcmV0dXJuIG5ldyBIdG1sNUVudGl0aWVzKCkuZW5jb2RlKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5IdG1sNUVudGl0aWVzLnByb3RvdHlwZS5lbmNvZGVOb25VVEYgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgdmFyIGNoYXJJbmZvID0gY2hhckluZGV4W2NdO1xuICAgICAgICBpZiAoY2hhckluZm8pIHtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IGNoYXJJbmZvW3N0ci5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgICAgICBpZiAoYWxwaGEpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFscGhhID0gY2hhckluZm9bJyddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFscGhhKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiJlwiICsgYWxwaGEgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAzMiB8fCBjID4gMTI2KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbiBIdG1sNUVudGl0aWVzLmVuY29kZU5vblVURiA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vblVURihzdHIpO1xuIH07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuSHRtbDVFbnRpdGllcy5wcm90b3R5cGUuZW5jb2RlTm9uQVNDSUkgPSBmdW5jdGlvbihzdHIpIHtcbiAgICBpZiAoIXN0ciB8fCAhc3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBzdHJMZW5ndGggPSBzdHIubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBzdHJMZW5ndGgpIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPD0gMjU1KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gc3RyW2krK107XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJyYjJyArIGMgKyAnOyc7XG4gICAgICAgIGkrK1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG4gSHRtbDVFbnRpdGllcy5lbmNvZGVOb25BU0NJSSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHJldHVybiBuZXcgSHRtbDVFbnRpdGllcygpLmVuY29kZU5vbkFTQ0lJKHN0cik7XG4gfTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gYWxwaGFJbmRleCBQYXNzZWQgYnkgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtPYmplY3R9IGNoYXJJbmRleCBQYXNzZWQgYnkgcmVmZXJlbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJbmRleGVzKGFscGhhSW5kZXgsIGNoYXJJbmRleCkge1xuICAgIHZhciBpID0gRU5USVRJRVMubGVuZ3RoO1xuICAgIHZhciBfcmVzdWx0cyA9IFtdO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIGUgPSBFTlRJVElFU1tpXTtcbiAgICAgICAgdmFyIGFscGhhID0gZVswXTtcbiAgICAgICAgdmFyIGNoYXJzID0gZVsxXTtcbiAgICAgICAgdmFyIGNociA9IGNoYXJzWzBdO1xuICAgICAgICB2YXIgYWRkQ2hhciA9IChjaHIgPCAzMiB8fCBjaHIgPiAxMjYpIHx8IGNociA9PT0gNjIgfHwgY2hyID09PSA2MCB8fCBjaHIgPT09IDM4IHx8IGNociA9PT0gMzQgfHwgY2hyID09PSAzOTtcbiAgICAgICAgdmFyIGNoYXJJbmZvO1xuICAgICAgICBpZiAoYWRkQ2hhcikge1xuICAgICAgICAgICAgY2hhckluZm8gPSBjaGFySW5kZXhbY2hyXSA9IGNoYXJJbmRleFtjaHJdIHx8IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyc1sxXSkge1xuICAgICAgICAgICAgdmFyIGNocjIgPSBjaGFyc1sxXTtcbiAgICAgICAgICAgIGFscGhhSW5kZXhbYWxwaGFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIpICsgU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkQ2hhciAmJiAoY2hhckluZm9bY2hyMl0gPSBhbHBoYSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxwaGFJbmRleFthbHBoYV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGFkZENoYXIgJiYgKGNoYXJJbmZvWycnXSA9IGFscGhhKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSHRtbDVFbnRpdGllcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZyA9IHJlcXVpcmUoJ2xvZ2xldmVsJykuZ2V0TG9nZ2VyKCd3ZWJwYWNrLWRldi1zZXJ2ZXInKTtcblxudmFyIElORk8gPSAnaW5mbyc7XG52YXIgV0FSTiA9ICd3YXJuJztcbnZhciBFUlJPUiA9ICdlcnJvcic7XG52YXIgREVCVUcgPSAnZGVidWcnO1xudmFyIFRSQUNFID0gJ3RyYWNlJztcbnZhciBTSUxFTlQgPSAnc2lsZW50JzsgLy8gZGVwcmVjYXRlZFxuLy8gVE9ETzogcmVtb3ZlIHRoZXNlIGF0IG1ham9yIHJlbGVhc2VkXG4vLyBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8xODI1XG5cbnZhciBXQVJOSU5HID0gJ3dhcm5pbmcnO1xudmFyIE5PTkUgPSAnbm9uZSc7IC8vIFNldCB0aGUgZGVmYXVsdCBsb2cgbGV2ZWxcblxubG9nLnNldERlZmF1bHRMZXZlbChJTkZPKTtcblxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwpIHtcbiAgc3dpdGNoIChsZXZlbCkge1xuICAgIGNhc2UgSU5GTzpcbiAgICBjYXNlIFdBUk46XG4gICAgY2FzZSBFUlJPUjpcbiAgICBjYXNlIERFQlVHOlxuICAgIGNhc2UgVFJBQ0U6XG4gICAgICBsb2cuc2V0TGV2ZWwobGV2ZWwpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gZGVwcmVjYXRlZFxuXG4gICAgY2FzZSBXQVJOSU5HOlxuICAgICAgLy8gbG9nbGV2ZWwncyB3YXJuaW5nIG5hbWUgaXMgZGlmZmVyZW50IGZyb20gd2VicGFjaydzXG4gICAgICBsb2cuc2V0TGV2ZWwoJ3dhcm4nKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIGRlcHJlY2F0ZWRcblxuICAgIGNhc2UgTk9ORTpcbiAgICBjYXNlIFNJTEVOVDpcbiAgICAgIGxvZy5kaXNhYmxlQWxsKCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBsb2cuZXJyb3IoXCJbV0RTXSBVbmtub3duIGNsaWVudExvZ0xldmVsICdcIi5jb25jYXQobGV2ZWwsIFwiJ1wiKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxvZzogbG9nLFxuICBzZXRMb2dMZXZlbDogc2V0TG9nTGV2ZWxcbn07IiwiLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoZGVmaW5pdGlvbik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vIFNsaWdodGx5IGR1YmlvdXMgdHJpY2tzIHRvIGN1dCBkb3duIG1pbmltaXplZCBmaWxlIHNpemVcbiAgICB2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIHVuZGVmaW5lZFR5cGUgPSBcInVuZGVmaW5lZFwiO1xuICAgIHZhciBpc0lFID0gKHR5cGVvZiB3aW5kb3cgIT09IHVuZGVmaW5lZFR5cGUpICYmIChcbiAgICAgICAgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKTtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBzdG9yYWdlS2V5ICs9IFwiOlwiICsgbmFtZTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbE51bSkge1xuICAgICAgICAgIHZhciBsZXZlbE5hbWUgPSAobG9nTWV0aG9kc1tsZXZlbE51bV0gfHwgJ3NpbGVudCcpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldFBlcnNpc3RlZExldmVsKCkge1xuICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDtcblxuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vbc3RvcmFnZUtleV07XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gRmFsbGJhY2sgdG8gY29va2llcyBpZiBsb2NhbCBzdG9yYWdlIGdpdmVzIHVzIG5vdGhpbmdcbiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY29va2llID0gd2luZG93LmRvY3VtZW50LmNvb2tpZTtcbiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKFxuICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IC9eKFteO10rKS8uZXhlYyhjb29raWUuc2xpY2UobG9jYXRpb24pKVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHRoZSBzdG9yZWQgbGV2ZWwgaXMgbm90IHZhbGlkLCB0cmVhdCBpdCBhcyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG4gICAgICAgICAgaWYgKHNlbGYubGV2ZWxzW3N0b3JlZExldmVsXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAqXG4gICAgICAgKi9cblxuICAgICAgc2VsZi5uYW1lID0gbmFtZTtcblxuICAgICAgc2VsZi5sZXZlbHMgPSB7IFwiVFJBQ0VcIjogMCwgXCJERUJVR1wiOiAxLCBcIklORk9cIjogMiwgXCJXQVJOXCI6IDMsXG4gICAgICAgICAgXCJFUlJPUlwiOiA0LCBcIlNJTEVOVFwiOiA1fTtcblxuICAgICAgc2VsZi5tZXRob2RGYWN0b3J5ID0gZmFjdG9yeSB8fCBkZWZhdWx0TWV0aG9kRmFjdG9yeTtcblxuICAgICAgc2VsZi5nZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudExldmVsO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXRMZXZlbCA9IGZ1bmN0aW9uIChsZXZlbCwgcGVyc2lzdCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwic3RyaW5nXCIgJiYgc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgICAgICAgICAgIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGxldmVsO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgaWYgKCFnZXRQZXJzaXN0ZWRMZXZlbCgpKSB7XG4gICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlRSQUNFLCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uKHBlcnNpc3QpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsXG4gICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIGlmIChpbml0aWFsTGV2ZWwgPT0gbnVsbCkge1xuICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gXCJXQVJOXCIgOiBkZWZhdWx0TGV2ZWw7XG4gICAgICB9XG4gICAgICBzZWxmLnNldExldmVsKGluaXRpYWxMZXZlbCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICpcbiAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICpcbiAgICAgKi9cblxuICAgIHZhciBkZWZhdWx0TG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuXG4gICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgZGVmYXVsdExvZ2dlci5nZXRMb2dnZXIgPSBmdW5jdGlvbiBnZXRMb2dnZXIobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xufSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIF9fcmVzb3VyY2VRdWVyeSBXb3JrZXJHbG9iYWxTY29wZSBzZWxmICovXG4vLyBTZW5kIG1lc3NhZ2VzIHRvIHRoZSBvdXRzaWRlLCBzbyBwbHVnaW5zIGNhbiBjb25zdW1lIGl0LlxuXG5mdW5jdGlvbiBzZW5kTXNnKHR5cGUsIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJyB8fCAhKHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSkpKSB7XG4gICAgc2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICB0eXBlOiBcIndlYnBhY2tcIi5jb25jYXQodHlwZSksXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSwgJyonKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNlbmRNc2c7IiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIFdvcmtlckdsb2JhbFNjb3BlIHNlbGYgKi9cblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9sb2cnKSxcbiAgICBsb2cgPSBfcmVxdWlyZS5sb2c7XG5cbmZ1bmN0aW9uIHJlbG9hZEFwcChfcmVmLCBfcmVmMikge1xuICB2YXIgaG90UmVsb2FkID0gX3JlZi5ob3RSZWxvYWQsXG4gICAgICBob3QgPSBfcmVmLmhvdCxcbiAgICAgIGxpdmVSZWxvYWQgPSBfcmVmLmxpdmVSZWxvYWQ7XG4gIHZhciBpc1VubG9hZGluZyA9IF9yZWYyLmlzVW5sb2FkaW5nLFxuICAgICAgY3VycmVudEhhc2ggPSBfcmVmMi5jdXJyZW50SGFzaDtcblxuICBpZiAoaXNVbmxvYWRpbmcgfHwgIWhvdFJlbG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChob3QpIHtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIGhvdCB1cGRhdGUuLi4nKTtcblxuICAgIHZhciBob3RFbWl0dGVyID0gcmVxdWlyZSgnd2VicGFjay9ob3QvZW1pdHRlcicpO1xuXG4gICAgaG90RW1pdHRlci5lbWl0KCd3ZWJwYWNrSG90VXBkYXRlJywgY3VycmVudEhhc2gpO1xuXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdykge1xuICAgICAgLy8gYnJvYWRjYXN0IHVwZGF0ZSB0byB3aW5kb3dcbiAgICAgIHNlbGYucG9zdE1lc3NhZ2UoXCJ3ZWJwYWNrSG90VXBkYXRlXCIuY29uY2F0KGN1cnJlbnRIYXNoKSwgJyonKTtcbiAgICB9XG4gIH0gLy8gYWxsb3cgcmVmcmVzaGluZyB0aGUgcGFnZSBvbmx5IGlmIGxpdmVSZWxvYWQgaXNuJ3QgZGlzYWJsZWRcbiAgZWxzZSBpZiAobGl2ZVJlbG9hZCkge1xuICAgICAgdmFyIHJvb3RXaW5kb3cgPSBzZWxmOyAvLyB1c2UgcGFyZW50IHdpbmRvdyBmb3IgcmVsb2FkIChpbiBjYXNlIHdlJ3JlIGluIGFuIGlmcmFtZSB3aXRoIG5vIHZhbGlkIHNyYylcblxuICAgICAgdmFyIGludGVydmFsSWQgPSBzZWxmLnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHJvb3RXaW5kb3cubG9jYXRpb24ucHJvdG9jb2wgIT09ICdhYm91dDonKSB7XG4gICAgICAgICAgLy8gcmVsb2FkIGltbWVkaWF0ZWx5IGlmIHByb3RvY29sIGlzIHZhbGlkXG4gICAgICAgICAgYXBwbHlSZWxvYWQocm9vdFdpbmRvdywgaW50ZXJ2YWxJZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vdFdpbmRvdyA9IHJvb3RXaW5kb3cucGFyZW50O1xuXG4gICAgICAgICAgaWYgKHJvb3RXaW5kb3cucGFyZW50ID09PSByb290V2luZG93KSB7XG4gICAgICAgICAgICAvLyBpZiBwYXJlbnQgZXF1YWxzIGN1cnJlbnQgd2luZG93IHdlJ3ZlIHJlYWNoZWQgdGhlIHJvb3Qgd2hpY2ggd291bGQgY29udGludWUgZm9yZXZlciwgc28gdHJpZ2dlciBhIHJlbG9hZCBhbnl3YXlzXG4gICAgICAgICAgICBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICBmdW5jdGlvbiBhcHBseVJlbG9hZChyb290V2luZG93LCBpbnRlcnZhbElkKSB7XG4gICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICBsb2cuaW5mbygnW1dEU10gQXBwIHVwZGF0ZWQuIFJlbG9hZGluZy4uLicpO1xuICAgIHJvb3RXaW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZWxvYWRBcHA7IiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZ2xvYmFsIHNlbGYgKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG52YXIgZ2V0Q3VycmVudFNjcmlwdFNvdXJjZSA9IHJlcXVpcmUoJy4vZ2V0Q3VycmVudFNjcmlwdFNvdXJjZScpO1xuXG5mdW5jdGlvbiBjcmVhdGVTb2NrZXRVcmwocmVzb3VyY2VRdWVyeSwgY3VycmVudExvY2F0aW9uKSB7XG4gIHZhciB1cmxQYXJ0cztcblxuICBpZiAodHlwZW9mIHJlc291cmNlUXVlcnkgPT09ICdzdHJpbmcnICYmIHJlc291cmNlUXVlcnkgIT09ICcnKSB7XG4gICAgLy8gSWYgdGhpcyBidW5kbGUgaXMgaW5saW5lZCwgdXNlIHRoZSByZXNvdXJjZSBxdWVyeSB0byBnZXQgdGhlIGNvcnJlY3QgdXJsLlxuICAgIC8vIGZvcm1hdCBpcyBsaWtlIGA/aHR0cDovLzAuMC4wLjA6ODA5NiZzb2NrUG9ydD04MDk3JnNvY2tIb3N0PWxvY2FsaG9zdGBcbiAgICB1cmxQYXJ0cyA9IHVybC5wYXJzZShyZXNvdXJjZVF1ZXJ5IC8vIHN0cmlwIGxlYWRpbmcgYD9gIGZyb20gcXVlcnkgc3RyaW5nIHRvIGdldCBhIHZhbGlkIFVSTFxuICAgIC5zdWJzdHIoMSkgLy8gcmVwbGFjZSBmaXJzdCBgJmAgd2l0aCBgP2AgdG8gaGF2ZSBhIHZhbGlkIHF1ZXJ5IHN0cmluZ1xuICAgIC5yZXBsYWNlKCcmJywgJz8nKSwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRWxzZSwgZ2V0IHRoZSB1cmwgZnJvbSB0aGUgPHNjcmlwdD4gdGhpcyBmaWxlIHdhcyBjYWxsZWQgd2l0aC5cbiAgICB2YXIgc2NyaXB0SG9zdCA9IGdldEN1cnJlbnRTY3JpcHRTb3VyY2UoKTtcbiAgICB1cmxQYXJ0cyA9IHVybC5wYXJzZShzY3JpcHRIb3N0IHx8ICcvJywgdHJ1ZSwgdHJ1ZSk7XG4gIH0gLy8gVXNlIHBhcmFtZXRlciB0byBhbGxvdyBwYXNzaW5nIGxvY2F0aW9uIGluIHVuaXQgdGVzdHNcblxuXG4gIGlmICh0eXBlb2YgY3VycmVudExvY2F0aW9uID09PSAnc3RyaW5nJyAmJiBjdXJyZW50TG9jYXRpb24gIT09ICcnKSB7XG4gICAgY3VycmVudExvY2F0aW9uID0gdXJsLnBhcnNlKGN1cnJlbnRMb2NhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgY3VycmVudExvY2F0aW9uID0gc2VsZi5sb2NhdGlvbjtcbiAgfVxuXG4gIHJldHVybiBnZXRTb2NrZXRVcmwodXJsUGFydHMsIGN1cnJlbnRMb2NhdGlvbik7XG59XG4vKlxuICogR2V0cyBzb2NrZXQgVVJMIGJhc2VkIG9uIFNjcmlwdCBTb3VyY2UvTG9jYXRpb25cbiAqIChzY3JpcHRTcmM6IFVSTCwgbG9jYXRpb246IFVSTCkgLT4gVVJMXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRTb2NrZXRVcmwodXJsUGFydHMsIGxvYykge1xuICB2YXIgYXV0aCA9IHVybFBhcnRzLmF1dGgsXG4gICAgICBxdWVyeSA9IHVybFBhcnRzLnF1ZXJ5O1xuICB2YXIgaG9zdG5hbWUgPSB1cmxQYXJ0cy5ob3N0bmFtZSxcbiAgICAgIHByb3RvY29sID0gdXJsUGFydHMucHJvdG9jb2wsXG4gICAgICBwb3J0ID0gdXJsUGFydHMucG9ydDtcblxuICBpZiAoIXBvcnQgfHwgcG9ydCA9PT0gJzAnKSB7XG4gICAgcG9ydCA9IGxvYy5wb3J0O1xuICB9IC8vIGNoZWNrIGlwdjQgYW5kIGlwdjYgYGFsbCBob3N0bmFtZWBcbiAgLy8gd2h5IGRvIHdlIG5lZWQgdGhpcyBjaGVjaz9cbiAgLy8gaG9zdG5hbWUgbi9hIGZvciBmaWxlIHByb3RvY29sIChleGFtcGxlLCB3aGVuIHVzaW5nIGVsZWN0cm9uLCBpb25pYylcbiAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay93ZWJwYWNrLWRldi1zZXJ2ZXIvcHVsbC8zODRcblxuXG4gIGlmICgoaG9zdG5hbWUgPT09ICcwLjAuMC4wJyB8fCBob3N0bmFtZSA9PT0gJzo6JykgJiYgbG9jLmhvc3RuYW1lICYmIGxvYy5wcm90b2NvbC5pbmRleE9mKCdodHRwJykgPT09IDApIHtcbiAgICBob3N0bmFtZSA9IGxvYy5ob3N0bmFtZTtcbiAgfSAvLyBgaG9zdG5hbWVgIGNhbiBiZSBlbXB0eSB3aGVuIHRoZSBzY3JpcHQgcGF0aCBpcyByZWxhdGl2ZS4gSW4gdGhhdCBjYXNlLCBzcGVjaWZ5aW5nXG4gIC8vIGEgcHJvdG9jb2wgd291bGQgcmVzdWx0IGluIGFuIGludmFsaWQgVVJMLlxuICAvLyBXaGVuIGh0dHBzIGlzIHVzZWQgaW4gdGhlIGFwcCwgc2VjdXJlIHdlYnNvY2tldHMgYXJlIGFsd2F5cyBuZWNlc3NhcnlcbiAgLy8gYmVjYXVzZSB0aGUgYnJvd3NlciBkb2Vzbid0IGFjY2VwdCBub24tc2VjdXJlIHdlYnNvY2tldHMuXG5cblxuICBpZiAoaG9zdG5hbWUgJiYgaG9zdG5hbWUgIT09ICcxMjcuMC4wLjEnICYmIChsb2MucHJvdG9jb2wgPT09ICdodHRwczonIHx8IHVybFBhcnRzLmhvc3RuYW1lID09PSAnMC4wLjAuMCcpKSB7XG4gICAgcHJvdG9jb2wgPSBsb2MucHJvdG9jb2w7XG4gIH0gLy8gYWxsIG9mIHRoZXNlIHNvY2sgdXJsIHBhcmFtcyBhcmUgb3B0aW9uYWxseSBwYXNzZWQgaW4gdGhyb3VnaFxuICAvLyByZXNvdXJjZVF1ZXJ5LCBzbyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBpZlxuICAvLyB0aGV5IGFyZSBub3QgcHJvdmlkZWRcblxuXG4gIHZhciBzb2NrSG9zdCA9IHF1ZXJ5LnNvY2tIb3N0IHx8IGhvc3RuYW1lO1xuICB2YXIgc29ja1BhdGggPSBxdWVyeS5zb2NrUGF0aCB8fCAnL3NvY2tqcy1ub2RlJztcbiAgdmFyIHNvY2tQb3J0ID0gcXVlcnkuc29ja1BvcnQgfHwgcG9ydDtcblxuICBpZiAoc29ja1BvcnQgPT09ICdsb2NhdGlvbicpIHtcbiAgICBzb2NrUG9ydCA9IGxvYy5wb3J0O1xuICB9XG5cbiAgcmV0dXJuIHVybC5mb3JtYXQoe1xuICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICBhdXRoOiBhdXRoLFxuICAgIGhvc3RuYW1lOiBzb2NrSG9zdCxcbiAgICBwb3J0OiBzb2NrUG9ydCxcbiAgICAvLyBJZiBzb2NrUGF0aCBpcyBwcm92aWRlZCBpdCdsbCBiZSBwYXNzZWQgaW4gdmlhIHRoZSByZXNvdXJjZVF1ZXJ5IGFzIGFcbiAgICAvLyBxdWVyeSBwYXJhbSBzbyBpdCBoYXMgdG8gYmUgcGFyc2VkIG91dCBvZiB0aGUgcXVlcnlzdHJpbmcgaW4gb3JkZXIgZm9yIHRoZVxuICAgIC8vIGNsaWVudCB0byBvcGVuIHRoZSBzb2NrZXQgdG8gdGhlIGNvcnJlY3QgbG9jYXRpb24uXG4gICAgcGF0aG5hbWU6IHNvY2tQYXRoXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVNvY2tldFVybDsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuMy4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjMuMicsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG9ialtrXS5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0U291cmNlKCkge1xuICAvLyBgZG9jdW1lbnQuY3VycmVudFNjcmlwdGAgaXMgdGhlIG1vc3QgYWNjdXJhdGUgd2F5IHRvIGZpbmQgdGhlIGN1cnJlbnQgc2NyaXB0LFxuICAvLyBidXQgaXMgbm90IHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnMuXG4gIGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWxsIGJhY2sgdG8gZ2V0dGluZyBhbGwgc2NyaXB0cyBpbiB0aGUgZG9jdW1lbnQuXG5cblxuICB2YXIgc2NyaXB0RWxlbWVudHMgPSBkb2N1bWVudC5zY3JpcHRzIHx8IFtdO1xuICB2YXIgY3VycmVudFNjcmlwdCA9IHNjcmlwdEVsZW1lbnRzW3NjcmlwdEVsZW1lbnRzLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChjdXJyZW50U2NyaXB0KSB7XG4gICAgcmV0dXJuIGN1cnJlbnRTY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgfSAvLyBGYWlsIGFzIHRoZXJlIHdhcyBubyBzY3JpcHQgdG8gdXNlLlxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdbV0RTXSBGYWlsZWQgdG8gZ2V0IGN1cnJlbnQgc2NyaXB0IHNvdXJjZS4nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRDdXJyZW50U2NyaXB0U291cmNlOyIsInZhciBtYXAgPSB7XG5cdFwiLi9sb2dcIjogMzFcbn07XG5cblxuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHZhciBpZCA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpO1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG59XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8obWFwLCByZXEpKSB7XG5cdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiBtYXBbcmVxXTtcbn1cbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSAzMDsiLCJ2YXIgbG9nTGV2ZWwgPSBcImluZm9cIjtcblxuZnVuY3Rpb24gZHVtbXkoKSB7fVxuXG5mdW5jdGlvbiBzaG91bGRMb2cobGV2ZWwpIHtcblx0dmFyIHNob3VsZExvZyA9XG5cdFx0KGxvZ0xldmVsID09PSBcImluZm9cIiAmJiBsZXZlbCA9PT0gXCJpbmZvXCIpIHx8XG5cdFx0KFtcImluZm9cIiwgXCJ3YXJuaW5nXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwid2FybmluZ1wiKSB8fFxuXHRcdChbXCJpbmZvXCIsIFwid2FybmluZ1wiLCBcImVycm9yXCJdLmluZGV4T2YobG9nTGV2ZWwpID49IDAgJiYgbGV2ZWwgPT09IFwiZXJyb3JcIik7XG5cdHJldHVybiBzaG91bGRMb2c7XG59XG5cbmZ1bmN0aW9uIGxvZ0dyb3VwKGxvZ0ZuKSB7XG5cdHJldHVybiBmdW5jdGlvbihsZXZlbCwgbXNnKSB7XG5cdFx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRcdGxvZ0ZuKG1zZyk7XG5cdFx0fVxuXHR9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxldmVsLCBtc2cpIHtcblx0aWYgKHNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRpZiAobGV2ZWwgPT09IFwiaW5mb1wiKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhtc2cpO1xuXHRcdH0gZWxzZSBpZiAobGV2ZWwgPT09IFwid2FybmluZ1wiKSB7XG5cdFx0XHRjb25zb2xlLndhcm4obXNnKTtcblx0XHR9IGVsc2UgaWYgKGxldmVsID09PSBcImVycm9yXCIpIHtcblx0XHRcdGNvbnNvbGUuZXJyb3IobXNnKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tdW5zdXBwb3J0ZWQtZmVhdHVyZXMvbm9kZS1idWlsdGlucyAqL1xudmFyIGdyb3VwID0gY29uc29sZS5ncm91cCB8fCBkdW1teTtcbnZhciBncm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQgfHwgZHVtbXk7XG52YXIgZ3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kIHx8IGR1bW15O1xuLyogZXNsaW50LWVuYWJsZSBub2RlL25vLXVuc3VwcG9ydGVkLWZlYXR1cmVzL25vZGUtYnVpbHRpbnMgKi9cblxubW9kdWxlLmV4cG9ydHMuZ3JvdXAgPSBsb2dHcm91cChncm91cCk7XG5cbm1vZHVsZS5leHBvcnRzLmdyb3VwQ29sbGFwc2VkID0gbG9nR3JvdXAoZ3JvdXBDb2xsYXBzZWQpO1xuXG5tb2R1bGUuZXhwb3J0cy5ncm91cEVuZCA9IGxvZ0dyb3VwKGdyb3VwRW5kKTtcblxubW9kdWxlLmV4cG9ydHMuc2V0TG9nTGV2ZWwgPSBmdW5jdGlvbihsZXZlbCkge1xuXHRsb2dMZXZlbCA9IGxldmVsO1xufTtcblxubW9kdWxlLmV4cG9ydHMuZm9ybWF0RXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcblx0dmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcblx0dmFyIHN0YWNrID0gZXJyLnN0YWNrO1xuXHRpZiAoIXN0YWNrKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdH0gZWxzZSBpZiAoc3RhY2suaW5kZXhPZihtZXNzYWdlKSA8IDApIHtcblx0XHRyZXR1cm4gbWVzc2FnZSArIFwiXFxuXCIgKyBzdGFjaztcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gc3RhY2s7XG5cdH1cbn07XG4iLCJ2YXIgYXBpID0gcmVxdWlyZShcIiEuLi8uLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2JpbGxib2FyZC5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG52YXIgZXhwb3J0ZWQgPSBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDoge307XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydGVkOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgaXNPbGRJRSA9IGZ1bmN0aW9uIGlzT2xkSUUoKSB7XG4gIHZhciBtZW1vO1xuICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgaWYgKHR5cGVvZiBtZW1vID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW87XG4gIH07XG59KCk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiBnZXRUYXJnZXQoKSB7XG4gIHZhciBtZW1vID0ge307XG4gIHJldHVybiBmdW5jdGlvbiBtZW1vcml6ZSh0YXJnZXQpIHtcbiAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICBzdHlsZVRhcmdldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWVtb1t0YXJnZXRdID0gc3R5bGVUYXJnZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1lbW9bdGFyZ2V0XTtcbiAgfTtcbn0oKTtcblxudmFyIHN0eWxlc0luRG9tID0gW107XG5cbmZ1bmN0aW9uIGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgdmFyIHJlc3VsdCA9IC0xO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5Eb20ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5Eb21baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gIHZhciBpZENvdW50TWFwID0ge307XG4gIHZhciBpZGVudGlmaWVycyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVzSW5Eb20ucHVzaCh7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cblxuICByZXR1cm4gaWRlbnRpZmllcnM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHZhciBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09ICd1bmRlZmluZWQnID8gX193ZWJwYWNrX25vbmNlX18gOiBudWxsO1xuXG4gICAgaWYgKG5vbmNlKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5vbmNlID0gbm9uY2U7XG4gICAgfVxuICB9XG5cbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KG9wdGlvbnMuaW5zZXJ0IHx8ICdoZWFkJyk7XG5cbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpIHtcbiAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gIGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG52YXIgcmVwbGFjZVRleHQgPSBmdW5jdGlvbiByZXBsYWNlVGV4dCgpIHtcbiAgdmFyIHRleHRTdG9yZSA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24gcmVwbGFjZShpbmRleCwgcmVwbGFjZW1lbnQpIHtcbiAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gIH07XG59KCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChvYmouY3NzLCBcIn1cIikgOiBvYmouY3NzOyAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuICAgIHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuICAgIH1cblxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIG9wdGlvbnMsIG9iaikge1xuICB2YXIgY3NzID0gb2JqLmNzcztcbiAgdmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuICBpZiAobWVkaWEpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VNYXAgJiYgYnRvYSkge1xuICAgIGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIuY29uY2F0KGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSksIFwiICovXCIpO1xuICB9IC8vIEZvciBvbGQgSUVcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgICovXG5cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGUuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuXG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXIgc2luZ2xldG9uQ291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgc3R5bGU7XG4gIHZhciB1cGRhdGU7XG4gIHZhciByZW1vdmU7XG5cbiAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgdmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgc3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSk7XG4gICAgdXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG4gICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICB1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXG4gICAgcmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlKG9iaik7XG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlKG9iaiA9IG5ld09iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGlzdCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG4gIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcblxuICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gIH1cblxuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cblxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9pZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW19pXTtcblxuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcblxuICAgICAgaWYgKHN0eWxlc0luRG9tW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRvbVtfaW5kZXhdLnVwZGF0ZXIoKTtcblxuICAgICAgICBzdHlsZXNJbkRvbS5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyIsIi8vIEltcG9ydHNcbnZhciBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKTtcbmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKi0tIENoYXJ0IC0tKi9cXG4uYmIgc3ZnIHtcXG4gIGZvbnQ6IDEwcHggc2Fucy1zZXJpZjtcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTsgfVxcblxcbi5iYiBwYXRoLCAuYmIgbGluZSB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjMDAwOyB9XFxuXFxuLmJiIHRleHQsIC5iYiAuYmItYnV0dG9uIHtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4uYmItbGVnZW5kLWl0ZW0tdGlsZSxcXG4uYmIteGdyaWQtZm9jdXMsXFxuLmJiLXlncmlkLWZvY3VzLFxcbi5iYi15Z3JpZCxcXG4uYmItZXZlbnQtcmVjdCxcXG4uYmItYmFycyBwYXRoIHtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlczsgfVxcblxcbi5iYi1jaGFydC1hcmMgLmJiLWdhdWdlLXZhbHVlIHtcXG4gIGZpbGw6ICMwMDA7IH1cXG5cXG4uYmItY2hhcnQtYXJjIHBhdGgge1xcbiAgc3Ryb2tlOiAjZmZmOyB9XFxuXFxuLmJiLWNoYXJ0LWFyYyByZWN0IHtcXG4gIHN0cm9rZTogI2ZmZjtcXG4gIHN0cm9rZS13aWR0aDogMTsgfVxcblxcbi5iYi1jaGFydC1hcmMgdGV4dCB7XFxuICBmaWxsOiAjZmZmO1xcbiAgZm9udC1zaXplOiAxM3B4OyB9XFxuXFxuLyotLSBBeGlzIC0tKi9cXG4uYmItYXhpcyB7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7IH1cXG5cXG4vKi0tIEdyaWQgLS0qL1xcbi5iYi1ncmlkIGxpbmUge1xcbiAgc3Ryb2tlOiAjYWFhOyB9XFxuXFxuLmJiLWdyaWQgdGV4dCB7XFxuICBmaWxsOiAjYWFhOyB9XFxuXFxuLmJiLXhncmlkLCAuYmIteWdyaWQge1xcbiAgc3Ryb2tlLWRhc2hhcnJheTogMyAzOyB9XFxuXFxuLyotLSBUZXh0IG9uIENoYXJ0IC0tKi9cXG4uYmItdGV4dC5iYi1lbXB0eSB7XFxuICBmaWxsOiAjODA4MDgwO1xcbiAgZm9udC1zaXplOiAyZW07IH1cXG5cXG4vKi0tIExpbmUgLS0qL1xcbi5iYi1saW5lIHtcXG4gIHN0cm9rZS13aWR0aDogMXB4OyB9XFxuXFxuLyotLSBQb2ludCAtLSovXFxuLmJiLWNpcmNsZS5fZXhwYW5kZWRfIHtcXG4gIHN0cm9rZS13aWR0aDogMXB4O1xcbiAgc3Ryb2tlOiB3aGl0ZTsgfVxcblxcbi5iYi1zZWxlY3RlZC1jaXJjbGUge1xcbiAgZmlsbDogd2hpdGU7XFxuICBzdHJva2Utd2lkdGg6IDJweDsgfVxcblxcbi8qLS0gQmFyIC0tKi9cXG4uYmItYmFyIHtcXG4gIHN0cm9rZS13aWR0aDogMDsgfVxcbiAgLmJiLWJhci5fZXhwYW5kZWRfIHtcXG4gICAgZmlsbC1vcGFjaXR5OiAwLjc1OyB9XFxuXFxuLyotLSBGb2N1cyAtLSovXFxuLmJiLXRhcmdldC5iYi1mb2N1c2VkIHtcXG4gIG9wYWNpdHk6IDE7IH1cXG5cXG4uYmItdGFyZ2V0LmJiLWZvY3VzZWQgcGF0aC5iYi1saW5lLCAuYmItdGFyZ2V0LmJiLWZvY3VzZWQgcGF0aC5iYi1zdGVwIHtcXG4gIHN0cm9rZS13aWR0aDogMnB4OyB9XFxuXFxuLmJiLXRhcmdldC5iYi1kZWZvY3VzZWQge1xcbiAgb3BhY2l0eTogMC4zICFpbXBvcnRhbnQ7IH1cXG4gIC5iYi10YXJnZXQuYmItZGVmb2N1c2VkIC50ZXh0LW92ZXJsYXBwaW5nIHtcXG4gICAgb3BhY2l0eTogLjA1ICFpbXBvcnRhbnQ7IH1cXG5cXG4vKi0tIFJlZ2lvbiAtLSovXFxuLmJiLXJlZ2lvbiB7XFxuICBmaWxsOiBzdGVlbGJsdWU7XFxuICBmaWxsLW9wYWNpdHk6IC4xOyB9XFxuXFxuLyotLSBab29tIHJlZ2lvbiAtLSovXFxuLmJiLXpvb20tYnJ1c2gge1xcbiAgZmlsbC1vcGFjaXR5OiAuMTsgfVxcblxcbi8qLS0gQnJ1c2ggLS0qL1xcbi5iYi1icnVzaCAuZXh0ZW50IHtcXG4gIGZpbGwtb3BhY2l0eTogLjE7IH1cXG5cXG4vKi0tIFNlbGVjdCAtIERyYWcgLS0qL1xcbi8qLS0gTGVnZW5kIC0tKi9cXG4uYmItbGVnZW5kLWl0ZW0ge1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXG5cXG4uYmItbGVnZW5kLWl0ZW0taGlkZGVuIHtcXG4gIG9wYWNpdHk6IDAuMTU7IH1cXG5cXG4uYmItbGVnZW5kLWJhY2tncm91bmQge1xcbiAgb3BhY2l0eTogMC43NTtcXG4gIGZpbGw6IHdoaXRlO1xcbiAgc3Ryb2tlOiBsaWdodGdyYXk7XFxuICBzdHJva2Utd2lkdGg6IDE7IH1cXG5cXG4vKi0tIFRpdGxlIC0tKi9cXG4uYmItdGl0bGUge1xcbiAgZm9udDogMTRweCBzYW5zLXNlcmlmOyB9XFxuXFxuLyotLSBUb29sdGlwIC0tKi9cXG4uYmItdG9vbHRpcC1jb250YWluZXIge1xcbiAgei1pbmRleDogMTA7XFxuICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcblxcbi5iYi10b29sdGlwIHtcXG4gIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XFxuICBib3JkZXItc3BhY2luZzogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBlbXB0eS1jZWxsczogc2hvdztcXG4gIG9wYWNpdHk6IDAuOTtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NztcXG4gIC1tb3otYm94LXNoYWRvdzogN3B4IDdweCAxMnB4IC05cHggIzc3Nzc3NztcXG4gIGJveC1zaGFkb3c6IDdweCA3cHggMTJweCAtOXB4ICM3Nzc3Nzc7IH1cXG4gIC5iYi10b29sdGlwIHRyIHtcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI0NDQzsgfVxcbiAgLmJiLXRvb2x0aXAgdGgge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYWFhO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIHBhZGRpbmc6IDJweCA1cHg7XFxuICAgIHRleHQtYWxpZ246IGxlZnQ7XFxuICAgIGNvbG9yOiAjRkZGOyB9XFxuICAuYmItdG9vbHRpcCB0ZCB7XFxuICAgIGZvbnQtc2l6ZTogMTNweDtcXG4gICAgcGFkZGluZzogM3B4IDZweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBkb3R0ZWQgIzk5OTsgfVxcbiAgICAuYmItdG9vbHRpcCB0ZCA+IHNwYW4sIC5iYi10b29sdGlwIHRkID4gc3ZnIHtcXG4gICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICAgICAgd2lkdGg6IDEwcHg7XFxuICAgICAgaGVpZ2h0OiAxMHB4O1xcbiAgICAgIG1hcmdpbi1yaWdodDogNnB4OyB9XFxuICAuYmItdG9vbHRpcC52YWx1ZSB7XFxuICAgIHRleHQtYWxpZ246IHJpZ2h0OyB9XFxuXFxuLyotLSBBcmVhIC0tKi9cXG4uYmItYXJlYSB7XFxuICBzdHJva2Utd2lkdGg6IDA7XFxuICBvcGFjaXR5OiAwLjI7IH1cXG5cXG4vKi0tIEFyYyAtLSovXFxuLmJiLWNoYXJ0LWFyY3MtdGl0bGUge1xcbiAgZG9taW5hbnQtYmFzZWxpbmU6IG1pZGRsZTtcXG4gIGZvbnQtc2l6ZTogMS4zZW07IH1cXG5cXG4uYmItY2hhcnQtYXJjcy1nYXVnZS10aXRsZSB7XFxuICBkb21pbmFudC1iYXNlbGluZTogbWlkZGxlO1xcbiAgZm9udC1zaXplOiAyLjdlbTsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWJhY2tncm91bmQge1xcbiAgZmlsbDogI2UwZTBlMDtcXG4gIHN0cm9rZTogI2ZmZjsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLXVuaXQge1xcbiAgZmlsbDogIzAwMDtcXG4gIGZvbnQtc2l6ZTogMTZweDsgfVxcblxcbi5iYi1jaGFydC1hcmNzIC5iYi1jaGFydC1hcmNzLWdhdWdlLW1heCB7XFxuICBmaWxsOiAjNzc3OyB9XFxuXFxuLmJiLWNoYXJ0LWFyY3MgLmJiLWNoYXJ0LWFyY3MtZ2F1Z2UtbWluIHtcXG4gIGZpbGw6ICM3Nzc7IH1cXG5cXG4vKi0tIFJhZGFyIC0tKi9cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1sZXZlbHMgcG9seWdvbiB7XFxuICBmaWxsOiBub25lO1xcbiAgc3Ryb2tlOiAjODQ4MjgyO1xcbiAgc3Ryb2tlLXdpZHRoOiAuNXB4OyB9XFxuXFxuLmJiLWNoYXJ0LXJhZGFycyAuYmItbGV2ZWxzIHRleHQge1xcbiAgZmlsbDogIzg0ODI4MjsgfVxcblxcbi5iYi1jaGFydC1yYWRhcnMgLmJiLWF4aXMgbGluZSB7XFxuICBzdHJva2U6ICM4NDgyODI7XFxuICBzdHJva2Utd2lkdGg6IC41cHg7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1heGlzIHRleHQge1xcbiAgZm9udC1zaXplOiAxLjE1ZW07XFxuICBjdXJzb3I6IGRlZmF1bHQ7IH1cXG5cXG4uYmItY2hhcnQtcmFkYXJzIC5iYi1zaGFwZXMgcG9seWdvbiB7XFxuICBmaWxsLW9wYWNpdHk6IC4yO1xcbiAgc3Ryb2tlLXdpZHRoOiAxcHg7IH1cXG5cXG4vKi0tIEJ1dHRvbiAtLSovXFxuLmJiLWJ1dHRvbiB7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDEwcHg7XFxuICByaWdodDogMTBweDsgfVxcbiAgLmJiLWJ1dHRvbiAuYmItem9vbS1yZXNldCB7XFxuICAgIGZvbnQtc2l6ZTogMTFweDtcXG4gICAgYm9yZGVyOiBzb2xpZCAxcHggI2NjYztcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXG4gICAgcGFkZGluZzogNXB4O1xcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjsgfVxcblwiLCBcIlwiXSk7XG4vLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodXNlU291cmNlTWFwKSB7XG4gIHZhciBsaXN0ID0gW107IC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblxuICBsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgcmV0dXJuIFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChjb250ZW50LCBcIn1cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnksIGRlZHVwZSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgJyddXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICB2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pXSk7XG5cbiAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udGludWVcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYVF1ZXJ5KSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMl0gPSBcIlwiLmNvbmNhdChtZWRpYVF1ZXJ5LCBcIiBhbmQgXCIpLmNvbmNhdChpdGVtWzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcblxuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCAnJykuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG4gIH1cblxuICByZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufSAvLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5cblxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG4gIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM2X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX18zN19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fMzhfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzM5X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180MF9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDFfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQyX187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180M19fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDRfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ1X187IiwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX180Nl9fOyIsIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9fNDdfXzsiLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzQ4X187IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59IiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogQ1NTIGNsYXNzIG5hbWVzIGRlZmluaXRpb25cclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRhcmM6IFwiYmItYXJjXCIsXHJcblx0YXJjTGFiZWxMaW5lOiBcImJiLWFyYy1sYWJlbC1saW5lXCIsXHJcblx0YXJjczogXCJiYi1hcmNzXCIsXHJcblx0YXJlYTogXCJiYi1hcmVhXCIsXHJcblx0YXJlYXM6IFwiYmItYXJlYXNcIixcclxuXHRheGlzOiBcImJiLWF4aXNcIixcclxuXHRheGlzWDogXCJiYi1heGlzLXhcIixcclxuXHRheGlzWExhYmVsOiBcImJiLWF4aXMteC1sYWJlbFwiLFxyXG5cdGF4aXNZOiBcImJiLWF4aXMteVwiLFxyXG5cdGF4aXNZMjogXCJiYi1heGlzLXkyXCIsXHJcblx0YXhpc1kyTGFiZWw6IFwiYmItYXhpcy15Mi1sYWJlbFwiLFxyXG5cdGF4aXNZTGFiZWw6IFwiYmItYXhpcy15LWxhYmVsXCIsXHJcblx0YmFyOiBcImJiLWJhclwiLFxyXG5cdGJhcnM6IFwiYmItYmFyc1wiLFxyXG5cdGJydXNoOiBcImJiLWJydXNoXCIsXHJcblx0YnV0dG9uOiBcImJiLWJ1dHRvblwiLFxyXG5cdGJ1dHRvblpvb21SZXNldDogXCJiYi16b29tLXJlc2V0XCIsXHJcblx0Y2hhcnQ6IFwiYmItY2hhcnRcIixcclxuXHRjaGFydEFyYzogXCJiYi1jaGFydC1hcmNcIixcclxuXHRjaGFydEFyY3M6IFwiYmItY2hhcnQtYXJjc1wiLFxyXG5cdGNoYXJ0QXJjc0JhY2tncm91bmQ6IFwiYmItY2hhcnQtYXJjcy1iYWNrZ3JvdW5kXCIsXHJcblx0Y2hhcnRBcmNzR2F1Z2VNYXg6IFwiYmItY2hhcnQtYXJjcy1nYXVnZS1tYXhcIixcclxuXHRjaGFydEFyY3NHYXVnZU1pbjogXCJiYi1jaGFydC1hcmNzLWdhdWdlLW1pblwiLFxyXG5cdGNoYXJ0QXJjc0dhdWdlVW5pdDogXCJiYi1jaGFydC1hcmNzLWdhdWdlLXVuaXRcIixcclxuXHRjaGFydEFyY3NUaXRsZTogXCJiYi1jaGFydC1hcmNzLXRpdGxlXCIsXHJcblx0Y2hhcnRBcmNzR2F1Z2VUaXRsZTogXCJiYi1jaGFydC1hcmNzLWdhdWdlLXRpdGxlXCIsXHJcblx0Y2hhcnRCYXI6IFwiYmItY2hhcnQtYmFyXCIsXHJcblx0Y2hhcnRCYXJzOiBcImJiLWNoYXJ0LWJhcnNcIixcclxuXHRjaGFydExpbmU6IFwiYmItY2hhcnQtbGluZVwiLFxyXG5cdGNoYXJ0TGluZXM6IFwiYmItY2hhcnQtbGluZXNcIixcclxuXHRjaGFydFJhZGFyOiBcImJiLWNoYXJ0LXJhZGFyXCIsXHJcblx0Y2hhcnRSYWRhcnM6IFwiYmItY2hhcnQtcmFkYXJzXCIsXHJcblx0Y2hhcnRUZXh0OiBcImJiLWNoYXJ0LXRleHRcIixcclxuXHRjaGFydFRleHRzOiBcImJiLWNoYXJ0LXRleHRzXCIsXHJcblx0Y2lyY2xlOiBcImJiLWNpcmNsZVwiLFxyXG5cdGNpcmNsZXM6IFwiYmItY2lyY2xlc1wiLFxyXG5cdGNvbG9yUGF0dGVybjogXCJiYi1jb2xvci1wYXR0ZXJuXCIsXHJcblx0Y29sb3JTY2FsZTogXCJiYi1jb2xvcnNjYWxlXCIsXHJcblx0ZGVmb2N1c2VkOiBcImJiLWRlZm9jdXNlZFwiLFxyXG5cdGRyYWdhcmVhOiBcImJiLWRyYWdhcmVhXCIsXHJcblx0ZW1wdHk6IFwiYmItZW1wdHlcIixcclxuXHRldmVudFJlY3Q6IFwiYmItZXZlbnQtcmVjdFwiLFxyXG5cdGV2ZW50UmVjdHM6IFwiYmItZXZlbnQtcmVjdHNcIixcclxuXHRldmVudFJlY3RzTXVsdGlwbGU6IFwiYmItZXZlbnQtcmVjdHMtbXVsdGlwbGVcIixcclxuXHRldmVudFJlY3RzU2luZ2xlOiBcImJiLWV2ZW50LXJlY3RzLXNpbmdsZVwiLFxyXG5cdGZvY3VzZWQ6IFwiYmItZm9jdXNlZFwiLFxyXG5cdGdhdWdlVmFsdWU6IFwiYmItZ2F1Z2UtdmFsdWVcIixcclxuXHRncmlkOiBcImJiLWdyaWRcIixcclxuXHRncmlkTGluZXM6IFwiYmItZ3JpZC1saW5lc1wiLFxyXG5cdGxlZ2VuZEJhY2tncm91bmQ6IFwiYmItbGVnZW5kLWJhY2tncm91bmRcIixcclxuXHRsZWdlbmRJdGVtOiBcImJiLWxlZ2VuZC1pdGVtXCIsXHJcblx0bGVnZW5kSXRlbUV2ZW50OiBcImJiLWxlZ2VuZC1pdGVtLWV2ZW50XCIsXHJcblx0bGVnZW5kSXRlbUZvY3VzZWQ6IFwiYmItbGVnZW5kLWl0ZW0tZm9jdXNlZFwiLFxyXG5cdGxlZ2VuZEl0ZW1IaWRkZW46IFwiYmItbGVnZW5kLWl0ZW0taGlkZGVuXCIsXHJcblx0bGVnZW5kSXRlbVBvaW50OiBcImJiLWxlZ2VuZC1pdGVtLXBvaW50XCIsXHJcblx0bGVnZW5kSXRlbVRpbGU6IFwiYmItbGVnZW5kLWl0ZW0tdGlsZVwiLFxyXG5cdGxldmVsOiBcImJiLWxldmVsXCIsXHJcblx0bGV2ZWxzOiBcImJiLWxldmVsc1wiLFxyXG5cdGxpbmU6IFwiYmItbGluZVwiLFxyXG5cdGxpbmVzOiBcImJiLWxpbmVzXCIsXHJcblx0cmVnaW9uOiBcImJiLXJlZ2lvblwiLFxyXG5cdHJlZ2lvbnM6IFwiYmItcmVnaW9uc1wiLFxyXG5cdHNlbGVjdGVkQ2lyY2xlOiBcImJiLXNlbGVjdGVkLWNpcmNsZVwiLFxyXG5cdHNlbGVjdGVkQ2lyY2xlczogXCJiYi1zZWxlY3RlZC1jaXJjbGVzXCIsXHJcblx0c2hhcGU6IFwiYmItc2hhcGVcIixcclxuXHRzaGFwZXM6IFwiYmItc2hhcGVzXCIsXHJcblx0c3RhbmZvcmRFbGVtZW50czogXCJiYi1zdGFuZm9yZC1lbGVtZW50c1wiLFxyXG5cdHN0YW5mb3JkTGluZTogXCJiYi1zdGFuZm9yZC1saW5lXCIsXHJcblx0c3RhbmZvcmRMaW5lczogXCJiYi1zdGFuZm9yZC1saW5lc1wiLFxyXG5cdHN0YW5mb3JkUmVnaW9uOiBcImJiLXN0YW5mb3JkLXJlZ2lvblwiLFxyXG5cdHN0YW5mb3JkUmVnaW9uczogXCJiYi1zdGFuZm9yZC1yZWdpb25zXCIsXHJcblx0dGFyZ2V0OiBcImJiLXRhcmdldFwiLFxyXG5cdHRleHQ6IFwiYmItdGV4dFwiLFxyXG5cdHRleHRzOiBcImJiLXRleHRzXCIsXHJcblx0dGl0bGU6IFwiYmItdGl0bGVcIixcclxuXHR0b29sdGlwOiBcImJiLXRvb2x0aXBcIixcclxuXHR0b29sdGlwQ29udGFpbmVyOiBcImJiLXRvb2x0aXAtY29udGFpbmVyXCIsXHJcblx0dG9vbHRpcE5hbWU6IFwiYmItdG9vbHRpcC1uYW1lXCIsXHJcblx0eGdyaWQ6IFwiYmIteGdyaWRcIixcclxuXHR4Z3JpZEZvY3VzOiBcImJiLXhncmlkLWZvY3VzXCIsXHJcblx0eGdyaWRMaW5lOiBcImJiLXhncmlkLWxpbmVcIixcclxuXHR4Z3JpZExpbmVzOiBcImJiLXhncmlkLWxpbmVzXCIsXHJcblx0eGdyaWRzOiBcImJiLXhncmlkc1wiLFxyXG5cdHlncmlkOiBcImJiLXlncmlkXCIsXHJcblx0eWdyaWRGb2N1czogXCJiYi15Z3JpZC1mb2N1c1wiLFxyXG5cdHlncmlkTGluZTogXCJiYi15Z3JpZC1saW5lXCIsXHJcblx0eWdyaWRMaW5lczogXCJiYi15Z3JpZC1saW5lc1wiLFxyXG5cdHlncmlkczogXCJiYi15Z3JpZHNcIixcclxuXHR6b29tQnJ1c2g6IFwiYmItem9vbS1icnVzaFwiLFxyXG5cdHpvb21SZWN0OiBcImJiLXpvb20tcmVjdFwiLFxyXG5cdEVYUEFOREVEOiBcIl9leHBhbmRlZF9cIixcclxuXHRTRUxFQ1RFRDogXCJfc2VsZWN0ZWRfXCIsXHJcblx0SU5DTFVERUQ6IFwiX2luY2x1ZGVkX1wiLFxyXG5cdFRleHRPdmVybGFwcGluZzogXCJ0ZXh0LW92ZXJsYXBwaW5nXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBzdGF0ZSB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR3aWR0aDogMCxcclxuXHRcdFx0d2lkdGgyOiAwLFxyXG5cdFx0XHRoZWlnaHQ6IDAsXHJcblx0XHRcdGhlaWdodDI6IDAsXHJcblx0XHRcdG1hcmdpbjoge1xyXG5cdFx0XHRcdHRvcDogMCxcclxuXHRcdFx0XHRib3R0b206IDAsXHJcblx0XHRcdFx0bGVmdDogMCxcclxuXHRcdFx0XHRyaWdodDogMFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRtYXJnaW4yOiB7XHJcblx0XHRcdFx0dG9wOiAwLFxyXG5cdFx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0XHRsZWZ0OiAwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwXHJcblx0XHRcdH0sXHJcblx0XHRcdG1hcmdpbjM6IHtcclxuXHRcdFx0XHR0b3A6IDAsXHJcblx0XHRcdFx0Ym90dG9tOiAwLFxyXG5cdFx0XHRcdGxlZnQ6IDAsXHJcblx0XHRcdFx0cmlnaHQ6IDBcclxuXHRcdFx0fSxcclxuXHRcdFx0YXJjV2lkdGg6IDAsXHJcblx0XHRcdGFyY0hlaWdodDogMCxcclxuXHRcdFx0Y3VycmVudFdpZHRoOiAwLFxyXG5cdFx0XHRjdXJyZW50SGVpZ2h0OiAwLFxyXG5cclxuXHRcdFx0Ly8gbGVnZW5kXHJcblx0XHRcdGlzTGVnZW5kUmlnaHQ6IGZhbHNlLFxyXG5cdFx0XHRpc0xlZ2VuZEluc2V0OiBmYWxzZSxcclxuXHRcdFx0aXNMZWdlbmRUb3A6IGZhbHNlLFxyXG5cdFx0XHRpc0xlZ2VuZExlZnQ6IGZhbHNlLFxyXG5cdFx0XHRsZWdlbmRTdGVwOiAwLFxyXG5cdFx0XHRsZWdlbmRJdGVtV2lkdGg6IDAsXHJcblx0XHRcdGxlZ2VuZEl0ZW1IZWlnaHQ6IDAsXHJcblx0XHRcdGxlZ2VuZEhhc1JlbmRlcmVkOiBmYWxzZSxcclxuXHJcblx0XHRcdGN1cnJlbnRNYXhUaWNrV2lkdGhzOiB7XHJcblx0XHRcdFx0eDoge3NpemU6IDAsIGRvbWFpbjogXCJcIn0sXHJcblx0XHRcdFx0eToge3NpemU6IDAsIGRvbWFpbjogXCJcIn0sXHJcblx0XHRcdFx0eTI6IHtzaXplOiAwLCBkb21haW46IFwiXCJ9XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRyb3RhdGVkUGFkZGluZzoge1xyXG5cdFx0XHRcdGxlZnQ6IDMwLFxyXG5cdFx0XHRcdHJpZ2h0OiAwLFxyXG5cdFx0XHRcdHRvcDogNVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0d2l0aG91dEZhZGVJbjoge30sXHJcblx0XHRcdGlucHV0VHlwZTogXCJcIixcclxuXHJcblx0XHRcdGRhdGV0aW1lSWQ6IFwiXCIsXHJcblxyXG5cdFx0XHQvLyBjbGlwIGlkIHN0cmluZ1xyXG5cdFx0XHRjbGlwOiB7XHJcblx0XHRcdFx0aWQ6IFwiXCIsXHJcblx0XHRcdFx0aWRYQXhpczogXCJcIixcclxuXHRcdFx0XHRpZFlBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdGlkR3JpZDogXCJcIixcclxuXHRcdFx0XHRpZFN1YmNoYXJ0OiBcIlwiLCAvLyBjbGlwSWRGb3JTdWJjaGFydFxyXG5cdFx0XHRcdHBhdGg6IFwiXCIsXHJcblx0XHRcdFx0cGF0aFhBeGlzOiBcIlwiLFxyXG5cdFx0XHRcdHBhdGhZQXhpczogXCJcIixcclxuXHRcdFx0XHRwYXRoR3JpZDogXCJcIlxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gc3RhdHVzXHJcblx0XHRcdGRyYWdTdGFydDogbnVsbCxcclxuXHRcdFx0ZHJhZ2dpbmc6IGZhbHNlLFxyXG5cdFx0XHRmbG93aW5nOiBmYWxzZSxcclxuXHRcdFx0Y2FuY2VsQ2xpY2s6IGZhbHNlLFxyXG5cdFx0XHRtb3VzZW92ZXI6IGZhbHNlLFxyXG5cdFx0XHRyZW5kZXJlZDogZmFsc2UsXHJcblx0XHRcdHRyYW5zaXRpbmc6IGZhbHNlLFxyXG5cdFx0XHRoYXNOZWdhdGl2ZVZhbHVlOiBmYWxzZSxcclxuXHRcdFx0aGFzUG9zaXRpdmVWYWx1ZTogdHJ1ZSxcclxuXHJcblx0XHRcdG9yZ0FyZWFPcGFjaXR5OiBcIjAuMlwiLFxyXG5cclxuXHRcdFx0Ly8gSUQgc3RyaW5nc1xyXG5cdFx0XHRoaWRkZW5UYXJnZXRJZHM6IFtdLFxyXG5cdFx0XHRoaWRkZW5MZWdlbmRJZHM6IFtdLFxyXG5cdFx0XHRmb2N1c2VkVGFyZ2V0SWRzOiBbXSxcclxuXHRcdFx0ZGVmb2N1c2VkVGFyZ2V0SWRzOiBbXSxcclxuXHJcblx0XHRcdC8vIHZhbHVlIGZvciBBcmNcclxuXHRcdFx0cmFkaXVzOiAwLFxyXG5cdFx0XHRpbm5lclJhZGl1czogMCxcclxuXHRcdFx0aW5uZXJSYWRpdXNSYXRpbzogMCxcclxuXHRcdFx0Z2F1Z2VBcmNXaWR0aDogMCxcclxuXHRcdFx0cmFkaXVzRXhwYW5kZWQ6IDAsXHJcblxyXG5cdFx0XHQvLyB4Z3JpZCBhdHRyaWJ1dGVcclxuXHRcdFx0eGdyaWRBdHRyOiB7XHJcblx0XHRcdFx0eDE6IG51bGwsXHJcblx0XHRcdFx0eDI6IG51bGwsXHJcblx0XHRcdFx0eTE6IG51bGwsXHJcblx0XHRcdFx0eTI6IG51bGxcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZGF0YS5zZWxlY3Rpb24gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGRhdGEgc2VsZWN0aW9uIGVuYWJsZWQ8YnI+PGJyPlxyXG4gICAgICogSWYgdGhpcyBvcHRpb24gaXMgc2V0IHRydWUsIHdlIGNhbiBzZWxlY3QgdGhlIGRhdGEgcG9pbnRzIGFuZCBnZXQvc2V0IGl0cyBzdGF0ZSBvZiBzZWxlY3Rpb24gYnkgQVBJIChlLmcuIHNlbGVjdCwgdW5zZWxlY3QsIHNlbGVjdGVkKS5cclxuICAgICAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRlbmFibGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YVNlbGVjdGlvbilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICBzZWxlY3Rpb246IHtcclxuICAgICAqICAgICAgIGVuYWJsZWQ6IHRydWVcclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9zZWxlY3Rpb25fZW5hYmxlZDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZ3JvdXBlZCBzZWxlY3Rpb24gZW5hYmxlZC48YnI+PGJyPlxyXG4gICAgICogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIG11bHRpcGxlIGRhdGEgcG9pbnRzIHRoYXQgaGF2ZSBzYW1lIHggdmFsdWUgd2lsbCBiZSBzZWxlY3RlZCBieSBvbmUgc2VsZWN0aW9uLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHNlbGVjdGlvbuKApGdyb3VwZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgc2VsZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICBncm91cGVkOiB0cnVlXHJcbiAgICAgKiAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIGVhY2ggZGF0YSBwb2ludCB0byBkZXRlcm1pbmUgaWYgaXQncyBzZWxlY3RhYmxlIG9yIG5vdC48YnI+PGJyPlxyXG4gICAgICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSBkIGFzIGFuIGFyZ3VtZW50IGFuZCBpdCBoYXMgc29tZSBwYXJhbWV0ZXJzIGxpa2UgaWQsIHZhbHVlLCBpbmRleC4gVGhpcyBjYWxsYmFjayBzaG91bGQgcmV0dXJuIGJvb2xlYW4uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkaXNzZWxlY3RhYmxlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgc2VsZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICBpc3NlbGVjdGFibGU6IGZ1bmN0aW9uKGQpIHsgLi4uIH1cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlOiAoKSA9PiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IG11bHRpcGxlIGRhdGEgcG9pbnRzIHNlbGVjdGlvbiBlbmFibGVkLjxicj48YnI+XHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgbXVsdGlsZSBkYXRhIHBvaW50cyBjYW4gaGF2ZSB0aGUgc2VsZWN0ZWQgc3RhdGUgYXQgdGhlIHNhbWUgdGltZS4gSWYgZmFsc2Ugc2V0LCBvbmx5IG9uZSBkYXRhIHBvaW50IGNhbiBoYXZlIHRoZSBzZWxlY3RlZCBzdGF0ZSBhbmQgdGhlIG90aGVycyB3aWxsIGJlIHVuc2VsZWN0ZWQgd2hlbiB0aGUgbmV3IGRhdGEgcG9pbnQgaXMgc2VsZWN0ZWQuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkc2VsZWN0aW9u4oCkbXVsdGlwbGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICBzZWxlY3Rpb246IHtcclxuICAgICAqICAgICAgIG11bHRpcGxlOiBmYWxzZVxyXG4gICAgICogICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3NlbGVjdGlvbl9tdWx0aXBsZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSB0byBzZWxlY3QgZGF0YSBwb2ludHMgYnkgZHJhZ2dpbmcuXHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBzZXQgdHJ1ZSwgZGF0YSBwb2ludHMgY2FuIGJlIHNlbGVjdGVkIGJ5IGRyYWdnaW5nLlxyXG4gICAgICogLSAqKk5PVEU6KiogSWYgdGhpcyBvcHRpb24gc2V0IHRydWUsIHNjcm9sbGluZyBvbiB0aGUgY2hhcnQgd2lsbCBiZSBkaXNhYmxlZCBiZWNhdXNlIGRyYWdnaW5nIGV2ZW50IHdpbGwgaGFuZGxlIHRoZSBldmVudC5cclxuICAgICAqIEBuYW1lIGRhdGHigKRzZWxlY3Rpb27igKRkcmFnZ2FibGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgc2VsZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICBkcmFnZ2FibGU6IHRydWVcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGU6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIFdpbmRvdyBvYmplY3RcclxuICogQG1vZHVsZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cclxuZXhwb3J0IHt3aW4gYXMgd2luZG93LCBkb2MgYXMgZG9jdW1lbnR9O1xyXG5cclxuY29uc3Qgd2luID0gKCgpID0+IHtcclxuXHRjb25zdCBkZWYgPSBvID0+IHR5cGVvZiBvICE9PSBcInVuZGVmaW5lZFwiICYmIG87XHJcblxyXG5cdHJldHVybiBkZWYoc2VsZikgfHwgZGVmKHdpbmRvdykgfHwgZGVmKGdsb2JhbCkgfHwgZGVmKGdsb2JhbFRoaXMpIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcclxufSkoKTtcclxuLyogZXNsaW50LWVuYWJsZSBuby1uZXctZnVuYywgbm8tdW5kZWYgKi9cclxuXHJcbmNvbnN0IGRvYyA9IHdpbiAmJiB3aW4uZG9jdW1lbnQ7XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge2V2ZW50IGFzIGQzRXZlbnR9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHticnVzaFNlbGVjdGlvbiBhcyBkM0JydXNoU2VsZWN0aW9ufSBmcm9tIFwiZDMtYnJ1c2hcIjtcclxuaW1wb3J0IHtkb2N1bWVudCwgd2luZG93fSBmcm9tIFwiLi9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtkM1NlbGVjdGlvbn0gZnJvbSBcInR5cGVzL3R5cGVzXCI7XHJcblxyXG5leHBvcnQge1xyXG5cdGFzSGFsZlBpeGVsLFxyXG5cdGJydXNoRW1wdHksXHJcblx0Y2FsbEZuLFxyXG5cdGNhcGl0YWxpemUsXHJcblx0Y2VpbDEwLFxyXG5cdGRpZmZEb21haW4sXHJcblx0ZW11bGF0ZUV2ZW50LFxyXG5cdGV4dGVuZCxcclxuXHRnZXRCcnVzaFNlbGVjdGlvbixcclxuXHRnZXRCb3VuZGluZ1JlY3QsXHJcblx0Z2V0Q3NzUnVsZXMsXHJcblx0Z2V0TWluTWF4LFxyXG5cdGdldE9wdGlvbixcclxuXHRnZXRQYXRoQm94LFxyXG5cdGdldFJhbmRvbSxcclxuXHRnZXRSYW5nZSxcclxuXHRnZXRSZWN0U2VnTGlzdCxcclxuXHRnZXRUcmFuc2xhdGlvbixcclxuXHRnZXRVbmlxdWUsXHJcblx0aGFzVmFsdWUsXHJcblx0aXNBcnJheSxcclxuXHRpc0Jvb2xlYW4sXHJcblx0aXNEZWZpbmVkLFxyXG5cdGlzRW1wdHksXHJcblx0aXNGdW5jdGlvbixcclxuXHRpc051bWJlcixcclxuXHRpc09iamVjdCxcclxuXHRpc09iamVjdFR5cGUsXHJcblx0aXNTdHJpbmcsXHJcblx0aXNVbmRlZmluZWQsXHJcblx0aXNWYWx1ZSxcclxuXHRtZXJnZUFycmF5LFxyXG5cdG1lcmdlT2JqLFxyXG5cdG5vdEVtcHR5LFxyXG5cdHNhbml0aXNlLFxyXG5cdHNldFRleHRWYWx1ZSxcclxuXHRzb3J0VmFsdWUsXHJcblx0dG9BcnJheSxcclxuXHR0cGxQcm9jZXNzXHJcbn07XHJcblxyXG5jb25zdCBpc1ZhbHVlID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdiB8fCB2ID09PSAwO1xyXG5jb25zdCBpc0Z1bmN0aW9uID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgPT09IFwiZnVuY3Rpb25cIjtcclxuY29uc3QgaXNTdHJpbmcgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIjtcclxuY29uc3QgaXNOdW1iZXIgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjtcclxuY29uc3QgaXNVbmRlZmluZWQgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIjtcclxuY29uc3QgaXNEZWZpbmVkID0gKHY6IGFueSk6IGJvb2xlYW4gPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCI7XHJcbmNvbnN0IGlzQm9vbGVhbiA9ICh2OiBhbnkpOiBib29sZWFuID0+IHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIjtcclxuY29uc3QgY2VpbDEwID0gKHY6IGFueSk6IG51bWJlciA9PiBNYXRoLmNlaWwodiAvIDEwKSAqIDEwO1xyXG5jb25zdCBhc0hhbGZQaXhlbCA9IChuOiBhbnkpOiBudW1iZXIgPT4gTWF0aC5jZWlsKG4pICsgMC41O1xyXG5jb25zdCBkaWZmRG9tYWluID0gKGQ6IG51bWJlcltdKTogbnVtYmVyID0+IGRbMV0gLSBkWzBdO1xyXG5jb25zdCBpc09iamVjdFR5cGUgPSAodjogYW55KTogYm9vbGVhbiA9PiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIjtcclxuY29uc3QgaXNFbXB0eSA9IChvOiBhbnkpOiBib29sZWFuID0+IChcclxuXHRpc1VuZGVmaW5lZChvKSB8fCBvID09PSBudWxsIHx8XHJcblx0KGlzU3RyaW5nKG8pICYmIG8ubGVuZ3RoID09PSAwKSB8fFxyXG5cdChpc09iamVjdFR5cGUobykgJiYgIShvIGluc3RhbmNlb2YgRGF0ZSkgJiYgT2JqZWN0LmtleXMobykubGVuZ3RoID09PSAwKSB8fFxyXG5cdChpc051bWJlcihvKSAmJiBpc05hTihvKSlcclxuKTtcclxuY29uc3Qgbm90RW1wdHkgPSAobzogYW55KTogYm9vbGVhbiA9PiAhaXNFbXB0eShvKTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBpcyBhcnJheVxyXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBpc0FycmF5ID0gKGFycjogYW55KTogYm9vbGVhbiA9PiBBcnJheS5pc0FycmF5KGFycik7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgaXMgb2JqZWN0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybnMge0Jvb2xlYW59XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCBpc09iamVjdCA9IChvYmo6IGFueSk6IGJvb2xlYW4gPT4gb2JqICYmICFvYmoubm9kZVR5cGUgJiYgaXNPYmplY3RUeXBlKG9iaikgJiYgIWlzQXJyYXkob2JqKTtcclxuXHJcbmZ1bmN0aW9uIGdldE9wdGlvbihvcHRpb25zOiBvYmplY3QsIGtleTogc3RyaW5nLCBkZWZhdWx0VmFsdWUpOiBhbnkge1xyXG5cdHJldHVybiBpc0RlZmluZWQob3B0aW9uc1trZXldKSA/IG9wdGlvbnNba2V5XSA6IGRlZmF1bHRWYWx1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gaGFzVmFsdWUoZGljdDogb2JqZWN0LCB2YWx1ZTogYW55KTogYm9vbGVhbiB7XHJcblx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdE9iamVjdC5rZXlzKGRpY3QpLmZvckVhY2goa2V5ID0+IChkaWN0W2tleV0gPT09IHZhbHVlKSAmJiAoZm91bmQgPSB0cnVlKSk7XHJcblxyXG5cdHJldHVybiBmb3VuZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhbGwgZnVuY3Rpb24gd2l0aCBhcmd1bWVudHNcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gYmUgY2FsbGVkXHJcbiAqIEBwYXJhbSB7Kn0gYXJncyBBcmd1bWVudHNcclxuICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZTogZm4gaXMgZnVuY3Rpb24sIGZhbHNlOiBmbiBpcyBub3QgZnVuY3Rpb25cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGNhbGxGbihmbiwgLi4uYXJncyk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IGlzRm4gPSBpc0Z1bmN0aW9uKGZuKTtcclxuXHJcblx0aXNGbiAmJiBmbi5jYWxsKC4uLmFyZ3MpO1xyXG5cdHJldHVybiBpc0ZuO1xyXG59XHJcblxyXG4vKipcclxuICogUmVwbGFjZSB0YWcgc2lnbiB0byBodG1sIGVudGl0eVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNhbml0aXNlKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuXHRyZXR1cm4gaXNTdHJpbmcoc3RyKSA/XHJcblx0XHRzdHIucmVwbGFjZSgvPC9nLCBcIiZsdDtcIikucmVwbGFjZSgvPi9nLCBcIiZndDtcIikgOiBzdHI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXQgdGV4dCB2YWx1ZS4gSWYgdGhlcmUncyBtdWx0aWxpbmUgYWRkIG5vZGVzLlxyXG4gKiBAcGFyYW0ge2QzU2VsZWN0aW9ufSBub2RlIFRleHQgbm9kZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUZXh0IHZhbHVlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge0FycmF5fSBkeSBkeSB2YWx1ZSBmb3IgbXVsdGlsaW5lZCB0ZXh0XHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdG9NaWRkbGUgVG8gYmUgYWxpbmduZWQgdmVydGljYWxseSBtaWRkbGVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldFRleHRWYWx1ZShub2RlOiBkM1NlbGVjdGlvbiwgdGV4dDogc3RyaW5nLCBkeTogbnVtYmVyW10gPSBbLTEsIDFdLCB0b01pZGRsZTogYm9vbGVhbiA9IGZhbHNlKSB7XHJcblx0aWYgKCFub2RlIHx8ICFpc1N0cmluZyh0ZXh0KSkge1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0aWYgKHRleHQuaW5kZXhPZihcIlxcblwiKSA9PT0gLTEpIHtcclxuXHRcdG5vZGUudGV4dCh0ZXh0KTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0Y29uc3QgZGlmZiA9IFtub2RlLnRleHQoKSwgdGV4dF0ubWFwKHYgPT4gdi5yZXBsYWNlKC9bXFxzXFxuXS9nLCBcIlwiKSk7XHJcblxyXG5cdFx0aWYgKGRpZmZbMF0gIT09IGRpZmZbMV0pIHtcclxuXHRcdFx0Y29uc3QgbXVsdGlsaW5lID0gdGV4dC5zcGxpdChcIlxcblwiKTtcclxuXHRcdFx0Y29uc3QgbGVuID0gdG9NaWRkbGUgPyBtdWx0aWxpbmUubGVuZ3RoIC0gMSA6IDE7XHJcblxyXG5cdFx0XHQvLyByZXNldCBwb3NzaWJsZSB0ZXh0XHJcblx0XHRcdG5vZGUuaHRtbChcIlwiKTtcclxuXHJcblx0XHRcdG11bHRpbGluZS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0bm9kZS5hcHBlbmQoXCJ0c3BhblwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIDApXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIGAke2kgPT09IDAgPyBkeVswXSAqIGxlbiA6IGR5WzFdfWVtYClcclxuXHRcdFx0XHRcdC50ZXh0KHYpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbi8vIHN1YnN0aXR1dGlvbiBvZiBTVkdQYXRoU2VnIEFQSSBwb2x5ZmlsbFxyXG5mdW5jdGlvbiBnZXRSZWN0U2VnTGlzdChwYXRoOiBTVkdHcmFwaGljc0VsZW1lbnQpOiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9W10ge1xyXG5cdC8qXHJcblx0ICogc2VnMSAtLS0tLS0tLS0tIHNlZzJcclxuXHQgKiAgIHwgICAgICAgICAgICAgICB8XHJcblx0ICogICB8ICAgICAgICAgICAgICAgfFxyXG5cdCAqICAgfCAgICAgICAgICAgICAgIHxcclxuXHQgKiBzZWcwIC0tLS0tLS0tLS0gc2VnM1xyXG5cdCAqICovXHJcblx0Y29uc3Qge3gsIHksIHdpZHRoLCBoZWlnaHR9ID0gcGF0aC5nZXRCQm94KCk7XHJcblxyXG5cdHJldHVybiBbXHJcblx0XHR7eCwgeTogeSArIGhlaWdodH0sIC8vIHNlZzBcclxuXHRcdHt4LCB5fSwgLy8gc2VnMVxyXG5cdFx0e3g6IHggKyB3aWR0aCwgeX0sIC8vIHNlZzJcclxuXHRcdHt4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHR9IC8vIHNlZzNcclxuXHRdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQYXRoQm94KHBhdGg6IFNWR0dyYXBoaWNzRWxlbWVudCk6IHt4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9IHtcclxuXHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBwYXRoLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdGNvbnN0IGl0ZW1zID0gZ2V0UmVjdFNlZ0xpc3QocGF0aCk7XHJcblx0Y29uc3QgeCA9IGl0ZW1zWzBdLng7XHJcblx0Y29uc3QgeSA9IE1hdGgubWluKGl0ZW1zWzBdLnksIGl0ZW1zWzFdLnkpO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0eCwgeSwgd2lkdGgsIGhlaWdodFxyXG5cdH07XHJcbn1cclxuXHJcbi8vIHJldHVybiBicnVzaCBzZWxlY3Rpb24gYXJyYXlcclxuZnVuY3Rpb24gZ2V0QnJ1c2hTZWxlY3Rpb24oY3R4KSB7XHJcblx0bGV0IHNlbGVjdGlvbjtcclxuXHRjb25zdCBldmVudCA9IGQzRXZlbnQ7XHJcblx0Y29uc3QgbWFpbiA9IGN0eC5jb250ZXh0IHx8IGN0eC5tYWluO1xyXG5cclxuXHQvLyBjaGVjayBmcm9tIGV2ZW50XHJcblx0aWYgKGV2ZW50ICYmIGV2ZW50LmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiQnJ1c2hFdmVudFwiKSB7XHJcblx0XHRzZWxlY3Rpb24gPSBldmVudC5zZWxlY3Rpb247XHJcblx0Ly8gY2hlY2sgZnJvbSBicnVzaCBhcmVhIHNlbGVjdGlvblxyXG5cdH0gZWxzZSBpZiAobWFpbiAmJiAoc2VsZWN0aW9uID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApLm5vZGUoKSkpIHtcclxuXHRcdHNlbGVjdGlvbiA9IGQzQnJ1c2hTZWxlY3Rpb24oc2VsZWN0aW9uKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBzZWxlY3Rpb247XHJcbn1cclxuXHJcbi8vIEdldCBib3VuZGluZ0NsaWVudFJlY3QuIGNhY2hlIHRoZSBldmFsdWF0ZWQgdmFsdWUgb25jZSBpdCB3YXMgY2FsbGVkLlxyXG5jb25zdCBnZXRCb3VuZGluZ1JlY3QgPSBub2RlID0+IG5vZGUucmVjdCB8fCAobm9kZS5yZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XHJcblxyXG4vLyByZXRydW4gcmFuZG9tIG51bWJlclxyXG5mdW5jdGlvbiBnZXRSYW5kb20oYXNTdHI6IGJvb2xlYW4gPSB0cnVlKTogbnVtYmVyIHwgc3RyaW5nIHtcclxuXHRjb25zdCByYW5kID0gTWF0aC5yYW5kb20oKTtcclxuXHJcblx0cmV0dXJuIGFzU3RyID8gU3RyaW5nKHJhbmQpIDogcmFuZDtcclxufVxyXG5cclxuZnVuY3Rpb24gYnJ1c2hFbXB0eShjdHgpIHtcclxuXHRjb25zdCBzZWxlY3Rpb24gPSBnZXRCcnVzaFNlbGVjdGlvbihjdHgpO1xyXG5cclxuXHRpZiAoc2VsZWN0aW9uKSB7XHJcblx0XHQvLyBicnVzaCBzZWxlY3RlZCBhcmVhXHJcblx0XHQvLyB0d28tZGltZW5zaW9uYWw6IFtbeDAsIHkwXSwgW3gxLCB5MV1dXHJcblx0XHQvLyBvbmUtZGltZW5zaW9uYWw6IFt4MCwgeDFdIG9yIFt5MCwgeTFdXHJcblx0XHRyZXR1cm4gc2VsZWN0aW9uWzBdID09PSBzZWxlY3Rpb25bMV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHJ1ZTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCA9IHt9LCBzb3VyY2UpOiBvYmplY3Qge1xyXG5cdGlmIChpc0FycmF5KHNvdXJjZSkpIHtcclxuXHRcdHNvdXJjZS5mb3JFYWNoKHYgPT4gZXh0ZW5kKHRhcmdldCwgdikpO1xyXG5cdH1cclxuXHJcblx0Ly8gZXhjbHVkZSBuYW1lIHdpdGggb25seSBudW1iZXJzXHJcblx0Zm9yIChjb25zdCBwIGluIHNvdXJjZSkge1xyXG5cdFx0aWYgKC9eXFxkKyQvLnRlc3QocCkpIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblxyXG5cdFx0dGFyZ2V0W3BdID0gc291cmNlW3BdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRhcmdldDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybiBmaXJzdCBsZXR0ZXIgY2FwaXRhbGl6ZWRcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGNhcGl0YWxpemVkIHN0cmluZ1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuY29uc3QgY2FwaXRhbGl6ZSA9IChzdHI6IHN0cmluZyk6IHN0cmluZyA9PiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XHJcblxyXG4vKipcclxuICogQ29udmVydCB0byBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gdlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5jb25zdCB0b0FycmF5ID0gKHY6IENTU1N0eWxlRGVjbGFyYXRpb24gfCBhbnkpOiBhbnkgPT4gW10uc2xpY2UuY2FsbCh2KTtcclxuXHJcbi8qKlxyXG4gKiBHZXQgY3NzIHJ1bGVzIGZvciBzcGVjaWZpZWQgc3R5bGVzaGVldHNcclxuICogQHBhcmFtIHtBcnJheX0gc3R5bGVTaGVldHMgVGhlIHN0eWxlc2hlZXRzIHRvIGdldCB0aGUgcnVsZXMgZnJvbVxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDc3NSdWxlcyhzdHlsZVNoZWV0czogYW55W10pIHtcclxuXHRsZXQgcnVsZXMgPSBbXTtcclxuXHJcblx0c3R5bGVTaGVldHMuZm9yRWFjaChzaGVldCA9PiB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRpZiAoc2hlZXQuY3NzUnVsZXMgJiYgc2hlZXQuY3NzUnVsZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cnVsZXMgPSBydWxlcy5jb25jYXQodG9BcnJheShzaGVldC5jc3NSdWxlcykpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoYEVycm9yIHdoaWxlIHJlYWRpbmcgcnVsZXMgZnJvbSAke3NoZWV0LmhyZWZ9OiAke2UudG9TdHJpbmcoKX1gKTtcclxuXHRcdH1cclxuXHR9KTtcclxuXHJcblx0cmV0dXJuIHJ1bGVzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgU1ZHTWF0cml4IG9mIGFuIFNWR0VsZW1lbnRcclxuICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbGVtZW50XHJcbiAqIEByZXR1cm4ge1NWR01hdHJpeH0gbWF0cml4XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGlvbihub2RlKSB7XHJcblx0Y29uc3QgdHJhbnNmb3JtID0gbm9kZSA/IG5vZGUudHJhbnNmb3JtIDogbnVsbDtcclxuXHRjb25zdCBiYXNlVmFsID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLmJhc2VWYWwgOiBbXTtcclxuXHJcblx0cmV0dXJuIGJhc2VWYWwubGVuZ3RoID8gYmFzZVZhbC5nZXRJdGVtKDApLm1hdHJpeCA6IHthOiAwLCBiOiAwLCBjOiAwLCBkOiAwLCBlOiAwLCBmOiAwfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB1bmlxdWUgdmFsdWUgZnJvbSBhcnJheVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhXHJcbiAqIEByZXR1cm4ge0FycmF5fSBVbmlxdWUgYXJyYXkgdmFsdWVcclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFVuaXF1ZShkYXRhOiBhbnlbXSk6IGFueVtdIHtcclxuXHRjb25zdCBpc0RhdGUgPSBkYXRhWzBdIGluc3RhbmNlb2YgRGF0ZTtcclxuXHRjb25zdCBkID0gKGlzRGF0ZSA/IGRhdGEubWFwKE51bWJlcikgOiBkYXRhKVxyXG5cdFx0LmZpbHRlcigodiwgaSwgc2VsZikgPT4gc2VsZi5pbmRleE9mKHYpID09PSBpKTtcclxuXHJcblx0cmV0dXJuIGlzRGF0ZSA/IGQubWFwKHYgPT4gbmV3IERhdGUodikpIDogZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIGFycmF5XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIG1lcmdlQXJyYXkoYXJyOiBhbnlbXSk6IGFueVtdIHtcclxuXHRyZXR1cm4gYXJyICYmIGFyci5sZW5ndGggPyBhcnIucmVkdWNlKChwLCBjKSA9PiBwLmNvbmNhdChjKSkgOiBbXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlIG9iamVjdCByZXR1cm5pbmcgbmV3IG9iamVjdFxyXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3ROXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IG1lcmdlZCB0YXJnZXQgb2JqZWN0XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZU9iaih0YXJnZXQ6IG9iamVjdCwgLi4ub2JqZWN0Tik6IGFueSB7XHJcblx0aWYgKCFvYmplY3ROLmxlbmd0aCB8fCAob2JqZWN0Ti5sZW5ndGggPT09IDEgJiYgIW9iamVjdE5bMF0pKSB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH1cclxuXHJcblx0Y29uc3Qgc291cmNlID0gb2JqZWN0Ti5zaGlmdCgpO1xyXG5cclxuXHRpZiAoaXNPYmplY3QodGFyZ2V0KSAmJiBpc09iamVjdChzb3VyY2UpKSB7XHJcblx0XHRPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcclxuXHJcblx0XHRcdGlmIChpc09iamVjdCh2YWx1ZSkpIHtcclxuXHRcdFx0XHQhdGFyZ2V0W2tleV0gJiYgKHRhcmdldFtrZXldID0ge30pO1xyXG5cdFx0XHRcdHRhcmdldFtrZXldID0gbWVyZ2VPYmoodGFyZ2V0W2tleV0sIHZhbHVlKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0YXJnZXRba2V5XSA9IGlzQXJyYXkodmFsdWUpID9cclxuXHRcdFx0XHRcdHZhbHVlLmNvbmNhdCgpIDogdmFsdWU7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIG1lcmdlT2JqKHRhcmdldCwgLi4ub2JqZWN0Tik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTb3J0IHZhbHVlXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgdmFsdWUgdG8gYmUgc29ydGVkXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNBc2MgdHJ1ZTogYXNjLCBmYWxzZTogZGVzY1xyXG4gKiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfERhdGV9IHNvcnRlZCBkYXRlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzb3J0VmFsdWUoZGF0YTogYW55W10sIGlzQXNjID0gdHJ1ZSk6IGFueVtdIHtcclxuXHRsZXQgZm47XHJcblxyXG5cdGlmIChkYXRhWzBdIGluc3RhbmNlb2YgRGF0ZSkge1xyXG5cdFx0Zm4gPSBpc0FzYyA/IChhLCBiKSA9PiBhIC0gYiA6IChhLCBiKSA9PiBiIC0gYTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0aWYgKGlzQXNjICYmICFkYXRhLmV2ZXJ5KGlzTmFOKSkge1xyXG5cdFx0XHRmbiA9IChhLCBiKSA9PiBhIC0gYjtcclxuXHRcdH0gZWxzZSBpZiAoIWlzQXNjKSB7XHJcblx0XHRcdGZuID0gKGEsIGIpID0+IChhID4gYiAmJiAtMSkgfHwgKGEgPCBiICYmIDEpIHx8IChhID09PSBiICYmIDApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGRhdGEuY29uY2F0KCkuc29ydChmbik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZXQgbWluL21heCB2YWx1ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAnbWluJyBvciAnbWF4J1xyXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIEFycmF5IGRhdGEgdmFsdWVcclxuICogQHJldHVuIHtOdW1iZXJ8RGF0ZXx1bmRlZmluZWR9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNaW5NYXgodHlwZTogXCJtaW5cIiB8IFwibWF4XCIsIGRhdGE6IG51bWJlcltdIHwgRGF0ZVtdIHwgYW55KSB7XHJcblx0bGV0IHJlcyA9IGRhdGEuZmlsdGVyKHYgPT4gbm90RW1wdHkodikpO1xyXG5cclxuXHRpZiAocmVzLmxlbmd0aCkge1xyXG5cdFx0aWYgKGlzTnVtYmVyKHJlc1swXSkpIHtcclxuXHRcdFx0cmVzID0gTWF0aFt0eXBlXSguLi5yZXMpO1xyXG5cdFx0fSBlbHNlIGlmIChyZXNbMF0gaW5zdGFuY2VvZiBEYXRlKSB7XHJcblx0XHRcdHJlcyA9IHNvcnRWYWx1ZShyZXMsIHR5cGUgPT09IFwibWluXCIpWzBdO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSB7XHJcblx0XHRyZXMgPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmVzO1xyXG59XHJcblxyXG4vKipcclxuICogR2V0IHJhbmdlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBTdGFydCBudW1iZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBFbmQgbnVtYmVyXHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBudW1iZXJbXSB7XHJcblx0Y29uc3QgcmVzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuXHRmb3IgKGxldCBpOiBudW1iZXIgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XHJcblx0XHRyZXMucHVzaChpKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiByZXM7XHJcbn1cclxuXHJcbi8vIGVtdWxhdGUgZXZlbnRcclxuY29uc3QgZW11bGF0ZUV2ZW50ID0ge1xyXG5cdG1vdXNlOiAoKCkgPT4ge1xyXG5cdFx0Y29uc3QgZ2V0UGFyYW1zID0gKCkgPT4gKHtcclxuXHRcdFx0YnViYmxlczogZmFsc2UsIGNhbmNlbGFibGU6IGZhbHNlLCBzY3JlZW5YOiAwLCBzY3JlZW5ZOiAwLCBjbGllbnRYOiAwLCBjbGllbnRZOiAwXHJcblx0XHR9KTtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3XHJcblx0XHRcdG5ldyBNb3VzZUV2ZW50KFwidFwiKTtcclxuXHJcblx0XHRcdHJldHVybiAoZWw6IFNWR0VsZW1lbnQgfCBIVE1MRWxlbWVudCwgZXZlbnRUeXBlOiBzdHJpbmcsIHBhcmFtcyA9IGdldFBhcmFtcygpKSA9PiB7XHJcblx0XHRcdFx0ZWwuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudChldmVudFR5cGUsIHBhcmFtcykpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHQvLyBQb2x5ZmlsbHMgRE9NNCBNb3VzZUV2ZW50XHJcblx0XHRcdHJldHVybiAoZWw6IFNWR0VsZW1lbnQgfCBIVE1MRWxlbWVudCwgZXZlbnRUeXBlOiBzdHJpbmcsIHBhcmFtcyA9IGdldFBhcmFtcygpKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbW91c2VFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcclxuXHJcblx0XHRcdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01vdXNlRXZlbnQvaW5pdE1vdXNlRXZlbnRcclxuXHRcdFx0XHRtb3VzZUV2ZW50LmluaXRNb3VzZUV2ZW50KFxyXG5cdFx0XHRcdFx0ZXZlbnRUeXBlLFxyXG5cdFx0XHRcdFx0cGFyYW1zLmJ1YmJsZXMsXHJcblx0XHRcdFx0XHRwYXJhbXMuY2FuY2VsYWJsZSxcclxuXHRcdFx0XHRcdHdpbmRvdyxcclxuXHRcdFx0XHRcdDAsIC8vIHRoZSBldmVudCdzIG1vdXNlIGNsaWNrIGNvdW50XHJcblx0XHRcdFx0XHRwYXJhbXMuc2NyZWVuWCwgcGFyYW1zLnNjcmVlblksXHJcblx0XHRcdFx0XHRwYXJhbXMuY2xpZW50WCwgcGFyYW1zLmNsaWVudFksXHJcblx0XHRcdFx0XHRmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdGVsLmRpc3BhdGNoRXZlbnQobW91c2VFdmVudCk7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fSkoKSxcclxuXHR0b3VjaDogKGVsOiBTVkdFbGVtZW50IHwgSFRNTEVsZW1lbnQsIGV2ZW50VHlwZTogc3RyaW5nLCBwYXJhbXM6IGFueSkgPT4ge1xyXG5cdFx0Y29uc3QgdG91Y2hPYmogPSBuZXcgVG91Y2gobWVyZ2VPYmooe1xyXG5cdFx0XHRpZGVudGlmaWVyOiBEYXRlLm5vdygpLFxyXG5cdFx0XHR0YXJnZXQ6IGVsLFxyXG5cdFx0XHRyYWRpdXNYOiAyLjUsXHJcblx0XHRcdHJhZGl1c1k6IDIuNSxcclxuXHRcdFx0cm90YXRpb25BbmdsZTogMTAsXHJcblx0XHRcdGZvcmNlOiAwLjVcclxuXHRcdH0sIHBhcmFtcykpO1xyXG5cclxuXHRcdGVsLmRpc3BhdGNoRXZlbnQobmV3IFRvdWNoRXZlbnQoZXZlbnRUeXBlLCB7XHJcblx0XHRcdGNhbmNlbGFibGU6IHRydWUsXHJcblx0XHRcdGJ1YmJsZXM6IHRydWUsXHJcblx0XHRcdHNoaWZ0S2V5OiB0cnVlLFxyXG5cdFx0XHR0b3VjaGVzOiBbdG91Y2hPYmpdLFxyXG5cdFx0XHR0YXJnZXRUb3VjaGVzOiBbXSxcclxuXHRcdFx0Y2hhbmdlZFRvdWNoZXM6IFt0b3VjaE9ial1cclxuXHRcdH0pKTtcclxuXHR9XHJcbn07XHJcblxyXG4vKipcclxuICogUHJvY2VzcyB0aGUgdGVtcGxhdGUgICYgcmV0dXJuIGJvdW5kIHN0cmluZ1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHBsIFRlbXBsYXRlIHN0cmluZ1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBEYXRhIHZhbHVlIHRvIGJlIHJlcGxhY2VkXHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHRwbFByb2Nlc3ModHBsOiBzdHJpbmcsIGRhdGE6IG9iamVjdCk6IHN0cmluZyB7XHJcblx0bGV0IHJlcyA9IHRwbDtcclxuXHJcblx0Zm9yIChjb25zdCB4IGluIGRhdGEpIHtcclxuXHRcdHJlcyA9IHJlcy5yZXBsYWNlKG5ldyBSZWdFeHAoYHs9JHt4fX1gLCBcImdcIiksIGRhdGFbeF0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlcztcclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBkYXRhU2VsZWN0aW9uIGZyb20gXCIuL3NlbGVjdGlvblwiO1xyXG5pbXBvcnQge21lcmdlT2JqfSBmcm9tIFwiLi4vLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBkYXRhIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBtZXJnZU9iaih7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZnkgdGhlIGtleSBvZiB4IHZhbHVlcyBpbiB0aGUgZGF0YS48YnI+PGJyPlxyXG4gICAgICogV2UgY2FuIHNob3cgdGhlIGRhdGEgd2l0aCBub24taW5kZXggeCB2YWx1ZXMgYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIGlzIHJlcXVpcmVkIHdoZW4gdGhlIHR5cGUgb2YgeCBheGlzIGlzIHRpbWVzZXJpZXMuIElmIHRoaXMgb3B0aW9uIGlzIHNldCBvbiBjYXRlZ29yeSBheGlzLCB0aGUgdmFsdWVzIG9mIHRoZSBkYXRhIG9uIHRoZSBrZXkgd2lsbCBiZSB1c2VkIGZvciBjYXRlZ29yeSBuYW1lcy5cclxuICAgICAqIEBuYW1lIGRhdGHigKR4XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgeDogXCJkYXRlXCJcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV94OiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZ5IHRoZSBrZXlzIG9mIHRoZSB4IHZhbHVlcyBmb3IgZWFjaCBkYXRhLjxicj48YnI+XHJcbiAgICAgKiBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCBpZiB3ZSB3YW50IHRvIHNob3cgdGhlIGRhdGEgdGhhdCBoYXMgZGlmZmVyZW50IHggdmFsdWVzLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHhzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICB4czoge1xyXG4gICAgICogICAgICBkYXRhMTogXCJ4MVwiLFxyXG4gICAgICogICAgICBkYXRhMjogXCJ4MlwiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV94czoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBmb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIHN0cmluZyBzcGVjaWZlZCBhcyB4LlxyXG4gICAgICogQG5hbWUgZGF0YeKApHhGb3JtYXRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgJVktJW0tJWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICB4OiBcInhcIixcclxuICAgICAqICAgIGNvbHVtbnM6IFtcclxuICAgICAqICAgICAgICBbXCJ4XCIsIFwiMDEwMTIwMTlcIiwgXCIwMjAxMjAxOVwiLCBcIjAzMDEyMDE5XCJdLFxyXG4gICAgICogICAgICAgIFtcImRhdGExXCIsIDMwLCAyMDAsIDEwMF1cclxuICAgICAqICAgIF0sXHJcbiAgICAgKiAgICAvLyBGb3JtYXQgc3BlY2lmaWVyIHRvIHBhcnNlIGFzIGRhdGV0aW1lIGZvciBnaXZlbiAneCcgc3RyaW5nIHZhbHVlXHJcbiAgICAgKiAgICB4Rm9ybWF0OiBcIiVtJWQlWVwiXHJcbiAgICAgKiB9LFxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICAgeDoge1xyXG4gICAgICogICAgICAgIHR5cGU6IFwidGltZXNlcmllc1wiXHJcbiAgICAgKiAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKiBAc2VlIFtEMydzIHRpbWUgc3BlY2lmaWVyXShodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZS1mb3JtYXQjbG9jYWxlX2Zvcm1hdClcclxuICAgICAqL1xyXG4gICAgZGF0YV94Rm9ybWF0OiBcIiVZLSVtLSVkXCIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbG9jYWx0aW1lIGZvcm1hdCB0byBwYXJzZSB4IGF4aXMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkeExvY2FsdGltZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgeExvY2FsdGltZTogZmFsc2VcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV94TG9jYWx0aW1lOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU29ydCBvbiB4IGF4aXMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkeFNvcnRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHhTb3J0OiBmYWxzZVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3hTb3J0OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgZGF0YSBpZCB2YWx1ZVxyXG4gICAgICogQG5hbWUgZGF0YeKApGlkQ29udmVydGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oaWQpIHsgcmV0dXJuIGlkOyB9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgaWRDb252ZXJ0ZXI6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgKiAgICAgICAvLyB3aGVuIGlkIGlzICdkYXRhMScsIGNvbnZlcnRzIHRvIGJlICdkYXRhMidcclxuICAgICAqICAgICAgIC8vICdkYXRhMicgc2hvdWxkIGJlIGdpdmVuIGFzIHRoZSBpbml0aWFsIGRhdGEgdmFsdWVcclxuICAgICAqICAgICAgIGlmIChpZCA9PT0gXCJkYXRhMVwiKSB7XHJcbiAgICAgKiAgICAgICAgICByZXR1cm4gXCJkYXRhMlwiO1xyXG4gICAgICogICAgICAgfSBlbHNlIHtcclxuICAgICAqICAgICAgICAgIHJldHVybiBpZDtcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9pZENvbnZlcnRlcjogaWQgPT4gaWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY3VzdG9tIGRhdGEgbmFtZS5cclxuICAgICAqIEBuYW1lIGRhdGHigKRuYW1lc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU5hbWUpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBuYW1lczoge1xyXG4gICAgICogICAgIGRhdGExOiBcIkRhdGEgTmFtZSAxXCIsXHJcbiAgICAgKiAgICAgZGF0YTI6IFwiRGF0YSBOYW1lIDJcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfbmFtZXM6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGN1c3RvbSBkYXRhIGNsYXNzLjxicj48YnI+XHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSBlbGVtZW50IGcgZm9yIHRoZSBkYXRhIGhhcyBhbiBhZGRpdGlvbmFsIGNsYXNzIHRoYXQgaGFzIHRoZSBwcmVmaXggJ2JiLXRhcmdldC0nIChlZy4gYmItdGFyZ2V0LWFkZGl0aW9uYWwtZGF0YTEtY2xhc3MpLlxyXG4gICAgICogQG5hbWUgZGF0YeKApGNsYXNzZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIGNsYXNzZXM6IHtcclxuICAgICAqICAgICBkYXRhMTogXCJhZGRpdGlvbmFsLWRhdGExLWNsYXNzXCIsXHJcbiAgICAgKiAgICAgZGF0YTI6IFwiYWRkaXRpb25hbC1kYXRhMi1jbGFzc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9jbGFzc2VzOiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBncm91cHMgZm9yIHRoZSBkYXRhIGZvciBzdGFja2luZy5cclxuICAgICAqIEBuYW1lIGRhdGHigKRncm91cHNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCBbXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgZ3JvdXBzOiBbXHJcbiAgICAgKiAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuICAgICAqICAgICBbXCJkYXRhM1wiXVxyXG4gICAgICogICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfZ3JvdXBzOiBbXSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB5IGF4aXMgdGhlIGRhdGEgcmVsYXRlZCB0by4geSBhbmQgeTIgY2FuIGJlIHVzZWQuXHJcblx0ICogLSAqKk5PVEU6KiogSWYgYWxsIGRhdGEgaXMgcmVsYXRlZCB0byBvbmUgb2YgdGhlIGF4ZXMsIHRoZSBkb21haW4gb2YgYXhpcyB3aXRob3V0IHJlbGF0ZWQgZGF0YSB3aWxsIGJlIHJlcGxhY2VkIGJ5IHRoZSBkb21haW4gZnJvbSB0aGUgYXhpcyB3aXRoIHJlbGF0ZWQgZGF0YVxyXG4gICAgICogQG5hbWUgZGF0YeKApGF4ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIGF4ZXM6IHtcclxuICAgICAqICAgICBkYXRhMTogXCJ5XCIsXHJcbiAgICAgKiAgICAgZGF0YTI6IFwieTJcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfYXhlczoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY2hhcnQgdHlwZSBhdCBvbmNlLjxicj48YnI+XHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSB0eXBlIHdpbGwgYmUgYXBwbGllZCB0byBldmVyeSBkYXRhLiBUaGlzIHNldHRpbmcgY2FuIGJlIG92ZXJ3cml0dGVuIGJ5IGRhdGEudHlwZXMuPGJyPjxicj5cclxuICAgICAqICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogLSBhcmVhXHJcbiAgICAgKiAtIGFyZWEtbGluZS1yYW5nZVxyXG4gICAgICogLSBhcmVhLXNwbGluZVxyXG4gICAgICogLSBhcmVhLXNwbGluZS1yYW5nZVxyXG4gICAgICogLSBhcmVhLXN0ZXBcclxuICAgICAqIC0gYmFyXHJcbiAgICAgKiAtIGJ1YmJsZVxyXG4gICAgICogLSBkb251dFxyXG4gICAgICogLSBnYXVnZVxyXG4gICAgICogLSBsaW5lXHJcbiAgICAgKiAtIHBpZVxyXG4gICAgICogLSByYWRhclxyXG4gICAgICogLSBzY2F0dGVyXHJcbiAgICAgKiAtIHNwbGluZVxyXG4gICAgICogLSBzdGVwXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkdHlwZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCBsaW5lXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgdHlwZTogXCJiYXJcIlxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3R5cGU6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjaGFydCB0eXBlIGZvciBlYWNoIGRhdGEuPGJyPlxyXG4gICAgICogVGhpcyBzZXR0aW5nIG92ZXJ3cml0ZXMgZGF0YS50eXBlIHNldHRpbmcuXHJcbiAgICAgKiAtICoqTk9URToqKiBgcmFkYXJgIHR5cGUgY2FuJ3QgYmUgY29tYmluZWQgd2l0aCBvdGhlciB0eXBlcy5cclxuICAgICAqIEBuYW1lIGRhdGHigKR0eXBlc1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgdHlwZXM6IHtcclxuICAgICAqICAgICBkYXRhMTogXCJiYXJcIixcclxuICAgICAqICAgICBkYXRhMjogXCJzcGxpbmVcIlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfdHlwZXM6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxhYmVscyBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkbGFiZWxzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzPWZhbHNlXSBTaG93IG9yIGhpZGUgbGFiZWxzIG9uIGVhY2ggZGF0YSBwb2ludHNcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2RhdGEubGFiZWxzLmNlbnRlcmVkPWZhbHNlXSBDZW50ZXJpemUgbGFiZWxzIG9uIGBiYXJgIHNoYXBlLiAoKipOT1RFOioqIHdvcmtzIG9ubHkgZm9yICdiYXInIHR5cGUpXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZGF0YS5sYWJlbHMuZm9ybWF0XSBTZXQgZm9ybWF0dGVyIGZ1bmN0aW9uIGZvciBkYXRhIGxhYmVscy48YnI+XHJcbiAgICAgKiBUaGUgZm9ybWF0dGVyIGZ1bmN0aW9uIHJlY2VpdmVzIDQgYXJndW1lbnRzIHN1Y2ggYXMgdiwgaWQsIGksIGogYW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgd2lsbCBiZSBzaG93biBhcyB0aGUgbGFiZWwuIFRoZSBhcmd1bWVudHMgYXJlOjxicj5cclxuICAgICAqICAtIGB2YCBpcyB0aGUgdmFsdWUgb2YgdGhlIGRhdGEgcG9pbnQgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxyXG4gICAgICogIC0gYGlkYCBpcyB0aGUgaWQgb2YgdGhlIGRhdGEgd2hlcmUgdGhlIGxhYmVsIGlzIHNob3duLlxyXG4gICAgICogIC0gYGlgIGlzIHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uXHJcbiAgICAgKiAgLSBgamAgaXMgdGhlIHN1YiBpbmRleCBvZiB0aGUgZGF0YSBwb2ludCB3aGVyZSB0aGUgbGFiZWwgaXMgc2hvd24uPGJyPjxicj5cclxuICAgICAqIEZvcm1hdHRlciBmdW5jdGlvbiBjYW4gYmUgZGVmaW5lZCBmb3IgZWFjaCBkYXRhIGJ5IHNwZWNpZnlpbmcgYXMgYW4gb2JqZWN0IGFuZCBEMyBmb3JtYXR0ZXIgZnVuY3Rpb24gY2FuIGJlIHNldCAoZXguIGQzLmZvcm1hdCgnJCcpKVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8T2JqZWN0fSBbZGF0YS5sYWJlbHMuY29sb3JzXSBTZXQgbGFiZWwgdGV4dCBjb2xvcnMuXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW2RhdGEubGFiZWxzLnBvc2l0aW9uXSBTZXQgZWFjaCBkYXRhc2V0IHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLng9MF0geCBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2RhdGEubGFiZWxzLnBvc2l0aW9uLnk9MF0geSBjb29yZGluYXRlIHBvc2l0aW9uLCByZWxhdGl2ZSB0aGUgb3JpZ2luYWwuXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWwpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBsYWJlbCBjb2xvcnNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkRhdGFMYWJlbENvbG9ycylcclxuICAgICAqIEBzZWUgW0RlbW86IGxhYmVsIGZvcm1hdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsRm9ybWF0KVxyXG4gICAgICogQHNlZSBbRGVtbzogbGFiZWwgb3ZlcmxhcF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUxhYmVsT3ZlcmxhcClcclxuICAgICAqIEBzZWUgW0RlbW86IGxhYmVsIHBvc2l0aW9uXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhTGFiZWxQb3NpdGlvbilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIGxhYmVsczogdHJ1ZSxcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIG9yIHNldCBzcGVjaWZpYyBvcHRpb25zXHJcbiAgICAgKiAgIGxhYmVsczoge1xyXG4gICAgICogICAgIGZvcm1hdDogZnVuY3Rpb24odiwgaWQsIGksIGopIHsgLi4uIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIGl0J3MgcG9zc2libGUgdG8gc2V0IGZvciBlYWNoIGRhdGFcclxuICAgICAqICAgICBmb3JtYXQ6IHtcclxuICAgICAqICAgICAgICAgZGF0YTE6IGZ1bmN0aW9uKHYsIGlkLCBpLCBqKSB7IC4uLiB9LFxyXG4gICAgICogICAgICAgICAuLi5cclxuICAgICAqICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBhbGlnbiB0ZXh0IHRvIGNlbnRlciBvZiB0aGUgJ2Jhcicgc2hhcGUgKHdvcmtzIG9ubHkgZm9yICdiYXInIHR5cGUpXHJcbiAgICAgKiAgICAgY2VudGVyZWQ6IHRydWUsXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIGFwcGx5IGZvciBhbGwgbGFiZWwgdGV4dHNcclxuICAgICAqICAgICBjb2xvcnM6IFwicmVkXCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIG9yIHNldCBkaWZmZXJlbnQgY29sb3JzIHBlciBkYXRhc2V0XHJcbiAgICAgKiAgICAgLy8gZm9yIG5vdCBzcGVjaWZpZWQgZGF0YXNldCwgd2lsbCBoYXZlIHRoZSBkZWZhdWx0IGNvbG9yIHZhbHVlXHJcbiAgICAgKiAgICAgY29sb3JzOiB7XHJcbiAgICAgKiAgICAgICAgZGF0YTE6IFwieWVsbG93XCIsXHJcbiAgICAgKiAgICAgICAgZGF0YTM6IFwiZ3JlZW5cIlxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb25cclxuICAgICAqICAgICBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgIHg6IC0xMCxcclxuICAgICAqICAgICAgICB5OiAxMFxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIG9yIHNldCB4LCB5IGNvb3JkaW5hdGUgcG9zaXRpb24gYnkgZWFjaCBkYXRhc2V0XHJcbiAgICAgKiAgICAgcG9zaXRpb246IHtcclxuICAgICAqICAgICAgICBkYXRhMToge3g6IDUsIHk6IDV9LFxyXG4gICAgICogICAgICAgIGRhdGEyOiB7eDogMTAsIHk6IC0yMH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9sYWJlbHM6IHt9LFxyXG4gICAgZGF0YV9sYWJlbHNfY29sb3JzOiB1bmRlZmluZWQsXHJcbiAgICBkYXRhX2xhYmVsc19wb3NpdGlvbjoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiAgVGhpcyBvcHRpb24gY2hhbmdlcyB0aGUgb3JkZXIgb2Ygc3RhY2tpbmcgZGF0YSBhbmQgcGllY2VzIG9mIHBpZS9kb251dC5cclxuICAgICAqICAtIElmIGBudWxsYCBzcGVjaWZpZWQsIGl0IHdpbGwgYmUgdGhlIG9yZGVyIHRoZSBkYXRhIGxvYWRlZC5cclxuICAgICAqICAtIElmIGZ1bmN0aW9uIHNwZWNpZmllZCwgaXQgd2lsbCBiZSB1c2VkIGFzIFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKTxicj48YnI+XHJcbiAgICAgKlxyXG4gICAgICogICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogIC0gYGRlc2NgOiBJbiBkZXNjZW5kaW5nIG9yZGVyXHJcbiAgICAgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIG9yZGVyXHJcbiAgICAgKiAgLSBgbnVsbGA6IEl0IGtlZXBzIHRoZSBkYXRhIGxvYWQgb3JkZXJcclxuICAgICAqICAtIGBmdW5jdGlvbihkYXRhMSwgZGF0YTIpIHsgLi4uIH1gOiBBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvblxyXG4gICAgICogQG5hbWUgZGF0YeKApG9yZGVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ3xGdW5jdGlvbnxudWxsfVxyXG4gICAgICogQGRlZmF1bHQgZGVzY1xyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YU9yZGVyKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgLy8gaW4gZGVzY2VuZGluZyBvcmRlciAoZGVmYXVsdClcclxuICAgICAqICAgb3JkZXI6IFwiZGVzY1wiXHJcbiAgICAgKlxyXG4gICAgICogICAvLyBpbiBhc2NlbmRpbmcgb3JkZXJcclxuICAgICAqICAgb3JkZXI6IFwiYXNjXCJcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIGtlZXBzIGRhdGEgaW5wdXQgb3JkZXJcclxuICAgICAqICAgb3JkZXI6IG51bGxcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIHNwZWNpZnlpbmcgc29ydCBmdW5jdGlvblxyXG4gICAgICogICBvcmRlcjogZnVuY3Rpb24oYSwgYikge1xyXG4gICAgICogICAgICAgLy8gcGFyYW0gZGF0YSBwYXNzZWQgZm9ybWF0XHJcbiAgICAgKiAgICAgICB7XHJcbiAgICAgKiAgICAgICAgICBpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBbXHJcbiAgICAgKiAgICAgICAgICAgICAge3g6IDUsIHZhbHVlOiAyNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA1LCBuYW1lOiBcImRhdGExXCJ9LFxyXG4gICAgICogICAgICAgICAgICAgIC4uLlxyXG4gICAgICogICAgICAgICAgXVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb3JkZXI6IFwiZGVzY1wiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogRGVmaW5lIHJlZ2lvbnMgZm9yIGVhY2ggZGF0YS48YnI+XHJcbiAgICAgKiBUaGUgdmFsdWVzIG11c3QgYmUgYW4gYXJyYXkgZm9yIGVhY2ggZGF0YSBhbmQgaXQgc2hvdWxkIGluY2x1ZGUgYW4gb2JqZWN0IHRoYXQgaGFzIGBzdGFydGAsIGBlbmRgIGFuZCBgc3R5bGVgLlxyXG4gICAgICogLSBUaGUgb2JqZWN0IHR5cGUgc2hvdWxkIGJlIGFzOlxyXG4gICAgICogICAtIHN0YXJ0IHtOdW1iZXJ9OiBTdGFydCBkYXRhIHBvaW50IG51bWJlci4gSWYgbm90IHNldCwgdGhlIHN0YXJ0IHdpbGwgYmUgdGhlIGZpcnN0IGRhdGEgcG9pbnQuXHJcbiAgICAgKiAgIC0gW2VuZF0ge051bWJlcn06IEVuZCBkYXRhIHBvaW50IG51bWJlci4gSWYgbm90IHNldCwgdGhlIGVuZCB3aWxsIGJlIHRoZSBsYXN0IGRhdGEgcG9pbnQuXHJcbiAgICAgKiAgIC0gW3N0eWxlLmRhc2hhcnJheT1cIjIgMlwiXSB7T2JqZWN0fTogVGhlIGZpcnN0IG51bWJlciBzcGVjaWZpZXMgYSBkaXN0YW5jZSBmb3IgdGhlIGZpbGxlZCBhcmVhLCBhbmQgdGhlIHNlY29uZCBhIGRpc3RhbmNlIGZvciB0aGUgdW5maWxsZWQgYXJlYS5cclxuICAgICAqIC0gKipOT1RFOioqIEN1cnJlbnRseSB0aGlzIG9wdGlvbiBzdXBwb3J0cyBvbmx5IGxpbmUgY2hhcnQgYW5kIGRhc2hlZCBzdHlsZS4gSWYgdGhpcyBvcHRpb24gc3BlY2lmaWVkLCB0aGUgbGluZSB3aWxsIGJlIGRhc2hlZCBvbmx5IGluIHRoZSByZWdpb25zLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHJlZ2lvbnNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHJlZ2lvbnM6IHtcclxuICAgICAqICAgICBkYXRhMTogW3tcclxuICAgICAqICAgICAgICAgc3RhcnQ6IDEsXHJcbiAgICAgKiAgICAgICAgIGVuZDogMixcclxuICAgICAqICAgICAgICAgc3R5bGU6IHtcclxuICAgICAqICAgICAgICAgICAgIGRhc2hhcnJheTogXCI1IDJcIlxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgfSwge1xyXG4gICAgICogICAgICAgICBzdGFydDogM1xyXG4gICAgICogICAgIH1dLFxyXG4gICAgICogICAgIC4uLlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfcmVnaW9uczoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY29sb3IgY29udmVydGVyIGZ1bmN0aW9uLjxicj48YnI+XHJcbiAgICAgKiBUaGlzIG9wdGlvbiBzaG91bGQgYSBmdW5jdGlvbiBhbmQgdGhlIHNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBjb2xvciAoZS5nLiAnI2ZmMDAwMCcpIGFuZCBkIHRoYXQgaGFzIGRhdGEgcGFyYW1ldGVycyBsaWtlIGlkLCB2YWx1ZSwgaW5kZXgsIGV0Yy4gQW5kIGl0IG11c3QgcmV0dXJuIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBjb2xvciAoZS5nLiAnIzAwZmYwMCcpLlxyXG4gICAgICogQG5hbWUgZGF0YeKApGNvbG9yXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5EYXRhQ29sb3IpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2xvcjogZnVuY3Rpb24oY29sb3IsIGQpIHsgLi4uIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9jb2xvcjogdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNvbG9yIGZvciBlYWNoIGRhdGEuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkY29sb3JzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2xvcnM6IHtcclxuICAgICAqICAgICBkYXRhMTogXCIjZmYwMDAwXCIsXHJcbiAgICAgKiAgICAgZGF0YTI6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAqICAgICAgICByZXR1cm4gXCIjMDAwXCI7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICAgIC4uLlxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfY29sb3JzOiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhpZGUgZWFjaCBkYXRhIHdoZW4gdGhlIGNoYXJ0IGFwcGVhcnMuPGJyPjxicj5cclxuICAgICAqIElmIHRydWUgc3BlY2lmaWVkLCBhbGwgb2YgZGF0YSB3aWxsIGJlIGhpZGRlbi4gSWYgbXVsdGlwbGUgaWRzIHNwZWNpZmllZCBhcyBhbiBhcnJheSwgdGhvc2Ugd2lsbCBiZSBoaWRkZW4uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkaGlkZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufEFycmF5fVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIC8vIGFsbCBvZiBkYXRhIHdpbGwgYmUgaGlkZGVuXHJcbiAgICAgKiAgIGhpZGU6IHRydWVcclxuICAgICAqXHJcbiAgICAgKiAgIC8vIHNwZWNpZmllZCBkYXRhIHdpbGwgYmUgaGlkZGVuXHJcbiAgICAgKiAgIGhpZGU6IFtcImRhdGExXCIsIC4uLl1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9oaWRlOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpbHRlciB2YWx1ZXMgdG8gYmUgc2hvd25cclxuICAgICAqIFRoZSBkYXRhIHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSByZXR1cm5lZCBieSBgLmRhdGEoKWAuXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2ZpbHRlclxyXG4gICAgICogQG5hbWUgZGF0YeKApGZpbHRlclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgLy8gZmlsdGVyIGZvciBpZCB2YWx1ZVxyXG4gICAgICogICBmaWx0ZXI6IGZ1bmN0aW9uKHYpIHtcclxuICAgICAqICAgICAgLy8gdjogW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBbXHJcbiAgICAgKiAgICAgIC8vICAgICAge3g6IDAsIHZhbHVlOiAxMzAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiAwfSwgLi4uXVxyXG4gICAgICogICAgICAvLyAgICB9LCAuLi5dXHJcbiAgICAgKiAgICAgIHJldHVybiB2LmlkICE9PSBcImRhdGExXCI7XHJcbiAgICAgKiAgIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9maWx0ZXI6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc3RhY2tpbmcgdG8gYmUgbm9ybWFsaXplZFxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICAgLSBGb3Igc3RhY2tpbmcsICdbZGF0YS5ncm91cHNdKCMuZGF0YSUyNUUyJTI1ODAlMjVBNGdyb3VwcyknIG9wdGlvbiBzaG91bGQgYmUgc2V0XHJcbiAgICAgKiAgIC0geSBBeGlzIHdpbGwgYmUgc2V0IGluIHBlcmNlbnRhZ2UgdmFsdWUgKDAgfiAxMDAlKVxyXG4gICAgICogICAtIE11c3QgaGF2ZSBwb3N0aXZlIHZhbHVlc1xyXG4gICAgICogQG5hbWUgZGF0YeKApHN0YWNr4oCkbm9ybWFsaXplXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YVN0YWNrTm9ybWFsaXplZClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHN0YWNrOiB7XHJcbiAgICAgKiAgICAgIG5vcm1hbGl6ZTogdHJ1ZVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfc3RhY2tfbm9ybWFsaXplOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBjbGljayBldmVudCBvbiBlYWNoIGRhdGEgcG9pbnQuPGJyPjxicj5cclxuICAgICAqIFRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2hlbiBlYWNoIGRhdGEgcG9pbnQgY2xpY2tlZCBhbmQgd2lsbCByZWNlaXZlIGBkYCBhbmQgZWxlbWVudCBhcyB0aGUgYXJndW1lbnRzLlxyXG4gICAgICogLSBgZGAgaXMgdGhlIGRhdGEgY2xpY2tlZCBhbmQgZWxlbWVudCBpcyB0aGUgZWxlbWVudCBjbGlja2VkLlxyXG4gICAgICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcbiAgICAgKiAtIEluIHRoaXMgY2FsbGJhY2ssIGB0aGlzYCB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkb25jbGlja1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAgb25jbGljazogZnVuY3Rpb24oZCwgZWxlbWVudCkge1xyXG4gICAgICogICAgICAgIC8vIGQgLSBleCkge3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGExXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGExXCJ9XHJcbiAgICAgKiAgICAgICAgLy8gZWxlbWVudCAtIDxjaXJjbGU+XHJcbiAgICAgKiAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX29uY2xpY2s6ICgpID0+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1vdXNlL3RvdWNoIG92ZXIgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XHJcbiAgICAgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvbnRvIGVhY2ggZGF0YSBwb2ludCBhbmQgd2lsbCByZWNlaXZlIGBkYCBhbmQgYGVsZW1lbnRgIGFzIHRoZSBhcmd1bWVudC5cclxuICAgICAqIC0gYGRgIGlzIHRoZSBkYXRhIHdoZXJlIG1vdXNlIGN1cnNvciBtb3ZlcyBvbnRvLlxyXG4gICAgICogLSBgZWxlbWVudGAgaXMgdGhlIGN1cnJlbnQgaW50ZXJhY3Rpbmcgc3ZnIGVsZW1lbnQuXHJcbiAgICAgKiAtIEluIHRoaXMgY2FsbGJhY2ssIGB0aGlzYCB3aWxsIGJlIHRoZSBDaGFydCBvYmplY3QuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkb25vdmVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgZnVuY3Rpb24oKSB7fVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBvbm92ZXI6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuICAgICAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNH1cclxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb25vdmVyOiAoKSA9PiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGNhbGxiYWNrIGZvciBtb3VzZS90b3VjaCBvdXQgZXZlbnQgb24gZWFjaCBkYXRhIHBvaW50Ljxicj48YnI+XHJcbiAgICAgKiBUaGlzIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdoZW4gbW91c2UgY3Vyc29yIG9yIHZpYSB0b3VjaCBtb3ZlcyBvdXQgZWFjaCBkYXRhIHBvaW50IGFuZCB3aWxsIHJlY2VpdmUgYGRgIGFzIHRoZSBhcmd1bWVudC5cclxuICAgICAqIC0gYGRgIGlzIHRoZSBkYXRhIHdoZXJlIG1vdXNlIGN1cnNvciBtb3ZlcyBvdXQuXHJcbiAgICAgKiAtIGBlbGVtZW50YCBpcyB0aGUgY3VycmVudCBpbnRlcmFjdGluZyBzdmcgZWxlbWVudC5cclxuICAgICAqIC0gSW4gdGhpcyBjYWxsYmFjaywgYHRoaXNgIHdpbGwgYmUgdGhlIENoYXJ0IG9iamVjdC5cclxuICAgICAqIEBuYW1lIGRhdGHigKRvbm91dFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAgb25vdXQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuICAgICAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNH1cclxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb25vdXQ6ICgpID0+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG9uIGRhdGEgc2VsZWN0aW9uLlxyXG4gICAgICogQG5hbWUgZGF0YeKApG9uc2VsZWN0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBmdW5jdGlvbigpIHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgIG9uc2VsZWN0ZWQ6IGZ1bmN0aW9uKGQsIGVsZW1lbnQpIHtcclxuICAgICAqICAgICAgICAvLyBkIC0gZXgpIHt4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMVwifVxyXG4gICAgICogICAgICAgIC8vIGVsZW1lbnQgLSA8Y2lyY2xlPlxyXG4gICAgICogICAgICAgIC4uLlxyXG4gICAgICogICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX29uc2VsZWN0ZWQ6ICgpID0+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG9uIGRhdGEgdW4tc2VsZWN0aW9uLlxyXG4gICAgICogQG5hbWUgZGF0YeKApG9udW5zZWxlY3RlZFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IGZ1bmN0aW9uKCkge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAgb251bnNlbGVjdGVkOiBmdW5jdGlvbihkLCBlbGVtZW50KSB7XHJcbiAgICAgKiAgICAgICAgLy8gZCAtIGV4KSB7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTFcIn1cclxuICAgICAqICAgICAgICAvLyBlbGVtZW50IC0gPGNpcmNsZT5cclxuICAgICAqICAgICAgICAuLi5cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9vbnVuc2VsZWN0ZWQ6ICgpID0+IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgY2FsbGJhY2sgZm9yIG1pbmltdW0gZGF0YVxyXG4gICAgICogLSAqKk5PVEU6KiogRm9yICdhcmVhLWxpbmUtcmFuZ2UnIGFuZCAnYXJlYS1zcGxpbmUtcmFuZ2UnLCBgbWlkYCBkYXRhIHdpbGwgYmUgdGFrZW4gZm9yIHRoZSBjb21wYXJpc29uXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkb25taW5cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLk9uTWluTWF4Q2FsbGJhY2spXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIG9ubWluOiBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgKiAgICAvLyBkYXRhIC0gZXgpIFt7eDogMywgdmFsdWU6IDQwMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDN9LCAuLi4gXVxyXG4gICAgICogICAgLi4uXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBkYXRhX29ubWluOiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBjYWxsYmFjayBmb3IgbWF4aW11bSBkYXRhXHJcbiAgICAgKiAtICoqTk9URToqKiBGb3IgJ2FyZWEtbGluZS1yYW5nZScgYW5kICdhcmVhLXNwbGluZS1yYW5nZScsIGBtaWRgIGRhdGEgd2lsbCBiZSB0YWtlbiBmb3IgdGhlIGNvbXBhcmlzb25cclxuICAgICAqIEBuYW1lIGRhdGHigKRvbm1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuT25NaW5NYXhDYWxsYmFjaylcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgb25tYXg6IGZ1bmN0aW9uKGRhdGEpIHtcclxuICAgICAqICAgIC8vIGRhdGEgLSBleCkgW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLiBdXHJcbiAgICAgKiAgICAuLi5cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGRhdGFfb25tYXg6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYSBDU1Ygb3IgSlNPTiBmaWxlIGZyb20gYSBVUkwuIE5PVEUgdGhhdCB0aGlzIHdpbGwgbm90IHdvcmsgaWYgbG9hZGluZyB2aWEgdGhlIFwiZmlsZTovL1wiIHByb3RvY29sIGFzIHRoZSBtb3N0IGJyb3dzZXJzIHdpbGwgYmxvY2sgWE1MSFRUUFJlcXVlc3RzLlxyXG4gICAgICogQG5hbWUgZGF0YeKApHVybFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNEYXRhLkxvYWREYXRhKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICB1cmw6IFwiL2RhdGEvdGVzdC5jc3ZcIlxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3VybDogdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogWEhSIGhlYWRlciB2YWx1ZVxyXG4gICAgICogLSAqKk5PVEU6KiogU2hvdWxkIGJlIHVzZWQgd2l0aCBgZGF0YS51cmxgIG9wdGlvblxyXG4gICAgICogQG5hbWUgZGF0YeKApGhlYWRlcnNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9zZXRSZXF1ZXN0SGVhZGVyXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgIHVybDogXCIvZGF0YS90ZXN0LmNzdlwiLFxyXG4gICAgICogICAgIGhlYWRlcnM6IHtcclxuICAgICAqICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQveG1sXCIsXHJcbiAgICAgKiAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2hlYWRlcnM6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGEgSlNPTiBvYmplY3QgZm9yIGRhdGEuIFNlZSBhbHNvIGRhdGEua2V5cy5cclxuICAgICAqIEBuYW1lIGRhdGHigKRqc29uXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBbZGF0YeKApGtleXNdKCMuZGF0YSUyNUUyJTI1ODAlMjVBNGtleXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5KU09ORGF0YSlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAganNvbjogW1xyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUxLmNvbVwiLCB1cGxvYWQ6IDIwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDQwMH0sXHJcbiAgICAgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTIuY29tXCIsIHVwbG9hZDogMTAwLCBkb3dubG9hZDogMzAwLCB0b3RhbDogNDAwfSxcclxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGU0LmNvbVwiLCB1cGxvYWQ6IDQwMCwgZG93bmxvYWQ6IDEwMCwgdG90YWw6IDUwMH1cclxuICAgICAqICAgICBdLFxyXG4gICAgICogICAgIGtleXM6IHtcclxuICAgICAqICAgICAgIC8vIHg6IFwibmFtZVwiLCAvLyBpdCdzIHBvc3NpYmxlIHRvIHNwZWNpZnkgJ3gnIHdoZW4gY2F0ZWdvcnkgYXhpc1xyXG4gICAgICogICAgICAgdmFsdWU6IFtcInVwbG9hZFwiLCBcImRvd25sb2FkXCJdXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2pzb246IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgZGF0YSBmcm9tIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSwgd2l0aCB0aGUgZmlyc3QgZWxlbWVudCBjb250YWluaW5nIHRoZSBkYXRhIG5hbWVzLCB0aGUgZm9sbG93aW5nIGNvbnRhaW5pbmcgcmVsYXRlZCBkYXRhIGluIHRoYXQgb3JkZXIuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkcm93c1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtBcnJheX1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuUm93T3JpZW50ZWREYXRhKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgcm93czogW1xyXG4gICAgICogICAgIFtcIkFcIiwgXCJCXCIsIFwiQ1wiXSxcclxuICAgICAqICAgICBbOTAsIDEyMCwgMzAwXSxcclxuICAgICAqICAgICBbNDAsIDE2MCwgMjQwXSxcclxuICAgICAqICAgICBbNTAsIDIwMCwgMjkwXSxcclxuICAgICAqICAgICBbMTIwLCAxNjAsIDIzMF0sXHJcbiAgICAgKiAgICAgWzgwLCAxMzAsIDMwMF0sXHJcbiAgICAgKiAgICAgWzkwLCAyMjAsIDMyMF1cclxuICAgICAqICAgXVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGZvciAncmFuZ2UnIHR5cGVzKCdhcmVhLWxpbmUtcmFuZ2UnIG9yICdhcmVhLXNwbGluZS1yYW5nZScpLCBkYXRhIHNob3VsZCBjb250YWluOlxyXG4gICAgICogLy8gLSBhbiBhcnJheSBvZiBbaGlnaCwgbWlkLCBsb3ddIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxyXG4gICAgICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAnaGlnaCcsICdtaWQnIGFuZCAnbG93JyBrZXkgdmFsdWVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgcm93czogW1xyXG4gICAgICogICAgICBbXCJkYXRhMVwiLCBcImRhdGEyXCJdLFxyXG4gICAgICogICAgICBbXHJcbiAgICAgKiAgICAgICAgLy8gb3Ige2hpZ2g6MTUwLCBtaWQ6IDE0MCwgbG93OiAxMTB9LCAxMjBcclxuICAgICAqICAgICAgICBbMTUwLCAxNDAsIDExMF0sIDEyMFxyXG4gICAgICogICAgICBdLFxyXG4gICAgICogICAgICBbWzE1NSwgMTMwLCAxMTVdLCA1NV0sXHJcbiAgICAgKiAgICAgIFtbMTYwLCAxMzUsIDEyMF0sIDYwXVxyXG4gICAgICogICBdLFxyXG4gICAgICogICB0eXBlczoge1xyXG4gICAgICogICAgICAgZGF0YTE6IFwiYXJlYS1saW5lLXJhbmdlXCIsXHJcbiAgICAgKiAgICAgICBkYXRhMjogXCJsaW5lXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIC8vIGZvciAnYnViYmxlJyB0eXBlLCBkYXRhIGNhbiBjb250YWluIGRpbWVuc2lvbiB2YWx1ZTpcclxuICAgICAqIC8vIC0gYW4gYXJyYXkgb2YgW3ksIHpdIGRhdGEgZm9sbG93aW5nIHRoZSBvcmRlclxyXG4gICAgICogLy8gLSBvciBhbiBvYmplY3Qgd2l0aCAneScgYW5kICd6JyBrZXkgdmFsdWVcclxuICAgICAqIC8vICd5JyBpcyBmb3IgeSBheGlzIGNvb3JkaW5hdGlvbiBhbmQgJ3onIGlzIHRoZSBidWJibGUgcmFkaXVzIHZhbHVlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgIHJvd3M6IFtcclxuICAgICAqICAgICAgW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSxcclxuICAgICAqICAgICAgW1xyXG4gICAgICogICAgICAgIC8vIG9yIHt5OjEwLCB6OiAxNDB9LCAxMjBcclxuICAgICAqICAgICAgICBbMTAsIDE0MF0sIDEyMFxyXG4gICAgICogICAgICBdLFxyXG4gICAgICogICAgICBbWzEwMCwgMzBdLCA1NV0sXHJcbiAgICAgKiAgICAgIFtbNTAsIDEwMF0sIDYwXVxyXG4gICAgICogICBdLFxyXG4gICAgICogICB0eXBlczoge1xyXG4gICAgICogICAgICAgZGF0YTE6IFwiYnViYmxlXCIsXHJcbiAgICAgKiAgICAgICBkYXRhMjogXCJsaW5lXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX3Jvd3M6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgZGF0YSBmcm9tIGEgbXVsdGlkaW1lbnNpb25hbCBhcnJheSwgd2l0aCBlYWNoIGVsZW1lbnQgY29udGFpbmluZyBhbiBhcnJheSBjb25zaXN0aW5nIG9mIGEgZGF0dW0gbmFtZSBhbmQgYXNzb2NpYXRlZCBkYXRhIHZhbHVlcy5cclxuICAgICAqIEBuYW1lIGRhdGHigKRjb2x1bW5zXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jRGF0YS5Db2x1bW5PcmllbnRlZERhdGEpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgIFtcImRhdGExXCIsIDMwLCAyMCwgNTAsIDQwLCA2MCwgNTBdLFxyXG4gICAgICogICAgICBbXCJkYXRhMlwiLCAyMDAsIDEzMCwgOTAsIDI0MCwgMTMwLCAyMjBdLFxyXG4gICAgICogICAgICBbXCJkYXRhM1wiLCAzMDAsIDIwMCwgMTYwLCA0MDAsIDI1MCwgMjUwXVxyXG4gICAgICogICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKlxyXG4gICAgICogLy8gZm9yICdyYW5nZScgdHlwZXMoJ2FyZWEtbGluZS1yYW5nZScgb3IgJ2FyZWEtc3BsaW5lLXJhbmdlJyksIGRhdGEgc2hvdWxkIGNvbnRhaW46XHJcbiAgICAgKiAvLyAtIGFuIGFycmF5IG9mIFtoaWdoLCBtaWQsIGxvd10gZGF0YSBmb2xsb3dpbmcgdGhlIG9yZGVyXHJcbiAgICAgKiAvLyAtIG9yIGFuIG9iamVjdCB3aXRoICdoaWdoJywgJ21pZCcgYW5kICdsb3cnIGtleSB2YWx1ZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgIFtcImRhdGExXCIsXHJcbiAgICAgKiAgICAgICAgICBbMTUwLCAxNDAsIDExMF0sICAvLyBvciB7aGlnaDoxNTAsIG1pZDogMTQwLCBsb3c6IDExMH1cclxuICAgICAqICAgICAgICAgIFsxNTAsIDE0MCwgMTEwXSxcclxuICAgICAqICAgICAgICAgIFsxNTAsIDE0MCwgMTEwXVxyXG4gICAgICogICAgICBdXHJcbiAgICAgKiAgIF0sXHJcbiAgICAgKiAgIHR5cGU6IFwiYXJlYS1saW5lLXJhbmdlXCJcclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiAvLyBmb3IgJ2J1YmJsZScgdHlwZSwgZGF0YSBjYW4gY29udGFpbiBkaW1lbnNpb24gdmFsdWU6XHJcbiAgICAgKiAvLyAtIGFuIGFycmF5IG9mIFt5LCB6XSBkYXRhIGZvbGxvd2luZyB0aGUgb3JkZXJcclxuICAgICAqIC8vIC0gb3IgYW4gb2JqZWN0IHdpdGggJ3knIGFuZCAneicga2V5IHZhbHVlXHJcbiAgICAgKiAvLyAneScgaXMgZm9yIHkgYXhpcyBjb29yZGluYXRpb24gYW5kICd6JyBpcyB0aGUgYnViYmxlIHJhZGl1cyB2YWx1ZVxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgIFtcImRhdGExXCIsXHJcbiAgICAgKiAgICAgICAgICBbMTAsIDE0MF0sICAvLyBvciB7eToxMCwgejogMTQwfVxyXG4gICAgICogICAgICAgICAgWzEwMCwgMzBdLFxyXG4gICAgICogICAgICAgICAgWzUwLCAxMDBdXHJcbiAgICAgKiAgICAgIF1cclxuICAgICAqICAgXSxcclxuICAgICAqICAgdHlwZTogXCJidWJibGVcIlxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2NvbHVtbnM6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgaWYgbG9hZGluZyBKU09OIHZpYSBkYXRhLnVybC5cclxuICAgICAqIC0gKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAgIC0ganNvblxyXG4gICAgICogICAtIGNzdlxyXG4gICAgICogICAtIHRzdlxyXG4gICAgICogQG5hbWUgZGF0YeKApG1pbWVUeXBlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IGNzdlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgICBtaW1lVHlwZTogXCJqc29uXCJcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9taW1lVHlwZTogXCJjc3ZcIixcclxuXHJcbiAgICAvKipcclxuICAgICAqIENob29zZSB3aGljaCBKU09OIG9iamVjdCBrZXlzIGNvcnJlc3BvbmQgdG8gZGVzaXJlZCBkYXRhLlxyXG4gICAgICogLSAqKk5PVEU6KiogT25seSBmb3IgSlNPTiBvYmplY3QgZ2l2ZW4gYXMgYXJyYXkuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCka2V5c1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBkYXRhOiB7XHJcbiAgICAgKiAgICAganNvbjogW1xyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGUxLmNvbVwiLCB1cGxvYWQ6IDIwMCwgZG93bmxvYWQ6IDIwMCwgdG90YWw6IDQwMH0sXHJcbiAgICAgKiAgICAgICB7bmFtZTogXCJ3d3cuc2l0ZTIuY29tXCIsIHVwbG9hZDogMTAwLCBkb3dubG9hZDogMzAwLCB0b3RhbDogNDAwfSxcclxuICAgICAqICAgICAgIHtuYW1lOiBcInd3dy5zaXRlMy5jb21cIiwgdXBsb2FkOiAzMDAsIGRvd25sb2FkOiAyMDAsIHRvdGFsOiA1MDB9LFxyXG4gICAgICogICAgICAge25hbWU6IFwid3d3LnNpdGU0LmNvbVwiLCB1cGxvYWQ6IDQwMCwgZG93bmxvYWQ6IDEwMCwgdG90YWw6IDUwMH1cclxuICAgICAqICAgICBdLFxyXG4gICAgICogICAgIGtleXM6IHtcclxuICAgICAqICAgICAgIC8vIHg6IFwibmFtZVwiLCAvLyBpdCdzIHBvc3NpYmxlIHRvIHNwZWNpZnkgJ3gnIHdoZW4gY2F0ZWdvcnkgYXhpc1xyXG4gICAgICogICAgICAgdmFsdWU6IFtcInVwbG9hZFwiLCBcImRvd25sb2FkXCJdXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBkYXRhX2tleXM6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0ZXh0IGxhYmVsIHRvIGJlIGRpc3BsYXllZCB3aGVuIHRoZXJlJ3Mgbm8gZGF0YSB0byBzaG93LlxyXG4gICAgICogLSBleC4gVG9nZ2xpbmcgYWxsIHZpc2libGUgZGF0YSB0byBub3QgYmUgc2hvd24sIHVubG9hZGluZyBhbGwgY3VycmVudCBkYXRhLCBldGMuXHJcbiAgICAgKiBAbmFtZSBkYXRh4oCkZW1wdHnigKRsYWJlbOKApHRleHRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgXCJcIlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGRhdGE6IHtcclxuICAgICAqICAgZW1wdHk6IHtcclxuICAgICAqICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgdGV4dDogXCJObyBEYXRhXCJcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZGF0YV9lbXB0eV9sYWJlbF90ZXh0OiBcIlwiXHJcbn0sIGRhdGFTZWxlY3Rpb24pO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNsaXAtcGF0aCBhdHRyaWJ1dGUgZm9yIHggYXhpcyBlbGVtZW50XHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGNsaXBQYXRoXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXSgpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogLy8gZG9uJ3Qgc2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZVxyXG4gICAgICogY2xpcFBhdGg6IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9jbGlwUGF0aDogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB4IGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHNob3dcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHR5cGUgb2YgeCBheGlzLjxicj48YnI+XHJcbiAgICAgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuICAgICAqIC0gdGltZXNlcmllc1xyXG4gICAgICogLSBjYXRlZ29yeVxyXG4gICAgICogLSBpbmRleGVkXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHR5cGVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxyXG4gICAgICogQGRlZmF1bHQgaW5kZXhlZFxyXG4gICAgICogQHNlZSBbRGVtbzogaW5kZXhlZF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LkFyZWFDaGFydClcclxuICAgICAqIEBzZWUgW0RlbW86IHRpbWVzZXJpZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydC5UaW1lc2VyaWVzQ2hhcnQpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBjYXRlZ29yeV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuQ2F0ZWdvcnlEYXRhKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHR5cGU6IFwidGltZXNlcmllc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3R5cGU6IFwiaW5kZXhlZFwiLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGhvdyB0byB0cmVhdCB0aGUgdGltZXpvbmUgb2YgeCB2YWx1ZXMuPGJyPlxyXG4gICAgICogSWYgdHJ1ZSwgdHJlYXQgeCB2YWx1ZSBhcyBsb2NhbHRpbWUuIElmIGZhbHNlLCBjb252ZXJ0IHRvIFVUQyBpbnRlcm5hbGx5LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRsb2NhbHRpbWVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBsb2NhbHRpbWU6IGZhbHNlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X2xvY2FsdGltZTogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBjYXRlZ29yeSBuYW1lcyBvbiBjYXRlZ29yeSBheGlzLlxyXG4gICAgICogVGhpcyBtdXN0IGJlIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgY2F0ZWdvcnkgbmFtZXMgaW4gc3RyaW5nLiBJZiBjYXRlZ29yeSBuYW1lcyBhcmUgaW5jbHVkZWQgaW4gdGhlIGRhdGUgYnkgZGF0YS54IG9wdGlvbiwgdGhpcyBpcyBub3QgcmVxdWlyZWQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGNhdGVnb3JpZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCBbXVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIGNhdGVnb3JpZXM6IFtcIkNhdGVnb3J5IDFcIiwgXCJDYXRlZ29yeSAyXCIsIC4uLl1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfY2F0ZWdvcmllczogW10sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBjZW50ZXJpemUgdGlja3Mgb24gY2F0ZWdvcnkgYXhpcy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGNlbnRlcmVkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIGNlbnRlcmVkOiB0cnVlXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX2NlbnRlcmVkOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEEgZnVuY3Rpb24gdG8gZm9ybWF0IHRpY2sgdmFsdWUuIEZvcm1hdCBzdHJpbmcgaXMgYWxzbyBhdmFpbGFibGUgZm9yIHRpbWVzZXJpZXMgZGF0YS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGZvcm1hdFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbnxTdHJpbmd9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBzZWUgW0QzJ3MgdGltZSBzcGVjaWZpZXJdKGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy10aW1lLWZvcm1hdCNsb2NhbGVfZm9ybWF0KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgICAvLyBmb3IgdGltZXNlcmllcywgYSAnZGF0ZXRpbWUnIG9iamVjdCBpcyBnaXZlbiBhcyBwYXJhbWV0ZXJcclxuICAgICAqICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG4gICAgICogICAgICAgICAgIHJldHVybiB4LmdldEZ1bGxZZWFyKCk7XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gZm9yIGNhdGVnb3J5LCBpbmRleChOdW1iZXIpIGFuZCBjYXRlZ29yeU5hbWUoU3RyaW5nKSBhcmUgZ2l2ZW4gYXMgcGFyYW1ldGVyXHJcbiAgICAgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKGluZGV4LCBjYXRlZ29yeU5hbWUpIHtcclxuICAgICAqICAgICAgICAgICByZXR1cm4gY2F0ZWdvcnlOYW1lLnN1YnN0cigwLCAxMCk7XHJcbiAgICAgKiAgICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAvLyBmb3IgdGltZXNlcmllcyBmb3JtYXQgc3BlY2lmaWVyXHJcbiAgICAgKiAgICAgICAgZm9ybWF0OiBcIiVZLSVtLSVkICVIOiVNOiVTXCJcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfZm9ybWF0OiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXR0aW5nIGZvciBjdWxsaW5nIHRpY2tzLjxicj48YnI+XHJcbiAgICAgKiBJZiB0cnVlIGlzIHNldCwgdGhlIHRpY2tzIHdpbGwgYmUgY3VsbGVkLCB0aGVuIG9ubHkgbGltaXR0ZWQgdGljayB0ZXh0IHdpbGwgYmUgc2hvd24uIFRoaXMgb3B0aW9uIGRvZXMgbm90IGhpZGUgdGhlIHRpY2sgbGluZXMuIElmIGZhbHNlIGlzIHNldCwgYWxsIG9mIHRpY2tzIHdpbGwgYmUgc2hvd24uPGJyPjxicj5cclxuICAgICAqIFdlIGNhbiBjaGFuZ2UgdGhlIG51bWJlciBvZiB0aWNrcyB0byBiZSBzaG93biBieSBheGlzLngudGljay5jdWxsaW5nLm1heC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmdcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0XHJcbiAgICAgKiAtIHRydWUgZm9yIGluZGV4ZWQgYXhpcyBhbmQgdGltZXNlcmllcyBheGlzXHJcbiAgICAgKiAtIGZhbHNlIGZvciBjYXRlZ29yeSBheGlzXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY3VsbGluZzogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfY3VsbGluZzoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpY2sgdGV4dHMgd2lsbCBiZSBhZGp1c3RlZCB0byBsZXNzIHRoYW4gdGhpcyB2YWx1ZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGN1bGxpbmfigKRtYXhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMTBcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjdWxsaW5nOiB7XHJcbiAgICAgKiAgICAgICAgICAgbWF4OiA1XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX2N1bGxpbmdfbWF4OiAxMCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgeCBheGlzIHRpY2tzIHRvIHNob3cuPGJyPjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIGhpZGVzIHRpY2sgbGluZXMgdG9nZXRoZXIgd2l0aCB0aWNrIHRleHQuIElmIHRoaXMgb3B0aW9uIGlzIHVzZWQgb24gdGltZXNlcmllcyBheGlzLCB0aGUgdGlja3MgcG9zaXRpb24gd2lsbCBiZSBkZXRlcm1pbmVkIHByZWNpc2VseSBhbmQgbm90IG5pY2VseSBwb3NpdGlvbmVkIChlLmcuIGl0IHdpbGwgaGF2ZSByb3VnaCBzZWNvbmQgdmFsdWUpLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkY291bnRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY291bnQ6IDVcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfY291bnQ6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayBsaW5lLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHggYXhpcyB0aWNrIHRleHQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR0ZXh04oCkc2hvd1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuSGlkZVRpY2tMaW5lVGV4dClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB4IEF4aXMgdGljayB0ZXh0J3MgcG9zaXRpb24gcmVsYXRpdmVseSBpdHMgb3JpZ2luYWwgcG9zaXRpb25cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIHRleHQ6IHtcclxuICAgICAqICAgICAgICAgcG9zaXRpb246IHtcclxuICAgICAqICAgICAgICAgICB4OiAxMCxcclxuICAgICAqICAgICAgICAgICB5OiAxMFxyXG4gICAgICogICAgICAgICB9XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX3RleHRfcG9zaXRpb246IHt4OiAwLCB5OiAwfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZpdCB4IGF4aXMgdGlja3MuXHJcbiAgICAgKiAtICoqdHJ1ZSoqOiB0aWNrcyB3aWxsIGJlIHBvc2l0aW9uZWQgbmljZWx5IHRvIGhhdmUgc2FtZSBpbnRlcnZhbHMuXHJcbiAgICAgKiAtICoqZmFsc2UqKjogdGlja3Mgd2lsbCBiZSBwb3NpdGlvbmVkIGFjY29yZGluZyB0byB4IHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApGZpdFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuWEF4aXNUaWNrRml0dGluZylcclxuICAgICAqIEBzZWUgW0RlbW86IGZvciB0aW1lc2VyaWVzIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlhBeGlzVGlja1RpbWVzZXJpZXMpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgZml0OiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19maXQ6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHggdmFsdWVzIG9mIHRpY2tzIG1hbnVhbGx5Ljxicj48YnI+XHJcbiAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBwcm92aWRlZCwgdGhlIHBvc2l0aW9uIG9mIHRoZSB0aWNrcyB3aWxsIGJlIGRldGVybWluZWQgYmFzZWQgb24gdGhvc2UgdmFsdWVzLjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIHdvcmtzIHdpdGggYHRpbWVzZXJpZXNgIGRhdGEgYW5kIHRoZSB4IHZhbHVlcyB3aWxsIGJlIHBhcnNlZCBhY2NvZGluZyB0byB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYW5kIGRhdGEueEZvcm1hdCBvcHRpb24uXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHRpY2vigKR2YWx1ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdmFsdWVzOiBbMSwgMiwgNCwgOCwgMTYsIDMyLCAuLi5dLFxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIGFuIEFycmF5IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZFxyXG4gICAgICogICAgICAgdmFsdWVzOiBmdW5jdGlvbigpIHtcclxuICAgICAqICAgICAgIFx0cmV0dXJuIFsgLi4uIF07XHJcbiAgICAgKiAgICAgICB9XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF90aWNrX3ZhbHVlczogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZSB4IGF4aXMgdGljayB0ZXh0LlxyXG4gICAgICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcbiAgICAgKiAtIEFwcGxpZWQgd2hlbiBbYGF4aXMucm90YXRlZGBdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHJvdGF0ZWQpIG9wdGlvbiBpcyBgZmFsc2VgLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkcm90YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlJvdGF0ZVhBeGlzVGlja1RleHQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgcm90YXRlOiA2MFxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja19yb3RhdGU6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHggYXhpcyBvdXRlciB0aWNrLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkb3V0ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBvdXRlcjogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfb3V0ZXI6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGljayB0ZXh0IHRvIGJlIG11bHRpbGluZVxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrIGFuZCAnYXhpcy54LnRpY2sud2lkdGgnIG9wdGlvbiBpcyBpZ25vcmVkLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKR0aWNr4oCkbXVsdGlsaW5lXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5YQXhpc1RpY2tNdWx0aWxpbmUpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgbXVsdGlsaW5lOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGV4YW1wbGUgb2YgbGluZSBicmVhayB3aXRoICdcXG4nXHJcbiAgICAgKiAvLyBJbiB0aGlzIGNhc2UsICdheGlzLngudGljay53aWR0aCcgaXMgaWdub3JlZFxyXG4gICAgICogZGF0YToge1xyXG4gICAgICogICAgeDogXCJ4XCIsXHJcbiAgICAgKiAgICBjb2x1bW5zOiBbXHJcbiAgICAgKiAgICAgICAgW1wieFwiLCBcImxvbmdcXG50ZXh0XCIsIFwiQW5vdGhlclxcbkxvbmdcXG5UZXh0XCJdLFxyXG4gICAgICogICAgICAgIC4uLlxyXG4gICAgICogICAgXSxcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfbXVsdGlsaW5lOiB0cnVlLFxyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aWNrIHdpZHRoXHJcbiAgICAgKiAtICoqTk9URToqKlxyXG4gICAgICogID4gV2hlbiB4IHRpY2sgdGV4dCBjb250YWlucyBgXFxuYCwgdGhpcyBvcHRpb24gaXMgaWdub3JlZC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHdpZHRoXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB3aWR0aDogNTBcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3RpY2tfd2lkdGg6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdG8gZGlzcGxheSBzeXN0ZW0gdG9vbHRpcCh2aWEgJ3RpdGxlJyBhdHRyaWJ1dGUpIGZvciB0aWNrIHRleHRcclxuICAgICAqIC0gKipOT1RFOioqIE9ubHkgYXZhaWxhYmxlIGZvciBjYXRlZ29yeSBheGlzIHR5cGUgKGBheGlzLngudHlwZT0nY2F0ZWdvcnknYClcclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkdGlja+KApHRvb2x0aXBcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdG9vbHRpcDogdHJ1ZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfdGlja190b29sdGlwOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtYXggdmFsdWUgb2YgeCBheGlzIHJhbmdlLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRtYXhcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgbWF4OiAxMDBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfbWF4OiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbWluIHZhbHVlIG9mIHggYXhpcyByYW5nZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR44oCkbWluXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIG1pbjogLTEwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9taW46IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBwYWRkaW5nIGZvciB4IGF4aXMuPGJyPjxicj5cclxuICAgICAqIElmIHRoaXMgb3B0aW9uIGlzIHNldCwgdGhlIHJhbmdlIG9mIHggYXhpcyB3aWxsIGluY3JlYXNlL2RlY3JlYXNlIGFjY29yZGluZyB0byB0aGUgdmFsdWVzLlxyXG4gICAgICogSWYgbm8gcGFkZGluZyBpcyBuZWVkZWQgaW4gdGhlIHJhZ2Ugb2YgeCBheGlzLCAwIHNob3VsZCBiZSBzZXQuXHJcbiAgICAgKiAtICoqTk9URToqKlxyXG4gICAgICogICBUaGUgcGFkZGluZyB2YWx1ZXMgYXJlbid0IGJhc2VkIG9uIHBpeGVscy4gSXQgZGlmZmVycyBhY2NvcmRpbmcgYXhpcyB0eXBlczxicj5cclxuICAgICAqICAgLSAqKmNhdGVnb3J5OioqIFRoZSB1bml0IG9mIHRpY2sgdmFsdWVcclxuICAgICAqICAgICBleC4gdGhlIGdpdmVuIHZhbHVlIGAxYCwgaXMgc2FtZSBhcyB0aGUgd2lkdGggb2YgMSB0aWNrIHdpZHRoXHJcbiAgICAgKiAgIC0gKip0aW1lc2VyaWVzOioqIE51bWVyaWMgdGltZSB2YWx1ZVxyXG4gICAgICogICAgIGV4LiB0aGUgZ2l2ZW4gdmFsdWUgYDEwMDAqNjAqNjAqMjRgLCB3aGljaCBpcyBudW1lcmljIHRpbWUgZXF1aXZhbGVudCBvZiBhIGRheSwgaXMgc2FtZSBhcyB0aGUgd2lkdGggb2YgMSB0aWNrIHdpZHRoXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApHBhZGRpbmdcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fE51bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB4OiB7XHJcbiAgICAgKiAgICAgcGFkZGluZzoge1xyXG4gICAgICogICAgICAgLy8gd2hlbiBheGlzIHR5cGUgaXMgJ2NhdGVnb3J5J1xyXG4gICAgICogICAgICAgbGVmdDogMSwgIC8vIHNldCBsZWZ0IHBhZGRpbmcgd2lkdGggb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIHRpY2sncyB3aWR0aFxyXG4gICAgICogICAgICAgcmlnaHQ6IDAuNSAgLy8gc2V0IHJpZ2h0IHBhZGRpbmcgd2lkdGggYXMgaGFsZiBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIHRpY2sncyB3aWR0aFxyXG4gICAgICpcclxuICAgICAqICAgICAgIC8vIHdoZW4gYXhpcyB0eXBlIGlzICd0aW1lc2VyaWVzJ1xyXG4gICAgICogICAgICAgbGVmdDogMTAwMCo2MCo2MCoyNCwgIC8vIHNldCBsZWZ0IHBhZGRpbmcgd2lkdGggb2YgZXF1aXZhbGVudCB2YWx1ZSBvZiBhIGRheSB0aWNrJ3Mgd2lkdGhcclxuICAgICAqICAgICAgIHJpZ2h0OiAxMDAwKjYwKjYwKjEyICAgLy8gc2V0IHJpZ2h0IHBhZGRpbmcgd2lkdGggYXMgaGFsZiBvZiBlcXVpdmFsZW50IHZhbHVlIG9mIGEgZGF5IHRpY2sncyB3aWR0aFxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIG9yIHNldCBib3RoIHZhbHVlcyBhdCBvbmNlLlxyXG4gICAgICogICAgIHBhZGRpbmc6IDEwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X3BhZGRpbmc6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGhlaWdodCBvZiB4IGF4aXMuPGJyPjxicj5cclxuICAgICAqIFRoZSBoZWlnaHQgb2YgeCBheGlzIGNhbiBiZSBzZXQgbWFudWFsbHkgYnkgdGhpcyBvcHRpb24uIElmIHlvdSBuZWVkIG1vcmUgc3BhY2UgZm9yIHggYXhpcywgcGxlYXNlIHVzZSB0aGlzIG9wdGlvbiBmb3IgdGhhdC4gVGhlIHVuaXQgaXMgcGl4ZWwuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGhlaWdodFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBoZWlnaHQ6IDIwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X2hlaWdodDogdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGRlZmF1bHQgZXh0ZW50IGZvciBzdWJjaGFydCBhbmQgem9vbS4gVGhpcyBjYW4gYmUgYW4gYXJyYXkgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGFycmF5LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRleHRlbnRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICAvLyBleHRlbnQgcmFuZ2UgYXMgYSBwaXhlbCB2YWx1ZVxyXG4gICAgICogICAgIGV4dGVudDogWzAsIDIwMF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHdoZW4gYXhpcyBpcyAndGltZXNlcmllcycsIHBhcnNhYmxlIGRhdGV0aW1lIHN0cmluZ1xyXG4gICAgICogICAgIGV4dGVudDogW1wiMjAxOS0wMy0wMVwiLCBcIjIwMTktMDMtMDVcIl0sXHJcbiAgICAgKlxyXG4gICAgICogICAgIC8vIHJldHVybiBleHRlbnQgdmFsdWVcclxuICAgICAqICAgICBleHRlbnQ6IGZ1bmN0aW9uKGRvbWFpbiwgc2NhbGUpIHtcclxuICAgICAqICAgIFx0IHZhciBleHRlbnQgPSBkb21haW4ubWFwKGZ1bmN0aW9uKHYpIHtcclxuICAgICAqICAgICBcdCAgICByZXR1cm4gc2NhbGUodik7XHJcbiAgICAgKiAgICAgXHQgfSk7XHJcbiAgICAgKlxyXG4gICAgICogICBcdCAvLyBpdCBzaG91bGQgcmV0dXJuIGEgZm9ybWF0IG9mIGFycmF5XHJcbiAgICAgKiAgIFx0IC8vIGV4KSBbMCwgNTg0XVxyXG4gICAgICogICAgIFx0IHJldHVybiBleHRlbnQ7XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeF9leHRlbnQ6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBsYWJlbCBvbiB4IGF4aXMuPGJyPjxicj5cclxuICAgICAqIFlvdSBjYW4gc2V0IHggYXhpcyBsYWJlbCBhbmQgY2hhbmdlIGl0cyBwb3NpdGlvbiBieSB0aGlzIG9wdGlvbi5cclxuICAgICAqIGBzdHJpbmdgIGFuZCBgb2JqZWN0YCBjYW4gYmUgcGFzc2VkIGFuZCB3ZSBjYW4gY2hhbmdlIHRoZSBwb2lzaXRvbiBieSBwYXNzaW5nIG9iamVjdCB0aGF0IGhhcyBwb3NpdGlvbiBrZXkuPGJyPlxyXG4gICAgICogQXZhaWxhYmxlIHBvc2l0aW9uIGRpZmZlcnMgYWNjb3JkaW5nIHRvIHRoZSBheGlzIGRpcmVjdGlvbiAodmVydGljYWwgb3IgaG9yaXpvbnRhbCkuXHJcbiAgICAgKiBJZiBzdHJpbmcgc2V0LCB0aGUgcG9zaXRpb24gd2lsbCBiZSB0aGUgZGVmYXVsdC5cclxuICAgICAqXHJcbiAgICAgKiAgLSAqKklmIGl0J3MgaG9yaXpvbnRhbCBheGlzOioqXHJcbiAgICAgKiAgICAtIGlubmVyLXJpZ2h0IFtkZWZhdWx0XVxyXG4gICAgICogICAgLSBpbm5lci1jZW50ZXJcclxuICAgICAqICAgIC0gaW5uZXItbGVmdFxyXG4gICAgICogICAgLSBvdXRlci1yaWdodFxyXG4gICAgICogICAgLSBvdXRlci1jZW50ZXJcclxuICAgICAqICAgIC0gb3V0ZXItbGVmdFxyXG4gICAgICogIC0gKipJZiBpdCdzIHZlcnRpY2FsIGF4aXM6KipcclxuICAgICAqICAgIC0gaW5uZXItdG9wIFtkZWZhdWx0XVxyXG4gICAgICogICAgLSBpbm5lci1taWRkbGVcclxuICAgICAqICAgIC0gaW5uZXItYm90dG9tXHJcbiAgICAgKiAgICAtIG91dGVyLXRvcFxyXG4gICAgICogICAgLSBvdXRlci1taWRkbGVcclxuICAgICAqICAgIC0gb3V0ZXItYm90dG9tXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeOKApGxhYmVsXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ3xPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBsYWJlbDogXCJZb3VyIFggQXhpc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHg6IHtcclxuICAgICAqICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgIHRleHQ6IFwiWW91ciBYIEF4aXNcIixcclxuICAgICAqICAgICAgICBwb3NpdGlvbjogXCJvdXRlci1jZW50ZXJcIlxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3hfbGFiZWw6IHt9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeCBBeGlzLlxyXG4gICAgICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geCBBeGlzIHZhbHVlIGlmIGRvbWFpbiBvcHRpb24gaXNuJ3Qgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggYXhpcyBvYmplY3Qgc2hvdWxkIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgb3B0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiB8IE5hbWUgfCBUeXBlIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuICAgICAqIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuICAgICAqIHwgZG9tYWluIHwgQXJyYXkgfCAtIHwgU2V0IHRoZSBkb21haW4gdmFsdWUgfFxyXG4gICAgICogfCB0aWNrLm91dGVyIHwgQm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxyXG4gICAgICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XHJcbiAgICAgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcclxuICAgICAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxyXG4gICAgICogQG5hbWUgYXhpc+KApHjigKRheGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxyXG4gICAgICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogeDoge1xyXG4gICAgICogICAgYXhlczogW1xyXG4gICAgICogICAgICB7XHJcbiAgICAgKiAgICAgICAgLy8gaWYgc2V0LCB3aWxsIG5vdCBiZSBjb3JyZWxhdGVkIHdpdGggdGhlIG1haW4geCBBeGlzIGRvbWFpbiB2YWx1ZVxyXG4gICAgICogICAgICAgIGRvbWFpbjogWzAsIDEwMDBdLFxyXG4gICAgICogICAgICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcclxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG4gICAgICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICBjb3VudDogMixcclxuICAgICAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXHJcbiAgICAgKiAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICAuLi5cclxuICAgICAqICAgIF1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc194X2F4ZXM6IFtdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHkgQXhpcyAgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNsaXAtcGF0aCBhdHRyaWJ1dGUgZm9yIHkgYXhpcyBlbGVtZW50XHJcbiAgICAgKiAtICoqTk9URSoqOiBgY2xpcC1wYXRoYCBhdHRyaWJ1dGUgZm9yIHkgQXhpcyBpcyBzZXQgb25seSB3aGVuIGBheGlzLnkuaW5uZXJgIG9wdGlvbiBpcyB0cnVlLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRjbGlwUGF0aFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuICAgICAqIGNsaXBQYXRoOiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfY2xpcFBhdGg6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG9yIGhpZGUgeSBheGlzLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0eXBlIG9mIHkgYXhpcy48YnI+PGJyPlxyXG4gICAgICogKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAgIC0gdGltZXNlcmllc1xyXG4gICAgICogICAtIGNhdGVnb3J5XHJcbiAgICAgKiAgIC0gaW5kZXhlZFxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0eXBlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge1N0cmluZ31cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHR5cGU6IFwidGltZXNlcmllc1wiXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3R5cGU6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtYXggdmFsdWUgb2YgeSBheGlzLlxyXG4gICAgICogLSAqKk5PVEU6KiogUGFkZGluZyB3aWxsIGJlIGFkZGVkIGJhc2VkIG9uIHRoaXMgdmFsdWUsIHNvIGlmIHlvdSBkb24ndCBuZWVkIHRoZSBwYWRkaW5nLCBwbGVhc2Ugc2V0IGF4aXMueS5wYWRkaW5nIHRvIGRpc2FibGUgaXQgKGUuZy4gYXhpcy55LnBhZGRpbmcgPSAwKS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkbWF4XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIG1heDogMTAwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV9tYXg6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtaW4gdmFsdWUgb2YgeSBheGlzLlxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICAgUGFkZGluZyB3aWxsIGJlIGFkZGVkIGJhc2VkIG9uIHRoaXMgdmFsdWUsIHNvIGlmIHlvdSBkb24ndCBuZWVkIHRoZSBwYWRkaW5nLCBwbGVhc2Ugc2V0IGF4aXMueS5wYWRkaW5nIHRvIGRpc2FibGUgaXQgKGUuZy4gYXhpcy55LnBhZGRpbmcgPSAwKS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkbWluXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIG1pbjogMTAwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV9taW46IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZSB0aGUgZGlyZWN0aW9uIG9mIHkgYXhpcy48YnI+PGJyPlxyXG4gICAgICogSWYgdHJ1ZSBzZXQsIHRoZSBkaXJlY3Rpb24gd2lsbCBiZSBmcm9tIHRoZSB0b3AgdG8gdGhlIGJvdHRvbS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkaW52ZXJ0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgaW52ZXJ0ZWQ6IHRydWVcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfaW52ZXJ0ZWQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNlbnRlciB2YWx1ZSBvZiB5IGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGNlbnRlclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICBjZW50ZXI6IDBcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfY2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHkgYXhpcyBpbnNpZGUgb2YgdGhlIGNoYXJ0LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRpbm5lclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICBpbm5lcjogdHJ1ZVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV9pbm5lcjogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbGFiZWwgb24geSBheGlzLjxicj48YnI+XHJcbiAgICAgKiBZb3UgY2FuIHNldCB5IGF4aXMgbGFiZWwgYW5kIGNoYW5nZSBpdHMgcG9zaXRpb24gYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRsYWJlbFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtTdHJpbmd8T2JqZWN0fVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBzZWUgW2F4aXMueC5sYWJlbF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0eCUyNUUyJTI1ODAlMjVBNGxhYmVsKSBmb3IgcG9zaXRpb24gc3RyaW5nIHZhbHVlLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIGxhYmVsOiBcIllvdXIgWSBBeGlzXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIGxhYmVsOiB7XHJcbiAgICAgKiAgICAgICAgdGV4dDogXCJZb3VyIFkgQXhpc1wiLFxyXG4gICAgICogICAgICAgIHBvc2l0aW9uOiBcIm91dGVyLW1pZGRsZVwiXHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV9sYWJlbDoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZm9ybWF0dGVyIGZvciB5IGF4aXMgdGljayB0ZXh0Ljxicj48YnI+XHJcbiAgICAgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGQzLmZvcm1hdCBvYmplY3QgYXMgd2VsbCBhcyBhIGZ1bmN0aW9uIHlvdSBkZWZpbmUuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRmb3JtYXRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAqICAgICAgICAgICByZXR1cm4geC5nZXRGdWxsWWVhcigpO1xyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19mb3JtYXQ6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldHRpbmcgZm9yIGN1bGxpbmcgdGlja3MuPGJyPjxicj5cclxuICAgICAqIElmIHRydWUgaXMgc2V0LCB0aGUgdGlja3Mgd2lsbCBiZSBjdWxsZWQsIHRoZW4gb25seSBsaW1pdHRlZCB0aWNrIHRleHQgd2lsbCBiZSBzaG93bi4gVGhpcyBvcHRpb24gZG9lcyBub3QgaGlkZSB0aGUgdGljayBsaW5lcy4gSWYgZmFsc2UgaXMgc2V0LCBhbGwgb2YgdGlja3Mgd2lsbCBiZSBzaG93bi48YnI+PGJyPlxyXG4gICAgICogV2UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRpY2tzIHRvIGJlIHNob3duIGJ5IGF4aXMueS50aWNrLmN1bGxpbmcubWF4LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY3VsbGluZ1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjdWxsaW5nOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19jdWxsaW5nOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGljayB0ZXh0cyB3aWxsIGJlIGFkanVzdGVkIHRvIGxlc3MgdGhhbiB0aGlzIHZhbHVlLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkY3VsbGluZ+KApG1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCA1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY3VsbGluZzoge1xyXG4gICAgICogICAgICAgICAgIG1heDogNVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19jdWxsaW5nX21heDogNSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgeSBheGlzIG91dGVyIHRpY2suXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKRvdXRlclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIG91dGVyOiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19vdXRlcjogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB5IGF4aXMgdGljayB2YWx1ZXMgbWFudWFsbHkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKR2YWx1ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl8RnVuY3Rpb259XHJcbiAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdmFsdWVzOiBbMTAwLCAxMDAwLCAxMDAwMF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gYW4gQXJyYXkgdmFsdWUgc2hvdWxkIGJlIHJldHVybmVkXHJcbiAgICAgKiAgICAgICB2YWx1ZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICogICAgICAgXHRyZXR1cm4gWyAuLi4gXTtcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3RpY2tfdmFsdWVzOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIHkgYXhpcyB0aWNrIHRleHQuXHJcbiAgICAgKiAtIElmIHlvdSBzZXQgbmVnYXRpdmUgdmFsdWUsIGl0IHdpbGwgcm90YXRlIHRvIG9wcG9zaXRlIGRpcmVjdGlvbi5cclxuICAgICAqIC0gQXBwbGllZCB3aGVuIFtgYXhpcy5yb3RhdGVkYF0oIy5heGlzJTI1RTIlMjU4MCUyNUE0cm90YXRlZCkgb3B0aW9uIGlzIGB0cnVlYC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHJvdGF0ZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgcm90YXRlOiA2MFxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19yb3RhdGU6IDAsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG51bWJlciBvZiB5IGF4aXMgdGlja3MuPGJyPjxicj5cclxuICAgICAqIC0gKipOT1RFOioqIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGlja3Mgd2lsbCBiZSBjYWxjdWxhdGVkIHByZWNpc2VseSwgc28gdGhlIHZhbHVlcyBvbiB0aGUgdGlja3Mgd2lsbCBub3QgYmUgcm91bmRlZCBuaWNlbHkuIEluIHRoZSBjYXNlLCBheGlzLnkudGljay5mb3JtYXQgb3IgYXhpcy55LnRpY2sudmFsdWVzIHdpbGwgYmUgaGVscGZ1bC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApGNvdW50XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeToge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIGNvdW50OiA1XHJcbiAgICAgKiAgICAgfVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV90aWNrX2NvdW50OiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IG9yIGhpZGUgeSBheGlzIHRpY2sgbGluZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHNob3dcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3RpY2tfc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBheGlzIHRpY2sgc3RlcChpbnRlcnZhbCkgc2l6ZS5cclxuICAgICAqIC0gKipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgYXhpcy55LnRpY2suY291bnRgIG9yIGBheGlzLnkudGljay52YWx1ZXNgIG9wdGlvbnMgYXJlIHNldC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHN0ZXBTaXplXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlN0ZXBTaXplRm9yWUF4aXMpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgLy8gdGljayB2YWx1ZSB3aWxsIHN0ZXAgYXMgaW5kaWNhdGVkIGludGVydmFsIHZhbHVlLlxyXG4gICAgICogICAgICAgLy8gZXgpICdzdGVwU2l6ZT0xNScgPT0+IFswLCAxNSwgMzAsIDQ1LCA2MF1cclxuICAgICAqICAgICAgIHN0ZXBTaXplOiAxNVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfdGlja19zdGVwU2l6ZTogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICogU2hvdyBvciBoaWRlIHkgYXhpcyB0aWNrIHRleHQuXHJcbiAgICAqIEBuYW1lIGF4aXPigKR54oCkdGlja+KApHRleHTigKRzaG93XHJcbiAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLkhpZGVUaWNrTGluZVRleHQpXHJcbiAgICAqIEBleGFtcGxlXHJcbiAgICAqIGF4aXM6IHtcclxuICAgICogICB5OiB7XHJcbiAgICAqICAgICB0aWNrOiB7XHJcbiAgICAqICAgICAgIHRleHQ6IHtcclxuICAgICogICAgICAgICAgIHNob3c6IGZhbHNlXHJcbiAgICAqICAgICAgIH1cclxuICAgICogICAgIH1cclxuICAgICogICB9XHJcbiAgICAqIH1cclxuICAgICovXHJcbiAgICBheGlzX3lfdGlja190ZXh0X3Nob3c6IHRydWUsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHkgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKR0aWNr4oCkdGV4dOKApHBvc2l0aW9uXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt4OiAwLCB5OjB9XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgICAgIHg6IDEwLFxyXG4gICAgICogICAgICAgICAgIHk6IDEwXHJcbiAgICAgKiAgICAgICAgIH1cclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzLjxicj48YnI+XHJcbiAgICAgKiAtICoqTk9URToqKiBUaGUgcG9zaXRpb24gb2YgdGhlIHRpY2tzIHdpbGwgYmUgY2FsY3VsYXRlZCBwcmVjaXNlbHksIHNvIHRoZSB2YWx1ZXMgb24gdGhlIHRpY2tzIHdpbGwgbm90IGJlIHJvdW5kZWQgbmljZWx5LiBJbiB0aGUgY2FzZSwgYXhpcy55LnRpY2suZm9ybWF0IG9yIGF4aXMueS50aWNrLnZhbHVlcyB3aWxsIGJlIGhlbHBmdWwuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApHRpY2vigKR0aW1lXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdGltZS52YWx1ZV0gRDMncyB0aW1lIGludGVydmFsIGZ1bmN0aW9uIChodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtdGltZSNpbnRlcnZhbHMpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgdGltZToge1xyXG4gICAgICogICAgICAgICAgLy8gdGlja3MgYXQgMTUtbWludXRlIGludGVydmFsc1xyXG4gICAgICogICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLXNjYWxlL2Jsb2IvbWFzdGVyL1JFQURNRS5tZCN0aW1lX3RpY2tzXHJcbiAgICAgKiAgICAgICAgICB2YWx1ZTogZDMudGltZU1pbnV0ZS5ldmVyeSgxNSlcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgLy8gQFRPRE86IG5vdCBmdWxseSBpbXBsZW1lbnRlZCB5ZXRcclxuICAgIGF4aXNfeV90aWNrX3RpbWVfdmFsdWU6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBwYWRkaW5nIGZvciB5IGF4aXMuPGJyPjxicj5cclxuICAgICAqIFlvdSBjYW4gc2V0IHBhZGRpbmcgZm9yIHkgYXhpcyB0byBjcmVhdGUgbW9yZSBzcGFjZSBvbiB0aGUgZWRnZSBvZiB0aGUgYXhpcy5cclxuICAgICAqIFRoaXMgb3B0aW9uIGFjY2VwdHMgb2JqZWN0IGFuZCBpdCBjYW4gaW5jbHVkZSB0b3AgYW5kIGJvdHRvbS4gdG9wLCBib3R0b20gd2lsbCBiZSB0cmVhdGVkIGFzIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiAtICoqTk9URToqKiBGb3IgYXJlYSBhbmQgYmFyIHR5cGUgY2hhcnRzLCBbYXJlYS56ZXJvYmFzZWRdKCMuYXJlYSkgb3IgW2Jhci56ZXJvYmFzZWRdKCMuYmFyKSBvcHRpb25zIHNob3VsZCBiZSBzZXQgdG8gJ2ZhbHNlYCB0byBnZXQgcGFkZGVkIGJvdHRvbS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR54oCkcGFkZGluZ1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R8TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICBwYWRkaW5nOiB7XHJcbiAgICAgKiAgICAgICB0b3A6IDAsXHJcbiAgICAgKiAgICAgICBib3R0b206IDBcclxuICAgICAqICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAvLyBvciBzZXQgYm90aCB2YWx1ZXMgYXQgb25jZS5cclxuICAgICAqICAgICBwYWRkaW5nOiAxMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeV9wYWRkaW5nOiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBkZWZhdWx0IHJhbmdlIG9mIHkgYXhpcy48YnI+PGJyPlxyXG4gICAgICogVGhpcyBvcHRpb24gc2V0IHRoZSBkZWZhdWx0IHZhbHVlIGZvciB5IGF4aXMgd2hlbiB0aGVyZSBpcyBubyBkYXRhIG9uIGluaXQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeeKApGRlZmF1bHRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHk6IHtcclxuICAgICAqICAgICBkZWZhdWx0OiBbMCwgMTAwMF1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3lfZGVmYXVsdDogdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGFkZGl0aW9uYWwgYXhlcyBmb3IgeSBBeGlzLlxyXG4gICAgICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geSBBeGlzIHZhbHVlIGlmIGRvbWFpbiBvcHRpb24gaXNuJ3Qgc2V0LlxyXG4gICAgICpcclxuICAgICAqIEVhY2ggYXhpcyBvYmplY3Qgc2hvdWxkIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgb3B0aW9uczpcclxuICAgICAqXHJcbiAgICAgKiB8IE5hbWUgfCBUeXBlIHwgRGVmYXVsdCB8IERlc2NyaXB0aW9uIHxcclxuICAgICAqIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuICAgICAqIHwgZG9tYWluIHwgQXJyYXkgfCAtIHwgU2V0IHRoZSBkb21haW4gdmFsdWUgfFxyXG4gICAgICogfCB0aWNrLm91dGVyIHwgQm9vbGVhbiB8IHRydWUgfCBTaG93IG91dGVyIHRpY2sgfFxyXG4gICAgICogfCB0aWNrLmZvcm1hdCB8IEZ1bmN0aW9uIHwgLSB8IFNldCBmb3JtYXR0ZXIgZm9yIHRpY2sgdGV4dCB8XHJcbiAgICAgKiB8IHRpY2suY291bnQgfCBOdW1iZXIgfCAtIHwgU2V0IHRoZSBudW1iZXIgb2YgeSBheGlzIHRpY2tzIHxcclxuICAgICAqIHwgdGljay52YWx1ZXMgfCBBcnJheSB8IC0gfCBTZXQgdGljayB2YWx1ZXMgbWFudWFsbHkgfFxyXG4gICAgICogQG5hbWUgYXhpc+KApHnigKRheGVzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fVxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0F4aXMuTXVsdGlBeGVzKVxyXG4gICAgICogQHNlZSBbRGVtbzogRG9tYWluXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXNEb21haW4pXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogeToge1xyXG4gICAgICogICAgYXhlczogW1xyXG4gICAgICogICAgICB7XHJcbiAgICAgKiAgICAgICAgLy8gaWYgc2V0LCB3aWxsIG5vdCBiZSBjb3JyZWxhdGVkIHdpdGggdGhlIG1haW4geSBBeGlzIGRvbWFpbiB2YWx1ZVxyXG4gICAgICogICAgICAgIGRvbWFpbjogWzAsIDEwMDBdLFxyXG4gICAgICogICAgICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgICAgIG91dGVyOiBmYWxzZSxcclxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG4gICAgICogICAgICAgICAgICAgcmV0dXJuIHggKyBcIiVcIjtcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICBjb3VudDogMixcclxuICAgICAqICAgICAgICAgIHZhbHVlczogWzEwLCAyMCwgMzBdXHJcbiAgICAgKiAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICAuLi5cclxuICAgICAqICAgIF1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195X2F4ZXM6IFtdXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHkyIEF4aXMgIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB5MiBheGlzLlxyXG4gICAgICogLSAqKk5PVEUqKjpcclxuICAgICAqICAgLSBXaGVuIHNldCB0byBgZmFsc2VgIHdpbGwgbm90IGdlbmVyYXRlIHkyIGF4aXMgbm9kZS4gSW4gdGhpcyBjYXNlLCBhbGwgJ3kyJyBheGlzIHJlbGF0ZWQgZnVuY3Rpb25hbGl0eSB3b24ndCB3b3JrIHByb3Blcmx5LlxyXG4gICAgICogICAtIElmIG5lZWQgdG8gdXNlICd5MicgcmVsYXRlZCBvcHRpb25zIHdoaWxlIHkyIGlzbid0IHZpc2libGUsIHNldCB0aGUgdmFsdWUgYHRydWVgIGFuZCBjb250cm9sIHZpc2liaWxpdHkgYnkgY3NzIGRpc3BsYXkgcHJvcGVydHkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICBzaG93OiB0cnVlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9zaG93OiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtYXggdmFsdWUgb2YgeTIgYXhpcy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApG1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgbWF4OiAxMDAwXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9tYXg6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBtaW4gdmFsdWUgb2YgeTIgYXhpcy5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApG1pblxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgbWluOiAtMTAwMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfbWluOiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2UgdGhlIGRpcmVjdGlvbiBvZiB5MiBheGlzLjxicj48YnI+XHJcbiAgICAgKiBJZiB0cnVlIHNldCwgdGhlIGRpcmVjdGlvbiB3aWxsIGJlIGZyb20gdGhlIHRvcCB0byB0aGUgYm90dG9tLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkaW52ZXJ0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIGludmVydGVkOiB0cnVlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9pbnZlcnRlZDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY2VudGVyIHZhbHVlIG9mIHkyIGF4aXMuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKRjZW50ZXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIGNlbnRlcjogMFxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfY2VudGVyOiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93IHkyIGF4aXMgaW5zaWRlIG9mIHRoZSBjaGFydC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGlubmVyXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICBpbm5lcjogdHJ1ZVxyXG4gICAgICogICB9XHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfaW5uZXI6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGxhYmVsIG9uIHkyIGF4aXMuPGJyPjxicj5cclxuICAgICAqIFlvdSBjYW4gc2V0IHkyIGF4aXMgbGFiZWwgYW5kIGNoYW5nZSBpdHMgcG9zaXRpb24gYnkgdGhpcyBvcHRpb24uIFRoaXMgb3B0aW9uIHdvcmtzIGluIHRoZSBzYW1lIHdheSBhcyBbYXhpcy54LmxhYmVsXSgjLmF4aXMlMjVFMiUyNTgwJTI1QTR4JTI1RTIlMjU4MCUyNUE0bGFiZWwpLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkbGFiZWxcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfE9iamVjdH1cclxuICAgICAqIEBkZWZhdWx0IHt9XHJcbiAgICAgKiBAc2VlIFtheGlzLngubGFiZWxdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHglMjVFMiUyNTgwJTI1QTRsYWJlbCkgZm9yIHBvc2l0aW9uIHN0cmluZyB2YWx1ZS5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgbGFiZWw6IFwiWW91ciBZMiBBeGlzXCJcclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICpcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgIHRleHQ6IFwiWW91ciBZMiBBeGlzXCIsXHJcbiAgICAgKiAgICAgICAgcG9zaXRpb246IFwib3V0ZXItbWlkZGxlXCJcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9sYWJlbDoge30sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZm9ybWF0dGVyIGZvciB5MiBheGlzIHRpY2sgdGV4dC48YnI+PGJyPlxyXG4gICAgICogVGhpcyBvcHRpb24gd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS5mb3JtYXQuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkZm9ybWF0XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIGZvcm1hdDogZDMuZm9ybWF0KFwiJCxcIilcclxuICAgICAqICAgICAgIC8vb3IgZm9ybWF0OiBmdW5jdGlvbihkKSB7IHJldHVybiBcIiRcIiArIGQ7IH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX2Zvcm1hdDogdW5kZWZpbmVkLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0dGluZyBmb3IgY3VsbGluZyB0aWNrcy48YnI+PGJyPlxyXG4gICAgICogSWYgdHJ1ZSBpcyBzZXQsIHRoZSB0aWNrcyB3aWxsIGJlIGN1bGxlZCwgdGhlbiBvbmx5IGxpbWl0dGVkIHRpY2sgdGV4dCB3aWxsIGJlIHNob3duLiBUaGlzIG9wdGlvbiBkb2VzIG5vdCBoaWRlIHRoZSB0aWNrIGxpbmVzLiBJZiBmYWxzZSBpcyBzZXQsIGFsbCBvZiB0aWNrcyB3aWxsIGJlIHNob3duLjxicj48YnI+XHJcbiAgICAgKiBXZSBjYW4gY2hhbmdlIHRoZSBudW1iZXIgb2YgdGlja3MgdG8gYmUgc2hvd24gYnkgYXhpcy55LnRpY2suY3VsbGluZy5tYXguXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY3VsbGluZ1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgY3VsbGluZzogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX2N1bGxpbmc6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0aWNrIHRleHRzIHdpbGwgYmUgYWRqdXN0ZWQgdG8gbGVzcyB0aGFuIHRoaXMgdmFsdWUuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkY3VsbGluZ+KApG1heFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCA1XHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIGN1bGxpbmc6IHtcclxuICAgICAqICAgICAgICAgICBtYXg6IDVcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX2N1bGxpbmdfbWF4OiA1LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHkyIGF4aXMgb3V0ZXIgdGljay5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRvdXRlclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtCb29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBvdXRlcjogZmFsc2VcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX291dGVyOiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHkyIGF4aXMgdGljayB2YWx1ZXMgbWFudWFsbHkuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkdmFsdWVzXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0FycmF5fEZ1bmN0aW9ufVxyXG4gICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB2YWx1ZXM6IFsxMDAsIDEwMDAsIDEwMDAwXSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAvLyBhbiBBcnJheSB2YWx1ZSBzaG91bGQgYmUgcmV0dXJuZWRcclxuICAgICAqICAgICAgIHZhbHVlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgKiAgICAgICBcdHJldHVybiBbIC4uLiBdO1xyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfdmFsdWVzOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIHkyIGF4aXMgdGljayB0ZXh0LlxyXG4gICAgICogLSBJZiB5b3Ugc2V0IG5lZ2F0aXZlIHZhbHVlLCBpdCB3aWxsIHJvdGF0ZSB0byBvcHBvc2l0ZSBkaXJlY3Rpb24uXHJcbiAgICAgKiAtIEFwcGxpZWQgd2hlbiBbYGF4aXMucm90YXRlZGBdKCMuYXhpcyUyNUUyJTI1ODAlMjVBNHJvdGF0ZWQpIG9wdGlvbiBpcyBgdHJ1ZWAuXHJcbiAgICAgKiBAbmFtZSBheGlz4oCkeTLigKR0aWNr4oCkcm90YXRlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgdGljazoge1xyXG4gICAgICogICAgICAgcm90YXRlOiA2MFxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfcm90YXRlOiAwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgeTIgYXhpcyB0aWNrcy5cclxuICAgICAqIC0gKipOT1RFOioqIFRoaXMgd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS50aWNrLmNvdW50LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApGNvdW50XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBjb3VudDogNVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfY291bnQ6IHVuZGVmaW5lZCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNob3cgb3IgaGlkZSB5MiBheGlzIHRpY2sgbGluZS5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApHRpY2vigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBheGlzIHRpY2sgc3RlcChpbnRlcnZhbCkgc2l6ZS5cclxuICAgICAqIC0gKipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgYXhpcy55Mi50aWNrLmNvdW50YCBvciBgYXhpcy55Mi50aWNrLnZhbHVlc2Agb3B0aW9ucyBhcmUgc2V0LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHN0ZXBTaXplXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge051bWJlcn1cclxuICAgICAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLlN0ZXBTaXplRm9yWUF4aXMpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICB5Mjoge1xyXG4gICAgICogICAgIHRpY2s6IHtcclxuICAgICAqICAgICAgIC8vIHRpY2sgdmFsdWUgd2lsbCBzdGVwIGFzIGluZGljYXRlZCBpbnRlcnZhbCB2YWx1ZS5cclxuICAgICAqICAgICAgIC8vIGV4KSAnc3RlcFNpemU9MTUnID09PiBbMCwgMTUsIDMwLCA0NSwgNjBdXHJcbiAgICAgKiAgICAgICBzdGVwU2l6ZTogMTVcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX3N0ZXBTaXplOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBvciBoaWRlIHkyIGF4aXMgdGljayB0ZXh0LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRzaG93XHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge0Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5IaWRlVGlja0xpbmVUZXh0KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICAgIH1cclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml90aWNrX3RleHRfc2hvdzogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgeTIgQXhpcyB0aWNrIHRleHQncyBwb3NpdGlvbiByZWxhdGl2ZWx5IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkdGlja+KApHRleHTigKRwb3NpdGlvblxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAZGVmYXVsdCB7eDogMCwgeTowfVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGF4aXM6IHtcclxuICAgICAqICAgeTI6IHtcclxuICAgICAqICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICAgeDogMTAsXHJcbiAgICAgKiAgICAgICAgICAgeTogMTBcclxuICAgICAqICAgICAgICAgfVxyXG4gICAgICogICAgICAgfVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfVxyXG4gICAgICovXHJcbiAgICBheGlzX3kyX3RpY2tfdGV4dF9wb3NpdGlvbjoge3g6IDAsIHk6IDB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBudW1iZXIgb2YgeTIgYXhpcyB0aWNrcy5cclxuICAgICAqIC0gKipOT1RFOioqIFRoaXMgd29ya3MgaW4gdGhlIHNhbWUgd2F5IGFzIGF4aXMueS50aWNrLmNvdW50LlxyXG4gICAgICogQG5hbWUgYXhpc+KApHky4oCkcGFkZGluZ1xyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R8TnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQge31cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgcGFkZGluZzoge1xyXG4gICAgICogICAgICAgdG9wOiAxMDAsXHJcbiAgICAgKiAgICAgICBib3R0b206IDEwMFxyXG4gICAgICogICAgIH1cclxuICAgICAqXHJcbiAgICAgKiAgICAgLy8gb3Igc2V0IGJvdGggdmFsdWVzIGF0IG9uY2UuXHJcbiAgICAgKiAgICAgcGFkZGluZzogMTBcclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9wYWRkaW5nOiB7fSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBkZWZhdWx0IHJhbmdlIG9mIHkyIGF4aXMuPGJyPjxicj5cclxuICAgICAqIFRoaXMgb3B0aW9uIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgeTIgYXhpcyB3aGVuIHRoZXJlIGlzIG5vIGRhdGEgb24gaW5pdC5cclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGRlZmF1bHRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBheGlzOiB7XHJcbiAgICAgKiAgIHkyOiB7XHJcbiAgICAgKiAgICAgZGVmYXVsdDogWzAsIDEwMDBdXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgYXhpc195Ml9kZWZhdWx0OiB1bmRlZmluZWQsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYWRkaXRpb25hbCBheGVzIGZvciB5MiBBeGlzLlxyXG4gICAgICogLSAqKk5PVEU6KiogQXhpcycgc2NhbGUgaXMgYmFzZWQgb24geTIgQXhpcyB2YWx1ZSBpZiBkb21haW4gb3B0aW9uIGlzbid0IHNldC5cclxuICAgICAqXHJcbiAgICAgKiBFYWNoIGF4aXMgb2JqZWN0IHNob3VsZCBjb25zaXN0IHdpdGggZm9sbG93aW5nIG9wdGlvbnM6XHJcbiAgICAgKlxyXG4gICAgICogfCBOYW1lIHwgVHlwZSB8IERlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcbiAgICAgKiB8IC0tLSB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcbiAgICAgKiB8IGRvbWFpbiB8IEFycmF5IHwgLSB8IFNldCB0aGUgZG9tYWluIHZhbHVlIHxcclxuICAgICAqIHwgdGljay5vdXRlciB8IEJvb2xlYW4gfCB0cnVlIHwgU2hvdyBvdXRlciB0aWNrIHxcclxuICAgICAqIHwgdGljay5mb3JtYXQgfCBGdW5jdGlvbiB8IC0gfCBTZXQgZm9ybWF0dGVyIGZvciB0aWNrIHRleHQgfFxyXG4gICAgICogfCB0aWNrLmNvdW50IHwgTnVtYmVyIHwgLSB8IFNldCB0aGUgbnVtYmVyIG9mIHkgYXhpcyB0aWNrcyB8XHJcbiAgICAgKiB8IHRpY2sudmFsdWVzIHwgQXJyYXkgfCAtIHwgU2V0IHRpY2sgdmFsdWVzIG1hbnVhbGx5IHxcclxuICAgICAqIEBuYW1lIGF4aXPigKR5MuKApGF4ZXNcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQXhpcy5NdWx0aUF4ZXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBEb21haW5dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBeGlzLk11bHRpQXhlc0RvbWFpbilcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiB5Mjoge1xyXG4gICAgICogICAgYXhlczogW1xyXG4gICAgICogICAgICB7XHJcbiAgICAgKiAgICAgICAgLy8gaWYgc2V0LCB3aWxsIG5vdCBiZSBjb3JyZWxhdGVkIHdpdGggdGhlIG1haW4geTIgQXhpcyBkb21haW4gdmFsdWVcclxuICAgICAqICAgICAgICBkb21haW46IFswLCAxMDAwXSxcclxuICAgICAqICAgICAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgICAgICBvdXRlcjogZmFsc2UsXHJcbiAgICAgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHgpIHtcclxuICAgICAqICAgICAgICAgICAgIHJldHVybiB4ICsgXCIlXCI7XHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgY291bnQ6IDIsXHJcbiAgICAgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwXVxyXG4gICAgICogICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgLi4uXHJcbiAgICAgKiAgICBdXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfeTJfYXhlczogW11cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgeCBmcm9tIFwiLi94XCI7XHJcbmltcG9ydCB5IGZyb20gXCIuL3lcIjtcclxuaW1wb3J0IHkyIGZyb20gXCIuL3kyXCI7XHJcblxyXG5pbXBvcnQge21lcmdlT2JqfSBmcm9tIFwiLi4vLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbiAvKipcclxuICogeSBBeGlzICBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgbWVyZ2VPYmooe1xyXG4gICAgLyoqXHJcbiAgICAgKiBTd2l0Y2ggeCBhbmQgeSBheGlzIHBvc2l0aW9uLlxyXG4gICAgICogQG5hbWUgYXhpc+KApHJvdGF0ZWRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogYXhpczoge1xyXG4gICAgICogICByb3RhdGVkOiB0cnVlXHJcbiAgICAgKiB9XHJcbiAgICAgKi9cclxuICAgIGF4aXNfcm90YXRlZDogZmFsc2VcclxufSwgeCwgeSwgeTIpO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBjb2xvciBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY29sb3Igb2YgdGhlIGRhdGEgdmFsdWVzXHJcbiAgICAgKiBAbmFtZSBjb2xvclxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xPYmplY3R8RnVuY3Rpb259IFtjb2xvci5vbm92ZXJdIFNldCB0aGUgY29sb3IgdmFsdWUgZm9yIGVhY2ggZGF0YSBwb2ludCB3aGVuIG1vdXNlL3RvdWNoIG9ub3ZlciBldmVudCBvY2N1cnMuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBbY29sb3IucGF0dGVybj1bXV0gY3VzdG9tIGNvbG9yIHBhdHRlcm5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtjb2xvci50aWxlc10gaWYgZGVmaW5lZCwgYWxsb3dzIHVzZSBzdmcncyBwYXR0ZXJucyB0byBmaWxsIGRhdGEgYXJlYS4gSXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBbU1ZHUGF0dGVybkVsZW1lbnRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TVkdQYXR0ZXJuRWxlbWVudCkuXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogVGhlIHBhdHRlcm4gZWxlbWVudCdzIGlkIHdpbGwgYmUgZGVmaW5lZCBhcyBgYmItY29sb3JpemUtcGF0dGVybi0kQ09MT1ItVkFMVUVgLjxicj5cclxuICAgICAqICAgIGV4LiBXaGVuIGNvbG9yIHBhdHRlcm4gdmFsdWUgaXMgYFsncmVkJywgJyNmZmYnXWAgYW5kIGRlZmluZWQgMiBwYXR0ZXJucyx0aGVuIGlkcyBmb3IgcGF0dGVybiBlbGVtZW50cyBhcmU6PGJyPlxyXG4gICAgICogICAgLSBgYmItY29sb3JpemUtcGF0dGVybi1yZWRgXHJcbiAgICAgKiAgICAtIGBiYi1jb2xvcml6ZS1wYXR0ZXJuLWZmZmBcclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbY29sb3IudGhyZXNob2xkXSBjb2xvciB0aHJlc2hvbGQgZm9yIGdhdWdlIGFuZCB0b29sdGlwIGNvbG9yXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2NvbG9yLnRocmVzaG9sZC51bml0XSBJZiBzZXQgdG8gYHZhbHVlYCwgdGhlIHRocmVzaG9sZCB3aWxsIGJlIGJhc2VkIG9uIHRoZSBkYXRhIHZhbHVlLiBPdGhlcndpc2UgaXQnbGwgYmUgYmFzZWQgb24gZXF1YXRpb24gb2YgdGhlIGB0aHJlc2hvbGQubWF4YCBvcHRpb24gdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBbY29sb3IudGhyZXNob2xkLnZhbHVlc10gVGhyZXNob2xkIHZhbHVlcyBmb3IgZWFjaCBzdGVwc1xyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtjb2xvci50aHJlc2hvbGQubWF4PTEwMF0gVGhlIGJhc2UgdmFsdWUgdG8gZGV0ZXJtaW5lIHRocmVzaG9sZCBzdGVwIHZhbHVlIGNvbmRpdGlvbi4gV2hlbiB0aGUgZ2l2ZW4gdmFsdWUgaXMgMTUgYW5kIG1heCAxMCwgdGhlbiB0aGUgdmFsdWUgZm9yIHRocmVzaG9sZCBpcyBgMTUqMTAwLzEwYC5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgY29sb3I6IHtcclxuICAgICAqICAgICAgcGF0dGVybjogW1wiIzFmNzdiNFwiLCBcIiNhZWM3ZThcIiwgLi4uXSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIFNldCBjb2xvcnMnIHBhdHRlcm5zXHJcbiAgICAgKiAgICAgIC8vIGl0IHNob3VsZCByZXR1cm4gYW4gYXJyYXkgb2YgU1ZHUGF0dGVybkVsZW1lbnRcclxuICAgICAqICAgICAgdGlsZXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICogICAgICAgICB2YXIgcGF0dGVybiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwicGF0dGVyblwiKTtcclxuICAgICAqICAgICAgICAgdmFyIGcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImdcIik7XHJcbiAgICAgKiAgICAgICAgIHZhciBjaXJjbGUxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJjaXJjbGVcIik7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xyXG4gICAgICogICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiMzJcIik7XHJcbiAgICAgKiAgICAgICAgIHBhdHRlcm4uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiMzJcIik7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICBnLnN0eWxlLmZpbGwgPSBcIiMwMDBcIjtcclxuICAgICAqICAgICAgICAgZy5zdHlsZS5vcGFjaXR5ID0gXCIwLjJcIjtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIGNpcmNsZTEuc2V0QXR0cmlidXRlKFwiY3hcIiwgXCIzXCIpO1xyXG4gICAgICogICAgICAgICBjaXJjbGUxLnNldEF0dHJpYnV0ZShcImN5XCIsIFwiM1wiKTtcclxuICAgICAqICAgICAgICAgY2lyY2xlMS5zZXRBdHRyaWJ1dGUoXCJyXCIsIFwiM1wiKTtcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgIGcuYXBwZW5kQ2hpbGQoY2lyY2xlMSk7XHJcbiAgICAgKiAgICAgICAgIHBhdHRlcm4uYXBwZW5kQ2hpbGQoZyk7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICByZXR1cm4gW3BhdHRlcm5dO1xyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZm9yIHRocmVzaG9sZCB1c2FnZSwgcGF0dGVybiB2YWx1ZXMgc2hvdWxkIGJlIHNldCBmb3IgZWFjaCBzdGVwc1xyXG4gICAgICogICAgICBwYXR0ZXJuOiBbXCJncmV5XCIsIFwiZ3JlZW5cIiwgXCJ5ZWxsb3dcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl0sXHJcbiAgICAgKiAgICAgIHRocmVzaG9sZDoge1xyXG4gICAgICogICAgICAgICAgdW5pdDogXCJ2YWx1ZVwiLFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIHdoZW4gdmFsdWUgaXMgMjAgPT4gJ2dyZWVuJywgdmFsdWUgaXMgNDAgPT4gJ29yYW5nZScgd2lsbCBiZSBzZXQuXHJcbiAgICAgKiAgICAgICAgICB2YWx1ZXM6IFsxMCwgMjAsIDMwLCA0MCwgNTBdLFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIHRoZSBlcXVhdGlvbiBmb3IgbWF4OlxyXG4gICAgICogICAgICAgICAgLy8gLSB1bml0ID09ICd2YWx1ZSc6IG1heCA9PiAzMFxyXG4gICAgICogICAgICAgICAgLy8gLSB1bml0ICE9ICd2YWx1ZSc6IG1heCA9PiB2YWx1ZSoxMDAvMzBcclxuICAgICAqICAgICAgICAgIG1heDogMzBcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNldCBhbGwgZGF0YSB0byAncmVkJ1xyXG4gICAgICogICAgICBvbm92ZXI6IFwicmVkXCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBzZXQgZGlmZmVyZW50IGNvbG9yIGZvciBkYXRhXHJcbiAgICAgKiAgICAgIG9ub3Zlcjoge1xyXG4gICAgICogICAgICAgICAgZGF0YTE6IFwicmVkXCIsXHJcbiAgICAgKiAgICAgICAgICBkYXRhMjogXCJ5ZWxsb3dcIlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gd2lsbCBwYXNzIGRhdGEgb2JqZWN0IHRvIHRoZSBjYWxsYmFja1xyXG4gICAgICogICAgICBvbm92ZXI6IGZ1bmN0aW9uKGQpIHtcclxuICAgICAqICAgICAgICAgIHJldHVybiBkLmlkID09PSBcImRhdGExXCIgPyBcInJlZFwiIDogXCJncmVlblwiO1xyXG4gICAgICogICAgICB9XHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBjb2xvcl9wYXR0ZXJuOiBbXSxcclxuICAgIGNvbG9yX3RpbGVzOiB1bmRlZmluZWQsXHJcbiAgICBjb2xvcl90aHJlc2hvbGQ6IHt9LFxyXG4gICAgY29sb3Jfb25vdmVyOiB1bmRlZmluZWRcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogZ3JpZCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcmVsYXRlZCBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBncmlkXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2Zyb250PWZhbHNlXSBTZXQgJ2dyaWQgJiBmb2N1cyBsaW5lcycgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGdyaWQgbGluZXMgYW5kIGNoYXJ0IGVsZW1lbnRzLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbeC5zaG93PWZhbHNlXSBTaG93IGdyaWRzIGFsb25nIHggYXhpcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt4LmxpbmVzPVtdXSBTaG93IGFkZGl0aW9uYWwgZ3JpZCBsaW5lcyBhbG9uZyB4IGF4aXMuPGJyPlxyXG4gICAgICogIFRoaXMgb3B0aW9uIGFjY2VwdHMgYXJyYXkgaW5jbHVkaW5nIG9iamVjdCB0aGF0IGhhcyB2YWx1ZSwgdGV4dCwgcG9zaXRpb24gYW5kIGNsYXNzLiB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MgYXJlIG9wdGlvbmFsLiBGb3IgcG9zaXRpb24sIHN0YXJ0LCBtaWRkbGUgYW5kIGVuZCAoZGVmYXVsdCkgYXJlIGF2YWlsYWJsZS5cclxuICAgICAqICBJZiB4IGF4aXMgaXMgY2F0ZWdvcnkgYXhpcywgdmFsdWUgY2FuIGJlIGNhdGVnb3J5IG5hbWUuIElmIHggYXhpcyBpcyB0aW1lc2VyaWVzIGF4aXMsIHZhbHVlIGNhbiBiZSBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3QgYW5kIHVuaXh0aW1lIGludGVnZXIuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt5LnNob3c9ZmFsc2VdIFNob3cgZ3JpZHMgYWxvbmcgeCBheGlzLlxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gW3kubGluZXM9W11dIFNob3cgYWRkaXRpb25hbCBncmlkIGxpbmVzIGFsb25nIHkgYXhpcy48YnI+XHJcbiAgICAgKiAgVGhpcyBvcHRpb24gYWNjZXB0cyBhcnJheSBpbmNsdWRpbmcgb2JqZWN0IHRoYXQgaGFzIHZhbHVlLCB0ZXh0LCBwb3NpdGlvbiBhbmQgY2xhc3MuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3kudGlja3M9MTBdIE51bWJlciBvZiB5IGdyaWRzIHRvIGJlIHNob3duLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZm9jdXMuZWRnZT1mYWxzZV0gU2hvdyBlZGdlZCBmb2N1cyBncmlkIGxpbmUuPGJyPioqTk9URToqKiBBdmFpbGFibGUgd2hlbiBbYHRvb2x0aXAuZ3JvdXBlZD1mYWxzZWBdKCMudG9vbHRpcCkgb3B0aW9uIGlzIHNldC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLnNob3c9dHJ1ZV0gU2hvdyBncmlkIGxpbmUgd2hlbiBmb2N1cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ZvY3VzLnk9ZmFsc2VdIFNob3cgeSBjb29yZGluYXRlIGZvY3VzIGdyaWQgbGluZS48YnI+KipOT1RFOioqIEF2YWlsYWJsZSB3aGVuIFtgdG9vbHRpcC5ncm91cGVkPWZhbHNlYF0oIy50b29sdGlwKSBvcHRpb24gaXMgc2V0LlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZXMuZnJvbnQ9dHJ1ZV0gU2V0IGdyaWQgbGluZXMgdG8gYmUgcG9zaXRpb25lZCBvdmVyIGNoYXJ0IGVsZW1lbnRzLlxyXG4gICAgICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jR3JpZC5HcmlkTGluZXMpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBYIEdyaWQgTGluZXNdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNHcmlkLk9wdGlvbmFsWEdyaWRMaW5lcylcclxuICAgICAqIEBzZWUgW0RlbW86IFkgR3JpZCBMaW5lc10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0dyaWQuT3B0aW9uYWxZR3JpZExpbmVzKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGdyaWQ6IHtcclxuICAgICAqICAgeDoge1xyXG4gICAgICogICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgbGluZXM6IFtcclxuICAgICAqICAgICAgIHt2YWx1ZTogMiwgdGV4dDogXCJMYWJlbCBvbiAyXCJ9LFxyXG4gICAgICogICAgICAge3ZhbHVlOiA1LCB0ZXh0OiBcIkxhYmVsIG9uIDVcIiwgY2xhc3M6IFwibGFiZWwtNVwifSxcclxuICAgICAqICAgICAgIHt2YWx1ZTogNiwgdGV4dDogXCJMYWJlbCBvbiA2XCIsIHBvc2l0aW9uOiBcInN0YXJ0XCJ9XHJcbiAgICAgKiAgICAgXVxyXG4gICAgICogICB9LFxyXG4gICAgICogICB5OiB7XHJcbiAgICAgKiAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAqICAgICBsaW5lczogW1xyXG4gICAgICogICAgICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgb24gMTAwXCJ9LFxyXG4gICAgICogICAgICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgb24gMjAwXCIsIGNsYXNzOiBcImxhYmVsLTIwMFwifSxcclxuICAgICAqICAgICAgIHt2YWx1ZTogMzAwLCB0ZXh0OiBcIkxhYmVsIG9uIDMwMFwiLCBwb3NpdGlvbjogJ21pZGRsZSd9XHJcbiAgICAgKiAgICAgXSxcclxuICAgICAqICAgICB0aWNrczogNVxyXG4gICAgICogICB9LFxyXG4gICAgICogICBmcm9udDogdHJ1ZSxcclxuICAgICAqICAgZm9jdXM6IHtcclxuICAgICAqICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBCZWxvdyBvcHRpb25zIGFyZSBhdmFpbGFibGUgd2hlbiAndG9vbHRpcC5ncm91cGVkPWZhbHNlJyBvcHRpb24gaXMgc2V0XHJcbiAgICAgKiAgICAgIGVkZ2U6IHRydWUsXHJcbiAgICAgKiAgICAgIHk6IHRydWVcclxuICAgICAqICAgfSxcclxuICAgICAqICAgbGluZXM6IHtcclxuICAgICAqICAgICAgZnJvbnQ6IGZhbHNlXHJcbiAgICAgKiAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgZ3JpZF94X3Nob3c6IGZhbHNlLFxyXG4gICAgZ3JpZF94X3R5cGU6IFwidGlja1wiLFxyXG4gICAgZ3JpZF94X2xpbmVzOiBbXSxcclxuICAgIGdyaWRfeV9zaG93OiBmYWxzZSxcclxuICAgIGdyaWRfeV9saW5lczogW10sXHJcbiAgICBncmlkX3lfdGlja3M6IDEwLFxyXG4gICAgZ3JpZF9mb2N1c19lZGdlOiBmYWxzZSxcclxuICAgIGdyaWRfZm9jdXNfc2hvdzogdHJ1ZSxcclxuICAgIGdyaWRfZm9jdXNfeTogZmFsc2UsXHJcbiAgICBncmlkX2Zyb250OiBmYWxzZSxcclxuICAgIGdyaWRfbGluZXNfZnJvbnQ6IHRydWVcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogaW50ZXJhY3Rpb24gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogSW50ZXJhY3Rpb24gb3B0aW9uc1xyXG4gICAgICogQG5hbWUgaW50ZXJhY3Rpb25cclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbaW50ZXJhY3Rpb24uZW5hYmxlZD10cnVlXSBJbmRpY2F0ZSBpZiB0aGUgY2hhcnQgc2hvdWxkIGhhdmUgaW50ZXJhY3Rpb25zLjxicj5cclxuICAgICAqICAgICBJZiBgZmFsc2VgIGlzIHNldCwgYWxsIG9mIGludGVyYWN0aW9ucyAoc2hvd2luZy9oaWRpbmcgdG9vbHRpcCwgc2VsZWN0aW9uLCBtb3VzZSBldmVudHMsIGV0Yykgd2lsbCBiZSBkaXNhYmxlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmJyaWdodGVuPXRydWVdIE1ha2UgYnJpZ2h0ZXIgZm9yIHRoZSBzZWxlY3RlZCBhcmVhIChleC4gJ3BpZScgdHlwZSBkYXRhIHNlbGVjdGVkIGFyZWEpXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUubW91c2U9dHJ1ZV0gZW5hYmxlIG9yIGRpc2FibGUgbW91c2UgaW50ZXJhY3Rpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2ludGVyYWN0aW9uLmlucHV0VHlwZS50b3VjaD10cnVlXSBlbmFibGUgb3IgZGlzYWJsZSAgdG91Y2ggaW50ZXJhY3Rpb25cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbnxOdW1iZXJ9IFtpbnRlcmFjdGlvbi5pbnB1dFR5cGUudG91Y2gucHJldmVudERlZmF1bHQ9ZmFsc2VdIGVuYWJsZSBvciBkaXNhYmxlIHRvIGNhbGwgZXZlbnQucHJldmVudERlZmF1bHQgb24gdG91Y2hzdGFydCAmIHRvdWNobW92ZSBldmVudC4gSXQncyB1c3VhbGx5IHVzZWQgdG8gcHJldmVudCBkb2N1bWVudCBzY3JvbGxpbmcuXHJcbiAgICAgKiBAc2VlIFtEZW1vOiB0b3VjaC5wcmV2ZW50RGVmYXVsdF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0ludGVyYWN0aW9uLlByZXZlbnRTY3JvbGxPblRvdWNoKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGludGVyYWN0aW9uOiB7XHJcbiAgICAgKiAgICBlbmFibGVkOiBmYWxzZSxcclxuICAgICAqICAgIGJyaWdodGVuOiBmYWxzZSxcclxuICAgICAqICAgIGlucHV0VHlwZToge1xyXG4gICAgICogICAgICAgIG1vdXNlOiB0cnVlLFxyXG4gICAgICogICAgICAgIHRvdWNoOiBmYWxzZVxyXG4gICAgICpcclxuICAgICAqICAgICAgICAvLyBvciBkZWNsYXJlIHByZXZlbnREZWZhdWx0IGV4cGxpY2l0bHkuXHJcbiAgICAgKiAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHRvdWNoIGlucHV0VHlwZSBpcyBlbmFibGVkIGJ5IGRlZmF1bHRcclxuICAgICAqICAgICAgICB0b3VjaDoge1xyXG4gICAgICogICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogdHJ1ZVxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgLy8gb3IgdGhyZXNob2xkIHBpeGVsIHZhbHVlIChwaXhlbCBtb3ZlZCBmcm9tIHRvdWNoc3RhcnQgdG8gdG91Y2htb3ZlKVxyXG4gICAgICogICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogNVxyXG4gICAgICogICAgICAgIH1cclxuICAgICAqICAgIH1cclxuICAgICAqIH1cclxuICAgICAqL1xyXG4gICAgaW50ZXJhY3Rpb25fZW5hYmxlZDogdHJ1ZSxcclxuICAgIGludGVyYWN0aW9uX2JyaWdodGVuOiB0cnVlLFxyXG4gICAgaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlOiB0cnVlLFxyXG4gICAgaW50ZXJhY3Rpb25faW5wdXRUeXBlX3RvdWNoOiB7fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBsZWdlbmQgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogTGVnZW5kIG9wdGlvbnNcclxuICAgICAqIEBuYW1lIGxlZ2VuZFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGVnZW5kLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLmhpZGU9ZmFsc2VdIEhpZGUgbGVnZW5kXHJcbiAgICAgKiAgSWYgdHJ1ZSBnaXZlbiwgYWxsIGxlZ2VuZCB3aWxsIGJlIGhpZGRlbi4gSWYgc3RyaW5nIG9yIGFycmF5IGdpdmVuLCBvbmx5IHRoZSBsZWdlbmQgdGhhdCBoYXMgdGhlIGlkIHdpbGwgYmUgaGlkZGVuLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR9IFtsZWdlbmQuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIGxlZ2VuZCBpdGVtcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfEZ1bmN0aW9ufSBbbGVnZW5kLmNvbnRlbnRzLnRlbXBsYXRlPXVuZGVmaW5lZF0gU2V0IGl0ZW0ncyB0ZW1wbGF0ZS48YnI+XHJcbiAgICAgKiAgLSBJZiBzZXQgYHN0cmluZ2AgdmFsdWUsIHdpdGhpbiB0ZW1wbGF0ZSB0aGUgJ2NvbG9yJyBhbmQgJ3RpdGxlJyBjYW4gYmUgcmVwbGFjZWQgdXNpbmcgdGVtcGxhdGUtbGlrZSBzeW50YXggc3RyaW5nOlxyXG4gICAgICogICAgLSB7PUNPTE9SfTogZGF0YSBjb2xvciB2YWx1ZVxyXG4gICAgICogICAgLSB7PVRJVExFfTogZGF0YSB0aXRsZSB2YWx1ZVxyXG4gICAgICogIC0gSWYgc2V0IGBmdW5jdGlvbmAgdmFsdWUsIHdpbGwgcGFzcyBmb2xsb3dpbmcgYXJndW1lbnRzIHRvIHRoZSBnaXZlbiBmdW5jdGlvbjpcclxuICAgICAqICAgLSB0aXRsZSB7U3RyaW5nfTogZGF0YSdzIGlkIHZhbHVlXHJcbiAgICAgKiAgIC0gY29sb3Ige1N0cmluZ306IGNvbG9yIHN0cmluZ1xyXG4gICAgICogICAtIGRhdGEge0FycmF5fTogZGF0YSBhcnJheVxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtsZWdlbmQucG9zaXRpb249Ym90dG9tXSBDaGFuZ2UgdGhlIHBvc2l0aW9uIG9mIGxlZ2VuZC48YnI+XHJcbiAgICAgKiAgQXZhaWxhYmxlIHZhbHVlcyBhcmU6IGBib3R0b21gLCBgcmlnaHRgIGFuZCBgaW5zZXRgIGFyZSBzdXBwb3J0ZWQuXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW2xlZ2VuZC5pbnNldD17YW5jaG9yOiAndG9wLWxlZnQnLHg6IDEwLHk6IDAsc3RlcDogdW5kZWZpbmVkfV0gQ2hhbmdlIGluc2V0IGxlZ2VuZCBhdHRyaWJ1dGVzLjxicj5cclxuICAgICAqICBUaGlzIG9wdGlvbiBhY2NlcHRzIG9iamVjdCB0aGF0IGhhcyB0aGUga2V5cyBgYW5jaG9yYCwgYHhgLCBgeWAgYW5kIGBzdGVwYC5cclxuICAgICAqICAtICoqYW5jaG9yKiogZGVjaWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIGxlZ2VuZDpcclxuICAgICAqICAgLSB0b3AtbGVmdFxyXG4gICAgICogICAtIHRvcC1yaWdodFxyXG4gICAgICogICAtIGJvdHRvbS1sZWZ0XHJcbiAgICAgKiAgIC0gYm90dG9tLXJpZ2h0XHJcbiAgICAgKiAgLSAqKngqKiBhbmQgKip5Kio6XHJcbiAgICAgKiAgIC0gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgbGVnZW5kIGJhc2VkIG9uIHRoZSBhbmNob3IuXHJcbiAgICAgKiAgLSAqKnN0ZXAqKjpcclxuICAgICAqICAgLSBkZWZpbmVzIHRoZSBtYXggc3RlcCB0aGUgbGVnZW5kIGhhcyAoZS5nLiBJZiAyIHNldCBhbmQgbGVnZW5kIGhhcyAzIGxlZ2VuZCBpdGVtLCB0aGUgbGVnZW5kIDIgY29sdW1ucykuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsZWdlbmQuZXF1YWxseT1mYWxzZV0gU2V0IHRvIGFsbCBpdGVtcyBoYXZlIHNhbWUgd2lkdGggc2l6ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xlZ2VuZC5wYWRkaW5nPTBdIFNldCBwYWRkaW5nIHZhbHVlXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbGVnZW5kLml0ZW0ub25jbGljaz11bmRlZmluZWRdIFNldCBjbGljayBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbm92ZXI9dW5kZWZpbmVkXSBTZXQgbW91c2UvdG91Y2ggb3ZlciBldmVudCBoYW5kbGVyIHRvIHRoZSBsZWdlbmQgaXRlbS5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtsZWdlbmQuaXRlbS5vbm91dD11bmRlZmluZWRdIFNldCBtb3VzZS90b3VjaCBvdXQgZXZlbnQgaGFuZGxlciB0byB0aGUgbGVnZW5kIGl0ZW0uXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2xlZ2VuZC5pdGVtLnRpbGUud2lkdGg9MTBdIFNldCB3aWR0aCBvZiBpdGVtIHRpbGUgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtsZWdlbmQuaXRlbS50aWxlLmhlaWdodD0xMF0gU2V0IGhlaWdodCBvZiBpdGVtIHRpbGUgZWxlbWVudFxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGVnZW5kLnVzZVBvaW50PWZhbHNlXSBXaGV0aGVyIHRvIHVzZSBjdXN0b20gcG9pbnRzIGluIGxlZ2VuZC5cclxuICAgICAqIEBzZWUgW0RlbW86IHBvc2l0aW9uXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jTGVnZW5kLkxlZ2VuZFBvc2l0aW9uKVxyXG4gICAgICogQHNlZSBbRGVtbzogY29udGVudHMudGVtcGxhdGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQuTGVnZW5kVGVtcGxhdGUxKVxyXG4gICAgICogQHNlZSBbRGVtbzogdXNlUG9pbnRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNMZWdlbmQudXNlUG9pbnQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIGxlZ2VuZDoge1xyXG4gICAgICogICAgICBzaG93OiB0cnVlLFxyXG4gICAgICogICAgICBoaWRlOiB0cnVlLFxyXG4gICAgICogICAgICAvL29yIGhpZGU6IFwiZGF0YTFcIlxyXG4gICAgICogICAgICAvL29yIGhpZGU6IFtcImRhdGExXCIsIFwiZGF0YTJcIl1cclxuICAgICAqICAgICAgY29udGVudHM6IHtcclxuICAgICAqICAgICAgICAgIGJpbmR0bzogXCIjbGVnZW5kXCIsICAgLy8gPHVsIGlkPSdsZWdlbmQnPjwvdWw+XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgLy8gd2lsbCBiZSBhczogPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOiMxZjc3YjQnPmRhdGExPC9saT5cclxuICAgICAqICAgICAgICAgIHRlbXBsYXRlOiBcIjxsaSBzdHlsZT0nYmFja2dyb3VuZC1jb2xvcjp7PUNPTE9SfSc+ez1USVRMRX08L2xpPlwiXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgLy8gb3IgdXNpbmcgZnVuY3Rpb25cclxuICAgICAqICAgICAgICAgIHRlbXBsYXRlOiBmdW5jdGlvbihpZCwgY29sb3IsIGRhdGEpIHtcclxuICAgICAqICAgICAgICAgICAgICAgLy8gaWYgeW91IHdhbnQgb21pdCBzb21lIGxlZ2VuZCwgcmV0dXJuIGZhbHN5IHZhbHVlXHJcbiAgICAgKiAgICAgICAgICAgICAgIGlmICh0aXRsZSAhPT0gXCJkYXRhMVwiKSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiPGxpIHN0eWxlPSdiYWNrZ3JvdW5kLWNvbG9yOlwiKyBjb2xvciArXCI+XCIrIHRpdGxlICtcIjwvbGk+XCI7XHJcbiAgICAgKiAgICAgICAgICAgICAgIH1cclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIsICAvLyBib3R0b20sIHJpZ2h0LCBpbnNldFxyXG4gICAgICogICAgICBpbnNldDoge1xyXG4gICAgICogICAgICAgICAgYW5jaG9yOiBcInRvcC1yaWdodFwiICAvLyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0XHJcbiAgICAgKiAgICAgICAgICB4OiAyMCxcclxuICAgICAqICAgICAgICAgIHk6IDEwLFxyXG4gICAgICogICAgICAgICAgc3RlcDogMlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBlcXVhbGx5OiBmYWxzZSxcclxuICAgICAqICAgICAgcGFkZGluZzogMTAsXHJcbiAgICAgKiAgICAgIGl0ZW06IHtcclxuICAgICAqICAgICAgICAgIG9uY2xpY2s6IGZ1bmN0aW9uKGlkKSB7IC4uLiB9LFxyXG4gICAgICogICAgICAgICAgb25vdmVyOiBmdW5jdGlvbihpZCkgeyAuLi4gfSxcclxuICAgICAqICAgICAgICAgIG9ub3V0OiBmdW5jdGlvbihpZCkgeyAuLi4gfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAvLyBzZXQgdGlsZSdzIHNpemVcclxuICAgICAqICAgICAgICAgIHRpbGU6IHtcclxuICAgICAqICAgICAgICAgICAgICB3aWR0aDogMjAsXHJcbiAgICAgKiAgICAgICAgICAgICAgaGVpZ2h0OiAxNVxyXG4gICAgICogICAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICB1c2VQb2ludDogdHJ1ZVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgbGVnZW5kX3Nob3c6IHRydWUsXHJcbiAgICBsZWdlbmRfaGlkZTogZmFsc2UsXHJcbiAgICBsZWdlbmRfY29udGVudHNfYmluZHRvOiB1bmRlZmluZWQsXHJcbiAgICBsZWdlbmRfY29udGVudHNfdGVtcGxhdGU6IHVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9wb3NpdGlvbjogXCJib3R0b21cIixcclxuICAgIGxlZ2VuZF9pbnNldF9hbmNob3I6IFwidG9wLWxlZnRcIixcclxuICAgIGxlZ2VuZF9pbnNldF94OiAxMCxcclxuICAgIGxlZ2VuZF9pbnNldF95OiAwLFxyXG4gICAgbGVnZW5kX2luc2V0X3N0ZXA6IHVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9pdGVtX29uY2xpY2s6IHVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9pdGVtX29ub3ZlcjogdW5kZWZpbmVkLFxyXG4gICAgbGVnZW5kX2l0ZW1fb25vdXQ6IHVuZGVmaW5lZCxcclxuICAgIGxlZ2VuZF9lcXVhbGx5OiBmYWxzZSxcclxuICAgIGxlZ2VuZF9wYWRkaW5nOiAwLFxyXG4gICAgbGVnZW5kX2l0ZW1fdGlsZV93aWR0aDogMTAsXHJcbiAgICBsZWdlbmRfaXRlbV90aWxlX2hlaWdodDogMTAsXHJcbiAgICBsZWdlbmRfdXNlUG9pbnQ6IGZhbHNlXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHBvaW50IGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBwb2ludCBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBwb2ludFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtwb2ludC5zaG93PXRydWVdIFdoZXRoZXIgdG8gc2hvdyBlYWNoIHBvaW50IGluIGxpbmUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW3BvaW50LnI9Mi41XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludC5cclxuICAgICAqICAtICoqTk9URToqKiBEaXNhYmxlZCBmb3IgJ2J1YmJsZScgdHlwZVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcG9pbnQuZm9jdXMuZXhwYW5kLmVuYWJsZWQ9dHJ1ZV0gV2hldGhlciB0byBleHBhbmQgZWFjaCBwb2ludCBvbiBmb2N1cy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuZm9jdXMuZXhwYW5kLnI9cG9pbnQucioxLjc1XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBmb2N1cy5cclxuICAgICAqICAtICoqTk9URToqKiBGb3IgJ2J1YmJsZScgdHlwZSwgdGhlIGRlZmF1bHQgaXMgYGJ1YmJsZVNpemUqMS4xNWBcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuc2Vuc2l0aXZpdHk9MTBdIFRoZSBzZW5zdGl2aXR5IHZhbHVlIGZvciBpbnRlcmFjdGlvbiBib3VuZGFyeS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcG9pbnQuc2VsZWN0LnI9cG9pbnQucio0XSBUaGUgcmFkaXVzIHNpemUgb2YgZWFjaCBwb2ludCBvbiBzZWxlY3RlZC5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbcG9pbnQudHlwZT1cImNpcmNsZVwiXSBUaGUgdHlwZSBvZiBwb2ludCB0byBiZSBkcmF3blxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICAgLSBJZiBjaGFydCBoYXMgJ2J1YmJsZScgdHlwZSwgb25seSBjaXJjbGUgY2FuIGJlIHVzZWQuXHJcbiAgICAgKiAgIC0gRm9yIElFLCBub24gY2lyY2xlIHBvaW50IGV4cGFuc2lvbnMgYXJlIG5vdCBzdXBwb3J0ZWQgZHVlIHRvIGxhY2sgb2YgdHJhbnNmb3JtIHN1cHBvcnQuXHJcbiAgICAgKiAtICoqQXZhaWxhYmxlIFZhbHVlczoqKlxyXG4gICAgICogICAtIGNpcmNsZVxyXG4gICAgICogICAtIHJlY3RhbmdsZVxyXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gW3BvaW50LnBhdHRlcm49W11dIFRoZSB0eXBlIG9mIHBvaW50IG9yIHN2ZyBzaGFwZSBhcyBzdHJpbmcsIHRvIGJlIGRyYXduIGZvciBlYWNoIGxpbmVcclxuICAgICAqIC0gKipOT1RFOioqXHJcbiAgICAgKiAgIC0gVGhpcyBpcyBhbiBgZXhwZXJpbWVudGFsYCBmZWF0dXJlIGFuZCBjYW4gaGF2ZSBzb21lIHVuZXhwZWN0ZWQgYmVoYXZpb3JzLlxyXG4gICAgICogICAtIElmIGNoYXJ0IGhhcyAnYnViYmxlJyB0eXBlLCBvbmx5IGNpcmNsZSBjYW4gYmUgdXNlZC5cclxuICAgICAqICAgLSBGb3IgSUUsIG5vbiBjaXJjbGUgcG9pbnQgZXhwYW5zaW9ucyBhcmUgbm90IHN1cHBvcnRlZCBkdWUgdG8gbGFjayBvZiB0cmFuc2Zvcm0gc3VwcG9ydC5cclxuICAgICAqIC0gKipBdmFpbGFibGUgVmFsdWVzOioqXHJcbiAgICAgKiAgIC0gY2lyY2xlXHJcbiAgICAgKiAgIC0gcmVjdGFuZ2xlXHJcbiAgICAgKiAgIC0gc3ZnIHNoYXBlIHRhZyBpbnRlcnByZXRlZCBhcyBzdHJpbmc8YnI+XHJcbiAgICAgKiAgICAgKGV4LiBgPHBvbHlnb24gcG9pbnRzPScyLjUgMCAwIDUgNSA1Jz48L3BvbHlnb24+YClcclxuICAgICAqIEBzZWUgW0RlbW86IHBvaW50IHR5cGVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNQb2ludC5SZWN0YW5nbGVQb2ludHMpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIHBvaW50OiB7XHJcbiAgICAgKiAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICogICAgICByOiA1LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gb3IgY3VzdG9taXplIHRoZSByYWRpdXNcclxuICAgICAqICAgICAgcjogZnVuY3Rpb24oZCkge1xyXG4gICAgICogICAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgICAgICByZXR1cm4gcjtcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIGZvY3VzOiB7XHJcbiAgICAgKiAgICAgICAgICBleHBhbmQ6IHtcclxuICAgICAqICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICogICAgICAgICAgICAgIHI6IDFcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgc2VsZWN0OiB7XHJcbiAgICAgKiAgICAgICAgICByOiAzXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBoYXZpbmcgbG93ZXIgdmFsdWUsIG1lYW5zIGhvdyBjbG9zZXIgdG8gYmUgZm9yIGludGVyYWN0aW9uXHJcbiAgICAgKiAgICAgIHNlbnNpdGl2aXR5OiAzLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gdmFsaWQgdmFsdWVzIGFyZSBcImNpcmNsZVwiIG9yIFwicmVjdGFuZ2xlXCJcclxuICAgICAqICAgICAgdHlwZTogXCJyZWN0YW5nbGVcIixcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yIGluZGljYXRlIGFzIHBhdHRlcm5cclxuICAgICAqICAgICAgcGF0dGVybjogW1xyXG4gICAgICogICAgICAgIFwiY2lyY2xlXCIsXHJcbiAgICAgKiAgICAgICAgXCJyZWN0YW5nbGVcIixcclxuICAgICAqICAgICAgICBcIjxwb2x5Z29uIHBvaW50cz0nMCA2IDQgMCAtNCAwJz48L3BvbHlnb24+XCJcclxuICAgICAqICAgICBdLFxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgcG9pbnRfc2hvdzogdHJ1ZSxcclxuICAgIHBvaW50X3I6IDIuNSxcclxuICAgIHBvaW50X3NlbnNpdGl2aXR5OiAxMCxcclxuICAgIHBvaW50X2ZvY3VzX2V4cGFuZF9lbmFibGVkOiB0cnVlLFxyXG4gICAgcG9pbnRfZm9jdXNfZXhwYW5kX3I6IHVuZGVmaW5lZCxcclxuICAgIHBvaW50X3BhdHRlcm46IFtdLFxyXG4gICAgcG9pbnRfc2VsZWN0X3I6IHVuZGVmaW5lZCxcclxuICAgIHBvaW50X3R5cGU6IFwiY2lyY2xlXCJcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogeCBBeGlzIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBzdWJjaGFydCBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBzdWJjaGFydFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5zaG93PWZhbHNlXSBTaG93IHN1YiBjaGFydCBvbiB0aGUgYm90dG9tIG9mIHRoZSBjaGFydC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3N1YmNoYXJ0LmF4aXMueC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtzdWJjaGFydC5heGlzLngudGljay5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayBsaW5lLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbc3ViY2hhcnQuYXhpcy54LnRpY2sudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSB4IGF4aXMgdGljayB0ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzdWJjaGFydC5zaXplLmhlaWdodF0gQ2hhbmdlIHRoZSBoZWlnaHQgb2YgdGhlIHN1YmNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3N1YmNoYXJ0Lm9uYnJ1c2hdIFNldCBjYWxsYmFjayBmb3IgYnJ1c2ggZXZlbnQuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgY3VycmVudCB6b29tZWQgeCBkb21haW4uXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jSW50ZXJhY3Rpb24uU3ViQ2hhcnQpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIHN1YmNoYXJ0OiB7XHJcbiAgICAgKiAgICAgIGF4aXM6IHtcclxuICAgICAqICAgICAgXHR4OiB7XHJcbiAgICAgKiAgICAgIFx0ICBzaG93OiB0cnVlLFxyXG4gICAgICogICAgICBcdCAgICB0aWNrOiB7XHJcbiAgICAgKiAgICAgIFx0ICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAqICAgICAgXHQgICAgICB0ZXh0OiB7XHJcbiAgICAgKiAgICAgIFx0ICAgICAgICBzaG93OiBmYWxzZVxyXG4gICAgICogICAgICBcdCAgICAgIH1cclxuICAgICAqICAgICAgXHQgICAgfVxyXG4gICAgICogICAgICBcdH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAqICAgICAgc2l6ZToge1xyXG4gICAgICogICAgICAgICAgaGVpZ2h0OiAyMFxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBvbmJydXNoOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHN1YmNoYXJ0X3Nob3c6IGZhbHNlLFxyXG4gICAgc3ViY2hhcnRfc2l6ZV9oZWlnaHQ6IDYwLFxyXG4gICAgc3ViY2hhcnRfYXhpc194X3Nob3c6IHRydWUsXHJcbiAgICBzdWJjaGFydF9heGlzX3hfdGlja19zaG93OiB0cnVlLFxyXG4gICAgc3ViY2hhcnRfYXhpc194X3RpY2tfdGV4dF9zaG93OiB0cnVlLFxyXG4gICAgc3ViY2hhcnRfb25icnVzaDogKCkgPT4ge31cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogdGl0bGUgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRpdGxlIG9wdGlvbnNcclxuICAgICAqIEBuYW1lIHRpdGxlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdGl0bGUudGV4dF0gVGl0bGUgdGV4dC4gSWYgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrIGFsbG93aW5nIG11bHRpbGluZSB0aXRsZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGl0bGUucGFkZGluZy50b3A9MF0gVG9wIHBhZGRpbmcgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcucmlnaHQ9MF0gUmlnaHQgcGFkZGluZyB2YWx1ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdGl0bGUucGFkZGluZy5ib3R0b209MF0gQm90dG9tIHBhZGRpbmcgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3RpdGxlLnBhZGRpbmcubGVmdD0wXSBMZWZ0IHBhZGRpbmcgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3RpdGxlLnBvc2l0aW9uPWNlbnRlcl0gQXZhaWxhYmxlIHZhbHVlcyBhcmU6ICdjZW50ZXInLCAncmlnaHQnIGFuZCAnbGVmdCcuXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVGl0bGUuTXVsdGlsaW5lZFRpdGxlKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICB0aXRsZToge1xyXG4gICAgICogICAgICB0ZXh0OiBcIlRpdGxlIFRleHRcIixcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yIE11bHRpbGluZSB0aXRsZSB0ZXh0XHJcbiAgICAgKiAgICAgIHRleHQ6IFwiTWFpbiB0aXRsZSB0ZXh0XFxuU3ViIHRpdGxlIHRleHRcIixcclxuICAgICAqXHJcbiAgICAgKiAgICAgIHBhZGRpbmc6IHtcclxuICAgICAqICAgICAgICAgIHRvcDogMTAsXHJcbiAgICAgKiAgICAgICAgICByaWdodDogMTAsXHJcbiAgICAgKiAgICAgICAgICBib3R0b206IDEwLFxyXG4gICAgICogICAgICAgICAgbGVmdDogMTBcclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgcG9zaXRpb246IFwiY2VudGVyXCJcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHRpdGxlX3RleHQ6IHVuZGVmaW5lZCxcclxuICAgIHRpdGxlX3BhZGRpbmc6IHtcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgICAgYm90dG9tOiAwLFxyXG4gICAgICAgIGxlZnQ6IDBcclxuICAgIH0sXHJcbiAgICB0aXRsZV9wb3NpdGlvbjogXCJjZW50ZXJcIlxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB0b29sdGlwIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFRvb2x0aXAgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgdG9vbHRpcFxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIHRvb2x0aXAuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmRvTm90SGlkZT1mYWxzZV0gTWFrZSB0b29sdGlwIGtlZXAgc2hvd2luZyBub3QgaGlkaW5nIG9uIGludGVyYWN0aW9uLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbdG9vbHRpcC5ncm91cGVkPXRydWVdIFNldCBpZiB0b29sdGlwIGlzIGdyb3VwZWQgb3Igbm90IGZvciB0aGUgZGF0YSBwb2ludHMuXHJcbiAgICAgKiAgIC0gKipOT1RFOioqIFRoZSBvdmVybGFwcGVkIGRhdGEgcG9pbnRzIHdpbGwgYmUgZGlzcGxheWVkIGFzIGdyb3VwZWQgZXZlbiBpZiBzZXQgZmFsc2UuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmxpbmtlZD1mYWxzZV0gU2V0IGlmIHRvb2x0aXBzIG9uIGFsbCB2aXNpYmxlIGNoYXJ0cyB3aXRoIGxpa2UgeCBwb2ludHMgYXJlIHNob3duIHRvZ2V0aGVyIHdoZW4gb25lIGlzIHNob3duLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0b29sdGlwLmxpbmtlZC5uYW1lPVwiXCJdIEdyb3BpbmcgbmFtZSBmb3IgbGlua2VkIHRvb2x0aXAuPGJyPklmIHNwZWNpZmllZCwgbGlua2VkIHRvb2x0aXAgd2lsbCBiZSBncm9wZWQgaW50ZXJhY3RpbmcgdG8gYmUgd29ya2VkIG9ubHkgd2l0aCB0aGUgc2FtZSBuYW1lLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAuZm9ybWF0LnRpdGxlXSBTZXQgZm9ybWF0IGZvciB0aGUgdGl0bGUgb2YgdG9vbHRpcC48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLmZvcm1hdC5uYW1lXSBTZXQgZm9ybWF0IGZvciB0aGUgbmFtZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbdG9vbHRpcC5mb3JtYXQudmFsdWVdIFNldCBmb3JtYXQgZm9yIHRoZSB2YWx1ZSBvZiBlYWNoIGRhdGEgaW4gdG9vbHRpcC48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIG5hbWUsIHJhdGlvLCBpZCBhbmQgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gcmF0aW8gd2lsbCBiZSB1bmRlZmluZWQgaWYgdGhlIGNoYXJ0IGlzIG5vdCBkb251dC9waWUvZ2F1Z2UuXHJcbiAgICAgKiAgSWYgdW5kZWZpbmVkIHJldHVybmVkLCB0aGUgcm93IG9mIHRoYXQgdmFsdWUgd2lsbCBiZSBza2lwcGVkLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAucG9zaXRpb25dIFNldCBjdXN0b20gcG9zaXRpb24gZm9yIHRoZSB0b29sdGlwLjxicj5cclxuICAgICAqICBUaGlzIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBtb2RpZnkgdGhlIHRvb2x0aXAgcG9zaXRpb24gYnkgcmV0dXJuaW5nIG9iamVjdCB0aGF0IGhhcyB0b3AgYW5kIGxlZnQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufE9iamVjdH0gW3Rvb2x0aXAuY29udGVudHNdIFNldCBjdXN0b20gSFRNTCBmb3IgdGhlIHRvb2x0aXAuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyBkYXRhLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCBhbmQgY29sb3Igb2YgdGhlIGRhdGEgcG9pbnQgdG8gc2hvdy4gSWYgdG9vbHRpcC5ncm91cGVkIGlzIHRydWUsIGRhdGEgaW5jbHVkZXMgbXVsdGlwbGUgZGF0YSBwb2ludHMuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xIVE1MRWxlbWVudH0gW3Rvb2x0aXAuY29udGVudHMuYmluZHRvPXVuZGVmaW5lZF0gU2V0IENTUyBzZWxlY3RvciBvciBlbGVtZW50IHJlZmVyZW5jZSB0byBiaW5kIHRvb2x0aXAuXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogV2hlbiBpcyBzcGVjaWZpZWQsIHdpbGwgbm90IGJlIHVwZGF0aW5nIHRvb2x0aXAncyBwb3NpdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbdG9vbHRpcC5jb250ZW50cy50ZW1wbGF0ZT11bmRlZmluZWRdIFNldCB0b29sdGlwJ3MgdGVtcGxhdGUuPGJyPjxicj5cclxuICAgICAqICBXaXRoaW4gdGVtcGxhdGUsIGJlbG93IHN5bnRheCB3aWxsIGJlIHJlcGxhY2VkIHVzaW5nIHRlbXBsYXRlLWxpa2Ugc3ludGF4IHN0cmluZzpcclxuICAgICAqICAgIC0gKip7eyAuLi4gfX0qKjogdGhlIGRvdWJseSBjdXJseSBicmFja2V0cyBpbmRpY2F0ZSBsb29wIGJsb2NrIGZvciBkYXRhIHJvd3MuXHJcbiAgICAgKiAgICAtICoqez1DTEFTU19UT09MVElQfSoqOiBkZWZhdWx0IHRvb2x0aXAgY2xhc3MgbmFtZSBgYmItdG9vbHRpcGAuXHJcbiAgICAgKiAgICAtICoqez1DTEFTU19UT09MVElQX05BTUV9Kio6IGRlZmF1bHQgdG9vbHRpcCBkYXRhIGNsYXNzIG5hbWUgKGV4LiBgYmItdG9vbHRpcC1uYW1lLWRhdGExYClcclxuICAgICAqICAgIC0gKip7PVRJVExFfSoqOiB0aXRsZSB2YWx1ZS5cclxuICAgICAqICAgIC0gKip7PUNPTE9SfSoqOiBkYXRhIGNvbG9yLlxyXG4gICAgICogICAgLSAqKns9VkFMVUV9Kio6IGRhdGEgdmFsdWUuXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW3Rvb2x0aXAuY29udGVudHMudGV4dD11bmRlZmluZWRdIFNldCBhZGRpdGlvbmFsIHRleHQgY29udGVudCB3aXRoaW4gZGF0YSBsb29wLCB1c2luZyB0ZW1wbGF0ZSBzeW50YXguXHJcbiAgICAgKiAgLSAqKk5PVEU6KiogSXQgc2hvdWxkIGNvbnRhaW4gYHsga2V5OiBBcnJheSwgLi4uIH1gIHZhbHVlXHJcbiAgICAgKiAgICAtICdrZXknIG5hbWUgaXMgdXNlZCBhcyBzdWJzdGl0dXRpb24gd2l0aGluIHRlbXBsYXRlIGFzICd7PUtFWX0nXHJcbiAgICAgKiAgICAtIFRoZSB2YWx1ZSBhcnJheSBsZW5ndGggc2hvdWxkIG1hdGNoIHdpdGggdGhlIGRhdGEgbGVuZ3RoXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt0b29sdGlwLmluaXQuc2hvdz1mYWxzZV0gU2hvdyB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbdG9vbHRpcC5pbml0Lng9MF0gU2V0IHggQXhpcyBpbmRleCB0byBiZSBzaG93biBhdCB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gW3Rvb2x0aXAuaW5pdC5wb3NpdGlvbj17dG9wOiBcIjBweFwiLGxlZnQ6IFwiNTBweFwifV0gU2V0IHRoZSBwb3NpdGlvbiBvZiB0b29sdGlwIGF0IHRoZSBpbml0aWFsaXphdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uc2hvd10gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYmVmb3JlIHRoZSB0b29sdGlwIGlzIHNob3duLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25oaWRlXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgdGhlIHRvb2x0aXAgaXMgaGlkZGVuLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3Rvb2x0aXAub25zaG93bl0gU2V0IGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHRvb2x0aXAgaXMgc2hvd25cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt0b29sdGlwLm9uaGlkZGVuXSBTZXQgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgaW52b2tlZCBhZnRlciB0aGUgdG9vbHRpcCBpcyBoaWRkZW4uXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ3xGdW5jdGlvbnxudWxsfSBbdG9vbHRpcC5vcmRlcj1udWxsXSBTZXQgdG9vbHRpcCBkYXRhIGRpc3BsYXkgb3JkZXIuPGJyPjxicj5cclxuICAgICAqICAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuICAgICAqICAtIGBkZXNjYDogSW4gZGVzY2VuZGluZyBkYXRhIHZhbHVlIG9yZGVyXHJcbiAgICAgKiAgLSBgYXNjYDogSW4gYXNjZW5kaW5nIGRhdGEgdmFsdWUgb3JkZXJcclxuICAgICAqICAtIGBudWxsYDogSXQga2VlcHMgdGhlIGRhdGEgZGlzcGxheSBvcmRlcjxicj5cclxuICAgICAqICAgICAqKk5PVEU6KiogV2hlbiBgZGF0YS5ncm91cHNgIGlzIHNldCwgdGhlIG9yZGVyIHdpbGwgZm9sbG93IGFzIHRoZSBzdGFja2VkIGdyYXBoIG9yZGVyLjxicj5cclxuICAgICAqICAgICAgSWYgd2FudCB0byBvcmRlciBhcyBkYXRhIGJvdW5kLCBzZXQgYW55IHZhbHVlIHJhdGhlciB0aGFuIGFzYywgZGVzYyBvciBudWxsLiAoZXguIGVtcHR5IHN0cmluZyBcIlwiKVxyXG4gICAgICogIC0gYGZ1bmN0aW9uKGRhdGExLCBkYXRhMikgeyAuLi4gfWA6IFtBcnJheS5zb3J0IGNvbXBhcmVGdW5jdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydCNQYXJhbWV0ZXJzKVxyXG4gICAgICogQHNlZSBbRGVtbzogSGlkZSBUb29sdGlwXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5IaWRlVG9vbHRpcClcclxuICAgICAqIEBzZWUgW0RlbW86IFRvb2x0aXAgR3JvdXBpbmddKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLlRvb2x0aXBHcm91cGluZylcclxuICAgICAqIEBzZWUgW0RlbW86IFRvb2x0aXAgRm9ybWF0XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jVG9vbHRpcC5Ub29sdGlwRm9ybWF0KVxyXG4gICAgICogQHNlZSBbRGVtbzogTGlua2VkIFRvb2x0aXBdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNUb29sdGlwLkxpbmtlZFRvb2x0aXBzKVxyXG4gICAgICogQHNlZSBbRGVtbzogVG9vbHRpcCBUZW1wbGF0ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1Rvb2x0aXAuVG9vbHRpcFRlbXBsYXRlKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICB0b29sdGlwOiB7XHJcbiAgICAgKiAgICAgIHNob3c6IHRydWUsXHJcbiAgICAgKiAgICAgIGRvTm90SGlkZTogdHJ1ZSxcclxuICAgICAqICAgICAgZ3JvdXBlZDogZmFsc2UsXHJcbiAgICAgKiAgICAgIGZvcm1hdDoge1xyXG4gICAgICogICAgICAgICAgdGl0bGU6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuIFwiRGF0YSBcIiArIHg7IH0sXHJcbiAgICAgKiAgICAgICAgICBuYW1lOiBmdW5jdGlvbihuYW1lLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiBuYW1lOyB9LFxyXG4gICAgICogICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQsIGluZGV4KSB7IHJldHVybiByYXRpbzsgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBwb3NpdGlvbjogZnVuY3Rpb24oZGF0YSwgd2lkdGgsIGhlaWdodCwgZWxlbWVudCkge1xyXG4gICAgICogICAgICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IDB9XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBjb250ZW50czogZnVuY3Rpb24oZCwgZGVmYXVsdFRpdGxlRm9ybWF0LCBkZWZhdWx0VmFsdWVGb3JtYXQsIGNvbG9yKSB7XHJcbiAgICAgKiAgICAgICAgICByZXR1cm4gLi4uIC8vIGZvcm1hdHRlZCBodG1sIGFzIHlvdSB3YW50XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gc3BlY2lmeSB0b29sdGlwIGNvbnRlbnRzIHVzaW5nIHRlbXBsYXRlXHJcbiAgICAgKiAgICAgICAvLyAtIGV4YW1wbGUgb2YgSFRNTCByZXR1cm5lZDpcclxuICAgICAqICAgICAgIC8vIDx1bCBjbGFzcz1cImJiLXRvb2x0aXBcIj5cclxuICAgICAqICAgICAgIC8vICAgPGxpIGNsYXNzPVwiYmItdG9vbHRpcC1uYW1lLWRhdGExXCI+PHNwYW4+MjUwPC9zcGFuPjxicj48c3BhbiBzdHlsZT1cImNvbG9yOiMwMGM3M2NcIj5kYXRhMTwvc3Bhbj48L2xpPlxyXG4gICAgICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTJcIj48c3Bhbj41MDwvc3Bhbj48YnI+PHNwYW4gc3R5bGU9XCJjb2xvcjojZmE3MTcxXCI+ZGF0YTI8L3NwYW4+PC9saT5cclxuICAgICAqICAgICAgIC8vIDwvdWw+XHJcbiAgICAgKiAgICAgICBjb250ZW50czoge1xyXG4gICAgICogICAgICBcdGJpbmR0bzogXCIjdG9vbHRpcFwiLFxyXG4gICAgICogICAgICBcdHRlbXBsYXRlOiAnPHVsIGNsYXNzPXs9Q0xBU1NfVE9PTFRJUH0+e3snICtcclxuICAgICAqICAgICAgXHRcdFx0JzxsaSBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUF9OQU1FfVwiPjxzcGFuPns9VkFMVUV9PC9zcGFuPjxicj4nICtcclxuICAgICAqICAgICAgXHRcdFx0JzxzcGFuIHN0eWxlPWNvbG9yOns9Q09MT1J9Pns9TkFNRX08L3NwYW4+PC9saT4nICtcclxuICAgICAqICAgICAgXHRcdCd9fTwvdWw+J1xyXG4gICAgICogICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgLy8gd2l0aCBhZGRpdGlvbmFsIHRleHQgdmFsdWVcclxuICAgICAqICAgICAgIC8vIC0gZXhhbXBsZSBvZiBIVE1MIHJldHVybmVkOlxyXG4gICAgICogICAgICAgLy8gPHVsIGNsYXNzPVwiYmItdG9vbHRpcFwiPlxyXG4gICAgICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTFcIj48c3Bhbj4yNTA8L3NwYW4+PGJyPmNvbW1lbnQxPHNwYW4gc3R5bGU9XCJjb2xvcjojMDBjNzNjXCI+ZGF0YTE8L3NwYW4+dGV4dDE8L2xpPlxyXG4gICAgICogICAgICAgLy8gICA8bGkgY2xhc3M9XCJiYi10b29sdGlwLW5hbWUtZGF0YTJcIj48c3Bhbj41MDwvc3Bhbj48YnI+Y29tbWVudDI8c3BhbiBzdHlsZT1cImNvbG9yOiNmYTcxNzFcIj5kYXRhMjwvc3Bhbj50ZXh0MjwvbGk+XHJcbiAgICAgKiAgICAgICAvLyA8L3VsPlxyXG4gICAgICogICAgICAgY29udGVudHM6IHtcclxuICAgICAqICAgICAgXHRiaW5kdG86IFwiI3Rvb2x0aXBcIixcclxuICAgICAqICAgICAgXHR0ZXh0OiB7XHJcbiAgICAgKiAgICAgIFx0XHQvLyBhKSAna2V5JyBuYW1lIGlzIHVzZWQgYXMgc3Vic3RpdHV0aW9uIHdpdGhpbiB0ZW1wbGF0ZSBhcyAnez1LRVl9J1xyXG4gICAgICogICAgICBcdFx0Ly8gYikgdGhlIGxlbmd0aCBzaG91bGQgbWF0Y2ggd2l0aCB0aGUgZGF0YSBsZW5ndGhcclxuICAgICAqICAgICAgXHRcdFZBUjE6IFtcInRleHQxXCIsIFwidGV4dDJcIl0sXHJcbiAgICAgKiAgICAgIFx0XHRWQVIyOiBbXCJjb21tZW50MVwiLCBcImNvbW1lbnQyXCJdLFxyXG4gICAgICogICAgICBcdH0sXHJcbiAgICAgKiAgICAgIFx0dGVtcGxhdGU6ICc8dWwgY2xhc3M9ez1DTEFTU19UT09MVElQfT57eycgK1xyXG4gICAgICogICAgICBcdFx0XHQnPGxpIGNsYXNzPVwiez1DTEFTU19UT09MVElQX05BTUV9XCI+PHNwYW4+ez1WQUxVRX08L3NwYW4+ez1WQVIyfTxicj4nICtcclxuICAgICAqICAgICAgXHRcdFx0JzxzcGFuIHN0eWxlPWNvbG9yOns9Q09MT1J9Pns9TkFNRX08L3NwYW4+ez1WQVIxfTwvbGk+JyArXHJcbiAgICAgKiAgICAgIFx0XHQnfX08L3VsPidcclxuICAgICAqICAgICAgfVxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc29ydCB0b29sdGlwIGRhdGEgdmFsdWUgZGlzcGxheSBpbiBhc2NlbmRpbmcgb3JkZXJcclxuICAgICAqICAgICAgb3JkZXI6IFwiYXNjXCIsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBzcGVjaWZ5aW5nIHNvcnQgZnVuY3Rpb25cclxuICAgICAqICAgICAgb3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgICAqICAgICAgICAgLy8gcGFyYW0gZGF0YSBwYXNzZWQgZm9ybWF0XHJcbiAgICAgKiAgICAgICAgIHt4OiA1LCB2YWx1ZTogMjUwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogNSwgbmFtZTogXCJkYXRhMVwifVxyXG4gICAgICogICAgICAgICAgIC4uLlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc2hvdyBhdCB0aGUgaW5pdGlhbGl6YXRpb25cclxuICAgICAqICAgICAgaW5pdDoge1xyXG4gICAgICogICAgICAgICAgc2hvdzogdHJ1ZSxcclxuICAgICAqICAgICAgICAgIHg6IDIsXHJcbiAgICAgKiAgICAgICAgICBwb3NpdGlvbjoge1xyXG4gICAgICogICAgICAgICAgICAgIHRvcDogXCIxNTBweFwiLFxyXG4gICAgICogICAgICAgICAgICAgIGxlZnQ6IFwiMjUwcHhcIlxyXG4gICAgICogICAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZmlyZXMgcHJpb3IgdG9vbHRpcCBpcyBzaG93blxyXG4gICAgICogICAgICBvbnNob3c6IGZ1bmN0aW9uKGN0eCwgc2VsZWN0ZWREYXRhKSB7XHJcbiAgICAgKiAgICAgIFx0Y3R4OyAvLyBjdXJyZW50IGNoYXJ0IGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdC8vIGN1cnJlbnQgZGF0YXNldCBzZWxlY3RlZFxyXG4gICAgICogICAgICBcdC8vID09PiBbe3g6IDQsIHZhbHVlOiAxNTAsIGlkOiBcImRhdGEyXCIsIGluZGV4OiA0LCBuYW1lOiBcImRhdGEyXCJ9LCAuLi5dXHJcbiAgICAgKiAgICAgIFx0c2VsZWN0ZWREYXRhO1xyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZmlyZXMgcHJpb3IgdG9vbHRpcCBpcyBoaWRkZW5cclxuICAgICAqICAgICAgb25oaWRlOiBmdW5jdGlvbihjdHgsIHNlbGVjdGVkRGF0YSkge1xyXG4gICAgICogICAgICBcdGN0eDsgLy8gY3VycmVudCBjaGFydCBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqICAgICAgXHQvLyBjdXJyZW50IGRhdGFzZXQgc2VsZWN0ZWRcclxuICAgICAqICAgICAgXHQvLyA9PT4gW3t4OiA0LCB2YWx1ZTogMTUwLCBpZDogXCJkYXRhMlwiLCBpbmRleDogNCwgbmFtZTogXCJkYXRhMlwifSwgLi4uXVxyXG4gICAgICogICAgICBcdHNlbGVjdGVkRGF0YTtcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGZpcmVzIGFmdGVyIHRvb2x0aXAgaXMgc2hvd25cclxuICAgICAqICAgICAgb25zaG93bjogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuICAgICAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcbiAgICAgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuICAgICAqICAgICAgXHRzZWxlY3RlZERhdGE7XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBmaXJlcyBhZnRlciB0b29sdGlwIGlzIGhpZGRlblxyXG4gICAgICogICAgICBvbmhpZGRlbjogZnVuY3Rpb24oY3R4LCBzZWxlY3RlZERhdGEpIHtcclxuICAgICAqICAgICAgXHRjdHg7IC8vIGN1cnJlbnQgY2hhcnQgaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0Ly8gY3VycmVudCBkYXRhc2V0IHNlbGVjdGVkXHJcbiAgICAgKiAgICAgIFx0Ly8gPT0+IFt7eDogNCwgdmFsdWU6IDE1MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDQsIG5hbWU6IFwiZGF0YTJcIn0sIC4uLl1cclxuICAgICAqICAgICAgXHRzZWxlY3RlZERhdGE7XHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyBMaW5rIGFueSB0b29sdGlwcyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBhcmUgb24gdGhlIHNjcmVlbiB3aGVyZSBzYW1lIHggY29vcmRpbmF0ZXMgYXJlIGF2YWlsYWJsZVxyXG4gICAgICogICAgICAvLyBVc2VmdWwgZm9yIHRpbWVzZXJpZXMgY29ycmVsYXRpb25cclxuICAgICAqICAgICAgbGlua2VkOiB0cnVlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gU3BlY2lmeSBuYW1lIHRvIGludGVyYWN0IHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBvbmx5LlxyXG4gICAgICogICAgICBsaW5rZWQ6IHtcclxuICAgICAqICAgICAgICAgIG5hbWU6IFwic29tZS1ncm91cFwiXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHRvb2x0aXBfc2hvdzogdHJ1ZSxcclxuICAgIHRvb2x0aXBfZG9Ob3RIaWRlOiBmYWxzZSxcclxuICAgIHRvb2x0aXBfZ3JvdXBlZDogdHJ1ZSxcclxuICAgIHRvb2x0aXBfZm9ybWF0X3RpdGxlOiB1bmRlZmluZWQsXHJcbiAgICB0b29sdGlwX2Zvcm1hdF9uYW1lOiB1bmRlZmluZWQsXHJcbiAgICB0b29sdGlwX2Zvcm1hdF92YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgdG9vbHRpcF9wb3NpdGlvbjogdW5kZWZpbmVkLFxyXG4gICAgdG9vbHRpcF9jb250ZW50czoge30sXHJcbiAgICB0b29sdGlwX2luaXRfc2hvdzogZmFsc2UsXHJcbiAgICB0b29sdGlwX2luaXRfeDogMCxcclxuICAgIHRvb2x0aXBfaW5pdF9wb3NpdGlvbjoge1xyXG4gICAgICAgIHRvcDogXCIwcHhcIixcclxuICAgICAgICBsZWZ0OiBcIjUwcHhcIlxyXG4gICAgfSxcclxuICAgIHRvb2x0aXBfbGlua2VkOiBmYWxzZSxcclxuICAgIHRvb2x0aXBfbGlua2VkX25hbWU6IFwiXCIsXHJcbiAgICB0b29sdGlwX29uc2hvdzogKCkgPT4ge30sXHJcbiAgICB0b29sdGlwX29uaGlkZTogKCkgPT4ge30sXHJcbiAgICB0b29sdGlwX29uc2hvd246ICgpID0+IHt9LFxyXG4gICAgdG9vbHRpcF9vbmhpZGRlbjogKCkgPT4ge30sXHJcbiAgICB0b29sdGlwX29yZGVyOiBudWxsXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHpvb20gY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHpvb20gb3B0aW9uc1xyXG4gICAgICogQG5hbWUgem9vbVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFt6b29tLmVuYWJsZWQ9ZmFsc2VdIEVuYWJsZSB6b29taW5nLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt6b29tLmVuYWJsZWQudHlwZT0nd2hlZWwnXSBTZXQgem9vbSBpbnRlcmFjdGlvbiB0eXBlLlxyXG4gICAgICogIC0gKipBdmFpbGFibGUgdHlwZXM6KipcclxuICAgICAqICAgIC0gd2hlZWxcclxuICAgICAqICAgIC0gZHJhZ1xyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbem9vbS5yZXNjYWxlPWZhbHNlXSBFbmFibGUgdG8gcmVzY2FsZSBhZnRlciB6b29taW5nLjxicj5cclxuICAgICAqICBJZiB0cnVlIHNldCwgeSBkb21haW4gd2lsbCBiZSB1cGRhdGVkIGFjY29yZGluZyB0byB0aGUgem9vbWVkIHJlZ2lvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt6b29tLmV4dGVudD1bMSwgMTBdXSBDaGFuZ2Ugem9vbSBleHRlbnQuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxEYXRlfSBbem9vbS54Lm1pbl0gU2V0IHggQXhpcyBtaW5pbXVtIHpvb20gcmFuZ2VcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfERhdGV9IFt6b29tLngubWF4XSBTZXQgeCBBeGlzIG1heGltdW0gem9vbSByYW5nZVxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tc3RhcnQ9dW5kZWZpbmVkXSBTZXQgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB6b29taW5nIHN0YXJ0cy48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tIGV2ZW50LlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3pvb20ub256b29tPXVuZGVmaW5lZF0gU2V0IGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHpvb21pbmcuPGJyPlxyXG4gICAgICogIFNwZWNpZmllZCBmdW5jdGlvbiByZWNlaXZlcyB0aGUgem9vbWVkIGRvbWFpbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLm9uem9vbWVuZD11bmRlZmluZWRdIFNldCBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHpvb21pbmcgZW5kcy48YnI+XHJcbiAgICAgKiAgU3BlY2lmaWVkIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSB6b29tZWQgZG9tYWluLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW3pvb20ucmVzZXRCdXR0b249dHJ1ZV0gU2V0IHRvIGRpc3BsYXkgem9vbSByZXNldCBidXR0b24gZm9yICdkcmFnJyB0eXBlIHpvb21cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFt6b29tLnJlc2V0QnV0dG9uLm9uY2xpY2tdIFNldCBjYWxsYmFjayB3aGVuIGNsaWNrcyB0aGUgcmVzZXQgYnV0dG9uLiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHJlc2V0IGJ1dHRvbiBlbGVtZW50IHJlZmVyZW5jZSBhcyBhcmd1bWVudC5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbem9vbS5yZXNldEJ1dHRvbi50ZXh0PSdSZXNldCBab29tJ10gVGV4dCB2YWx1ZSBmb3Igem9vbSByZXNldCBidXR0b24uXHJcbiAgICAgKiBAc2VlIFtEZW1vOnpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5ab29tKVxyXG4gICAgICogQHNlZSBbRGVtbzpkcmFnIHpvb21dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNJbnRlcmFjdGlvbi5EcmFnWm9vbSlcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgem9vbToge1xyXG4gICAgICogICAgICBlbmFibGVkOiB7XHJcbiAgICAgKiAgICAgICAgICB0eXBlOiBcImRyYWdcIlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICByZXNjYWxlOiB0cnVlLFxyXG4gICAgICogICAgICBleHRlbnQ6IFsxLCAxMDBdICAvLyBlbmFibGUgbW9yZSB6b29taW5nXHJcbiAgICAgKiAgICAgIHg6IHtcclxuICAgICAqICAgICAgICAgIG1pbjogLTEsICAvLyBzZXQgbWluIHJhbmdlXHJcbiAgICAgKiAgICAgICAgICBtYXg6IDEwICAvLyBzZXQgbWF4IHJhbmdlXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKiAgICAgIG9uem9vbXN0YXJ0OiBmdW5jdGlvbihldmVudCkgeyAuLi4gfSxcclxuICAgICAqICAgICAgb256b29tOiBmdW5jdGlvbihkb21haW4pIHsgLi4uIH0sXHJcbiAgICAgKiAgICAgIG9uem9vbWVuZDogZnVuY3Rpb24oZG9tYWluKSB7IC4uLiB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc2hvdyByZXNldCBidXR0b24gd2hlbiBpcyB6b29tZWQtaW5cclxuICAgICAqICAgICAgcmVzZXRCdXR0b246IHRydWUsXHJcbiAgICAgKlxyXG4gICAgICogICAgICByZXNldEJ1dHRvbjoge1xyXG4gICAgICogICAgICAgICAgLy8gb25jbGljayBjYWxsYmFjayB3aGVuIHJlc2V0IGJ1dHRvbiBpcyBjbGlja2VkXHJcbiAgICAgKiAgICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbihidXR0b24pIHtcclxuICAgICAqICAgICAgICAgICAgYnV0dG9uOyAvLyBSZXNldCBidXR0b24gZWxlbWVudCByZWZlcmVuY2VcclxuICAgICAqICAgICAgICAgICAgLi4uXHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIGN1c3RvbWl6ZWQgdGV4dCB2YWx1ZSBmb3IgcmVzZXQgem9vbSBidXR0b25cclxuICAgICAqICAgICAgICAgIHRleHQ6IFwiVW56b29tXCJcclxuICAgICAqICAgICAgfVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgem9vbV9lbmFibGVkOiB1bmRlZmluZWQsXHJcbiAgICB6b29tX2V4dGVudDogdW5kZWZpbmVkLFxyXG4gICAgem9vbV9wcml2aWxlZ2VkOiBmYWxzZSxcclxuICAgIHpvb21fcmVzY2FsZTogZmFsc2UsXHJcbiAgICB6b29tX29uem9vbTogdW5kZWZpbmVkLFxyXG4gICAgem9vbV9vbnpvb21zdGFydDogdW5kZWZpbmVkLFxyXG4gICAgem9vbV9vbnpvb21lbmQ6IHVuZGVmaW5lZCxcclxuICAgIHpvb21fcmVzZXRCdXR0b246IHRydWUsXHJcbiAgICB6b29tX3hfbWluOiB1bmRlZmluZWQsXHJcbiAgICB6b29tX3hfbWF4OiB1bmRlZmluZWRcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogYXJlYSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYXJlYSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBhcmVhXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2FyZWEuemVyb2Jhc2VkPXRydWVdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBhcmVhIGNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbYXJlYS5hYm92ZT1mYWxzZV0gU2V0IGJhY2tncm91bmQgYXJlYSBhYm92ZSB0aGUgZGF0YSBjaGFydCBsaW5lLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufE9iamVjdH0gW2FyZWEubGluZWFyR3JhZGllbnQ9ZmFsc2VdIFNldCB0aGUgbGluZWFyIGdyYWRpZW50IG9uIGFyZWEuPGJyPjxicj5cclxuICAgICAqIE9yIGN1c3RvbWl6ZSBieSBnaXZpbmcgYmVsb3cgb2JqZWN0IHZhbHVlOlxyXG4gICAgICogIC0geCB7QXJyYXl9OiBgeDFgLCBgeDJgIHZhbHVlXHJcbiAgICAgKiAgLSB5IHtBcnJheX06IGB5MWAsIGB5MmAgdmFsdWVcclxuICAgICAqICAtIHN0b3BzIHtBcnJheX06IEVhY2ggaXRlbSBzaG91bGQgYmUgaGF2aW5nIGBbb2Zmc2V0LCBzdG9wLWNvbG9yLCBzdG9wLW9wYWNpdHldYCB2YWx1ZXMuXHJcbiAgICAgKiBAc2VlIFtNRE4ncyAmbHQ7bGluZWFyR3JhZGllbnQ+XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvRWxlbWVudC9saW5lYXJHcmFkaWVudCksIFsmbHQ7c3RvcD5dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9FbGVtZW50L3N0b3ApXHJcbiAgICAgKiBAc2VlIFtEZW1vXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQ2hhcnQuQXJlYUNoYXJ0KVxyXG4gICAgICogQHNlZSBbRGVtbzogYWJvdmVdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBcmVhQ2hhcnRPcHRpb25zLkFib3ZlKVxyXG4gICAgICogQHNlZSBbRGVtbzogbGluZWFyR3JhZGllbnRdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNBcmVhQ2hhcnRPcHRpb25zLkxpbmVhckdyYWRpZW50KVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBhcmVhOiB7XHJcbiAgICAgKiAgICAgIHplcm9iYXNlZDogZmFsc2UsXHJcbiAgICAgKiAgICAgIGFib3ZlOiB0cnVlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gd2lsbCBnZW5lcmF0ZSBmb2xsd2luZyBsaW5lYXJHcmFkaWVudDpcclxuICAgICAqICAgICAgLy8gPGxpbmVhckdyYWRpZW50IHgxPVwiMFwiIHgyPVwiMFwiIHkxPVwiMFwiIHkyPVwiMVwiPlxyXG4gICAgICogICAgICAvLyAgICA8c3RvcCBvZmZzZXQ9XCIwXCIgc3RvcC1jb2xvcj1cIiREQVRBX0NPTE9SXCIgc3RvcC1vcGFjaXR5PVwiMVwiPjwvc3RvcD5cclxuICAgICAqICAgICAgLy8gICAgPHN0b3Agb2Zmc2V0PVwiMVwiIHN0b3AtY29sb3I9XCIkREFUQV9DT0xPUlwiIHN0b3Atb3BhY2l0eT1cIjBcIj48L3N0b3A+XHJcbiAgICAgKiAgICAgIC8vIDwvbGluZWFyR3JhZGllbnQ+XHJcbiAgICAgKiAgICAgIGxpbmVhckdyYWRpZW50OiB0cnVlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gT3IgY3VzdG9taXplZCBncmFkaWVudFxyXG4gICAgICogICAgICBsaW5lYXJHcmFkaWVudDoge1xyXG4gICAgICogICAgICBcdHg6IFswLCAwXSwgIC8vIHgxLCB4MiBhdHRyaWJ1dGVzXHJcbiAgICAgKiAgICAgIFx0eTogWzAsIDBdLCAgLy8geTEsIHkyIGF0dHJpYnV0ZXNcclxuICAgICAqICAgICAgXHRzdG9wczogW1xyXG4gICAgICogICAgICBcdCAgLy8gb2Zmc2V0LCBzdG9wLWNvbG9yLCBzdG9wLW9wYWNpdHlcclxuICAgICAqICAgICAgXHQgIFswLCBcIiM3Y2I1ZWNcIiwgMV0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdCAgLy8gc2V0dGluZyAnbnVsbCcgZm9yIHN0b3AtY29sb3IsIHdpbGwgc2V0IGl0cyBvcmlnaW5hbCBkYXRhIGNvbG9yXHJcbiAgICAgKiAgICAgIFx0ICBbMC41LCBudWxsLCAwXSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIFx0ICAvLyBzZXR0aW5nICdmdW5jdGlvbicgZm9yIHN0b3AtY29sb3IsIHdpbGwgcGFzcyBkYXRhIGlkIGFzIGFyZ3VtZW50LlxyXG4gICAgICogICAgICBcdCAgLy8gSXQgc2hvdWxkIHJldHVybiBjb2xvciBzdHJpbmcgb3IgbnVsbCB2YWx1ZVxyXG4gICAgICogICAgICBcdCAgWzEsIGZ1bmN0aW9uKGlkKSB7IHJldHVybiBpZCA9PT0gXCJkYXRhMVwiID8gXCJyZWRcIiA6IFwiYmx1ZVwiOyB9LCAwXSxcclxuICAgICAqICAgICAgXHRdXHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGFyZWFfemVyb2Jhc2VkOiB0cnVlLFxyXG4gICAgYXJlYV9hYm92ZTogZmFsc2UsXHJcbiAgICBhcmVhX2xpbmVhckdyYWRpZW50OiBmYWxzZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBiYXIgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGJhciBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBiYXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIucGFkZGluZz0wXSBUaGUgcGFkZGluZyBwaXhlbCB2YWx1ZSBiZXR3ZWVuIGVhY2ggYmFyLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIucmFkaXVzXSBTZXQgdGhlIHJhZGl1cyBvZiBiYXIgZWRnZSBpbiBwaXhlbC5cclxuICAgICAqIC0gKipOT1RFOioqIFdvcmtzIG9ubHkgZm9yIG5vbi1zdGFja2VkIGJhclxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIucmFkaXVzLnJhdGlvXSBTZXQgdGhlIHJhZGl1cyByYXRpbyBvZiBiYXIgZWRnZSBpbiByZWxhdGl2ZSB0aGUgYmFyJ3Mgd2lkdGguXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci5zZW5zaXRpdml0eT0yXSBUaGUgc2Vuc3Rpdml0eSBvZmZzZXQgdmFsdWUgZm9yIGludGVyYWN0aW9uIGJvdW5kYXJ5LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGhdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGgucmF0aW89MC42XSBDaGFuZ2UgdGhlIHdpZHRoIG9mIGJhciBjaGFydCBieSByYXRpby5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLm1heF0gVGhlIG1heGltdW0gd2lkdGggdmFsdWUgZm9yIHJhdGlvLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtiYXIud2lkdGguZGF0YW5hbWVdIENoYW5nZSB0aGUgd2lkdGggb2YgYmFyIGZvciBpbmRpY2F0ZWQgZGF0YXNldCBvbmx5LlxyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICAgLSBXb3JrcyBvbmx5IGZvciBub24tc3RhY2tlZCBiYXJcclxuICAgICAqICAgLSBCYXJzIGFyZSBjZW50ZXJlZCBhY2NvZGluZyBpdHMgdG90YWwgd2lkdGggdmFsdWVcclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbYmFyLndpZHRoLmRhdGFuYW1lLnJhdGlvPTAuNl0gQ2hhbmdlIHRoZSB3aWR0aCBvZiBiYXIgY2hhcnQgYnkgcmF0aW8uXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2Jhci53aWR0aC5kYXRhbmFtZS5tYXhdIFRoZSBtYXhpbXVtIHdpZHRoIHZhbHVlIGZvciByYXRpby5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2Jhci56ZXJvYmFzZWQ9dHJ1ZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGJhciBjaGFydC5cclxuICAgICAqIEBzZWUgW0RlbW86IGJhciBwYWRkaW5nXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclBhZGRpbmcpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiBiYXIgcmFkaXVzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhclJhZGl1cylcclxuICAgICAqIEBzZWUgW0RlbW86IGJhciB3aWR0aF0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0JhckNoYXJ0T3B0aW9ucy5CYXJXaWR0aClcclxuICAgICAqIEBzZWUgW0RlbW86IGJhciB3aWR0aCB2YXJpYW50XShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jQmFyQ2hhcnRPcHRpb25zLkJhcldpZHRoVmFyaWFudClcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgYmFyOiB7XHJcbiAgICAgKiAgICAgIHBhZGRpbmc6IDEsXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyB0aGUgJ3JhZGl1cycgb3B0aW9uIGNhbiBiZSB1c2VkIG9ubHkgZm9yIG5vbi1zdGFja2luZyBiYXJzXHJcbiAgICAgKiAgICAgIHJhZGl1czogMTAsXHJcbiAgICAgKiAgICAgIC8vIG9yXHJcbiAgICAgKiAgICAgIHJhZGl1czoge1xyXG4gICAgICogICAgICAgICAgcmF0aW86IDAuNVxyXG4gICAgICogICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyB3aWxsIG5vdCBoYXZlIG9mZnNldCBiZXR3ZWVuIGVhY2ggYmFyIGVsZW1lbnRzIGZvciBpbnRlcmFjdGlvblxyXG4gICAgICogICAgICBzZW5zaXRpdml0eTogMCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIHdpZHRoOiAxMCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIG9yXHJcbiAgICAgKiAgICAgIHdpZHRoOiB7XHJcbiAgICAgKiAgICAgICAgICByYXRpbzogMC4yLFxyXG4gICAgICogICAgICAgICAgbWF4OiAyMFxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gb3Igc3BlY2lmeSB3aWR0aCBwZXIgZGF0YXNldFxyXG4gICAgICogICAgICB3aWR0aDoge1xyXG4gICAgICogICAgICAgICAgZGF0YTE6IDIwLFxyXG4gICAgICogICAgICAgICAgZGF0YTI6IHtcclxuICAgICAqICAgICAgICAgICAgICByYXRpbzogMC4yLFxyXG4gICAgICogICAgICAgICAgICAgIG1heDogMjBcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIHplcm9iYXNlZDogZmFsc2VcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGJhcl9wYWRkaW5nOiAwLFxyXG4gICAgYmFyX3JhZGl1czogdW5kZWZpbmVkLFxyXG4gICAgYmFyX3JhZGl1c19yYXRpbzogdW5kZWZpbmVkLFxyXG4gICAgYmFyX3NlbnNpdGl2aXR5OiAyLFxyXG4gICAgYmFyX3dpZHRoOiB1bmRlZmluZWQsXHJcbiAgICBiYXJfd2lkdGhfcmF0aW86IDAuNixcclxuICAgIGJhcl93aWR0aF9tYXg6IHVuZGVmaW5lZCxcclxuICAgIGJhcl96ZXJvYmFzZWQ6IHRydWVcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogYnViYmxlIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBidWJibGUgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgYnViYmxlXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfEZ1bmN0aW9ufSBbYnViYmxlLm1heFI9MzVdIFNldCB0aGUgbWF4IGJ1YmJsZSByYWRpdXMgdmFsdWVcclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2J1YmJsZS56ZXJvYmFzZWQ9ZmFsc2VdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBidWJibGUgY2hhcnQuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIGJ1YmJsZToge1xyXG4gICAgICogICAgICAvLyBleCkgSWYgMTAwIGlzIHRoZSBoaWdoZXN0IHZhbHVlIGFtb25nIGRhdGEgYm91bmQsIHRoZSByZXByZXNlbnRhdGlvbiBidWJibGUgb2YgMTAwIHdpbGwgaGF2ZSByYWRpdXMgb2YgNTAuXHJcbiAgICAgKiAgICAgIC8vIEFuZCB0aGUgbGVzc2VyIHdpbGwgaGF2ZSByYWRpdXMgcmVsYXRpdmVseSBmcm9tIHRoYSBtYXggdmFsdWUuXHJcbiAgICAgKiAgICAgIG1heFI6IDUwLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gb3Igc2V0IHJhZGl1cyBjYWxsYmFja1xyXG4gICAgICogICAgICBtYXhSOiBmdW5jdGlvbihkKSB7XHJcbiAgICAgKiAgICAgICAgICAvLyBleC4gb2YgZCBwYXJhbSAtIHt4OiBGcmkgT2N0IDA2IDIwMTcgMDA6MDA6MDAgR01UKzA5MDAsIHZhbHVlOiA4MCwgaWQ6IFwiZGF0YTJcIiwgaW5kZXg6IDV9XHJcbiAgICAgKiAgICAgICAgICAuLi5cclxuICAgICAqICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZC52YWx1ZSAqIDIpO1xyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBidWJibGVfbWF4UjogMzUsXHJcbiAgICBidWJibGVfemVyb2Jhc2VkOiBmYWxzZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiBkb251dCBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgZG9udXQgb3B0aW9uc1xyXG4gICAgICogQG5hbWUgZG9udXRcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZG9udXQubGFiZWwuc2hvdz10cnVlXSBTaG93IG9yIGhpZGUgbGFiZWwgb24gZWFjaCBkb251dCBwaWVjZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtkb251dC5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIGRvbnV0IHBpZWNlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5sYWJlbC50aHJlc2hvbGQ9MC4wNV0gU2V0IHRocmVzaG9sZCB0byBzaG93L2hpZGUgbGFiZWxzLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ8RnVuY3Rpb259IFtkb251dC5sYWJlbC5yYXRpbz11bmRlZmluZWRdIFNldCByYXRpbyBvZiBsYWJlbHMgcG9zaXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtkb251dC5leHBhbmQ9dHJ1ZV0gRW5hYmxlIG9yIGRpc2FibGUgZXhwYW5kaW5nIGRvbnV0IHBpZWNlcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQuZXhwYW5kLnJhdGU9MC45OF0gU2V0IGV4cGFuZCByYXRlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5leHBhbmQuZHVyYXRpb249NTBdIFNldCBleHBhbmQgdHJhbnNpdGlvbiB0aW1lIGluIG1zLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC53aWR0aF0gU2V0IHdpZHRoIG9mIGRvbnV0IGNoYXJ0LlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtkb251dC50aXRsZT1cIlwiXSBTZXQgdGl0bGUgb2YgZG9udXQgY2hhcnQuIFVzZSBgXFxuYCBjaGFyYWN0ZXIgdG8gZW50ZXIgbGluZSBicmVhay5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZG9udXQucGFkQW5nbGU9MF0gU2V0IHBhZGRpbmcgYmV0d2VlbiBkYXRhLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5zdGFydGluZ0FuZ2xlPTBdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBkb251dDoge1xyXG4gICAgICogICAgICBsYWJlbDoge1xyXG4gICAgICogICAgICAgICAgc2hvdzogZmFsc2UsXHJcbiAgICAgKiAgICAgICAgICBmb3JtYXQ6IGZ1bmN0aW9uKHZhbHVlLCByYXRpbywgaWQpIHtcclxuICAgICAqICAgICAgICAgICAgICByZXR1cm4gZDMuZm9ybWF0KFwiJFwiKSh2YWx1ZSk7XHJcbiAgICAgKlxyXG4gICAgICogICAgICAgICAgICAgIC8vIHRvIG11bHRpbGluZSwgcmV0dXJuIHdpdGggJ1xcbicgY2hhcmFjdGVyXHJcbiAgICAgKiAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlICtcIiVcXG5MaW5lMVxcbjJMaW5lMlwiO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIHRocmVzaG9sZDogMC4xLFxyXG4gICAgICpcclxuICAgICAqICAgICAgICAgIC8vIHNldCByYXRpbyBjYWxsYmFjay4gU2hvdWxkIHJldHVybiByYXRpbyB2YWx1ZVxyXG4gICAgICogICAgICAgICAgcmF0aW86IGZ1bmN0aW9uKGQsIHJhZGl1cywgaCkge1xyXG4gICAgICogICAgICAgICAgXHQuLi5cclxuICAgICAqICAgICAgICAgIFx0cmV0dXJuIHJhdGlvO1xyXG4gICAgICogICAgICAgICAgfSxcclxuICAgICAqICAgICAgICAgIC8vIG9yIHNldCByYXRpbyBudW1iZXJcclxuICAgICAqICAgICAgICAgIHJhdGlvOiAwLjVcclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXHJcbiAgICAgKiAgICAgIGV4cGFuZDogZmFsc2UsXHJcbiAgICAgKlxyXG4gICAgICogICAgICBleHBhbmQ6IHtcclxuICAgICAqICAgICAgXHQvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXHJcbiAgICAgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxyXG4gICAgICpcclxuICAgICAqICAgICAgXHQvLyBzZXQgZXhwYW5kIGFyZWEgcmF0ZVxyXG4gICAgICogICAgICAgICAgcmF0ZTogMVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgd2lkdGg6IDEwLFxyXG4gICAgICogICAgICBwYWRBbmdsZTogMC4yLFxyXG4gICAgICogICAgICBzdGFydGluZ0FuZ2xlOiAxLFxyXG4gICAgICogICAgICB0aXRsZTogXCJEb251dCBUaXRsZVwiXHJcbiAgICAgKlxyXG4gICAgICogICAgICAvLyB0aXRsZSB3aXRoIGxpbmUgYnJlYWtcclxuICAgICAqICAgICAgdGl0bGU6IFwiVGl0bGUxXFxuVGl0bGUyXCJcclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIGRvbnV0X2xhYmVsX3Nob3c6IHRydWUsXHJcbiAgICBkb251dF9sYWJlbF9mb3JtYXQ6IHVuZGVmaW5lZCxcclxuICAgIGRvbnV0X2xhYmVsX3RocmVzaG9sZDogMC4wNSxcclxuICAgIGRvbnV0X2xhYmVsX3JhdGlvOiB1bmRlZmluZWQsXHJcbiAgICBkb251dF93aWR0aDogdW5kZWZpbmVkLFxyXG4gICAgZG9udXRfdGl0bGU6IFwiXCIsXHJcbiAgICBkb251dF9leHBhbmQ6IHt9LFxyXG4gICAgZG9udXRfZXhwYW5kX3JhdGU6IDAuOTgsXHJcbiAgICBkb251dF9leHBhbmRfZHVyYXRpb246IDUwLFxyXG4gICAgZG9udXRfcGFkQW5nbGU6IDAsXHJcbiAgICBkb251dF9zdGFydGluZ0FuZ2xlOiAwXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIGdhdWdlIGNvbmZpZyBvcHRpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBnYXVnZSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBnYXVnZVxyXG4gICAgICogQG1lbWJlcm9mIE9wdGlvbnNcclxuICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtnYXVnZS5mdWxsQ2lyY2xlPWZhbHNlXSBTaG93IGZ1bGwgY2lyY2xlIGFzIGRvbnV0LiBXaGVuIHNldCB0byAndHJ1ZScsIHRoZSBtYXggbGFiZWwgd2lsbCBub3QgYmUgc2hvd2VkIGR1ZSB0byBzdGFydCBhbmQgZW5kIHBvaW50cyBhcmUgc2FtZSBsb2NhdGlvbi5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGdhdWdlLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2dhdWdlLmxhYmVsLmZvcm1hdF0gU2V0IGZvcm1hdHRlciBmb3IgdGhlIGxhYmVsIG9uIGdhdWdlLiBMYWJlbCB0ZXh0IGNhbiBiZSBtdWx0aWxpbmVkIHdpdGggYFxcbmAgY2hhcmFjdGVyLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2dhdWdlLmxhYmVsLmV4dGVudHNdIFNldCBjdXN0b21pemVkIG1pbi9tYXggbGFiZWwgdGV4dC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2dhdWdlLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgZ2F1Z2UuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbZ2F1Z2UuZXhwYW5kLmR1cmF0aW9uPTUwXSBTZXQgdGhlIGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5taW49MF0gU2V0IG1pbiB2YWx1ZSBvZiB0aGUgZ2F1Z2UuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLm1heD0xMDBdIFNldCBtYXggdmFsdWUgb2YgdGhlIGdhdWdlLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtnYXVnZS5zdGFydGluZ0FuZ2xlPS0xICogTWF0aC5QSSAvIDJdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IFtnYXVnZS50aXRsZT1cIlwiXSBTZXQgdGl0bGUgb2YgZ2F1Z2UgY2hhcnQuIFVzZSBgXFxuYCBjaGFyYWN0ZXIgdG8gZW50ZXIgbGluZSBicmVhay5cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbZ2F1Z2UudW5pdHNdIFNldCB1bml0cyBvZiB0aGUgZ2F1Z2UuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW2dhdWdlLndpZHRoXSBTZXQgd2lkdGggb2YgZ2F1Z2UgY2hhcnQuXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2dhdWdlLnR5cGU9XCJzaW5nbGVcIl0gU2V0IHR5cGUgb2YgZ2F1Z2UgdG8gYmUgZGlzcGxheWVkLjxicj48YnI+XHJcbiAgICAgKiAqKkF2YWlsYWJsZSBWYWx1ZXM6KipcclxuICAgICAqIC0gc2luZ2xlXHJcbiAgICAgKiAtIG11bHRpXHJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gW2dhdWdlLmFyY3MubWluV2lkdGg9NV0gU2V0IG1pbmltYWwgd2lkdGggb2YgZ2F1Z2UgYXJjcyB1bnRpbCB0aGUgaW5uZXJSYWRpdXMgZGlzYXBwZWFycy5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiAgZ2F1Z2U6IHtcclxuICAgICAqICAgICAgZnVsbENpcmNsZTogZmFsc2UsXHJcbiAgICAgKiAgICAgIGxhYmVsOiB7XHJcbiAgICAgKiAgICAgICAgICBzaG93OiBmYWxzZSxcclxuICAgICAqICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24odmFsdWUsIHJhdGlvKSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxyXG4gICAgICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICBleHRlbnRzOiBmdW5jdGlvbih2YWx1ZSwgaXNNYXgpIHtcclxuICAgICAqICAgICAgICAgICAgICByZXR1cm4gKGlzTWF4ID8gXCJNYXg6XCIgOiBcIk1pbjpcIikgKyB2YWx1ZTtcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIGRpc2FibGUgZXhwYW5kIHRyYW5zaXRpb24gZm9yIGludGVyYWN0aW9uXHJcbiAgICAgKiAgICAgIGV4cGFuZDogZmFsc2UsXHJcbiAgICAgKlxyXG4gICAgICogICAgICBleHBhbmQ6IHtcclxuICAgICAqICAgICAgXHQvLyBzZXQgZHVyYXRpb24gb2YgZXhwYW5kIHRyYW5zaXRpb24gdG8gNTAwbXMuXHJcbiAgICAgKiAgICAgICAgICBkdXJhdGlvbjogNTAwLFxyXG4gICAgICpcclxuICAgICAqICAgICAgXHQvLyBzZXQgZXhwYW5kIGFyZWEgcmF0ZVxyXG4gICAgICogICAgICAgICAgcmF0ZTogMVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgbWluOiAtMTAwLFxyXG4gICAgICogICAgICBtYXg6IDIwMCxcclxuICAgICAqICAgICAgdHlwZTogXCJzaW5nbGVcIiAgLy8gb3IgJ211bHRpJ1xyXG4gICAgICogICAgICB0aXRsZTogXCJUaXRsZSBUZXh0XCIsXHJcbiAgICAgKiAgICAgIHVuaXRzOiBcIiVcIixcclxuICAgICAqICAgICAgd2lkdGg6IDEwLFxyXG4gICAgICogICAgICBhcmNzOiB7XHJcbiAgICAgKiAgICAgICAgICBtaW5XaWR0aDogNVxyXG4gICAgICogICAgICB9XHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBnYXVnZV9mdWxsQ2lyY2xlOiBmYWxzZSxcclxuICAgIGdhdWdlX2xhYmVsX3Nob3c6IHRydWUsXHJcbiAgICBnYXVnZV9sYWJlbF9mb3JtYXQ6IHVuZGVmaW5lZCxcclxuICAgIGdhdWdlX21pbjogMCxcclxuICAgIGdhdWdlX21heDogMTAwLFxyXG4gICAgZ2F1Z2VfdHlwZTogXCJzaW5nbGVcIixcclxuICAgIGdhdWdlX3N0YXJ0aW5nQW5nbGU6IC0xICogTWF0aC5QSSAvIDIsXHJcbiAgICBnYXVnZV9sYWJlbF9leHRlbnRzOiB1bmRlZmluZWQsXHJcbiAgICBnYXVnZV90aXRsZTogXCJcIixcclxuICAgIGdhdWdlX3VuaXRzOiB1bmRlZmluZWQsXHJcbiAgICBnYXVnZV93aWR0aDogdW5kZWZpbmVkLFxyXG4gICAgZ2F1Z2VfYXJjc19taW5XaWR0aDogNSxcclxuICAgIGdhdWdlX2V4cGFuZDoge30sXHJcbiAgICBnYXVnZV9leHBhbmRfcmF0ZTogMC45OCxcclxuICAgIGdhdWdlX2V4cGFuZF9kdXJhdGlvbjogNTBcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG4vKipcclxuICogbGluZSBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgbGluZSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBsaW5lXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2xpbmUuY29ubmVjdE51bGw9ZmFsc2VdIFNldCBpZiBudWxsIGRhdGEgcG9pbnQgd2lsbCBiZSBjb25uZWN0ZWQgb3Igbm90Ljxicj5cclxuICAgICAqICBJZiB0cnVlIHNldCwgdGhlIHJlZ2lvbiBvZiBudWxsIGRhdGEgd2lsbCBiZSBjb25uZWN0ZWQgd2l0aG91dCBhbnkgZGF0YSBwb2ludC4gSWYgZmFsc2Ugc2V0LCB0aGUgcmVnaW9uIG9mIG51bGwgZGF0YSB3aWxsIG5vdCBiZSBjb25uZWN0ZWQgYW5kIGdldCBlbXB0eS5cclxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9ICAgW2xpbmUuY2xhc3Nlcz11bmRlZmluZWRdIElmIHNldCwgdXNlZCB0byBzZXQgYSBjc3MgY2xhc3Mgb24gZWFjaCBsaW5lLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbGluZS5zdGVwLnR5cGU9c3RlcF0gQ2hhbmdlIHN0ZXAgdHlwZSBmb3Igc3RlcCBjaGFydC48YnI+XHJcbiAgICAgKiAqKkF2YWlsYWJsZSB2YWx1ZXM6KipcclxuICAgICAqIC0gc3RlcFxyXG4gICAgICogLSBzdGVwLWJlZm9yZVxyXG4gICAgICogLSBzdGVwLWFmdGVyXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58QXJyYXl9IFtsaW5lLnBvaW50PXRydWVdIFNldCB0byBmYWxzZSB0byBub3QgZHJhdyBwb2ludHMgb24gbGluZWNoYXJ0cy4gT3IgcGFzcyBhbiBhcnJheSBvZiBsaW5lIGlkcyB0byBkcmF3IHBvaW50cyBmb3IuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtsaW5lLnplcm9iYXNlZD1mYWxzZV0gU2V0IGlmIG1pbiBvciBtYXggdmFsdWUgd2lsbCBiZSAwIG9uIGxpbmUgY2hhcnQuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIGxpbmU6IHtcclxuICAgICAqICAgICAgY29ubmVjdE51bGw6IHRydWUsXHJcbiAgICAgKiAgICAgIGNsYXNzZXM6IFtcclxuICAgICAqICAgICAgICAgIFwibGluZS1jbGFzczFcIixcclxuICAgICAqICAgICAgICAgIFwibGluZS1jbGFzczJcIlxyXG4gICAgICogICAgICBdLFxyXG4gICAgICogICAgICBzdGVwOiB7XHJcbiAgICAgKiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcclxuICAgICAqICAgICAgcG9pbnQ6IGZhbHNlLFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcclxuICAgICAqICAgICAgcG9pbnQ6IFtcclxuICAgICAqICAgICAgICAgIFwiZGF0YTFcIiwgXCJkYXRhM1wiXHJcbiAgICAgKiAgICAgIF0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBsaW5lX2Nvbm5lY3ROdWxsOiBmYWxzZSxcclxuICAgIGxpbmVfc3RlcF90eXBlOiBcInN0ZXBcIixcclxuICAgIGxpbmVfemVyb2Jhc2VkOiBmYWxzZSxcclxuICAgIGxpbmVfY2xhc3NlczogdW5kZWZpbmVkLFxyXG4gICAgbGluZV9wb2ludDogdHJ1ZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHBpZSBvcHRpb25zXHJcbiAgICAgKiBAbmFtZSBwaWVcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcGllLmxhYmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxhYmVsIG9uIGVhY2ggcGllIHBpZWNlLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3BpZS5sYWJlbC5mb3JtYXRdIFNldCBmb3JtYXR0ZXIgZm9yIHRoZSBsYWJlbCBvbiBlYWNoIHBpZSBwaWVjZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLmxhYmVsLnRocmVzaG9sZD0wLjA1XSBTZXQgdGhyZXNob2xkIHRvIHNob3cvaGlkZSBsYWJlbHMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxGdW5jdGlvbn0gW3BpZS5sYWJlbC5yYXRpbz11bmRlZmluZWRdIFNldCByYXRpbyBvZiBsYWJlbHMgcG9zaXRpb24uXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW58T2JqZWN0fSBbcGllLmV4cGFuZD10cnVlXSBFbmFibGUgb3IgZGlzYWJsZSBleHBhbmRpbmcgcGllIHBpZWNlcy5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLmV4cGFuZC5yYXRlPTAuOThdIFNldCBleHBhbmQgcmF0ZS5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGllLmV4cGFuZC5kdXJhdGlvbj01MF0gU2V0IGV4cGFuZCB0cmFuc2l0aW9uIHRpbWUgaW4gbXMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcnxPYmplY3R9IFtwaWUuaW5uZXJSYWRpdXM9MF0gU2V0cyB0aGUgaW5uZXIgcmFkaXVzIG9mIHBpZSBhcmMuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5wYWRBbmdsZT0wXSBTZXQgcGFkZGluZyBiZXR3ZWVuIGRhdGEuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3BpZS5wYWRkaW5nPTBdIFNldHMgdGhlIGdhcCBiZXR3ZWVuIHBpZSBhcmNzLlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtkb251dC5zdGFydGluZ0FuZ2xlPTBdIFNldCBzdGFydGluZyBhbmdsZSB3aGVyZSBkYXRhIGRyYXdzLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICBwaWU6IHtcclxuICAgICAqICAgICAgbGFiZWw6IHtcclxuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgZm9ybWF0OiBmdW5jdGlvbih2YWx1ZSwgcmF0aW8sIGlkKSB7XHJcbiAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIGQzLmZvcm1hdChcIiRcIikodmFsdWUpO1xyXG4gICAgICpcclxuICAgICAqICAgICAgICAgICAgICAvLyB0byBtdWx0aWxpbmUsIHJldHVybiB3aXRoICdcXG4nIGNoYXJhY3RlclxyXG4gICAgICogICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSArXCIlXFxuTGluZTFcXG4yTGluZTJcIjtcclxuICAgICAqICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICB0aHJlc2hvbGQ6IDAuMSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgICAgICAvLyBzZXQgcmF0aW8gY2FsbGJhY2suIFNob3VsZCByZXR1cm4gcmF0aW8gdmFsdWVcclxuICAgICAqICAgICAgICAgIHJhdGlvOiBmdW5jdGlvbihkLCByYWRpdXMsIGgpIHtcclxuICAgICAqICAgICAgICAgICAgICAuLi5cclxuICAgICAqICAgICAgICAgICAgICByZXR1cm4gcmF0aW87XHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgLy8gb3Igc2V0IHJhdGlvIG51bWJlclxyXG4gICAgICogICAgICAgICAgcmF0aW86IDAuNVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICpcclxuICAgICAqICAgICAgLy8gZGlzYWJsZSBleHBhbmQgdHJhbnNpdGlvbiBmb3IgaW50ZXJhY3Rpb25cclxuICAgICAqICAgICAgZXhwYW5kOiBmYWxzZSxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIGV4cGFuZDoge1xyXG4gICAgICogICAgICBcdC8vIHNldCBkdXJhdGlvbiBvZiBleHBhbmQgdHJhbnNpdGlvbiB0byA1MDBtcy5cclxuICAgICAqICAgICAgICAgIGR1cmF0aW9uOiA1MDAsXHJcbiAgICAgKlxyXG4gICAgICogICAgICBcdC8vIHNldCBleHBhbmQgYXJlYSByYXRlXHJcbiAgICAgKiAgICAgICAgICByYXRlOiAxXHJcbiAgICAgKiAgICAgIH0sXHJcbiAgICAgKlxyXG4gICAgICogICAgICBpbm5lclJhZGl1czogMCxcclxuICAgICAqXHJcbiAgICAgKiAgICAgIC8vIHNldCBkaWZmZXJlbnQgaW5uZXJSYWRpdXMgZm9yIGVhY2ggZGF0YVxyXG4gICAgICogICAgICBpbm5lclJhZGl1czoge1xyXG4gICAgICogICAgICBcdGRhdGExOiAxMCxcclxuICAgICAqICAgICAgXHRkYXRhMjogMFxyXG4gICAgICogICAgICB9XHJcbiAgICAgKlxyXG4gICAgICogICAgICBwYWRBbmdsZTogMC4xLFxyXG4gICAgICogICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICogICAgICBzdGFydGluZ0FuZ2xlOiAxXHJcbiAgICAgKiAgfVxyXG4gICAgICovXHJcbiAgICBwaWVfbGFiZWxfc2hvdzogdHJ1ZSxcclxuICAgIHBpZV9sYWJlbF9mb3JtYXQ6IHVuZGVmaW5lZCxcclxuICAgIHBpZV9sYWJlbF90aHJlc2hvbGQ6IDAuMDUsXHJcbiAgICBwaWVfbGFiZWxfcmF0aW86IHVuZGVmaW5lZCxcclxuICAgIHBpZV9leHBhbmQ6IHt9LFxyXG4gICAgcGllX2V4cGFuZF9yYXRlOiAwLjk4LFxyXG4gICAgcGllX2V4cGFuZF9kdXJhdGlvbjogNTAsXHJcbiAgICBwaWVfaW5uZXJSYWRpdXM6IDAsXHJcbiAgICBwaWVfcGFkQW5nbGU6IDAsXHJcbiAgICBwaWVfcGFkZGluZzogMCxcclxuICAgIHBpZV9zdGFydGluZ0FuZ2xlOiAwXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIHggQXhpcyBjb25maWcgb3B0aW9uc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgcmFkYXIgb3B0aW9uc1xyXG4gICAgICogLSAqKk5PVEU6KipcclxuICAgICAqICA+IFdoZW4geCB0aWNrIHRleHQgY29udGFpbnMgYFxcbmAsIGl0J3MgdXNlZCBhcyBsaW5lIGJyZWFrLlxyXG4gICAgICogQG5hbWUgcmFkYXJcclxuICAgICAqIEBtZW1iZXJvZiBPcHRpb25zXHJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5heGlzLm1heD11bmRlZmluZWRdIFRoZSBtYXggdmFsdWUgb2YgYXhpcy4gSWYgbm90IGdpdmVuLCBpdCdsbCB0YWtlIHRoZSBtYXggdmFsdWUgZnJvbSB0aGUgZ2l2ZW4gZGF0YS5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmF4aXMubGluZS5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBheGlzIGxpbmUuXHJcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gW3JhZGFyLmF4aXMudGV4dC5wb3NpdGlvbi54PTBdIHggY29vcmRpbmF0ZSBwb3NpdGlvbiwgcmVsYXRpdmUgdGhlIG9yaWdpbmFsLlxyXG4gICAgICogQHByb3BlcnR5IHtOVW1iZXJ9IFtyYWRhci5heGlzLnRleHQucG9zaXRpb24ueT0wXSB5IGNvb3JkaW5hdGUgcG9zaXRpb24sIHJlbGF0aXZlIHRoZSBvcmlnaW5hbC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmF4aXMudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBheGlzIHRleHQuXHJcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyYWRhci5kaXJlY3Rpb24uY2xvY2t3aXNlPWZhbHNlXSBTZXQgdGhlIGRpcmVjdGlvbiB0byBiZSBkcmF3bi5cclxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcmFkYXIubGV2ZWwuZGVwdGg9M10gU2V0IHRoZSBsZXZlbCBkZXB0aC5cclxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JhZGFyLmxldmVsLnNob3c9dHJ1ZV0gU2hvdyBvciBoaWRlIGxldmVsLlxyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW3JhZGFyLmxldmVsLnRleHQuZm9ybWF0PSh4KSA9PiAoeCAlIDEgPT09IDAgPyB4IDogeC50b0ZpeGVkKDIpKV0gU2V0IGZvcm1hdCBmdW5jdGlvbiBmb3IgdGhlIGxldmVsIHZhbHVlLlxyXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBbcmFkYXIubGV2ZWwudGV4dC5zaG93PXRydWVdIFNob3cgb3IgaGlkZSBsZXZlbCB0ZXh0LlxyXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IFtyYWRhci5zaXplLnJhdGlvPTAuODddIFNldCBzaXplIHJhdGlvLlxyXG4gICAgICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0LlJhZGFyQ2hhcnQpXHJcbiAgICAgKiBAc2VlIFtEZW1vOiByYWRhciBheGlzXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzKVxyXG4gICAgICogQHNlZSBbRGVtbzogcmFkYXIgbGV2ZWxdKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNSYWRhckNoYXJ0T3B0aW9ucy5SYWRhckxldmVsKVxyXG4gICAgICogQHNlZSBbRGVtbzogcmFkYXIgc2l6ZV0oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI1JhZGFyQ2hhcnRPcHRpb25zLlJhZGFyU2l6ZSlcclxuICAgICAqIEBzZWUgW0RlbW86IHJhZGFyIGF4aXMgbXVsdGlsaW5lXShodHRwczovL25hdmVyLmdpdGh1Yi5pby9iaWxsYm9hcmQuanMvZGVtby8jUmFkYXJDaGFydE9wdGlvbnMuUmFkYXJBeGlzTXVsdGlsaW5lKVxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqICByYWRhcjoge1xyXG4gICAgICogICAgICBheGlzOiB7XHJcbiAgICAgKiAgICAgICAgICBtYXg6IDUwLFxyXG4gICAgICogICAgICAgICAgbGluZToge1xyXG4gICAgICogICAgICAgICAgICAgIHNob3c6IGZhbHNlXHJcbiAgICAgKiAgICAgICAgICB9LFxyXG4gICAgICogICAgICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICAgICAgIHBvc2l0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICAgICAgXHR4OiAwLFxyXG4gICAgICogICAgICAgICAgICAgIFx0eTogMFxyXG4gICAgICogICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgc2hvdzogZmFsc2VcclxuICAgICAqICAgICAgICAgIH1cclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgZGlyZWN0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICBjbG9ja3dpc2U6IHRydWVcclxuICAgICAqICAgICAgfSxcclxuICAgICAqICAgICAgbGV2ZWw6IHtcclxuICAgICAqICAgICAgICAgIHNob3c6IGZhbHNlLFxyXG4gICAgICogICAgICAgICAgdGV4dDoge1xyXG4gICAgICogICAgICAgICAgICAgIGZvcm1hdDogZnVuY3Rpb24oeCkge1xyXG4gICAgICogICAgICAgICAgICAgICAgICByZXR1cm4geCArIFwiJVwiO1xyXG4gICAgICogICAgICAgICAgICAgIH0sXHJcbiAgICAgKiAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxyXG4gICAgICogICAgICAgICAgfVxyXG4gICAgICogICAgICB9LFxyXG4gICAgICogICAgICBzaXplOiB7XHJcbiAgICAgKiAgICAgICAgICByYXRpbzogMC43XHJcbiAgICAgKiAgICAgIH1cclxuICAgICAqICB9XHJcbiAgICAgKi9cclxuICAgIHJhZGFyX2F4aXNfbWF4OiB1bmRlZmluZWQsXHJcbiAgICByYWRhcl9heGlzX2xpbmVfc2hvdzogdHJ1ZSxcclxuICAgIHJhZGFyX2F4aXNfdGV4dF9zaG93OiB0cnVlLFxyXG4gICAgcmFkYXJfYXhpc190ZXh0X3Bvc2l0aW9uOiB7fSxcclxuICAgIHJhZGFyX2xldmVsX2RlcHRoOiAzLFxyXG4gICAgcmFkYXJfbGV2ZWxfc2hvdzogdHJ1ZSxcclxuICAgIHJhZGFyX2xldmVsX3RleHRfZm9ybWF0OiAoeDogbnVtYmVyKSA9PiAoeCAlIDEgPT09IDAgPyB4IDogeC50b0ZpeGVkKDIpKSxcclxuICAgIHJhZGFyX2xldmVsX3RleHRfc2hvdzogdHJ1ZSxcclxuICAgIHJhZGFyX3NpemVfcmF0aW86IDAuODcsXHJcbiAgICByYWRhcl9kaXJlY3Rpb25fY2xvY2t3aXNlOiBmYWxzZVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbi8qKlxyXG4gKiB4IEF4aXMgY29uZmlnIG9wdGlvbnNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHNwbGluZSBvcHRpb25zXHJcbiAgICAgKiAtICoqQXZhaWxhYmxlIGludGVycG9sYXRpb24gdHlwZSB2YWx1ZXM6KipcclxuICAgICAqICAtIGJhc2lzIChkMy5jdXJ2ZUJhc2lzKVxyXG4gICAgICogIC0gYmFzaXMtY2xvc2VkIChkMy5jdXJ2ZUJhc2lzQ2xvc2VkKVxyXG4gICAgICogIC0gYmFzaXMtb3BlbiAoZDMuY3VydmVCYXNpc09wZW4pXHJcbiAgICAgKiAgLSBidW5kbGUgKGQzLmN1cnZlQnVuZGxlKVxyXG4gICAgICogIC0gY2FyZGluYWwgKGQzLmN1cnZlQ2FyZGluYWwpXHJcbiAgICAgKiAgLSBjYXJkaW5hbC1jbG9zZWQgKGQzLmN1cnZlQ2FyZGluYWxDbG9zZWQpXHJcbiAgICAgKiAgLSBjYXJkaW5hbC1vcGVuIChkMy5jdXJ2ZUNhcmRpbmFsT3BlbilcclxuICAgICAqICAtIGNhdG11bGwtcm9tIChkMy5jdXJ2ZUNhdG11bGxSb20pXHJcbiAgICAgKiAgLSBjYXRtdWxsLXJvbS1jbG9zZWQgKGQzLmN1cnZlQ2F0bXVsbFJvbUNsb3NlZClcclxuICAgICAqICAtIGNhdG11bGwtcm9tLW9wZW4gKGQzLmN1cnZlQ2F0bXVsbFJvbU9wZW4pXHJcbiAgICAgKiAgLSBtb25vdG9uZS14IChkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAqICAtIG1vbm90b25lLXkgKGQzLmN1cnZlTW9ub3RvbmVZKVxyXG4gICAgICogIC0gbmF0dXJhbCAoZDMuY3VydmVOYXR1cmFsKVxyXG4gICAgICogIC0gbGluZWFyLWNsb3NlZCAoZDMuY3VydmVMaW5lYXJDbG9zZWQpXHJcbiAgICAgKiAgLSBsaW5lYXIgKGQzLmN1cnZlTGluZWFyKVxyXG4gICAgICogIC0gc3RlcCAoZDMuY3VydmVTdGVwKVxyXG4gICAgICogIC0gc3RlcC1hZnRlciAoZDMuY3VydmVTdGVwQWZ0ZXIpXHJcbiAgICAgKiAgLSBzdGVwLWJlZm9yZSAoZDMuY3VydmVTdGVwQmVmb3JlKVxyXG4gICAgICogQG5hbWUgc3BsaW5lXHJcbiAgICAgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG4gICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbc3BsaW5lLmludGVycG9sYXRpb24udHlwZT1cImNhcmRpbmFsXCJdXHJcbiAgICAgKiBAc2VlIFtJbnRlcnBvbGF0aW9uIChkMyB2NCldKGh0dHA6Ly9ibC5vY2tzLm9yZy9lbW1hc2F1bmRlcnMvYzI1YTE0Nzk3MGRlZjJiMDJkOGM3YzI3MTlkYzc1MDIpXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogIHNwbGluZToge1xyXG4gICAgICogICAgICBpbnRlcnBvbGF0aW9uOiB7XHJcbiAgICAgKiAgICAgICAgICB0eXBlOiBcImNhcmRpbmFsXCJcclxuICAgICAqICAgICAgfVxyXG4gICAgICogIH1cclxuICAgICAqL1xyXG4gICAgc3BsaW5lX2ludGVycG9sYXRpb25fdHlwZTogXCJjYXJkaW5hbFwiXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IGRhdGEgZnJvbSBcIi4vZGF0YS9kYXRhXCI7XHJcbmltcG9ydCBheGlzIGZyb20gXCIuL2F4aXMvYXhpc1wiO1xyXG5cclxuLy8gY29tbW9uXHJcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9jb21tb24vY29sb3JcIjtcclxuaW1wb3J0IGdyaWQgZnJvbSBcIi4vY29tbW9uL2dyaWRcIjtcclxuaW1wb3J0IGludGVyYWN0aW9uIGZyb20gXCIuL2NvbW1vbi9pbnRlcmFjdGlvblwiO1xyXG5pbXBvcnQgbGVnZW5kIGZyb20gXCIuL2NvbW1vbi9sZWdlbmRcIjtcclxuaW1wb3J0IHBvaW50IGZyb20gXCIuL2NvbW1vbi9wb2ludFwiO1xyXG5pbXBvcnQgc3ViY2hhcnQgZnJvbSBcIi4vY29tbW9uL3N1YmNoYXJ0XCI7XHJcbmltcG9ydCB0aXRsZSBmcm9tIFwiLi9jb21tb24vdGl0bGVcIjtcclxuaW1wb3J0IHRvb2x0aXAgZnJvbSBcIi4vY29tbW9uL3Rvb2x0aXBcIjtcclxuaW1wb3J0IHpvb20gZnJvbSBcIi4vY29tbW9uL3pvb21cIjtcclxuXHJcbi8vIHNoYXBlXHJcbmltcG9ydCBhcmVhIGZyb20gXCIuL3NoYXBlL2FyZWFcIjtcclxuaW1wb3J0IGJhciBmcm9tIFwiLi9zaGFwZS9iYXJcIjtcclxuaW1wb3J0IGJ1YmJsZSBmcm9tIFwiLi9zaGFwZS9idWJibGVcIjtcclxuaW1wb3J0IGRvbnV0IGZyb20gXCIuL3NoYXBlL2RvbnV0XCI7XHJcbmltcG9ydCBnYXVnZSBmcm9tIFwiLi9zaGFwZS9nYXVnZVwiO1xyXG5pbXBvcnQgbGluZSBmcm9tIFwiLi9zaGFwZS9saW5lXCI7XHJcbmltcG9ydCBwaWUgZnJvbSBcIi4vc2hhcGUvcGllXCI7XHJcbmltcG9ydCByYWRhciBmcm9tIFwiLi9zaGFwZS9yYWRhclwiO1xyXG5pbXBvcnQgc3BsaW5lIGZyb20gXCIuL3NoYXBlL3NwbGluZVwiO1xyXG5cclxuaW1wb3J0IHttZXJnZU9ian0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogQ2xhc3MgdG8gc2V0IG9wdGlvbnMgb24gZ2VuZXJhdGluZyBjaGFydC5cclxuICogLSBJdCdzIGluc3RhbnRpYXRlZCBpbnRlcm5hbGx5LCBub3QgZXhwb3NlZCBmb3IgcHVibGljLlxyXG4gKiBAY2xhc3MgT3B0aW9uc1xyXG4gKiBAc2VlIHtAbGluayBiYi5nZW5lcmF0ZX0gdG8gdXNlIHRoZXNlIG9wdGlvbnMgb24gZ2VuZXJhdGluZyB0aGUgY2hhcnRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE9wdGlvbnMge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0Y29uc3QgY29tbW9uQ29uZmlnID0gbWVyZ2VPYmooe30sIGRhdGEsIGF4aXMsIGNvbG9yLCBncmlkLCBpbnRlcmFjdGlvbiwgbGVnZW5kLCBwb2ludCwgc3ViY2hhcnQsIHRpdGxlLCB0b29sdGlwLCB6b29tKTtcclxuXHRcdGNvbnN0IHNoYXBlQ29uZmlnID0gbWVyZ2VPYmooe30sIGFyZWEsIGJhciwgYnViYmxlLCBkb251dCwgZ2F1Z2UsIGxpbmUsIHBpZSwgcmFkYXIsIHNwbGluZSk7XHJcblxyXG5cdFx0cmV0dXJuIG1lcmdlT2JqKHtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNwZWNpZnkgdGhlIENTUyBzZWxlY3RvciBvciB0aGUgZWxlbWVudCB3aGljaCB0aGUgY2hhcnQgd2lsbCBiZSBzZXQgdG8uIEQzIHNlbGVjdGlvbiBvYmplY3QgY2FuIGJlIHNwZWNpZmllZCBhbHNvLjxicj5cclxuXHRcdFx0ICogSWYgb3RoZXIgY2hhcnQgaXMgc2V0IGFscmVhZHksIGl0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgbmV3IG9uZSAob25seSBvbmUgY2hhcnQgY2FuIGJlIHNldCBpbiBvbmUgZWxlbWVudCkuXHJcblx0XHRcdCAqIC0gKipOT1RFOioqIEluIGNhc2Ugb2YgZWxlbWVudCBkb2Vzbid0IGV4aXN0IG9yIG5vdCBzcGVjaWZpZWQsIHdpbGwgYWRkIGEgYDxkaXY+YCBlbGVtZW50IHRvIHRoZSBib2R5LlxyXG5cdFx0XHQgKiBAbmFtZSBiaW5kdG9cclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBiaW5kdG89I2NoYXJ0IFNwZWNpZnkgdGhlIGVsZW1lbnQgd2hlcmUgY2hhcnQgd2lsbCBiZSBkcmF3bi5cclxuXHRcdFx0ICogQHByb3BlcnR5IHtTdHJpbmd8SFRNTEVsZW1lbnR8ZDMuc2VsZWN0aW9ufSBiaW5kdG8uZWxlbWVudD0jY2hhcnQgU3BlY2lmeSB0aGUgZWxlbWVudCB3aGVyZSBjaGFydCB3aWxsIGJlIGRyYXduLlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW2JpbmR0by5jbGFzc25hbWU9YmJdIFNwZWNpZnkgdGhlIGNsYXNzIG5hbWUgb2YgYmluZCBlbGVtZW50Ljxicj5cclxuXHRcdFx0ICogICAgICoqTk9URToqKiBXaGVuIGNsYXNzIG5hbWUgaXNuJ3QgYGJiYCwgdGhlbiB5b3UgYWxzbyBuZWVkIHRvIHVwZGF0ZSB0aGUgZGVmYXVsdCBDU1MgdG8gYmUgcmVuZGVyZWQgY29ycmVjdGx5LlxyXG5cdFx0XHQgKiBAZGVmYXVsdCAjY2hhcnRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogYmluZHRvOiBcIiNteUNvbnRhaW5lclwiXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIC8vIG9yIEhUTUxFbGVtZW50XHJcblx0XHRcdCAqIGJpbmR0bzogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUNvbnRhaW5lclwiKVxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiAvLyBvciBEMyBzZWxlY3Rpb24gb2JqZWN0XHJcblx0XHRcdCAqIGJpbmR0bzogZDMuc2VsZWN0KFwiI215Q29udGFpbmVyXCIpXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIC8vIG9yIHRvIGNoYW5nZSBkZWZhdWx0IGNsYXNzbmFtZVxyXG5cdFx0XHQgKiBiaW5kdG86IHtcclxuXHRcdFx0ICogICAgZWxlbWVudDogXCIjY2hhcnRcIixcclxuXHRcdFx0ICogICAgY2xhc3NuYW1lOiBcImJpbGwtYm9hcmRcIiAgLy8gZXgpIDxkaXYgaWQ9J2NoYXJ0JyBjbGFzcz0nYmlsbC1ib2FyZCc+XHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdGJpbmR0bzogXCIjY2hhcnRcIixcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgY2hhcnQgYmFja2dyb3VuZC5cclxuXHRcdFx0ICogQG5hbWUgYmFja2dyb3VuZFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gYmFja2dyb3VuZC5jbGFzcyBTcGVjaWZ5IHRoZSBjbGFzcyBuYW1lIGZvciBiYWNrZ3JvdW5kIGVsZW1lbnQuXHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBiYWNrZ3JvdW5kLmNvbG9yIFNwZWNpZnkgdGhlIGZpbGwgY29sb3IgZm9yIGJhY2tncm91bmQgZWxlbWVudC48YnI+KipOT1RFOioqIFdpbGwgYmUgaWdub3JlZCBpZiBgaW1nVXJsYCBvcHRpb24gaXMgc2V0LlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gYmFja2dyb3VuZC5pbWdVcmwgU3BlY2lmeSB0aGUgaW1hZ2UgdXJsIHN0cmluZyBmb3IgYmFja2dyb3VuZC5cclxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5CYWNrZ3JvdW5kKVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBiYWNrZ3JvdW5kOiB7XHJcblx0XHRcdCAqICAgIGNsYXNzOiBcIm15Q2xhc3NcIixcclxuXHRcdFx0ICogICAgY29sb3I6IFwicmVkXCIsXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAgIC8vIFNldCBpbWFnZSB1cmwgZm9yIGJhY2tncm91bmQuXHJcblx0XHRcdCAqICAgIC8vIElmIHNwZWNpZmllZCwgJ2NvbG9yJyBvcHRpb24gd2lsbCBiZSBpZ25vcmVkLlxyXG5cdFx0XHQgKiAgICBpbWdVcmw6IFwiaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2ltZy9sb2dvL2JpbGxib2FyZC5qcy5zdmdcIixcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0YmFja2dyb3VuZDoge30sXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0ICdjbGlwLXBhdGgnIGF0dHJpYnV0ZSBmb3IgY2hhcnQgZWxlbWVudFxyXG5cdFx0XHQgKiAtICoqTk9URToqKlxyXG5cdFx0XHQgKiAgPiBXaGVuIGlzIGZhbHNlLCBjaGFydCBub2RlIGVsZW1lbnQgaXMgcG9zaXRpb25lZCBhZnRlciB0aGUgYXhpcyBub2RlIGluIERPTSB0cmVlIGhpZXJhcmNoeS5cclxuXHRcdFx0ICogID4gSXMgdG8gbWFrZSBjaGFydCBlbGVtZW50IHBvc2l0aW9uZWQgb3ZlciBheGlzIGVsZW1lbnQuXHJcblx0XHRcdCAqIEBuYW1lIGNsaXBQYXRoXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtCb29sZWFufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB0cnVlXHJcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuY2xpcFBhdGgpXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIGRvbid0IHNldCAnY2xpcC1wYXRoJyBhdHRyaWJ1dGVcclxuXHRcdFx0ICogY2xpcFBhdGg6IGZhbHNlXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRjbGlwUGF0aDogdHJ1ZSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgc3ZnIGVsZW1lbnQncyBjbGFzcyBuYW1lXHJcblx0XHRcdCAqIEBuYW1lIHN2Z1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge1N0cmluZ30gW3N2Zy5jbGFzc25hbWVdIGNsYXNzIG5hbWUgZm9yIHN2ZyBlbGVtZW50XHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHN2Zzoge1xyXG4gICAgICAgICAgICAgKiAgIGNsYXNzbmFtZTogXCJ0ZXN0X2NsYXNzXCJcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0c3ZnX2NsYXNzbmFtZTogdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFRoZSBkZXNpcmVkIHNpemUgb2YgdGhlIGNoYXJ0IGVsZW1lbnQuXHJcblx0XHRcdCAqIElmIHZhbHVlIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSB3aWR0aCBvZiB0aGUgY2hhcnQgd2lsbCBiZSBjYWxjdWxhdGVkIGJ5IHRoZSBzaXplIG9mIHRoZSBwYXJlbnQgZWxlbWVudCBpdCdzIGFwcGVuZGVkIHRvLlxyXG5cdFx0XHQgKiBAbmFtZSBzaXplXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbc2l6ZS53aWR0aF0gd2lkdGggb2YgdGhlIGNoYXJ0IGVsZW1lbnRcclxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtzaXplLmhlaWdodF0gaGVpZ2h0IG9mIHRoZSBjaGFydCBlbGVtZW50XHJcblx0XHRcdCAqIEBzZWUgW0RlbW9dKGh0dHBzOi8vbmF2ZXIuZ2l0aHViLmlvL2JpbGxib2FyZC5qcy9kZW1vLyNDaGFydE9wdGlvbnMuQ2hhcnRTaXplKVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiBzaXplOiB7XHJcbiAgICAgICAgICAgICAqICAgd2lkdGg6IDY0MCxcclxuICAgICAgICAgICAgICogICBoZWlnaHQ6IDQ4MFxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRzaXplX3dpZHRoOiB1bmRlZmluZWQsXHJcblx0XHRcdHNpemVfaGVpZ2h0OiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogVGhlIHBhZGRpbmcgb2YgdGhlIGNoYXJ0IGVsZW1lbnQuXHJcblx0XHRcdCAqIEBuYW1lIHBhZGRpbmdcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLnRvcF0gcGFkZGluZyBvbiB0aGUgdG9wIG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5yaWdodF0gcGFkZGluZyBvbiB0aGUgcmlnaHQgb2YgY2hhcnRcclxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFtwYWRkaW5nLmJvdHRvbV0gcGFkZGluZyBvbiB0aGUgYm90dG9tIG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbcGFkZGluZy5sZWZ0XSBwYWRkaW5nIG9uIHRoZSBsZWZ0IG9mIGNoYXJ0XHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHBhZGRpbmc6IHtcclxuICAgICAgICAgICAgICogICB0b3A6IDIwLFxyXG4gICAgICAgICAgICAgKiAgIHJpZ2h0OiAyMCxcclxuICAgICAgICAgICAgICogICBib3R0b206IDIwLFxyXG4gICAgICAgICAgICAgKiAgIGxlZnQ6IDIwXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdHBhZGRpbmdfbGVmdDogdW5kZWZpbmVkLFxyXG5cdFx0XHRwYWRkaW5nX3JpZ2h0OiB1bmRlZmluZWQsXHJcblx0XHRcdHBhZGRpbmdfdG9wOiB1bmRlZmluZWQsXHJcblx0XHRcdHBhZGRpbmdfYm90dG9tOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGNoYXJ0IHJlc2l6ZSBvcHRpb25zXHJcblx0XHRcdCAqIEBuYW1lIHJlc2l6ZVxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZXNpemUuYXV0bz10cnVlXSBTZXQgY2hhcnQgcmVzaXplIGF1dG9tYXRpY2FsbHkgb24gdmlld3BvcnQgY2hhbmdlcy5cclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogIHJlc2l6ZToge1xyXG5cdFx0XHQgKiAgICAgIGF1dG86IGZhbHNlXHJcblx0XHRcdCAqICB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRyZXNpemVfYXV0bzogdHJ1ZSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggZW50ZXJzIHRoZSBjaGFydC5cclxuXHRcdFx0ICogQG5hbWUgb25vdmVyXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbm92ZXI6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbm92ZXI6IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gbW91c2UvdG91Y2ggbGVhdmVzIHRoZSBjaGFydC5cclxuXHRcdFx0ICogQG5hbWUgb25vdXRcclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge0Z1bmN0aW9ufVxyXG5cdFx0XHQgKiBAZGVmYXVsdCB1bmRlZmluZWRcclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogLy8gQHBhcmFtIHtDaGFydH0gY3R4IC0gSW5zdGFuY2UgaXRzZWxmXHJcblx0XHRcdCAqIG9ub3V0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25vdXQ6IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIHdoZW4gdXNlciByZXNpemVzIHRoZSBzY3JlZW4uXHJcblx0XHRcdCAqIEBuYW1lIG9ucmVzaXplXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbnJlc2l6ZTogZnVuY3Rpb24oY3R4KSB7XHJcblx0XHRcdCAqICAgLi4uXHJcblx0XHRcdCAqIH1cclxuXHRcdFx0ICovXHJcblx0XHRcdG9ucmVzaXplOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHNjcmVlbiByZXNpemUgZmluaXNoZWQuXHJcblx0XHRcdCAqIEBuYW1lIG9ucmVzaXplZFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25yZXNpemVkOiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25yZXNpemVkOiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGNoYXJ0IGlzIGluaXRpYWxpemVkXHJcblx0XHRcdCAqIEBuYW1lIG9uYmVmb3JlaW5pdFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25iZWZvcmVpbml0OiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25iZWZvcmVpbml0OiB1bmRlZmluZWQsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogU2V0IGEgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZC5cclxuXHRcdFx0ICogQG5hbWUgb25pbml0XHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbmluaXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbmluaXQ6IHVuZGVmaW5lZCxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgYSBjYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIHRoZSBjaGFydCBpcyBpbml0aWFsaXplZFxyXG5cdFx0XHQgKiBAbmFtZSBvbmFmdGVyaW5pdFxyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7RnVuY3Rpb259XHJcblx0XHRcdCAqIEBkZWZhdWx0IHVuZGVmaW5lZFxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAvLyBAcGFyYW0ge0NoYXJ0fSBjdHggLSBJbnN0YW5jZSBpdHNlbGZcclxuXHRcdFx0ICogb25hZnRlcmluaXQ6IGZ1bmN0aW9uKGN0eCkge1xyXG5cdFx0XHQgKiAgIC4uLlxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHRvbmFmdGVyaW5pdDogdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBhIGNhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYXJ0IGlzIHJlbmRlcmVkLiBCYXNpY2FsbHksIHRoaXMgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgaW4gZWFjaCB0aW1lIHdoZW4gdGhlIGNoYXJ0IGlzIHJlZHJhd2VkLlxyXG5cdFx0XHQgKiBAbmFtZSBvbnJlbmRlcmVkXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtGdW5jdGlvbn1cclxuXHRcdFx0ICogQGRlZmF1bHQgdW5kZWZpbmVkXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIC8vIEBwYXJhbSB7Q2hhcnR9IGN0eCAtIEluc3RhbmNlIGl0c2VsZlxyXG5cdFx0XHQgKiBvbnJlbmRlcmVkOiBmdW5jdGlvbihjdHgpIHtcclxuXHRcdFx0ICogICAuLi5cclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0b25yZW5kZXJlZDogdW5kZWZpbmVkLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIFNldCBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uIChpbiBtaWxsaXNlY29uZHMpIGZvciBjaGFydCBhbmltYXRpb24uPGJyPjxicj5cclxuXHRcdFx0ICogLSAqKk5PVEU6KiogSWYgYDAgYG9yIGBudWxsYCBzZXQsIHRyYW5zaXRpb24gd2lsbCBiZSBza2lwcGVkLiBTbywgdGhpcyBtYWtlcyBpbml0aWFsIHJlbmRlcmluZyBmYXN0ZXIgZXNwZWNpYWxseSBpbiBjYXNlIHlvdSBoYXZlIGEgbG90IG9mIGRhdGEuXHJcblx0XHRcdCAqIEBuYW1lIHRyYW5zaXRpb25cclxuXHRcdFx0ICogQG1lbWJlcm9mIE9wdGlvbnNcclxuXHRcdFx0ICogQHR5cGUge09iamVjdH1cclxuXHRcdFx0ICogQHByb3BlcnR5IHtOdW1iZXJ9IFt0cmFuc2l0aW9uLmR1cmF0aW9uPTM1MF0gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqIHRyYW5zaXRpb246IHtcclxuXHRcdFx0ICogICAgZHVyYXRpb246IDUwMFxyXG5cdFx0XHQgKiB9XHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0cmFuc2l0aW9uX2R1cmF0aW9uOiAzNTAsXHJcblxyXG5cdFx0XHQvKipcclxuXHRcdFx0XHQqIFNldCBzY2F0dGVyIG9wdGlvbnNcclxuXHRcdFx0XHQqIEBuYW1lIHNjYXR0ZXJcclxuXHRcdFx0XHQqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdFx0KiBAdHlwZSB7T2JqZWN0fVxyXG5cdFx0XHRcdCogQHByb3BlcnR5IHtCb29sZWFufSBbc2NhdHRlci56ZXJvYmFzZWQ9ZmFsc2VdIFNldCBpZiBtaW4gb3IgbWF4IHZhbHVlIHdpbGwgYmUgMCBvbiBzY2F0dGVyIGNoYXJ0LlxyXG5cdFx0XHRcdCogQGV4YW1wbGVcclxuXHRcdFx0XHQqICBzY2F0dGVyOiB7XHJcblx0XHRcdFx0KiAgICAgIGNvbm5lY3ROdWxsOiB0cnVlLFxyXG5cdFx0XHRcdCogICAgICBzdGVwOiB7XHJcblx0XHRcdFx0KiAgICAgICAgICB0eXBlOiBcInN0ZXAtYWZ0ZXJcIlxyXG5cdFx0XHRcdCogICAgICB9LFxyXG5cdFx0XHRcdCpcclxuXHRcdFx0XHQqICAgICAgLy8gaGlkZSBhbGwgZGF0YSBwb2ludHMgKCdwb2ludC5zaG93PWZhbHNlJyBhbHNvIGhhcyBzaW1pbGFyIGVmZmVjdClcclxuXHRcdFx0XHQqICAgICAgcG9pbnQ6IGZhbHNlLFxyXG5cdFx0XHRcdCpcclxuXHRcdFx0XHQqICAgICAgLy8gc2hvdyBkYXRhIHBvaW50cyBmb3Igb25seSBpbmRpY2F0ZWQgZGF0YXNcclxuXHRcdFx0XHQqICAgICAgcG9pbnQ6IFtcclxuXHRcdFx0XHQqICAgICAgICAgIFwiZGF0YTFcIiwgXCJkYXRhM1wiXHJcblx0XHRcdFx0KiAgICAgIF0sXHJcblx0XHRcdFx0KlxyXG5cdFx0XHRcdCogICAgICB6ZXJvYmFzZWQ6IGZhbHNlXHJcblx0XHRcdFx0KiAgfVxyXG5cdFx0XHRcdCovXHJcblx0XHRcdHNjYXR0ZXJfemVyb2Jhc2VkOiBmYWxzZSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTZXQgcGx1Z2luc1xyXG5cdFx0XHQgKiBAbmFtZSBwbHVnaW5zXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtBcnJheX1cclxuXHRcdFx0ICogQGV4YW1wbGVcclxuXHRcdFx0ICogIHBsdWdpbnM6IFtcclxuXHRcdFx0ICogICAgbmV3IGJiLnBsdWdpbi5zdGFuZm9yZCh7IC4uLiB9KSxcclxuXHRcdFx0ICogICAgbmV3IFBsdWdpbkEoKSxcclxuXHRcdFx0ICogICAgLi4uXHJcblx0XHRcdCAqIF1cclxuXHRcdFx0ICovXHJcblx0XHRcdHBsdWdpbnM6IFtdLFxyXG5cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIENvbnRyb2wgdGhlIHJlbmRlciB0aW1pbmdcclxuXHRcdFx0ICogQG5hbWUgcmVuZGVyXHJcblx0XHRcdCAqIEBtZW1iZXJvZiBPcHRpb25zXHJcblx0XHRcdCAqIEB0eXBlIHtPYmplY3R9XHJcblx0XHRcdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW3JlbmRlci5sYXp5PXRydWVdIE1ha2UgdG8gbm90IHJlbmRlciBhdCBpbml0aWFsaXphdGlvbiAoZW5hYmxlZCBieSBkZWZhdWx0IHdoZW4gYmluZCBlbGVtZW50J3MgdmlzaWJpbGl0eSBpcyBoaWRkZW4pLlxyXG5cdFx0XHQgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtyZW5kZXIub2JzZXJ2ZT10cnVlXSBPYnNlcnZlIGJpbmQgZWxlbWVudCdzIHZpc2liaWxpdHkoYGRpc3BsYXlgIG9yIGB2aXNpYmxpdHlgIGlubGluZSBjc3MgcHJvcGVydHkgb3IgY2xhc3MgdmFsdWUpICYgcmVuZGVyIHdoZW4gaXMgdmlzaWJsZSBhdXRvbWF0aWNhbGx5IChmb3IgSUVzLCBvbmx5IHdvcmtzIElFMTErKS4gV2hlbiBzZXQgdG8gKipmYWxzZSoqLCBjYWxsIFtgLmZsdXNoKClgXSguL0NoYXJ0Lmh0bWwjZmx1c2gpIHRvIHJlbmRlci5cclxuXHRcdFx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0NoYXJ0T3B0aW9ucy5MYXp5UmVuZGVyKVxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKiAgcmVuZGVyOiB7XHJcblx0XHRcdCAqICAgIGxhenk6IHRydWUsXHJcblx0XHRcdCAqICAgIG9ic2VydmU6IHRydWVcclxuXHRcdFx0ICogfVxyXG5cdFx0XHQgKlxyXG5cdFx0XHQgKiBAZXhhbXBsZVxyXG5cdFx0XHQgKlx0Ly8gPCEtLSByZW5kZXIubGF6eSB3aWxsIGRldGVjdCB2aXNpYmlsaXR5IGRlZmluZWQgLS0+XHJcblx0XHRcdCAqICAvLyAoYSkgPGRpdiBpZD0nY2hhcnQnIGNsYXNzPSdoaWRlJz48L2Rpdj5cclxuXHRcdFx0ICogIC8vIChiKSA8ZGl2IGlkPSdjaGFydCcgc3R5bGU9J2Rpc3BsYXk6bm9uZSc+PC9kaXY+XHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAvLyByZW5kZXIubGF6eSBlbmFibGVkIGJ5IGRlZmF1bHQgd2hlbiBlbGVtZW50IGlzIGhpZGRlblxyXG5cdFx0XHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XHJcblx0XHRcdCAqXHJcblx0XHRcdCAqICAvLyBjaGFydCB3aWxsIGJlIHJlbmRlcmVkIGF1dG9tYXRpY2FsbHkgd2hlbiBlbGVtZW50J3MgdmlzaWJpbGl0eSBjaGFuZ2VzXHJcblx0XHRcdCAqICAvLyBOb3RlOiB3b3JrcyBvbmx5IGZvciBpbmxpbmVkIGNzcyBwcm9wZXJ0eSBvciBjbGFzcyBhdHRyaWJ1dGUgY2hhbmdlc1xyXG5cdFx0XHQgKiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NoYXJ0JykuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZScpICAvLyAoYSlcclxuXHRcdFx0ICogIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjaGFydCcpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snOyAgLy8gKGIpXHJcblx0XHRcdCAqXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqXHQvLyBjaGFydCB3b24ndCBiZSByZW5kZXJlZCBhbmQgbm90IG9ic2VydmluZyBiaW5kIGVsZW1lbnQncyB2aXNpYmxpdHkgY2hhbmdlc1xyXG5cdFx0XHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xyXG5cdFx0XHQgKiAgICAgcmVuZGVyOiB7XHJcblx0XHRcdCAqICAgICAgICAgIGxhenk6IHRydWUsXHJcblx0XHRcdCAqICAgICAgICAgIG9ic2VydmU6IGZhbHNlXHJcblx0XHRcdCAqICAgICB9XHJcblx0XHRcdCAqICB9KTtcclxuXHRcdFx0ICpcclxuXHRcdFx0ICogIC8vIGNhbGwgYXQgYW55IHBvaW50IHdoZW4geW91IHdhbnQgdG8gcmVuZGVyXHJcblx0XHRcdCAqICBjaGFydC5mbHVzaCgpO1xyXG5cdFx0XHQgKi9cclxuXHRcdFx0cmVuZGVyOiB7fSxcclxuXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiBTaG93IHJlY3RhbmdsZXMgaW5zaWRlIHRoZSBjaGFydC48YnI+PGJyPlxyXG5cdFx0XHQgKiBUaGlzIG9wdGlvbiBhY2NlcHRzIGFycmF5IGluY2x1ZGluZyBvYmplY3QgdGhhdCBoYXMgYXhpcywgc3RhcnQsIGVuZCBhbmQgY2xhc3MuXHJcblx0XHRcdCAqIFRoZSBrZXlzIHN0YXJ0LCBlbmQgYW5kIGNsYXNzIGFyZSBvcHRpb25hbC5cclxuXHRcdFx0ICogYXhpcyBtdXN0IGJlIHgsIHkgb3IgeTIuIHN0YXJ0IGFuZCBlbmQgc2hvdWxkIGJlIHRoZSB2YWx1ZSB3aGVyZSByZWdpb25zIHN0YXJ0IGFuZCBlbmQuXHJcblx0XHRcdCAqIElmIG5vdCBzcGVjaWZpZWQsIHRoZSBlZGdlIHZhbHVlcyB3aWxsIGJlIHVzZWQuXHJcblx0XHRcdCAqIElmIHRpbWVzZXJpZXMgeCBheGlzLCBkYXRlIHN0cmluZywgRGF0ZSBvYmplY3QgYW5kIHVuaXh0aW1lIGludGVnZXIgY2FuIGJlIHVzZWQuXHJcblx0XHRcdCAqIElmIGNsYXNzIGlzIHNldCwgdGhlIHJlZ2lvbiBlbGVtZW50IHdpbGwgaGF2ZSBpdCBhcyBjbGFzcy5cclxuXHRcdFx0ICogQG5hbWUgcmVnaW9uc1xyXG5cdFx0XHQgKiBAbWVtYmVyb2YgT3B0aW9uc1xyXG5cdFx0XHQgKiBAdHlwZSB7QXJyYXl9XHJcblx0XHRcdCAqIEBkZWZhdWx0IFtdXHJcblx0XHRcdCAqIEBleGFtcGxlXHJcblx0XHRcdCAqICByZWdpb25zOiBbXHJcblx0XHRcdCAqICAgIHtcclxuXHRcdFx0ICogICAgICBheGlzOiBcInhcIixcclxuXHRcdFx0ICogICAgICBzdGFydDogMSxcclxuXHRcdFx0ICogICAgICBlbmQ6IDQsXHJcblx0XHRcdCAqICAgICAgY2xhc3M6IFwicmVnaW9uLTEtNFwiXHJcblx0XHRcdCAqICAgIH1cclxuXHRcdFx0ICogIF1cclxuXHRcdFx0ICovXHJcblx0XHRcdHJlZ2lvbnM6IFtdXHJcblx0XHR9LCBjb21tb25Db25maWcsIHNoYXBlQ29uZmlnKTtcclxuXHR9XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3RvQXJyYXl9IGZyb20gXCIuL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENhY2hlIHtcclxuXHRwcml2YXRlIGNhY2hlID0ge307XHJcblxyXG5cdC8qKlxyXG5cdCAqIEFkZCBjYWNoZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcclxuXHQgKiBAcGFyYW0geyp9IHZhbHVlXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0RhdGFUeXBlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRhZGQoa2V5OiBzdHJpbmcsIHZhbHVlLCBpc0RhdGFUeXBlID0gZmFsc2UpIHtcclxuXHRcdHRoaXMuY2FjaGVba2V5XSA9IGlzRGF0YVR5cGUgPyB0aGlzLmNsb25lVGFyZ2V0KHZhbHVlKSA6IHZhbHVlO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGNhY2hlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVtb3ZlKGtleTogc3RyaW5nIHwgc3RyaW5nW10pIHtcclxuXHRcdHRvQXJyYXkoa2V5KS5mb3JFYWNoKHYgPT4gZGVsZXRlIHRoaXMuY2FjaGVbdl0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGNhaGNlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGtleVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEYXRhVHlwZVxyXG5cdCAqIEByZXR1cm4geyp9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXQoa2V5LCBpc0RhdGFUeXBlID0gZmFsc2UpIHtcclxuXHRcdGlmIChpc0RhdGFUeXBlKSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgaWQ7IChpZCA9IGtleVtpXSk7IGkrKykge1xyXG5cdFx0XHRcdGlmIChpZCBpbiB0aGlzLmNhY2hlKSB7XHJcblx0XHRcdFx0XHR0YXJnZXRzLnB1c2godGhpcy5jbG9uZVRhcmdldCh0aGlzLmNhY2hlW2lkXSkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHRhcmdldHM7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jYWNoZVtrZXldIHx8IG51bGw7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiByZXNldCBjYWNoZWQgZGF0YVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsIHRydWU6IHJlc2V0IGFsbCBkYXRhLCBmYWxzZTogcmVzZXQgb25seSAnJCcgcHJlZml4ZWQga2V5IGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG4gXHQgKi9cclxuXHRyZXNldChhbGw/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Zm9yIChjb25zdCB4IGluICQkLmNhY2hlKSB7XHJcblx0XHRcdC8vIHJlc2V0IHRoZSBwcmVmaXhlZCAnJCcga2V5KHdoaWNoIGlzIGludGVybmFsIHVzZSBkYXRhKSBvbmx5LlxyXG5cdFx0XHRpZiAoYWxsIHx8IC9eXFwkLy50ZXN0KHgpKSB7XHJcblx0XHRcdFx0JCQuY2FjaGVbeF0gPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRjbG9uZVRhcmdldCh0YXJnZXQpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGlkOiB0YXJnZXQuaWQsXHJcblx0XHRcdGlkX29yZzogdGFyZ2V0LmlkX29yZyxcclxuXHRcdFx0dmFsdWVzOiB0YXJnZXQudmFsdWVzLm1hcChkID0+ICh7eDogZC54LCB2YWx1ZTogZC52YWx1ZSwgaWQ6IGQuaWR9KSlcclxuXHRcdH07XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5pbXBvcnQge3NjYWxlTGluZWFyIGFzIGQzU2NhbGVMaW5lYXJ9IGZyb20gXCJkMy1zY2FsZVwiO1xyXG5pbXBvcnQge2lzRGVmaW5lZCwgaXNOdW1iZXIsIGlzU3RyaW5nfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNSZW5kZXJlckhlbHBlciB7XHJcblx0cHJpdmF0ZSBvd25lcjtcclxuXHRwcml2YXRlIGNvbmZpZztcclxuXHRwcml2YXRlIHNjYWxlO1xyXG5cclxuXHRjb25zdHJ1Y3Rvcihvd25lcikge1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSBkM1NjYWxlTGluZWFyKCk7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBwYXJhbXN9ID0gb3duZXI7XHJcblxyXG5cdFx0dGhpcy5vd25lciA9IG93bmVyO1xyXG5cdFx0dGhpcy5jb25maWcgPSBjb25maWc7XHJcblx0XHR0aGlzLnNjYWxlID0gc2NhbGU7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5ub1RyYW5zaXRpb24gfHwgIXBhcmFtcy5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbikge1xyXG5cdFx0XHRjb25maWcud2l0aG91dFRyYW5zaXRpb24gPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCByYW5nZVxyXG5cdFx0Y29uZmlnLnJhbmdlID0gdGhpcy5zY2FsZUV4dGVudCgocGFyYW1zLm9yZ1hTY2FsZSB8fCBzY2FsZSkucmFuZ2UoKSk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDb21wdXRlIGEgY2hhcmFjdGVyIGRpbWVuc2lvblxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBub2RlXHJcblx0ICogQHJldHVybiB7e3c6IG51bWJlciwgaDogbnVtYmVyfX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHN0YXRpYyBnZXRTaXplRm9yMUNoYXIobm9kZSkge1xyXG5cdFx0Ly8gZGVmYXVsdCBzaXplIGZvciBvbmUgY2hhcmFjdGVyXHJcblx0XHRjb25zdCBzaXplID0ge1xyXG5cdFx0XHR3OiA1LjUsXHJcblx0XHRcdGg6IDExLjVcclxuXHRcdH07XHJcblxyXG5cdFx0IW5vZGUuZW1wdHkoKSAmJiBub2RlLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LnRleHQoXCIwXCIpXHJcblx0XHRcdC5jYWxsKGVsID0+IHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gZWwubm9kZSgpLmdldEJCb3goKTtcclxuXHJcblx0XHRcdFx0XHRpZiAod2lkdGggJiYgaGVpZ2h0KSB7XHJcblx0XHRcdFx0XHRcdHNpemUudyA9IHdpZHRoO1xyXG5cdFx0XHRcdFx0XHRzaXplLmggPSBoZWlnaHQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZWwudGV4dChcIlwiKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmdldFNpemVGb3IxQ2hhciA9ICgpID0+IHNpemU7XHJcblxyXG5cdFx0cmV0dXJuIHNpemU7XHJcblx0fVxyXG5cclxuXHRheGlzWChzZWxlY3Rpb24sIHgpIHtcclxuXHRcdHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgke01hdGguY2VpbCh4KGQpICsgdGhpcy5jb25maWcudGlja09mZnNldCl9LDApYCk7XHJcblx0fVxyXG5cclxuXHRheGlzWShzZWxlY3Rpb24sIHkpIHtcclxuXHRcdHNlbGVjdGlvbi5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgwLCR7TWF0aC5jZWlsKHkoZCkpfSlgKTtcclxuXHR9XHJcblxyXG5cdHNjYWxlRXh0ZW50KGRvbWFpbikge1xyXG5cdFx0Y29uc3Qgc3RhcnQgPSBkb21haW5bMF07XHJcblx0XHRjb25zdCBzdG9wID0gZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXTtcclxuXHJcblx0XHRyZXR1cm4gc3RhcnQgPCBzdG9wID8gW3N0YXJ0LCBzdG9wXSA6IFtzdG9wLCBzdGFydF07XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRpY2tzKHNjYWxlLCBpc1lBeGVzKSB7XHJcblx0XHRjb25zdCB7dGlja1N0ZXBTaXplfSA9IHRoaXMub3duZXIucGFyYW1zO1xyXG5cdFx0bGV0IHRpY2tzID0gW107XHJcblxyXG5cdFx0Ly8gV2hlbiAnYXhpc1t5fHkyXS50aWNrLnN0ZXBTaXplJyBvcHRpb24gaXMgc2V0XHJcblx0XHRpZiAoaXNZQXhlcyAmJiB0aWNrU3RlcFNpemUpIHtcclxuXHRcdFx0Y29uc3QgW3N0YXJ0LCBlbmRdID0gc2NhbGUuZG9tYWluKCk7XHJcblx0XHRcdGxldCBpbnRlcnZhbCA9IHN0YXJ0O1xyXG5cclxuXHRcdFx0d2hpbGUgKGludGVydmFsIDw9IGVuZCkge1xyXG5cdFx0XHRcdHRpY2tzLnB1c2goaW50ZXJ2YWwpO1xyXG5cdFx0XHRcdGludGVydmFsICs9IHRpY2tTdGVwU2l6ZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChzY2FsZS50aWNrcykge1xyXG5cdFx0XHR0aWNrcyA9IHNjYWxlLnRpY2tzKFxyXG5cdFx0XHRcdC4uLih0aGlzLmNvbmZpZy50aWNrQXJndW1lbnRzIHx8IFtdKVxyXG5cdFx0XHQpLm1hcCh2ID0+IChcclxuXHRcdFx0XHQvLyByb3VuZCB0aGUgdGljayB2YWx1ZSBpZiBpcyBudW1iZXJcclxuXHRcdFx0XHQoaXNTdHJpbmcodikgJiYgaXNOdW1iZXIodikgJiYgIWlzTmFOKHYpICYmXHJcblx0XHRcdFx0XHRNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMFxyXG5cdFx0XHRcdCkgfHwgdlxyXG5cdFx0XHQpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IE1hdGguY2VpbChkb21haW5bMF0pOyBpIDwgZG9tYWluWzFdOyBpKyspIHtcclxuXHRcdFx0XHR0aWNrcy5wdXNoKGkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGlja3MubGVuZ3RoID4gMCAmJiB0aWNrc1swXSA+IDApIHtcclxuXHRcdFx0XHR0aWNrcy51bnNoaWZ0KHRpY2tzWzBdIC0gKHRpY2tzWzFdIC0gdGlja3NbMF0pKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWNrcztcclxuXHR9XHJcblxyXG5cdGNvcHlTY2FsZSgpIHtcclxuXHRcdGNvbnN0IG5ld1NjYWxlID0gdGhpcy5zY2FsZS5jb3B5KCk7XHJcblxyXG5cdFx0aWYgKCFuZXdTY2FsZS5kb21haW4oKS5sZW5ndGgpIHtcclxuXHRcdFx0bmV3U2NhbGUuZG9tYWluKHRoaXMuc2NhbGUuZG9tYWluKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBuZXdTY2FsZTtcclxuXHR9XHJcblxyXG5cdHRleHRGb3JtYXR0ZWQodikge1xyXG5cdFx0Y29uc3QgdGlja0Zvcm1hdCA9IHRoaXMuY29uZmlnLnRpY2tGb3JtYXQ7XHJcblxyXG5cdFx0Ly8gdG8gcm91bmQgZmxvYXQgbnVtYmVycyBmcm9tICdiaW5hcnkgZmxvYXRpbmcgcG9pbnQnXHJcblx0XHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3VibGUtcHJlY2lzaW9uX2Zsb2F0aW5nLXBvaW50X2Zvcm1hdFxyXG5cdFx0Ly8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4NDkxMDEvbGF5bWFucy1leHBsYW5hdGlvbi1mb3Itd2h5LWphdmFzY3JpcHQtaGFzLXdlaXJkLWZsb2F0aW5nLW1hdGgtaWVlZS03NTQtc3RhbmRcclxuXHRcdGNvbnN0IHZhbHVlID0gL1xcZCtcXC5cXGQrMHs1LH1cXGQkLy50ZXN0KHYpID8gK1N0cmluZyh2KS5yZXBsYWNlKC8wK1xcZCQvLCBcIlwiKSA6IHY7XHJcblx0XHRjb25zdCBmb3JtYXR0ZWQgPSB0aWNrRm9ybWF0ID8gdGlja0Zvcm1hdCh2YWx1ZSkgOiB2YWx1ZTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKGZvcm1hdHRlZCkgPyBmb3JtYXR0ZWQgOiBcIlwiO1xyXG5cdH1cclxuXHJcblx0dHJhbnNpdGlvbmlzZShzZWxlY3Rpb24pIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLndpdGhvdXRUcmFuc2l0aW9uID9cclxuXHRcdFx0c2VsZWN0aW9uLmludGVycnVwdCgpIDogc2VsZWN0aW9uLnRyYW5zaXRpb24oY29uZmlnLnRyYW5zaXRpb24pO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICogQGlnbm9yZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IEhlbHBlciBmcm9tIFwiLi9BeGlzUmVuZGVyZXJIZWxwZXJcIjtcclxuaW1wb3J0IHtpc0FycmF5LCB0b0FycmF5LCBpc0Z1bmN0aW9uLCBpc1N0cmluZywgaXNOdW1iZXJ9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQge2QzU2VsZWN0aW9ufSBmcm9tIFwidHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEF4aXNSZW5kZXJlciB7XHJcblx0aGVscGVyO1xyXG5cdGNvbmZpZztcclxuXHRwYXJhbXM7XHJcblx0ZztcclxuXHJcblx0Y29uc3RydWN0b3IocGFyYW1zOiBhbnkgPSB7fSkge1xyXG5cdFx0Y29uc3QgY29uZmlnID0ge1xyXG5cdFx0XHRpbm5lclRpY2tTaXplOiA2LFxyXG5cdFx0XHRvdXRlclRpY2tTaXplOiBwYXJhbXMub3V0ZXJUaWNrID8gNiA6IDAsXHJcblx0XHRcdG9yaWVudDogXCJib3R0b21cIixcclxuXHRcdFx0cmFuZ2U6IFtdLFxyXG5cdFx0XHR0aWNrQXJndW1lbnRzOiBudWxsLFxyXG5cdFx0XHR0aWNrQ2VudGVyZWQ6IG51bGwsXHJcblx0XHRcdHRpY2tDdWxsaW5nOiB0cnVlLFxyXG5cdFx0XHR0aWNrRm9ybWF0OiBudWxsLFxyXG5cdFx0XHR0aWNrTGVuZ3RoOiA5LFxyXG5cdFx0XHR0aWNrT2Zmc2V0OiAwLFxyXG5cdFx0XHR0aWNrUGFkZGluZzogMyxcclxuXHRcdFx0dGlja1ZhbHVlczogbnVsbCxcclxuXHRcdFx0dHJhbnNpdGlvbjogbnVsbCxcclxuXHRcdFx0bm9UcmFuc2l0aW9uOiBwYXJhbXMubm9UcmFuc2l0aW9uXHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbmZpZy50aWNrTGVuZ3RoID0gTWF0aC5tYXgoY29uZmlnLmlubmVyVGlja1NpemUsIDApICsgY29uZmlnLnRpY2tQYWRkaW5nO1xyXG5cclxuXHRcdHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG5cdFx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0XHR0aGlzLmhlbHBlciA9IG5ldyBIZWxwZXIodGhpcyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgYXhpcyBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtkMy5zZWxlY3Rpb259IGdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGNyZWF0ZShnOiBkM1NlbGVjdGlvbikge1xyXG5cdFx0Y29uc3QgY3R4ID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHBhcmFtcywgaGVscGVyOiBoZWxwZXJJbnN0fSA9IHRoaXM7XHJcblx0XHRjb25zdCBzY2FsZSA9IGhlbHBlckluc3Quc2NhbGU7XHJcblx0XHRjb25zdCBvcmllbnQgPSBjb25maWcub3JpZW50O1xyXG5cdFx0Y29uc3Qgc3BsaXRUaWNrVGV4dCA9IHRoaXMuc3BsaXRUaWNrVGV4dC5iaW5kKHRoaXMpO1xyXG5cdFx0Y29uc3QgaXNMZWZ0UmlnaHQgPSAvXihsZWZ0fHJpZ2h0KSQvLnRlc3Qob3JpZW50KTtcclxuXHRcdGNvbnN0IGlzVG9wQm90dG9tID0gL14odG9wfGJvdHRvbSkkLy50ZXN0KG9yaWVudCk7XHJcblxyXG5cdFx0Ly8gbGluZS90ZXh0IGVudGVyIGFuZCBwYXRoIHVwZGF0ZVxyXG5cdFx0Y29uc3QgdGlja1RyYW5zZm9ybSA9IGhlbHBlckluc3RbaXNUb3BCb3R0b20gPyBcImF4aXNYXCIgOiBcImF4aXNZXCJdO1xyXG5cdFx0Y29uc3QgYXhpc1B4ID0gdGlja1RyYW5zZm9ybSA9PT0gaGVscGVySW5zdC5heGlzWCA/IFwieVwiIDogXCJ4XCI7XHJcblx0XHRjb25zdCBzaWduID0gL14odG9wfGxlZnQpJC8udGVzdChvcmllbnQpID8gLTEgOiAxO1xyXG5cclxuXHRcdC8vIHRpY2sgdGV4dCBoZWxwZXJzXHJcblx0XHRjb25zdCByb3RhdGUgPSBwYXJhbXMudGlja1RleHRSb3RhdGU7XHJcblxyXG5cdFx0dGhpcy5jb25maWcucmFuZ2UgPSBzY2FsZS5yYW5nZUV4dGVudCA/XHJcblx0XHRcdHNjYWxlLnJhbmdlRXh0ZW50KCkgOlxyXG5cdFx0XHRoZWxwZXJJbnN0LnNjYWxlRXh0ZW50KChwYXJhbXMub3JnWFNjYWxlIHx8IHNjYWxlKS5yYW5nZSgpKTtcclxuXHJcblx0XHRjb25zdCB7aW5uZXJUaWNrU2l6ZSwgdGlja0xlbmd0aCwgcmFuZ2V9ID0gY29uZmlnO1xyXG5cclxuXHRcdC8vIC8vIGdldCB0aGUgYXhpcycgdGljayBwb3NpdGlvbiBjb25maWd1cmF0aW9uXHJcblx0XHRjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XHJcblx0XHRjb25zdCB0aWNrVGV4dFBvcyA9IG5hbWUgJiYgL14oeHx5fHkyKSQvLnRlc3QobmFtZSkgP1xyXG5cdFx0XHRwYXJhbXMuY29uZmlnW2BheGlzXyR7bmFtZX1fdGlja190ZXh0X3Bvc2l0aW9uYF0gOiB7eDogMCwgeTogMH07XHJcblxyXG5cdFx0Ly8gdGljayB2aXNpYmxpdHlcclxuXHRcdGNvbnN0IHByZWZpeCA9IG5hbWUgPT09IFwic3ViWFwiID8gYHN1YmNoYXJ0X2F4aXNfeGAgOiBgYXhpc18ke25hbWV9YDtcclxuXHRcdGNvbnN0IGF4aXNTaG93ID0gcGFyYW1zLmNvbmZpZ1tgJHtwcmVmaXh9X3Nob3dgXTtcclxuXHRcdGNvbnN0IHRpY2tTaG93ID0ge1xyXG5cdFx0XHR0aWNrOiBheGlzU2hvdyA/IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV90aWNrX3Nob3dgXSA6IGZhbHNlLFxyXG5cdFx0XHR0ZXh0OiBheGlzU2hvdyA/IHBhcmFtcy5jb25maWdbYCR7cHJlZml4fV90aWNrX3RleHRfc2hvd2BdIDogZmFsc2VcclxuXHRcdH07XHJcblxyXG5cdFx0bGV0ICRnO1xyXG5cclxuXHRcdGcuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgZyA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRsZXQgc2NhbGUwID0gdGhpcy5fX2NoYXJ0X18gfHwgc2NhbGU7XHJcblx0XHRcdGxldCBzY2FsZTEgPSBoZWxwZXJJbnN0LmNvcHlTY2FsZSgpO1xyXG5cclxuXHRcdFx0JGcgPSBnO1xyXG5cdFx0XHR0aGlzLl9fY2hhcnRfXyA9IHNjYWxlMTtcclxuXHJcblx0XHRcdGNvbmZpZy50aWNrT2Zmc2V0ID0gcGFyYW1zLmlzQ2F0ZWdvcnkgP1xyXG5cdFx0XHRcdE1hdGguY2VpbCgoc2NhbGUxKDEpIC0gc2NhbGUxKDApKSAvIDIpIDogMDtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb24gLSBkYXRhIGpvaW5cclxuXHRcdFx0Y29uc3QgcGF0aCA9IGcuc2VsZWN0QWxsKFwiLmRvbWFpblwiKS5kYXRhKFswXSk7XHJcblxyXG5cdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cclxuXHRcdFx0cGF0aC5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwiZG9tYWluXCIpXHJcblx0XHRcdFx0Lm1lcmdlKGhlbHBlckluc3QudHJhbnNpdGlvbmlzZShwYXRoKSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3Qgb3V0ZXJUaWNrU2l6ZWQgPSBjb25maWcub3V0ZXJUaWNrU2l6ZSAqIHNpZ247XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGlzVG9wQm90dG9tID9cclxuXHRcdFx0XHRcdFx0YE0ke3JhbmdlWzBdfSwke291dGVyVGlja1NpemVkfVYwSCR7cmFuZ2VbMV19ViR7b3V0ZXJUaWNrU2l6ZWR9YCA6XHJcblx0XHRcdFx0XHRcdGBNJHtvdXRlclRpY2tTaXplZH0sJHtyYW5nZVswXX1IMFYke3JhbmdlWzFdfUgke291dGVyVGlja1NpemVkfWA7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAodGlja1Nob3cudGljayB8fCB0aWNrU2hvdy50ZXh0KSB7XHJcblx0XHRcdFx0Ly8gY291bnQgb2YgdGljayBkYXRhIGluIGFycmF5XHJcblx0XHRcdFx0Y29uc3QgdGlja3MgPSBjb25maWcudGlja1ZhbHVlcyB8fCBoZWxwZXJJbnN0LmdlbmVyYXRlVGlja3Moc2NhbGUxLCBpc0xlZnRSaWdodCk7XHJcblxyXG5cdFx0XHRcdC8vIHVwZGF0ZSBzZWxlY3Rpb25cclxuXHRcdFx0XHRsZXQgdGljazogZDNTZWxlY3Rpb24gPSBnLnNlbGVjdEFsbChcIi50aWNrXCIpXHJcblx0XHRcdFx0XHQuZGF0YSh0aWNrcywgc2NhbGUxKTtcclxuXHJcblx0XHRcdFx0Ly8gZW50ZXIgc2VsZWN0aW9uXHJcblx0XHRcdFx0Y29uc3QgdGlja0VudGVyID0gdGlja1xyXG5cdFx0XHRcdFx0LmVudGVyKClcclxuXHRcdFx0XHRcdC5pbnNlcnQoXCJnXCIsIFwiLmRvbWFpblwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBcInRpY2tcIilcclxuXHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cclxuXHRcdFx0XHQvLyBNRU1POiBObyBleGl0IHRyYW5zaXRpb24uIFRoZSByZWFzb24gaXMgdGhpcyB0cmFuc2l0aW9uIGFmZmVjdHMgbWF4IHRpY2sgd2lkdGggY2FsY3VsYXRpb24gYmVjYXVzZSBvbGQgdGljayB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSB0aWNrcy5cclxuXHRcdFx0XHRjb25zdCB0aWNrRXhpdCA9IHRpY2suZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBlbnRlciArIHVwZGF0ZSBzZWxlY3Rpb25cclxuXHRcdFx0XHR0aWNrID0gdGlja0VudGVyLm1lcmdlKHRpY2spO1xyXG5cclxuXHRcdFx0XHR0aWNrU2hvdy50aWNrICYmIHRpY2tFbnRlci5hcHBlbmQoXCJsaW5lXCIpO1xyXG5cdFx0XHRcdHRpY2tTaG93LnRleHQgJiYgdGlja0VudGVyLmFwcGVuZChcInRleHRcIik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHNpemVGb3IxQ2hhciA9IEhlbHBlci5nZXRTaXplRm9yMUNoYXIodGljayk7XHJcblx0XHRcdFx0Y29uc3QgY291bnRzOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuXHRcdFx0XHRsZXQgdHNwYW46IGQzU2VsZWN0aW9uID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKFwidHNwYW5cIilcclxuXHRcdFx0XHRcdC5kYXRhKChkLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzcGxpdCA9IHBhcmFtcy50aWNrTXVsdGlsaW5lID9cclxuXHRcdFx0XHRcdFx0XHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlMSwgdGlja3MsIGlzTGVmdFJpZ2h0LCBzaXplRm9yMUNoYXIudykgOiAoXHJcblx0XHRcdFx0XHRcdFx0XHRpc0FycmF5KGhlbHBlckluc3QudGV4dEZvcm1hdHRlZChkKSkgP1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRoZWxwZXJJbnN0LnRleHRGb3JtYXR0ZWQoZCkuY29uY2F0KCkgOiBbaGVscGVySW5zdC50ZXh0Rm9ybWF0dGVkKGQpXVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHRjb3VudHNbaW5kZXhdID0gc3BsaXQubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuIHNwbGl0Lm1hcChzcGxpdHRlZCA9PiAoe2luZGV4LCBzcGxpdHRlZH0pKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0c3Bhbi5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHRcdHRzcGFuID0gdHNwYW5cclxuXHRcdFx0XHRcdC5lbnRlcigpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwidHNwYW5cIilcclxuXHRcdFx0XHRcdC5tZXJnZSh0c3BhbilcclxuXHRcdFx0XHRcdC50ZXh0KGQgPT4gZC5zcGxpdHRlZCk7XHJcblxyXG5cdFx0XHRcdC8vIHNldCA8dHNwYW4+J3MgcG9zaXRpb25cclxuXHRcdFx0XHR0c3BhblxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIGlzVG9wQm90dG9tID8gMCA6IHRpY2tMZW5ndGggKiBzaWduKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeFwiLCAoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgZHggPSAwO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKC8odG9wfGJvdHRvbSkvLnRlc3Qob3JpZW50KSAmJiByb3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0XHRkeCA9IDggKiBNYXRoLnNpbihNYXRoLlBJICogKHJvdGF0ZSAvIDE4MCkpICogKG9yaWVudCA9PT0gXCJ0b3BcIiA/IC0xIDogMSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBkeCArICh0aWNrVGV4dFBvcy54IHx8IDApO1xyXG5cdFx0XHRcdFx0fSkoKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgKGQsIGkpID0+IHtcclxuXHRcdFx0XHRcdFx0Y29uc3QgZGVmVmFsdWUgPSBcIi43MWVtXCI7XHJcblx0XHRcdFx0XHRcdGxldCBkeTogbnVtYmVyIHwgc3RyaW5nID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChvcmllbnQgIT09IFwidG9wXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRkeSA9IHNpemVGb3IxQ2hhci5oO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZHkgPSBpc0xlZnRSaWdodCA/IC0oKGNvdW50c1tkLmluZGV4XSAtIDEpICogKHNpemVGb3IxQ2hhci5oIC8gMikgLSAzKSA6XHJcblx0XHRcdFx0XHRcdFx0XHRcdCh0aWNrVGV4dFBvcy55ID09PSAwID8gZGVmVmFsdWUgOiAwKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHJldHVybiBpc051bWJlcihkeSkgJiYgdGlja1RleHRQb3MueSA/XHJcblx0XHRcdFx0XHRcdFx0ZHkgKyB0aWNrVGV4dFBvcy55IDogZHkgfHwgZGVmVmFsdWU7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0Y29uc3QgbGluZVVwZGF0ZSA9IHRpY2suc2VsZWN0KFwibGluZVwiKTtcclxuXHRcdFx0XHRjb25zdCB0ZXh0VXBkYXRlID0gdGljay5zZWxlY3QoXCJ0ZXh0XCIpO1xyXG5cclxuXHRcdFx0XHR0aWNrRW50ZXIuc2VsZWN0KFwibGluZVwiKS5hdHRyKGAke2F4aXNQeH0yYCwgaW5uZXJUaWNrU2l6ZSAqIHNpZ24pO1xyXG5cdFx0XHRcdHRpY2tFbnRlci5zZWxlY3QoXCJ0ZXh0XCIpLmF0dHIoYCR7YXhpc1B4fWAsIHRpY2tMZW5ndGggKiBzaWduKTtcclxuXHJcblx0XHRcdFx0Y3R4LnNldFRpY2tMaW5lVGV4dFBvc2l0aW9uKGxpbmVVcGRhdGUsIHRleHRVcGRhdGUpO1xyXG5cclxuXHRcdFx0XHQvLyBBcHBlbmQgPHRpdGxlPiBmb3IgdG9vbHRpcCBkaXNwbGF5XHJcblx0XHRcdFx0cGFyYW1zLnRpY2tUaXRsZSAmJiB0ZXh0VXBkYXRlLmFwcGVuZCAmJiB0ZXh0VXBkYXRlLmFwcGVuZChcInRpdGxlXCIpXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihpbmRleCkge1xyXG5cdFx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzKS50ZXh0KHBhcmFtcy50aWNrVGl0bGVbaW5kZXhdKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRpZiAoc2NhbGUxLmJhbmR3aWR0aCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHNjYWxlMTtcclxuXHRcdFx0XHRcdGNvbnN0IGR4ID0geC5iYW5kd2lkdGgoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0c2NhbGUwID0gZCA9PiB4KGQpICsgZHg7XHJcblx0XHRcdFx0XHRzY2FsZTEgPSBzY2FsZTA7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChzY2FsZTAuYmFuZHdpZHRoKSB7XHJcblx0XHRcdFx0XHRzY2FsZTAgPSBzY2FsZTE7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCB0aWNrRXhpdCwgc2NhbGUxKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRpY2tUcmFuc2Zvcm0uY2FsbChoZWxwZXJJbnN0LCB0aWNrRW50ZXIsIHNjYWxlMCk7XHJcblx0XHRcdFx0dGlja1RyYW5zZm9ybS5jYWxsKGhlbHBlckluc3QsIGhlbHBlckluc3QudHJhbnNpdGlvbmlzZSh0aWNrKS5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpLCBzY2FsZTEpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHR0aGlzLmcgPSAkZztcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aWNrIHgveSBjb29yZGluYXRlXHJcblx0ICogQHJldHVybiB7e3g6IG51bWJlciwgeTogbnVtYmVyfX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRpY2tYWSgpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IHBvcyA9IHt4OiAwLCB5OiAwfTtcclxuXHJcblx0XHRpZiAodGhpcy5wYXJhbXMuaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRwb3MueCA9IGNvbmZpZy50aWNrQ2VudGVyZWQgPyAwIDogY29uZmlnLnRpY2tPZmZzZXQ7XHJcblx0XHRcdHBvcy55ID0gY29uZmlnLnRpY2tDZW50ZXJlZCA/IGNvbmZpZy50aWNrT2Zmc2V0IDogMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcG9zO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpY2sgc2l6ZVxyXG5cdCAqIEBwYXJhbSBkXHJcblx0ICogQHJldHVybiB7bnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0VGlja1NpemUoZCkge1xyXG5cdFx0Y29uc3Qge3NjYWxlfSA9IHRoaXMuaGVscGVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2lubmVyVGlja1NpemUsIHJhbmdlfSA9IGNvbmZpZztcclxuXHJcblx0XHRjb25zdCB0aWNrUG9zaXRpb24gPSBzY2FsZShkKSArXHJcblx0XHRcdChjb25maWcudGlja0NlbnRlcmVkID8gMCA6IGNvbmZpZy50aWNrT2Zmc2V0KTtcclxuXHJcblx0XHRyZXR1cm4gcmFuZ2VbMF0gPCB0aWNrUG9zaXRpb24gJiYgdGlja1Bvc2l0aW9uIDwgcmFuZ2VbMV0gPyBpbm5lclRpY2tTaXplIDogMDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB0aWNrJ3MgbGluZSAmIHRleHQgcG9zaXRpb25cclxuXHQgKiBAcGFyYW0gbGluZVVwZGF0ZVxyXG5cdCAqIEBwYXJhbSB0ZXh0VXBkYXRlXHJcblx0ICogQHBhcmFtIHNjYWxlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRUaWNrTGluZVRleHRQb3NpdGlvbihsaW5lVXBkYXRlLCB0ZXh0VXBkYXRlKSB7XHJcblx0XHRjb25zdCB0aWNrUG9zID0gdGhpcy5nZXRUaWNrWFkoKTtcclxuXHRcdGNvbnN0IHtpbm5lclRpY2tTaXplLCBvcmllbnQsIHRpY2tMZW5ndGgsIHRpY2tPZmZzZXR9ID0gdGhpcy5jb25maWc7XHJcblx0XHRjb25zdCByb3RhdGUgPSB0aGlzLnBhcmFtcy50aWNrVGV4dFJvdGF0ZTtcclxuXHJcblx0XHRjb25zdCB0ZXh0QW5jaG9yRm9yVGV4dCA9IHIgPT4ge1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IFtcInN0YXJ0XCIsIFwiZW5kXCJdO1xyXG5cclxuXHRcdFx0b3JpZW50ID09PSBcInRvcFwiICYmIHZhbHVlLnJldmVyc2UoKTtcclxuXHJcblx0XHRcdHJldHVybiAhciA/IFwibWlkZGxlXCIgOiAociA+IDAgPyB2YWx1ZVswXSA6IHZhbHVlWzFdKTtcclxuXHRcdH07XHJcblx0XHRjb25zdCB0ZXh0VHJhbnNmb3JtID0gciA9PiAociA/IGByb3RhdGUoJHtyfSlgIDogbnVsbCk7XHJcblx0XHRjb25zdCB5Rm9yVGV4dCA9IHIgPT4ge1xyXG5cdFx0XHRjb25zdCByMiA9IHIgLyAob3JpZW50ID09PSBcImJvdHRvbVwiID8gMTUgOiAyMyk7XHJcblxyXG5cdFx0XHRyZXR1cm4gciA/IDExLjUgLSAyLjUgKiByMiAqIChyID4gMCA/IDEgOiAtMSkgOiB0aWNrTGVuZ3RoO1xyXG5cdFx0fTtcclxuXHJcblx0XHRzd2l0Y2ggKG9yaWVudCkge1xyXG5cdFx0XHRjYXNlIFwiYm90dG9tXCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB0aWNrUG9zLngpXHJcblx0XHRcdFx0XHQuYXR0cihcIngyXCIsIHRpY2tQb3MueClcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGhpcy5nZXRUaWNrU2l6ZS5iaW5kKHRoaXMpKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIDApXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZvclRleHQocm90YXRlKSlcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwidG9wXCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAtaW5uZXJUaWNrU2l6ZSk7XHJcblxyXG5cdFx0XHRcdHRleHRVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIC15Rm9yVGV4dChyb3RhdGUpICogMilcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIHRleHRBbmNob3JGb3JUZXh0KHJvdGF0ZSkpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0ZXh0VHJhbnNmb3JtKHJvdGF0ZSkpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIFwibGVmdFwiOlxyXG5cdFx0XHRcdGxpbmVVcGRhdGVcclxuXHRcdFx0XHRcdC5hdHRyKFwieDJcIiwgLWlubmVyVGlja1NpemUpXHJcblx0XHRcdFx0XHQuYXR0cihcInkxXCIsIHRpY2tQb3MueSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieTJcIiwgdGlja1Bvcy55KTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIC10aWNrTGVuZ3RoKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHRpY2tPZmZzZXQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSBcInJpZ2h0XCI6XHJcblx0XHRcdFx0bGluZVVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpbm5lclRpY2tTaXplKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCAwKTtcclxuXHJcblx0XHRcdFx0dGV4dFVwZGF0ZVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHRpY2tMZW5ndGgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgMClcclxuXHRcdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwic3RhcnRcIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyB0aGlzIHNob3VsZCBiZSBjYWxsZWQgb25seSB3aGVuIGNhdGVnb3J5IGF4aXNcclxuXHRzcGxpdFRpY2tUZXh0KGQsIHNjYWxlLCB0aWNrcywgaXNMZWZ0UmlnaHQsIGNoYXJXaWR0aCkge1xyXG5cdFx0Y29uc3Qge3BhcmFtc30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGlja1RleHQgPSB0aGlzLmhlbHBlci50ZXh0Rm9ybWF0dGVkKGQpO1xyXG5cdFx0Y29uc3Qgc3BsaXR0ZWQgPSBpc1N0cmluZyh0aWNrVGV4dCkgJiYgdGlja1RleHQuaW5kZXhPZihcIlxcblwiKSA+IC0xID9cclxuXHRcdFx0dGlja1RleHQuc3BsaXQoXCJcXG5cIikgOiBbXTtcclxuXHJcblx0XHRpZiAoc3BsaXR0ZWQubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBzcGxpdHRlZDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNBcnJheSh0aWNrVGV4dCkpIHtcclxuXHRcdFx0cmV0dXJuIHRpY2tUZXh0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCB0aWNrV2lkdGggPSBwYXJhbXMudGlja1dpZHRoO1xyXG5cclxuXHRcdGlmICghdGlja1dpZHRoIHx8IHRpY2tXaWR0aCA8PSAwKSB7XHJcblx0XHRcdHRpY2tXaWR0aCA9IGlzTGVmdFJpZ2h0ID8gOTUgOiAoXHJcblx0XHRcdFx0cGFyYW1zLmlzQ2F0ZWdvcnkgP1xyXG5cdFx0XHRcdFx0KE1hdGguY2VpbChzY2FsZSh0aWNrc1sxXSkgLSBzY2FsZSh0aWNrc1swXSkpIC0gMTIpIDogMTEwXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gc3BsaXQoc3BsaXR0ZWQsIHRleHQpIHtcclxuXHRcdFx0bGV0IHN1YnRleHQ7XHJcblx0XHRcdGxldCBzcGFjZUluZGV4O1xyXG5cdFx0XHRsZXQgdGV4dFdpZHRoO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHRleHQuY2hhckF0KGkpID09PSBcIiBcIikge1xyXG5cdFx0XHRcdFx0c3BhY2VJbmRleCA9IGk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdWJ0ZXh0ID0gdGV4dC5zdWJzdHIoMCwgaSArIDEpO1xyXG5cdFx0XHRcdHRleHRXaWR0aCA9IGNoYXJXaWR0aCAqIHN1YnRleHQubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0ZXh0IHdpZHRoIGdldHMgb3ZlciB0aWNrIHdpZHRoLCBzcGxpdCBieSBzcGFjZSBpbmRleCBvciBjdXJyZW50IGluZGV4XHJcblx0XHRcdFx0aWYgKHRpY2tXaWR0aCA8IHRleHRXaWR0aCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHNwbGl0KFxyXG5cdFx0XHRcdFx0XHRzcGxpdHRlZC5jb25jYXQodGV4dC5zdWJzdHIoMCwgc3BhY2VJbmRleCB8fCBpKSksXHJcblx0XHRcdFx0XHRcdHRleHQuc2xpY2Uoc3BhY2VJbmRleCA/IHNwYWNlSW5kZXggKyAxIDogaSlcclxuXHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gc3BsaXR0ZWQuY29uY2F0KHRleHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzcGxpdChzcGxpdHRlZCwgU3RyaW5nKHRpY2tUZXh0KSk7XHJcblx0fVxyXG5cclxuXHRzY2FsZSh4KSB7XHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuaGVscGVyLnNjYWxlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuaGVscGVyLnNjYWxlID0geDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdG9yaWVudCh4KSB7XHJcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY29uZmlnLm9yaWVudDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmNvbmZpZy5vcmllbnQgPSB4IGluIHtcclxuXHRcdFx0dG9wOiAxLFxyXG5cdFx0XHRyaWdodDogMSxcclxuXHRcdFx0Ym90dG9tOiAxLFxyXG5cdFx0XHRsZWZ0OiAxXHJcblx0XHR9ID8gU3RyaW5nKHgpIDogXCJib3R0b21cIjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tGb3JtYXQoZm9ybWF0KSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0Zvcm1hdDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcudGlja0Zvcm1hdCA9IGZvcm1hdDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHRpY2tDZW50ZXJlZChpc0NlbnRlcmVkKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcudGlja0NlbnRlcmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy50aWNrQ2VudGVyZWQgPSBpc0NlbnRlcmVkO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIHRpY2sncyBvZmZzZXQgdmFsdWUuXHJcblx0ICogVGhlIHZhbHVlIHdpbGwgYmUgc2V0IGZvciAnY2F0ZWdvcnknIGF4aXMgdHlwZS5cclxuXHQgKiBAcmV0dXJuIHtudW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR0aWNrT2Zmc2V0KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY29uZmlnLnRpY2tPZmZzZXQ7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGljayBpbnRlcnZhbCBjb3VudFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHNpemUgVG90YWwgZGF0YSBzaXplXHJcblx0ICogQHJldHVybiB7bnVtYmVyfVxyXG5cdCAqL1xyXG5cdHRpY2tJbnRlcnZhbChzaXplKSB7XHJcblx0XHRsZXQgaW50ZXJ2YWw7XHJcblxyXG5cdFx0aWYgKHRoaXMucGFyYW1zLmlzQ2F0ZWdvcnkpIHtcclxuXHRcdFx0aW50ZXJ2YWwgPSB0aGlzLmNvbmZpZy50aWNrT2Zmc2V0ICogMjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGxlbmd0aCA9IHRoaXMuZy5zZWxlY3QoXCJwYXRoLmRvbWFpblwiKVxyXG5cdFx0XHRcdC5ub2RlKClcclxuXHRcdFx0XHQuZ2V0VG90YWxMZW5ndGgoKSAtIHRoaXMuY29uZmlnLm91dGVyVGlja1NpemUgKiAyO1xyXG5cclxuXHRcdFx0aW50ZXJ2YWwgPSBsZW5ndGggLyAoc2l6ZSB8fCB0aGlzLmcuc2VsZWN0QWxsKFwibGluZVwiKS5zaXplKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpbnRlcnZhbCA9PT0gSW5maW5pdHkgPyAwIDogaW50ZXJ2YWw7XHJcblx0fVxyXG5cclxuXHR0aWNrcyguLi5hcmdzKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCFhcmdzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tBcmd1bWVudHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnRpY2tBcmd1bWVudHMgPSB0b0FycmF5KGFyZ3MpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0dGlja0N1bGxpbmcoY3VsbGluZykge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLnRpY2tDdWxsaW5nO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy50aWNrQ3VsbGluZyA9IGN1bGxpbmc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHR0aWNrVmFsdWVzKHgpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHJcblx0XHRpZiAoaXNGdW5jdGlvbih4KSkge1xyXG5cdFx0XHRjb25maWcudGlja1ZhbHVlcyA9ICgpID0+IHgodGhpcy5oZWxwZXIuc2NhbGUuZG9tYWluKCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0dXJuIGNvbmZpZy50aWNrVmFsdWVzO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25maWcudGlja1ZhbHVlcyA9IHg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRzZXRUcmFuc2l0aW9uKHQpIHtcclxuXHRcdHRoaXMuY29uZmlnLnRyYW5zaXRpb24gPSB0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufVxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0YXhpc1RvcCBhcyBkM0F4aXNUb3AsXHJcblx0YXhpc0JvdHRvbSBhcyBkM0F4aXNCb3R0b20sXHJcblx0YXhpc0xlZnQgYXMgZDNBeGlzTGVmdCxcclxuXHRheGlzUmlnaHQgYXMgZDNBeGlzUmlnaHRcclxufSBmcm9tIFwiZDMtYXhpc1wiO1xyXG5pbXBvcnQgQXhpc1JlbmRlcmVyIGZyb20gXCIuL0F4aXNSZW5kZXJlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Y2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzVmFsdWUsIGlzRW1wdHksIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIG1lcmdlT2JqLCBzb3J0VmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vQ2hhcnRJbnRlcm5hbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXhpcyB7XHJcblx0cHVibGljIG93bmVyOiBDaGFydEludGVybmFsO1xyXG5cdHByaXZhdGUgYXhlc0xpc3QgPSB7fTtcclxuXHRwcml2YXRlIG9yaWVudCA9IHtcclxuXHRcdHg6IFwiYm90dG9tXCIsXHJcblx0XHR5OiBcImxlZnRcIixcclxuXHRcdHkyOiBcInJpZ2h0XCIsXHJcblx0XHRzdWJYOiBcImJvdHRvbVwiXHJcblx0fTtcclxuXHJcblx0Y29uc3RydWN0b3Iob3duZXIpIHtcclxuXHRcdHRoaXMub3duZXIgPSBvd25lcjtcclxuXHRcdHRoaXMuc2V0T3JpZW50KCk7XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdldEF4aXNDbGFzc05hbWUoaWQpIHtcclxuXHRcdHJldHVybiBgJHtDTEFTUy5heGlzfSAke0NMQVNTW2BheGlzJHtjYXBpdGFsaXplKGlkKX1gXX1gXHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGlzSG9yaXpvbnRhbCgkJCwgZm9ySG9yaXpvbnRhbCkge1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gJCQuY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRyZXR1cm4gZm9ySG9yaXpvbnRhbCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQ7XHJcblx0fVxyXG5cclxuXHRpbml0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbiwgYXhpc30sIHN0YXRlOiB7Y2xpcH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0ID0gW1wieFwiLCBcInlcIl07XHJcblxyXG5cdFx0Y29uZmlnLmF4aXNfeTJfc2hvdyAmJiB0YXJnZXQucHVzaChcInkyXCIpO1xyXG5cclxuXHRcdHRhcmdldC5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRjb25zdCBjbGFzc0F4aXMgPSB0aGlzLmdldEF4aXNDbGFzc05hbWUodik7XHJcblx0XHRcdGNvbnN0IGF4aXNJZCA9IHYudG9VcHBlckNhc2UoKTtcclxuXHRcdFx0Y29uc3QgY2xhc3NMYWJlbCA9IENMQVNTW2BheGlzJHtheGlzSWR9TGFiZWxgXTtcclxuXHJcblx0XHRcdGF4aXNbdl0gPSBtYWluLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQXhpcylcclxuXHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRsZXQgcmVzID0gbnVsbDtcclxuXHJcblx0XHRcdFx0XHRpZiAodiA9PT0gXCJ4XCIpIHtcclxuXHRcdFx0XHRcdFx0cmVzID0gY2xpcC5wYXRoWEF4aXM7XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHYgPT09IFwieVwiICYmIGNvbmZpZy5heGlzX3lfaW5uZXIpIHtcclxuXHRcdFx0XHRcdFx0cmVzID0gY2xpcC5wYXRoWUF4aXM7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZSh2KSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZ1tgYXhpc18ke3Z9X3Nob3dgXSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIik7XHJcblxyXG5cdFx0XHRheGlzW3ZdLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTGFiZWwpXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgW1wicm90YXRlKC05MClcIiwgbnVsbF1bXHJcblx0XHRcdFx0XHR2ID09PSBcInhcIiA/ICshaXNSb3RhdGVkIDogK2lzUm90YXRlZFxyXG5cdFx0XHRcdF0pXHJcblx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgdGhpc1tgdGV4dEFuY2hvckZvciR7YXhpc0lkfUF4aXNMYWJlbGBdLmJpbmQodGhpcykpO1xyXG5cclxuXHRcdFx0dGhpcy5nZW5lcmF0ZUF4ZXModik7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBheGlzIG9yaWVudCBhY2NvcmRpbmcgb3B0aW9uIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzZXRPcmllbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7XHJcblx0XHRcdGF4aXNfcm90YXRlZDogaXNSb3RhdGVkLFxyXG5cdFx0XHRheGlzX3lfaW5uZXI6IHlJbm5lcixcclxuXHRcdFx0YXhpc195Ml9pbm5lcjogeTJJbm5lclxyXG5cdFx0fSA9ICQkLmNvbmZpZztcclxuXHJcblx0XHR0aGlzLm9yaWVudCA9IHtcclxuXHRcdFx0eDogaXNSb3RhdGVkID8gXCJsZWZ0XCIgOiBcImJvdHRvbVwiLFxyXG5cdFx0XHR5OiBpc1JvdGF0ZWQgPyAoeUlubmVyID8gXCJ0b3BcIiA6IFwiYm90dG9tXCIpIDogKHlJbm5lciA/IFwicmlnaHRcIiA6IFwibGVmdFwiKSxcclxuXHRcdFx0eTI6IGlzUm90YXRlZCA/ICh5MklubmVyID8gXCJib3R0b21cIiA6IFwidG9wXCIpIDogKHkySW5uZXIgPyBcImxlZnRcIiA6IFwicmlnaHRcIiksXHJcblx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IFwibGVmdFwiIDogXCJib3R0b21cIlxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGF4ZXNcclxuXHQgKiBJdCdzIHVzZWQgd2hlbiBheGlzJyBheGVzIG9wdGlvbiBpcyBzZXRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgQXhpcyBpZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVBeGVzKGlkOiBzdHJpbmcpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBheGVzOiBhbnlbXSA9IFtdO1xyXG5cdFx0Y29uc3QgYXhlc0NvbmZpZyA9IGNvbmZpZ1tgYXhpc18ke2lkfV9heGVzYF07XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IGQzQXhpcztcclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc0xlZnQgOiBkM0F4aXNCb3R0b207XHJcblx0XHR9IGVsc2UgaWYgKGlkID09PSBcInlcIikge1xyXG5cdFx0XHRkM0F4aXMgPSBpc1JvdGF0ZWQgPyBkM0F4aXNCb3R0b20gOiBkM0F4aXNMZWZ0O1xyXG5cdFx0fSBlbHNlIGlmIChpZCA9PT0gXCJ5MlwiKSB7XHJcblx0XHRcdGQzQXhpcyA9IGlzUm90YXRlZCA/IGQzQXhpc1RvcCA6IGQzQXhpc1JpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChheGVzQ29uZmlnLmxlbmd0aCkge1xyXG5cdFx0XHRheGVzQ29uZmlnLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdGljayA9IHYudGljayB8fCB7fTtcclxuXHRcdFx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlW2lkXS5jb3B5KCk7XHJcblxyXG5cdFx0XHRcdHYuZG9tYWluICYmIHNjYWxlLmRvbWFpbih2LmRvbWFpbik7XHJcblxyXG5cdFx0XHRcdGF4ZXMucHVzaChcclxuXHRcdFx0XHRcdGQzQXhpcyhzY2FsZSlcclxuXHRcdFx0XHRcdFx0LnRpY2tzKHRpY2suY291bnQpXHJcblx0XHRcdFx0XHRcdC50aWNrRm9ybWF0KHRpY2suZm9ybWF0IHx8ICgoeDogYW55KSA9PiB4KSlcclxuXHRcdFx0XHRcdFx0LnRpY2tWYWx1ZXModGljay52YWx1ZXMpXHJcblx0XHRcdFx0XHRcdC50aWNrU2l6ZU91dGVyKHRpY2sub3V0ZXIgPT09IGZhbHNlID8gMCA6IDYpXHJcblx0XHRcdFx0KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5heGVzTGlzdFtpZF0gPSBheGVzO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlIGF4ZXMgbm9kZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUF4ZXMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHJcblx0XHRPYmplY3Qua2V5cyh0aGlzLmF4ZXNMaXN0KS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uc3QgYXhlc0NvbmZpZyA9IGNvbmZpZ1tgYXhpc18ke2lkfV9heGVzYF07XHJcblx0XHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGVbaWRdLmNvcHkoKTtcclxuXHRcdFx0Y29uc3QgcmFuZ2UgPSBzY2FsZS5yYW5nZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5heGVzTGlzdFtpZF0uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGF4aXNSYW5nZSA9IHYuc2NhbGUoKS5yYW5nZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBhZGp1c3QgcmFuZ2UgdmFsdWUgd2l0aCB0aGUgY3VycmVudFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzg1OVxyXG5cdFx0XHRcdGlmICghcmFuZ2UuZXZlcnkoKHYsIGkpID0+IHYgPT09IGF4aXNSYW5nZVtpXSkpIHtcclxuXHRcdFx0XHRcdHYuc2NhbGUoKS5yYW5nZShyYW5nZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBjbGFzc05hbWUgPSBgJHt0aGlzLmdldEF4aXNDbGFzc05hbWUoaWQpfS0ke2kgKyAxfWA7XHJcblx0XHRcdFx0bGV0IGcgPSBtYWluLnNlbGVjdChgLiR7Y2xhc3NOYW1lLnJlcGxhY2UoL1xccy8sIFwiLlwiKX1gKTtcclxuXHJcblx0XHRcdFx0aWYgKGcuZW1wdHkoKSkge1xyXG5cdFx0XHRcdFx0ZyA9IG1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcclxuXHRcdFx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWdbYGF4aXNfJHtpZH1fc2hvd2BdID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiKVxyXG5cdFx0XHRcdFx0XHQuY2FsbCh2KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0YXhlc0NvbmZpZ1tpXS5kb21haW4gJiYgc2NhbGUuZG9tYWluKGF4ZXNDb25maWdbaV0uZG9tYWluKTtcclxuXHJcblx0XHRcdFx0XHQkJC5heGlzLnguaGVscGVyLnRyYW5zaXRpb25pc2UoZylcclxuXHRcdFx0XHRcdFx0LmNhbGwodi5zY2FsZShzY2FsZSkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShpZCwgaSArIDEpKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIGNhbGxlZCBmcm9tIDogdXBkYXRlU2NhbGVzKCkgJiBnZXRNYXhUaWNrV2lkdGgoKVxyXG5cdGdldEF4aXMobmFtZSwgc2NhbGUsIG91dGVyVGljaywgbm9UcmFuc2l0aW9uLCBub1RpY2tUZXh0Um90YXRlKTogQXhpc1JlbmRlcmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1ggPSAvXih4fHN1YlgpJC8udGVzdChuYW1lKTtcclxuXHRcdGNvbnN0IHR5cGUgPSBpc1ggPyBcInhcIiA6IG5hbWU7XHJcblxyXG5cdFx0Y29uc3QgaXNDYXRlZ29yeSA9IGlzWCAmJiAkJC5pc0NhdGVnb3JpemVkKCk7XHJcblx0XHRjb25zdCBvcmllbnQgPSB0aGlzLm9yaWVudFtuYW1lXTtcclxuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSBpc1ggPyAkJC5mb3JtYXQueEF4aXNUaWNrIDogY29uZmlnW2BheGlzXyR7bmFtZX1fdGlja19mb3JtYXRgXTtcclxuXHRcdGxldCB0aWNrVmFsdWVzID0gaXNYID8gJCQuYXhpcy54VGlja1ZhbHVlcyA6ICQkW2Ake25hbWV9QXhpc1RpY2tWYWx1ZXNgXTtcclxuXHJcblx0XHRjb25zdCBheGlzUGFyYW1zID0gbWVyZ2VPYmooe1xyXG5cdFx0XHRvdXRlclRpY2ssXHJcblx0XHRcdG5vVHJhbnNpdGlvbixcclxuXHRcdFx0Y29uZmlnLFxyXG5cdFx0XHRuYW1lLFxyXG5cdFx0XHR0aWNrVGV4dFJvdGF0ZTogbm9UaWNrVGV4dFJvdGF0ZSA/IDAgOiBjb25maWdbYGF4aXNfJHt0eXBlfV90aWNrX3JvdGF0ZWBdXHJcblx0XHR9LCBpc1ggJiYge1xyXG5cdFx0XHRpc0NhdGVnb3J5LFxyXG5cdFx0XHR0aWNrTXVsdGlsaW5lOiBjb25maWcuYXhpc194X3RpY2tfbXVsdGlsaW5lLFxyXG5cdFx0XHR0aWNrV2lkdGg6IGNvbmZpZy5heGlzX3hfdGlja193aWR0aCxcclxuXHRcdFx0dGlja1RpdGxlOiBpc0NhdGVnb3J5ICYmIGNvbmZpZy5heGlzX3hfdGlja190b29sdGlwICYmICQkLmFwaS5jYXRlZ29yaWVzKCksXHJcblx0XHRcdG9yZ1hTY2FsZTogJCQuc2NhbGUueFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCFpc1gpIHtcclxuXHRcdFx0YXhpc1BhcmFtcy50aWNrU3RlcFNpemUgPSBjb25maWdbYGF4aXNfJHt0eXBlfV90aWNrX3N0ZXBTaXplYF07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgYXhpcyA9IG5ldyBBeGlzUmVuZGVyZXIoYXhpc1BhcmFtcylcclxuXHRcdFx0LnNjYWxlKChpc1ggJiYgJCQuc2NhbGUuem9vbSkgfHwgc2NhbGUpXHJcblx0XHRcdC5vcmllbnQob3JpZW50KTtcclxuXHJcblx0XHRpZiAoaXNYICYmICQkLmlzVGltZVNlcmllcygpICYmIHRpY2tWYWx1ZXMgJiYgIWlzRnVuY3Rpb24odGlja1ZhbHVlcykpIHtcclxuXHRcdFx0dGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMubWFwKHYgPT4gJCQucGFyc2VEYXRlKHYpKTtcclxuXHRcdH0gZWxzZSBpZiAoIWlzWCAmJiAkJC5pc1RpbWVTZXJpZXNZKCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2Jsb2IvbWFzdGVyL0NIQU5HRVMubWQjdGltZS1pbnRlcnZhbHMtZDMtdGltZVxyXG5cdFx0XHRheGlzLnRpY2tzKGNvbmZpZy5heGlzX3lfdGlja190aW1lX3ZhbHVlKTtcclxuXHRcdFx0dGlja1ZhbHVlcyA9IG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dGlja1ZhbHVlcyAmJiBheGlzLnRpY2tWYWx1ZXModGlja1ZhbHVlcyk7XHJcblxyXG5cdFx0Ly8gU2V0IHRpY2tcclxuXHRcdGF4aXMudGlja0Zvcm1hdChcclxuXHRcdFx0dGlja0Zvcm1hdCB8fCAoXHJcblx0XHRcdFx0IWlzWCAmJiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAoeCA9PiBgJHt4fSVgKSlcclxuXHRcdFx0KVxyXG5cdFx0KTtcclxuXHJcblx0XHRpZiAoaXNDYXRlZ29yeSkge1xyXG5cdFx0XHRheGlzLnRpY2tDZW50ZXJlZChjb25maWcuYXhpc194X3RpY2tfY2VudGVyZWQpO1xyXG5cclxuXHRcdFx0aWYgKGlzRW1wdHkoY29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcpKSB7XHJcblx0XHRcdFx0Y29uZmlnLmF4aXNfeF90aWNrX2N1bGxpbmcgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfY291bnRgXSAmJiBheGlzLnRpY2tzKGNvbmZpZ1tgYXhpc18ke3R5cGV9X3RpY2tfY291bnRgXSk7XHJcblxyXG5cdFx0cmV0dXJuIGF4aXM7XHJcblx0fVxyXG5cclxuXHR1cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0cywgYXhpcz8pOiBzdHJpbmdbXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgZml0ID0gY29uZmlnLmF4aXNfeF90aWNrX2ZpdDtcclxuXHRcdGNvbnN0IGNvdW50ID0gY29uZmlnLmF4aXNfeF90aWNrX2NvdW50O1xyXG5cdFx0bGV0IHZhbHVlcztcclxuXHJcblx0XHRpZiAoZml0IHx8IChjb3VudCAmJiBmaXQpKSB7XHJcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdCQkLm1hcFRhcmdldHNUb1VuaXF1ZVhzKHRhcmdldHMpLFxyXG5cdFx0XHRcdGNvdW50LFxyXG5cdFx0XHRcdCQkLmlzVGltZVNlcmllcygpXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF4aXMpIHtcclxuXHRcdFx0YXhpcy50aWNrVmFsdWVzKHZhbHVlcyk7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmF4aXMueCkge1xyXG5cdFx0XHQkJC5heGlzLngudGlja1ZhbHVlcyh2YWx1ZXMpO1xyXG5cdFx0XHQkJC5heGlzLnN1YlgudGlja1ZhbHVlcyh2YWx1ZXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZXM7XHJcblx0fVxyXG5cclxuXHRnZXRJZChpZCkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzLm93bmVyO1xyXG5cclxuXHRcdHJldHVybiBpZCBpbiBjb25maWcuZGF0YV9heGVzID8gY29uZmlnLmRhdGFfYXhlc1tpZF0gOiBcInlcIjtcclxuXHR9XHJcblxyXG5cdGdldFhBeGlzVGlja0Zvcm1hdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIGZvcm1hdH0gPSAkJDtcclxuXHRcdGNvbnN0IHRpY2tGb3JtYXQgPSBjb25maWcuYXhpc194X3RpY2tfZm9ybWF0O1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDYXRlZ29yaXplZCgpO1xyXG5cdFx0bGV0IGN1cnJGb3JtYXQ7XHJcblxyXG5cdFx0aWYgKHRpY2tGb3JtYXQpIHtcclxuXHRcdFx0aWYgKGlzRnVuY3Rpb24odGlja0Zvcm1hdCkpIHtcclxuXHRcdFx0XHRjdXJyRm9ybWF0ID0gdGlja0Zvcm1hdDtcclxuXHRcdFx0fSBlbHNlIGlmIChpc1RpbWVTZXJpZXMpIHtcclxuXHRcdFx0XHRjdXJyRm9ybWF0ID0gZGF0ZSA9PiAoZGF0ZSA/IGZvcm1hdC5heGlzVGltZSh0aWNrRm9ybWF0KShkYXRlKSA6IFwiXCIpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdXJyRm9ybWF0ID0gaXNUaW1lU2VyaWVzID8gZm9ybWF0LmRlZmF1bHRBeGlzVGltZSA6IChcclxuXHRcdFx0XHRpc0NhdGVnb3JpemVkID9cclxuXHRcdFx0XHRcdCQkLmNhdGVnb3J5TmFtZSA6IHYgPT4gKHYgPCAwID8gdi50b0ZpeGVkKDApIDogdilcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihjdXJyRm9ybWF0KSA/IHYgPT5cclxuXHRcdFx0Y3VyckZvcm1hdC5hcHBseSgkJCwgaXNDYXRlZ29yaXplZCA/XHJcblx0XHRcdFx0W3YsICQkLmNhdGVnb3J5TmFtZSh2KV0gOiBbdl1cclxuXHRcdFx0KSA6IGN1cnJGb3JtYXQ7XHJcblx0fVxyXG5cclxuXHRnZXRUaWNrVmFsdWVzKGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB0aWNrVmFsdWVzID0gJCQuY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfdmFsdWVzYF07XHJcblx0XHRjb25zdCBheGlzID0gJCRbYCR7aWR9QXhpc2BdO1xyXG5cclxuXHRcdHJldHVybiAoaXNGdW5jdGlvbih0aWNrVmFsdWVzKSA/IHRpY2tWYWx1ZXMoKSA6IHRpY2tWYWx1ZXMpIHx8XHJcblx0XHRcdChheGlzID8gYXhpcy50aWNrVmFsdWVzKCkgOiB1bmRlZmluZWQpO1xyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3duZXIuY29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF07XHJcblx0fVxyXG5cclxuXHRnZXRMYWJlbFRleHQoaWQpIHtcclxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XHJcblxyXG5cdFx0cmV0dXJuIGlzU3RyaW5nKG9wdGlvbikgPyBvcHRpb24gOiAoXHJcblx0XHRcdG9wdGlvbiA/IG9wdGlvbi50ZXh0IDogbnVsbFxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdHNldExhYmVsVGV4dChpZCwgdGV4dCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IG9wdGlvbiA9IHRoaXMuZ2V0TGFiZWxPcHRpb25CeUF4aXNJZChpZCk7XHJcblxyXG5cdFx0aWYgKGlzU3RyaW5nKG9wdGlvbikpIHtcclxuXHRcdFx0Y29uZmlnW2BheGlzXyR7aWR9X2xhYmVsYF0gPSB0ZXh0O1xyXG5cdFx0fSBlbHNlIGlmIChvcHRpb24pIHtcclxuXHRcdFx0b3B0aW9uLnRleHQgPSB0ZXh0O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxQb3NpdGlvbihpZCwgZGVmYXVsdFBvc2l0aW9uKSB7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLm93bmVyLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBvcHRpb24gPSB0aGlzLmdldExhYmVsT3B0aW9uQnlBeGlzSWQoaWQpO1xyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSAoaXNPYmplY3RUeXBlKG9wdGlvbikgJiYgb3B0aW9uLnBvc2l0aW9uKSA/XHJcblx0XHRcdG9wdGlvbi5wb3NpdGlvbiA6IGRlZmF1bHRQb3NpdGlvblsrIWlzUm90YXRlZF07XHJcblxyXG5cdFx0Y29uc3QgaGFzID0gdiA9PiAhIX5wb3NpdGlvbi5pbmRleE9mKHYpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGlzSW5uZXI6IGhhcyhcImlubmVyXCIpLFxyXG5cdFx0XHRpc091dGVyOiBoYXMoXCJvdXRlclwiKSxcclxuXHRcdFx0aXNMZWZ0OiBoYXMoXCJsZWZ0XCIpLFxyXG5cdFx0XHRpc0NlbnRlcjogaGFzKFwiY2VudGVyXCIpLFxyXG5cdFx0XHRpc1JpZ2h0OiBoYXMoXCJyaWdodFwiKSxcclxuXHRcdFx0aXNUb3A6IGhhcyhcInRvcFwiKSxcclxuXHRcdFx0aXNNaWRkbGU6IGhhcyhcIm1pZGRsZVwiKSxcclxuXHRcdFx0aXNCb3R0b206IGhhcyhcImJvdHRvbVwiKVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdGdldFhBeGlzTGFiZWxQb3NpdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldExhYmVsUG9zaXRpb24oXCJ4XCIsIFtcImlubmVyLXRvcFwiLCBcImlubmVyLXJpZ2h0XCJdKTtcclxuXHR9XHJcblxyXG5cdGdldFlBeGlzTGFiZWxQb3NpdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldExhYmVsUG9zaXRpb24oXCJ5XCIsIFtcImlubmVyLXJpZ2h0XCIsIFwiaW5uZXItdG9wXCJdKTtcclxuXHR9XHJcblxyXG5cdGdldFkyQXhpc0xhYmVsUG9zaXRpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFBvc2l0aW9uKFwieTJcIiwgW1wiaW5uZXItcmlnaHRcIiwgXCJpbm5lci10b3BcIl0pO1xyXG5cdH1cclxuXHJcblx0Z2V0TGFiZWxQb3NpdGlvbkJ5SWQoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzW2BnZXQke2lkLnRvVXBwZXJDYXNlKCl9QXhpc0xhYmVsUG9zaXRpb25gXSgpO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvclhBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ4XCIpO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvcllBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRMYWJlbFRleHQoXCJ5XCIpO1xyXG5cdH1cclxuXHJcblx0dGV4dEZvclkyQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TGFiZWxUZXh0KFwieTJcIik7XHJcblx0fVxyXG5cclxuXHR4Rm9yQXhpc0xhYmVsKHBvc2l0aW9uLCBmb3JIb3Jpem9udGFsID0gdHJ1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gJCQuc3RhdGU7XHJcblx0XHRsZXQgeCA9IHBvc2l0aW9uLmlzTWlkZGxlID8gLWhlaWdodCAvIDIgOiAwO1xyXG5cclxuXHRcdGlmICh0aGlzLmlzSG9yaXpvbnRhbCgkJCwgZm9ySG9yaXpvbnRhbCkpIHtcclxuXHRcdFx0eCA9IHBvc2l0aW9uLmlzTGVmdCA/IDAgOiAoXHJcblx0XHRcdFx0cG9zaXRpb24uaXNDZW50ZXIgPyB3aWR0aCAvIDIgOiB3aWR0aFxyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIGlmIChwb3NpdGlvbi5pc0JvdHRvbSkge1xyXG5cdFx0XHR4ID0gLSQkLnN0YXRlLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblxyXG5cdGR4Rm9yQXhpc0xhYmVsKHBvc2l0aW9uLCBmb3JIb3Jpem9udGFsID0gdHJ1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0bGV0IGR4ID0gcG9zaXRpb24uaXNCb3R0b20gPyBcIjAuNWVtXCIgOiBcIjBcIjtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XHJcblx0XHRcdGR4ID0gcG9zaXRpb24uaXNMZWZ0ID8gXCIwLjVlbVwiIDogKFxyXG5cdFx0XHRcdHBvc2l0aW9uLmlzUmlnaHQgPyBcIi0wLjVlbVwiIDogXCIwXCJcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaXNUb3ApIHtcclxuXHRcdFx0ZHggPSBcIi0wLjVlbVwiO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkeDtcclxuXHR9XHJcblxyXG5cdHRleHRBbmNob3JGb3JBeGlzTGFiZWwocG9zaXRpb24sIGZvckhvcml6b250YWwgPSB0cnVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRsZXQgYW5jaG9yID0gcG9zaXRpb24uaXNNaWRkbGUgPyBcIm1pZGRsZVwiIDogXCJlbmRcIjtcclxuXHJcblx0XHRpZiAodGhpcy5pc0hvcml6b250YWwoJCQsIGZvckhvcml6b250YWwpKSB7XHJcblx0XHRcdGFuY2hvciA9IHBvc2l0aW9uLmlzTGVmdCA/IFwic3RhcnRcIiA6IChcclxuXHRcdFx0XHRwb3NpdGlvbi5pc0NlbnRlciA/IFwibWlkZGxlXCIgOiBcImVuZFwiXHJcblx0XHRcdCk7XHJcblx0XHR9IGVsc2UgaWYgKHBvc2l0aW9uLmlzQm90dG9tKSB7XHJcblx0XHRcdGFuY2hvciA9IFwic3RhcnRcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gYW5jaG9yO1xyXG5cdH1cclxuXHJcblx0eEZvclhBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy54Rm9yQXhpc0xhYmVsKHRoaXMuZ2V0WEF4aXNMYWJlbFBvc2l0aW9uKCksIGZhbHNlKTtcclxuXHR9XHJcblxyXG5cdHhGb3JZQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMueEZvckF4aXNMYWJlbCh0aGlzLmdldFlBeGlzTGFiZWxQb3NpdGlvbigpKTtcclxuXHR9XHJcblxyXG5cdHhGb3JZMkF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnhGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xyXG5cdH1cclxuXHJcblx0ZHhGb3JYQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKSwgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0ZHhGb3JZQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRZQXhpc0xhYmVsUG9zaXRpb24oKSk7XHJcblx0fVxyXG5cclxuXHRkeEZvclkyQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZHhGb3JBeGlzTGFiZWwodGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkpO1xyXG5cdH1cclxuXHJcblx0ZHlGb3JYQXhpc0xhYmVsKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGlzSW5uZXIgPSB0aGlzLmdldFhBeGlzTGFiZWxQb3NpdGlvbigpLmlzSW5uZXI7XHJcblx0XHRjb25zdCB4SGVpZ2h0ID0gY29uZmlnLmF4aXNfeF9oZWlnaHQ7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIjEuMmVtXCIgOiAtMjUgLSB0aGlzLmdldE1heFRpY2tXaWR0aChcInhcIik7XHJcblx0XHR9IGVsc2UgaWYgKGlzSW5uZXIpIHtcclxuXHRcdFx0cmV0dXJuIFwiLTAuNWVtXCI7XHJcblx0XHR9IGVsc2UgaWYgKHhIZWlnaHQpIHtcclxuXHRcdFx0cmV0dXJuIHhIZWlnaHQgLSAxMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBcIjNlbVwiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZHlGb3JZQXhpc0xhYmVsKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3QgaXNJbm5lciA9IHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNJbm5lcjtcclxuXHJcblx0XHRpZiAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiLTAuNWVtXCIgOiBcIjNlbVwiO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGlzSW5uZXIgPyBcIjEuMmVtXCIgOiAtMTAgLSAoJCQuY29uZmlnLmF4aXNfeV9pbm5lciA/IDAgOiAodGhpcy5nZXRNYXhUaWNrV2lkdGgoXCJ5XCIpICsgMTApKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGR5Rm9yWTJBeGlzTGFiZWwoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCBpc0lubmVyID0gdGhpcy5nZXRZMkF4aXNMYWJlbFBvc2l0aW9uKCkuaXNJbm5lcjtcclxuXHJcblx0XHRpZiAoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiMS4yZW1cIiA6IFwiLTIuMmVtXCI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gaXNJbm5lciA/IFwiLTAuNWVtXCIgOiAxNSArICgkJC5jb25maWcuYXhpc195Ml9pbm5lciA/IDAgOiAodGhpcy5nZXRNYXhUaWNrV2lkdGgoXCJ5MlwiKSArIDE1KSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHR0ZXh0QW5jaG9yRm9yWEF4aXNMYWJlbCgpIHtcclxuXHRcdHJldHVybiB0aGlzLnRleHRBbmNob3JGb3JBeGlzTGFiZWwodGhpcy5nZXRYQXhpc0xhYmVsUG9zaXRpb24oKSwgZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0dGV4dEFuY2hvckZvcllBeGlzTGFiZWwoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy50ZXh0QW5jaG9yRm9yQXhpc0xhYmVsKHRoaXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkpO1xyXG5cdH1cclxuXHJcblx0dGV4dEFuY2hvckZvclkyQXhpc0xhYmVsKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudGV4dEFuY2hvckZvckF4aXNMYWJlbCh0aGlzLmdldFkyQXhpc0xhYmVsUG9zaXRpb24oKSk7XHJcblx0fVxyXG5cclxuXHRnZXRNYXhUaWNrV2lkdGgoaWQ6IHN0cmluZywgd2l0aG91dFJlY29tcHV0ZT86IGJvb2xlYW4pOiBudW1iZXIge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7c3ZnLCBjaGFydH19ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyZW50VGlja01heCA9ICQkLnN0YXRlLmN1cnJlbnRNYXhUaWNrV2lkdGhzW2lkXTtcclxuXHRcdGxldCBtYXhXaWR0aCA9IDA7XHJcblxyXG5cdFx0aWYgKHdpdGhvdXRSZWNvbXB1dGUgfHwgIWNvbmZpZ1tgYXhpc18ke2lkfV9zaG93YF0pIHtcclxuXHRcdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN2Zykge1xyXG5cdFx0XHRjb25zdCBpc1lBeGlzID0gL155Mj8kLy50ZXN0KGlkKTtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3Qgc2NhbGUgPSAkJC5zY2FsZVtpZF0uY29weSgpLmRvbWFpbigkJFtgZ2V0JHtpc1lBeGlzID8gXCJZXCIgOiBcIlhcIn1Eb21haW5gXSh0YXJnZXRzVG9TaG93LCBpZCkpO1xyXG5cdFx0XHRjb25zdCBkb21haW4gPSBzY2FsZS5kb21haW4oKTtcclxuXHJcblx0XHRcdC8vIGRvIG5vdCBjb21wdXRlIGlmIGRvbWFpbiBpcyBzYW1lXHJcblx0XHRcdGlmIChpc0FycmF5KGN1cnJlbnRUaWNrTWF4LmRvbWFpbikgJiYgY3VycmVudFRpY2tNYXguZG9tYWluLmV2ZXJ5KCh2LCBpKSA9PiB2ID09PSBkb21haW5baV0pKSB7XHJcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y3VycmVudFRpY2tNYXguZG9tYWluID0gZG9tYWluO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBheGlzID0gdGhpcy5nZXRBeGlzKGlkLCBzY2FsZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcclxuXHRcdFx0Y29uc3QgdGlja0NvdW50ID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY291bnRgXTtcclxuXHJcblx0XHRcdC8vIE1ha2UgdG8gZ2VuZXJhdGUgdGhlIGZpbmFsIHRpY2sgdGV4dCB0byBiZSByZW5kZXJlZFxyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy85MjBcclxuXHRcdFx0aWYgKHRpY2tDb3VudCkge1xyXG5cdFx0XHRcdGF4aXMudGlja1ZhbHVlcyhcclxuXHRcdFx0XHRcdHRoaXMuZ2VuZXJhdGVUaWNrVmFsdWVzKFxyXG5cdFx0XHRcdFx0XHRkb21haW4sXHJcblx0XHRcdFx0XHRcdHRpY2tDb3VudCxcclxuXHRcdFx0XHRcdFx0aXNZQXhpcyA/ICQkLmlzVGltZVNlcmllc1koKSA6ICQkLmlzVGltZVNlcmllcygpXHJcblx0XHRcdFx0XHQpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0IWlzWUF4aXMgJiYgdGhpcy51cGRhdGVYQXhpc1RpY2tWYWx1ZXModGFyZ2V0c1RvU2hvdywgYXhpcyk7XHJcblxyXG5cdFx0XHRjb25zdCBkdW1teSA9IGNoYXJ0LmFwcGVuZChcInN2Z1wiKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJoaWRkZW5cIilcclxuXHRcdFx0XHQuc3R5bGUoXCJwb3NpdGlvblwiLCBcImZpeGVkXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidG9wXCIsIFwiMHB4XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwibGVmdFwiLCBcIjBweFwiKTtcclxuXHJcblx0XHRcdGF4aXMuY3JlYXRlKGR1bW15KTtcclxuXHJcblx0XHRcdGR1bW15LnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZHVtbXkucmVtb3ZlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG1heFdpZHRoID4gMCkge1xyXG5cdFx0XHRjdXJyZW50VGlja01heC5zaXplID0gbWF4V2lkdGg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGN1cnJlbnRUaWNrTWF4LnNpemU7XHJcblx0fVxyXG5cclxuXHR1cGRhdGVMYWJlbHMod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHJcblx0XHRjb25zdCBsYWJlbHMgPSB7XHJcblx0XHRcdFg6IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH0gLiR7Q0xBU1MuYXhpc1hMYWJlbH1gKSxcclxuXHRcdFx0WTogbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZfSAuJHtDTEFTUy5heGlzWUxhYmVsfWApLFxyXG5cdFx0XHRZMjogbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNZMn0gLiR7Q0xBU1MuYXhpc1kyTGFiZWx9YClcclxuXHRcdH07XHJcblxyXG5cdFx0T2JqZWN0LmtleXMobGFiZWxzKS5maWx0ZXIoaWQgPT4gIWxhYmVsc1tpZF0uZW1wdHkoKSlcclxuXHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgbm9kZSA9IGxhYmVsc1t2XTtcclxuXHRcdFx0XHRjb25zdCBheGlzTGFiZWwgPSBgJHt2fUF4aXNMYWJlbGA7XHJcblxyXG5cdFx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IG5vZGUudHJhbnNpdGlvbigpIDogbm9kZSlcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCB0aGlzW2B4Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSlcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgdGhpc1tgZHhGb3Ike2F4aXNMYWJlbH1gXS5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkeVwiLCB0aGlzW2BkeUZvciR7YXhpc0xhYmVsfWBdLmJpbmQodGhpcykpXHJcblx0XHRcdFx0XHQudGV4dCh0aGlzW2B0ZXh0Rm9yJHtheGlzTGFiZWx9YF0uYmluZCh0aGlzKSk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Z2V0UGFkZGluZyhwYWRkaW5nLCBrZXksIGRlZmF1bHRWYWx1ZSwgZG9tYWluTGVuZ3RoKSB7XHJcblx0XHRjb25zdCBwID0gaXNOdW1iZXIocGFkZGluZykgPyBwYWRkaW5nIDogcGFkZGluZ1trZXldO1xyXG5cclxuXHRcdGlmICghaXNWYWx1ZShwKSkge1xyXG5cdFx0XHRyZXR1cm4gZGVmYXVsdFZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKHAsIGRvbWFpbkxlbmd0aCk7XHJcblx0fVxyXG5cclxuXHRjb252ZXJ0UGl4ZWxzVG9BeGlzUGFkZGluZyhwaXhlbHMsIGRvbWFpbkxlbmd0aCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aWR0aCwgaGVpZ2h0fX0gPSAkJDtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyB3aWR0aCA6IGhlaWdodDtcclxuXHJcblx0XHRyZXR1cm4gZG9tYWluTGVuZ3RoICogKHBpeGVscyAvIGxlbmd0aCk7XHJcblx0fVxyXG5cclxuXHRnZW5lcmF0ZVRpY2tWYWx1ZXModmFsdWVzLCB0aWNrQ291bnQsIGZvclRpbWVTZXJpZXMpIHtcclxuXHRcdGxldCB0aWNrVmFsdWVzID0gdmFsdWVzO1xyXG5cdFx0bGV0IHN0YXJ0O1xyXG5cdFx0bGV0IGVuZDtcclxuXHRcdGxldCBjb3VudDtcclxuXHRcdGxldCBpbnRlcnZhbDtcclxuXHRcdGxldCBpO1xyXG5cdFx0bGV0IHRpY2tWYWx1ZTtcclxuXHJcblx0XHRpZiAodGlja0NvdW50KSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldENvdW50ID0gaXNGdW5jdGlvbih0aWNrQ291bnQpID8gdGlja0NvdW50KCkgOiB0aWNrQ291bnQ7XHJcblxyXG5cdFx0XHQvLyBjb21wdXRlIHRpY2tzIGFjY29yZGluZyB0byB0aWNrQ291bnRcclxuXHRcdFx0aWYgKHRhcmdldENvdW50ID09PSAxKSB7XHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID09PSAyKSB7XHJcblx0XHRcdFx0dGlja1ZhbHVlcyA9IFt2YWx1ZXNbMF0sIHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKHRhcmdldENvdW50ID4gMikge1xyXG5cdFx0XHRcdGNvbnN0IGlzQ2F0ZWdvcml6ZWQgPSB0aGlzLm93bmVyLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHJcblx0XHRcdFx0Y291bnQgPSB0YXJnZXRDb3VudCAtIDI7XHJcblx0XHRcdFx0c3RhcnQgPSB2YWx1ZXNbMF07XHJcblx0XHRcdFx0ZW5kID0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXTtcclxuXHRcdFx0XHRpbnRlcnZhbCA9IChlbmQgLSBzdGFydCkgLyAoY291bnQgKyAxKTtcclxuXHJcblx0XHRcdFx0Ly8gcmUtY29uc3RydWN0IHVuaXF1ZSB2YWx1ZXNcclxuXHRcdFx0XHR0aWNrVmFsdWVzID0gW3N0YXJ0XTtcclxuXHJcblx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuXHRcdFx0XHRcdHRpY2tWYWx1ZSA9ICtzdGFydCArIGludGVydmFsICogKGkgKyAxKTtcclxuXHRcdFx0XHRcdHRpY2tWYWx1ZXMucHVzaChcclxuXHRcdFx0XHRcdFx0Zm9yVGltZVNlcmllcyA/IG5ldyBEYXRlKHRpY2tWYWx1ZSkgOiAoXHJcblx0XHRcdFx0XHRcdFx0aXNDYXRlZ29yaXplZCA/IE1hdGgucm91bmQodGlja1ZhbHVlKSA6IHRpY2tWYWx1ZVxyXG5cdFx0XHRcdFx0XHQpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGlja1ZhbHVlcy5wdXNoKGVuZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWZvclRpbWVTZXJpZXMpIHtcclxuXHRcdFx0dGlja1ZhbHVlcyA9IHRpY2tWYWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWNrVmFsdWVzO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLm93bmVyO1xyXG5cdFx0Y29uc3QgYXhpcyA9ICQkLiRlbC5heGlzO1xyXG5cclxuXHRcdGNvbnN0IFtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1YlhdID0gW1wieFwiLCBcInlcIiwgXCJ5MlwiLCBcInN1YlhcIl1cclxuXHRcdFx0Lm1hcCh2ID0+IHtcclxuXHRcdFx0XHRsZXQgYXggPSBheGlzW3ZdO1xyXG5cclxuXHRcdFx0XHRpZiAoYXggJiYgZHVyYXRpb24pIHtcclxuXHRcdFx0XHRcdGF4ID0gYXgudHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBheDtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHtheGlzWCwgYXhpc1ksIGF4aXNZMiwgYXhpc1N1Ylh9O1xyXG5cdH1cclxuXHJcblx0cmVkcmF3KHRyYW5zaXRpb25zLCBpc0hpZGRlbiwgaXNJbml0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBvcGFjaXR5ID0gaXNIaWRkZW4gPyBcIjBcIiA6IFwiMVwiO1xyXG5cclxuXHRcdFtcInhcIiwgXCJ5XCIsIFwieTJcIiwgXCJzdWJYXCJdLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25zdCBheGlzID0gJCQuYXhpc1tpZF07XHJcblx0XHRcdGNvbnN0ICRheGlzID0gJGVsLmF4aXNbaWRdO1xyXG5cclxuXHRcdFx0aWYgKGF4aXMpIHtcclxuXHRcdFx0XHRpZiAoIWlzSW5pdCkge1xyXG5cdFx0XHRcdFx0YXhpcy5jb25maWcud2l0aG91dFRyYW5zaXRpb24gPSAhY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb247XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQkYXhpcy5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eSk7XHJcblx0XHRcdFx0YXhpcy5jcmVhdGUodHJhbnNpdGlvbnNbYGF4aXMke2NhcGl0YWxpemUoaWQpfWBdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGVBeGVzKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgYXhpc1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzVG9TaG93IHRhcmdldHMgZGF0YSB0byBiZSBzaG93blxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB3dGhcclxuXHQgKiBAcGFyYW0ge09qYmVjdH0gdHJhbnNpdGlvbnNcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmxvd1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3QXhpcyh0YXJnZXRzVG9TaG93LCB3dGgsIHRyYW5zaXRpb25zLCBmbG93LCBpc0luaXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5vd25lcjtcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBoYXNab29tID0gISFzY2FsZS56b29tO1xyXG5cdFx0bGV0IHhEb21haW5Gb3Jab29tO1xyXG5cclxuXHRcdGlmICghaGFzWm9vbSAmJiAkJC5pc0NhdGVnb3JpemVkKCkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0c2NhbGUueC5kb21haW4oWzAsICRlbC5heGlzLnguc2VsZWN0QWxsKFwiLnRpY2tcIikuc2l6ZSgpXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHNjYWxlLnggJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcclxuXHRcdFx0IWhhc1pvb20gJiZcclxuXHRcdFx0XHQkJC51cGRhdGVYRG9tYWluKHRhcmdldHNUb1Nob3csIHd0aC5VcGRhdGVYRG9tYWluLCB3dGguVXBkYXRlT3JnWERvbWFpbiwgd3RoLlRyaW1YRG9tYWluKTtcclxuXHJcblx0XHRcdGlmICghY29uZmlnLmF4aXNfeF90aWNrX3ZhbHVlcykge1xyXG5cdFx0XHRcdHRoaXMudXBkYXRlWEF4aXNUaWNrVmFsdWVzKHRhcmdldHNUb1Nob3cpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKCQkLmF4aXMueCkge1xyXG5cdFx0XHQkJC5heGlzLngudGlja1ZhbHVlcyhbXSk7XHJcblx0XHRcdCQkLmF4aXMuc3ViWC50aWNrVmFsdWVzKFtdKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29uZmlnLnpvb21fcmVzY2FsZSAmJiAhZmxvdykge1xyXG5cdFx0XHR4RG9tYWluRm9yWm9vbSA9IHNjYWxlLngub3JnRG9tYWluKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0W1wieVwiLCBcInkyXCJdLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0Y29uc3QgYXhpcyA9IHNjYWxlW2tleV07XHJcblxyXG5cdFx0XHRpZiAoYXhpcykge1xyXG5cdFx0XHRcdGNvbnN0IHRpY2tWYWx1ZXMgPSBjb25maWdbYGF4aXNfJHtrZXl9X3RpY2tfdmFsdWVzYF07XHJcblx0XHRcdFx0Y29uc3QgdGlja0NvdW50ID0gY29uZmlnW2BheGlzXyR7a2V5fV90aWNrX2NvdW50YF07XHJcblxyXG5cdFx0XHRcdGF4aXMuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywga2V5LCB4RG9tYWluRm9yWm9vbSkpO1xyXG5cclxuXHRcdFx0XHRpZiAoIXRpY2tWYWx1ZXMgJiYgdGlja0NvdW50KSB7XHJcblx0XHRcdFx0XHRjb25zdCBkb21haW4gPSBheGlzLmRvbWFpbigpO1xyXG5cclxuXHRcdFx0XHRcdCQkW2Ake2tleX1BeGlzYF0udGlja1ZhbHVlcyhcclxuXHRcdFx0XHRcdFx0dGhpcy5nZW5lcmF0ZVRpY2tWYWx1ZXMoXHJcblx0XHRcdFx0XHRcdFx0ZG9tYWluLFxyXG5cdFx0XHRcdFx0XHRcdGRvbWFpbi5ldmVyeSh2ID0+IHYgPT09IDApID8gMSA6IHRpY2tDb3VudCxcclxuXHRcdFx0XHRcdFx0XHQkJC5pc1RpbWVTZXJpZXNZKClcclxuXHRcdFx0XHRcdFx0KVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGF4ZXNcclxuXHRcdHRoaXMucmVkcmF3KHRyYW5zaXRpb25zLCAkJC5oYXNBcmNUeXBlKCksIGlzSW5pdCk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGF4aXMgbGFiZWxcclxuXHRcdHRoaXMudXBkYXRlTGFiZWxzKHd0aC5UcmFuc2l0aW9uKTtcclxuXHJcblx0XHQvLyBzaG93L2hpZGUgaWYgbWFudWFsIGN1bGxpbmcgbmVlZGVkXHJcblx0XHRpZiAoKHd0aC5VcGRhdGVYRG9tYWluIHx8IHd0aC5VcGRhdGVYQXhpcyB8fCB3dGguWSkgJiYgdGFyZ2V0c1RvU2hvdy5sZW5ndGgpIHtcclxuXHRcdFx0dGhpcy5zZXRDdWxsaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIHN1YiBkb21haW5cclxuXHRcdGlmICh3dGguWSkge1xyXG5cdFx0XHRzY2FsZS5zdWJZICYmIHNjYWxlLnN1YlkuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywgXCJ5XCIpKTtcclxuXHRcdFx0c2NhbGUuc3ViWTIgJiYgc2NhbGUuc3ViWTIuZG9tYWluKCQkLmdldFlEb21haW4odGFyZ2V0c1RvU2hvdywgXCJ5MlwiKSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgbWFudWFsIGN1bGxpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEN1bGxpbmcoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMub3duZXI7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0W1wic3ViWFwiLCBcInhcIiwgXCJ5XCIsIFwieTJcIl0uZm9yRWFjaCh0eXBlID0+IHtcclxuXHRcdFx0Y29uc3QgYXhpcyA9ICRlbC5heGlzW3R5cGVdO1xyXG5cclxuXHRcdFx0Ly8gc3ViY2hhcnQgeCBheGlzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggeCBheGlzIGN1bGxpbmdcclxuXHRcdFx0Y29uc3QgaWQgPSB0eXBlID09PSBcInN1YlhcIiA/IFwieFwiIDogdHlwZTtcclxuXHRcdFx0Y29uc3QgdG9DdWxsID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfY3VsbGluZ2BdO1xyXG5cclxuXHRcdFx0aWYgKGF4aXMgJiYgdG9DdWxsKSB7XHJcblx0XHRcdFx0Y29uc3QgdGlja1RleHQgPSBheGlzLnNlbGVjdEFsbChcIi50aWNrIHRleHRcIik7XHJcblx0XHRcdFx0Y29uc3QgdGlja1ZhbHVlcyA9IHNvcnRWYWx1ZSh0aWNrVGV4dC5kYXRhKCkpO1xyXG5cdFx0XHRcdGNvbnN0IHRpY2tTaXplID0gdGlja1ZhbHVlcy5sZW5ndGg7XHJcblx0XHRcdFx0Y29uc3QgY3VsbGluZ01heCA9IGNvbmZpZ1tgYXhpc18ke2lkfV90aWNrX2N1bGxpbmdfbWF4YF07XHJcblx0XHRcdFx0bGV0IGludGVydmFsRm9yQ3VsbGluZztcclxuXHJcblx0XHRcdFx0aWYgKHRpY2tTaXplKSB7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHRpY2tTaXplOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0aWYgKHRpY2tTaXplIC8gaSA8IGN1bGxpbmdNYXgpIHtcclxuXHRcdFx0XHRcdFx0XHRpbnRlcnZhbEZvckN1bGxpbmcgPSBpO1xyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGlja1RleHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IHRpY2tWYWx1ZXMuaW5kZXhPZihkKSAlIGludGVydmFsRm9yQ3VsbGluZyA/IFwibm9uZVwiIDogXCJibG9ja1wiO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpY2tUZXh0LnN0eWxlKFwiZGlzcGxheVwiLCBcImJsb2NrXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG59XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRjc3ZQYXJzZSBhcyBkM0NzdlBhcnNlLFxyXG5cdHRzdlBhcnNlIGFzIGQzVHN2UGFyc2UsXHJcblx0Y3N2UGFyc2VSb3dzIGFzIGQzQ3N2UGFyc2VSb3dzLFxyXG5cdHRzdlBhcnNlUm93cyBhcyBkM1RzdlBhcnNlUm93cyxcclxufSBmcm9tIFwiZDMtZHN2XCI7XHJcbmltcG9ydCB7aXNVbmRlZmluZWQsIGlzRGVmaW5lZCwgaXNPYmplY3QsIGlzVmFsdWUsIG5vdEVtcHR5LCBpc0FycmF5LCBjYXBpdGFsaXplfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBEYXRhIGNvbnZlcnRcclxuICogQG1lbWJlcm9mIENoYXJ0SW50ZXJuYWxcclxuICogQHByaXZhdGVcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IGRhdGEgYWNjb3JkaW5nIGl0cyB0eXBlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgZGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZvciB1cmwoWEhSKSB0eXBlIGxvYWRpbmdcclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjb252ZXJ0RGF0YShhcmdzLCBjYWxsYmFjaykge1xyXG5cdFx0bGV0IGRhdGE7XHJcblxyXG5cdFx0aWYgKGFyZ3MuYmluZHRvKSB7XHJcblx0XHRcdGRhdGEgPSB7fTtcclxuXHJcblx0XHRcdFtcInVybFwiLCBcIm1pbWVUeXBlXCIsIFwiaGVhZGVyc1wiLCBcImtleXNcIiwgXCJqc29uXCIsIFwia2V5c1wiLCBcInJvd3NcIiwgXCJjb2x1bW5zXCJdXHJcblx0XHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCBrZXkgPSBgZGF0YV8ke3Z9YDtcclxuXHJcblx0XHRcdFx0XHRpZiAoa2V5IGluIGFyZ3MpIHtcclxuXHRcdFx0XHRcdFx0ZGF0YVt2XSA9IGFyZ3Nba2V5XTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRhdGEgPSBhcmdzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkYXRhLnVybCAmJiBjYWxsYmFjaykge1xyXG5cdFx0XHR0aGlzLmNvbnZlcnRVcmxUb0RhdGEoZGF0YS51cmwsIGRhdGEubWltZVR5cGUsIGRhdGEuaGVhZGVycywgZGF0YS5rZXlzLCBjYWxsYmFjayk7XHJcblx0XHR9IGVsc2UgaWYgKGRhdGEuanNvbikge1xyXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0SnNvblRvRGF0YShkYXRhLmpzb24sIGRhdGEua2V5cyk7XHJcblx0XHR9IGVsc2UgaWYgKGRhdGEucm93cykge1xyXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Um93c1RvRGF0YShkYXRhLnJvd3MpO1xyXG5cdFx0fSBlbHNlIGlmIChkYXRhLmNvbHVtbnMpIHtcclxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydENvbHVtbnNUb0RhdGEoZGF0YS5jb2x1bW5zKTtcclxuXHRcdH0gZWxzZSBpZiAoYXJncy5iaW5kdG8pIHtcclxuXHRcdFx0dGhyb3cgRXJyb3IoXCJ1cmwgb3IganNvbiBvciByb3dzIG9yIGNvbHVtbnMgaXMgcmVxdWlyZWQuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBpc0FycmF5KGRhdGEpICYmIGRhdGE7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydCBVUkwgZGF0YVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgUmVtb3RlIFVSTFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBtaW1lVHlwZSBNSU1FIHR5cGUgc3RyaW5nOiBqc29uIHwgY3N2IHwgdHN2XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnMgSGVhZGVyIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBrZXlzIEtleSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBkb25lIENhbGxiYWNrIGZ1bmN0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjb252ZXJ0VXJsVG9EYXRhKHVybCwgbWltZVR5cGUgPSBcImNzdlwiLCBoZWFkZXJzLCBrZXlzLCBkb25lKSB7XHJcblx0XHRjb25zdCByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0XHRyZXEub3BlbihcIkdFVFwiLCB1cmwpO1xyXG5cclxuXHRcdGlmIChoZWFkZXJzKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRyZXEuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJlcS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcblx0XHRcdGlmIChyZXEucmVhZHlTdGF0ZSA9PT0gNCkge1xyXG5cdFx0XHRcdGlmIChyZXEuc3RhdHVzID09PSAyMDApIHtcclxuXHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcclxuXHJcblx0XHRcdFx0XHRyZXNwb25zZSAmJiBkb25lLmNhbGwodGhpcyxcclxuXHRcdFx0XHRcdFx0dGhpc1tgY29udmVydCR7Y2FwaXRhbGl6ZShtaW1lVHlwZSl9VG9EYXRhYF0oXHJcblx0XHRcdFx0XHRcdFx0bWltZVR5cGUgPT09IFwianNvblwiID8gSlNPTi5wYXJzZShyZXNwb25zZSkgOiByZXNwb25zZSxcclxuXHRcdFx0XHRcdFx0XHRrZXlzXHJcblx0XHRcdFx0XHRcdCkpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYCR7dXJsfTogU29tZXRoaW5nIHdlbnQgd3JvbmcgbG9hZGluZyFgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0cmVxLnNlbmQoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDb252ZXJ0IENTVi9UU1YgZGF0YVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJzZXIgUGFyc2VyIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB4c3YgRGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdCAqL1xyXG5cdGNvbnZlcnRDc3ZUc3ZUb0RhdGEocGFyc2VyLCB4c3YpIHtcclxuXHRcdGNvbnN0IHJvd3MgPSBwYXJzZXIucm93cyh4c3YpO1xyXG5cdFx0bGV0IGQ7XHJcblxyXG5cdFx0aWYgKHJvd3MubGVuZ3RoID09PSAxKSB7XHJcblx0XHRcdGQgPSBbe31dO1xyXG5cclxuXHRcdFx0cm93c1swXS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0XHRkWzBdW2lkXSA9IG51bGw7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZCA9IHBhcnNlci5wYXJzZSh4c3YpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRDc3ZUb0RhdGEoeHN2KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0Q3N2VHN2VG9EYXRhKHtcclxuXHRcdFx0cm93czogZDNDc3ZQYXJzZVJvd3MsXHJcblx0XHRcdHBhcnNlOiBkM0NzdlBhcnNlXHJcblx0XHR9LCB4c3YpO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRUc3ZUb0RhdGEodHN2KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0Q3N2VHN2VG9EYXRhKHtcclxuXHRcdFx0cm93czogZDNUc3ZQYXJzZVJvd3MsXHJcblx0XHRcdHBhcnNlOiBkM1RzdlBhcnNlXHJcblx0XHR9LCB0c3YpO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRKc29uVG9EYXRhKGpzb24sIGtleXNQYXJhbSkge1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSB0aGlzO1xyXG5cdFx0Y29uc3QgbmV3Um93czogc3RyaW5nW11bXSA9IFtdO1xyXG5cdFx0bGV0IHRhcmdldEtleXM6IHN0cmluZ1tdO1xyXG5cdFx0bGV0IGRhdGE7XHJcblxyXG5cdFx0aWYgKGlzQXJyYXkoanNvbikpIHtcclxuXHRcdFx0Y29uc3Qga2V5cyA9IGtleXNQYXJhbSB8fCBjb25maWcuZGF0YV9rZXlzO1xyXG5cclxuXHRcdFx0aWYgKGtleXMueCkge1xyXG5cdFx0XHRcdHRhcmdldEtleXMgPSBrZXlzLnZhbHVlLmNvbmNhdChrZXlzLngpO1xyXG5cdFx0XHRcdGNvbmZpZy5kYXRhX3ggPSBrZXlzLng7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGFyZ2V0S2V5cyA9IGtleXMudmFsdWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG5ld1Jvd3MucHVzaCh0YXJnZXRLZXlzKTtcclxuXHJcblx0XHRcdGpzb24uZm9yRWFjaChvID0+IHtcclxuXHRcdFx0XHRjb25zdCBuZXdSb3cgPSB0YXJnZXRLZXlzLm1hcChrZXkgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gY29udmVydCB1bmRlZmluZWQgdG8gbnVsbCBiZWNhdXNlIHVuZGVmaW5lZCBkYXRhIHdpbGwgYmUgcmVtb3ZlZCBpbiBjb252ZXJ0RGF0YVRvVGFyZ2V0cygpXHJcblx0XHRcdFx0XHRsZXQgdiA9IHRoaXMuZmluZFZhbHVlSW5Kc29uKG8sIGtleSk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHYpKSB7XHJcblx0XHRcdFx0XHRcdHYgPSBudWxsO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiB2O1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRuZXdSb3dzLnB1c2gobmV3Um93KTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRkYXRhID0gdGhpcy5jb252ZXJ0Um93c1RvRGF0YShuZXdSb3dzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKGpzb24pLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0XHRjb25zdCB0bXAgPSBqc29uW2tleV0uY29uY2F0KCk7XHJcblxyXG5cdFx0XHRcdHRtcC51bnNoaWZ0KGtleSk7XHJcblx0XHRcdFx0bmV3Um93cy5wdXNoKHRtcCk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZGF0YSA9IHRoaXMuY29udmVydENvbHVtbnNUb0RhdGEobmV3Um93cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGE7XHJcblx0fSxcclxuXHJcblx0ZmluZFZhbHVlSW5Kc29uKG9iamVjdCwgcGF0aCkge1xyXG5cdFx0aWYgKG9iamVjdFtwYXRoXSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiBvYmplY3RbcGF0aF07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgY29udmVydGVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXFxbKFxcdyspXFxdL2csIFwiLiQxXCIpOyAvLyBjb252ZXJ0IGluZGV4ZXMgdG8gcHJvcGVydGllcyAocmVwbGFjZSBbXSB3aXRoIC4pXHJcblx0XHRjb25zdCBwYXRoQXJyYXkgPSBjb252ZXJ0ZWRQYXRoLnJlcGxhY2UoL15cXC4vLCBcIlwiKS5zcGxpdChcIi5cIik7IC8vIHN0cmlwIGEgbGVhZGluZyBkb3RcclxuXHRcdGxldCB0YXJnZXQgPSBvYmplY3Q7XHJcblxyXG5cdFx0cGF0aEFycmF5LnNvbWUoayA9PiAhKFxyXG5cdFx0XHR0YXJnZXQgPSB0YXJnZXQgJiYgayBpbiB0YXJnZXQgP1xyXG5cdFx0XHRcdHRhcmdldFtrXSA6IHVuZGVmaW5lZFxyXG5cdFx0KSk7XHJcblxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0Um93c1RvRGF0YShyb3dzKSB7XHJcblx0XHRjb25zdCBrZXlzID0gcm93c1swXTtcclxuXHRcdGNvbnN0IG5ld1Jvd3M6IGFueVtdID0gW107XHJcblxyXG5cdFx0cm93cy5mb3JFYWNoKChyb3csIGkpID0+IHtcclxuXHRcdFx0aWYgKGkgPiAwKSB7XHJcblx0XHRcdFx0Y29uc3QgbmV3Um93ID0ge307XHJcblxyXG5cdFx0XHRcdHJvdy5mb3JFYWNoKCh2LCBqKSA9PiB7XHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodikpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBTb3VyY2UgZGF0YSBpcyBtaXNzaW5nIGEgY29tcG9uZW50IGF0ICgke2l9LCAke2p9KSFgKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRuZXdSb3dba2V5c1tqXV0gPSB2O1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRuZXdSb3dzLnB1c2gobmV3Um93KTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ld1Jvd3M7XHJcblx0fSxcclxuXHJcblx0Y29udmVydENvbHVtbnNUb0RhdGEoY29sdW1ucykge1xyXG5cdFx0Y29uc3QgbmV3Um93czogYW55W10gPSBbXTtcclxuXHJcblx0XHRjb2x1bW5zLmZvckVhY2goKGNvbCwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCBrZXkgPSBjb2xbMF07XHJcblxyXG5cdFx0XHRjb2wuZm9yRWFjaCgodiwgaikgPT4ge1xyXG5cdFx0XHRcdGlmIChqID4gMCkge1xyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKG5ld1Jvd3NbaiAtIDFdKSkge1xyXG5cdFx0XHRcdFx0XHRuZXdSb3dzW2ogLSAxXSA9IHt9O1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChpc1VuZGVmaW5lZCh2KSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYFNvdXJjZSBkYXRhIGlzIG1pc3NpbmcgYSBjb21wb25lbnQgYXQgKCR7aX0sICR7an0pIWApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG5ld1Jvd3NbaiAtIDFdW2tleV0gPSB2O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gbmV3Um93cztcclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0RGF0YVRvVGFyZ2V0cyhkYXRhLCBhcHBlbmRYcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1RpbWVTZXJpZXMgPSAkJC5pc1RpbWVTZXJpZXMoKTtcclxuXHJcblx0XHRjb25zdCBkYXRhS2V5cyA9IE9iamVjdC5rZXlzKGRhdGFbMF0gfHwge30pO1xyXG5cdFx0Y29uc3QgaWRzID0gZGF0YUtleXMubGVuZ3RoID8gZGF0YUtleXMuZmlsdGVyKCQkLmlzTm90WCwgJCQpIDogW107XHJcblx0XHRjb25zdCB4cyA9IGRhdGFLZXlzLmxlbmd0aCA/IGRhdGFLZXlzLmZpbHRlcigkJC5pc1gsICQkKSA6IFtdO1xyXG5cclxuXHRcdGxldCB4c0RhdGE7XHJcblxyXG5cdFx0Ly8gc2F2ZSB4IGZvciB1cGRhdGUgZGF0YSBieSBsb2FkIHdoZW4gY3VzdG9tIHggYW5kIGJiLnggQVBJXHJcblx0XHRpZHMuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGNvbnN0IHhLZXkgPSB0aGlzLmdldFhLZXkoaWQpO1xyXG5cclxuXHRcdFx0aWYgKHRoaXMuaXNDdXN0b21YKCkgfHwgaXNUaW1lU2VyaWVzKSB7XHJcblx0XHRcdFx0Ly8gaWYgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YVxyXG5cdFx0XHRcdGlmICh4cy5pbmRleE9mKHhLZXkpID49IDApIHtcclxuXHRcdFx0XHRcdHhzRGF0YSA9ICgoYXBwZW5kWHMgJiYgJCQuZGF0YS54c1tpZF0pIHx8IFtdKVxyXG5cdFx0XHRcdFx0XHQuY29uY2F0KFxyXG5cdFx0XHRcdFx0XHRcdGRhdGEubWFwKGQgPT4gZFt4S2V5XSlcclxuXHRcdFx0XHRcdFx0XHRcdC5maWx0ZXIoaXNWYWx1ZSlcclxuXHRcdFx0XHRcdFx0XHRcdC5tYXAoKHJhd1gsIGkpID0+ICQkLmdlbmVyYXRlVGFyZ2V0WChyYXdYLCBpZCwgaSkpXHJcblx0XHRcdFx0XHRcdCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChjb25maWcuZGF0YV94KSB7XHJcblx0XHRcdFx0XHQvLyBpZiBub3QgaW5jbHVkZWQgaW4gaW5wdXQgZGF0YSwgZmluZCBmcm9tIHByZWxvYWRlZCBkYXRhIG9mIG90aGVyIGlkJ3MgeFxyXG5cdFx0XHRcdFx0eHNEYXRhID0gdGhpcy5nZXRPdGhlclRhcmdldFhzKCk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChub3RFbXB0eShjb25maWcuZGF0YV94cykpIHtcclxuXHRcdFx0XHRcdC8vIGlmIG5vdCBpbmNsdWRlZCBpbiBpbnB1dCBkYXRhLCBmaW5kIGZyb20gcHJlbG9hZGVkIGRhdGFcclxuXHRcdFx0XHRcdHhzRGF0YSA9ICQkLmdldFhWYWx1ZXNPZlhLZXkoeEtleSwgJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gTUVNTzogaWYgbm8geCBpbmNsdWRlZCwgdXNlIHNhbWUgeCBvZiBjdXJyZW50IHdpbGwgYmUgdXNlZFxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHhzRGF0YSA9IGRhdGEubWFwKChkLCBpKSA9PiBpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eHNEYXRhICYmICh0aGlzLmRhdGEueHNbaWRdID0geHNEYXRhKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIGNoZWNrIHggaXMgZGVmaW5lZFxyXG5cdFx0aWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRpZiAoIXRoaXMuZGF0YS54c1tpZF0pIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHggaXMgbm90IGRlZmluZWQgZm9yIGlkID0gXCIke2lkfVwiLmApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBjb252ZXJ0IHRvIHRhcmdldFxyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IGlkcy5tYXAoKGlkLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRjb25zdCBjb252ZXJ0ZWRJZCA9IGNvbmZpZy5kYXRhX2lkQ29udmVydGVyKGlkKTtcclxuXHRcdFx0Y29uc3QgeEtleSA9ICQkLmdldFhLZXkoaWQpO1xyXG5cdFx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDdXN0b21YKCkgJiYgJCQuaXNDYXRlZ29yaXplZCgpO1xyXG5cdFx0XHRjb25zdCBoYXNDYXRlZ29yeSA9IGlzQ2F0ZWdvcml6ZWQgJiYgZGF0YS5tYXAodiA9PiB2LngpXHJcblx0XHRcdFx0LmV2ZXJ5KHYgPT4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmluZGV4T2YodikgPiAtMSk7XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdGlkOiBjb252ZXJ0ZWRJZCxcclxuXHRcdFx0XHRpZF9vcmc6IGlkLFxyXG5cdFx0XHRcdHZhbHVlczogZGF0YS5tYXAoKGQsIGkpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHJhd1ggPSBkW3hLZXldO1xyXG5cdFx0XHRcdFx0bGV0IHZhbHVlID0gZFtpZF07XHJcblx0XHRcdFx0XHRsZXQgeDtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgIWlzT2JqZWN0KHZhbHVlKSA/XHJcblx0XHRcdFx0XHRcdCt2YWx1ZSA6IChpc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IG51bGwpO1xyXG5cclxuXHRcdFx0XHRcdC8vIHVzZSB4IGFzIGNhdGVnb3JpZXMgaWYgY3VzdG9tIHggYW5kIGNhdGVnb3JpemVkXHJcblx0XHRcdFx0XHRpZiAoaXNDYXRlZ29yaXplZCAmJiBpbmRleCA9PT0gMCAmJiAhaXNVbmRlZmluZWQocmF3WCkpIHtcclxuXHRcdFx0XHRcdFx0aWYgKCFoYXNDYXRlZ29yeSAmJiBpbmRleCA9PT0gMCAmJiBpID09PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gW107XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHggPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMuaW5kZXhPZihyYXdYKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICh4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdHggPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXMubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5wdXNoKHJhd1gpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR4ID0gJCQuZ2VuZXJhdGVUYXJnZXRYKHJhd1gsIGlkLCBpKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBtYXJrIGFzIHggPSB1bmRlZmluZWQgaWYgdmFsdWUgaXMgdW5kZWZpbmVkIGFuZCBmaWx0ZXIgdG8gcmVtb3ZlIGFmdGVyIG1hcHBlZFxyXG5cdFx0XHRcdFx0aWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCAkJC5kYXRhLnhzW2lkXS5sZW5ndGggPD0gaSkge1xyXG5cdFx0XHRcdFx0XHR4ID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7eCwgdmFsdWUsIGlkOiBjb252ZXJ0ZWRJZH07XHJcblx0XHRcdFx0fSkuZmlsdGVyKHYgPT4gaXNEZWZpbmVkKHYueCkpXHJcblx0XHRcdH07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBmaW5pc2ggdGFyZ2V0c1xyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHQvLyBzb3J0IHZhbHVlcyBieSBpdHMgeFxyXG5cdFx0XHRpZiAoY29uZmlnLmRhdGFfeFNvcnQpIHtcclxuXHRcdFx0XHR0LnZhbHVlcyA9IHQudmFsdWVzLnNvcnQoKHYxLCB2MikgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgeDEgPSB2MS54IHx8IHYxLnggPT09IDAgPyB2MS54IDogSW5maW5pdHk7XHJcblx0XHRcdFx0XHRjb25zdCB4MiA9IHYyLnggfHwgdjIueCA9PT0gMCA/IHYyLnggOiBJbmZpbml0eTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4geDEgLSB4MjtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaW5kZXhpbmcgZWFjaCB2YWx1ZVxyXG5cdFx0XHR0LnZhbHVlcy5mb3JFYWNoKCh2LCBpKSA9PiAodi5pbmRleCA9IGkpKTtcclxuXHJcblx0XHRcdC8vIHRoaXMgbmVlZHMgdG8gYmUgc29ydGVkIGJlY2F1c2UgaXRzIGluZGV4IGFuZCB2YWx1ZS5pbmRleCBpcyBpZGVudGljYWxcclxuXHRcdFx0JCQuZGF0YS54c1t0LmlkXS5zb3J0KCh2MSwgdjIpID0+IHYxIC0gdjIpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gY2FjaGUgaW5mb3JtYXRpb24gYWJvdXQgdmFsdWVzXHJcblx0XHRzdGF0ZS5oYXNOZWdhdGl2ZVZhbHVlID0gJCQuaGFzTmVnYXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKTtcclxuXHRcdHN0YXRlLmhhc1Bvc2l0aXZlVmFsdWUgPSAkJC5oYXNQb3NpdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpO1xyXG5cclxuXHRcdC8vIHNldCB0YXJnZXQgdHlwZXNcclxuXHRcdGlmIChjb25maWcuZGF0YV90eXBlKSB7XHJcblx0XHRcdCQkLnNldFRhcmdldFR5cGUoJCQubWFwVG9JZHModGFyZ2V0cylcclxuXHRcdFx0XHQuZmlsdGVyKGlkID0+ICEoaWQgaW4gY29uZmlnLmRhdGFfdHlwZXMpKSwgY29uZmlnLmRhdGFfdHlwZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2FjaGUgYXMgb3JpZ2luYWwgaWQga2V5ZWRcclxuXHRcdHRhcmdldHMuZm9yRWFjaChkID0+ICQkLmNhY2hlLmFkZChkLmlkX29yZywgZCwgdHJ1ZSkpO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXRzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7XHJcbsKgwqDCoMKgZ2V0VW5pcXVlLFxyXG7CoMKgwqDCoGhhc1ZhbHVlLFxyXG7CoMKgwqDCoGlzQXJyYXksXHJcbsKgwqDCoMKgaXNCb29sZWFuLFxyXG7CoMKgwqDCoGlzRGVmaW5lZCxcclxuwqDCoMKgwqBpc0Z1bmN0aW9uLFxyXG7CoMKgwqDCoGlzTnVtYmVyLFxyXG7CoMKgwqDCoGlzT2JqZWN0LFxyXG7CoMKgwqDCoGlzT2JqZWN0VHlwZSxcclxuwqDCoMKgwqBpc1N0cmluZyxcclxuwqDCoMKgwqBpc1VuZGVmaW5lZCxcclxuwqDCoMKgwqBpc1ZhbHVlLFxyXG7CoMKgwqDCoG1lcmdlQXJyYXksXHJcbsKgwqDCoMKgbm90RW1wdHksXHJcblx0c29ydFZhbHVlXHJcbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aXNYKGtleSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFLZXkgPSBjb25maWcuZGF0YV94ICYmIGtleSA9PT0gY29uZmlnLmRhdGFfeDtcclxuXHRcdGNvbnN0IGV4aXN0VmFsdWUgPSBub3RFbXB0eShjb25maWcuZGF0YV94cykgJiYgaGFzVmFsdWUoY29uZmlnLmRhdGFfeHMsIGtleSk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGFLZXkgfHwgZXhpc3RWYWx1ZTtcclxuXHR9LFxyXG5cclxuXHRpc05vdFgoa2V5KSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuaXNYKGtleSk7XHJcblx0fSxcclxuXHJcblx0aXNTdGFja05vcm1hbGl6ZWQoKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICEhKGNvbmZpZy5kYXRhX3N0YWNrX25vcm1hbGl6ZSAmJiBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoKTtcclxuXHR9LFxyXG5cclxuXHRpc0dyb3VwZWQoaWQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5kYXRhX2dyb3Vwc1xyXG5cdFx0XHQubWFwKHYgPT4gdi5pbmRleE9mKGlkKSA+PSAwKVswXTtcclxuXHR9LFxyXG5cclxuXHRnZXRYS2V5KGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdHJldHVybiBjb25maWcuZGF0YV94ID9cclxuXHRcdFx0Y29uZmlnLmRhdGFfeCA6IChub3RFbXB0eShjb25maWcuZGF0YV94cykgPyBjb25maWcuZGF0YV94c1tpZF0gOiBudWxsKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYVmFsdWVzT2ZYS2V5KGtleSwgdGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaWRzID0gdGFyZ2V0cyAmJiBub3RFbXB0eSh0YXJnZXRzKSA/ICQkLm1hcFRvSWRzKHRhcmdldHMpIDogW107XHJcblx0XHRsZXQgeFZhbHVlcztcclxuXHJcblx0XHRpZHMuZm9yRWFjaChpZCA9PiB7XHJcblx0XHRcdGlmICgkJC5nZXRYS2V5KGlkKSA9PT0ga2V5KSB7XHJcblx0XHRcdFx0eFZhbHVlcyA9ICQkLmRhdGEueHNbaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4geFZhbHVlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgaW5kZXggbnVtYmVyIGJhc2VkIG9uIGdpdmVuIHggQXhpcyB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ8U3RyaW5nfSB4IHggQXhpcyB0byBiZSBjb21wYXJlZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGJhc2VkWCB4IEF4aXMgbGlzdCB0byBiZSBiYXNlZCBvblxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gaW5kZXggbnVtYmVyXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRJbmRleEJ5WCh4LCBiYXNlZFgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gYmFzZWRYID9cclxuXHRcdFx0YmFzZWRYLmluZGV4T2YoaXNTdHJpbmcoeCkgPyB4IDogK3gpIDpcclxuXHRcdFx0KCQkLmZpbHRlckJ5WCgkJC5kYXRhLnRhcmdldHMsIHgpWzBdIHx8IHtpbmRleDogbnVsbH0pLmluZGV4O1xyXG5cdH0sXHJcblxyXG5cdGdldFhWYWx1ZShpZCwgaSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBpZCBpbiAkJC5kYXRhLnhzICYmXHJcblx0XHRcdCQkLmRhdGEueHNbaWRdICYmXHJcblx0XHRcdGlzVmFsdWUoJCQuZGF0YS54c1tpZF1baV0pID8gJCQuZGF0YS54c1tpZF1baV0gOiBpO1xyXG5cdH0sXHJcblxyXG5cdGdldE90aGVyVGFyZ2V0WHMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBpZHNGb3JYID0gT2JqZWN0LmtleXMoJCQuZGF0YS54cyk7XHJcblxyXG5cdFx0cmV0dXJuIGlkc0ZvclgubGVuZ3RoID8gJCQuZGF0YS54c1tpZHNGb3JYWzBdXSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0T3RoZXJUYXJnZXRYKGluZGV4KSB7XHJcblx0XHRjb25zdCB4cyA9IHRoaXMuZ2V0T3RoZXJUYXJnZXRYcygpO1xyXG5cclxuXHRcdHJldHVybiB4cyAmJiBpbmRleCA8IHhzLmxlbmd0aCA/IHhzW2luZGV4XSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0YWRkWHMoeHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMoeHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25maWcuZGF0YV94c1tpZF0gPSB4c1tpZF07XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRpc011bHRpcGxlWCgpIHtcclxuXHRcdHJldHVybiBub3RFbXB0eSh0aGlzLmNvbmZpZy5kYXRhX3hzKSB8fFxyXG5cdFx0XHQhdGhpcy5jb25maWcuZGF0YV94U29ydCB8fFxyXG5cdFx0XHR0aGlzLmhhc1R5cGUoXCJidWJibGVcIikgfHxcclxuXHRcdFx0dGhpcy5oYXNUeXBlKFwic2NhdHRlclwiKTtcclxuXHR9LFxyXG5cclxuXHRhZGROYW1lKGRhdGEpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRsZXQgbmFtZTtcclxuXHJcblx0XHRpZiAoZGF0YSkge1xyXG5cdFx0XHRuYW1lID0gY29uZmlnLmRhdGFfbmFtZXNbZGF0YS5pZF07XHJcblx0XHRcdGRhdGEubmFtZSA9IG5hbWUgIT09IHVuZGVmaW5lZCA/IG5hbWUgOiBkYXRhLmlkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkYXRhO1xyXG5cdH0sXHJcblxyXG5cdGdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpXHJcblx0XHRcdC5tYXAodCA9PiAkJC5hZGROYW1lKCQkLmdldFZhbHVlT25JbmRleCh0LnZhbHVlcywgaW5kZXgpKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0VmFsdWVPbkluZGV4KHZhbHVlcywgaW5kZXgpIHtcclxuXHRcdGNvbnN0IHZhbHVlT25JbmRleCA9IHZhbHVlcy5maWx0ZXIodiA9PiB2LmluZGV4ID09PSBpbmRleCk7XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlT25JbmRleC5sZW5ndGggPyB2YWx1ZU9uSW5kZXhbMF0gOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldFgodGFyZ2V0cywgeCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0dC52YWx1ZXMuZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdHYueCA9ICQkLmdlbmVyYXRlVGFyZ2V0WCh4W2ldLCB0LmlkLCBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQkJC5kYXRhLnhzW3QuaWRdID0geDtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldFhzKHRhcmdldHMsIHhzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHR4c1t0LmlkXSAmJiAkJC51cGRhdGVUYXJnZXRYKFt0XSwgeHNbdC5pZF0pO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVUYXJnZXRYKHJhd1gsIGlkLCBpbmRleCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHggPSAkJC5pc0NhdGVnb3JpemVkKCkgPyBpbmRleCA6IChyYXdYIHx8IGluZGV4KTtcclxuXHJcblx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0eCA9IHJhd1ggPyAkJC5wYXJzZURhdGUocmF3WCkgOiAkJC5wYXJzZURhdGUoJCQuZ2V0WFZhbHVlKGlkLCBpbmRleCkpO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5pc0N1c3RvbVgoKSAmJiAhJCQuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdHggPSBpc1ZhbHVlKHJhd1gpID8gK3Jhd1ggOiAkJC5nZXRYVmFsdWUoaWQsIGluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geDtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVYcyh2YWx1ZXMpIHtcclxuXHRcdGlmICh2YWx1ZXMubGVuZ3RoKSB7XHJcblx0XHRcdHRoaXMuc3RhdGUueHMgPSB2YWx1ZXMubWFwKHYgPT4gdi54KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRQcmV2WChpKSB7XHJcblx0XHRjb25zdCB4ID0gdGhpcy5zdGF0ZS54c1tpIC0gMV07XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh4KSA/IHggOiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldE5leHRYKGkpIHtcclxuXHRcdGNvbnN0IHggPSB0aGlzLnN0YXRlLnhzW2kgKyAxXTtcclxuXHJcblx0XHRyZXR1cm4gaXNEZWZpbmVkKHgpID8geCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGJhc2UgdmFsdWUgaXNBcmVhUmFuZ2VUeXBlXHJcblx0ICogQHBhcmFtIGRhdGEgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRCYXNlVmFsdWUoZGF0YSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHZhbHVlID0gZGF0YS52YWx1ZTtcclxuXHJcblx0XHQvLyBJbiBjYXNlIG9mIGFyZWEtcmFuZ2UsIGRhdGEgaXMgZ2l2ZW4gYXM6IFtsb3csIG1pZCwgaGlnaF0gb3Ige2xvdywgbWlkLCBoaWdofVxyXG5cdFx0Ly8gd2lsbCB0YWtlIHRoZSAnbWlkJyBhcyB0aGUgYmFzZSB2YWx1ZVxyXG5cdFx0aWYgKHZhbHVlKSB7XHJcblx0XHRcdGlmICgkJC5pc0FyZWFSYW5nZVR5cGUoZGF0YSkpIHtcclxuXHRcdFx0XHR2YWx1ZSA9ICQkLmdldEFyZWFSYW5nZURhdGEoZGF0YSwgXCJtaWRcIik7XHJcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNCdWJibGVaVHlwZShkYXRhKSkge1xyXG5cdFx0XHRcdHZhbHVlID0gJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBtaW4vbWF4IHZhbHVlIGZyb20gdGhlIGRhdGFcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgYXJyYXkgZGF0YSB0byBiZSBldmFsdWF0ZWRcclxuXHQgKiBAcmV0dXJuIHt7bWluOiB7TnVtYmVyfSwgbWF4OiB7TnVtYmVyfX19XHJcblx0ICovXHJcblx0Z2V0TWluTWF4VmFsdWUoZGF0YSkge1xyXG5cdFx0Y29uc3QgZ2V0QmFzZVZhbHVlID0gdGhpcy5nZXRCYXNlVmFsdWUuYmluZCh0aGlzKTtcclxuXHRcdGxldCBtaW47XHJcblx0XHRsZXQgbWF4O1xyXG5cclxuXHRcdChkYXRhIHx8IHRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKSlcclxuXHRcdFx0LmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IHYubWFwKGdldEJhc2VWYWx1ZSkuZmlsdGVyKGlzTnVtYmVyKTtcclxuXHJcblx0XHRcdFx0bWluID0gTWF0aC5taW4oaSA/IG1pbiA6IEluZmluaXR5LCAuLi52YWx1ZSk7XHJcblx0XHRcdFx0bWF4ID0gTWF0aC5tYXgoaSA/IG1heCA6IC1JbmZpbml0eSwgLi4udmFsdWUpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4ge21pbiwgbWF4fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG1pbi9tYXggZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybiB7e21pbjogQXJyYXksIG1heDogQXJyYXl9fVxyXG5cdCAqL1xyXG5cdGdldE1pbk1heERhdGEoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IFwiJG1pbk1heERhdGFcIjtcclxuXHRcdGxldCBtaW5NYXhEYXRhID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIW1pbk1heERhdGEpIHtcclxuXHRcdFx0Y29uc3QgZGF0YSA9ICQkLmRhdGEudGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcyk7XHJcblx0XHRcdGNvbnN0IG1pbk1heCA9ICQkLmdldE1pbk1heFZhbHVlKGRhdGEpO1xyXG5cclxuXHRcdFx0bGV0IG1pbiA9IFtdO1xyXG5cdFx0XHRsZXQgbWF4ID0gW107XHJcblxyXG5cdFx0XHRkYXRhLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbWluRGF0YSA9ICQkLmdldEZpbHRlcmVkRGF0YUJ5VmFsdWUodiwgbWluTWF4Lm1pbik7XHJcblx0XHRcdFx0Y29uc3QgbWF4RGF0YSA9ICQkLmdldEZpbHRlcmVkRGF0YUJ5VmFsdWUodiwgbWluTWF4Lm1heCk7XHJcblxyXG5cdFx0XHRcdGlmIChtaW5EYXRhLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0bWluID0gbWluLmNvbmNhdChtaW5EYXRhKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChtYXhEYXRhLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0bWF4ID0gbWF4LmNvbmNhdChtYXhEYXRhKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIHRoZSBjYWNoZWQgZGF0YVxyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIG1pbk1heERhdGEgPSB7bWluLCBtYXh9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWluTWF4RGF0YTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgc3VtIG9mIGRhdGEgcGVyIGluZGV4XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcmV0dXJuIHtBcnJheX1cclxuXHQgKi9cclxuXHRnZXRUb3RhbFBlckluZGV4KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FjaGVLZXkgPSBcIiR0b3RhbFBlckluZGV4XCI7XHJcblx0XHRsZXQgc3VtID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSAmJiAhc3VtKSB7XHJcblx0XHRcdHN1bSA9IFtdO1xyXG5cclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2gocm93ID0+IHtcclxuXHRcdFx0XHRyb3cudmFsdWVzLmZvckVhY2goKHYsIGkpID0+IHtcclxuXHRcdFx0XHRcdGlmICghc3VtW2ldKSB7XHJcblx0XHRcdFx0XHRcdHN1bVtpXSA9IDA7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c3VtW2ldICs9IGlzTnVtYmVyKHYudmFsdWUpID8gdi52YWx1ZSA6IDA7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdW07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRvdGFsIGRhdGEgc3VtXHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG4gXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFRvdGFsRGF0YVN1bSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCIkdG90YWxEYXRhU3VtXCI7XHJcblx0XHRsZXQgdG90YWxEYXRhU3VtID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIXRvdGFsRGF0YVN1bSkge1xyXG5cdFx0XHRjb25zdCB0b3RhbCA9IG1lcmdlQXJyYXkoJCQuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzKSlcclxuXHRcdFx0XHQubWFwKHYgPT4gdi52YWx1ZSlcclxuXHRcdFx0XHQucmVkdWNlKChwLCBjKSA9PiBwICsgYyk7XHJcblxyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIHRvdGFsRGF0YVN1bSA9IHRvdGFsKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdG90YWxEYXRhU3VtO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBmaWx0ZXJlZCBkYXRhIGJ5IHZhbHVlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gZmlsdGVyZWQgYXJyYXkgZGF0YVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0RmlsdGVyZWREYXRhQnlWYWx1ZShkYXRhLCB2YWx1ZSkge1xyXG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKHQgPT4gdGhpcy5nZXRCYXNlVmFsdWUodCkgPT09IHZhbHVlKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm4gdGhlIG1heCBsZW5ndGggb2YgdGhlIGRhdGFcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IG1heCBkYXRhIGxlbmd0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0TWF4RGF0YUNvdW50KCkge1xyXG5cdFx0cmV0dXJuIE1hdGgubWF4KC4uLnRoaXMuZGF0YS50YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLmxlbmd0aCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1heERhdGFDb3VudFRhcmdldCgpIHtcclxuXHRcdGxldCB0YXJnZXQgPSB0aGlzLmZpbHRlclRhcmdldHNUb1Nob3coKSB8fCBbXTtcclxuXHRcdGNvbnN0IGxlbmd0aCA9IHRhcmdldC5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKGxlbmd0aCA+IDEpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0Lm1hcCh0ID0+IHQudmFsdWVzKVxyXG5cdFx0XHRcdC5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2LngpO1xyXG5cclxuXHRcdFx0dGFyZ2V0ID0gc29ydFZhbHVlKGdldFVuaXF1ZSh0YXJnZXQpKVxyXG5cdFx0XHRcdC5tYXAoKHgsIGluZGV4KSA9PiAoe3gsIGluZGV4fSkpO1xyXG5cdFx0fSBlbHNlIGlmIChsZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0WzBdLnZhbHVlcztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0O1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvSWRzKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0YXJnZXRzLm1hcChkID0+IGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdG1hcFRvVGFyZ2V0SWRzKGlkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBpZHMgPyAoaXNBcnJheShpZHMpID8gaWRzLmNvbmNhdCgpIDogW2lkc10pIDogJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHR9LFxyXG5cclxuXHRoYXNUYXJnZXQodGFyZ2V0cywgaWQpIHtcclxuXHRcdGNvbnN0IGlkcyA9IHRoaXMubWFwVG9JZHModGFyZ2V0cyk7XHJcblxyXG5cdFx0Zm9yIChsZXQgaSA9IDAsIHZhbDsgKHZhbCA9IGlkc1tpXSk7IGkrKykge1xyXG5cdFx0XHRpZiAodmFsID09PSBpZCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGlzVGFyZ2V0VG9TaG93KHRhcmdldElkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGlzTGVnZW5kVG9TaG93KHRhcmdldElkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMuaW5kZXhPZih0YXJnZXRJZCkgPCAwO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlclRhcmdldHNUb1Nob3codGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAodGFyZ2V0cyB8fCAkJC5kYXRhLnRhcmdldHMpLmZpbHRlcih0ID0+ICQkLmlzVGFyZ2V0VG9TaG93KHQuaWQpKTtcclxuXHR9LFxyXG5cclxuXHRtYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgeHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0aWYgKHRhcmdldHMgJiYgdGFyZ2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0eHMgPSBnZXRVbmlxdWUoXHJcblx0XHRcdFx0bWVyZ2VBcnJheSh0YXJnZXRzLm1hcCh0ID0+IHQudmFsdWVzLm1hcCh2ID0+ICt2LngpKSlcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHhzID0gJCQuaXNUaW1lU2VyaWVzKCkgPyB4cy5tYXAoeCA9PiBuZXcgRGF0ZSgreCkpIDogeHMubWFwKHggPT4gK3gpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzb3J0VmFsdWUoeHMpO1xyXG5cdH0sXHJcblxyXG5cdGFkZEhpZGRlblRhcmdldElkcyh0YXJnZXRJZHMpIHtcclxuXHRcdHRoaXMuc3RhdGUuaGlkZGVuVGFyZ2V0SWRzID0gdGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMuY29uY2F0KHRhcmdldElkcyk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlSGlkZGVuVGFyZ2V0SWRzKHRhcmdldElkcykge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5UYXJnZXRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlblRhcmdldElkcy5maWx0ZXIoaWQgPT4gdGFyZ2V0SWRzLmluZGV4T2YoaWQpIDwgMCk7XHJcblx0fSxcclxuXHJcblx0YWRkSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcykge1xyXG5cdFx0dGhpcy5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMgPSB0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcy5jb25jYXQodGFyZ2V0SWRzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIaWRkZW5MZWdlbmRJZHModGFyZ2V0SWRzKSB7XHJcblx0XHR0aGlzLnN0YXRlLmhpZGRlbkxlZ2VuZElkcyA9IHRoaXMuc3RhdGUuaGlkZGVuTGVnZW5kSWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRWYWx1ZXNBc0lkS2V5ZWQodGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeXMgPSB7fTtcclxuXHRcdGNvbnN0IGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKTtcclxuXHRcdGNvbnN0IHhzID0gaXNNdWx0aXBsZVggPyAkJC5tYXBUYXJnZXRzVG9VbmlxdWVYcyh0YXJnZXRzKVxyXG5cdFx0XHQubWFwKHYgPT4gKGlzU3RyaW5nKHYpID8gdiA6ICt2KSkgOiBudWxsO1xyXG5cclxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0Y29uc3QgZGF0YTogYW55W10gPSBbXTtcclxuXHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSB2LnZhbHVlO1xyXG5cclxuXHRcdFx0XHRpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0XHRcdGRhdGEucHVzaCguLi52YWx1ZSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgXCJoaWdoXCIgaW4gdmFsdWUpIHtcclxuXHRcdFx0XHRcdGRhdGEucHVzaCguLi5PYmplY3QudmFsdWVzKHZhbHVlKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICgkJC5pc0J1YmJsZVpUeXBlKHYpKSB7XHJcblx0XHRcdFx0XHRkYXRhLnB1c2goJCQuZ2V0QnViYmxlWkRhdGEodmFsdWUsIFwieVwiKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGlmIChpc011bHRpcGxlWCkge1xyXG5cdFx0XHRcdFx0XHRkYXRhWyQkLmdldEluZGV4QnlYKHYueCwgeHMpXSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0ZGF0YS5wdXNoKHZhbHVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0eXNbdC5pZF0gPSBkYXRhO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHlzO1xyXG5cdH0sXHJcblxyXG5cdGNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgY2hlY2tlcikge1xyXG5cdFx0Y29uc3QgaWRzID0gT2JqZWN0LmtleXModGFyZ2V0cyk7XHJcblx0XHRsZXQgdmFsdWVzO1xyXG5cclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhbHVlcyA9IHRhcmdldHNbaWRzW2ldXS52YWx1ZXM7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xyXG5cdFx0XHRcdGlmIChjaGVja2VyKHZhbHVlc1tqXS52YWx1ZSkpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRoYXNNdWx0aVRhcmdldHMoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXJUYXJnZXRzVG9TaG93KCkubGVuZ3RoID4gMTtcclxuXHR9LFxyXG5cclxuXHRoYXNOZWdhdGl2ZVZhbHVlSW5UYXJnZXRzKHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmNoZWNrVmFsdWVJblRhcmdldHModGFyZ2V0cywgdiA9PiB2IDwgMCk7XHJcblx0fSxcclxuXHJcblx0aGFzUG9zaXRpdmVWYWx1ZUluVGFyZ2V0cyh0YXJnZXRzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGVja1ZhbHVlSW5UYXJnZXRzKHRhcmdldHMsIHYgPT4gdiA+IDApO1xyXG5cdH0sXHJcblxyXG5cdF9jaGVja09yZGVyKHR5cGUpIHtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gdGhpcztcclxuXHRcdGNvbnN0IG9yZGVyID0gY29uZmlnLmRhdGFfb3JkZXI7XHJcblxyXG5cdFx0cmV0dXJuIGlzU3RyaW5nKG9yZGVyKSAmJiBvcmRlci50b0xvd2VyQ2FzZSgpID09PSB0eXBlO1xyXG5cdH0sXHJcblxyXG5cdGlzT3JkZXJEZXNjKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NoZWNrT3JkZXIoXCJkZXNjXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzT3JkZXJBc2MoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY2hlY2tPcmRlcihcImFzY1wiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTb3J0IHRhcmdldHMgZGF0YVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldHNWYWx1ZVxyXG5cdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b3JkZXJUYXJnZXRzKHRhcmdldHNWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRhcmdldHMgPSBbLi4udGFyZ2V0c1ZhbHVlXTtcclxuXHRcdGNvbnN0IG9yZGVyQXNjID0gJCQuaXNPcmRlckFzYygpO1xyXG5cdFx0Y29uc3Qgb3JkZXJEZXNjID0gJCQuaXNPcmRlckRlc2MoKTtcclxuXHJcblx0XHRpZiAob3JkZXJBc2MgfHwgb3JkZXJEZXNjKSB7XHJcblx0XHRcdHRhcmdldHMuc29ydCgodDEsIHQyKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgcmVkdWNlciA9IChwLCBjKSA9PiBwICsgTWF0aC5hYnMoYy52YWx1ZSk7XHJcblx0XHRcdFx0Y29uc3QgdDFTdW0gPSB0MS52YWx1ZXMucmVkdWNlKHJlZHVjZXIsIDApO1xyXG5cdFx0XHRcdGNvbnN0IHQyU3VtID0gdDIudmFsdWVzLnJlZHVjZShyZWR1Y2VyLCAwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9yZGVyQXNjID8gdDJTdW0gLSB0MVN1bSA6IHQxU3VtIC0gdDJTdW07XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5kYXRhX29yZGVyKSkge1xyXG5cdFx0XHR0YXJnZXRzLnNvcnQoY29uZmlnLmRhdGFfb3JkZXIpO1xyXG5cdFx0fSAvLyBUT0RPOiBhY2NlcHQgbmFtZSBhcnJheSBmb3Igb3JkZXJcclxuXHJcblx0XHRyZXR1cm4gdGFyZ2V0cztcclxuXHR9LFxyXG5cclxuXHRmaWx0ZXJCeVgodGFyZ2V0cywgeCkge1xyXG5cdFx0cmV0dXJuIG1lcmdlQXJyYXkodGFyZ2V0cy5tYXAodCA9PiB0LnZhbHVlcykpLmZpbHRlcih2ID0+IHYueCAtIHggPT09IDApO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlclJlbW92ZU51bGwoZGF0YSkge1xyXG5cdFx0cmV0dXJuIGRhdGEuZmlsdGVyKGQgPT4gaXNWYWx1ZSh0aGlzLmdldEJhc2VWYWx1ZShkKSkpO1xyXG5cdH0sXHJcblxyXG5cdGZpbHRlckJ5WERvbWFpbih0YXJnZXRzLCB4RG9tYWluKSB7XHJcblx0XHRyZXR1cm4gdGFyZ2V0cy5tYXAodCA9PiAoe1xyXG5cdFx0XHRpZDogdC5pZCxcclxuXHRcdFx0aWRfb3JnOiB0LmlkX29yZyxcclxuXHRcdFx0dmFsdWVzOiB0LnZhbHVlcy5maWx0ZXIodiA9PiB4RG9tYWluWzBdIDw9IHYueCAmJiB2LnggPD0geERvbWFpblsxXSlcclxuXHRcdH0pKTtcclxuXHR9LFxyXG5cclxuXHRoYXNEYXRhTGFiZWwoKSB7XHJcblx0XHRjb25zdCBkYXRhTGFiZWxzID0gdGhpcy5jb25maWcuZGF0YV9sYWJlbHM7XHJcblxyXG5cdFx0cmV0dXJuIChpc0Jvb2xlYW4oZGF0YUxhYmVscykgJiYgZGF0YUxhYmVscykgfHxcclxuXHRcdFx0KGlzT2JqZWN0VHlwZShkYXRhTGFiZWxzKSAmJiBub3RFbXB0eShkYXRhTGFiZWxzKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0RGF0YUxhYmVsTGVuZ3RoKG1pbiwgbWF4LCBrZXkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGxlbmd0aHMgPSBbMCwgMF07XHJcblx0XHRjb25zdCBwYWRkaW5nQ29lZiA9IDEuMztcclxuXHJcblx0XHQkJC4kZWwuY2hhcnQuc2VsZWN0KFwic3ZnXCIpLnNlbGVjdEFsbChcIi5kdW1teVwiKVxyXG5cdFx0XHQuZGF0YShbbWluLCBtYXhdKVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChkID0+ICQkLmRhdGFMYWJlbEZvcm1hdChkLmlkKShkKSlcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdGxlbmd0aHNbaV0gPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV0gKiBwYWRkaW5nQ29lZjtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdHJldHVybiBsZW5ndGhzO1xyXG5cdH0sXHJcblxyXG5cdGlzTm9uZUFyYyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNUYXJnZXQodGhpcy5kYXRhLnRhcmdldHMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJjKGQpIHtcclxuXHRcdHJldHVybiBcImRhdGFcIiBpbiBkICYmIHRoaXMuaGFzVGFyZ2V0KHRoaXMuZGF0YS50YXJnZXRzLCBkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGZpbmRTYW1lWE9mVmFsdWVzKHZhbHVlcywgaW5kZXgpIHtcclxuXHRcdGNvbnN0IHRhcmdldFggPSB2YWx1ZXNbaW5kZXhdLng7XHJcblx0XHRjb25zdCBzYW1lczogYW55W10gPSBbXTtcclxuXHRcdGxldCBpO1xyXG5cclxuXHRcdGZvciAoaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0aWYgKHRhcmdldFggIT09IHZhbHVlc1tpXS54KSB7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNhbWVzLnB1c2godmFsdWVzW2ldKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKGkgPSBpbmRleDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAodGFyZ2V0WCAhPT0gdmFsdWVzW2ldLngpIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2FtZXMucHVzaCh2YWx1ZXNbaV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzYW1lcztcclxuXHR9LFxyXG5cclxuXHRmaW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHMsIHBvcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9IHRhcmdldHMubWFwKHRhcmdldCA9PiAkJC5maW5kQ2xvc2VzdCh0YXJnZXQudmFsdWVzLCBwb3MpKTsgLy8gbWFwIHRvIGFycmF5IG9mIGNsb3Nlc3QgcG9pbnRzIG9mIGVhY2ggdGFyZ2V0XHJcblxyXG5cdFx0Ly8gZGVjaWRlIGNsb3Nlc3QgcG9pbnQgYW5kIHJldHVyblxyXG5cdFx0cmV0dXJuICQkLmZpbmRDbG9zZXN0KGNhbmRpZGF0ZXMsIHBvcyk7XHJcblx0fSxcclxuXHJcblx0ZmluZENsb3Nlc3QodmFsdWVzLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgZGF0YSA9IHZhbHVlcy5maWx0ZXIodiA9PiB2ICYmIGlzVmFsdWUodi52YWx1ZSkpO1xyXG5cdFx0bGV0IG1pbkRpc3QgPSBjb25maWcucG9pbnRfc2Vuc2l0aXZpdHk7XHJcblx0XHRsZXQgY2xvc2VzdDtcclxuXHJcblx0XHQvLyBmaW5kIG1vdXNlb3ZlcmluZyBiYXJcclxuXHRcdGRhdGFcclxuXHRcdFx0LmZpbHRlcih2ID0+ICQkLmlzQmFyVHlwZSh2LmlkKSlcclxuXHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYmFyc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHYuaWQpfSAuJHtDTEFTUy5iYXJ9LSR7di5pbmRleH1gKS5ub2RlKCk7XHJcblxyXG5cdFx0XHRcdGlmICghY2xvc2VzdCAmJiAkJC5pc1dpdGhpbkJhcihzaGFwZSkpIHtcclxuXHRcdFx0XHRcdGNsb3Nlc3QgPSB2O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gZmluZCBjbG9zZXN0IHBvaW50IGZyb20gbm9uLWJhclxyXG5cdFx0ZGF0YVxyXG5cdFx0XHQuZmlsdGVyKHYgPT4gISQkLmlzQmFyVHlwZSh2LmlkKSlcclxuXHRcdFx0LmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgZCA9ICQkLmRpc3QodiwgcG9zKTtcclxuXHJcblx0XHRcdFx0aWYgKGQgPCBtaW5EaXN0KSB7XHJcblx0XHRcdFx0XHRtaW5EaXN0ID0gZDtcclxuXHRcdFx0XHRcdGNsb3Nlc3QgPSB2O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIGNsb3Nlc3Q7XHJcblx0fSxcclxuXHJcblx0ZGlzdChkYXRhLCBwb3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWc6IHtheGlzX3JvdGF0ZWQ6IGlzUm90YXRlZH0sIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgeEluZGV4ID0gaXNSb3RhdGVkID8gMSA6IDA7XHJcblx0XHRjb25zdCB5SW5kZXggPSBpc1JvdGF0ZWQgPyAwIDogMTtcclxuXHRcdGNvbnN0IHkgPSAkJC5jaXJjbGVZKGRhdGEsIGRhdGEuaW5kZXgpO1xyXG5cdFx0Y29uc3QgeCA9IChzY2FsZS56b29tIHx8IHNjYWxlLngpKGRhdGEueCk7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zW3hJbmRleF0sIDIpICsgTWF0aC5wb3coeSAtIHBvc1t5SW5kZXhdLCAyKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ29udmVydCBkYXRhIGZvciBzdGVwIHR5cGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgT2JqZWN0IGRhdGEgdmFsdWVzXHJcblx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3Qgc3RlcFR5cGUgPSBjb25maWcubGluZV9zdGVwX3R5cGU7XHJcblx0XHRjb25zdCBpc0NhdGVnb3JpemVkID0gJCQuaXNDYXRlZ29yaXplZCgpO1xyXG5cclxuXHRcdGNvbnN0IGNvbnZlcnRlZCA9IGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5jb25jYXQoKSA6IFt2YWx1ZXNdO1xyXG5cclxuXHRcdGlmICghaXNSb3RhdGVkICYmICFpc0NhdGVnb3JpemVkKSB7XHJcblx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaW5zZXJ0ICYgYXBwZW5kIGNsb25pbmcgZmlyc3QvbGFzdCB2YWx1ZSB0byBiZSBmdWxseSByZW5kZXJlZCBjb3ZlcmluZyBvbiBlYWNoIGdhcCBzaWRlc1xyXG5cdFx0Y29uc3QgaWQgPSBjb252ZXJ0ZWRbMF0uaWQ7XHJcblxyXG5cdFx0Ly8gaW5zZXJ0XHJcblx0XHRsZXQgeCA9IGNvbnZlcnRlZFswXS54IC0gMTtcclxuXHRcdGxldCB2YWx1ZSA9IGNvbnZlcnRlZFswXS52YWx1ZTtcclxuXHJcblx0XHRpc0NhdGVnb3JpemVkICYmIGNvbnZlcnRlZC51bnNoaWZ0KHt4LCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRzdGVwVHlwZSA9PT0gXCJzdGVwLWFmdGVyXCIgJiZcclxuXHRcdFx0Y29udmVydGVkLnVuc2hpZnQoe3g6IHggLSAxLCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHQvLyBhcHBlbmRcclxuXHRcdHggPSBjb252ZXJ0ZWQubGVuZ3RoO1xyXG5cdFx0dmFsdWUgPSBjb252ZXJ0ZWRbeCAtIDFdLnZhbHVlO1xyXG5cclxuXHRcdGlzQ2F0ZWdvcml6ZWQgJiYgY29udmVydGVkLnB1c2goe3gsIHZhbHVlLCBpZH0pO1xyXG5cclxuXHRcdHN0ZXBUeXBlID09PSBcInN0ZXAtYmVmb3JlXCIgJiZcclxuXHRcdFx0Y29udmVydGVkLnB1c2goe3g6IHggKyAxLCB2YWx1ZSwgaWR9KTtcclxuXHJcblx0XHRyZXR1cm4gY29udmVydGVkO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRWYWx1ZXNUb1JhbmdlKHZhbHVlcykge1xyXG5cdFx0Y29uc3QgY29udmVydGVkID0gaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzLmNvbmNhdCgpIDogW3ZhbHVlc107XHJcblx0XHRjb25zdCByYW5nZXM6IHt4OiBzdHJpbmcgfCBudW1iZXIsIGlkOiBzdHJpbmcsIHZhbHVlOiBudW1iZXJ9W10gPSBbXTtcclxuXHJcblx0XHRjb252ZXJ0ZWQuZm9yRWFjaChyYW5nZSA9PiB7XHJcblx0XHRcdGNvbnN0IHt4LCBpZH0gPSByYW5nZTtcclxuXHJcblx0XHRcdHJhbmdlcy5wdXNoKHtcclxuXHRcdFx0XHR4LFxyXG5cdFx0XHRcdGlkLFxyXG5cdFx0XHRcdHZhbHVlOiByYW5nZS52YWx1ZVswXVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJhbmdlcy5wdXNoKHtcclxuXHRcdFx0XHR4LFxyXG5cdFx0XHRcdGlkLFxyXG5cdFx0XHRcdHZhbHVlOiByYW5nZS52YWx1ZVsyXVxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiByYW5nZXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlRGF0YUF0dHJpYnV0ZXMobmFtZSwgYXR0cnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyZW50ID0gY29uZmlnW2BkYXRhXyR7bmFtZX1gXTtcclxuXHJcblx0XHRpZiAoaXNVbmRlZmluZWQoYXR0cnMpKSB7XHJcblx0XHRcdHJldHVybiBjdXJyZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y3VycmVudFtpZF0gPSBhdHRyc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQkJC5yZWRyYXcoe3dpdGhMZWdlbmQ6IHRydWV9KTtcclxuXHJcblx0XHRyZXR1cm4gY3VycmVudDtcclxuXHR9LFxyXG5cclxuXHRnZXRBcmVhUmFuZ2VEYXRhKGQsIHR5cGUpIHtcclxuXHRcdGNvbnN0IHZhbHVlID0gZC52YWx1ZTtcclxuXHJcblx0XHRpZiAoaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0Y29uc3QgaW5kZXggPSBbXCJoaWdoXCIsIFwibWlkXCIsIFwibG93XCJdLmluZGV4T2YodHlwZSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHZhbHVlW2luZGV4XTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVbdHlwZV07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHJhdGlvIHZhbHVlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgUmF0aW8gZm9yIGdpdmVuIHR5cGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIHZhbHVlIG9iamVjdFxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNQZXJjZW50IENvbnZlcnQgdGhlIHJldHVybiBhcyBwZXJjZW50IG9yIG5vdFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gUmF0aW8gdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFJhdGlvKHR5cGUsIGQsIGFzUGVyY2VudCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBhcGkgPSAkJC5hcGk7XHJcblx0XHRsZXQgcmF0aW8gPSAwO1xyXG5cclxuXHRcdGlmIChkICYmIGFwaS5kYXRhLnNob3duKCkubGVuZ3RoKSB7XHJcblx0XHRcdGNvbnN0IGRhdGFWYWx1ZXMgPSBhcGkuZGF0YS52YWx1ZXMuYmluZChhcGkpO1xyXG5cclxuXHRcdFx0cmF0aW8gPSBkLnJhdGlvIHx8IGQudmFsdWU7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gXCJhcmNcIikge1xyXG5cdFx0XHRcdC8vIGlmIGhhcyBwYWRBbmdsZSBzZXQsIGNhbGN1bGF0ZSByYXRlIGJhc2VkIG9uIHZhbHVlXHJcblx0XHRcdFx0aWYgKCQkLnBpZS5wYWRBbmdsZSgpKCkpIHtcclxuXHRcdFx0XHRcdGxldCB0b3RhbCA9ICQkLmdldFRvdGFsRGF0YVN1bSgpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChzdGF0ZS5oaWRkZW5UYXJnZXRJZHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHRvdGFsIC09IGRhdGFWYWx1ZXMoc3RhdGUuaGlkZGVuVGFyZ2V0SWRzKS5yZWR1Y2UoKHAsIGMpID0+IHAgKyBjKTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRyYXRpbyA9IGQudmFsdWUgLyB0b3RhbDtcclxuXHJcblx0XHRcdFx0XHQvLyBvdGhlcndpc2UsIGJhc2VkIG9uIHRoZSByZW5kZXJlZCBhbmdsZSB2YWx1ZVxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRyYXRpbyA9IChkLmVuZEFuZ2xlIC0gZC5zdGFydEFuZ2xlKSAvIChcclxuXHRcdFx0XHRcdFx0TWF0aC5QSSAqICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMSA6IDIpXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSBcImluZGV4XCIpIHtcclxuXHRcdFx0XHRsZXQgdG90YWwgPSB0aGlzLmdldFRvdGFsUGVySW5kZXgoKTtcclxuXHJcblx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGxldCBoaWRkZW5TdW0gPSBkYXRhVmFsdWVzKHN0YXRlLmhpZGRlblRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChoaWRkZW5TdW0ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGhpZGRlblN1bSA9IGhpZGRlblN1bVxyXG5cdFx0XHRcdFx0XHRcdC5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjLm1hcCgodiwgaSkgPT4gKGlzTnVtYmVyKHYpID8gdiA6IDApICsgY3VycltpXSkpO1xyXG5cclxuXHRcdFx0XHRcdFx0dG90YWwgPSB0b3RhbC5tYXAoKHYsIGkpID0+IHYgLSBoaWRkZW5TdW1baV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZC5yYXRpbyA9IGlzTnVtYmVyKGQudmFsdWUpICYmIHRvdGFsICYmIHRvdGFsW2QuaW5kZXhdID4gMCA/XHJcblx0XHRcdFx0XHRkLnZhbHVlIC8gdG90YWxbZC5pbmRleF0gOiAwO1xyXG5cclxuXHRcdFx0XHRyYXRpbyA9IGQucmF0aW87XHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdFx0cmF0aW8gPSAocGFyc2VGbG9hdChTdHJpbmcoTWF0aC5tYXgoZC52YWx1ZSwgMCkpKSAvICQkLm1heFZhbHVlKSAqIGNvbmZpZy5yYWRhcl9zaXplX3JhdGlvO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFzUGVyY2VudCAmJiByYXRpbyA/IHJhdGlvICogMTAwIDogcmF0aW87XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU29ydCBkYXRhIGluZGV4IHRvIGJlIGFsaWduZWQgd2l0aCB4IGF4aXMuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gdGlja1ZhbHVlcyBUaWNrIGFycmF5IHZhbHVlc1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlRGF0YUluZGV4QnlYKHRpY2tWYWx1ZXMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRjb25zdCB0aWNrVmFsdWVNYXAgPSB0aWNrVmFsdWVzLnJlZHVjZSgob3V0LCB0aWNrLCBpbmRleCkgPT4ge1xyXG5cdFx0XHRvdXRbTnVtYmVyKHRpY2sueCldID0gaW5kZXg7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LCB7fSk7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdHQudmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XHJcblx0XHRcdFx0bGV0IGluZGV4ID0gdGlja1ZhbHVlTWFwW051bWJlcih2YWx1ZS54KV07XHJcblxyXG5cdFx0XHRcdGlmIChpbmRleCA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRpbmRleCA9IHZhbHVlSW5kZXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhbHVlLmluZGV4ID0gaW5kZXg7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRsb2FkKHJhd1RhcmdldHMsIGFyZ3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCB0YXJnZXRzID0gcmF3VGFyZ2V0cztcclxuXHJcblx0XHRpZiAodGFyZ2V0cykge1xyXG5cdFx0XHQvLyBmaWx0ZXIgbG9hZGluZyB0YXJnZXRzIGlmIG5lZWRlZFxyXG5cdFx0XHRpZiAoYXJncy5maWx0ZXIpIHtcclxuXHRcdFx0XHR0YXJnZXRzID0gdGFyZ2V0cy5maWx0ZXIoYXJncy5maWx0ZXIpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZXQgdHlwZSBpZiBhcmdzLnR5cGVzIHx8IGFyZ3MudHlwZSBzcGVjaWZpZWRcclxuXHRcdFx0aWYgKGFyZ3MudHlwZSB8fCBhcmdzLnR5cGVzKSB7XHJcblx0XHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IChhcmdzLnR5cGVzICYmIGFyZ3MudHlwZXNbdC5pZF0pIHx8IGFyZ3MudHlwZTtcclxuXHJcblx0XHRcdFx0XHQkJC5zZXRUYXJnZXRUeXBlKHQuaWQsIHR5cGUpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBVcGRhdGUvQWRkIGRhdGFcclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoZC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xyXG5cdFx0XHRcdFx0XHRkLnZhbHVlcyA9IHRhcmdldHNbaV0udmFsdWVzO1xyXG5cdFx0XHRcdFx0XHR0YXJnZXRzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdCQkLmRhdGEudGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cy5jb25jYXQodGFyZ2V0cyk7IC8vIGFkZCByZW1haW5lZFxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gUmVkcmF3IHdpdGggbmV3IHRhcmdldHNcclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aExlZ2VuZDogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0YXJncy5kb25lICYmIGFyZ3MuZG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdGxvYWRGcm9tQXJncyhhcmdzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gcHJldmVudCBsb2FkIHdoZW4gY2hhcnQgaXMgYWxyZWFkeSBkZXN0cm95ZWRcclxuXHRcdGlmICghJCQuY29uZmlnKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXNldCBpbnRlcm5hbGx5IGNhY2hlZCBkYXRhXHJcblx0XHQkJC5jYWNoZS5yZXNldCgpO1xyXG5cclxuXHRcdGNvbnN0IGRhdGEgPSBhcmdzLmRhdGEgfHwgJCQuY29udmVydERhdGEoYXJncywgZCA9PiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGQpLCBhcmdzKSk7XHJcblxyXG5cdFx0ZGF0YSAmJiAkJC5sb2FkKCQkLmNvbnZlcnREYXRhVG9UYXJnZXRzKGRhdGEpLCBhcmdzKTtcclxuXHR9LFxyXG5cclxuXHR1bmxvYWQocmF3VGFyZ2V0SWRzLCBjdXN0b21Eb25lQ2IpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cdFx0bGV0IGRvbmUgPSBjdXN0b21Eb25lQ2I7XHJcblx0XHRsZXQgdGFyZ2V0SWRzID0gcmF3VGFyZ2V0SWRzO1xyXG5cclxuXHRcdC8vIHJlc2V0IGludGVybmFsbHkgY2FjaGVkIGRhdGFcclxuXHRcdCQkLmNhY2hlLnJlc2V0KCk7XHJcblxyXG5cdFx0aWYgKCFkb25lKSB7XHJcblx0XHRcdGRvbmUgPSAoKSA9PiB7fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmaWx0ZXIgZXhpc3RpbmcgdGFyZ2V0XHJcblx0XHR0YXJnZXRJZHMgPSB0YXJnZXRJZHMuZmlsdGVyKGlkID0+ICQkLmhhc1RhcmdldCgkJC5kYXRhLnRhcmdldHMsIGlkKSk7XHJcblxyXG5cdFx0Ly8gSWYgbm8gdGFyZ2V0LCBjYWxsIGRvbmUgYW5kIHJldHVyblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMgfHwgdGFyZ2V0SWRzLmxlbmd0aCA9PT0gMCkge1xyXG5cdFx0XHRkb25lKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuc3ZnLnNlbGVjdEFsbCh0YXJnZXRJZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkKSkpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpXHJcblx0XHRcdC5jYWxsKCQkLmVuZGFsbCwgZG9uZSk7XHJcblxyXG5cdFx0dGFyZ2V0SWRzLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHQvLyBSZXNldCBmYWRlaW4gZm9yIGZ1dHVyZSBsb2FkXHJcblx0XHRcdHN0YXRlLndpdGhvdXRGYWRlSW5baWRdID0gZmFsc2U7XHJcblx0XHRcdC8vIFJlbW92ZSB0YXJnZXQncyBlbGVtZW50c1xyXG5cdFx0XHRpZiAoJGVsLmxlZ2VuZCkge1xyXG5cdFx0XHRcdCRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWApLnJlbW92ZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIFJlbW92ZSB0YXJnZXRcclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0ID0+IHQuaWQgIT09IGlkKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0UGF0aEJveH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCB7ZDNTZWxlY3Rpb259IGZyb20gXCJ0eXBlcy90eXBlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIGRyYWdnaW5nLlxyXG5cdCAqIERhdGEgcG9pbnRzIGNhbiBiZSBzZWxlY3RlZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSBPYmplY3RcclxuXHQgKi9cclxuXHRkcmFnKG1vdXNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fFxyXG5cdFx0XHQhY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQgfHwgLy8gZG8gbm90aGluZyBpZiBub3Qgc2VsZWN0YWJsZVxyXG5cdFx0XHQoY29uZmlnLnpvb21fZW5hYmxlZCAmJiAhJCQuem9vbS5hbHREb21haW4pIHx8IC8vIHNraXAgaWYgem9vbWFibGUgYmVjYXVzZSBvZiBjb25mbGljdCBkcmFnIGJlaGF2aW9yXHJcblx0XHRcdCFjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUgLy8gc2tpcCB3aGVuIHNpbmdsZSBzZWxlY3Rpb24gYmVjYXVzZSBkcmFnIGlzIHVzZWQgZm9yIG11bHRpcGxlIHNlbGVjdGlvblxyXG5cdFx0KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBbc3gsIHN5XSA9IHN0YXRlLmRyYWdTdGFydDtcclxuXHRcdGNvbnN0IFtteCwgbXldID0gbW91c2U7XHJcblxyXG5cdFx0Y29uc3QgbWluWCA9IE1hdGgubWluKHN4LCBteCk7XHJcblx0XHRjb25zdCBtYXhYID0gTWF0aC5tYXgoc3gsIG14KTtcclxuXHRcdGNvbnN0IG1pblkgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCA/IHN0YXRlLm1hcmdpbi50b3AgOiBNYXRoLm1pbihzeSwgbXkpO1xyXG5cdFx0Y29uc3QgbWF4WSA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gc3RhdGUuaGVpZ2h0IDogTWF0aC5tYXgoc3ksIG15KTtcclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuZHJhZ2FyZWF9YClcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIG1pblgpXHJcblx0XHRcdC5hdHRyKFwieVwiLCBtaW5ZKVxyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsIG1heFggLSBtaW5YKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBtYXhZIC0gbWluWSk7XHJcblxyXG5cdFx0Ly8gVE9ETzogYmluYXJ5IHNlYXJjaCB3aGVuIG11bHRpcGxlIHhzXHJcblx0XHRtYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5maWx0ZXIoZCA9PiBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGU6IGQzU2VsZWN0aW9uID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xyXG5cdFx0XHRcdGNvbnN0IGlzSW5jbHVkZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLklOQ0xVREVEKTtcclxuXHRcdFx0XHRsZXQgaXNXaXRoaW46IGFueSA9IGZhbHNlO1xyXG5cdFx0XHRcdGxldCB0b2dnbGU7XHJcblxyXG5cdFx0XHRcdGlmIChzaGFwZS5jbGFzc2VkKENMQVNTLmNpcmNsZSkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHg6IG51bWJlciA9ICtzaGFwZS5hdHRyKFwiY3hcIikgKiAxO1xyXG5cdFx0XHRcdFx0Y29uc3QgeTogbnVtYmVyID0gK3NoYXBlLmF0dHIoXCJjeVwiKSAqIDE7XHJcblxyXG5cdFx0XHRcdFx0dG9nZ2xlID0gJCQudG9nZ2xlUG9pbnQ7XHJcblx0XHRcdFx0XHRpc1dpdGhpbiA9IG1pblggPCB4ICYmIHggPCBtYXhYICYmIG1pblkgPCB5ICYmIHkgPCBtYXhZO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5iYXIpKSB7XHJcblx0XHRcdFx0XHRjb25zdCB7eCwgeSwgd2lkdGgsIGhlaWdodH0gPSBnZXRQYXRoQm94KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRcdHRvZ2dsZSA9ICQkLnRvZ2dsZVBhdGg7XHJcblx0XHRcdFx0XHRpc1dpdGhpbiA9ICEobWF4WCA8IHggfHwgeCArIHdpZHRoIDwgbWluWCkgJiYgIShtYXhZIDwgeSB8fCB5ICsgaGVpZ2h0IDwgbWluWSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRpZiAoaXNXaXRoaW4gXiBpc0luY2x1ZGVkKSB7XHJcblx0XHRcdFx0XHRzaGFwZS5jbGFzc2VkKENMQVNTLklOQ0xVREVELCAhaXNJbmNsdWRlZCk7XHJcblx0XHRcdFx0XHQvLyBUT0RPOiBpbmNsdWRlZC91bmluY2x1ZGVkIGNhbGxiYWNrIGhlcmVcclxuXHRcdFx0XHRcdHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsICFpc1NlbGVjdGVkKTtcclxuXHRcdFx0XHRcdHRvZ2dsZS5jYWxsKCQkLCAhaXNTZWxlY3RlZCwgc2hhcGUsIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGRyYWcgc3RhcnRzLlxyXG5cdCAqIEFkZHMgYW5kIFNob3dzIHRoZSBkcmFnIGFyZWEuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgT2JqZWN0XHJcblx0ICovXHJcblx0ZHJhZ3N0YXJ0KG1vdXNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhY29uZmlnLmRhdGFfc2VsZWN0aW9uX2VuYWJsZWQpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLmRyYWdTdGFydCA9IG1vdXNlO1xyXG5cclxuXHRcdG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmRyYWdhcmVhKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMC4xXCIpO1xyXG5cclxuXHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGRyYWcgZmluaXNoZXMuXHJcblx0ICogUmVtb3ZlcyB0aGUgZHJhZyBhcmVhLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0ZHJhZ2VuZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkLmNvbmZpZztcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpIHx8ICFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkgeyAvLyBkbyBub3RoaW5nIGlmIG5vdCBzZWxlY3RhYmxlXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuZHJhZ2FyZWF9YClcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLklOQ0xVREVELCBmYWxzZSk7XHJcblxyXG5cdFx0JCQuc2V0RHJhZ1N0YXR1cyhmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0c2V0RHJhZ1N0YXR1cyhpc0RyYWdnaW5nKSB7XHJcblx0XHR0aGlzLmRyYWdnaW5nID0gaXNEcmFnZ2luZztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3RBbGwgYXMgZDNTZWxlY3RBbGx9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtlYXNlTGluZWFyIGFzIGQzRWFzZUxpbmVhcn0gZnJvbSBcImQzLWVhc2VcIjtcclxuaW1wb3J0IHt0cmFuc2l0aW9uIGFzIGQzVHJhbnNpdGlvbn0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcclxuaW1wb3J0IHtkaWZmRG9tYWlufSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGZsb3dcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRJbnRlcm5hbFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuXHQgKi9cclxuXHRnZW5lcmF0ZUZsb3coYXJncykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGNvbnN0IHRhcmdldHMgPSBhcmdzLnRhcmdldHM7XHJcblx0XHRcdGNvbnN0IGZsb3cgPSBhcmdzLmZsb3c7XHJcblxyXG5cdFx0XHRjb25zdCB7YmFyOiBkcmF3QmFyLCBsaW5lOiBkcmF3TGluZSwgYXJlYTogZHJhd0FyZWF9ID0gYXJncy5zaGFwZS50eXBlO1xyXG5cdFx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gYXJncy5zaGFwZS5wb3M7XHJcblx0XHRcdGNvbnN0IHh2ID0gYXJncy54djtcclxuXHRcdFx0Y29uc3QgZHVyYXRpb24gPSBhcmdzLmR1cmF0aW9uO1xyXG5cclxuXHRcdFx0bGV0IHRyYW5zbGF0ZVg7XHJcblx0XHRcdGxldCBzY2FsZVggPSAxO1xyXG5cdFx0XHRjb25zdCBmbG93SW5kZXggPSBmbG93LmluZGV4O1xyXG5cdFx0XHRjb25zdCBmbG93TGVuZ3RoID0gZmxvdy5sZW5ndGg7XHJcblx0XHRcdGxldCBmbG93U3RhcnQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgZmxvd0luZGV4KTtcclxuXHRcdFx0bGV0IGZsb3dFbmQgPSAkJC5nZXRWYWx1ZU9uSW5kZXgoJCQuZGF0YS50YXJnZXRzWzBdLnZhbHVlcywgZmxvd0luZGV4ICsgZmxvd0xlbmd0aCk7XHJcblx0XHRcdGNvbnN0IG9yZ0RvbWFpbiA9ICQkLnNjYWxlLnguZG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IGR1cmF0aW9uRm9yRmxvdyA9IGZsb3cuZHVyYXRpb24gfHwgZHVyYXRpb247XHJcblx0XHRcdGNvbnN0IGRvbmUgPSBmbG93LmRvbmUgfHwgZnVuY3Rpb24oKSB7fTtcclxuXHRcdFx0Y29uc3Qgd2FpdCA9ICQkLmdlbmVyYXRlV2FpdCgpO1xyXG5cclxuXHRcdFx0Y29uc3QgeGdyaWQgPSAkZWwuZ3JpZC54O1xyXG5cdFx0XHRjb25zdCB4Z3JpZExpbmVzID0gJGVsLmdyaWQueExpbmVzO1xyXG5cdFx0XHRjb25zdCBtYWluUmVnaW9uID0gJGVsLnJlZ2lvbi5saXN0O1xyXG5cdFx0XHRjb25zdCBtYWluVGV4dCA9ICRlbC50ZXh0O1xyXG5cdFx0XHRjb25zdCBtYWluQmFyID0gJGVsLmJhcjtcclxuXHRcdFx0Y29uc3QgbWFpbkxpbmUgPSAkZWwubGluZTtcclxuXHRcdFx0Y29uc3QgbWFpbkFyZWEgPSAkZWwuYXJlYTtcclxuXHRcdFx0Y29uc3QgbWFpbkNpcmNsZSA9ICRlbC5jaXJjbGU7XHJcblxyXG5cdFx0XHQvLyBzZXQgZmxhZ1xyXG5cdFx0XHRzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSBoZWFkIGRhdGEgYWZ0ZXIgcmVuZGVyZWRcclxuXHRcdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdFx0ZC52YWx1ZXMuc3BsaWNlKDAsIGZsb3dMZW5ndGgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZSB4IGRvbWFpbiB0byBnZW5lcmF0ZSBheGlzIGVsZW1lbnRzIGZvciBmbG93XHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9ICQkLnVwZGF0ZVhEb21haW4odGFyZ2V0cywgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgZWxlbWVudHMgcmVsYXRlZCB0byB4IHNjYWxlXHJcblx0XHRcdGlmICgkJC51cGRhdGVYR3JpZCkgeyAkJC51cGRhdGVYR3JpZCh0cnVlKTsgfVxyXG5cclxuXHRcdFx0Y29uc3Qge3h9ID0gJCQuc2NhbGU7XHJcblxyXG5cdFx0XHQvLyBnZW5lcmF0ZSB0cmFuc2Zvcm0gdG8gZmxvd1xyXG5cdFx0XHRpZiAoIWZsb3cub3JnRGF0YUNvdW50KSB7IC8vIGlmIGVtcHR5XHJcblx0XHRcdFx0aWYgKCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMubGVuZ3RoICE9PSAxKSB7XHJcblx0XHRcdFx0XHR0cmFuc2xhdGVYID0geChvcmdEb21haW5bMF0pIC0geChkb21haW5bMF0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0XHRcdFx0Zmxvd1N0YXJ0ID0gJCQuZ2V0VmFsdWVPbkluZGV4KCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMsIDApO1xyXG5cdFx0XHRcdFx0XHRmbG93RW5kID0gJCQuZ2V0VmFsdWVPbkluZGV4KCQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMsICQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXMubGVuZ3RoIC0gMSk7XHJcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZVggPSB4KGZsb3dTdGFydC54KSAtIHgoZmxvd0VuZC54KTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRyYW5zbGF0ZVggPSBkaWZmRG9tYWluKGRvbWFpbikgLyAyO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChmbG93Lm9yZ0RhdGFDb3VudCA9PT0gMSB8fCAoZmxvd1N0YXJ0ICYmIGZsb3dTdGFydC54KSA9PT0gKGZsb3dFbmQgJiYgZmxvd0VuZC54KSkge1xyXG5cdFx0XHRcdHRyYW5zbGF0ZVggPSB4KG9yZ0RvbWFpblswXSkgLSB4KGRvbWFpblswXSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdFx0XHR0cmFuc2xhdGVYID0gKHgob3JnRG9tYWluWzBdKSAtIHgoZG9tYWluWzBdKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRyYW5zbGF0ZVggPSAoeChmbG93U3RhcnQueCkgLSB4KGZsb3dFbmQueCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c2NhbGVYID0gKGRpZmZEb21haW4ob3JnRG9tYWluKSAvIGRpZmZEb21haW4oZG9tYWluKSk7XHJcblx0XHRcdGNvbnN0IHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt0cmFuc2xhdGVYfSwwKSBzY2FsZSgke3NjYWxlWH0sMSlgO1xyXG5cclxuXHRcdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cclxuXHRcdFx0Y29uc3QgZ3QgPSBkM1RyYW5zaXRpb24oKS5lYXNlKGQzRWFzZUxpbmVhcilcclxuXHRcdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JGbG93KTtcclxuXHJcblx0XHRcdHdhaXQuYWRkKFtcclxuXHRcdFx0XHQkJC4kZWwuYXhpcy54XHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcclxuXHRcdFx0XHRcdC5jYWxsKGcgPT4gJCQuYXhpcy54LnNldFRyYW5zaXRpb24oZ3QpLmNyZWF0ZShnKSksXHJcblxyXG5cdFx0XHRcdG1haW5CYXJcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcclxuXHJcblx0XHRcdFx0bWFpbkxpbmVcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcclxuXHJcblx0XHRcdFx0bWFpbkFyZWFcclxuXHRcdFx0XHRcdC50cmFuc2l0aW9uKGd0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtKSxcclxuXHJcblx0XHRcdFx0bWFpbkNpcmNsZVxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxyXG5cclxuXHRcdFx0XHRtYWluVGV4dFxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxyXG5cclxuXHRcdFx0XHRtYWluUmVnaW9uXHJcblx0XHRcdFx0XHQuZmlsdGVyKCQkLmlzUmVnaW9uT25YKVxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxyXG5cclxuXHRcdFx0XHR4Z3JpZFxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oZ3QpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pLFxyXG5cclxuXHRcdFx0XHR4Z3JpZExpbmVzXHJcblx0XHRcdFx0XHQudHJhbnNpdGlvbihndClcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSksXHJcblx0XHRcdF0pO1xyXG5cclxuXHRcdFx0Z3QuY2FsbCh3YWl0LCAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRcdFx0Ly8gcmVtb3ZlIGZsb3dlZCBlbGVtZW50c1xyXG5cdFx0XHRcdGlmIChmbG93TGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRjb25zdCB0YXJnZXQ6IGFueSA9IHtcclxuXHRcdFx0XHRcdFx0c2hhcGVzOiBbXSxcclxuXHRcdFx0XHRcdFx0dGV4dHM6IFtdLFxyXG5cdFx0XHRcdFx0XHRldmVudFJlY3RzOiBbXVxyXG5cdFx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGZsb3dMZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR0YXJnZXQuc2hhcGVzLnB1c2goYC4ke0NMQVNTLnNoYXBlfS0ke2l9YCk7XHJcblx0XHRcdFx0XHRcdHRhcmdldC50ZXh0cy5wdXNoKGAuJHtDTEFTUy50ZXh0fS0ke2l9YCk7XHJcblx0XHRcdFx0XHRcdHRhcmdldC5ldmVudFJlY3RzLnB1c2goYC4ke0NMQVNTLmV2ZW50UmVjdH0tJHtpfWApO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFtcInNoYXBlc1wiLCBcInRleHRzXCIsIFwiZXZlbnRSZWN0c1wiXS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0XHQkZWwuc3ZnLnNlbGVjdEFsbChgLiR7Q0xBU1Nbdl19YClcclxuXHRcdFx0XHRcdFx0XHQuc2VsZWN0QWxsKHRhcmdldFt2XSlcclxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlKCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0XHQkZWwuc3ZnLnNlbGVjdChgLiR7Q0xBU1MueGdyaWR9YClcclxuXHRcdFx0XHRcdFx0LnJlbW92ZSgpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gZHJhdyBhZ2FpbiBmb3IgcmVtb3ZpbmcgZmxvd2VkIGVsZW1lbnRzIGFuZCByZXZlcnRpbmcgYXR0clxyXG5cdFx0XHRcdHhncmlkLnNpemUoKSAmJiB4Z3JpZFxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbClcclxuXHRcdFx0XHRcdC5hdHRyKHN0YXRlLnhncmlkQXR0cik7XHJcblxyXG5cdFx0XHRcdHhncmlkTGluZXNcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xyXG5cclxuXHRcdFx0XHR4Z3JpZExpbmVzLnNlbGVjdChcImxpbmVcIilcclxuXHRcdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IHh2KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyBzdGF0ZS53aWR0aCA6IHh2KTtcclxuXHJcblx0XHRcdFx0eGdyaWRMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgaXNSb3RhdGVkID8gc3RhdGUud2lkdGggOiAwKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5XCIsIHh2KTtcclxuXHJcblx0XHRcdFx0bWFpbkJhclxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3QmFyKTtcclxuXHJcblx0XHRcdFx0bWFpbkxpbmVcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXHJcblx0XHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0xpbmUpO1xyXG5cclxuXHRcdFx0XHRtYWluQXJlYVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3QXJlYSk7XHJcblxyXG5cdFx0XHRcdG1haW5DaXJjbGVcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpO1xyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNDaXJjbGVQb2ludCgpKSB7XHJcblx0XHRcdFx0XHRtYWluQ2lyY2xlXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zdCB4RnVuYyA9IGQgPT4gY3goZCkgLSBjb25maWcucG9pbnRfcjtcclxuXHRcdFx0XHRcdGNvbnN0IHlGdW5jID0gZCA9PiBjeShkKSAtIGNvbmZpZy5wb2ludF9yO1xyXG5cclxuXHRcdFx0XHRcdG1haW5DaXJjbGVcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHhGdW5jKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZ1bmMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3hcIiwgY3gpIC8vIHdoZW4gcGF0dGVybiBpcyB1c2VkLCBpdCBwb3NzaWJseSBjb250YWluICdjaXJjbGUnIGFsc28uXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY3lcIiwgY3kpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bWFpblRleHRcclxuXHRcdFx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIG51bGwpXHJcblx0XHRcdFx0XHQuYXR0cihcInhcIiwgeEZvclRleHQpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeUZvclRleHQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgJCQub3BhY2l0eUZvclRleHQuYmluZCgkJCkpO1xyXG5cclxuXHRcdFx0XHRtYWluUmVnaW9uXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBudWxsKTtcclxuXHJcblx0XHRcdFx0bWFpblJlZ2lvbi5zZWxlY3QoXCJyZWN0XCIpLmZpbHRlcigkJC5pc1JlZ2lvbk9uWClcclxuXHRcdFx0XHRcdC5hdHRyKFwieFwiLCAkJC5yZWdpb25YLmJpbmQoJCQpKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5yZWdpb25XaWR0aC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0XHRcdGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmICQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cclxuXHRcdFx0XHQvLyBjYWxsYmFjayBmb3IgZW5kIG9mIGZsb3dcclxuXHRcdFx0XHRkb25lKCk7XHJcblxyXG5cdFx0XHRcdHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdG1vdXNlIGFzIGQzTW91c2UsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdGV2ZW50IGFzIGQzRXZlbnRcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZHJhZyBhcyBkM0RyYWd9IGZyb20gXCJkMy1kcmFnXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7ZW11bGF0ZUV2ZW50LCBpc0Jvb2xlYW4sIGlzTnVtYmVyLCBpc09iamVjdH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxyXG5cdCAqIEFkZCBhIGNvbnRhaW5lciBmb3IgdGhlIHpvbmUgdGhhdCBkZXRlY3RzIHRoZSBldmVudC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRFdmVudFJlY3QoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmV2ZW50UmVjdHMpXHJcblx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBcIjBcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3cyB0aGUgYXJlYSB0aGF0IGRldGVjdHMgdGhlIGV2ZW50LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3RXZlbnRSZWN0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNNdWx0aXBsZVggPSAkJC5pc011bHRpcGxlWCgpO1xyXG5cdFx0bGV0IGV2ZW50UmVjdFVwZGF0ZTtcclxuXHJcblx0XHRjb25zdCB6b29tRW5hYmxlZCA9IGNvbmZpZy56b29tX2VuYWJsZWQ7XHJcblx0XHRjb25zdCBldmVudFJlY3RzID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3RzfWApXHJcblx0XHRcdC5zdHlsZShcImN1cnNvclwiLCB6b29tRW5hYmxlZCAmJiB6b29tRW5hYmxlZC50eXBlICE9PSBcImRyYWdcIiA/IChcclxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJucy1yZXNpemVcIiA6IFwiZXctcmVzaXplXCJcclxuXHRcdFx0KSA6IG51bGwpXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNNdWx0aXBsZSwgaXNNdWx0aXBsZVgpXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdHNTaW5nbGUsICFpc011bHRpcGxlWCk7XHJcblxyXG5cdFx0Ly8gY2xlYXIgb2xkIHJlY3RzXHJcblx0XHRldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApLnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIG9wZW4gYXMgcHVibGljIGNvbnN0aWFibGVcclxuXHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApO1xyXG5cclxuXHRcdGlmIChpc011bHRpcGxlWCkge1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkZWwuZXZlbnRSZWN0LmRhdGEoWzBdKTtcclxuXHRcdFx0Ly8gdXBkYXRlXHJcblx0XHRcdC8vIGVudGVyOiBvbmx5IG9uZSByZWN0IHdpbGwgYmUgYWRkZWRcclxuXHRcdFx0Ly8gZXhpdDogbm90IG5lZWRlZCBiZWNhdXNlIGFsd2F5cyBvbmx5IG9uZSByZWN0IGV4aXN0c1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdFVwZGF0ZS5lbnRlcigpKVxyXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gU2V0IGRhdGEgYW5kIHVwZGF0ZSAkZWwuZXZlbnRSZWN0XHJcblx0XHRcdGNvbnN0IHhBeGlzVGlja1ZhbHVlcyA9ICQkLmdldE1heERhdGFDb3VudFRhcmdldCgpO1xyXG5cclxuXHRcdFx0Ly8gdXBkYXRlIGRhdGEncyBpbmRleCB2YWx1ZSB0byBiZSBhbGluZ2VkIHdpdGggdGhlIHggQXhpc1xyXG5cdFx0XHQkJC51cGRhdGVEYXRhSW5kZXhCeVgoeEF4aXNUaWNrVmFsdWVzKTtcclxuXHRcdFx0JCQudXBkYXRlWHMoeEF4aXNUaWNrVmFsdWVzKTtcclxuXHRcdFx0JCQudXBkYXRlUG9pbnRDbGFzcyh0cnVlKTtcclxuXHJcblx0XHRcdGV2ZW50UmVjdHMuZGF0dW0oeEF4aXNUaWNrVmFsdWVzKTtcclxuXHJcblx0XHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RzLnNlbGVjdEFsbChgLiR7Q0xBU1MuZXZlbnRSZWN0fWApO1xyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkZWwuZXZlbnRSZWN0LmRhdGEoZCA9PiBkKTtcclxuXHJcblx0XHRcdC8vIGV4aXRcclxuXHRcdFx0ZXZlbnRSZWN0VXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRcdC8vIHVwZGF0ZVxyXG5cdFx0XHRldmVudFJlY3RVcGRhdGUgPSAkJC5nZW5lcmF0ZUV2ZW50UmVjdHNGb3JTaW5nbGVYKGV2ZW50UmVjdFVwZGF0ZS5lbnRlcigpKVxyXG5cdFx0XHRcdC5tZXJnZShldmVudFJlY3RVcGRhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCRlbC5ldmVudFJlY3QgPSBldmVudFJlY3RVcGRhdGU7XHJcblx0XHQkJC51cGRhdGVFdmVudFJlY3QoZXZlbnRSZWN0VXBkYXRlKTtcclxuXHJcblx0XHRpZiAoJCQuc3RhdGUuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgISRlbC5zdmcub24oXCJ0b3VjaHN0YXJ0LmV2ZW50UmVjdFwiKSAmJiAhJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdCQkLmJpbmRUb3VjaE9uRXZlbnRSZWN0KGlzTXVsdGlwbGVYKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRiaW5kVG91Y2hPbkV2ZW50UmVjdChpc011bHRpcGxlWCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0RXZlbnRSZWN0ID0gKCkgPT4ge1xyXG5cdFx0XHRjb25zdCB0b3VjaCA9IGQzRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblxyXG5cdFx0XHRyZXR1cm4gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IGdldEluZGV4ID0gZXZlbnRSZWN0ID0+IHtcclxuXHRcdFx0bGV0IGluZGV4ID0gZXZlbnRSZWN0ICYmIGV2ZW50UmVjdC5hdHRyKFwiY2xhc3NcIikgJiYgZXZlbnRSZWN0LmF0dHIoXCJjbGFzc1wiKVxyXG5cdFx0XHRcdC5yZXBsYWNlKG5ldyBSZWdFeHAoYCgke0NMQVNTLmV2ZW50UmVjdH0tP3xzKWAsIFwiZ1wiKSwgXCJcIikgKiAxO1xyXG5cclxuXHRcdFx0aWYgKGlzTmFOKGluZGV4KSB8fCBpbmRleCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdGluZGV4ID0gLTE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBpbmRleDtcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3Qgc2VsZWN0UmVjdCA9IGNvbnRleHQgPT4ge1xyXG5cdFx0XHRpZiAoaXNNdWx0aXBsZVgpIHtcclxuXHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyhjb250ZXh0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBldmVudFJlY3QgPSBnZXRFdmVudFJlY3QoKTtcclxuXHRcdFx0XHRjb25zdCBpbmRleCA9IGdldEluZGV4KGV2ZW50UmVjdCk7XHJcblxyXG5cdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRpbmRleCA9PT0gLTEgP1xyXG5cdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOlxyXG5cdFx0XHRcdFx0JCQuc2VsZWN0UmVjdEZvclNpbmdsZShjb250ZXh0LCBldmVudFJlY3QsIGluZGV4KTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBjYWxsIGV2ZW50LnByZXZlbnREZWZhdWx0KClcclxuXHRcdC8vIGFjY29yZGluZyAnaW50ZXJhY3Rpb24uaW5wdXRUeXBlLnRvdWNoLnByZXZlbnREZWZhdWx0JyBvcHRpb25cclxuXHRcdGNvbnN0IHByZXZlbnREZWZhdWx0ID0gY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaC5wcmV2ZW50RGVmYXVsdDtcclxuXHRcdGNvbnN0IGlzUHJldmVudGVkID0gKGlzQm9vbGVhbihwcmV2ZW50RGVmYXVsdCkgJiYgcHJldmVudERlZmF1bHQpIHx8IGZhbHNlO1xyXG5cdFx0Y29uc3QgcHJldmVudFRocmVzaG9sZCA9ICghaXNOYU4ocHJldmVudERlZmF1bHQpICYmIHByZXZlbnREZWZhdWx0KSB8fCBudWxsO1xyXG5cdFx0bGV0IHN0YXJ0UHg7XHJcblxyXG5cdFx0Y29uc3QgcHJldmVudEV2ZW50ID0gZXZlbnQgPT4ge1xyXG5cdFx0XHRjb25zdCBldmVudFR5cGUgPSBldmVudC50eXBlO1xyXG5cdFx0XHRjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRjb25zdCBjdXJyZW50WFkgPSB0b3VjaFtgY2xpZW50JHtjb25maWcuYXhpc19yb3RhdGVkID8gXCJZXCIgOiBcIlhcIn1gXTtcclxuXHJcblx0XHRcdC8vIHByZXZlbnQgZG9jdW1lbnQgc2Nyb2xsaW5nXHJcblx0XHRcdGlmIChldmVudFR5cGUgPT09IFwidG91Y2hzdGFydFwiKSB7XHJcblx0XHRcdFx0aWYgKGlzUHJldmVudGVkKSB7XHJcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAocHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0c3RhcnRQeCA9IGN1cnJlbnRYWTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBcInRvdWNobW92ZVwiKSB7XHJcblx0XHRcdFx0aWYgKGlzUHJldmVudGVkIHx8IHN0YXJ0UHggPT09IHRydWUgfHwgKFxyXG5cdFx0XHRcdFx0cHJldmVudFRocmVzaG9sZCAhPT0gbnVsbCAmJiBNYXRoLmFicyhzdGFydFB4IC0gY3VycmVudFhZKSA+PSBwcmV2ZW50VGhyZXNob2xkXHJcblx0XHRcdFx0KSkge1xyXG5cdFx0XHRcdFx0Ly8gb25jZSBwcmV2ZW50ZWQsIGtlZXAgcHJldmVudGVkIGR1cmluZyB3aG9sZSAndG91Y2htb3ZlJyBjb250ZXh0XHJcblx0XHRcdFx0XHRzdGFydFB4ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGJpbmQgdG91Y2ggZXZlbnRzXHJcblx0XHQkJC4kZWwuc3ZnXHJcblx0XHRcdC5vbihcInRvdWNoc3RhcnQuZXZlbnRSZWN0IHRvdWNobW92ZS5ldmVudFJlY3RcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgZXZlbnRSZWN0ID0gZ2V0RXZlbnRSZWN0KCk7XHJcblx0XHRcdFx0Y29uc3QgZXZlbnQgPSBkM0V2ZW50O1xyXG5cclxuXHRcdFx0XHRpZiAoIWV2ZW50UmVjdC5lbXB0eSgpICYmIGV2ZW50UmVjdC5jbGFzc2VkKENMQVNTLmV2ZW50UmVjdCkpIHtcclxuXHRcdFx0XHRcdC8vIGlmIHRvdWNoIHBvaW50cyBhcmUgPiAxLCBtZWFucyBkb2luZyB6b29taW5nIGludGVyYWN0aW9uLiBJbiB0aGlzIGNhc2UgZG8gbm90IGV4ZWN1dGUgdG9vbHRpcCBjb2Rlcy5cclxuXHRcdFx0XHRcdGlmIChzdGF0ZS5kcmFnZ2luZyB8fCBzdGF0ZS5mbG93aW5nIHx8ICQkLmhhc0FyY1R5cGUoKSB8fCBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHByZXZlbnRFdmVudChldmVudCk7XHJcblx0XHRcdFx0XHRzZWxlY3RSZWN0KHRoaXMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIHRydWUpXHJcblx0XHRcdC5vbihcInRvdWNoZW5kLmV2ZW50UmVjdFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgZXZlbnRSZWN0ID0gZ2V0RXZlbnRSZWN0KCk7XHJcblxyXG5cdFx0XHRcdGlmICghZXZlbnRSZWN0LmVtcHR5KCkgJiYgZXZlbnRSZWN0LmNsYXNzZWQoQ0xBU1MuZXZlbnRSZWN0KSkge1xyXG5cdFx0XHRcdFx0aWYgKCQkLmhhc0FyY1R5cGUoKSB8fCAhJCQudG9nZ2xlU2hhcGUgfHwgc3RhdGUuY2FuY2VsQ2xpY2spIHtcclxuXHRcdFx0XHRcdFx0c3RhdGUuY2FuY2VsQ2xpY2sgJiYgKHN0YXRlLmNhbmNlbENsaWNrID0gZmFsc2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVXBkYXRlcyB0aGUgbG9jYXRpb24gYW5kIHNpemUgb2YgdGhlIGV2ZW50UmVjdC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdHVwZGF0ZUV2ZW50UmVjdChldmVudFJlY3RVcGRhdGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IHhTY2FsZSA9IHNjYWxlLnpvb20gfHwgc2NhbGUueDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdERhdGEgPSBldmVudFJlY3RVcGRhdGUgfHwgJCQuJGVsLmV2ZW50UmVjdC5kYXRhKCk7IC8vIHNldCB1cGRhdGUgc2VsZWN0aW9uIGlmIG51bGxcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRsZXQgeDtcclxuXHRcdGxldCB5O1xyXG5cdFx0bGV0IHc7XHJcblx0XHRsZXQgaDtcclxuXHJcblx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHQvLyBUT0RPOiByb3RhdGVkIG5vdCBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdHggPSAwO1xyXG5cdFx0XHR5ID0gMDtcclxuXHRcdFx0dyA9IHN0YXRlLndpZHRoO1xyXG5cdFx0XHRoID0gc3RhdGUuaGVpZ2h0O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IHJlY3RXO1xyXG5cdFx0XHRsZXQgcmVjdFg7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNDYXRlZ29yaXplZCgpKSB7XHJcblx0XHRcdFx0cmVjdFcgPSAkJC5nZXRFdmVudFJlY3RXaWR0aCgpO1xyXG5cdFx0XHRcdHJlY3RYID0gZCA9PiB4U2NhbGUoZC54KSAtIChyZWN0VyAvIDIpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvbnN0IGdldFByZXZOZXh0WCA9IGQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgaW5kZXggPSBkLmluZGV4O1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdHByZXY6ICQkLmdldFByZXZYKGluZGV4KSxcclxuXHRcdFx0XHRcdFx0bmV4dDogJCQuZ2V0TmV4dFgoaW5kZXgpXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdHJlY3RXID0gZCA9PiB7XHJcblx0XHRcdFx0XHRjb25zdCB4ID0gZ2V0UHJldk5leHRYKGQpO1xyXG5cclxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIHRoaXMgaXMgYSBzaW5nbGUgZGF0YSBwb2ludCBtYWtlIHRoZSBldmVudFJlY3QgZnVsbCB3aWR0aCAob3IgaGVpZ2h0KVxyXG5cdFx0XHRcdFx0aWYgKHgucHJldiA9PT0gbnVsbCAmJiB4Lm5leHQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCA6IHN0YXRlLndpZHRoO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0eC5wcmV2ID0geFNjYWxlLmRvbWFpbigpWzBdO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh4Lm5leHQgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0eC5uZXh0ID0geFNjYWxlLmRvbWFpbigpWzFdO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heCgwLCAoeFNjYWxlKHgubmV4dCkgLSB4U2NhbGUoeC5wcmV2KSkgLyAyKTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRyZWN0WCA9IGQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IGdldFByZXZOZXh0WChkKTtcclxuXHRcdFx0XHRcdGNvbnN0IHRoaXNYID0gZC54O1xyXG5cclxuXHRcdFx0XHRcdC8vIGlmIHRoZXJlIHRoaXMgaXMgYSBzaW5nbGUgZGF0YSBwb2ludCBwb3NpdGlvbiB0aGUgZXZlbnRSZWN0IGF0IDBcclxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwgJiYgeC5uZXh0ID09PSBudWxsKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiAwO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmICh4LnByZXYgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdFx0eC5wcmV2ID0geFNjYWxlLmRvbWFpbigpWzBdO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHJldHVybiAoeFNjYWxlKHRoaXNYKSArIHhTY2FsZSh4LnByZXYpKSAvIDI7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiByZWN0WDtcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IHJlY3RYIDogMDtcclxuXHRcdFx0dyA9IGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogcmVjdFc7XHJcblx0XHRcdGggPSBpc1JvdGF0ZWQgPyByZWN0VyA6IHN0YXRlLmhlaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRldmVudFJlY3REYXRhLmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0V2ZW50LmJpbmQoJCQpKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgeClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgdylcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaCk7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0UmVjdEZvclNpbmdsZShjb250ZXh0LCBldmVudFJlY3QsIGluZGV4KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzU2VsZWN0aW9uRW5hYmxlZCA9IGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkO1xyXG5cdFx0Y29uc3QgaXNTZWxlY3Rpb25Hcm91cGVkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQ7XHJcblx0XHRjb25zdCBpc1Rvb2x0aXBHcm91cGVkID0gY29uZmlnLnRvb2x0aXBfZ3JvdXBlZDtcclxuXHRcdGNvbnN0IHNlbGVjdGVkRGF0YSA9ICQkLmdldEFsbFZhbHVlc09uSW5kZXgoaW5kZXgpO1xyXG5cclxuXHRcdGlmIChpc1Rvb2x0aXBHcm91cGVkKSB7XHJcblx0XHRcdCQkLnNob3dUb29sdGlwKHNlbGVjdGVkRGF0YSwgY29udGV4dCk7XHJcblx0XHRcdCQkLnNob3dHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHRcdGlmICghaXNTZWxlY3Rpb25FbmFibGVkIHx8IGlzU2VsZWN0aW9uR3JvdXBlZCkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtpbmRleH1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVELCB0cnVlKTtcclxuXHJcblx0XHRcdFx0aWYgKGlzU2VsZWN0aW9uRW5hYmxlZCkge1xyXG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIGlzU2VsZWN0aW9uR3JvdXBlZCA/IFwicG9pbnRlclwiIDogbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIWlzVG9vbHRpcEdyb3VwZWQpIHtcclxuXHRcdFx0XHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHRcdFx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblxyXG5cdFx0XHRcdFx0IWlzU2VsZWN0aW9uR3JvdXBlZCAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhpbmRleCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhbGwoc2VsZWN0ZWQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IGQgPSBzZWxlY3RlZC5kYXRhKCk7XHJcblxyXG5cdFx0XHRcdGlmIChpc1NlbGVjdGlvbkVuYWJsZWQgJiYgKGlzU2VsZWN0aW9uR3JvdXBlZCB8fCBjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpKSkge1xyXG5cdFx0XHRcdFx0ZXZlbnRSZWN0LnN0eWxlKFwiY3Vyc29yXCIsIFwicG9pbnRlclwiKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICghaXNUb29sdGlwR3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0JCQuc2hvd1Rvb2x0aXAoZCwgY29udGV4dCk7XHJcblx0XHRcdFx0XHQkJC5zaG93R3JpZEZvY3VzKGQpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cdFx0XHRcdFx0c2VsZWN0ZWQuZWFjaChkID0+ICQkLmV4cGFuZENpcmNsZXNCYXJzKGluZGV4LCBkLmlkKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRleHBhbmRDaXJjbGVzQmFycyhpbmRleCwgaWQsIHJlc2V0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNvbmZpZy5wb2ludF9mb2N1c19leHBhbmRfZW5hYmxlZCAmJlxyXG5cdFx0XHQkJC5leHBhbmRDaXJjbGVzKGluZGV4LCBpZCwgcmVzZXQpO1xyXG5cclxuXHRcdCQkLmV4cGFuZEJhcnMoaW5kZXgsIGlkLCByZXNldCk7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0UmVjdEZvck11bHRpcGxlWHMoY29udGV4dCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdC8vIGRvIG5vdGhpbmcgd2hlbiBkcmFnZ2luZ1xyXG5cdFx0aWYgKCQkLmRyYWdnaW5nIHx8ICQkLmhhc0FyY1R5cGUodGFyZ2V0c1RvU2hvdykpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG1vdXNlID0gZDNNb3VzZShjb250ZXh0KTtcclxuXHRcdGNvbnN0IGNsb3Nlc3QgPSAkJC5maW5kQ2xvc2VzdEZyb21UYXJnZXRzKHRhcmdldHNUb1Nob3csIG1vdXNlKTtcclxuXHJcblx0XHRpZiAoc3RhdGUubW91c2VvdmVyICYmICghY2xvc2VzdCB8fCBjbG9zZXN0LmlkICE9PSBzdGF0ZS5tb3VzZW92ZXIuaWQpKSB7XHJcblx0XHRcdGNvbmZpZy5kYXRhX29ub3V0LmNhbGwoJCQuYXBpLCBzdGF0ZS5tb3VzZW92ZXIpO1xyXG5cdFx0XHRzdGF0ZS5tb3VzZW92ZXIgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjbG9zZXN0KSB7XHJcblx0XHRcdCQkLnVuc2VsZWN0UmVjdCgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgc2FtZVhEYXRhID0gKFxyXG5cdFx0XHQkJC5pc0J1YmJsZVR5cGUoY2xvc2VzdCkgfHwgJCQuaXNTY2F0dGVyVHlwZShjbG9zZXN0KSB8fCAhY29uZmlnLnRvb2x0aXBfZ3JvdXBlZFxyXG5cdFx0KSA/IFtjbG9zZXN0XSA6ICQkLmZpbHRlckJ5WCh0YXJnZXRzVG9TaG93LCBjbG9zZXN0LngpO1xyXG5cclxuXHRcdC8vIHNob3cgdG9vbHRpcCB3aGVuIGN1cnNvciBpcyBjbG9zZSB0byBzb21lIHBvaW50XHJcblx0XHRjb25zdCBzZWxlY3RlZERhdGEgPSBzYW1lWERhdGEubWFwKGQgPT4gJCQuYWRkTmFtZShkKSk7XHJcblxyXG5cdFx0JCQuc2hvd1Rvb2x0aXAoc2VsZWN0ZWREYXRhLCBjb250ZXh0KTtcclxuXHJcblx0XHQvLyBleHBhbmQgcG9pbnRzXHJcblx0XHQkJC5leHBhbmRDaXJjbGVzQmFycyhjbG9zZXN0LmluZGV4LCBjbG9zZXN0LmlkLCB0cnVlKTtcclxuXHJcblx0XHQvLyBTaG93IHhncmlkIGZvY3VzIGxpbmVcclxuXHRcdCQkLnNob3dHcmlkRm9jdXMoc2VsZWN0ZWREYXRhKTtcclxuXHJcblx0XHQvLyBTaG93IGN1cnNvciBhcyBwb2ludGVyIGlmIHBvaW50IGlzIGNsb3NlIHRvIG1vdXNlIHBvc2l0aW9uXHJcblx0XHRpZiAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSB7XHJcblx0XHRcdCQkLiRlbC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3R9YCkuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpO1xyXG5cclxuXHRcdFx0aWYgKCFzdGF0ZS5tb3VzZW92ZXIpIHtcclxuXHRcdFx0XHRjb25maWcuZGF0YV9vbm92ZXIuY2FsbCgkJC5hcGksIGNsb3Nlc3QpO1xyXG5cdFx0XHRcdHN0YXRlLm1vdXNlb3ZlciA9IGNsb3Nlc3Q7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbnNlbGVjdCBFdmVudFJlY3QuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1bnNlbGVjdFJlY3QoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmV2ZW50UmVjdH1gKS5zdHlsZShcImN1cnNvclwiLCBudWxsKTtcclxuXHRcdCQkLmhpZGVHcmlkRm9jdXMoKTtcclxuXHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKGZhbHNlKTtcclxuXHRcdCQkLnVuZXhwYW5kQ2lyY2xlcygpO1xyXG5cdFx0JCQudW5leHBhbmRCYXJzKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGFuZGxlIGRhdGEub25vdmVyL291dCBjYWxsYmFjayBvcHRpb25zXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJcclxuXHQgKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IGRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldE92ZXJPdXQoaXNPdmVyLCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHttYWlufX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzQXJjID0gaXNPYmplY3QoZCk7XHJcblxyXG5cdFx0Ly8gQ2FsbCBldmVudCBoYW5kbGVyXHJcblx0XHRpZiAoaXNBcmMgfHwgZCAhPT0gLTEpIHtcclxuXHRcdFx0bGV0IGNhbGxiYWNrID0gY29uZmlnW2lzT3ZlciA/IFwiZGF0YV9vbm92ZXJcIiA6IFwiZGF0YV9vbm91dFwiXS5iaW5kKCQkLmFwaSk7XHJcblxyXG5cdFx0XHRjb25maWcuY29sb3Jfb25vdmVyICYmICQkLnNldE92ZXJDb2xvcihpc092ZXIsIGQsIGlzQXJjKTtcclxuXHJcblx0XHRcdGlmIChpc0FyYykge1xyXG5cdFx0XHRcdGNhbGxiYWNrKGQsIG1haW4uc2VsZWN0KGAuJHtDTEFTUy5hcmN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKS5ub2RlKCkpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgY2FsbGVlID0gJCQuc2V0T3Zlck91dDtcclxuXHRcdFx0XHRsZXQgbGFzdCA9IGNhbGxlZS5sYXN0IHx8IFtdO1xyXG5cclxuXHRcdFx0XHRjb25zdCBzaGFwZSA9IG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtkfWApXHJcblx0XHRcdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmlzV2l0aGluU2hhcGUodGhpcywgZCk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0c2hhcGVcclxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0aWYgKGxhc3QubGVuZ3RoID09PSAwIHx8IGxhc3QuZXZlcnkodiA9PiB2ICE9PSB0aGlzKSkge1xyXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGQsIHRoaXMpO1xyXG5cdFx0XHRcdFx0XHRcdGxhc3QucHVzaCh0aGlzKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChsYXN0Lmxlbmd0aCA+IDAgJiYgc2hhcGUuZW1wdHkoKSkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBjb25maWcuZGF0YV9vbm91dC5iaW5kKCQkLmFwaSk7XHJcblxyXG5cdFx0XHRcdFx0bGFzdC5mb3JFYWNoKHYgPT4gY2FsbGJhY2soZDNTZWxlY3QodikuZGF0dW0oKSwgdikpO1xyXG5cdFx0XHRcdFx0bGFzdCA9IFtdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y2FsbGVlLmxhc3QgPSBsYXN0O1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlzT3ZlciAmJiAkJC5leHBhbmRDaXJjbGVzQmFycyhkLCBudWxsLCB0cnVlKTtcclxuXHJcblx0XHRcdFx0ISQkLmlzTXVsdGlwbGVYKCkgJiYgbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2R9YClcclxuXHRcdFx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZCwgdGhpcyk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGwgZGF0YS5vbm92ZXIvb3V0IGNhbGxiYWNrIGZvciB0b3VjaCBldmVudFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gZCB0YXJnZXQgaW5kZXggb3IgZGF0YSBvYmplY3QgZm9yIEFyYyB0eXBlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjYWxsT3Zlck91dEZvclRvdWNoKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGNhbGxlZSA9ICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2g7XHJcblx0XHRjb25zdCBsYXN0ID0gY2FsbGVlLmxhc3Q7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KGQpICYmIGxhc3QgPyBkLmlkICE9PSBsYXN0LmlkIDogKGQgIT09IGxhc3QpKSB7XHJcblx0XHRcdChsYXN0IHx8IGlzTnVtYmVyKGxhc3QpKSAmJiAkJC5zZXRPdmVyT3V0KGZhbHNlLCBsYXN0KTtcclxuXHRcdFx0KGQgfHwgaXNOdW1iZXIoZCkpICYmICQkLnNldE92ZXJPdXQodHJ1ZSwgZCk7XHJcblxyXG5cdFx0XHRjYWxsZWUubGFzdCA9IGQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJuIGRyYWdnYWJsZSBzZWxlY3Rpb24gZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldERyYWdnYWJsZVNlbGVjdGlvbigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9kcmFnZ2FibGUgJiYgJCQuZHJhZyA/XHJcblx0XHRcdGQzRHJhZygpXHJcblx0XHRcdFx0Lm9uKFwiZHJhZ1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRcdCQkLmRyYWcoZDNNb3VzZSh0aGlzKSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJzdGFydFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0XHRcdCQkLmRyYWdzdGFydChkM01vdXNlKHRoaXMpKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcImVuZFwiLCAoKSA9PiB7ICQkLmRyYWdlbmQoKTsgfSkgOiAoKSA9PiB7fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgZXZlbnRSZWN0IGZvciBlYWNoIGRhdGEgb24gdGhlIHgtYXhpcy5cclxuXHQgKiBSZWdpc3RlciB0b3VjaCBhbmQgZHJhZyBldmVudHMuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBkMy5zZWxlY3QoQ0xBU1MuZXZlbnRSZWN0cykgb2JqZWN0LlxyXG5cdCAqL1xyXG5cdGdlbmVyYXRlRXZlbnRSZWN0c0ZvclNpbmdsZVgoZXZlbnRSZWN0RW50ZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHJlY3QgPSBldmVudFJlY3RFbnRlci5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NFdmVudC5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiY3Vyc29yXCIsIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9ncm91cGVkID8gXCJwb2ludGVyXCIgOiBudWxsKVxyXG5cdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yU2luZ2xlWC5iaW5kKHRoaXMpKGQsICQkKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNhbGwoJCQuZ2V0RHJhZ2dhYmxlU2VsZWN0aW9uKCkpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pbnB1dFR5cGUgPT09IFwibW91c2VcIikge1xyXG5cdFx0XHRyZWN0XHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGQgPT4ge1xyXG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZyB3aGlsZSBkcmFnZ2luZy9mbG93aW5nXHJcblx0XHRcdFx0XHRpZiAoc3RhdGUuZHJhZ2dpbmcgfHwgc3RhdGUuZmxvd2luZyB8fCAkJC5oYXNBcmNUeXBlKCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbmZpZy50b29sdGlwX2dyb3VwZWQgJiYgJCQuc2V0T3Zlck91dCh0cnVlLCBkLmluZGV4KTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlbW92ZVwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nIHdoaWxlIGRyYWdnaW5nL2Zsb3dpbmdcclxuXHRcdFx0XHRcdGlmIChzdGF0ZS5kcmFnZ2luZyB8fCBzdGF0ZS5mbG93aW5nIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IGluZGV4ID0gZC5pbmRleDtcclxuXHRcdFx0XHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLiRlbC5zdmcuc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3R9LSR7aW5kZXh9YCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCQkLmlzU3RlcFR5cGUoZCkgJiZcclxuXHRcdFx0XHRcdFx0Y29uZmlnLmxpbmVfc3RlcF90eXBlID09PSBcInN0ZXAtYWZ0ZXJcIiAmJlxyXG5cdFx0XHRcdFx0XHRkM01vdXNlKHRoaXMpWzBdIDwgJCQuc2NhbGUueCgkJC5nZXRYVmFsdWUoZC5pZCwgaW5kZXgpKVxyXG5cdFx0XHRcdFx0KSB7XHJcblx0XHRcdFx0XHRcdGluZGV4IC09IDE7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aW5kZXggPT09IC0xID9cclxuXHRcdFx0XHRcdFx0JCQudW5zZWxlY3RSZWN0KCkgOiAkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKHRoaXMsIGV2ZW50UmVjdCwgaW5kZXgpO1xyXG5cclxuXHRcdFx0XHRcdC8vIEFzIG9mIGluZGl2aWR1YWwgZGF0YSBwb2ludChvciA8cGF0aD4pIGVsZW1lbnQgY2FuJ3QgYmluZCBtb3VzZW92ZXIvb3V0IGV2ZW50XHJcblx0XHRcdFx0XHQvLyB0byBkZXRlcm1pbmUgY3VycmVudCBpbnRlcmFjdGluZyBlbGVtZW50LCBzbyB1c2UgJ21vdXNlbW92ZScgZXZlbnQgaW5zdGVhZC5cclxuXHRcdFx0XHRcdGlmICghY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0XHQkJC5zZXRPdmVyT3V0KGluZGV4ICE9PSAtMSwgZC5pbmRleCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcclxuXHRcdFx0XHRcdC8vIGNoYXJ0IGlzIGRlc3Ryb3llZFxyXG5cdFx0XHRcdFx0aWYgKCFjb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQoZmFsc2UsIGQuaW5kZXgpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH0sXHJcblxyXG5cdGNsaWNrSGFuZGxlckZvclNpbmdsZVgoZCwgY3R4KSB7XHJcblx0XHRjb25zdCAkJCA9IGN0eDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNBcmNUeXBlKCkgfHwgISQkLnRvZ2dsZVNoYXBlIHx8IHN0YXRlLmNhbmNlbENsaWNrKSB7XHJcblx0XHRcdHN0YXRlLmNhbmNlbENsaWNrICYmIChzdGF0ZS5jYW5jZWxDbGljayA9IGZhbHNlKTtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpbmRleCA9IGQuaW5kZXg7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtpbmRleH1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkMikge1xyXG5cdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAkJC5pc1dpdGhpblNoYXBlKHRoaXMsIGQyKSkge1xyXG5cdFx0XHRcdFx0JCQudG9nZ2xlU2hhcGUodGhpcywgZDIsIGluZGV4KTtcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGQyLCB0aGlzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhbiBldmVudFJlY3QsXHJcblx0ICogUmVnaXN0ZXIgdG91Y2ggYW5kIGRyYWcgZXZlbnRzLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGQzLnNlbGVjdChDTEFTUy5ldmVudFJlY3RzKSBvYmplY3QuXHJcblx0ICogQHJldHVybnMge09iamVjdH0gZDMuc2VsZWN0KENMQVNTLmV2ZW50UmVjdHMpIG9iamVjdC5cclxuXHQgKi9cclxuXHRnZW5lcmF0ZUV2ZW50UmVjdHNGb3JNdWx0aXBsZVhzKGV2ZW50UmVjdEVudGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodCwgaW5wdXRUeXBlfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdGNvbnN0IHJlY3QgPSBldmVudFJlY3RFbnRlclxyXG5cdFx0XHQuYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgMClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIDApXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5ldmVudFJlY3QpXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvck11bHRpcGxlWFMuYmluZCh0aGlzKSgkJCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYWxsKCQkLmdldERyYWdnYWJsZVNlbGVjdGlvbigpKTtcclxuXHJcblx0XHRpZiAoaW5wdXRUeXBlID09PSBcIm1vdXNlXCIpIHtcclxuXHRcdFx0cmVjdFxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3ZlciBtb3VzZW1vdmVcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yTXVsdGlwbGVYcyh0aGlzKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsICgpID0+IHtcclxuXHRcdFx0XHRcdC8vIGNoYXJ0IGlzIGRlc3Ryb3llZFxyXG5cdFx0XHRcdFx0aWYgKCEkJC5jb25maWcgfHwgJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQkJC51bnNlbGVjdFJlY3QoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVjdDtcclxuXHR9LFxyXG5cclxuXHRjbGlja0hhbmRsZXJGb3JNdWx0aXBsZVhTKGN0eCkge1xyXG5cdFx0Y29uc3QgJCQgPSBjdHg7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0c1RvU2hvdyA9ICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSh0YXJnZXRzVG9TaG93KSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKHRoaXMpO1xyXG5cdFx0Y29uc3QgY2xvc2VzdCA9ICQkLmZpbmRDbG9zZXN0RnJvbVRhcmdldHModGFyZ2V0c1RvU2hvdywgbW91c2UpO1xyXG5cclxuXHRcdGlmICghY2xvc2VzdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2VsZWN0IGlmIHNlbGVjdGlvbiBlbmFibGVkXHJcblx0XHRpZiAoJCQuaXNCYXJUeXBlKGNsb3Nlc3QuaWQpIHx8ICQkLmRpc3QoY2xvc2VzdCwgbW91c2UpIDwgY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KSB7XHJcblx0XHRcdCQkLiRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoY2xvc2VzdC5pZCl9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX0tJHtjbG9zZXN0LmluZGV4fWApXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRpZiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgJCQuaXNXaXRoaW5TaGFwZSh0aGlzLCBjbG9zZXN0KSkge1xyXG5cdFx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSh0aGlzLCBjbG9zZXN0LCBjbG9zZXN0LmluZGV4KTtcclxuXHRcdFx0XHRcdFx0Y29uZmlnLmRhdGFfb25jbGljay5jYWxsKCQkLmFwaSwgY2xvc2VzdCwgdGhpcyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogRGlzcGF0Y2ggYSBtb3VzZSBldmVudC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIGV2ZW50IHR5cGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaW5kZXggSW5kZXggb2YgZXZlbnRSZWN0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gbW91c2UgeCBhbmQgeSBjb29yZGluYXRlIHZhbHVlXHJcblx0ICovXHJcblx0ZGlzcGF0Y2hFdmVudCh0eXBlLCBpbmRleCwgbW91c2UpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzTXVsdGlwbGVYID0gJCQuaXNNdWx0aXBsZVgoKTtcclxuXHRcdGNvbnN0IHNlbGVjdG9yID0gYC4ke2lzTXVsdGlwbGVYID8gQ0xBU1MuZXZlbnRSZWN0IDogYCR7Q0xBU1MuZXZlbnRSZWN0fS0ke2luZGV4fWB9YDtcclxuXHRcdGNvbnN0IGV2ZW50UmVjdCA9ICQkLiRlbC5tYWluLnNlbGVjdChzZWxlY3Rvcikubm9kZSgpO1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBsZWZ0LCB0b3B9ID0gZXZlbnRSZWN0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cdFx0Y29uc3QgeCA9IGxlZnQgKyAobW91c2UgPyBtb3VzZVswXSA6IDApICsgKFxyXG5cdFx0XHRpc011bHRpcGxlWCB8fCAkJC5jb25maWcuYXhpc19yb3RhdGVkID8gMCA6ICh3aWR0aCAvIDIpXHJcblx0XHQpO1xyXG5cdFx0Y29uc3QgeSA9IHRvcCArIChtb3VzZSA/IG1vdXNlWzFdIDogMCk7XHJcblx0XHRjb25zdCBwYXJhbXMgPSB7XHJcblx0XHRcdHNjcmVlblg6IHgsXHJcblx0XHRcdHNjcmVlblk6IHksXHJcblx0XHRcdGNsaWVudFg6IHgsXHJcblx0XHRcdGNsaWVudFk6IHlcclxuXHRcdH07XHJcblxyXG5cdFx0ZW11bGF0ZUV2ZW50Wy9eKG1vdXNlfGNsaWNrKS8udGVzdCh0eXBlKSA/IFwibW91c2VcIiA6IFwidG91Y2hcIl0oZXZlbnRSZWN0LCB0eXBlLCBwYXJhbXMpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge1xyXG5cdGJydXNoWCBhcyBkM0JydXNoWCxcclxuXHRicnVzaFkgYXMgZDNCcnVzaFksXHJcblx0YnJ1c2hTZWxlY3Rpb24gYXMgZDNCcnVzaFNlbGVjdGlvblxyXG59IGZyb20gXCJkMy1icnVzaFwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7YnJ1c2hFbXB0eSwgY2FwaXRhbGl6ZSwgaXNBcnJheSwgaXNGdW5jdGlvbiwgZ2V0UmFuZG9tfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSBicnVzaC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRCcnVzaCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBzZXQgdGhlIGJydXNoXHJcblx0XHQkJC5icnVzaCA9IGlzUm90YXRlZCA/IGQzQnJ1c2hZKCkgOiBkM0JydXNoWCgpO1xyXG5cclxuXHRcdC8vIHNldCBcImJydXNoXCIgZXZlbnRcclxuXHRcdGNvbnN0IGJydXNoSGFuZGxlciA9ICgpID0+IHtcclxuXHRcdFx0JCQucmVkcmF3Rm9yQnJ1c2goKTtcclxuXHRcdH07XHJcblx0XHRjb25zdCBnZXRCcnVzaFNpemUgPSAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IGJydXNoID0gJCQuJGVsLnN2Zy5zZWxlY3QoYC4ke0NMQVNTLmJydXNofSAub3ZlcmxheWApO1xyXG5cdFx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG5cdFx0XHRpZiAoYnJ1c2guc2l6ZSgpKSB7XHJcblx0XHRcdFx0YnJ1c2hTaXplLndpZHRoID0gK2JydXNoLmF0dHIoXCJ3aWR0aFwiKTtcclxuXHRcdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBicnVzaFNpemVbaXNSb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl07XHJcblx0XHR9O1xyXG5cclxuXHRcdGxldCBsYXN0RG9tYWluO1xyXG5cdFx0bGV0IHRpbWVvdXQ7XHJcblxyXG5cdFx0JCQuYnJ1c2hcclxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgKCkgPT4ge1xyXG5cdFx0XHRcdCQkLnN0YXRlLmlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiICYmICQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHRcdFx0YnJ1c2hIYW5kbGVyKCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImJydXNoXCIsIGJydXNoSGFuZGxlcilcclxuXHRcdFx0Lm9uKFwiZW5kXCIsICgpID0+IHtcclxuXHRcdFx0XHRsYXN0RG9tYWluID0gc2NhbGUueC5vcmdEb21haW4oKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0JCQuYnJ1c2gudXBkYXRlUmVzaXplID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG5cdFx0XHR0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRcdFx0bGFzdERvbWFpbiAmJiBkM0JydXNoU2VsZWN0aW9uKHNlbGVjdGlvbi5ub2RlKCkpICYmXHJcblx0XHRcdFx0XHR0aGlzLm1vdmUoc2VsZWN0aW9uLCBsYXN0RG9tYWluLm1hcChzY2FsZS5zdWJYLm9yZ1NjYWxlKCkpKTtcclxuXHRcdFx0fSwgMCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLmJydXNoLnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBleHRlbnQgPSB0aGlzLmV4dGVudCgpKCk7XHJcblxyXG5cdFx0XHRpZiAoZXh0ZW50WzFdLmZpbHRlcih2ID0+IGlzTmFOKHYpKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHQkJC5jb250ZXh0ICYmICQkLmNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5icnVzaH1gKS5jYWxsKHRoaXMpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gc2V0IHRoZSBicnVzaCBleHRlbnRcclxuXHRcdCQkLmJydXNoLnNjYWxlID0gZnVuY3Rpb24oc2NhbGUpIHtcclxuXHRcdFx0Y29uc3QgaCA9IGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCB8fCBnZXRCcnVzaFNpemUoKTtcclxuXHRcdFx0bGV0IGV4dGVudCA9ICQkLmdldEV4dGVudCgpO1xyXG5cclxuXHRcdFx0aWYgKCFleHRlbnQgJiYgc2NhbGUucmFuZ2UpIHtcclxuXHRcdFx0XHRleHRlbnQgPSBbWzAsIDBdLCBbc2NhbGUucmFuZ2UoKVsxXSwgaF1dO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzQXJyYXkoZXh0ZW50KSkge1xyXG5cdFx0XHRcdGV4dGVudCA9IGV4dGVudC5tYXAoKHYsIGkpID0+IFt2LCBpID4gMCA/IGggOiBpXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFtbeDAsIHkwXSwgW3gxLCB5MV1dLCB3aGVyZSBbeDAsIHkwXSBpcyB0aGUgdG9wLWxlZnQgY29ybmVyIGFuZCBbeDEsIHkxXSBpcyB0aGUgYm90dG9tLXJpZ2h0IGNvcm5lclxyXG5cdFx0XHRpc1JvdGF0ZWQgJiYgZXh0ZW50WzFdLnJldmVyc2UoKTtcclxuXHRcdFx0dGhpcy5leHRlbnQoZXh0ZW50KTtcclxuXHJcblx0XHRcdC8vIHdoZW4gZXh0ZW50IHVwZGF0ZXMsIGJydXNoIHNlbGVjdGlvbiBhbHNvIGJlIHJlLWFwcGxpZWRcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzL2lzc3Vlcy8yOTE4XHJcblx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLmJydXNoLmdldFNlbGVjdGlvbiA9ICgpID0+IChcclxuXHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHQkJC5jb250ZXh0ID8gJCQuY29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmJydXNofWApIDogZDNTZWxlY3QoW10pXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIHN1YmNoYXJ0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFN1YmNoYXJ0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjbGlwfSwgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgdmlzaWJpbGl0eSA9IGNvbmZpZy5zdWJjaGFydF9zaG93ID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiO1xyXG5cdFx0Y29uc3QgY2xpcElkID0gYCR7Y2xpcC5pZH0tc3ViY2hhcnRgO1xyXG5cdFx0Y29uc3QgY2xpcFBhdGggPSAkJC5nZXRDbGlwUGF0aChjbGlwSWQpO1xyXG5cclxuXHRcdGNsaXAuaWRTdWJjaGFydCA9IGNsaXBJZDtcclxuXHRcdCQkLmFwcGVuZENsaXAoJGVsLmRlZnMsIGNsaXBJZCk7XHJcblx0XHQkJC5pbml0QnJ1c2goKTtcclxuXHJcblx0XHQkJC5jb250ZXh0ID0gJGVsLnN2Zy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XHJcblxyXG5cdFx0Y29uc3QgY29udGV4dCA9ICQkLmNvbnRleHQ7XHJcblxyXG5cdFx0Y29udGV4dC5zdHlsZShcInZpc2liaWxpdHlcIiwgdmlzaWJpbGl0eSk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcclxuXHRcdGNvbnRleHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjbGlwUGF0aClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydCk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGJhciBjaGFydCBhcmVhXHJcblx0XHQkJC5oYXNUeXBlKFwiYmFyXCIpICYmIGNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0QmFycyk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGxpbmUgY2hhcnQgYXJlYVxyXG5cdFx0Y29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApXHJcblx0XHRcdC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRMaW5lcyk7XHJcblxyXG5cdFx0Ly8gQWRkIGV4dGVudCByZWN0IGZvciBCcnVzaFxyXG5cdFx0Y29udGV4dC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXBQYXRoKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmJydXNoKVxyXG5cdFx0XHQuY2FsbCgkJC5icnVzaCk7XHJcblxyXG5cdFx0Ly8gQVRURU5USU9OOiBUaGlzIG11c3QgYmUgY2FsbGVkIEFGVEVSIGNoYXJ0IGFkZGVkXHJcblx0XHQvLyBBZGQgQXhpc1xyXG5cdFx0JGVsLmF4aXMuc3ViWCA9IGNvbnRleHQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmF4aXNYKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJzdWJYXCIpKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBjb25maWcuYXhpc19yb3RhdGVkID8gXCJcIiA6IGNsaXAucGF0aFhBeGlzKVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5zdWJjaGFydF9heGlzX3hfc2hvdyA/IHZpc2liaWxpdHkgOiBcImhpZGRlblwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgc3ViIGNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gJCQuZGF0YS50YXJnZXRzXHJcblx0ICovXHJcblx0dXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIGNvbnRleHQsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydEJhciA9ICQkLmNsYXNzQ2hhcnRCYXIuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0JhcnMgPSAkJC5jbGFzc0JhcnMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0TGluZSA9ICQkLmNsYXNzQ2hhcnRMaW5lLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NMaW5lcyA9ICQkLmNsYXNzTGluZXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0FyZWFzID0gJCQuY2xhc3NBcmVhcy5iaW5kKCQkKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcclxuXHRcdFx0Ly8gLS0gQmFyIC0tLy9cclxuXHRcdFx0Y29uc3QgY29udGV4dEJhclVwZGF0ZSA9IGNvbnRleHQuc2VsZWN0KGAuJHtDTEFTUy5jaGFydEJhcnN9YClcclxuXHRcdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEJhcn1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0QmFyKTtcclxuXHRcdFx0Y29uc3QgY29udGV4dEJhckVudGVyID0gY29udGV4dEJhclVwZGF0ZS5lbnRlcigpXHJcblx0XHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydEJhcilcclxuXHRcdFx0XHQubWVyZ2UoY29udGV4dEJhclVwZGF0ZSk7XHJcblxyXG5cdFx0XHQvLyBCYXJzIGZvciBlYWNoIGRhdGFcclxuXHRcdFx0Y29udGV4dEJhckVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQmFycyk7XHJcblxyXG5cdFx0XHQvLyAtLSBMaW5lIC0tLy9cclxuXHRcdFx0Y29uc3QgY29udGV4dExpbmVVcGRhdGUgPSBjb250ZXh0LnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRMaW5lc31gKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0TGluZX1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0NoYXJ0TGluZSk7XHJcblx0XHRcdGNvbnN0IGNvbnRleHRMaW5lRW50ZXIgPSBjb250ZXh0TGluZVVwZGF0ZS5lbnRlcigpLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXHJcblx0XHRcdFx0Lm1lcmdlKGNvbnRleHRMaW5lVXBkYXRlKTtcclxuXHJcblx0XHRcdC8vIExpbmVzIGZvciBlYWNoIGRhdGFcclxuXHRcdFx0Y29udGV4dExpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcclxuXHJcblx0XHRcdC8vIEFyZWFcclxuXHRcdFx0JCQuaGFzVHlwZShcImFyZWFcIikgJiYgY29udGV4dExpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0FyZWFzKTtcclxuXHJcblx0XHRcdC8vIC0tIEJydXNoIC0tLy9cclxuXHRcdFx0Y29udGV4dC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJydXNofSByZWN0YClcclxuXHRcdFx0XHQuYXR0cihjb25maWcuYXhpc19yb3RhdGVkID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIiwgY29uZmlnLmF4aXNfcm90YXRlZCA/IHN0YXRlLndpZHRoMiA6IHN0YXRlLmhlaWdodDIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgYmFyIG9mIHRoZSBzdWIgY2hhcnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkdXJhdGlvbkZvckV4aXRcclxuXHQgKi9cclxuXHR1cGRhdGVCYXJGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5jb250ZXh0QmFyID0gJCQuY29udGV4dC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9YClcclxuXHRcdFx0LmRhdGEoJCQuYmFyRGF0YS5iaW5kKCQkKSk7XHJcblxyXG5cdFx0JCQuY29udGV4dEJhclxyXG5cdFx0XHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdCQkLmNvbnRleHRCYXIgPSAkJC5jb250ZXh0QmFyXHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NCYXIuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCBcIm5vbmVcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKCQkLmNvbnRleHRCYXIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aGUgYmFyIG9mIHRoZSBzdWJjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGggaW4gc3ViY2hhcnQgYmFyXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uLlxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICovXHJcblx0cmVkcmF3QmFyRm9yU3ViY2hhcnQoZHJhd0Jhck9uU3ViLCB3aXRoVHJhbnNpdGlvbiwgZHVyYXRpb24pIHtcclxuXHRcdGNvbnN0IGNvbnRleHRCYXIgPSB3aXRoVHJhbnNpdGlvbiA/XHJcblx0XHRcdHRoaXMuY29udGV4dEJhci50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOlxyXG5cdFx0XHR0aGlzLmNvbnRleHRCYXI7XHJcblxyXG5cdFx0Y29udGV4dEJhci5hdHRyKFwiZFwiLCBkcmF3QmFyT25TdWIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgbGluZSBvZiB0aGUgc3ViIGNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxpbmVGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5jb250ZXh0TGluZSA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkJC5jb250ZXh0TGluZVxyXG5cdFx0XHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdCQkLmNvbnRleHRMaW5lID0gJCQuY29udGV4dExpbmVcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0xpbmUuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInN0cm9rZVwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKCQkLmNvbnRleHRMaW5lKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGhlIGxpbmUgb2YgdGhlIHN1YmNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBpbiBzdWJjaGFydCBsaW5lXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byB0cmFuc2l0aW9uXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHRyZWRyYXdMaW5lRm9yU3ViY2hhcnQoZHJhd0xpbmVPblN1Yiwgd2l0aFRyYW5zaXRpb24sIGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCBjb250ZXh0TGluZSA9IHdpdGhUcmFuc2l0aW9uID9cclxuXHRcdFx0dGhpcy5jb250ZXh0TGluZS50cmFuc2l0aW9uKGdldFJhbmRvbSgpKS5kdXJhdGlvbihkdXJhdGlvbikgOlxyXG5cdFx0XHR0aGlzLmNvbnRleHRMaW5lO1xyXG5cclxuXHRcdGNvbnRleHRMaW5lLmF0dHIoXCJkXCIsIGRyYXdMaW5lT25TdWIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgYXJlYSBvZiB0aGUgc3ViIGNoYXJ0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gRmFkZS1vdXQgdHJhbnNpdGlvbiBkdXJhdGlvblxyXG5cdCAqL1xyXG5cdHVwZGF0ZUFyZWFGb3JTdWJjaGFydChkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5jb250ZXh0QXJlYSA9ICQkLmNvbnRleHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkJC5jb250ZXh0QXJlYVxyXG5cdFx0XHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdCQkLmNvbnRleHRBcmVhID0gJCQuY29udGV4dEFyZWFcclxuXHRcdFx0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAkJC5jbGFzc0FyZWEuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0JCQuc3RhdGUub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XHJcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2UoJCQuY29udGV4dEFyZWEpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cdH0sXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHRoZSBhcmVhIG9mIHRoZSBzdWJjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHBhdGggaW4gc3ViY2hhcnQgbGluZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvblxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSB0cmFuc2l0aW9uIGR1cmF0aW9uXHJcblx0ICovXHJcblx0cmVkcmF3QXJlYUZvclN1YmNoYXJ0KGRyYXdBcmVhT25TdWIsIHdpdGhUcmFuc2l0aW9uLCBkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgY29udGV4dEFyZWEgPSB3aXRoVHJhbnNpdGlvbiA/XHJcblx0XHRcdHRoaXMuY29udGV4dEFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkuZHVyYXRpb24oZHVyYXRpb24pIDpcclxuXHRcdFx0dGhpcy5jb250ZXh0QXJlYTtcclxuXHJcblx0XHRjb250ZXh0QXJlYS5hdHRyKFwiZFwiLCBkcmF3QXJlYU9uU3ViKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsXCIsIHRoaXMuY29sb3IpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgdGhpcy5zdGF0ZS5vcmdBcmVhT3BhY2l0eSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IHN1YmNoYXJ0LlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aXRoU3ViY2hhcnQgd2hldGhlciBvciBub3QgdG8gc2hvdyBzdWJjaGFydFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvbiBkdXJhdGlvblxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzaGFwZSBTaGFwZSdzIGluZm9cclxuXHQgKi9cclxuXHRyZWRyYXdTdWJjaGFydCh3aXRoU3ViY2hhcnQsIGR1cmF0aW9uLCBzaGFwZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHQkJC5jb250ZXh0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBjb25maWcuc3ViY2hhcnRfc2hvdyA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIik7XHJcblxyXG5cdFx0Ly8gc3ViY2hhcnRcclxuXHRcdGlmIChjb25maWcuc3ViY2hhcnRfc2hvdykge1xyXG5cdFx0XHQvLyByZWZsZWN0IG1haW4gY2hhcnQgdG8gZXh0ZW50IG9uIHN1YmNoYXJ0IGlmIHpvb21lZFxyXG5cdFx0XHRpZiAoZDNFdmVudCAmJiBkM0V2ZW50LnR5cGUgPT09IFwiem9vbVwiKSB7XHJcblx0XHRcdFx0JCQuYnJ1c2gudXBkYXRlKCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHVwZGF0ZSBzdWJjaGFydCBlbGVtZW50cyBpZiBuZWVkZWRcclxuXHRcdFx0aWYgKHdpdGhTdWJjaGFydCkge1xyXG5cdFx0XHRcdC8vIGV4dGVudCByZWN0XHJcblx0XHRcdFx0IWJydXNoRW1wdHkoJCQpICYmICQkLmJydXNoLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0XHRPYmplY3Qua2V5cyhzaGFwZS50eXBlKS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IGNhcGl0YWxpemUodik7XHJcblx0XHRcdFx0XHRjb25zdCBkcmF3ID0gJCRbYGdlbmVyYXRlRHJhdyR7bmFtZX1gXShzaGFwZS5pbmRpY2VzW3ZdLCB0cnVlKTtcclxuXHJcblx0XHRcdFx0XHQkJFtgdXBkYXRlJHtuYW1lfUZvclN1YmNoYXJ0YF0oZHVyYXRpb24pO1xyXG5cdFx0XHRcdFx0JCRbYHJlZHJhdyR7bmFtZX1Gb3JTdWJjaGFydGBdKGRyYXcsIGR1cmF0aW9uLCBkdXJhdGlvbik7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZWRyYXcgdGhlIGJydXNoLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3Rm9yQnJ1c2goKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnOiB7c3ViY2hhcnRfb25icnVzaCwgem9vbV9yZXNjYWxlOiB3aXRoWX19ID0gJCQ7XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoWSxcclxuXHRcdFx0d2l0aFN1YmNoYXJ0OiBmYWxzZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhEaW1lbnNpb246IGZhbHNlXHJcblx0XHR9KTtcclxuXHJcblx0XHRzdWJjaGFydF9vbmJydXNoLmNhbGwoJCQuYXBpLCAkJC5zY2FsZS54Lm9yZ0RvbWFpbigpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm0gY29udGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpbmRpY2F0ZXMgdHJhbnNpdGlvbiBpcyBlbmFibGVkXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGdlbmVyYXRlVHJhbnNpdGlvbnMgbWV0aG9kIG9mIEF4aXMuXHJcblx0ICovXHJcblx0dHJhbnNmb3JtQ29udGV4dCh3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCBzdWJYQXhpcztcclxuXHJcblx0XHRpZiAodHJhbnNpdGlvbnMgJiYgdHJhbnNpdGlvbnMuYXhpc1N1YlgpIHtcclxuXHRcdFx0c3ViWEF4aXMgPSB0cmFuc2l0aW9ucy5heGlzU3ViWDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHN1YlhBeGlzID0gJCQuY29udGV4dC5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApO1xyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHsgc3ViWEF4aXMgPSBzdWJYQXhpcy50cmFuc2l0aW9uKCk7IH1cclxuXHRcdH1cclxuXHJcblx0XHQkJC5jb250ZXh0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwiY29udGV4dFwiKSk7XHJcblx0XHRzdWJYQXhpcy5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcInN1YlhcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBleHRlbnQgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gZGVmYXVsdCBleHRlbnRcclxuXHQgKi9cclxuXHRnZXRFeHRlbnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c2NhbGV9ID0gJCQ7XHJcblx0XHRsZXQgZXh0ZW50ID0gJCQuY29uZmlnLmF4aXNfeF9leHRlbnQ7XHJcblxyXG5cdFx0aWYgKGV4dGVudCkge1xyXG5cdFx0XHRpZiAoaXNGdW5jdGlvbihleHRlbnQpKSB7XHJcblx0XHRcdFx0ZXh0ZW50ID0gZXh0ZW50KCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSwgc2NhbGUuc3ViWCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoJCQuaXNUaW1lU2VyaWVzKCkgJiYgZXh0ZW50LmV2ZXJ5KGlzTmFOKSkge1xyXG5cdFx0XHRcdGV4dGVudCA9IGV4dGVudC5tYXAodiA9PiBzY2FsZS5zdWJYKCQkLnBhcnNlRGF0ZSh2KSkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV4dGVudDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRtb3VzZSBhcyBkM01vdXNlLFxyXG5cdGV2ZW50IGFzIGQzRXZlbnQsXHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge2RyYWcgYXMgZDNEcmFnfSBmcm9tIFwiZDMtZHJhZ1wiO1xyXG5pbXBvcnQge3pvb20gYXMgZDNab29tfSBmcm9tIFwiZDMtem9vbVwiO1xyXG5pbXBvcnQge2RvY3VtZW50fSBmcm9tIFwiLi4vLi4vbW9kdWxlL2Jyb3dzZXJcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbiwgZGlmZkRvbWFpbiwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIGlzRnVuY3Rpb259IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgem9vbS5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRab29tKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLnNjYWxlLnpvb20gPSBudWxsO1xyXG5cclxuXHRcdCQkLmdlbmVyYXRlWm9vbSgpO1xyXG5cdFx0JCQuaW5pdFpvb21CZWhhdmlvdXIoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBCaW5kIHpvb20gZXZlbnRcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGJpbmQgV2VhdGhlciBiaW5kIG9yIHVuYm91bmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGJpbmRab29tRXZlbnQoYmluZCA9IHRydWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgem9vbUVuYWJsZWQgPSBjb25maWcuem9vbV9lbmFibGVkO1xyXG5cclxuXHRcdCQkLnJlZHJhd0V2ZW50UmVjdCgpO1xyXG5cclxuXHRcdGNvbnN0IGV2ZW50UmVjdHMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuZXZlbnRSZWN0c31gKTtcclxuXHJcblx0XHRpZiAoem9vbUVuYWJsZWQgJiYgYmluZCkge1xyXG5cdFx0XHQvLyBEbyBub3QgYmluZCB6b29tIGV2ZW50IHdoZW4gc3ViY2hhcnQgaXMgc2hvd25cclxuXHRcdFx0IWNvbmZpZy5zdWJjaGFydF9zaG93ICYmXHJcblx0XHRcdFx0JCQuYmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB6b29tRW5hYmxlZC50eXBlKTtcclxuXHRcdH0gZWxzZSBpZiAoYmluZCA9PT0gZmFsc2UpIHtcclxuXHRcdFx0JCQuYXBpLnVuem9vbSgpO1xyXG5cclxuXHRcdFx0ZXZlbnRSZWN0c1xyXG5cdFx0XHRcdC5vbihcIi56b29tXCIsIG51bGwpXHJcblx0XHRcdFx0Lm9uKFwiLmRyYWdcIiwgbnVsbCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgem9vbVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVab29tKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnLCBzY2FsZX0gPSAkJDtcclxuXHJcblx0XHRjb25zdCB6b29tID0gZDNab29tKCkuZHVyYXRpb24oMClcclxuXHRcdFx0Lm9uKFwic3RhcnRcIiwgJCQub25ab29tU3RhcnQuYmluZCgkJCkpXHJcblx0XHRcdC5vbihcInpvb21cIiwgJCQub25ab29tLmJpbmQoJCQpKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgJCQub25ab29tRW5kLmJpbmQoJCQpKTtcclxuXHJcblx0XHQvLyBnZXQgem9vbSBleHRlbnRcclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHpvb20ub3JnU2NhbGVFeHRlbnQgPSAoKSA9PiB7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IGNvbmZpZy56b29tX2V4dGVudCB8fCBbMSwgMTBdO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtleHRlbnRbMF0sIE1hdGgubWF4KCQkLmdldE1heERhdGFDb3VudCgpIC8gZXh0ZW50WzFdLCBleHRlbnRbMV0pXTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0em9vbS51cGRhdGVTY2FsZUV4dGVudCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCByYXRpbyA9IGRpZmZEb21haW4oJCQuc2NhbGUueC5vcmdEb21haW4oKSkgLyBkaWZmRG9tYWluKCQkLmdldFpvb21Eb21haW4oKSk7XHJcblx0XHRcdGNvbnN0IGV4dGVudCA9IHRoaXMub3JnU2NhbGVFeHRlbnQoKTtcclxuXHJcblx0XHRcdHRoaXMuc2NhbGVFeHRlbnQoW2V4dGVudFswXSAqIHJhdGlvLCBleHRlbnRbMV0gKiByYXRpb10pO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVXBkYXRlIHNjYWxlIGFjY29yZGluZyB6b29tIHRyYW5zZm9ybSB2YWx1ZVxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IHRyYW5zZm9ybVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0em9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZSA9IHRyYW5zZm9ybSA9PiB7XHJcblx0XHRcdC8vIGluIGNhc2Ugb2YgcmVzaXplLCB1cGRhdGUgcmFuZ2Ugb2Ygb3JnWFNjYWxlXHJcblx0XHRcdG9yZy54U2NhbGUgJiYgb3JnLnhTY2FsZS5yYW5nZShzY2FsZS54LnJhbmdlKCkpO1xyXG5cclxuXHRcdFx0Ly8gcmVzY2FsZSBmcm9tIHRoZSBvcmlnaW5hbCBzY2FsZVxyXG5cdFx0XHRjb25zdCBuZXdTY2FsZSA9IHRyYW5zZm9ybVtcclxuXHRcdFx0XHRjb25maWcuYXhpc19yb3RhdGVkID8gXCJyZXNjYWxlWVwiIDogXCJyZXNjYWxlWFwiXHJcblx0XHRcdF0ob3JnLnhTY2FsZSB8fCBzY2FsZS54KTtcclxuXHJcblx0XHRcdGNvbnN0IGRvbWFpbiA9ICQkLnRyaW1YRG9tYWluKG5ld1NjYWxlLmRvbWFpbigpKTtcclxuXHRcdFx0Y29uc3QgcmVzY2FsZSA9IGNvbmZpZy56b29tX3Jlc2NhbGU7XHJcblxyXG5cdFx0XHRuZXdTY2FsZS5kb21haW4oZG9tYWluLCBvcmcueERvbWFpbik7XHJcblxyXG5cdFx0XHRzY2FsZS56b29tID0gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKG5ld1NjYWxlKTtcclxuXHRcdFx0JCQuYXhpcy54LnNjYWxlKHNjYWxlLnpvb20pO1xyXG5cclxuXHRcdFx0aWYgKHJlc2NhbGUpIHtcclxuXHRcdFx0XHQvLyBjb3B5IGN1cnJlbnQgaW5pdGlhbCB4IHNjYWxlIGluIGNhc2Ugb2YgcmVzY2FsZSBvcHRpb24gaXMgdXNlZFxyXG5cdFx0XHRcdCFvcmcueFNjYWxlICYmIChvcmcueFNjYWxlID0gc2NhbGUueC5jb3B5KCkpO1xyXG5cdFx0XHRcdHNjYWxlLnguZG9tYWluKGRvbWFpbik7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0JCQuem9vbSA9IHpvb207XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogJ3N0YXJ0JyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tU3RhcnQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBldmVudCA9IGQzRXZlbnQuc291cmNlRXZlbnQ7XHJcblxyXG5cdFx0aWYgKCFldmVudCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuem9vbS5zdGFydEV2ZW50ID0gZXZlbnQ7XHJcblx0XHRjYWxsRm4oJCQuY29uZmlnLnpvb21fb256b29tc3RhcnQsICQkLmFwaSwgZXZlbnQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqICd6b29tJyBldmVudCBsaXN0ZW5lclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0b25ab29tKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGUsIG9yZ30gPSAkJDtcclxuXHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudDtcclxuXHRcdGNvbnN0IHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQ7XHJcblxyXG5cdFx0aWYgKFxyXG5cdFx0XHQhY29uZmlnLnpvb21fZW5hYmxlZCB8fFxyXG5cdFx0XHQhZXZlbnQuc291cmNlRXZlbnQgfHxcclxuXHRcdFx0JCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aCA9PT0gMCB8fFxyXG5cdFx0XHQoIXNjYWxlLnpvb20gJiYgc291cmNlRXZlbnQudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPiAtMSAmJiBzb3VyY2VFdmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSlcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaXNNb3VzZW1vdmUgPSBzb3VyY2VFdmVudC50eXBlID09PSBcIm1vdXNlbW92ZVwiO1xyXG5cdFx0Y29uc3QgaXNab29tT3V0ID0gc291cmNlRXZlbnQud2hlZWxEZWx0YSA8IDA7XHJcblx0XHRjb25zdCB0cmFuc2Zvcm0gPSBldmVudC50cmFuc2Zvcm07XHJcblxyXG5cdFx0aWYgKCFpc01vdXNlbW92ZSAmJiBpc1pvb21PdXQgJiYgc2NhbGUueC5kb21haW4oKS5ldmVyeSgodiwgaSkgPT4gdiAhPT0gb3JnLnhEb21haW5baV0pKSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKG9yZy54RG9tYWluKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC56b29tLnVwZGF0ZVRyYW5zZm9ybVNjYWxlKHRyYW5zZm9ybSk7XHJcblxyXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSAmJiBzY2FsZS54Lm9yZ0RvbWFpbigpWzBdID09PSBvcmcueERvbWFpblswXSkge1xyXG5cdFx0XHRzY2FsZS54LmRvbWFpbihbb3JnLnhEb21haW5bMF0gLSAxZS0xMCwgc2NhbGUueC5vcmdEb21haW4oKVsxXV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZSxcclxuXHRcdFx0d2l0aFk6IGNvbmZpZy56b29tX3Jlc2NhbGUsXHJcblx0XHRcdHdpdGhTdWJjaGFydDogZmFsc2UsXHJcblx0XHRcdHdpdGhFdmVudFJlY3Q6IGZhbHNlLFxyXG5cdFx0XHR3aXRoRGltZW5zaW9uOiBmYWxzZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0JCQuc3RhdGUuY2FuY2VsQ2xpY2sgPSBpc01vdXNlbW92ZTtcclxuXHRcdGNhbGxGbihjb25maWcuem9vbV9vbnpvb20sICQkLmFwaSwgc2NhbGUuem9vbS5kb21haW4oKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogJ2VuZCcgZXZlbnQgbGlzdGVuZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdG9uWm9vbUVuZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cdFx0bGV0IHN0YXJ0RXZlbnQgPSAkJC56b29tLnN0YXJ0RXZlbnQ7XHJcblx0XHRsZXQgZXZlbnQgPSBkM0V2ZW50ICYmIGQzRXZlbnQuc291cmNlRXZlbnQ7XHJcblxyXG5cdFx0aWYgKChzdGFydEV2ZW50ICYmIHN0YXJ0RXZlbnQudHlwZS5pbmRleE9mKFwidG91Y2hcIikgPiAtMSkpIHtcclxuXHRcdFx0c3RhcnRFdmVudCA9IHN0YXJ0RXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblx0XHRcdGV2ZW50ID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gaWYgY2xpY2ssIGRvIG5vdGhpbmcuIG90aGVyd2lzZSwgY2xpY2sgaW50ZXJhY3Rpb24gd2lsbCBiZSBjYW5jZWxlZC5cclxuXHRcdGlmICghc3RhcnRFdmVudCB8fFxyXG5cdFx0XHQoZXZlbnQgJiYgc3RhcnRFdmVudC5jbGllbnRYID09PSBldmVudC5jbGllbnRYICYmIHN0YXJ0RXZlbnQuY2xpZW50WSA9PT0gZXZlbnQuY2xpZW50WSlcclxuXHRcdCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JCQucmVkcmF3RXZlbnRSZWN0KCk7XHJcblx0XHQkJC51cGRhdGVab29tKCk7XHJcblxyXG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbWVuZCwgJCQuYXBpLCBzY2FsZVtzY2FsZS56b29tID8gXCJ6b29tXCIgOiBcInN1YlhcIl0uZG9tYWluKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB6b29tIGRvbWFpblxyXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gem9vbSBkb21haW5cclxuIFx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRab29tRG9tYWluKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnfSA9ICQkO1xyXG5cdFx0bGV0IFttaW4sIG1heF0gPSBvcmcueERvbWFpbjtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWluKSkge1xyXG5cdFx0XHRtaW4gPSBnZXRNaW5NYXgoXCJtaW5cIiwgW21pbiwgY29uZmlnLnpvb21feF9taW5dKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKGNvbmZpZy56b29tX3hfbWF4KSkge1xyXG5cdFx0XHRtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgW21heCwgY29uZmlnLnpvb21feF9tYXhdKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gW21pbiwgbWF4XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgem9vbVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgRm9yY2UgdW56b29tXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVab29tKGZvcmNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQge3N1YlgsIHgsIHpvb219ID0gJCQuc2NhbGU7XHJcblxyXG5cdFx0aWYgKHpvb20pIHtcclxuXHRcdFx0Y29uc3Qgem9vbURvbWFpbiA9IHpvb20uZG9tYWluKCk7XHJcblx0XHRcdGNvbnN0IHhEb21haW4gPSBzdWJYLmRvbWFpbigpO1xyXG5cdFx0XHRjb25zdCBkZWx0YSA9IDAuMDE1OyAvLyBhcmJpdHJhcnkgdmFsdWVcclxuXHJcblx0XHRcdGNvbnN0IGlzZnVsbHlTaG93biA9ICh6b29tRG9tYWluWzBdIDw9IHhEb21haW5bMF0gfHwgKHpvb21Eb21haW5bMF0gLSBkZWx0YSkgPD0geERvbWFpblswXSkgJiZcclxuXHRcdFx0XHQoeERvbWFpblsxXSA8PSB6b29tRG9tYWluWzFdIHx8IHhEb21haW5bMV0gPD0gKHpvb21Eb21haW5bMV0gLSBkZWx0YSkpO1xyXG5cclxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHpvb21lZCBjaGFydCBpcyBmdWxseSBzaG93biwgdGhlbiByZXNldCBzY2FsZSB3aGVuIHpvb20gaXMgb3V0IGFzIGluaXRpYWxcclxuXHRcdFx0aWYgKGZvcmNlIHx8IGlzZnVsbHlTaG93bikge1xyXG5cdFx0XHRcdCQkLmF4aXMueC5zY2FsZShzdWJYKTtcclxuXHRcdFx0XHR4LmRvbWFpbihzdWJYLm9yZ0RvbWFpbigpKTtcclxuXHRcdFx0XHR6b29tID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEF0dGFjaCB6b29tIGV2ZW50IG9uIDxyZWN0PlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0YmluZFpvb21PbkV2ZW50UmVjdChldmVudFJlY3RzLCB0eXBlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBiZWhhdmlvdXIgPSB0eXBlID09PSBcImRyYWdcIiA/ICQkLnpvb21CZWhhdmlvdXIgOiAkJC56b29tO1xyXG5cclxuXHRcdGV2ZW50UmVjdHNcclxuXHRcdFx0LmNhbGwoYmVoYXZpb3VyKVxyXG5cdFx0XHQub24oXCJkYmxjbGljay56b29tXCIsIG51bGwpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemUgdGhlIGRyYWcgYmVoYXZpb3VyIHVzZWQgZm9yIHpvb21pbmcuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0Wm9vbUJlaGF2aW91cigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGxldCBzdGFydCA9IDA7XHJcblx0XHRsZXQgZW5kID0gMDtcclxuXHRcdGxldCB6b29tUmVjdDtcclxuXHJcblx0XHRjb25zdCBwcm9wID0ge1xyXG5cdFx0XHRheGlzOiBpc1JvdGF0ZWQgPyBcInlcIiA6IFwieFwiLFxyXG5cdFx0XHRhdHRyOiBpc1JvdGF0ZWQgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiLFxyXG5cdFx0XHRpbmRleDogaXNSb3RhdGVkID8gMSA6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0JCQuem9vbUJlaGF2aW91ciA9IGQzRHJhZygpXHJcblx0XHRcdC5jbGlja0Rpc3RhbmNlKDQpXHJcblx0XHRcdC5vbihcInN0YXJ0XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdCQkLnNldERyYWdTdGF0dXModHJ1ZSk7XHJcblxyXG5cdFx0XHRcdGlmICghem9vbVJlY3QpIHtcclxuXHRcdFx0XHRcdHpvb21SZWN0ID0gJCQuJGVsLm1haW4uYXBwZW5kKFwicmVjdFwiKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCBzdGF0ZS5jbGlwLnBhdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbUJydXNoKVxyXG5cdFx0XHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIGlzUm90YXRlZCA/IHN0YXRlLndpZHRoIDogMClcclxuXHRcdFx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0c3RhcnQgPSBkM01vdXNlKHRoaXMpW3Byb3AuaW5kZXhdO1xyXG5cdFx0XHRcdGVuZCA9IHN0YXJ0O1xyXG5cclxuXHRcdFx0XHR6b29tUmVjdFxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5heGlzLCBzdGFydClcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgMCk7XHJcblxyXG5cdFx0XHRcdCQkLm9uWm9vbVN0YXJ0KCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbihcImRyYWdcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxyXG5cdFx0XHRcdGVuZCA9IGQzTW91c2UodGhpcylbcHJvcC5pbmRleF07XHJcblxyXG5cdFx0XHRcdHpvb21SZWN0XHJcblx0XHRcdFx0XHQuYXR0cihwcm9wLmF4aXMsIE1hdGgubWluKHN0YXJ0LCBlbmQpKVxyXG5cdFx0XHRcdFx0LmF0dHIocHJvcC5hdHRyLCBNYXRoLmFicyhlbmQgLSBzdGFydCkpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGNvbnN0IHNjYWxlID0gJCQuc2NhbGUuem9vbSB8fCAkJC5zY2FsZS54O1xyXG5cclxuXHRcdFx0XHQkJC5zZXREcmFnU3RhdHVzKGZhbHNlKTtcclxuXHJcblx0XHRcdFx0em9vbVJlY3RcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXhpcywgMClcclxuXHRcdFx0XHRcdC5hdHRyKHByb3AuYXR0ciwgMCk7XHJcblxyXG5cdFx0XHRcdGlmIChzdGFydCA+IGVuZCkge1xyXG5cdFx0XHRcdFx0W3N0YXJ0LCBlbmRdID0gW2VuZCwgc3RhcnRdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKHN0YXJ0IDwgMCkge1xyXG5cdFx0XHRcdFx0ZW5kICs9IE1hdGguYWJzKHN0YXJ0KTtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gMDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChzdGFydCAhPT0gZW5kKSB7XHJcblx0XHRcdFx0XHQkJC5hcGkuem9vbShbc3RhcnQsIGVuZF0ubWFwKHYgPT4gc2NhbGUuaW52ZXJ0KHYpKSk7XHJcblx0XHRcdFx0XHQkJC5vblpvb21FbmQoKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKCQkLmlzTXVsdGlwbGVYKCkpIHtcclxuXHRcdFx0XHRcdFx0JCQuY2xpY2tIYW5kbGVyRm9yTXVsdGlwbGVYUy5iaW5kKHRoaXMpKCQkKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGV2ZW50ID0gZDNFdmVudC5zb3VyY2VFdmVudCB8fCBkM0V2ZW50O1xyXG5cdFx0XHRcdFx0XHRjb25zdCBbeCwgeV0gPSBcImNsaWVudFhcIiBpbiBldmVudCA/IFtldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZXSA6IFtldmVudC54LCBldmVudC55XTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcclxuXHJcblx0XHRcdFx0XHRcdCQkLmNsaWNrSGFuZGxlckZvclNpbmdsZVguYmluZCh0YXJnZXQpKGQzU2VsZWN0KHRhcmdldCkuZGF0dW0oKSwgJCQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0c2V0Wm9vbVJlc2V0QnV0dG9uKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHJlc2V0QnV0dG9uID0gY29uZmlnLnpvb21fcmVzZXRCdXR0b247XHJcblxyXG5cdFx0aWYgKHJlc2V0QnV0dG9uICYmIGNvbmZpZy56b29tX2VuYWJsZWQudHlwZSA9PT0gXCJkcmFnXCIpIHtcclxuXHRcdFx0aWYgKCEkJC56b29tLnJlc2V0QnRuKSB7XHJcblx0XHRcdFx0JCQuem9vbS5yZXNldEJ0biA9ICQkLiRlbC5jaGFydC5hcHBlbmQoXCJkaXZcIilcclxuXHRcdFx0XHRcdC5jbGFzc2VkKENMQVNTLmJ1dHRvbiwgdHJ1ZSlcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJzcGFuXCIpXHJcblx0XHRcdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0aXNGdW5jdGlvbihyZXNldEJ1dHRvbi5vbmNsaWNrKSAmJiByZXNldEJ1dHRvbi5vbmNsaWNrKHRoaXMpO1xyXG5cdFx0XHRcdFx0XHQkJC5hcGkudW56b29tKCk7XHJcblx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0LmNsYXNzZWQoQ0xBU1MuYnV0dG9uWm9vbVJlc2V0LCB0cnVlKVxyXG5cdFx0XHRcdFx0LnRleHQocmVzZXRCdXR0b24udGV4dCB8fCBcIlJlc2V0IFpvb21cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0JCQuem9vbS5yZXNldEJ0bi5zdHlsZShcImRpc3BsYXlcIiwgbnVsbCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIENhdGVnb3J5IE5hbWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IGdhdGVnb3J5IE5hbWVcclxuXHQgKi9cclxuXHRjYXRlZ29yeU5hbWUoaSkge1xyXG5cdFx0Y29uc3Qge2F4aXNfeF9jYXRlZ29yaWVzOiBjYXRlZ29yaWVzfSA9IHRoaXMuY29uZmlnO1xyXG5cclxuXHRcdHJldHVybiBpIDwgY2F0ZWdvcmllcy5sZW5ndGggPyBjYXRlZ29yaWVzW2ldIDogaTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRnZW5lcmF0ZUNsYXNzKHByZWZpeCwgdGFyZ2V0SWQpIHtcclxuXHRcdHJldHVybiBgICR7cHJlZml4fSAke3ByZWZpeCArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpfWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUZXh0KGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MudGV4dCwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUZXh0cyhkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLnRleHRzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc1NoYXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGUsIGQuaW5kZXgpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzU2hhcGVzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1Muc2hhcGVzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUV4dHJhTGluZUNsYXNzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2xhc3NlcyA9ICQkLmNvbmZpZy5saW5lX2NsYXNzZXMgfHwgW107XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0Y29uc3QgaWQ6IHN0cmluZyA9IGQuaWQgfHwgKGQuZGF0YSAmJiBkLmRhdGEuaWQpIHx8IGQ7XHJcblxyXG5cdFx0XHRpZiAoaWRzLmluZGV4T2YoaWQpIDwgMCkge1xyXG5cdFx0XHRcdGlkcy5wdXNoKGlkKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGNsYXNzZXNbaWRzLmluZGV4T2YoaWQpICUgY2xhc3Nlcy5sZW5ndGhdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0xpbmUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5saW5lLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0xpbmVzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmxpbmVzLCBkLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0NpcmNsZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZSwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaXJjbGVzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGVzKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmNpcmNsZXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQmFyKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzU2hhcGUoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYmFyLCBkLmluZGV4KTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0JhcnMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYmFycywgZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NBcmMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZShkLmRhdGEpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyYywgZC5kYXRhLmlkKTtcclxuXHR9LFxyXG5cclxuXHRjbGFzc0FyY3MoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZC5kYXRhKSArIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy5hcmNzLCBkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJlYShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGFzc1NoYXBlKGQpICsgdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmFyZWEsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQXJlYXMoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xhc3NTaGFwZXMoZCkgKyB0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MuYXJlYXMsIGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzUmVnaW9uKGQsIGkpIHtcclxuXHRcdHJldHVybiBgJHt0aGlzLmdlbmVyYXRlQ2xhc3MoQ0xBU1MucmVnaW9uLCBpKX0gJHtcImNsYXNzXCIgaW4gZCA/IGQuY2xhc3MgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NFdmVudChkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZW5lcmF0ZUNsYXNzKENMQVNTLmV2ZW50UmVjdCwgZC5pbmRleCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NUYXJnZXQoaWQpIHtcclxuXHRcdGNvbnN0IGFkZGl0aW9uYWxDbGFzc1N1ZmZpeCA9IHRoaXMuY29uZmlnLmRhdGFfY2xhc3Nlc1tpZF07XHJcblx0XHRsZXQgYWRkaXRpb25hbENsYXNzID0gXCJcIjtcclxuXHJcblx0XHRpZiAoYWRkaXRpb25hbENsYXNzU3VmZml4KSB7XHJcblx0XHRcdGFkZGl0aW9uYWxDbGFzcyA9IGAgJHtDTEFTUy50YXJnZXR9LSR7YWRkaXRpb25hbENsYXNzU3VmZml4fWA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2VuZXJhdGVDbGFzcyhDTEFTUy50YXJnZXQsIGlkKSArIGFkZGl0aW9uYWxDbGFzcztcclxuXHR9LFxyXG5cclxuXHRjbGFzc0ZvY3VzKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsYXNzRm9jdXNlZChkKSArIHRoaXMuY2xhc3NEZWZvY3VzZWQoZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NGb2N1c2VkKGQpIHtcclxuXHRcdHJldHVybiBgICR7dGhpcy5zdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzLmluZGV4T2YoZC5pZCkgPj0gMCA/IENMQVNTLmZvY3VzZWQgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NEZWZvY3VzZWQoZCkge1xyXG5cdFx0cmV0dXJuIGAgJHt0aGlzLnN0YXRlLmRlZm9jdXNlZFRhcmdldElkcy5pbmRleE9mKGQuaWQpID49IDAgPyBDTEFTUy5kZWZvY3VzZWQgOiBcIlwifWA7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydFRleHQoZCkge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0VGV4dCArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydExpbmUoZCkge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0TGluZSArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Y2xhc3NDaGFydEJhcihkKSB7XHJcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRCYXIgKyB0aGlzLmNsYXNzVGFyZ2V0KGQuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRBcmMoZCkge1xyXG5cdFx0cmV0dXJuIENMQVNTLmNoYXJ0QXJjICsgdGhpcy5jbGFzc1RhcmdldChkLmRhdGEuaWQpO1xyXG5cdH0sXHJcblxyXG5cdGNsYXNzQ2hhcnRSYWRhcihkKSB7XHJcblx0XHRyZXR1cm4gQ0xBU1MuY2hhcnRSYWRhciArIHRoaXMuY2xhc3NUYXJnZXQoZC5pZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgodGFyZ2V0SWQpIHtcclxuXHRcdHJldHVybiB0YXJnZXRJZCB8fCB0YXJnZXRJZCA9PT0gMCA/XHJcblx0XHRcdGAtJHt0YXJnZXRJZH1gLnJlcGxhY2UoL1tcXHM/IUAjJCVeJiooKV89KywuPD4nXCI6O1xcW1xcXVxcL3x+YHt9XFxcXF0vZywgXCItXCIpIDogXCJcIjtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RvclRhcmdldChpZCwgcHJlZml4KSB7XHJcblx0XHRyZXR1cm4gYCR7cHJlZml4IHx8IFwiXCJ9LiR7Q0xBU1MudGFyZ2V0ICsgdGhpcy5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YDtcclxuXHR9LFxyXG5cclxuXHRzZWxlY3RvclRhcmdldHMoaWRzVmFsdWUsIHByZWZpeCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaWRzID0gaWRzVmFsdWUgfHwgW107XHJcblxyXG5cdFx0cmV0dXJuIGlkcy5sZW5ndGggP1xyXG5cdFx0XHRpZHMubWFwKGlkID0+ICQkLnNlbGVjdG9yVGFyZ2V0KGlkLCBwcmVmaXgpKSA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JMZWdlbmQoaWQpIHtcclxuXHRcdHJldHVybiBgLiR7Q0xBU1MubGVnZW5kSXRlbSArIHRoaXMuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoaWQpfWA7XHJcblx0fSxcclxuXHJcblx0c2VsZWN0b3JMZWdlbmRzKGlkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiBpZHMgJiYgaWRzLmxlbmd0aCA/XHJcblx0XHRcdGlkcy5tYXAoaWQgPT4gJCQuc2VsZWN0b3JMZWdlbmQoaWQpKSA6IG51bGw7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRDbGlwKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2xpcCA9ICQkLnN0YXRlLmNsaXA7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2xpcElkIG5lZWRzIHRvIGJlIHVuaXF1ZSBiZWNhdXNlIGl0IGNvbmZsaWN0cyB3aGVuIG11bHRpcGxlIGNoYXJ0cyBleGlzdFxyXG5cdFx0Y2xpcC5pZCA9IGAkeyQkLnN0YXRlLmRhdGV0aW1lSWR9LWNsaXBgO1xyXG5cdFx0Y2xpcC5pZFhBeGlzID0gYCR7Y2xpcC5pZH0teGF4aXNgO1xyXG5cdFx0Y2xpcC5pZFlBeGlzID0gYCR7Y2xpcC5pZH0teWF4aXNgO1xyXG5cdFx0Y2xpcC5pZEdyaWQgPSBgJHtjbGlwLmlkfS1ncmlkYDtcclxuXHJcblx0XHQvLyBEZWZpbmUgJ2NsaXAtcGF0aCcgYXR0cmlidXRlIHZhbHVlc1xyXG5cdFx0Y2xpcC5wYXRoID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcC5pZCk7XHJcblx0XHRjbGlwLnBhdGhYQXhpcyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRYQXhpcyk7XHJcblx0XHRjbGlwLnBhdGhZQXhpcyA9ICQkLmdldENsaXBQYXRoKGNsaXAuaWRZQXhpcyk7XHJcblx0XHRjbGlwLnBhdGhHcmlkID0gJCQuZ2V0Q2xpcFBhdGgoY2xpcC5pZEdyaWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldENsaXBQYXRoKGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgoIWNvbmZpZy5jbGlwUGF0aCAmJiAvLWNsaXAkLy50ZXN0KGlkKSkgfHxcclxuXHRcdFx0KCFjb25maWcuYXhpc194X2NsaXBQYXRoICYmIC8tY2xpcC14YXhpcyQvLnRlc3QoaWQpKSB8fFxyXG5cdFx0XHQoIWNvbmZpZy5heGlzX3lfY2xpcFBhdGggJiYgLy1jbGlwLXlheGlzJC8udGVzdChpZCkpKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGlzSUU5ID0gd2luZG93Lm5hdmlnYXRvciA/XHJcblx0XHRcdHdpbmRvdy5uYXZpZ2F0b3IuYXBwVmVyc2lvblxyXG5cdFx0XHRcdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJtc2llIDkuXCIpID49IDAgOiBmYWxzZTtcclxuXHJcblx0XHRyZXR1cm4gYHVybCgkeyhpc0lFOSA/IFwiXCIgOiBkb2N1bWVudC5VUkwuc3BsaXQoXCIjXCIpWzBdKX0jJHtpZH0pYDtcclxuXHR9LFxyXG5cclxuXHRhcHBlbmRDbGlwKHBhcmVudCwgaWQpIHtcclxuXHRcdHJldHVybiBwYXJlbnQuYXBwZW5kKFwiY2xpcFBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJpZFwiLCBpZClcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBYKGZvckhvcml6b250YWwpIHtcclxuXHRcdGNvbnN0IHttYXJnaW59ID0gdGhpcy5zdGF0ZTtcclxuXHRcdC8vIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnRcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID8gLSgxICsgbGVmdCkgOiAtKGxlZnQgLSAxKTtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcFkoZm9ySG9yaXpvbnRhbCkge1xyXG5cdFx0Y29uc3Qge21hcmdpbn0gPSB0aGlzLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID8gLTIwIDogLW1hcmdpbi50b3A7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwWCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBYKCEkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYQXhpc0NsaXBZKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoISQkLmNvbmZpZy5heGlzX3JvdGF0ZWQpO1xyXG5cdH0sXHJcblxyXG5cdGdldFlBeGlzQ2xpcFgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy5heGlzX3lfaW5uZXIgP1xyXG5cdFx0XHQtMSA6ICQkLmdldEF4aXNDbGlwWCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZQXhpc0NsaXBZKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcFkoJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc0NsaXBXaWR0aChmb3JIb3Jpem9udGFsKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bWFyZ2luLCB3aWR0aH0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGxlZnQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLmxlZnQpO1xyXG5cdFx0Y29uc3QgcmlnaHQgPSBNYXRoLm1heCgzMCwgbWFyZ2luLnJpZ2h0KTtcclxuXHJcblx0XHQvLyB3aWR0aCArIGF4aXMgbGluZSB3aWR0aCArIHBhZGRpbmcgZm9yIGxlZnQvcmlnaHRcclxuXHRcdHJldHVybiBmb3JIb3Jpem9udGFsID9cclxuXHRcdFx0d2lkdGggKyAyICsgbGVmdCArIHJpZ2h0IDogbWFyZ2luLmxlZnQgKyAyMDtcclxuXHR9LFxyXG5cclxuXHRnZXRBeGlzQ2xpcEhlaWdodChmb3JIb3Jpem9udGFsKSB7XHJcblx0XHRjb25zdCB7bWFyZ2luLCBoZWlnaHR9ID0gdGhpcy5zdGF0ZTtcclxuXHRcdC8vIGxlc3MgdGhhbiAyMCBpcyBub3QgZW5vdWdoIHRvIHNob3cgdGhlIGF4aXMgbGFiZWwgJ291dGVyJyB3aXRob3V0IGxlZ2VuZFxyXG5cdFx0cmV0dXJuIChmb3JIb3Jpem9udGFsID8gbWFyZ2luLmJvdHRvbSA6IChtYXJnaW4udG9wICsgaGVpZ2h0KSkgKyAyMDtcclxuXHR9LFxyXG5cclxuXHRnZXRYQXhpc0NsaXBXaWR0aCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0QXhpc0NsaXBXaWR0aCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WEF4aXNDbGlwSGVpZ2h0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCghJCQuY29uZmlnLmF4aXNfcm90YXRlZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WUF4aXNDbGlwV2lkdGgoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmdldEF4aXNDbGlwV2lkdGgoJCQuY29uZmlnLmF4aXNfcm90YXRlZCkgKyAoJCQuY29uZmlnLmF4aXNfeV9pbm5lciA/IDIwIDogMCk7XHJcblx0fSxcclxuXHJcblx0Z2V0WUF4aXNDbGlwSGVpZ2h0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5nZXRBeGlzQ2xpcEhlaWdodCgkJC5jb25maWcuYXhpc19yb3RhdGVkKTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtzZWxlY3QgYXMgZDNTZWxlY3R9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtzY2FsZU9yZGluYWwgYXMgZDNTY2FsZU9yZGluYWx9IGZyb20gXCJkMy1zY2FsZVwiO1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7bm90RW1wdHksIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogU2V0IHBhdHRlcm4ncyBiYWNrZ3JvdW5kIGNvbG9yXHJcbiAqIChpdCBhZGRzIGEgPHJlY3Q+IGVsZW1lbnQgdG8gc2ltdWxhdGUgYmctY29sb3IpXHJcbiAqIEBwYXJhbSB7U1ZHUGF0dGVybkVsZW1lbnR9IHBhdHRlcm4gU1ZHIHBhdHRlcm4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sb3IgQ29sb3Igc3RyaW5nXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBJRCB0byBiZSBzZXRcclxuICogQHJldHVybiB7e2lkOiBzdHJpbmcsIG5vZGU6IFNWR1BhdHRlcm5FbGVtZW50fX1cclxuICogQHByaXZhdGVcclxuICovXHJcbmNvbnN0IGNvbG9yaXplUGF0dGVybiA9IChwYXR0ZXJuLCBjb2xvciwgaWQ6IHN0cmluZykgPT4ge1xyXG5cdGNvbnN0IG5vZGUgPSBkM1NlbGVjdChwYXR0ZXJuLmNsb25lTm9kZSh0cnVlKSk7XHJcblxyXG5cdG5vZGVcclxuXHRcdC5hdHRyKFwiaWRcIiwgaWQpXHJcblx0XHQuaW5zZXJ0KFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKVxyXG5cdFx0LmF0dHIoXCJ3aWR0aFwiLCBub2RlLmF0dHIoXCJ3aWR0aFwiKSlcclxuXHRcdC5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuYXR0cihcImhlaWdodFwiKSlcclxuXHRcdC5zdHlsZShcImZpbGxcIiwgY29sb3IpO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0aWQsXHJcblx0XHRub2RlOiBub2RlLm5vZGUoKVxyXG5cdH07XHJcbn07XHJcblxyXG4vLyBSZXBsYWNlbWVudCBvZiBkMy5zY2hlbWVDYXRlZ29yeTEwLlxyXG4vLyBDb250YWluZWQgZGlmZmVyZW50bHkgZGVwZW5kIG9uIGQzIHZlcnNpb246IHY0KGQzLXNjYWxlKSwgdjUoZDMtc2NhbGUtY2hyb21hdGljKVxyXG5jb25zdCBzY2hlbWVDYXRlZ29yeTEwID0gW1wiIzFmNzdiNFwiLCBcIiNmZjdmMGVcIiwgXCIjMmNhMDJjXCIsIFwiI2Q2MjcyOFwiLCBcIiM5NDY3YmRcIiwgXCIjOGM1NjRiXCIsIFwiI2UzNzdjMlwiLCBcIiM3ZjdmN2ZcIiwgXCIjYmNiZDIyXCIsIFwiIzE3YmVjZlwiXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBHZXQgY29sb3IgcGF0dGVybiBmcm9tIENTUyBmaWxlXHJcblx0ICogQ1NTIHNob3VsZCBiZSBkZWZpbmVkIGFzOiBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoXCIjMDBjNzNjOyNmYTcxNzE7IC4uLlwiKTtcclxuXHQgKiBAcmV0dXJuIHtBcnJheX1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldENvbG9yRnJvbUNzcygpIHtcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCJfX2NvbG9yUGF0dGVybl9fXCI7XHJcblx0XHRjb25zdCBib2R5ID0gZG9jdW1lbnQuYm9keTtcclxuXHRcdGxldCBwYXR0ZXJuID0gYm9keVtjYWNoZUtleV07XHJcblxyXG5cdFx0aWYgKCFwYXR0ZXJuKSB7XHJcblx0XHRcdGNvbnN0IGRlbGltaXRlciA9IFwiO1wiO1xyXG5cdFx0XHRjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XHJcblxyXG5cdFx0XHRzcGFuLmNsYXNzTmFtZSA9IENMQVNTLmNvbG9yUGF0dGVybjtcclxuXHRcdFx0c3Bhbi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcblx0XHRcdGJvZHkuYXBwZW5kQ2hpbGQoc3Bhbik7XHJcblxyXG5cdFx0XHRjb25zdCBjb250ZW50ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuYmFja2dyb3VuZEltYWdlO1xyXG5cclxuXHRcdFx0c3Bhbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNwYW4pO1xyXG5cclxuXHRcdFx0aWYgKGNvbnRlbnQuaW5kZXhPZihkZWxpbWl0ZXIpID4gLTEpIHtcclxuXHRcdFx0XHRwYXR0ZXJuID0gY29udGVudFxyXG5cdFx0XHRcdFx0LnJlcGxhY2UoL3VybFteI10qfFtcIicoKV18KFxcc3wlMjApL2csIFwiXCIpXHJcblx0XHRcdFx0XHQuc3BsaXQoZGVsaW1pdGVyKVxyXG5cdFx0XHRcdFx0Lm1hcCh2ID0+IHYudHJpbSgpLnJlcGxhY2UoL1tcXFwiJ1xcc10vZywgXCJcIikpXHJcblx0XHRcdFx0XHQuZmlsdGVyKEJvb2xlYW4pO1xyXG5cclxuXHRcdFx0XHRib2R5W2NhY2hlS2V5XSA9IHBhdHRlcm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGF0dGVybjtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUNvbG9yKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5kYXRhX2NvbG9ycztcclxuXHRcdGNvbnN0IGNhbGxiYWNrID0gY29uZmlnLmRhdGFfY29sb3I7XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblxyXG5cdFx0bGV0IHBhdHRlcm4gPSBub3RFbXB0eShjb25maWcuY29sb3JfcGF0dGVybikgPyBjb25maWcuY29sb3JfcGF0dGVybiA6XHJcblx0XHRcdGQzU2NhbGVPcmRpbmFsKCQkLmdldENvbG9yRnJvbUNzcygpIHx8IHNjaGVtZUNhdGVnb3J5MTApLnJhbmdlKCk7XHJcblxyXG5cdFx0Y29uc3Qgb3JpZ2luYWxDb2xvclBhdHRlcm4gPSBwYXR0ZXJuO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKGNvbmZpZy5jb2xvcl90aWxlcykpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBjb25maWcuY29sb3JfdGlsZXMoKTtcclxuXHJcblx0XHRcdC8vIEFkZCBiYWNrZ3JvdW5kIGNvbG9yIHRvIHBhdHRlcm5zXHJcblx0XHRcdGNvbnN0IGNvbG9yaXplZFBhdHRlcm5zID0gcGF0dGVybi5tYXAoKHAsIGluZGV4KSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY29sb3IgPSBwLnJlcGxhY2UoL1sjXFwoXFwpXFxzLF0vZywgXCJcIik7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSBgJHskJC5zdGF0ZS5kYXRldGltZUlkfS1wYXR0ZXJuLSR7Y29sb3J9LSR7aW5kZXh9YDtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGNvbG9yaXplUGF0dGVybih0aWxlc1tpbmRleCAlIHRpbGVzLmxlbmd0aF0sIHAsIGlkKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRwYXR0ZXJuID0gY29sb3JpemVkUGF0dGVybnMubWFwKHAgPT4gYHVybCgjJHtwLmlkfSlgKTtcclxuXHRcdFx0JCQucGF0dGVybnMgPSBjb2xvcml6ZWRQYXR0ZXJucztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRjb25zdCBpZDogc3RyaW5nID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcclxuXHRcdFx0Y29uc3QgaXNMaW5lID0gJCQuaXNUeXBlT2YoaWQsIFtcImxpbmVcIiwgXCJzcGxpbmVcIiwgXCJzdGVwXCJdKSB8fCAhY29uZmlnLmRhdGFfdHlwZXNbaWRdO1xyXG5cdFx0XHRsZXQgY29sb3I7XHJcblxyXG5cdFx0XHQvLyBpZiBjYWxsYmFjayBmdW5jdGlvbiBpcyBwcm92aWRlZFxyXG5cdFx0XHRpZiAoaXNGdW5jdGlvbihjb2xvcnNbaWRdKSkge1xyXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzW2lkXShkKTtcclxuXHJcblx0XHRcdC8vIGlmIHNwZWNpZmllZCwgY2hvb3NlIHRoYXQgY29sb3JcclxuXHRcdFx0fSBlbHNlIGlmIChjb2xvcnNbaWRdKSB7XHJcblx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbaWRdO1xyXG5cclxuXHRcdFx0Ly8gaWYgbm90IHNwZWNpZmllZCwgY2hvb3NlIGZyb20gcGF0dGVyblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmIChpZHMuaW5kZXhPZihpZCkgPCAwKSB7XHJcblx0XHRcdFx0XHRpZHMucHVzaChpZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvciA9IGlzTGluZSA/IG9yaWdpbmFsQ29sb3JQYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIG9yaWdpbmFsQ29sb3JQYXR0ZXJuLmxlbmd0aF0gOlxyXG5cdFx0XHRcdFx0cGF0dGVybltpZHMuaW5kZXhPZihpZCkgJSBwYXR0ZXJuLmxlbmd0aF07XHJcblxyXG5cdFx0XHRcdGNvbG9yc1tpZF0gPSBjb2xvcjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGlzRnVuY3Rpb24oY2FsbGJhY2spID9cclxuXHRcdFx0XHRjYWxsYmFjayhjb2xvciwgZCkgOiBjb2xvcjtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVMZXZlbENvbG9yKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGNvbG9ycyA9IGNvbmZpZy5jb2xvcl9wYXR0ZXJuO1xyXG5cdFx0Y29uc3QgdGhyZXNob2xkID0gY29uZmlnLmNvbG9yX3RocmVzaG9sZDtcclxuXHRcdGNvbnN0IGFzVmFsdWUgPSB0aHJlc2hvbGQudW5pdCA9PT0gXCJ2YWx1ZVwiO1xyXG5cdFx0Y29uc3QgbWF4ID0gdGhyZXNob2xkLm1heCB8fCAxMDA7XHJcblx0XHRjb25zdCB2YWx1ZXMgPSB0aHJlc2hvbGQudmFsdWVzICYmXHJcblx0XHRcdHRocmVzaG9sZC52YWx1ZXMubGVuZ3RoID8gdGhyZXNob2xkLnZhbHVlcyA6IFtdO1xyXG5cclxuXHRcdHJldHVybiBub3RFbXB0eSh0aHJlc2hvbGQpID8gZnVuY3Rpb24odmFsdWUpIHtcclxuXHRcdFx0Y29uc3QgdiA9IGFzVmFsdWUgPyB2YWx1ZSA6ICh2YWx1ZSAqIDEwMCAvIG1heCk7XHJcblx0XHRcdGxldCBjb2xvciA9IGNvbG9yc1tjb2xvcnMubGVuZ3RoIC0gMV07XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbCA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodiA8PSB2YWx1ZXNbaV0pIHtcclxuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzW2ldO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gY29sb3I7XHJcblx0XHR9IDogbnVsbDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgdGhlIGRhdGEgb3ZlciBjb2xvci5cclxuXHQgKiBXaGVuIGlzIG91dCwgd2lsbCByZXN0YXRlIGluIGl0cyBwcmV2aW91cyBjb2xvciB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNPdmVyIHRydWU6IHNldCBvdmVyZWQgY29sb3IsIGZhbHNlOiByZXN0b3JlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBkIHRhcmdldCBpbmRleCBvciBkYXRhIG9iamVjdCBmb3IgQXJjIHR5cGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldE92ZXJDb2xvcihpc092ZXIsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgb25vdmVyID0gY29uZmlnLmNvbG9yX29ub3ZlcjtcclxuXHRcdGxldCBjb2xvciA9IGlzT3ZlciA/IG9ub3ZlciA6ICQkLmNvbG9yO1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb2xvcikpIHtcclxuXHRcdFx0Y29sb3IgPSAoe2lkfSkgPT4gKGlkIGluIG9ub3ZlciA/IG9ub3ZlcltpZF0gOiAkJC5jb2xvcihpZCkpO1xyXG5cdFx0fSBlbHNlIGlmIChpc1N0cmluZyhjb2xvcikpIHtcclxuXHRcdFx0Y29sb3IgPSAoKSA9PiBvbm92ZXI7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gd2hlbiBpcyBBcmMgdHlwZVxyXG5cdFx0aWYgKGlzT2JqZWN0KGQpKSB7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgY29sb3IoZCkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfS0ke2R9YClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsIGNvbG9yKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHticnVzaEVtcHR5LCBnZXRCcnVzaFNlbGVjdGlvbiwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIG5vdEVtcHR5LCBpc1ZhbHVlLCBpc09iamVjdCwgaXNOdW1iZXIsIGRpZmZEb21haW4sIHNvcnRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCB0eXBlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNNaW4gPSB0eXBlID09PSBcIm1pblwiO1xyXG5cclxuXHRcdGNvbnN0IGRhdGFHcm91cHMgPSBjb25maWcuZGF0YV9ncm91cHM7XHJcblx0XHRjb25zdCBpZHMgPSAkJC5tYXBUb0lkcyh0YXJnZXRzKTtcclxuXHRcdGNvbnN0IHlzID0gJCQuZ2V0VmFsdWVzQXNJZEtleWVkKHRhcmdldHMpO1xyXG5cclxuXHRcdGlmIChkYXRhR3JvdXBzLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0Y29uc3QgaGFzVmFsdWUgPSAkJFtgaGFzJHtpc01pbiA/IFwiTmVnYXRpdmVcIiA6IFwiUG9zaXRpdmVcIn1WYWx1ZUluVGFyZ2V0c2BdKHRhcmdldHMpO1xyXG5cclxuXHRcdFx0Zm9yIChsZXQgaiA9IDAsIGlkc0luR3JvdXA7IChpZHNJbkdyb3VwID0gZGF0YUdyb3Vwc1tqXSk7IGorKykge1xyXG5cdFx0XHRcdC8vIERldGVybWluZSBiYXNlSWRcclxuXHRcdFx0XHRpZHNJbkdyb3VwID0gaWRzSW5Hcm91cC5maWx0ZXIodiA9PiBpZHMuaW5kZXhPZih2KSA+PSAwKTtcclxuXHJcblx0XHRcdFx0aWYgKGlkc0luR3JvdXAubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGJhc2VJZCA9IGlkc0luR3JvdXBbMF07XHJcblx0XHRcdFx0Y29uc3QgYmFzZUF4aXNJZCA9ICQkLmF4aXMuZ2V0SWQoYmFzZUlkKTtcclxuXHJcblx0XHRcdFx0Ly8gSW5pdGlhbGl6ZSBiYXNlIHZhbHVlLiBTZXQgdG8gMCBpZiBub3QgbWF0Y2ggd2l0aCB0aGUgY29uZGl0aW9uXHJcblx0XHRcdFx0aWYgKGhhc1ZhbHVlICYmIHlzW2Jhc2VJZF0pIHtcclxuXHRcdFx0XHRcdHlzW2Jhc2VJZF0gPSB5c1tiYXNlSWRdLm1hcCh2ID0+IChcclxuXHRcdFx0XHRcdFx0KGlzTWluID8gdiA8IDAgOiB2ID4gMCkgPyB2IDogMFxyXG5cdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKGxldCBrID0gMSwgaWQ7IChpZCA9IGlkc0luR3JvdXBba10pOyBrKyspIHtcclxuXHRcdFx0XHRcdGlmICgheXNbaWRdKSB7XHJcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGF4aXNJZCA9ICQkLmF4aXMuZ2V0SWQoaWQpO1xyXG5cclxuXHRcdFx0XHRcdHlzW2lkXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHZhbCA9ICt2O1xyXG5cdFx0XHRcdFx0XHRjb25zdCBtZWV0Q29uZGl0aW9uID0gaXNNaW4gPyB2YWwgPiAwIDogdmFsIDwgMDtcclxuXHJcblx0XHRcdFx0XHRcdGlmIChheGlzSWQgPT09IGJhc2VBeGlzSWQgJiYgIShoYXNWYWx1ZSAmJiBtZWV0Q29uZGl0aW9uKSkge1xyXG5cdFx0XHRcdFx0XHRcdHlzW2Jhc2VJZF1baV0gKz0gdmFsO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZ2V0TWluTWF4KHR5cGUsIE9iamVjdC5rZXlzKHlzKS5tYXAoa2V5ID0+IGdldE1pbk1heCh0eXBlLCB5c1trZXldKSkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFlEb21haW5NaW4odGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WURvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1pblwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRZRG9tYWluTWF4KHRhcmdldHMpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFlEb21haW5NaW5NYXgodGFyZ2V0cywgXCJtYXhcIik7XHJcblx0fSxcclxuXHJcblx0Z2V0WURvbWFpbih0YXJnZXRzLCBheGlzSWQsIHhEb21haW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5pc1N0YWNrTm9ybWFsaXplZCgpKSB7XHJcblx0XHRcdHJldHVybiBbMCwgMTAwXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB0YXJnZXRzQnlBeGlzSWQgPSB0YXJnZXRzLmZpbHRlcih0ID0+ICQkLmF4aXMuZ2V0SWQodC5pZCkgPT09IGF4aXNJZCk7XHJcblx0XHRjb25zdCB5VGFyZ2V0cyA9IHhEb21haW4gPyAkJC5maWx0ZXJCeVhEb21haW4odGFyZ2V0c0J5QXhpc0lkLCB4RG9tYWluKSA6IHRhcmdldHNCeUF4aXNJZDtcclxuXHJcblx0XHRpZiAoeVRhcmdldHMubGVuZ3RoID09PSAwKSB7IC8vIHVzZSBkb21haW4gb2YgdGhlIG90aGVyIGF4aXMgaWYgdGFyZ2V0IG9mIGF4aXNJZCBpcyBub25lXHJcblx0XHRcdHJldHVybiBheGlzSWQgPT09IFwieTJcIiA/XHJcblx0XHRcdFx0c2NhbGUueS5kb21haW4oKSA6XHJcblx0XHRcdFx0Ly8gV2hlbiBhbGwgZGF0YSBib3VuZHMgdG8geTIsIHkgQXhpcyBkb21haW4gaXMgY2FsbGVkIHByaW9yIHkyLlxyXG5cdFx0XHRcdC8vIFNvLCBpdCBuZWVkcyB0byBjYWxsIHRvIGdldCB5MiBkb21haW4gaGVyZVxyXG5cdFx0XHRcdCQkLmdldFlEb21haW4odGFyZ2V0cywgXCJ5MlwiLCB4RG9tYWluKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCB5TWluID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9taW5gXTtcclxuXHRcdGNvbnN0IHlNYXggPSBjb25maWdbYGF4aXNfJHtheGlzSWR9X21heGBdO1xyXG5cdFx0bGV0IHlEb21haW5NaW4gPSAkJC5nZXRZRG9tYWluTWluKHlUYXJnZXRzKTtcclxuXHRcdGxldCB5RG9tYWluTWF4ID0gJCQuZ2V0WURvbWFpbk1heCh5VGFyZ2V0cyk7XHJcblxyXG5cdFx0Y29uc3QgY2VudGVyID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9jZW50ZXJgXTtcclxuXHRcdGxldCBpc1plcm9CYXNlZCA9IFtcImFyZWFcIiwgXCJiYXJcIiwgXCJidWJibGVcIiwgXCJsaW5lXCIsIFwic2NhdHRlclwiXVxyXG5cdFx0XHQuc29tZSh2ID0+ICQkLmhhc1R5cGUodiwgeVRhcmdldHMpICYmIGNvbmZpZ1tgJHt2fV96ZXJvYmFzZWRgXSk7XHJcblx0XHRjb25zdCBpc0ludmVydGVkID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9pbnZlcnRlZGBdO1xyXG5cdFx0Y29uc3Qgc2hvd0hvcml6b250YWxEYXRhTGFiZWwgPSAkJC5oYXNEYXRhTGFiZWwoKSAmJiBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3Qgc2hvd1ZlcnRpY2FsRGF0YUxhYmVsID0gJCQuaGFzRGF0YUxhYmVsKCkgJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Ly8gTUVNTzogYXZvaWQgaW52ZXJ0aW5nIGRvbWFpbiB1bmV4cGVjdGVkbHlcclxuXHRcdHlEb21haW5NaW4gPSBpc1ZhbHVlKHlNaW4pID8geU1pbiA6XHJcblx0XHRcdChpc1ZhbHVlKHlNYXgpID8gKHlEb21haW5NaW4gPCB5TWF4ID8geURvbWFpbk1pbiA6IHlNYXggLSAxMCkgOiB5RG9tYWluTWluKTtcclxuXHRcdHlEb21haW5NYXggPSBpc1ZhbHVlKHlNYXgpID8geU1heCA6XHJcblx0XHRcdChpc1ZhbHVlKHlNaW4pID8gKHlNaW4gPCB5RG9tYWluTWF4ID8geURvbWFpbk1heCA6IHlNaW4gKyAxMCkgOiB5RG9tYWluTWF4KTtcclxuXHJcblx0XHRpZiAoaXNOYU4oeURvbWFpbk1pbikpIHsgLy8gc2V0IG1pbmltdW0gdG8gemVybyB3aGVuIG5vdCBudW1iZXJcclxuXHRcdFx0eURvbWFpbk1pbiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzTmFOKHlEb21haW5NYXgpKSB7IC8vIHNldCBtYXhpbXVtIHRvIGhhdmUgc2FtZSB2YWx1ZSBhcyB5RG9tYWluTWluXHJcblx0XHRcdHlEb21haW5NYXggPSB5RG9tYWluTWluO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh5RG9tYWluTWluID09PSB5RG9tYWluTWF4KSB7XHJcblx0XHRcdHlEb21haW5NaW4gPCAwID8geURvbWFpbk1heCA9IDAgOiB5RG9tYWluTWluID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBpc0FsbFBvc2l0aXZlID0geURvbWFpbk1pbiA+PSAwICYmIHlEb21haW5NYXggPj0gMDtcclxuXHRcdGNvbnN0IGlzQWxsTmVnYXRpdmUgPSB5RG9tYWluTWluIDw9IDAgJiYgeURvbWFpbk1heCA8PSAwO1xyXG5cclxuXHRcdC8vIENhbmNlbCB6ZXJvYmFzZWQgaWYgYXhpc18qX21pbiAvIGF4aXNfKl9tYXggc3BlY2lmaWVkXHJcblx0XHRpZiAoKGlzVmFsdWUoeU1pbikgJiYgaXNBbGxQb3NpdGl2ZSkgfHwgKGlzVmFsdWUoeU1heCkgJiYgaXNBbGxOZWdhdGl2ZSkpIHtcclxuXHRcdFx0aXNaZXJvQmFzZWQgPSBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBCYXIvQXJlYSBjaGFydCBzaG91bGQgYmUgMC1iYXNlZCBpZiBhbGwgcG9zaXRpdmV8bmVnYXRpdmVcclxuXHRcdGlmIChpc1plcm9CYXNlZCkge1xyXG5cdFx0XHRpc0FsbFBvc2l0aXZlICYmICh5RG9tYWluTWluID0gMCk7XHJcblx0XHRcdGlzQWxsTmVnYXRpdmUgJiYgKHlEb21haW5NYXggPSAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkb21haW5MZW5ndGggPSBNYXRoLmFicyh5RG9tYWluTWF4IC0geURvbWFpbk1pbik7XHJcblx0XHRjb25zdCBwYWRkaW5nID0ge3RvcDogZG9tYWluTGVuZ3RoICogMC4xLCBib3R0b206IGRvbWFpbkxlbmd0aCAqIDAuMX07XHJcblxyXG5cdFx0aWYgKGlzRGVmaW5lZChjZW50ZXIpKSB7XHJcblx0XHRcdGNvbnN0IHlEb21haW5BYnMgPSBNYXRoLm1heChNYXRoLmFicyh5RG9tYWluTWluKSwgTWF0aC5hYnMoeURvbWFpbk1heCkpO1xyXG5cclxuXHRcdFx0eURvbWFpbk1heCA9IGNlbnRlciArIHlEb21haW5BYnM7XHJcblx0XHRcdHlEb21haW5NaW4gPSBjZW50ZXIgLSB5RG9tYWluQWJzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFkZCBwYWRkaW5nIGZvciBkYXRhIGxhYmVsXHJcblx0XHRpZiAoc2hvd0hvcml6b250YWxEYXRhTGFiZWwpIHtcclxuXHRcdFx0Y29uc3QgZGlmZiA9IGRpZmZEb21haW4oc2NhbGUueS5yYW5nZSgpKTtcclxuXHRcdFx0Y29uc3QgcmF0aW8gPSAkJC5nZXREYXRhTGFiZWxMZW5ndGgoeURvbWFpbk1pbiwgeURvbWFpbk1heCwgXCJ3aWR0aFwiKVxyXG5cdFx0XHRcdC5tYXAodiA9PiB2IC8gZGlmZik7XHJcblxyXG5cdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCgodiwgaSkgPT4ge1xyXG5cdFx0XHRcdHBhZGRpbmdbdl0gKz0gZG9tYWluTGVuZ3RoICogKHJhdGlvW2ldIC8gKDEgLSByYXRpb1swXSAtIHJhdGlvWzFdKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChzaG93VmVydGljYWxEYXRhTGFiZWwpIHtcclxuXHRcdFx0Y29uc3QgbGVuZ3RocyA9ICQkLmdldERhdGFMYWJlbExlbmd0aCh5RG9tYWluTWluLCB5RG9tYWluTWF4LCBcImhlaWdodFwiKTtcclxuXHJcblx0XHRcdFtcImJvdHRvbVwiLCBcInRvcFwiXS5mb3JFYWNoKCh2LCBpKSA9PiB7XHJcblx0XHRcdFx0cGFkZGluZ1t2XSArPSAkJC5heGlzLmNvbnZlcnRQaXhlbHNUb0F4aXNQYWRkaW5nKGxlbmd0aHNbaV0sIGRvbWFpbkxlbmd0aCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgvXnkyPyQvLnRlc3QoYXhpc0lkKSkge1xyXG5cdFx0XHRjb25zdCBwID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9wYWRkaW5nYF07XHJcblxyXG5cdFx0XHRpZiAobm90RW1wdHkocCkpIHtcclxuXHRcdFx0XHRbXCJib3R0b21cIiwgXCJ0b3BcIl0uZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdHBhZGRpbmdbdl0gPSAkJC5heGlzLmdldFBhZGRpbmcocCwgdiwgcGFkZGluZ1t2XSwgZG9tYWluTGVuZ3RoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJhci9BcmVhIGNoYXJ0IHNob3VsZCBiZSAwLWJhc2VkIGlmIGFsbCBwb3NpdGl2ZXxuZWdhdGl2ZVxyXG5cdFx0aWYgKGlzWmVyb0Jhc2VkKSB7XHJcblx0XHRcdGlzQWxsUG9zaXRpdmUgJiYgKHBhZGRpbmcuYm90dG9tID0geURvbWFpbk1pbik7XHJcblx0XHRcdGlzQWxsTmVnYXRpdmUgJiYgKHBhZGRpbmcudG9wID0gLXlEb21haW5NYXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IGRvbWFpbiA9IFt5RG9tYWluTWluIC0gcGFkZGluZy5ib3R0b20sIHlEb21haW5NYXggKyBwYWRkaW5nLnRvcF07XHJcblxyXG5cdFx0cmV0dXJuIGlzSW52ZXJ0ZWQgPyBkb21haW4ucmV2ZXJzZSgpIDogZG9tYWluO1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW5NaW5NYXgodGFyZ2V0cywgdHlwZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdmFsdWUgPSAkJC5jb25maWdbYGF4aXNfeF8ke3R5cGV9YF07XHJcblxyXG5cdFx0cmV0dXJuIGlzRGVmaW5lZCh2YWx1ZSkgP1xyXG5cdFx0XHQoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUodmFsdWUpIDogdmFsdWUpIDpcclxuXHRcdFx0Z2V0TWluTWF4KHR5cGUsIHRhcmdldHMubWFwKHQgPT4gZ2V0TWluTWF4KHR5cGUsIHQudmFsdWVzLm1hcCh2ID0+IHYueCkpKSk7XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbk1pbih0YXJnZXRzKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRYRG9tYWluTWluTWF4KHRhcmdldHMsIFwibWluXCIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFhEb21haW5NYXgodGFyZ2V0cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0WERvbWFpbk1pbk1heCh0YXJnZXRzLCBcIm1heFwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRYRG9tYWluUGFkZGluZyhkb21haW4pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBkaWZmID0gZG9tYWluWzFdIC0gZG9tYWluWzBdO1xyXG5cdFx0Y29uc3QgeFBhZGRpbmcgPSBjb25maWcuYXhpc194X3BhZGRpbmc7XHJcblx0XHRsZXQgbWF4RGF0YUNvdW50O1xyXG5cdFx0bGV0IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKCQkLmlzQ2F0ZWdvcml6ZWQoKSkge1xyXG5cdFx0XHRwYWRkaW5nID0gMDtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaGFzVHlwZShcImJhclwiKSkge1xyXG5cdFx0XHRtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdFx0cGFkZGluZyA9IG1heERhdGFDb3VudCA+IDEgPyAoZGlmZiAvIChtYXhEYXRhQ291bnQgLSAxKSkgLyAyIDogMC41O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFkZGluZyA9IGRpZmYgKiAwLjAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxldCBsZWZ0ID0gcGFkZGluZztcclxuXHRcdGxldCByaWdodCA9IHBhZGRpbmc7XHJcblxyXG5cdFx0aWYgKGlzT2JqZWN0KHhQYWRkaW5nKSAmJiBub3RFbXB0eSh4UGFkZGluZykpIHtcclxuXHRcdFx0bGVmdCA9IGlzVmFsdWUoeFBhZGRpbmcubGVmdCkgPyB4UGFkZGluZy5sZWZ0IDogcGFkZGluZztcclxuXHRcdFx0cmlnaHQgPSBpc1ZhbHVlKHhQYWRkaW5nLnJpZ2h0KSA/IHhQYWRkaW5nLnJpZ2h0IDogcGFkZGluZztcclxuXHRcdH0gZWxzZSBpZiAoaXNOdW1iZXIoY29uZmlnLmF4aXNfeF9wYWRkaW5nKSkge1xyXG5cdFx0XHRsZWZ0ID0geFBhZGRpbmc7XHJcblx0XHRcdHJpZ2h0ID0geFBhZGRpbmc7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtsZWZ0LCByaWdodH07XHJcblx0fSxcclxuXHJcblx0Z2V0WERvbWFpbih0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB4RG9tYWluID0gWyQkLmdldFhEb21haW5NaW4odGFyZ2V0cyksICQkLmdldFhEb21haW5NYXgodGFyZ2V0cyldO1xyXG5cdFx0bGV0IGZpcnN0WCA9IHhEb21haW5bMF07XHJcblx0XHRsZXQgbGFzdFggPSB4RG9tYWluWzFdO1xyXG5cdFx0Y29uc3QgcGFkZGluZyA9ICQkLmdldFhEb21haW5QYWRkaW5nKHhEb21haW4pO1xyXG5cdFx0bGV0IG1pbjogRGF0ZSB8IG51bWJlciA9IDA7XHJcblx0XHRsZXQgbWF4OiBEYXRlIHwgbnVtYmVyID0gMDtcclxuXHJcblx0XHQvLyBzaG93IGNlbnRlciBvZiB4IGRvbWFpbiBpZiBtaW4gYW5kIG1heCBhcmUgdGhlIHNhbWVcclxuXHRcdGlmICgoZmlyc3RYIC0gbGFzdFgpID09PSAwICYmICEkJC5pc0NhdGVnb3JpemVkKCkpIHtcclxuXHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdFx0Zmlyc3RYID0gbmV3IERhdGUoZmlyc3RYLmdldFRpbWUoKSAqIDAuNSk7XHJcblx0XHRcdFx0bGFzdFggPSBuZXcgRGF0ZShsYXN0WC5nZXRUaW1lKCkgKiAxLjUpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZpcnN0WCA9IGZpcnN0WCA9PT0gMCA/IDEgOiAoZmlyc3RYICogMC41KTtcclxuXHRcdFx0XHRsYXN0WCA9IGxhc3RYID09PSAwID8gLTEgOiAobGFzdFggKiAxLjUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGZpcnN0WCB8fCBmaXJzdFggPT09IDApIHtcclxuXHRcdFx0bWluID0gJCQuaXNUaW1lU2VyaWVzKCkgPyBuZXcgRGF0ZShmaXJzdFguZ2V0VGltZSgpIC0gcGFkZGluZy5sZWZ0KSA6IGZpcnN0WCAtIHBhZGRpbmcubGVmdDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobGFzdFggfHwgbGFzdFggPT09IDApIHtcclxuXHRcdFx0bWF4ID0gJCQuaXNUaW1lU2VyaWVzKCkgPyBuZXcgRGF0ZShsYXN0WC5nZXRUaW1lKCkgKyBwYWRkaW5nLnJpZ2h0KSA6IGxhc3RYICsgcGFkZGluZy5yaWdodDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gW21pbiwgbWF4XTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVYRG9tYWluKHRhcmdldHMsIHdpdGhVcGRhdGVYRG9tYWluLCB3aXRoVXBkYXRlT3JnWERvbWFpbiwgd2l0aFRyaW0sIGRvbWFpbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IHpvb21FbmFibGVkID0gY29uZmlnLnpvb21fZW5hYmxlZDtcclxuXHJcblx0XHRpZiAod2l0aFVwZGF0ZU9yZ1hEb21haW4pIHtcclxuXHRcdFx0c2NhbGUueC5kb21haW4oZG9tYWluIHx8IHNvcnRWYWx1ZSgkJC5nZXRYRG9tYWluKHRhcmdldHMpKSk7XHJcblx0XHRcdG9yZy54RG9tYWluID0gc2NhbGUueC5kb21haW4oKTtcclxuXHJcblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcclxuXHJcblx0XHRcdHNjYWxlLnN1YlguZG9tYWluKHNjYWxlLnguZG9tYWluKCkpO1xyXG5cdFx0XHQkJC5icnVzaCAmJiAkJC5icnVzaC5zY2FsZShzY2FsZS5zdWJYKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAod2l0aFVwZGF0ZVhEb21haW4pIHtcclxuXHRcdFx0Y29uc3QgZG9tYWluVmFsdWUgPSBkb21haW4gfHwgKCEkJC5icnVzaCB8fCBicnVzaEVtcHR5KCQkKSkgP1xyXG5cdFx0XHRcdG9yZy54RG9tYWluIDogZ2V0QnJ1c2hTZWxlY3Rpb24oJCQpLm1hcChzY2FsZS5zdWJYLmludmVydCk7XHJcblxyXG5cdFx0XHRzY2FsZS54LmRvbWFpbihkb21haW5WYWx1ZSk7XHJcblx0XHRcdHpvb21FbmFibGVkICYmICQkLnpvb20udXBkYXRlU2NhbGVFeHRlbnQoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUcmltIGRvbWFpbiB3aGVuIHRvbyBiaWcgYnkgem9vbSBtb3VzZW1vdmUgZXZlbnRcclxuXHRcdHdpdGhUcmltICYmIHNjYWxlLnguZG9tYWluKCQkLnRyaW1YRG9tYWluKHNjYWxlLngub3JnRG9tYWluKCkpKTtcclxuXHJcblx0XHRyZXR1cm4gc2NhbGUueC5kb21haW4oKTtcclxuXHR9LFxyXG5cclxuXHR0cmltWERvbWFpbihkb21haW4pIHtcclxuXHRcdGNvbnN0IHpvb21Eb21haW4gPSB0aGlzLmdldFpvb21Eb21haW4oKTtcclxuXHRcdGNvbnN0IFttaW4sIG1heF0gPSB6b29tRG9tYWluO1xyXG5cclxuXHRcdGlmIChkb21haW5bMF0gPD0gbWluKSB7XHJcblx0XHRcdGRvbWFpblsxXSA9ICtkb21haW5bMV0gKyAobWluIC0gZG9tYWluWzBdKTtcclxuXHRcdFx0ZG9tYWluWzBdID0gbWluO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXggPD0gZG9tYWluWzFdKSB7XHJcblx0XHRcdGRvbWFpblswXSA9ICtkb21haW5bMF0gLSAoZG9tYWluWzFdIC0gbWF4KTtcclxuXHRcdFx0ZG9tYWluWzFdID0gbWF4O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBkb21haW47XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0VHlwZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5mdW5jdGlvbiBnZXRGb3JtYXQoJCQsIHR5cGVWYWx1ZSwgdikge1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0Y29uc3QgdHlwZSA9IGBheGlzXyR7dHlwZVZhbHVlfV90aWNrX2Zvcm1hdGA7XHJcblx0Y29uc3QgZm9ybWF0ID0gY29uZmlnW3R5cGVdID9cclxuXHRcdGNvbmZpZ1t0eXBlXSA6ICQkLmRlZmF1bHRWYWx1ZUZvcm1hdDtcclxuXHJcblx0cmV0dXJuIGZvcm1hdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGdldFlGb3JtYXQoZm9yQXJjKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgZm9ybWF0Rm9yWSA9ICQkLnlGb3JtYXQ7XHJcblx0XHRsZXQgZm9ybWF0Rm9yWTIgPSAkJC55MkZvcm1hdDtcclxuXHJcblx0XHRpZiAoZm9yQXJjICYmICEkJC5oYXNUeXBlKFwiZ2F1Z2VcIikpIHtcclxuXHRcdFx0Zm9ybWF0Rm9yWSA9ICQkLmRlZmF1bHRBcmNWYWx1ZUZvcm1hdDtcclxuXHRcdFx0Zm9ybWF0Rm9yWTIgPSAkJC5kZWZhdWx0QXJjVmFsdWVGb3JtYXQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHYsIHJhdGlvLCBpZCkge1xyXG5cdFx0XHRjb25zdCBmb3JtYXQgPSAkJC5heGlzLmdldElkKGlkKSA9PT0gXCJ5MlwiID9cclxuXHRcdFx0XHRmb3JtYXRGb3JZMiA6IGZvcm1hdEZvclk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZm9ybWF0LmNhbGwoJCQsIHYsIHJhdGlvKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0eUZvcm1hdCh2KSB7XHJcblx0XHRyZXR1cm4gZ2V0Rm9ybWF0KHRoaXMsIFwieVwiLCB2KTtcclxuXHR9LFxyXG5cclxuXHR5MkZvcm1hdCh2KSB7XHJcblx0XHRyZXR1cm4gZ2V0Rm9ybWF0KHRoaXMsIFwieTJcIiwgdik7XHJcblx0fSxcclxuXHJcblx0ZGVmYXVsdFZhbHVlRm9ybWF0KHYpIHtcclxuXHRcdHJldHVybiBpc1ZhbHVlKHYpID8gK3YgOiBcIlwiO1xyXG5cdH0sXHJcblxyXG5cdGRlZmF1bHRBcmNWYWx1ZUZvcm1hdCh2LCByYXRpbykge1xyXG5cdFx0cmV0dXJuIGAkeyhyYXRpbyAqIDEwMCkudG9GaXhlZCgxKX0lYDtcclxuXHR9LFxyXG5cclxuXHRkYXRhTGFiZWxGb3JtYXQodGFyZ2V0SWQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGRhdGFMYWJlbHMgPSAkJC5jb25maWcuZGF0YV9sYWJlbHM7XHJcblx0XHRjb25zdCBkZWZhdWx0Rm9ybWF0ID0gdiA9PiAoaXNWYWx1ZSh2KSA/ICt2IDogXCJcIik7XHJcblx0XHRsZXQgZm9ybWF0ID0gZGVmYXVsdEZvcm1hdDtcclxuXHJcblx0XHQvLyBmaW5kIGZvcm1hdCBhY2NvcmRpbmcgdG8gYXhpcyBpZFxyXG5cdFx0aWYgKGlzRnVuY3Rpb24oZGF0YUxhYmVscy5mb3JtYXQpKSB7XHJcblx0XHRcdGZvcm1hdCA9IGRhdGFMYWJlbHMuZm9ybWF0O1xyXG5cdFx0fSBlbHNlIGlmIChpc09iamVjdFR5cGUoZGF0YUxhYmVscy5mb3JtYXQpKSB7XHJcblx0XHRcdGlmIChkYXRhTGFiZWxzLmZvcm1hdFt0YXJnZXRJZF0pIHtcclxuXHRcdFx0XHRmb3JtYXQgPSBkYXRhTGFiZWxzLmZvcm1hdFt0YXJnZXRJZF0gPT09IHRydWUgP1xyXG5cdFx0XHRcdFx0ZGVmYXVsdEZvcm1hdCA6IGRhdGFMYWJlbHMuZm9ybWF0W3RhcmdldElkXTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3JtYXQgPSAoKSA9PiBcIlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZvcm1hdDtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0c2VsZWN0QWxsIGFzIGQzU2VsZWN0QWxsXHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNBcnJheSwgaXNWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vLyBHcmlkIHBvc2l0aW9uIGFuZCB0ZXh0IGFuY2hvciBoZWxwZXJzXHJcbmNvbnN0IGdldEdyaWRUZXh0QW5jaG9yID0gZCA9PiBpc1ZhbHVlKGQucG9zaXRpb24pIHx8IFwiZW5kXCI7XHJcbmNvbnN0IGdldEdyaWRUZXh0RHggPSBkID0+IChkLnBvc2l0aW9uID09PSBcInN0YXJ0XCIgPyA0IDogKGQucG9zaXRpb24gPT09IFwibWlkZGxlXCIgPyAwIDogLTQpKTtcclxuY29uc3QgZ2V0R3JpZFRleHRYID0gKGlzWCwgd2lkdGgsIGhlaWdodCkgPT4gZCA9PiB7XHJcblx0bGV0IHggPSBpc1ggPyAwIDogd2lkdGg7XHJcblxyXG5cdGlmIChkLnBvc2l0aW9uID09PSBcInN0YXJ0XCIpIHtcclxuXHRcdHggPSBpc1ggPyAtaGVpZ2h0IDogMDtcclxuXHR9IGVsc2UgaWYgKGQucG9zaXRpb24gPT09IFwibWlkZGxlXCIpIHtcclxuXHRcdHggPSAoaXNYID8gLWhlaWdodCA6IHdpZHRoKSAvIDI7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4geDtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0R3JpZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5pbml0R3JpZExpbmVzKCk7XHJcblx0XHQkJC5pbml0Rm9jdXNHcmlkKCk7XHJcblx0fSxcclxuXHJcblx0aW5pdEdyaWRMaW5lcygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y2xpcH0sICRlbDoge2dyaWR9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcuZ3JpZF94X2xpbmVzLmxlbmd0aCB8fCBjb25maWcuZ3JpZF95X2xpbmVzLmxlbmd0aCkge1xyXG5cdFx0XHQkJC5ncmlkTGluZXMgPSAkJC4kZWwubWFpbi5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5jaGFydH0ke2NvbmZpZy5ncmlkX2xpbmVzX2Zyb250ID8gXCIgKyAqXCIgOiBcIlwifWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGlwLXBhdGhcIiwgY2xpcC5wYXRoR3JpZClcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGAke0NMQVNTLmdyaWR9ICR7Q0xBU1MuZ3JpZExpbmVzfWApO1xyXG5cclxuXHRcdFx0JCQuZ3JpZExpbmVzLmFwcGVuZChcImdcIikuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkTGluZXMpO1xyXG5cdFx0XHQkJC5ncmlkTGluZXMuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWRMaW5lcyk7XHJcblxyXG5cdFx0XHRncmlkLnhMaW5lcyA9IGQzU2VsZWN0QWxsKFtdKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVYR3JpZCh3aXRob3V0VXBkYXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZSwgc3RhdGUsICRlbDoge21haW4sIGdyaWR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHhncmlkRGF0YSA9ICQkLmdlbmVyYXRlR3JpZERhdGEoY29uZmlnLmdyaWRfeF90eXBlLCBzY2FsZS54KTtcclxuXHRcdGNvbnN0IHRpY2tPZmZzZXQgPSAkJC5pc0NhdGVnb3JpemVkKCkgPyAkJC5heGlzLngudGlja09mZnNldCgpIDogMDtcclxuXHRcdGNvbnN0IHBvcyA9IGQgPT4gKChzY2FsZS56b29tIHx8IHNjYWxlLngpKGQpICsgdGlja09mZnNldCkgKiAoaXNSb3RhdGVkID8gLTEgOiAxKTtcclxuXHJcblx0XHRzdGF0ZS54Z3JpZEF0dHIgPSBpc1JvdGF0ZWQgPyB7XHJcblx0XHRcdFwieDFcIjogMCxcclxuXHRcdFx0XCJ4MlwiOiBzdGF0ZS53aWR0aCxcclxuXHRcdFx0XCJ5MVwiOiBwb3MsXHJcblx0XHRcdFwieTJcIjogcG9zLFxyXG5cdFx0fSA6IHtcclxuXHRcdFx0XCJ4MVwiOiBwb3MsXHJcblx0XHRcdFwieDJcIjogcG9zLFxyXG5cdFx0XHRcInkxXCI6IDAsXHJcblx0XHRcdFwieTJcIjogc3RhdGUuaGVpZ2h0LFxyXG5cdFx0fTtcclxuXHJcblx0XHRncmlkLnggPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueGdyaWRzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnhncmlkfWApXHJcblx0XHRcdC5kYXRhKHhncmlkRGF0YSk7XHJcblxyXG5cdFx0Z3JpZC54LmV4aXQoKS5yZW1vdmUoKTtcclxuXHJcblx0XHRncmlkLnggPSBncmlkLnguZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnhncmlkKVxyXG5cdFx0XHQubWVyZ2UoZ3JpZC54KTtcclxuXHJcblx0XHRpZiAoIXdpdGhvdXRVcGRhdGUpIHtcclxuXHRcdFx0Z3JpZC54LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgZ3JpZCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cclxuXHRcdFx0XHRPYmplY3Qua2V5cyhzdGF0ZS54Z3JpZEF0dHIpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRcdFx0Z3JpZC5hdHRyKGlkLCBzdGF0ZS54Z3JpZEF0dHJbaWRdKVxyXG5cdFx0XHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICgpID0+IChcclxuXHRcdFx0XHRcdFx0XHRncmlkLmF0dHIoaXNSb3RhdGVkID8gXCJ5MVwiIDogXCJ4MVwiKSA9PT0gKGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCA6IDApID9cclxuXHRcdFx0XHRcdFx0XHRcdFwiMFwiIDogXCIxXCJcclxuXHRcdFx0XHRcdFx0KSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVlHcmlkKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge2dyaWQsIG1haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGdyaWRWYWx1ZXMgPSAkJC5heGlzLnkudGlja1ZhbHVlcygpIHx8ICQkLnNjYWxlLnkudGlja3MoY29uZmlnLmdyaWRfeV90aWNrcyk7XHJcblx0XHRjb25zdCBwb3MgPSBkID0+IE1hdGguY2VpbCgkJC5zY2FsZS55KGQpKTtcclxuXHJcblx0XHRncmlkLnkgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MueWdyaWRzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnlncmlkfWApXHJcblx0XHRcdC5kYXRhKGdyaWRWYWx1ZXMpO1xyXG5cclxuXHRcdGdyaWQueS5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Z3JpZC55ID0gZ3JpZC55XHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueWdyaWQpXHJcblx0XHRcdC5tZXJnZShncmlkLnkpO1xyXG5cclxuXHRcdGdyaWQueS5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gcG9zIDogMClcclxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyBwb3MgOiBzdGF0ZS53aWR0aClcclxuXHRcdFx0LmF0dHIoXCJ5MVwiLCBpc1JvdGF0ZWQgPyAwIDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCA6IHBvcyk7XHJcblxyXG5cdFx0JCQuc21vb3RoTGluZXMoZ3JpZC55LCBcImdyaWRcIik7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlR3JpZChkdXJhdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCEkJC5ncmlkTGluZXMgJiYgJCQuaW5pdEdyaWRMaW5lcygpO1xyXG5cclxuXHRcdC8vIGhpZGUgaWYgYXJjIHR5cGVcclxuXHRcdCQkLiRlbC5ncmlkLm1haW4uc3R5bGUoXCJ2aXNpYmlsaXR5XCIsICQkLmhhc0FyY1R5cGUoKSA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIik7XHJcblxyXG5cdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cdFx0JCQudXBkYXRlWEdyaWRMaW5lcyhkdXJhdGlvbik7XHJcblx0XHQkJC51cGRhdGVZR3JpZExpbmVzKGR1cmF0aW9uKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgWCBHcmlkIGxpbmVzXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGR1cmF0aW9uXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVYR3JpZExpbmVzKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cclxuXHRcdGNvbmZpZy5ncmlkX3hfc2hvdyAmJiAkJC51cGRhdGVYR3JpZCgpO1xyXG5cclxuXHRcdGxldCB4TGluZXMgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnhncmlkTGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueGdyaWRMaW5lfWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5ncmlkX3hfbGluZXMpO1xyXG5cclxuXHRcdC8vIGV4aXRcclxuXHRcdHhMaW5lcy5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdC8vIGVudGVyXHJcblx0XHRjb25zdCB4Z3JpZExpbmUgPSB4TGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdHhncmlkTGluZS5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHhncmlkTGluZS5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGlzUm90YXRlZCA/IFwiXCIgOiBcInJvdGF0ZSgtOTApXCIpXHJcblx0XHRcdC5hdHRyKFwiZHlcIiwgLTUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHhMaW5lcyA9IHhncmlkTGluZS5tZXJnZSh4TGluZXMpO1xyXG5cclxuXHRcdHhMaW5lc1xyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gYCR7Q0xBU1MueGdyaWRMaW5lfSAke2QuY2xhc3MgfHwgXCJcIn1gLnRyaW0oKSlcclxuXHRcdFx0LnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBnZXRHcmlkVGV4dEFuY2hvcilcclxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnRleHQoZCA9PiBkLnRleHQpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblxyXG5cdFx0JGVsLmdyaWQueExpbmVzID0geExpbmVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBZIEdyaWQgbGluZXNcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZHVyYXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVlHcmlkTGluZXMoZHVyYXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7d2lkdGgsIGhlaWdodH0sICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uZmlnLmdyaWRfeV9zaG93ICYmICQkLnVwZGF0ZVlHcmlkKCk7XHJcblxyXG5cdFx0bGV0IHlncmlkTGluZXMgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnlncmlkTGluZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MueWdyaWRMaW5lfWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5ncmlkX3lfbGluZXMpO1xyXG5cclxuXHRcdC8vIGV4aXRcclxuXHRcdHlncmlkTGluZXMuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0Ly8gZW50ZXJcclxuXHRcdGNvbnN0IHlncmlkTGluZSA9IHlncmlkTGluZXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xyXG5cclxuXHRcdHlncmlkTGluZS5hcHBlbmQoXCJsaW5lXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHlncmlkTGluZS5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGlzUm90YXRlZCA/IFwicm90YXRlKC05MClcIiA6IFwiXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpO1xyXG5cclxuXHRcdHlncmlkTGluZXMgPSB5Z3JpZExpbmUubWVyZ2UoeWdyaWRMaW5lcyk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlXHJcblx0XHRjb25zdCB5diA9ICQkLnl2LmJpbmQoJCQpO1xyXG5cclxuXHRcdHlncmlkTGluZXNcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAke0NMQVNTLnlncmlkTGluZX0gJHtkLmNsYXNzIHx8IFwiXCJ9YC50cmltKCkpXHJcblx0XHRcdC5zZWxlY3QoXCJsaW5lXCIpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IHl2IDogMClcclxuXHRcdFx0LmF0dHIoXCJ4MlwiLCBpc1JvdGF0ZWQgPyB5diA6IHdpZHRoKVxyXG5cdFx0XHQuYXR0cihcInkxXCIsIGlzUm90YXRlZCA/IDAgOiB5dilcclxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyBoZWlnaHQgOiB5dilcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKTtcclxuXHJcblx0XHR5Z3JpZExpbmVzLnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBnZXRHcmlkVGV4dEFuY2hvcilcclxuXHRcdFx0LmF0dHIoXCJkeFwiLCBnZXRHcmlkVGV4dER4KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LmF0dHIoXCJkeVwiLCAtNSlcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIGdldEdyaWRUZXh0WChpc1JvdGF0ZWQsIHdpZHRoLCBoZWlnaHQpKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeXYpXHJcblx0XHRcdC50ZXh0KGQgPT4gZC50ZXh0KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpO1xyXG5cclxuXHRcdCRlbC5ncmlkLnlMaW5lcyA9IHlncmlkTGluZXM7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3R3JpZCh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge1xyXG5cdFx0XHRjb25maWc6IHtheGlzX3JvdGF0ZWQ6IGlzUm90YXRlZH0sXHJcblx0XHRcdHN0YXRlOiB7d2lkdGgsIGhlaWdodH0sXHJcblx0XHRcdCRlbDoge2dyaWR9XHJcblx0XHR9ID0gJCQ7XHJcblx0XHRjb25zdCB4diA9ICQkLnh2LmJpbmQoJCQpO1xyXG5cclxuXHRcdGxldCBsaW5lcyA9IGdyaWQueExpbmVzLnNlbGVjdChcImxpbmVcIik7XHJcblx0XHRsZXQgdGV4dHMgPSBncmlkLnhMaW5lcy5zZWxlY3QoXCJ0ZXh0XCIpO1xyXG5cclxuXHRcdGxpbmVzID0gKHdpdGhUcmFuc2l0aW9uID8gbGluZXMudHJhbnNpdGlvbigpIDogbGluZXMpXHJcblx0XHRcdC5hdHRyKFwieDFcIiwgaXNSb3RhdGVkID8gMCA6IHh2KVxyXG5cdFx0XHQuYXR0cihcIngyXCIsIGlzUm90YXRlZCA/IHdpZHRoIDogeHYpXHJcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8geHYgOiAwKVxyXG5cdFx0XHQuYXR0cihcInkyXCIsIGlzUm90YXRlZCA/IHh2IDogaGVpZ2h0KTtcclxuXHJcblx0XHR0ZXh0cyA9ICh3aXRoVHJhbnNpdGlvbiA/IHRleHRzLnRyYW5zaXRpb24oKSA6IHRleHRzKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgZ2V0R3JpZFRleHRYKCFpc1JvdGF0ZWQsIHdpZHRoLCBoZWlnaHQpKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeHYpXHJcblx0XHRcdC50ZXh0KGQgPT4gZC50ZXh0KTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBsaW5lcy50cmFuc2l0aW9uKCkgOiBsaW5lcykuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKSxcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpLnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0aW5pdEZvY3VzR3JpZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7Y2xpcH0sICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGlzRnJvbnQgPSBjb25maWcuZ3JpZF9mcm9udDtcclxuXHRcdGNvbnN0IGNsYXNzTmFtZSA9IGAuJHtDTEFTU1tpc0Zyb250ICYmICQkLmdyaWRMaW5lcyA/IFwiZ3JpZExpbmVzXCIgOiBcImNoYXJ0XCJdfSR7aXNGcm9udCA/IFwiICsgKlwiIDogXCJcIn1gO1xyXG5cclxuXHRcdGNvbnN0IGdyaWQgPSAkZWwuZ3JpZC5tYWluID0gJGVsLm1haW4uaW5zZXJ0KFwiZ1wiLCBjbGFzc05hbWUpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIGNsaXAucGF0aEdyaWQpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuZ3JpZCk7XHJcblxyXG5cdFx0Y29uZmlnLmdyaWRfeF9zaG93ICYmXHJcblx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRzKTtcclxuXHJcblx0XHRjb25maWcuZ3JpZF95X3Nob3cgJiZcclxuXHRcdFx0Z3JpZC5hcHBlbmQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZHMpO1xyXG5cclxuXHRcdGlmIChjb25maWcuZ3JpZF9mb2N1c19zaG93KSB7XHJcblx0XHRcdGdyaWQuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cylcclxuXHRcdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MueGdyaWRGb2N1cyk7XHJcblxyXG5cdFx0XHQvLyB0byBzaG93IHh5IGZvY3VzIGdyaWQgbGluZSwgc2hvdWxkIGJlICd0b29sdGlwLmdyb3VwZWQ9ZmFsc2UnXHJcblx0XHRcdGlmIChjb25maWcuZ3JpZF9mb2N1c195ICYmICFjb25maWcudG9vbHRpcF9ncm91cGVkKSB7XHJcblx0XHRcdFx0Z3JpZC5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnlncmlkRm9jdXMpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy55Z3JpZEZvY3VzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNob3cgZ3JpZCBmb2N1cyBsaW5lXHJcblx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWREYXRhXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRzaG93R3JpZEZvY3VzKHNlbGVjdGVkRGF0YSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aWR0aCwgaGVpZ2h0fX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBkYXRhVG9TaG93ID0gc2VsZWN0ZWREYXRhLmZpbHRlcihkID0+IGQgJiYgaXNWYWx1ZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcclxuXHJcblx0XHQvLyBIaWRlIHdoZW4gYnViYmxlL3NjYXR0ZXIvc3RhbmZvcmQgcGxvdCBleGlzdHNcclxuXHRcdGlmICghY29uZmlnLnRvb2x0aXBfc2hvdyB8fCBkYXRhVG9TaG93Lmxlbmd0aCA9PT0gMCB8fCAkJC5oYXNUeXBlKFwiYnViYmxlXCIpIHx8ICQkLmhhc0FyY1R5cGUoKSkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZm9jdXNFbCA9ICQkLiRlbC5tYWluLnNlbGVjdEFsbChgbGluZS4ke0NMQVNTLnhncmlkRm9jdXN9LCBsaW5lLiR7Q0xBU1MueWdyaWRGb2N1c31gKTtcclxuXHRcdGNvbnN0IGlzRWRnZSA9IGNvbmZpZy5ncmlkX2ZvY3VzX2VkZ2UgJiYgIWNvbmZpZy50b29sdGlwX2dyb3VwZWQ7XHJcblx0XHRjb25zdCB4eCA9ICQkLnh4LmJpbmQoJCQpO1xyXG5cclxuXHRcdGZvY3VzRWxcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIilcclxuXHRcdFx0LmRhdGEoZGF0YVRvU2hvdy5jb25jYXQoZGF0YVRvU2hvdykpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBlbCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdGNvbnN0IHBvcyA9IHtcclxuXHRcdFx0XHRcdHg6IHh4KGQpLFxyXG5cdFx0XHRcdFx0eTogJCQuZ2V0WVNjYWxlKGQuaWQpKGQudmFsdWUpXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRsZXQgeHk7XHJcblxyXG5cdFx0XHRcdGlmIChlbC5jbGFzc2VkKENMQVNTLnhncmlkRm9jdXMpKSB7XHJcblx0XHRcdFx0XHQvLyB3aWxsIGNvbnRhaW4gJ3gxLCB5MSwgeDIsIHkyJyBvcmRlclxyXG5cdFx0XHRcdFx0eHkgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFx0XHRbXHJcblx0XHRcdFx0XHRcdFx0bnVsbCwgLy8geDFcclxuXHRcdFx0XHRcdFx0XHRwb3MueCwgLy8geTFcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgPyBwb3MueSA6IHdpZHRoLCAvLyB4MlxyXG5cdFx0XHRcdFx0XHRcdHBvcy54IC8vIHkyXHJcblx0XHRcdFx0XHRcdF0gOiBbXHJcblx0XHRcdFx0XHRcdFx0cG9zLngsXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlID8gcG9zLnkgOiBudWxsLFxyXG5cdFx0XHRcdFx0XHRcdHBvcy54LFxyXG5cdFx0XHRcdFx0XHRcdGhlaWdodFxyXG5cdFx0XHRcdFx0XHRdO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb25zdCBpc1kyID0gJCQuYXhpcy5nZXRJZChkLmlkKSA9PT0gXCJ5MlwiO1xyXG5cclxuXHRcdFx0XHRcdHh5ID0gaXNSb3RhdGVkID9cclxuXHRcdFx0XHRcdFx0W1xyXG5cdFx0XHRcdFx0XHRcdHBvcy55LCAvLyB4MVxyXG5cdFx0XHRcdFx0XHRcdGlzRWRnZSAmJiAhaXNZMiA/IHBvcy54IDogbnVsbCwgLy8geTFcclxuXHRcdFx0XHRcdFx0XHRwb3MueSwgLy8geDJcclxuXHRcdFx0XHRcdFx0XHRpc0VkZ2UgJiYgaXNZMiA/IHBvcy54IDogaGVpZ2h0IC8vIHkyXHJcblx0XHRcdFx0XHRcdF0gOiBbXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlICYmIGlzWTIgPyBwb3MueCA6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0cG9zLnksXHJcblx0XHRcdFx0XHRcdFx0aXNFZGdlICYmICFpc1kyID8gcG9zLnggOiB3aWR0aCxcclxuXHRcdFx0XHRcdFx0XHRwb3MueVxyXG5cdFx0XHRcdFx0XHRdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0W1wieDFcIiwgXCJ5MVwiLCBcIngyXCIsIFwieTJcIl1cclxuXHRcdFx0XHRcdC5mb3JFYWNoKCh2LCBpKSA9PiBlbC5hdHRyKHYsIHh5W2ldKSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdCQkLnNtb290aExpbmVzKGZvY3VzRWwsIFwiZ3JpZFwiKTtcclxuXHR9LFxyXG5cclxuXHRoaWRlR3JpZEZvY3VzKCkge1xyXG5cdFx0dGhpcy4kZWwubWFpbi5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy54Z3JpZEZvY3VzfSwgbGluZS4ke0NMQVNTLnlncmlkRm9jdXN9YClcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVncmlkRm9jdXMoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSAkJC5zdGF0ZTtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGBsaW5lLiR7Q0xBU1MueGdyaWRGb2N1c31gKVxyXG5cdFx0XHQuYXR0cihcIngxXCIsIGlzUm90YXRlZCA/IDAgOiAtMTApXHJcblx0XHRcdC5hdHRyKFwieDJcIiwgaXNSb3RhdGVkID8gd2lkdGggOiAtMTApXHJcblx0XHRcdC5hdHRyKFwieTFcIiwgaXNSb3RhdGVkID8gLTEwIDogMClcclxuXHRcdFx0LmF0dHIoXCJ5MlwiLCBpc1JvdGF0ZWQgPyAtMTAgOiBoZWlnaHQpO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR3JpZERhdGEodHlwZSwgc2NhbGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHRpY2tOdW0gPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmF4aXNYfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoXCIudGlja1wiKVxyXG5cdFx0XHQuc2l6ZSgpO1xyXG5cdFx0bGV0IGdyaWREYXRhOiBEYXRlW10gPSBbXTtcclxuXHJcblx0XHRpZiAodHlwZSA9PT0gXCJ5ZWFyXCIpIHtcclxuXHRcdFx0Y29uc3QgeERvbWFpbiA9ICQkLmdldFhEb21haW4oKTtcclxuXHRcdFx0Y29uc3QgZmlyc3RZZWFyID0geERvbWFpblswXS5nZXRGdWxsWWVhcigpO1xyXG5cdFx0XHRjb25zdCBsYXN0WWVhciA9IHhEb21haW5bMV0uZ2V0RnVsbFllYXIoKTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSBmaXJzdFllYXI7IGkgPD0gbGFzdFllYXI7IGkrKykge1xyXG5cdFx0XHRcdGdyaWREYXRhLnB1c2gobmV3IERhdGUoYCR7aX0tMDEtMDEgMDA6MDA6MDBgKSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGdyaWREYXRhID0gc2NhbGUudGlja3MoMTApO1xyXG5cclxuXHRcdFx0aWYgKGdyaWREYXRhLmxlbmd0aCA+IHRpY2tOdW0pIHsgLy8gdXNlIG9ubHkgaW50XHJcblx0XHRcdFx0Z3JpZERhdGEgPSBncmlkRGF0YS5maWx0ZXIoZCA9PiBTdHJpbmcoZCkuaW5kZXhPZihcIi5cIikgPCAwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBncmlkRGF0YTtcclxuXHR9LFxyXG5cclxuXHRnZXRHcmlkRmlsdGVyVG9SZW1vdmUocGFyYW1zKSB7XHJcblx0XHRyZXR1cm4gcGFyYW1zID8gbGluZSA9PiB7XHJcblx0XHRcdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuXHRcdFx0KGlzQXJyYXkocGFyYW1zKSA/IHBhcmFtcy5jb25jYXQoKSA6IFtwYXJhbXNdKS5mb3JFYWNoKHBhcmFtID0+IHtcclxuXHRcdFx0XHRpZiAoKChcInZhbHVlXCIgaW4gcGFyYW0gJiYgbGluZS52YWx1ZSA9PT0gcGFyYW0udmFsdWUpIHx8IChcImNsYXNzXCIgaW4gcGFyYW0gJiYgbGluZS5jbGFzcyA9PT0gcGFyYW0uY2xhc3MpKSkge1xyXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gZm91bmQ7XHJcblx0XHR9IDogKCkgPT4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVHcmlkTGluZXMocGFyYW1zLCBmb3JYKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdG9SZW1vdmUgPSAkJC5nZXRHcmlkRmlsdGVyVG9SZW1vdmUocGFyYW1zKTtcclxuXHRcdGNvbnN0IHRvU2hvdyA9IGxpbmUgPT4gIXRvUmVtb3ZlKGxpbmUpO1xyXG5cdFx0Y29uc3QgY2xhc3NMaW5lcyA9IGZvclggPyBDTEFTUy54Z3JpZExpbmVzIDogQ0xBU1MueWdyaWRMaW5lcztcclxuXHRcdGNvbnN0IGNsYXNzTGluZSA9IGZvclggPyBDTEFTUy54Z3JpZExpbmUgOiBDTEFTUy55Z3JpZExpbmU7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGAuJHtjbGFzc0xpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke2NsYXNzTGluZX1gKVxyXG5cdFx0XHQuZmlsdGVyKHRvUmVtb3ZlKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdGNvbnN0IGdyaWRMaW5lcyA9IGBncmlkXyR7Zm9yWCA/IFwieFwiIDogXCJ5XCJ9X2xpbmVzYDtcclxuXHJcblx0XHRjb25maWdbZ3JpZExpbmVzXSA9IGNvbmZpZ1tncmlkTGluZXNdLmZpbHRlcih0b1Nob3cpO1xyXG5cdH0sXHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3QsXHJcblx0ZXZlbnQgYXMgZDNFdmVudCxcclxuXHRuYW1lc3BhY2VzIGFzIGQzTmFtZXNwYWNlc1xyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGlzRGVmaW5lZCwgZ2V0T3B0aW9uLCBpc0VtcHR5LCBpc0Z1bmN0aW9uLCBub3RFbXB0eSwgdHBsUHJvY2Vzc30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZSB0aGUgbGVnZW5kLlxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdExlZ2VuZCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHQkJC5sZWdlbmRJdGVtVGV4dEJveCA9IHt9O1xyXG5cdFx0JCQuc3RhdGUubGVnZW5kSGFzUmVuZGVyZWQgPSBmYWxzZTtcclxuXHRcdCRlbC5sZWdlbmQgPSAkJC4kZWwuc3ZnLmFwcGVuZChcImdcIik7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHQkZWwubGVnZW5kLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibGVnZW5kXCIpKTtcclxuXHJcblx0XHRcdC8vIE1FTU86IGNhbGwgaGVyZSB0byB1cGRhdGUgbGVnZW5kIGJveCBhbmQgdHJhbnNsYXRlIGZvciBhbGxcclxuXHRcdFx0Ly8gTUVNTzogdHJhbnNsYXRlIHdpbGwgYmUgdXBkYXRlZCBieSB0aGlzLCBzbyB0cmFuc2Zvcm0gbm90IG5lZWRlZCBpbiB1cGRhdGVMZWdlbmQoKVxyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmQoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLiRlbC5sZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG5cdFx0XHQkJC5zdGF0ZS5oaWRkZW5MZWdlbmRJZHMgPSAkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbnMgUmV0dXJuIHZhbHVlIG9mIHRoZSBnZW5lcmF0ZVRyYW5zaXRpb25zXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmQodGFyZ2V0SWRzLCBvcHRpb25zLCB0cmFuc2l0aW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBvcHRpb256ID0gb3B0aW9ucyB8fCB7XHJcblx0XHRcdHdpdGhUcmFuc2Zvcm06IGZhbHNlLFxyXG5cdFx0XHR3aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybTogZmFsc2UsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBmYWxzZVxyXG5cdFx0fTtcclxuXHJcblx0XHRvcHRpb256LndpdGhUcmFuc2l0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnosIFwid2l0aFRyYW5zaXRpb25cIiwgdHJ1ZSk7XHJcblx0XHRvcHRpb256LndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnosIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfY29udGVudHNfYmluZHRvICYmIGNvbmZpZy5sZWdlbmRfY29udGVudHNfdGVtcGxhdGUpIHtcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kVGVtcGxhdGUoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLnVwZGF0ZUxlZ2VuZEVsZW1lbnQoXHJcblx0XHRcdFx0dGFyZ2V0SWRzIHx8ICQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyksXHJcblx0XHRcdFx0b3B0aW9ueixcclxuXHRcdFx0XHR0cmFuc2l0aW9uc1xyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRvZ2dsZSBsZWdlbmQgc3RhdGVcclxuXHRcdCQkLiRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4sIGlkID0+ICEkJC5pc1RhcmdldFRvU2hvdyhpZCkpO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBzaXplIGFuZCBzY2FsZVxyXG5cdFx0JCQudXBkYXRlU2NhbGVzKGZhbHNlLCAhc2NhbGUuem9vbSk7XHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGcgcG9zaXRpb25zXHJcblx0XHQkJC50cmFuc2Zvcm1BbGwob3B0aW9uei53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSwgdHJhbnNpdGlvbnMpO1xyXG5cclxuXHRcdCQkLnN0YXRlLmxlZ2VuZEhhc1JlbmRlcmVkID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIHVzaW5nIHRlbXBsYXRlIG9wdGlvblxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kVGVtcGxhdGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3Qgd3JhcHBlciA9IGQzU2VsZWN0KGNvbmZpZy5sZWdlbmRfY29udGVudHNfYmluZHRvKTtcclxuXHRcdGNvbnN0IHRlbXBsYXRlID0gY29uZmlnLmxlZ2VuZF9jb250ZW50c190ZW1wbGF0ZTtcclxuXHJcblx0XHRpZiAoIXdyYXBwZXIuZW1wdHkoKSkge1xyXG5cdFx0XHRjb25zdCB0YXJnZXRzID0gJCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKTtcclxuXHRcdFx0Y29uc3QgaWRzOiBhbnlbXSA9IFtdO1xyXG5cdFx0XHRsZXQgaHRtbCA9IFwiXCI7XHJcblxyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY29udGVudCA9IGlzRnVuY3Rpb24odGVtcGxhdGUpID9cclxuXHRcdFx0XHRcdHRlbXBsYXRlLmNhbGwoJCQsIHYsICQkLmNvbG9yKHYpLCAkJC5hcGkuZGF0YSh2KVswXS52YWx1ZXMpIDpcclxuXHRcdFx0XHRcdHRwbFByb2Nlc3ModGVtcGxhdGUsIHtcclxuXHRcdFx0XHRcdFx0Q09MT1I6ICQkLmNvbG9yKHYpLFxyXG5cdFx0XHRcdFx0XHRUSVRMRTogdlxyXG5cdFx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdGlmIChjb250ZW50KSB7XHJcblx0XHRcdFx0XHRpZHMucHVzaCh2KTtcclxuXHRcdFx0XHRcdGh0bWwgKz0gY29udGVudDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uc3QgbGVnZW5kSXRlbSA9IHdyYXBwZXIuaHRtbChodG1sKVxyXG5cdFx0XHRcdC5zZWxlY3RBbGwoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNoaWxkTm9kZXM7IH0pXHJcblx0XHRcdFx0LmRhdGEoaWRzKTtcclxuXHJcblx0XHRcdCQkLnNldExlZ2VuZEl0ZW0obGVnZW5kSXRlbSk7XHJcblxyXG5cdFx0XHQkJC4kZWwubGVnZW5kID0gd3JhcHBlcjtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIHNpemUgb2YgdGhlIGxlZ2VuZC5cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JlamN0fSBzaXplIFNcclxuXHQgKi9cclxuXHR1cGRhdGVTaXplRm9yTGVnZW5kKHNpemUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7XHJcblx0XHRcdGlzTGVnZW5kVG9wLCBpc0xlZ2VuZExlZnQsIGlzTGVnZW5kUmlnaHQsIGlzTGVnZW5kSW5zZXQsIGN1cnJlbnRXaWR0aCwgY3VycmVudEhlaWdodFxyXG5cdFx0fX0gPSAkJDtcclxuXHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNpemU7XHJcblxyXG5cdFx0Y29uc3QgaW5zZXRMZWdlbmRQb3NpdGlvbiA9IHtcclxuXHRcdFx0dG9wOiBpc0xlZ2VuZFRvcCA/XHJcblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdUb3AoKSArIGNvbmZpZy5sZWdlbmRfaW5zZXRfeSArIDUuNSA6XHJcblx0XHRcdFx0Y3VycmVudEhlaWdodCAtIGhlaWdodCAtICQkLmdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkgLSBjb25maWcubGVnZW5kX2luc2V0X3ksXHJcblx0XHRcdGxlZnQ6IGlzTGVnZW5kTGVmdCA/XHJcblx0XHRcdFx0JCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkgKyBjb25maWcubGVnZW5kX2luc2V0X3ggKyAwLjUgOlxyXG5cdFx0XHRcdGN1cnJlbnRXaWR0aCAtIHdpZHRoIC0gJCQuZ2V0Q3VycmVudFBhZGRpbmdSaWdodCgpIC0gY29uZmlnLmxlZ2VuZF9pbnNldF94ICsgMC41XHJcblx0XHR9O1xyXG5cclxuXHRcdCQkLnN0YXRlLm1hcmdpbjMgPSB7XHJcblx0XHRcdHRvcDogaXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0MCA6IGlzTGVnZW5kSW5zZXQgPyBpbnNldExlZ2VuZFBvc2l0aW9uLnRvcCA6IGN1cnJlbnRIZWlnaHQgLSBoZWlnaHQsXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0bGVmdDogaXNMZWdlbmRSaWdodCA/XHJcblx0XHRcdFx0Y3VycmVudFdpZHRoIC0gd2lkdGggOiBpc0xlZ2VuZEluc2V0ID8gaW5zZXRMZWdlbmRQb3NpdGlvbi5sZWZ0IDogMFxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUcmFuc2Zvcm0gTGVnZW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRvIHRyYW5zaXRpb24uXHJcblx0ICovXHJcblx0dHJhbnNmb3JtTGVnZW5kKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bGVnZW5kfSA9ICQkLiRlbDtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyBsZWdlbmQudHJhbnNpdGlvbigpIDogbGVnZW5kKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJsZWdlbmRcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0aGUgbGVnZW5kIHN0ZXBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzdGVwXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kU3RlcChzdGVwKSB7XHJcblx0XHR0aGlzLnN0YXRlLmxlZ2VuZFN0ZXAgPSBzdGVwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSB3aWR0aFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kSXRlbVdpZHRoKHcpIHtcclxuXHRcdHRoaXMuc3RhdGUubGVnZW5kSXRlbVdpZHRoID0gdztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgbGVnZW5kIGl0ZW0gaGVpZ2h0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XHJcblx0ICovXHJcblx0dXBkYXRlTGVnZW5kSXRlbUhlaWdodChoKSB7XHJcblx0XHR0aGlzLnN0YXRlLmxlZ2VuZEl0ZW1IZWlnaHQgPSBoO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBsZWdlbmQgaXRlbSBjb2xvclxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlkIENvcnJlc3BvbmRpbmcgZGF0YSBJRCB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjb2xvciBDb2xvciB2YWx1ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcihpZCwgY29sb3IpIHtcclxuXHRcdHRoaXMuJGVsLmxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19LSR7aWR9IGxpbmVgKVxyXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgY29sb3IpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgd2lkdGggb2YgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSB3aWR0aFxyXG5cdCAqL1xyXG5cdGdldExlZ2VuZFdpZHRoKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2N1cnJlbnRXaWR0aCwgaXNMZWdlbmRSaWdodCwgaXNMZWdlbmRJbnNldCwgbGVnZW5kSXRlbVdpZHRoLCBsZWdlbmRTdGVwfSA9ICQkLnN0YXRlO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcubGVnZW5kX3Nob3cgPyAoXHJcblx0XHRcdGlzTGVnZW5kUmlnaHQgfHwgaXNMZWdlbmRJbnNldCA/XHJcblx0XHRcdFx0bGVnZW5kSXRlbVdpZHRoICogKGxlZ2VuZFN0ZXAgKyAxKSA6IGN1cnJlbnRXaWR0aFxyXG5cdFx0KSA6IDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBoZWlnaHQgb2YgdGhlIGxlZ2VuZFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gaGVpZ2h0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRMZWdlbmRIZWlnaHQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y3VycmVudEhlaWdodCwgaXNMZWdlbmRSaWdodCwgbGVnZW5kSXRlbUhlaWdodCwgbGVnZW5kU3RlcH0gPSAkJC5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gJCQuY29uZmlnLmxlZ2VuZF9zaG93ID8gKFxyXG5cdFx0XHRpc0xlZ2VuZFJpZ2h0ID9cclxuXHRcdFx0XHRjdXJyZW50SGVpZ2h0IDogTWF0aC5tYXgoMjAsIGxlZ2VuZEl0ZW1IZWlnaHQpICogKGxlZ2VuZFN0ZXAgKyAxKVxyXG5cdFx0KSA6IDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkMy5TZWxlY3RcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBvcGFjaXR5XHJcblx0ICovXHJcblx0b3BhY2l0eUZvckxlZ2VuZChsZWdlbmRJdGVtKSB7XHJcblx0XHRyZXR1cm4gbGVnZW5kSXRlbS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1IaWRkZW4pID8gbnVsbCA6IFwiMVwiO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgb3BhY2l0eSBvZiB0aGUgbGVnZW5kIHRoYXQgaXMgdW5mb2N1c2VkXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGVnZW5kSXRlbSwgZDMuU2VsZWN0XHJcblx0ICogQHJldHVybnMge051bWJlcn0gb3BhY2l0eVxyXG5cdCAqL1xyXG5cdG9wYWNpdHlGb3JVbmZvY3VzZWRMZWdlbmQobGVnZW5kSXRlbSkge1xyXG5cdFx0cmV0dXJuIGxlZ2VuZEl0ZW0uY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtSGlkZGVuKSA/IG51bGwgOiBcIjAuM1wiO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIGZvY3VzIG9mIHRoZSBsZWdlbmRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IElEJ3Mgb2YgdGFyZ2V0XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byBmb2N1cy5cclxuXHQgKi9cclxuXHR0b2dnbGVGb2N1c0xlZ2VuZCh0YXJnZXRJZHMsIGZvY3VzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0YXJnZXRJZHogPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdCQkLiRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdC5maWx0ZXIoaWQgPT4gdGFyZ2V0SWR6LmluZGV4T2YoaWQpID49IDApXHJcblx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmb2N1cylcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oMTAwKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAoZm9jdXMgPyAkJC5vcGFjaXR5Rm9yTGVnZW5kIDogJCQub3BhY2l0eUZvclVuZm9jdXNlZExlZ2VuZClcclxuXHRcdFx0XHRcdC5jYWxsKCQkLCBkM1NlbGVjdCh0aGlzKSk7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldmVydCB0aGUgbGVnZW5kIHRvIGl0cyBkZWZhdWx0IHN0YXRlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyZXZlcnRMZWdlbmQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLmxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIGZhbHNlKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICQkLm9wYWNpdHlGb3JMZWdlbmQoZDNTZWxlY3QodGhpcykpO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTaG93cyB0aGUgbGVnZW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxyXG5cdCAqL1xyXG5cdHNob3dMZWdlbmQodGFyZ2V0SWRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cclxuXHRcdGlmICghY29uZmlnLmxlZ2VuZF9zaG93KSB7XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IHRydWU7XHJcblx0XHRcdGxlZ2VuZC5zdHlsZShcInZpc2liaWxpdHlcIiwgXCJ2aXNpYmxlXCIpO1xyXG5cclxuXHRcdFx0ISQkLnN0YXRlLmxlZ2VuZEhhc1JlbmRlcmVkICYmICQkLnVwZGF0ZUxlZ2VuZCgpO1xyXG5cdFx0fVxyXG5cdFx0JCQucmVtb3ZlSGlkZGVuTGVnZW5kSWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0bGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSlcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcInZpc2libGVcIilcclxuXHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAkJC5vcGFjaXR5Rm9yTGVnZW5kKGQzU2VsZWN0KHRoaXMpKTtcclxuXHRcdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSB0aGUgbGVnZW5kXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0FycmF5fSBJRCdzIG9mIHRhcmdldFxyXG5cdCAqL1xyXG5cdGhpZGVMZWdlbmQodGFyZ2V0SWRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHtsZWdlbmR9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgaXNFbXB0eSh0YXJnZXRJZHMpKSB7XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfc2hvdyA9IGZhbHNlO1xyXG5cdFx0XHRsZWdlbmQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIFwiaGlkZGVuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyh0YXJnZXRJZHMpO1xyXG5cdFx0bGVnZW5kLnNlbGVjdEFsbCgkJC5zZWxlY3RvckxlZ2VuZHModGFyZ2V0SWRzKSlcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDbGVhciB0aGUgTGVnZW5kSXRlbVRleHRCb3ggY2FjaGUuXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjbGVhckxlZ2VuZEl0ZW1UZXh0Qm94Y2FjaGUoKSB7XHJcblx0XHR0aGlzLmxlZ2VuZEl0ZW1UZXh0Qm94ID0ge307XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGxlZ2VuZCBpdGVtIHN0eWxlICYgYmluZCBldmVudHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7ZDMuc2VsZWN0aW9ufSBpdGVtXHJcblx0ICovXHJcblx0c2V0TGVnZW5kSXRlbShpdGVtKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cclxuXHRcdGl0ZW1cclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBmdW5jdGlvbihpZCkge1xyXG5cdFx0XHRcdGNvbnN0IG5vZGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpdGVtQ2xhc3MgPSAoIW5vZGUuZW1wdHkoKSAmJiBub2RlLmF0dHIoXCJjbGFzc1wiKSkgfHwgXCJcIjtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGl0ZW1DbGFzcyArICQkLmdlbmVyYXRlQ2xhc3MoQ0xBU1MubGVnZW5kSXRlbSwgaWQpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGlkID0+ICgkJC5pc0xlZ2VuZFRvU2hvdyhpZCkgPyBcInZpc2libGVcIiA6IFwiaGlkZGVuXCIpKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgXCJwb2ludGVyXCIpXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGlkID0+IHtcclxuXHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25jbGljaywgJCQsIGlkKSkge1xyXG5cdFx0XHRcdFx0aWYgKGQzRXZlbnQuYWx0S2V5KSB7XHJcblx0XHRcdFx0XHRcdCQkLmFwaS5oaWRlKCk7XHJcblx0XHRcdFx0XHRcdCQkLmFwaS5zaG93KGlkKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdCQkLmFwaS50b2dnbGUoaWQpO1xyXG5cdFx0XHRcdFx0XHQhaXNUb3VjaCAmJiAkJC5pc1RhcmdldFRvU2hvdyhpZCkgPyAkJC5hcGkuZm9jdXMoaWQpIDogJCQuYXBpLnJldmVydCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aXNUb3VjaCAmJiAkJC5oaWRlVG9vbHRpcCgpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRpZiAoIWlzVG91Y2gpIHtcclxuXHRcdFx0aXRlbVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGlkKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25vdXQsICQkLCBpZCkpIHtcclxuXHRcdFx0XHRcdFx0ZDNTZWxlY3QodGhpcykuY2xhc3NlZChDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZCwgZmFsc2UpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0JCQudW5kb01hcmtPdmVybGFwcGVkKCQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0JCQuYXBpLnJldmVydCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGlkKSB7XHJcblx0XHRcdFx0XHRpZiAoIWNhbGxGbihjb25maWcubGVnZW5kX2l0ZW1fb25vdmVyLCAkJCwgaWQpKSB7XHJcblx0XHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpLmNsYXNzZWQoQ0xBU1MubGVnZW5kSXRlbUZvY3VzZWQsIHRydWUpO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKGhhc0dhdWdlKSB7XHJcblx0XHRcdFx0XHRcdFx0JCQubWFya092ZXJsYXBwZWQoaWQsICQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCFzdGF0ZS50cmFuc2l0aW5nICYmICQkLmlzVGFyZ2V0VG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdFx0XHRcdCQkLmFwaS5mb2N1cyhpZCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGhlIGxlZ2VuZFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldElkcyBJRCdzIG9mIHRhcmdldFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHdpdGhUcmFuc2Zvcm0gOiBXaGV0aGVyIHRvIHVzZSB0aGUgdHJhbnNmb3JtIHByb3BlcnR5IC8gd2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm06IFdoZXRoZXIgdHJhbnNpdGlvbiBpcyB1c2VkIHdoZW4gdXNpbmcgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0eSAvIHdpdGhUcmFuc2l0aW9uIDogd2hldGhlciBvciBub3QgdG8gdHJhbnNpdGlvbi5cclxuIFx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR1cGRhdGVMZWdlbmRFbGVtZW50KHRhcmdldElkcywgb3B0aW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nVG9wID0gNDtcclxuXHRcdGNvbnN0IHBhZGRpbmdSaWdodCA9IDEwO1xyXG5cdFx0Y29uc3QgcG9zTWluID0gMTA7XHJcblx0XHRjb25zdCB0aWxlV2lkdGggPSBjb25maWcubGVnZW5kX2l0ZW1fdGlsZV93aWR0aCArIDU7XHJcblx0XHRsZXQgbWF4V2lkdGggPSAwO1xyXG5cdFx0bGV0IG1heEhlaWdodCA9IDA7XHJcblx0XHRsZXQgeEZvckxlZ2VuZDtcclxuXHRcdGxldCB5Rm9yTGVnZW5kO1xyXG5cdFx0bGV0IHRvdGFsTGVuZ3RoID0gMDtcclxuXHRcdGNvbnN0IG9mZnNldHMgPSB7fTtcclxuXHRcdGNvbnN0IHdpZHRocyA9IHt9O1xyXG5cdFx0Y29uc3QgaGVpZ2h0cyA9IHt9O1xyXG5cdFx0Y29uc3QgbWFyZ2lucyA9IFswXTtcclxuXHRcdGNvbnN0IHN0ZXBzID0ge307XHJcblx0XHRsZXQgc3RlcCA9IDA7XHJcblx0XHRsZXQgYmFja2dyb3VuZDtcclxuXHRcdGNvbnN0IGlzTGVnZW5kUmlnaHRPckluc2V0ID0gc3RhdGUuaXNMZWdlbmRSaWdodCB8fCBzdGF0ZS5pc0xlZ2VuZEluc2V0O1xyXG5cclxuXHRcdC8vIFNraXAgZWxlbWVudHMgd2hlbiB0aGVpciBuYW1lIGlzIHNldCB0byBudWxsXHJcblx0XHRjb25zdCB0YXJnZXRJZHogPSB0YXJnZXRJZHNcclxuXHRcdFx0LmZpbHRlcihpZCA9PiAhaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgfHwgY29uZmlnLmRhdGFfbmFtZXNbaWRdICE9PSBudWxsKTtcclxuXHJcblx0XHRjb25zdCB3aXRoVHJhbnNpdGlvbiA9IG9wdGlvbnMud2l0aFRyYW5zaXRpb247XHJcblxyXG5cdFx0Y29uc3QgZ2V0VGV4dEJveCA9IGZ1bmN0aW9uKHRleHRFbGVtZW50LCBpZCkge1xyXG5cdFx0XHRpZiAoISQkLmxlZ2VuZEl0ZW1UZXh0Qm94W2lkXSkge1xyXG5cdFx0XHRcdCQkLmxlZ2VuZEl0ZW1UZXh0Qm94W2lkXSA9XHJcblx0XHRcdFx0XHQkJC5nZXRUZXh0UmVjdCh0ZXh0RWxlbWVudCwgQ0xBU1MubGVnZW5kSXRlbSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiAkJC5sZWdlbmRJdGVtVGV4dEJveFtpZF07XHJcblx0XHR9O1xyXG5cclxuXHRcdGNvbnN0IHVwZGF0ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKHRleHRFbGVtZW50LCBpZCwgaW5kZXgpIHtcclxuXHRcdFx0Y29uc3QgcmVzZXQgPSBpbmRleCA9PT0gMDtcclxuXHRcdFx0Y29uc3QgaXNMYXN0ID0gaW5kZXggPT09IHRhcmdldElkei5sZW5ndGggLSAxO1xyXG5cdFx0XHRjb25zdCBib3ggPSBnZXRUZXh0Qm94KHRleHRFbGVtZW50LCBpZCk7XHJcblx0XHRcdGNvbnN0IGl0ZW1XaWR0aCA9IGJveC53aWR0aCArIHRpbGVXaWR0aCArXHJcblx0XHRcdFx0KGlzTGFzdCAmJiAhaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAwIDogcGFkZGluZ1JpZ2h0KSArIGNvbmZpZy5sZWdlbmRfcGFkZGluZztcclxuXHRcdFx0Y29uc3QgaXRlbUhlaWdodCA9IGJveC5oZWlnaHQgKyBwYWRkaW5nVG9wO1xyXG5cdFx0XHRjb25zdCBpdGVtTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBpdGVtSGVpZ2h0IDogaXRlbVdpZHRoO1xyXG5cdFx0XHRjb25zdCBhcmVhTGVuZ3RoID0gaXNMZWdlbmRSaWdodE9ySW5zZXQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6ICQkLmdldExlZ2VuZFdpZHRoKCk7XHJcblx0XHRcdGxldCBtYXJnaW47XHJcblxyXG5cdFx0XHQvLyBNRU1POiBjYXJlIGFib3V0IGNvbmRpZmlvbiBvZiBzdGVwLCB0b3RhbExlbmd0aFxyXG5cdFx0XHRjb25zdCB1cGRhdGVWYWx1ZXMgPSBmdW5jdGlvbihpZDIsIHdpdGhvdXRTdGVwPzogYm9vbGVhbikge1xyXG5cdFx0XHRcdGlmICghd2l0aG91dFN0ZXApIHtcclxuXHRcdFx0XHRcdG1hcmdpbiA9IChhcmVhTGVuZ3RoIC0gdG90YWxMZW5ndGggLSBpdGVtTGVuZ3RoKSAvIDI7XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIGl0ZW1MZW5ndGgpIC8gMjtcclxuXHRcdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0XHRzdGVwKys7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzdGVwc1tpZDJdID0gc3RlcDtcclxuXHRcdFx0XHRtYXJnaW5zW3N0ZXBdID0gc3RhdGUuaXNMZWdlbmRJbnNldCA/IDEwIDogbWFyZ2luO1xyXG5cdFx0XHRcdG9mZnNldHNbaWQyXSA9IHRvdGFsTGVuZ3RoO1xyXG5cdFx0XHRcdHRvdGFsTGVuZ3RoICs9IGl0ZW1MZW5ndGg7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRpZiAocmVzZXQpIHtcclxuXHRcdFx0XHR0b3RhbExlbmd0aCA9IDA7XHJcblx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0bWF4V2lkdGggPSAwO1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IDA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChjb25maWcubGVnZW5kX3Nob3cgJiYgISQkLmlzTGVnZW5kVG9TaG93KGlkKSkge1xyXG5cdFx0XHRcdHdpZHRoc1tpZF0gPSAwO1xyXG5cdFx0XHRcdGhlaWdodHNbaWRdID0gMDtcclxuXHRcdFx0XHRzdGVwc1tpZF0gPSAwO1xyXG5cdFx0XHRcdG9mZnNldHNbaWRdID0gMDtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR3aWR0aHNbaWRdID0gaXRlbVdpZHRoO1xyXG5cdFx0XHRoZWlnaHRzW2lkXSA9IGl0ZW1IZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoIW1heFdpZHRoIHx8IGl0ZW1XaWR0aCA+PSBtYXhXaWR0aCkge1xyXG5cdFx0XHRcdG1heFdpZHRoID0gaXRlbVdpZHRoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW1heEhlaWdodCB8fCBpdGVtSGVpZ2h0ID49IG1heEhlaWdodCkge1xyXG5cdFx0XHRcdG1heEhlaWdodCA9IGl0ZW1IZWlnaHQ7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IG1heExlbmd0aCA9IGlzTGVnZW5kUmlnaHRPckluc2V0ID8gbWF4SGVpZ2h0IDogbWF4V2lkdGg7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmxlZ2VuZF9lcXVhbGx5KSB7XHJcblx0XHRcdFx0T2JqZWN0LmtleXMod2lkdGhzKS5mb3JFYWNoKGlkMiA9PiAod2lkdGhzW2lkMl0gPSBtYXhXaWR0aCkpO1xyXG5cdFx0XHRcdE9iamVjdC5rZXlzKGhlaWdodHMpLmZvckVhY2goaWQyID0+IChoZWlnaHRzW2lkMl0gPSBtYXhIZWlnaHQpKTtcclxuXHRcdFx0XHRtYXJnaW4gPSAoYXJlYUxlbmd0aCAtIG1heExlbmd0aCAqIHRhcmdldElkei5sZW5ndGgpIC8gMjtcclxuXHJcblx0XHRcdFx0aWYgKG1hcmdpbiA8IHBvc01pbikge1xyXG5cdFx0XHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cdFx0XHRcdFx0c3RlcCA9IDA7XHJcblx0XHRcdFx0XHR0YXJnZXRJZHouZm9yRWFjaChpZDIgPT4gdXBkYXRlVmFsdWVzKGlkMikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQsIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR1cGRhdGVWYWx1ZXMoaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHN0ZXAgPSBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgPyBjb25maWcubGVnZW5kX2luc2V0X3N0ZXAgOiB0YXJnZXRJZHoubGVuZ3RoO1xyXG5cdFx0XHQkJC51cGRhdGVMZWdlbmRTdGVwKHN0ZXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXTtcclxuXHRcdFx0eUZvckxlZ2VuZCA9IGlkID0+IG1hcmdpbnNbc3RlcHNbaWRdXSArIG9mZnNldHNbaWRdO1xyXG5cdFx0fSBlbHNlIGlmIChzdGF0ZS5pc0xlZ2VuZEluc2V0KSB7XHJcblx0XHRcdHhGb3JMZWdlbmQgPSBpZCA9PiBtYXhXaWR0aCAqIHN0ZXBzW2lkXSArIDEwO1xyXG5cdFx0XHR5Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4Rm9yTGVnZW5kID0gaWQgPT4gbWFyZ2luc1tzdGVwc1tpZF1dICsgb2Zmc2V0c1tpZF07XHJcblx0XHRcdHlGb3JMZWdlbmQgPSBpZCA9PiBtYXhIZWlnaHQgKiBzdGVwc1tpZF07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFRleHQgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpICsgNCArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cdFx0Y29uc3QgeEZvckxlZ2VuZFJlY3QgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpO1xyXG5cdFx0Y29uc3QgeDFGb3JMZWdlbmRUaWxlID0gKGlkLCBpPzogbnVtYmVyKSA9PiB4Rm9yTGVnZW5kKGlkLCBpKSAtIDI7XHJcblx0XHRjb25zdCB4MkZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHhGb3JMZWdlbmQoaWQsIGkpIC0gMiArIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX3dpZHRoO1xyXG5cclxuXHRcdGNvbnN0IHlGb3JMZWdlbmRUZXh0ID0gKGlkLCBpPzogbnVtYmVyKSA9PiB5Rm9yTGVnZW5kKGlkLCBpKSArIDk7XHJcblx0XHRjb25zdCB5Rm9yTGVnZW5kUmVjdCA9IChpZCwgaT86IG51bWJlcikgPT4geUZvckxlZ2VuZChpZCwgaSkgLSA1O1xyXG5cdFx0Y29uc3QgeUZvckxlZ2VuZFRpbGUgPSAoaWQsIGk/OiBudW1iZXIpID0+IHlGb3JMZWdlbmQoaWQsIGkpICsgNDtcclxuXHJcblx0XHRjb25zdCBwb3MgPSAtMjAwO1xyXG5cclxuXHRcdGNvbnN0IHtsZWdlbmR9ID0gJCQuJGVsO1xyXG5cclxuXHRcdC8vIERlZmluZSBnIGZvciBsZWdlbmQgYXJlYVxyXG5cdFx0Y29uc3QgbCA9IGxlZ2VuZC5zZWxlY3RBbGwoYC4ke0NMQVNTLmxlZ2VuZEl0ZW19YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKFwiZ1wiKTtcclxuXHJcblx0XHQkJC5zZXRMZWdlbmRJdGVtKGwpO1xyXG5cclxuXHRcdGwuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRUZXh0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kVGV4dCk7XHJcblxyXG5cdFx0bC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbUV2ZW50KVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHhGb3JMZWdlbmRSZWN0IDogcG9zKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyBwb3MgOiB5Rm9yTGVnZW5kUmVjdCk7XHJcblxyXG5cdFx0Y29uc3QgdXNlUG9pbnQgPSBjb25maWcubGVnZW5kX3VzZVBvaW50O1xyXG5cclxuXHRcdGlmICh1c2VQb2ludCkge1xyXG5cdFx0XHRjb25zdCBpZHM6IGFueVtdID0gW107XHJcblxyXG5cdFx0XHRsLmFwcGVuZChkID0+IHtcclxuXHRcdFx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID9cclxuXHRcdFx0XHRcdGNvbmZpZy5wb2ludF9wYXR0ZXJuIDogW2NvbmZpZy5wb2ludF90eXBlXTtcclxuXHJcblx0XHRcdFx0aWRzLmluZGV4T2YoZCkgPT09IC0xICYmIGlkcy5wdXNoKGQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGQpICUgcGF0dGVybi5sZW5ndGhdO1xyXG5cclxuXHRcdFx0XHRpZiAocG9pbnQgPT09IFwicmVjdGFuZ2xlXCIpIHtcclxuXHRcdFx0XHRcdHBvaW50ID0gXCJyZWN0XCI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsICQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSA/IHBvaW50IDogXCJ1c2VcIik7XHJcblx0XHRcdH0pXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRJdGVtUG9pbnQpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiaHJlZlwiLCAoZGF0YSwgaWR4LCBzZWxlY3Rpb24pID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25baWR4XTtcclxuXHRcdFx0XHRcdGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBub2RlTmFtZSA9PT0gXCJ1c2VcIiA/IGAjJHtzdGF0ZS5kYXRldGltZUlkfS1wb2ludC0ke2RhdGF9YCA6IHVuZGVmaW5lZDtcclxuXHRcdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGwuYXBwZW5kKFwibGluZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MubGVnZW5kSXRlbVRpbGUpXHJcblx0XHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieDFcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MUZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwieDJcIiwgaXNMZWdlbmRSaWdodE9ySW5zZXQgPyB4MkZvckxlZ2VuZFRpbGUgOiBwb3MpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MlwiLCBpc0xlZ2VuZFJpZ2h0T3JJbnNldCA/IHBvcyA6IHlGb3JMZWdlbmRUaWxlKVxyXG5cdFx0XHRcdC5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIGNvbmZpZy5sZWdlbmRfaXRlbV90aWxlX2hlaWdodCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IGJhY2tncm91bmQgZm9yIGluc2V0IGxlZ2VuZFxyXG5cdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5zZWxlY3QoYC4ke0NMQVNTLmxlZ2VuZEJhY2tncm91bmR9IHJlY3RgKTtcclxuXHJcblx0XHRpZiAoc3RhdGUuaXNMZWdlbmRJbnNldCAmJiBtYXhXaWR0aCA+IDAgJiYgYmFja2dyb3VuZC5zaXplKCkgPT09IDApIHtcclxuXHRcdFx0YmFja2dyb3VuZCA9IGxlZ2VuZC5pbnNlcnQoXCJnXCIsIGAuJHtDTEFTUy5sZWdlbmRJdGVtfWApXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZWdlbmRCYWNrZ3JvdW5kKVxyXG5cdFx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHRleHRzID0gbGVnZW5kLnNlbGVjdEFsbChcInRleHRcIilcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KVxyXG5cdFx0XHQudGV4dChpZCA9PiAoaXNEZWZpbmVkKGNvbmZpZy5kYXRhX25hbWVzW2lkXSkgPyBjb25maWcuZGF0YV9uYW1lc1tpZF0gOiBpZCkpIC8vIE1FTU86IG5lZWRlZCBmb3IgdXBkYXRlXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGlkLCBpKSB7XHJcblx0XHRcdFx0dXBkYXRlUG9zaXRpb25zKHRoaXMsIGlkLCBpKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0KHdpdGhUcmFuc2l0aW9uID8gdGV4dHMudHJhbnNpdGlvbigpIDogdGV4dHMpXHJcblx0XHRcdC5hdHRyKFwieFwiLCB4Rm9yTGVnZW5kVGV4dClcclxuXHRcdFx0LmF0dHIoXCJ5XCIsIHlGb3JMZWdlbmRUZXh0KTtcclxuXHJcblx0XHRjb25zdCByZWN0cyA9IGxlZ2VuZC5zZWxlY3RBbGwoYHJlY3QuJHtDTEFTUy5sZWdlbmRJdGVtRXZlbnR9YClcclxuXHRcdFx0LmRhdGEodGFyZ2V0SWR6KTtcclxuXHJcblx0XHQod2l0aFRyYW5zaXRpb24gPyByZWN0cy50cmFuc2l0aW9uKCkgOiByZWN0cylcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBpZCA9PiB3aWR0aHNbaWRdKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBpZCA9PiBoZWlnaHRzW2lkXSlcclxuXHRcdFx0LmF0dHIoXCJ4XCIsIHhGb3JMZWdlbmRSZWN0KVxyXG5cdFx0XHQuYXR0cihcInlcIiwgeUZvckxlZ2VuZFJlY3QpO1xyXG5cclxuXHJcblx0XHRpZiAodXNlUG9pbnQpIHtcclxuXHRcdFx0Y29uc3QgdGlsZXMgPSBsZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtUG9pbnR9YClcclxuXHRcdFx0XHQuZGF0YSh0YXJnZXRJZHopO1xyXG5cclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gdGlsZXMudHJhbnNpdGlvbigpIDogdGlsZXMpXHJcblx0XHRcdFx0LmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRjb25zdCBub2RlTmFtZSA9IHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50UiA9IGNvbmZpZy5wb2ludF9yO1xyXG5cdFx0XHRcdFx0bGV0IHggPSBcInhcIjtcclxuXHRcdFx0XHRcdGxldCB5ID0gXCJ5XCI7XHJcblx0XHRcdFx0XHRsZXQgeE9mZnNldCA9IDI7XHJcblx0XHRcdFx0XHRsZXQgeU9mZnNldCA9IDIuNTtcclxuXHRcdFx0XHRcdGxldCByYWRpdXM7XHJcblx0XHRcdFx0XHRsZXQgd2lkdGg7XHJcblx0XHRcdFx0XHRsZXQgaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRcdGlmIChub2RlTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0XHRjb25zdCBzaXplID0gcG9pbnRSICogMC4yO1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IFwiY3hcIjtcclxuXHRcdFx0XHRcdFx0eSA9IFwiY3lcIjtcclxuXHRcdFx0XHRcdFx0cmFkaXVzID0gcG9pbnRSICsgc2l6ZTtcclxuXHRcdFx0XHRcdFx0eE9mZnNldCA9IHBvaW50UiAqIDI7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAtc2l6ZTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAobm9kZU5hbWUgPT09IFwicmVjdFwiKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNpemUgPSBwb2ludFIgKiAyLjU7XHJcblxyXG5cdFx0XHRcdFx0XHR3aWR0aCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdGhlaWdodCA9IHNpemU7XHJcblx0XHRcdFx0XHRcdHlPZmZzZXQgPSAzO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGQzU2VsZWN0KHRoaXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKHgsIGQgPT4geDFGb3JMZWdlbmRUaWxlKGQpICsgeE9mZnNldClcclxuXHRcdFx0XHRcdFx0LmF0dHIoeSwgZCA9PiB5Rm9yTGVnZW5kVGlsZShkKSAtIHlPZmZzZXQpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiclwiLCByYWRpdXMpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgd2lkdGgpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb25zdCB0aWxlcyA9IGxlZ2VuZC5zZWxlY3RBbGwoYGxpbmUuJHtDTEFTUy5sZWdlbmRJdGVtVGlsZX1gKVxyXG5cdFx0XHRcdC5kYXRhKHRhcmdldElkeik7XHJcblxyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyB0aWxlcy50cmFuc2l0aW9uKCkgOiB0aWxlcylcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgJCQubGV2ZWxDb2xvciA/IGlkID0+ICQkLmxldmVsQ29sb3IoJCQuY2FjaGUuZ2V0KGlkKS52YWx1ZXNbMF0udmFsdWUpIDogJCQuY29sb3IpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4MUZvckxlZ2VuZFRpbGUpXHJcblx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5Rm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIHgyRm9yTGVnZW5kVGlsZSlcclxuXHRcdFx0XHQuYXR0cihcInkyXCIsIHlGb3JMZWdlbmRUaWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoYmFja2dyb3VuZCkge1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYWNrZ3JvdW5kLnRyYW5zaXRpb24oKSA6IGJhY2tncm91bmQpXHJcblx0XHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0TGVnZW5kSGVpZ2h0KCkgLSAxMilcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIG1heFdpZHRoICogKHN0ZXAgKyAxKSArIDEwKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVcGRhdGUgYWxsIHRvIHJlZmxlY3QgY2hhbmdlIG9mIGxlZ2VuZFxyXG5cdFx0JCQudXBkYXRlTGVnZW5kSXRlbVdpZHRoKG1heFdpZHRoKTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobWF4SGVpZ2h0KTtcclxuXHRcdCQkLnVwZGF0ZUxlZ2VuZFN0ZXAoc3RlcCk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7IC8vIHNlbGVjdGlvblxyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdFJlZ2lvbigpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLnJlZ2lvbi5tYWluID0gJGVsLm1haW4uYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsaXAtcGF0aFwiLCAkJC5zdGF0ZS5jbGlwLnBhdGgpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MucmVnaW9ucyk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlUmVnaW9uKGR1cmF0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0Ly8gaGlkZSBpZiBhcmMgdHlwZVxyXG5cdFx0JGVsLnJlZ2lvbi5tYWluLnN0eWxlKFwidmlzaWJpbGl0eVwiLCAkJC5oYXNBcmNUeXBlKCkgPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCIpO1xyXG5cclxuXHRcdC8vIHNlbGVjdCA8Zz4gZWxlbWVudFxyXG5cdFx0bGV0IGxpc3QgPSAkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnJlZ2lvbnN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MucmVnaW9ufWApXHJcblx0XHRcdC5kYXRhKGNvbmZpZy5yZWdpb25zKTtcclxuXHJcblx0XHRsaXN0LmV4aXQoKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0LnJlbW92ZSgpO1xyXG5cclxuXHRcdGxpc3QgPSBsaXN0LmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0Lm1lcmdlKGxpc3QpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NSZWdpb24uYmluZCgkJCkpO1xyXG5cclxuXHRcdGxpc3RcclxuXHRcdFx0LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKTtcclxuXHJcblx0XHQkZWwucmVnaW9uLmxpc3QgPSBsaXN0O1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd1JlZ2lvbih3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC4kZWwucmVnaW9uLmxpc3Quc2VsZWN0KFwicmVjdFwiKTtcclxuXHJcblx0XHRyZWdpb25zID0gKHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgJCQucmVnaW9uWC5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJ5XCIsICQkLnJlZ2lvblkuYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQucmVnaW9uV2lkdGguYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLnJlZ2lvbkhlaWdodC5iaW5kKCQkKSk7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gcmVnaW9ucy50cmFuc2l0aW9uKCkgOiByZWdpb25zKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGwtb3BhY2l0eVwiLCBkID0+IChpc1ZhbHVlKGQub3BhY2l0eSkgPyBkLm9wYWNpdHkgOiBcIjAuMVwiKSlcclxuXHRcdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQvLyByZW1vdmUgdW5uZWNlc3NhcnkgcmVjdCBhZnRlciB0cmFuc2l0aW9uXHJcblx0XHRcdFx0XHRkM1NlbGVjdCh0aGlzLnBhcmVudE5vZGUpXHJcblx0XHRcdFx0XHRcdC5zZWxlY3RBbGwoXCJyZWN0Om5vdChbeF0pXCIpXHJcblx0XHRcdFx0XHRcdC5yZW1vdmUoKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWdpb25YWSh0eXBlLCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1ggPSB0eXBlID09PSBcInhcIjtcclxuXHRcdGxldCBrZXkgPSBcInN0YXJ0XCI7XHJcblx0XHRsZXQgY3VyclNjYWxlO1xyXG5cdFx0bGV0IHBvcyA9IDA7XHJcblxyXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcclxuXHRcdFx0aWYgKCFpc1gpIHtcclxuXHRcdFx0XHRrZXkgPSBcImVuZFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoKGlzWCA/IGlzUm90YXRlZCA6ICFpc1JvdGF0ZWQpICYmIGtleSBpbiBkKSB7XHJcblx0XHRcdFx0Y3VyclNjYWxlID0gc2NhbGVbZC5heGlzXTtcclxuXHRcdFx0XHRwb3MgPSBjdXJyU2NhbGUoZFtrZXldKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICgoaXNYID8gIWlzUm90YXRlZCA6IGlzUm90YXRlZCkgJiYga2V5IGluIGQpIHtcclxuXHRcdFx0Y3VyclNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cdFx0XHRwb3MgPSBjdXJyU2NhbGUoJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5wYXJzZURhdGUoZFtrZXldKSA6IGRba2V5XSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvcztcclxuXHR9LFxyXG5cclxuXHRyZWdpb25YKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieFwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRyZWdpb25ZKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFJlZ2lvblhZKFwieVwiLCBkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRSZWdpb25TaXplKHR5cGUsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc1dpZHRoID0gdHlwZSA9PT0gXCJ3aWR0aFwiO1xyXG5cdFx0Y29uc3Qgc3RhcnQgPSAkJFtpc1dpZHRoID8gXCJyZWdpb25YXCIgOiBcInJlZ2lvbllcIl0oZCk7XHJcblx0XHRsZXQgY3VyclNjYWxlO1xyXG5cdFx0bGV0IGtleSA9IFwiZW5kXCI7XHJcblx0XHRsZXQgZW5kID0gc3RhdGVbdHlwZV07XHJcblxyXG5cdFx0aWYgKGQuYXhpcyA9PT0gXCJ5XCIgfHwgZC5heGlzID09PSBcInkyXCIpIHtcclxuXHRcdFx0aWYgKCFpc1dpZHRoKSB7XHJcblx0XHRcdFx0a2V5ID0gXCJzdGFydFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoKGlzV2lkdGggPyBpc1JvdGF0ZWQgOiAhaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRcdGN1cnJTY2FsZSA9IHNjYWxlW2QuYXhpc107XHJcblx0XHRcdFx0ZW5kID0gY3VyclNjYWxlKGRba2V5XSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAoKGlzV2lkdGggPyAhaXNSb3RhdGVkIDogaXNSb3RhdGVkKSAmJiBrZXkgaW4gZCkge1xyXG5cdFx0XHRjdXJyU2NhbGUgPSBzY2FsZS56b29tIHx8IHNjYWxlLng7XHJcblx0XHRcdGVuZCA9IGN1cnJTY2FsZSgkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShkW2tleV0pIDogZFtrZXldKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZW5kIDwgc3RhcnQgPyAwIDogZW5kIC0gc3RhcnQ7XHJcblx0fSxcclxuXHJcblx0cmVnaW9uV2lkdGgoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmVnaW9uU2l6ZShcIndpZHRoXCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdHJlZ2lvbkhlaWdodChkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRSZWdpb25TaXplKFwiaGVpZ2h0XCIsIGQpO1xyXG5cdH0sXHJcblxyXG5cdGlzUmVnaW9uT25YKGQpIHtcclxuXHRcdHJldHVybiAhZC5heGlzIHx8IGQuYXhpcyA9PT0gXCJ4XCI7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNjYWxlVGltZSBhcyBkM1NjYWxlVGltZSxcclxuXHRzY2FsZUxpbmVhciBhcyBkM1NjYWxlTGluZWFyXHJcbn0gZnJvbSBcImQzLXNjYWxlXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0Z2V0U2NhbGUobWluLCBtYXgsIGZvclRpbWVzZXJpZXMpIHtcclxuXHRcdHJldHVybiAoZm9yVGltZXNlcmllcyA/XHJcblx0XHRcdGQzU2NhbGVUaW1lKCkgOiBkM1NjYWxlTGluZWFyKClcclxuXHRcdCkucmFuZ2UoW21pbiwgbWF4XSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHggQXhpcyBzY2FsZSBmdW5jdGlvblxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRvbWFpblxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9mZnNldCBUaGUgb2Zmc2V0IGdldHRlciB0byBiZSBzdW1cclxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gc2NhbGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldFgobWluLCBtYXgsIGRvbWFpbiwgb2Zmc2V0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBzY2FsZSA9ICQkLnNjYWxlLnpvb20gfHwgJCQuZ2V0U2NhbGUobWluLCBtYXgsICQkLmlzVGltZVNlcmllcygpKTtcclxuXHJcblx0XHRyZXR1cm4gJCQuZ2V0Q3VzdG9taXplZFNjYWxlKFxyXG5cdFx0XHRkb21haW4gPyBzY2FsZS5kb21haW4oZG9tYWluKSA6IHNjYWxlLFxyXG5cdFx0XHRvZmZzZXRcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHkgQXhpcyBzY2FsZSBmdW5jdGlvblxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtaW5cclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbWF4XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRvbWFpblxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufSBzY2FsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0WShtaW4sIG1heCwgZG9tYWluKSB7XHJcblx0XHRjb25zdCBzY2FsZSA9IHRoaXMuZ2V0U2NhbGUobWluLCBtYXgsIHRoaXMuaXNUaW1lU2VyaWVzWSgpKTtcclxuXHJcblx0XHRkb21haW4gJiYgc2NhbGUuZG9tYWluKGRvbWFpbik7XHJcblxyXG5cdFx0cmV0dXJuIHNjYWxlO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBjdXN0b21pemVkIHNjYWxlXHJcblx0ICogQHBhcmFtIHtkMy5zY2FsZUxpbmVhcnxkMy5zY2FsZVRpbWV9IHNjYWxlVmFsdWVcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvZmZzZXRWYWx1ZSBPZmZzZXQgZ2V0dGVyIHRvIGJlIHN1bVxyXG5cdCAqIEByZXR1cm4ge30gc2NhbGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEN1c3RvbWl6ZWRTY2FsZShzY2FsZVZhbHVlLCBvZmZzZXRWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gb2Zmc2V0VmFsdWUgfHwgKCgpID0+ICQkLmF4aXMueC50aWNrT2Zmc2V0KCkpO1xyXG5cdFx0Y29uc3Qgc2NhbGUgPSBmdW5jdGlvbihkLCByYXcpIHtcclxuXHRcdFx0Y29uc3QgdiA9IHNjYWxlVmFsdWUoZCkgKyBvZmZzZXQoKTtcclxuXHJcblx0XHRcdHJldHVybiByYXcgPyB2IDogTWF0aC5jZWlsKHYpO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBjb3B5IG9yaWdpbmFsIHNjYWxlIG1ldGhvZHNcclxuXHRcdGZvciAoY29uc3Qga2V5IGluIHNjYWxlVmFsdWUpIHtcclxuXHRcdFx0c2NhbGVba2V5XSA9IHNjYWxlVmFsdWVba2V5XTtcclxuXHRcdH1cclxuXHJcblx0XHRzY2FsZS5vcmdEb21haW4gPSAoKSA9PiBzY2FsZVZhbHVlLmRvbWFpbigpO1xyXG5cdFx0c2NhbGUub3JnU2NhbGUgPSAoKSA9PiBzY2FsZVZhbHVlO1xyXG5cclxuXHRcdC8vIGRlZmluZSBjdXN0b20gZG9tYWluKCkgZm9yIGNhdGVnb3JpemVkIGF4aXNcclxuXHRcdGlmICgkJC5pc0NhdGVnb3JpemVkKCkpIHtcclxuXHRcdFx0c2NhbGUuZG9tYWluID0gZnVuY3Rpb24oZG9tYWluVmFsdWUpIHtcclxuXHRcdFx0XHRsZXQgZG9tYWluID0gZG9tYWluVmFsdWU7XHJcblxyXG5cdFx0XHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0ZG9tYWluID0gdGhpcy5vcmdEb21haW4oKTtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gW2RvbWFpblswXSwgZG9tYWluWzFdICsgMV07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRzY2FsZVZhbHVlLmRvbWFpbihkb21haW4pO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gc2NhbGU7XHJcblx0XHRcdH07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNjYWxlO1xyXG5cdH0sXHJcblxyXG5cdGdldFlTY2FsZShpZCkge1xyXG5cdFx0Y29uc3Qge3ksIHkyfSA9IHRoaXMuc2NhbGU7XHJcblx0XHRyZXR1cm4gdGhpcy5heGlzLmdldElkKGlkKSA9PT0gXCJ5MlwiID8geTIgOiB5O1xyXG5cdH0sXHJcblxyXG5cdGdldFN1YllTY2FsZShpZCkge1xyXG5cdFx0Y29uc3Qge3N1YlksIHN1YlkyfSA9IHRoaXMuc2NhbGU7XHJcblx0XHRyZXR1cm4gdGhpcy5heGlzLmdldElkKGlkKSA9PT0gXCJ5MlwiID8gc3ViWTIgOiBzdWJZO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBzY2FsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBpc0luaXQgLSBwYXJhbSBpcyBnaXZlbiBhdCB0aGUgaW5pdCByZW5kZXJpbmdcclxuXHQgKi9cclxuXHR1cGRhdGVTY2FsZXMoaXNJbml0LCB1cGRhdGVYRG9tYWluID0gdHJ1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgb3JnLCBzY2FsZSwgc3RhdGU6IHtcclxuXHRcdFx0d2lkdGgsIGhlaWdodCwgd2lkdGgyLCBoZWlnaHQyXHJcblx0XHR9fSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyB1cGRhdGUgZWRnZXNcclxuXHRcdGNvbnN0IG1pbiA9IHtcclxuXHRcdFx0eDogaXNSb3RhdGVkID8gMSA6IDAsXHJcblx0XHRcdHk6IGlzUm90YXRlZCA/IDAgOiBoZWlnaHQsXHJcblx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IDEgOiAwLFxyXG5cdFx0XHRzdWJZOiBpc1JvdGF0ZWQgPyAwIDogaGVpZ2h0MlxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBtYXggPSB7XHJcblx0XHRcdHg6IGlzUm90YXRlZCA/IGhlaWdodCA6IHdpZHRoLFxyXG5cdFx0XHR5OiBpc1JvdGF0ZWQgPyB3aWR0aCA6IDEsXHJcblx0XHRcdHN1Ylg6IGlzUm90YXRlZCA/IGhlaWdodCA6IHdpZHRoLFxyXG5cdFx0XHRzdWJZOiBpc1JvdGF0ZWQgPyB3aWR0aDIgOiAxXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHNjYWxlc1xyXG5cdFx0Ly8geCBBeGlzXHJcblx0XHRjb25zdCB4RG9tYWluID0gdXBkYXRlWERvbWFpbiAmJiBzY2FsZS54ICYmIHNjYWxlLngub3JnRG9tYWluKCk7XHJcblx0XHRjb25zdCB4U3ViRG9tYWluID0gdXBkYXRlWERvbWFpbiAmJiBvcmcueERvbWFpbjtcclxuXHJcblx0XHRzY2FsZS54ID0gJCQuZ2V0WChtaW4ueCwgbWF4LngsIHhEb21haW4sICgpID0+ICQkLmF4aXMueC50aWNrT2Zmc2V0KCkpO1xyXG5cdFx0c2NhbGUuc3ViWCA9ICQkLmdldFgobWluLngsIG1heC54LCB4U3ViRG9tYWluLCBkID0+IChkICUgMSA/IDAgOiAkJC5heGlzLnN1YlgudGlja09mZnNldCgpKSk7XHJcblxyXG5cdFx0JCQuZm9ybWF0LnhBeGlzVGljayA9ICQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCk7XHJcblx0XHQkJC5heGlzLnhUaWNrVmFsdWVzID0gJCQuYXhpcy5nZXRUaWNrVmFsdWVzKFwieFwiKTtcclxuXHJcblx0XHQkJC5heGlzLnggPSAkJC5heGlzXHJcblx0XHRcdC5nZXRBeGlzKFwieFwiLCBzY2FsZS54LCBjb25maWcuYXhpc194X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblxyXG5cdFx0JCQuYXhpcy5zdWJYID0gJCQuYXhpc1xyXG5cdFx0XHQuZ2V0QXhpcyhcInN1YlhcIiwgc2NhbGUuc3ViWCwgY29uZmlnLmF4aXNfeF90aWNrX291dGVyLCBpc0luaXQpO1xyXG5cclxuXHRcdC8vIHkgQXhpc1xyXG5cdFx0c2NhbGUueSA9ICQkLmdldFkobWluLnksIG1heC55LCBzY2FsZS55ID8gc2NhbGUueS5kb21haW4oKSA6IGNvbmZpZy5heGlzX3lfZGVmYXVsdCk7XHJcblx0XHRzY2FsZS5zdWJZID0gJCQuZ2V0WShtaW4uc3ViWSwgbWF4LnN1YlksIHNjYWxlLnN1YlkgPyBzY2FsZS5zdWJZLmRvbWFpbigpIDogY29uZmlnLmF4aXNfeV9kZWZhdWx0KTtcclxuXHJcblx0XHQkJC5heGlzLnlUaWNrVmFsdWVzID0gJCQuYXhpcy5nZXRUaWNrVmFsdWVzKFwieVwiKTtcclxuXHJcblx0XHQkJC5heGlzLnkgPSAkJC5heGlzXHJcblx0XHRcdC5nZXRBeGlzKFwieVwiLCBzY2FsZS55LCBjb25maWcuYXhpc195X3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblxyXG5cdFx0Ly8geTIgQXhpc1xyXG5cdFx0aWYgKGNvbmZpZy5heGlzX3kyX3Nob3cpIHtcclxuXHRcdFx0c2NhbGUueTIgPSAkJC5nZXRZKG1pbi55LCBtYXgueSwgc2NhbGUueTIgPyBzY2FsZS55Mi5kb21haW4oKSA6IGNvbmZpZy5heGlzX3kyX2RlZmF1bHQpO1xyXG5cdFx0XHRzY2FsZS5zdWJZMiA9ICQkLmdldFkobWluLnN1YlksIG1heC5zdWJZLFxyXG5cdFx0XHRcdHNjYWxlLnN1YlkyID8gc2NhbGUuc3ViWTIuZG9tYWluKCkgOiBjb25maWcuYXhpc195Ml9kZWZhdWx0KTtcclxuXHJcblx0XHRcdCQkLmF4aXMueTJUaWNrVmFsdWVzID0gJCQuYXhpcy5nZXRUaWNrVmFsdWVzKFwieTJcIik7XHJcblxyXG5cdFx0XHQkJC5heGlzLnkyID0gJCQuYXhpc1xyXG5cdFx0XHRcdC5nZXRBeGlzKFwieTJcIiwgc2NhbGUueTIsIGNvbmZpZy5heGlzX3kyX3RpY2tfb3V0ZXIsIGlzSW5pdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGZvciBhcmNcclxuXHRcdCQkLnVwZGF0ZUFyYyAmJiAkJC51cGRhdGVBcmMoKTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7cmdiIGFzIGQzUmdifSBmcm9tIFwiZDMtY29sb3JcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhbGxGbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2VsZWN0IGEgcG9pbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqL1xyXG5cdHNlbGVjdFBvaW50KHRhcmdldCwgZCwgaSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgY3ggPSAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWSA6ICQkLmNpcmNsZVgpLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY3kgPSAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgciA9ICQkLnBvaW50U2VsZWN0Ui5iaW5kKCQkKTtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcclxuXHJcblx0XHQvLyBhZGQgc2VsZWN0ZWQtY2lyY2xlIG9uIGxvdyBsYXllciBnXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGV9LSR7aX1gKVxyXG5cdFx0XHQuZGF0YShbZF0pXHJcblx0XHRcdC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJjaXJjbGVcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoKSA9PiAkJC5nZW5lcmF0ZUNsYXNzKENMQVNTLnNlbGVjdGVkQ2lyY2xlLCBpKSlcclxuXHRcdFx0LmF0dHIoXCJjeFwiLCBjeClcclxuXHRcdFx0LmF0dHIoXCJjeVwiLCBjeSlcclxuXHRcdFx0LmF0dHIoXCJzdHJva2VcIiwgJCQuY29sb3IpXHJcblx0XHRcdC5hdHRyKFwiclwiLCBkMiA9PiAkJC5wb2ludFNlbGVjdFIoZDIpICogMS40KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5hdHRyKFwiclwiLCByKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbmVsZWN0IGEgcG9pbnRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcG9pbnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqL1xyXG5cdHVuc2VsZWN0UG9pbnQodGFyZ2V0LCBkLCBpKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5kYXRhX29udW5zZWxlY3RlZCwgJCQuYXBpLCBkLCB0YXJnZXQubm9kZSgpKTtcclxuXHJcblx0XHQvLyByZW1vdmUgc2VsZWN0ZWQtY2lyY2xlIGZyb20gbG93IGxheWVyIGdcclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGVzfSR7JCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCl9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2VsZWN0ZWRDaXJjbGV9LSR7aX1gKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigxMDApXHJcblx0XHRcdC5hdHRyKFwiclwiLCAwKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVG9nZ2xlcyB0aGUgc2VsZWN0aW9uIG9mIHBvaW50c1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0byBzZWxlY3QuXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBwb2ludFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcblx0ICovXHJcblx0dG9nZ2xlUG9pbnQoc2VsZWN0ZWQsIHRhcmdldCwgZCwgaSkge1xyXG5cdFx0Y29uc3QgbWV0aG9kID0gYCR7c2VsZWN0ZWQgPyBcIlwiIDogXCJ1blwifXNlbGVjdFBvaW50YDtcclxuXHJcblx0XHR0aGlzW21ldGhvZF0odGFyZ2V0LCBkLCBpKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZWxlY3QgYSBwYXRoXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHBhdGhcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqL1xyXG5cdHNlbGVjdFBhdGgodGFyZ2V0LCBkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGNhbGxGbihjb25maWcuZGF0YV9vbnNlbGVjdGVkLCAkJCwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbikge1xyXG5cdFx0XHR0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsICgpID0+IGQzUmdiKCQkLmNvbG9yKGQpKS5icmlnaHRlcigwLjc1KSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogVW5lbGVjdCBhIHBhdGhcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgcGF0aFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcblx0ICovXHJcblx0dW5zZWxlY3RQYXRoKHRhcmdldCwgZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb251bnNlbGVjdGVkLCAkJCwgZCwgdGFyZ2V0Lm5vZGUoKSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5pbnRlcmFjdGlvbl9icmlnaHRlbikge1xyXG5cdFx0XHR0YXJnZXQudHJhbnNpdGlvbigpLmR1cmF0aW9uKDEwMClcclxuXHRcdFx0XHQuc3R5bGUoXCJmaWxsXCIsICgpID0+ICQkLmNvbG9yKGQpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGVzIHRoZSBzZWxlY3Rpb24gb2YgbGluZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdG8gc2VsZWN0LlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgc2hhcGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqL1xyXG5cdHRvZ2dsZVBhdGgoc2VsZWN0ZWQsIHRhcmdldCwgZCwgaSkge1xyXG5cdFx0dGhpc1tcclxuXHRcdFx0YCR7c2VsZWN0ZWQgPyBcIlwiIDogXCJ1blwifXNlbGVjdFBhdGhgXHJcblx0XHRdKHRhcmdldCwgZCwgaSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgdG9nZ2xlIG1ldGhvZCBvZiB0aGUgdGFyZ2V0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IHNoYXBlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcmV0dXJucyB7RnVuY3Rpb259IHRvZ2dsZSBtZXRob2RcclxuXHQgKi9cclxuXHRnZXRUb2dnbGUodGhhdCwgZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiB0aGF0Lm5vZGVOYW1lID09PSBcInBhdGhcIiA/XHJcblx0XHRcdCQkLnRvZ2dsZVBhdGggOiAoXHJcblx0XHRcdFx0JCQuaXNTdGVwVHlwZShkKSA/XHJcblx0XHRcdFx0XHQoKSA9PiB7fSA6IC8vIGNpcmNsZSBpcyBoaWRkZW4gaW4gc3RlcCBjaGFydCwgc28gdHJlYXQgYXMgd2l0aGluIHRoZSBjbGljayBhcmVhXHJcblx0XHRcdFx0XHQkJC50b2dnbGVQb2ludFxyXG5cdFx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZXMgdGhlIHNlbGVjdGlvbiBvZiBzaGFwZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgc2hhcGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleFxyXG5cdCAqL1xyXG5cdHRvZ2dsZVNoYXBlKHRoYXQsIGQsIGkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGF0KTtcclxuXHRcdGNvbnN0IGlzU2VsZWN0ZWQgPSBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGF0LCBkKS5iaW5kKCQkKTtcclxuXHRcdGxldCB0b2dnbGVkU2hhcGU7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkpIHtcclxuXHRcdFx0aWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fbXVsdGlwbGUpIHtcclxuXHRcdFx0XHRsZXQgc2VsZWN0b3IgPSBgLiR7Q0xBU1Muc2hhcGVzfWA7XHJcblxyXG5cdFx0XHRcdGlmIChjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0c2VsZWN0b3IgKz0gJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgoZC5pZCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRtYWluLnNlbGVjdEFsbChzZWxlY3RvcilcclxuXHRcdFx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlfWApXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCkpIHtcclxuXHRcdFx0XHRcdFx0XHR0b2dnbGVkU2hhcGUgPSBzaGFwZTtcclxuXHRcdFx0XHRcdFx0XHR0b2dnbGUoZmFsc2UsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIGZhbHNlKSwgZCwgaSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIXRvZ2dsZWRTaGFwZSB8fCB0b2dnbGVkU2hhcGUubm9kZSgpICE9PSBzaGFwZS5ub2RlKCkpIHtcclxuXHRcdFx0XHRzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCAhaXNTZWxlY3RlZCk7XHJcblx0XHRcdFx0dG9nZ2xlKCFpc1NlbGVjdGVkLCBzaGFwZSwgZCwgaSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNWYWx1ZSwgY2VpbDEwLCBjYXBpdGFsaXplfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBVcGRhdGUgY29udGFpbmVyIHNpemVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldENvbnRhaW5lclNpemUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblxyXG5cdFx0c3RhdGUuY3VycmVudFdpZHRoID0gJCQuZ2V0Q3VycmVudFdpZHRoKCk7XHJcblx0XHRzdGF0ZS5jdXJyZW50SGVpZ2h0ID0gJCQuZ2V0Q3VycmVudEhlaWdodCgpO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRXaWR0aCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXR1cm4gJCQuY29uZmlnLnNpemVfd2lkdGggfHwgJCQuZ2V0UGFyZW50V2lkdGgoKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50SGVpZ2h0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGggPSBjb25maWcuc2l6ZV9oZWlnaHQgfHwgJCQuZ2V0UGFyZW50SGVpZ2h0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGggPiAwID8gaCA6IDMyMCAvICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlID8gMiA6IDEpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBBeGlzIHNpemUgYWNjb3JkaW5nIGl0cyBwb3NpdGlvblxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBBeGlzIGlkIHZhbHVlIC0geCwgeSBvciB5MlxyXG5cdCAqIEByZXR1cm4ge251bWJlcn0gc2l6ZSBBeGlzIHNpemUgdmFsdWVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEF4aXNTaXplKGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRyZXR1cm4gKGlzUm90YXRlZCAmJiBpZCA9PT0gXCJ4XCIpIHx8ICghaXNSb3RhdGVkICYmIC95Mj8vLnRlc3QoaWQpKSA/XHJcblx0XHRcdCQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKGlkLCB0cnVlKSA6XHJcblx0XHRcdCQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KGlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ1RvcCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWcuYXhpc195Ml9heGVzLmxlbmd0aDtcclxuXHJcblx0XHRsZXQgcGFkZGluZyA9IGlzVmFsdWUoY29uZmlnLnBhZGRpbmdfdG9wKSA/XHJcblx0XHRcdGNvbmZpZy5wYWRkaW5nX3RvcCA6IDA7XHJcblxyXG5cdFx0aWYgKCRlbC50aXRsZSAmJiAkZWwudGl0bGUubm9kZSgpKSB7XHJcblx0XHRcdHBhZGRpbmcgKz0gJCQuZ2V0VGl0bGVQYWRkaW5nKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGF4ZXNMZW4gJiYgY29uZmlnLmF4aXNfcm90YXRlZCkge1xyXG5cdFx0XHRwYWRkaW5nICs9ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieTJcIikgKiBheGVzTGVuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRQYWRkaW5nQm90dG9tKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGF4aXNJZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQgPyBcInlcIiA6IFwieFwiO1xyXG5cdFx0Y29uc3QgYXhlc0xlbiA9IGNvbmZpZ1tgYXhpc18ke2F4aXNJZH1fYXhlc2BdLmxlbmd0aDtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2JvdHRvbSkgP1xyXG5cdFx0XHRjb25maWcucGFkZGluZ19ib3R0b20gOiAwO1xyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nICsgKFxyXG5cdFx0XHRheGVzTGVuID8gJCQuZ2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoYXhpc0lkKSAqIGF4ZXNMZW4gOiAwXHJcblx0XHQpO1xyXG5cdH0sXHJcblxyXG5cdGdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGF4aXNJZCA9IGlzUm90YXRlZCA/IFwieFwiIDogXCJ5XCI7XHJcblx0XHRjb25zdCBheGVzTGVuID0gY29uZmlnW2BheGlzXyR7YXhpc0lkfV9heGVzYF0ubGVuZ3RoO1xyXG5cdFx0Y29uc3QgYXhpc1dpZHRoID0gJCQuZ2V0QXhpc1dpZHRoQnlBeGlzSWQoYXhpc0lkLCB3aXRob3V0UmVjb21wdXRlKTtcclxuXHRcdGxldCBwYWRkaW5nO1xyXG5cclxuXHRcdGlmIChpc1ZhbHVlKGNvbmZpZy5wYWRkaW5nX2xlZnQpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjb25maWcucGFkZGluZ19sZWZ0O1xyXG5cdFx0fSBlbHNlIGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyA9ICFjb25maWcuYXhpc194X3Nob3cgP1xyXG5cdFx0XHRcdDEgOiBNYXRoLm1heChjZWlsMTAoYXhpc1dpZHRoKSwgNDApO1xyXG5cdFx0fSBlbHNlIGlmICghY29uZmlnLmF4aXNfeV9zaG93IHx8IGNvbmZpZy5heGlzX3lfaW5uZXIpIHsgLy8gJiYgIWNvbmZpZy5heGlzX3JvdGF0ZWRcclxuXHRcdFx0cGFkZGluZyA9ICQkLmF4aXMuZ2V0WUF4aXNMYWJlbFBvc2l0aW9uKCkuaXNPdXRlciA/IDMwIDogMTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHBhZGRpbmcgPSBjZWlsMTAoYXhpc1dpZHRoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcGFkZGluZyArIChheGlzV2lkdGggKiBheGVzTGVuKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRlZmF1bHRQYWRkaW5nID0gMTA7XHJcblx0XHRjb25zdCBsZWdlbmRXaWR0aE9uUmlnaHQgPSAkJC5zdGF0ZS5pc0xlZ2VuZFJpZ2h0ID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSArIDIwIDogMDtcclxuXHRcdGNvbnN0IGF4ZXNMZW4gPSBjb25maWcuYXhpc195Ml9heGVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGF4aXNXaWR0aCA9ICQkLmdldEF4aXNXaWR0aEJ5QXhpc0lkKFwieTJcIik7XHJcblx0XHRsZXQgcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNWYWx1ZShjb25maWcucGFkZGluZ19yaWdodCkpIHtcclxuXHRcdFx0cGFkZGluZyA9IGNvbmZpZy5wYWRkaW5nX3JpZ2h0ICsgMTsgLy8gMSBpcyBuZWVkZWQgbm90IHRvIGhpZGUgdGljayBsaW5lXHJcblx0XHR9IGVsc2UgaWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0cGFkZGluZyA9IGRlZmF1bHRQYWRkaW5nICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xyXG5cdFx0fSBlbHNlIGlmICghY29uZmlnLmF4aXNfeTJfc2hvdyB8fCBjb25maWcuYXhpc195Ml9pbm5lcikgeyAvLyAmJiAhY29uZmlnLmF4aXNfcm90YXRlZFxyXG5cdFx0XHRwYWRkaW5nID0gMiArIGxlZ2VuZFdpZHRoT25SaWdodCArXHJcblx0XHRcdFx0KCQkLmF4aXMuZ2V0WTJBeGlzTGFiZWxQb3NpdGlvbigpLmlzT3V0ZXIgPyAyMCA6IDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFkZGluZyA9IGNlaWwxMChheGlzV2lkdGgpICsgbGVnZW5kV2lkdGhPblJpZ2h0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBwYWRkaW5nICsgKGF4aXNXaWR0aCAqIGF4ZXNMZW4pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgcGFyZW50IHJlY3QgZWxlbWVudCdzIHNpemVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHByb3BlcnR5L2F0dHJpYnV0ZSBuYW1lXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRQYXJlbnRSZWN0VmFsdWUoa2V5KSB7XHJcblx0XHRjb25zdCBvZmZzZXROYW1lID0gYG9mZnNldCR7Y2FwaXRhbGl6ZShrZXkpfWA7XHJcblx0XHRsZXQgcGFyZW50ID0gdGhpcy4kZWwuY2hhcnQubm9kZSgpO1xyXG5cdFx0bGV0IHY7XHJcblxyXG5cdFx0d2hpbGUgKCF2ICYmIHBhcmVudCAmJiBwYXJlbnQudGFnTmFtZSAhPT0gXCJCT0RZXCIpIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHR2ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2tleV07XHJcblx0XHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0XHRpZiAob2Zmc2V0TmFtZSBpbiBwYXJlbnQpIHtcclxuXHRcdFx0XHRcdC8vIEluIElFIGluIGNlcnRhaW4gY2FzZXMgZ2V0Qm91bmRpbmdDbGllbnRSZWN0XHJcblx0XHRcdFx0XHQvLyB3aWxsIGNhdXNlIGFuIFwidW5zcGVjaWZpZWQgZXJyb3JcIlxyXG5cdFx0XHRcdFx0diA9IHBhcmVudFtvZmZzZXROYW1lXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChrZXkgPT09IFwid2lkdGhcIikge1xyXG5cdFx0XHQvLyBTb21ldGltZXMgZWxlbWVudCdzIHdpZHRoIHZhbHVlIGlzIGluY29ycmVjdChleC4gZmxleCBjb250YWluZXIpXHJcblx0XHRcdC8vIEluIHRoaXMgY2FzZSwgdXNlIGJvZHkncyBvZmZzZXRXaWR0aCBpbnN0ZWFkLlxyXG5cdFx0XHRjb25zdCBib2R5V2lkdGggPSBkb2N1bWVudC5ib2R5Lm9mZnNldFdpZHRoO1xyXG5cclxuXHRcdFx0diA+IGJvZHlXaWR0aCAmJiAodiA9IGJvZHlXaWR0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHY7XHJcblx0fSxcclxuXHJcblx0Z2V0UGFyZW50V2lkdGgoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5nZXRQYXJlbnRSZWN0VmFsdWUoXCJ3aWR0aFwiKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQYXJlbnRIZWlnaHQoKSB7XHJcblx0XHRjb25zdCBoID0gdGhpcy4kZWwuY2hhcnQuc3R5bGUoXCJoZWlnaHRcIik7XHJcblxyXG5cdFx0cmV0dXJuIGguaW5kZXhPZihcInB4XCIpID4gMCA/IHBhcnNlSW50KGgsIDEwKSA6IDA7XHJcblx0fSxcclxuXHJcblx0Z2V0U3ZnTGVmdCh3aXRob3V0UmVjb21wdXRlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBoYXNMZWZ0QXhpc1JlY3QgPSBjb25maWcuYXhpc19yb3RhdGVkIHx8ICghY29uZmlnLmF4aXNfcm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeV9pbm5lcik7XHJcblx0XHRjb25zdCBsZWZ0QXhpc0NsYXNzID0gY29uZmlnLmF4aXNfcm90YXRlZCA/IENMQVNTLmF4aXNYIDogQ0xBU1MuYXhpc1k7XHJcblx0XHRjb25zdCBsZWZ0QXhpcyA9ICRlbC5tYWluLnNlbGVjdChgLiR7bGVmdEF4aXNDbGFzc31gKS5ub2RlKCk7XHJcblx0XHRjb25zdCBzdmdSZWN0ID0gbGVmdEF4aXMgJiYgaGFzTGVmdEF4aXNSZWN0ID8gbGVmdEF4aXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiB7cmlnaHQ6IDB9O1xyXG5cdFx0Y29uc3QgY2hhcnRSZWN0ID0gJGVsLmNoYXJ0Lm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuXHRcdGNvbnN0IGhhc0FyYyA9ICQkLmhhc0FyY1R5cGUoKTtcclxuXHRcdGNvbnN0IHN2Z0xlZnQgPSBzdmdSZWN0LnJpZ2h0IC0gY2hhcnRSZWN0LmxlZnQgLVxyXG5cdFx0XHQoaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh3aXRob3V0UmVjb21wdXRlKSk7XHJcblxyXG5cdFx0cmV0dXJuIHN2Z0xlZnQgPiAwID8gc3ZnTGVmdCA6IDA7XHJcblx0fSxcclxuXHJcblx0Z2V0QXhpc1dpZHRoQnlBeGlzSWQoaWQsIHdpdGhvdXRSZWNvbXB1dGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHBvc2l0aW9uID0gJCQuYXhpcy5nZXRMYWJlbFBvc2l0aW9uQnlJZChpZCk7XHJcblxyXG5cdFx0cmV0dXJuICQkLmF4aXMuZ2V0TWF4VGlja1dpZHRoKGlkLCB3aXRob3V0UmVjb21wdXRlKSArXHJcblx0XHRcdChwb3NpdGlvbi5pc0lubmVyID8gMjAgOiA0MCk7XHJcblx0fSxcclxuXHJcblx0Z2V0SG9yaXpvbnRhbEF4aXNIZWlnaHQoaWQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB7cm90YXRlZFBhZGRpbmcsIGlzTGVnZW5kUmlnaHQsIGlzTGVnZW5kSW5zZXR9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IGggPSAzMDtcclxuXHJcblx0XHRpZiAoaWQgPT09IFwieFwiICYmICFjb25maWcuYXhpc194X3Nob3cpIHtcclxuXHRcdFx0cmV0dXJuIDg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInhcIiAmJiBjb25maWcuYXhpc194X2hlaWdodCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9oZWlnaHQ7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlkID09PSBcInlcIiAmJiAhY29uZmlnLmF4aXNfeV9zaG93KSB7XHJcblx0XHRcdHJldHVybiBjb25maWcubGVnZW5kX3Nob3cgJiZcclxuXHRcdFx0XHQhaXNMZWdlbmRSaWdodCAmJlxyXG5cdFx0XHRcdCFpc0xlZ2VuZEluc2V0ID8gMTAgOiAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChpZCA9PT0gXCJ5MlwiICYmICFjb25maWcuYXhpc195Ml9zaG93KSB7XHJcblx0XHRcdHJldHVybiByb3RhdGVkUGFkZGluZy50b3A7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3Qgcm90YXRlID0gY29uZmlnW2BheGlzXyR7aWR9X3RpY2tfcm90YXRlYF07XHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlIHgveSBheGlzIGhlaWdodCB3aGVuIHRpY2sgcm90YXRlZFxyXG5cdFx0aWYgKFxyXG5cdFx0XHQoKGlkID09PSBcInhcIiAmJiAhaXNSb3RhdGVkKSB8fCAoL3kyPy8udGVzdChpZCkgJiYgaXNSb3RhdGVkKSkgJiYgcm90YXRlXHJcblx0XHQpIHtcclxuXHRcdFx0aCA9IDMwICtcclxuXHRcdFx0XHQkJC5heGlzLmdldE1heFRpY2tXaWR0aChpZCkgKlxyXG5cdFx0XHRcdE1hdGguY29zKE1hdGguUEkgKiAoOTAgLSByb3RhdGUpIC8gMTgwKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaCArXHJcblx0XHRcdCgkJC5heGlzLmdldExhYmVsUG9zaXRpb25CeUlkKGlkKS5pc0lubmVyID8gMCA6IDEwKSArXHJcblx0XHRcdChpZCA9PT0gXCJ5MlwiICYmICFpc1JvdGF0ZWQgPyAtMTAgOiAwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRFdmVudFJlY3RXaWR0aCgpIHtcclxuXHRcdHJldHVybiBNYXRoLm1heCgwLCB0aGlzLmF4aXMueC50aWNrSW50ZXJ2YWwoKSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2NhcGl0YWxpemUsIGdldEJvdW5kaW5nUmVjdCwgZ2V0UmFuZG9tLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nLCBnZXRUcmFuc2xhdGlvbn0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUZXh0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbH0gPSAkJDtcclxuXHJcblx0XHQkZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0fWApLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydFRleHRzKTtcclxuXHJcblx0XHQkZWwudGV4dCA9IGQzU2VsZWN0QWxsKFtdKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgY2hhcnRUZXh0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gJCQuZGF0YS50YXJnZXRzXHJcblx0ICovXHJcblx0dXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydFRleHQgPSAkJC5jbGFzc0NoYXJ0VGV4dC5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzVGV4dHMgPSAkJC5jbGFzc1RleHRzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBtYWluVGV4dFVwZGF0ZSA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRUZXh0c31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0VGV4dH1gKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydFRleHQoZCkgKyBjbGFzc0ZvY3VzKGQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluVGV4dEVudGVyID0gbWFpblRleHRVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydFRleHQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHRtYWluVGV4dEVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc1RleHRzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgdGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IEZhZGUtb3V0IHRyYW5zaXRpb24gZHVyYXRpb25cclxuXHQgKi9cclxuXHR1cGRhdGVUZXh0KGR1cmF0aW9uRm9yRXhpdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgZGF0YUZuID0gJCQubGFiZWxpc2hEYXRhLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NUZXh0ID0gJCQuY2xhc3NUZXh0LmJpbmQoJCQpO1xyXG5cclxuXHRcdCRlbC50ZXh0ID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy50ZXh0c31gKS5zZWxlY3RBbGwoYC4ke0NMQVNTLnRleHR9YClcclxuXHRcdFx0LmRhdGEoZCA9PiAodGhpcy5pc1JhZGFyVHlwZShkKSA/IGQudmFsdWVzIDogZGF0YUZuKGQpKSk7XHJcblxyXG5cdFx0JGVsLnRleHQuZXhpdCgpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uRm9yRXhpdClcclxuXHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0JGVsLnRleHQgPSAkZWwudGV4dC5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdC5tZXJnZSgkJC4kZWwudGV4dClcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc1RleHQpXHJcblx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgZCA9PiAoY29uZmlnLmF4aXNfcm90YXRlZCA/IChkLnZhbHVlIDwgMCA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpIDogXCJtaWRkbGVcIikpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlVGV4dENvbG9yLmJpbmQoJCQpKVxyXG5cdFx0XHQuc3R5bGUoXCJmaWxsLW9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC50ZXh0KChkLCBpLCBqKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSAkJC5pc0J1YmJsZVpUeXBlKGQpID8gJCQuZ2V0QnViYmxlWkRhdGEoZC52YWx1ZSwgXCJ6XCIpIDogZC52YWx1ZTtcclxuXHJcblx0XHRcdFx0cmV0dXJuICQkLmRhdGFMYWJlbEZvcm1hdChkLmlkKSh2YWx1ZSwgZC5pZCwgaSwgaik7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRleHRDb2xvcihkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBsYWJlbENvbG9ycyA9ICQkLmNvbmZpZy5kYXRhX2xhYmVsc19jb2xvcnM7XHJcblx0XHRsZXQgY29sb3I7XHJcblxyXG5cdFx0aWYgKGlzU3RyaW5nKGxhYmVsQ29sb3JzKSkge1xyXG5cdFx0XHRjb2xvciA9IGxhYmVsQ29sb3JzO1xyXG5cdFx0fSBlbHNlIGlmIChpc09iamVjdChsYWJlbENvbG9ycykpIHtcclxuXHRcdFx0Y29sb3IgPSBsYWJlbENvbG9yc1tkLmlkXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29sb3IgfHwgJCQuY29sb3IoZCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVkcmF3IGNoYXJ0VGV4dFxyXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IHggUG9zaXRpb25pbmcgZnVuY3Rpb24gZm9yIHhcclxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSB5IFBvc2l0aW9uaW5nIGZ1bmN0aW9uIGZvciB5XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JGbG93XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aXRoVHJhbnNpdGlvbiB0cmFuc2l0aW9uIGlzIGVuYWJsZWRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHJlZHJhd1RleHQoeCwgeSwgZm9yRmxvdywgd2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHQ6IGFueSA9IGdldFJhbmRvbSgpO1xyXG5cdFx0Y29uc3Qgb3BhY2l0eUZvclRleHQgPSBmb3JGbG93ID8gMCA6ICQkLm9wYWNpdHlGb3JUZXh0LmJpbmQoJCQpO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdHRoaXMuJGVsLnRleHQuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCB0ZXh0ID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdC8vIGRvIG5vdCBhcHBseSB0cmFuc2l0aW9uIGZvciBuZXdseSBhZGRlZCB0ZXh0IGVsZW1lbnRzXHJcblx0XHRcdFx0KHdpdGhUcmFuc2l0aW9uICYmIHRleHQuYXR0cihcInhcIikgPyB0ZXh0LnRyYW5zaXRpb24odCkgOiB0ZXh0KVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeSlcclxuXHRcdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgJCQudXBkYXRlVGV4dENvbG9yLmJpbmQoJCQpKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwiZmlsbC1vcGFjaXR5XCIsIG9wYWNpdHlGb3JUZXh0KTtcclxuXHRcdFx0fSlcclxuXHRcdF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHZhbHVlIG9mIHRoZSBlbGVtZW50XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGQzLnNlbGVjdGlvbn0gZWxlbWVudFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBjbGFzc05hbWVcclxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSB2YWx1ZSBvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcblx0ICovXHJcblx0Z2V0VGV4dFJlY3QoZWxlbWVudCwgY2xhc3NOYW1lKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgYmFzZSA9IChlbGVtZW50Lm5vZGUgPyBlbGVtZW50Lm5vZGUoKSA6IGVsZW1lbnQpO1xyXG5cclxuXHRcdGlmICghL3RleHQvaS50ZXN0KGJhc2UudGFnTmFtZSkpIHtcclxuXHRcdFx0YmFzZSA9IGJhc2UucXVlcnlTZWxlY3RvcihcInRleHRcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdGV4dCA9IGJhc2UudGV4dENvbnRlbnQ7XHJcblx0XHRjb25zdCBjYWNoZUtleSA9IGAkJHt0ZXh0LnJlcGxhY2UoL1xcVy9nLCBcIl9cIil9YDtcclxuXHRcdGxldCByZWN0ID0gJCQuY2FjaGUuZ2V0KGNhY2hlS2V5KTtcclxuXHJcblx0XHRpZiAoIXJlY3QpIHtcclxuXHRcdFx0JCQuJGVsLnN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKVxyXG5cdFx0XHRcdC5zdHlsZShcImZvbnRcIiwgZDNTZWxlY3QoYmFzZSkuc3R5bGUoXCJmb250XCIpKVxyXG5cdFx0XHRcdC5jbGFzc2VkKGNsYXNzTmFtZSwgdHJ1ZSlcclxuXHRcdFx0XHQudGV4dCh0ZXh0KVxyXG5cdFx0XHRcdC5jYWxsKHYgPT4ge1xyXG5cdFx0XHRcdFx0cmVjdCA9IGdldEJvdW5kaW5nUmVjdCh2Lm5vZGUoKSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIHJlY3QpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZWN0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHggb3IgeSBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGluZGljZXMgSW5kaWNlcyB2YWx1ZXNcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvclggd2hldGhlciBvciBub3QgdG8geFxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IGNvb3JkaW5hdGVzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVhZRm9yVGV4dChpbmRpY2VzLCBmb3JYKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB0eXBlcyA9IE9iamVjdC5rZXlzKGluZGljZXMpO1xyXG5cdFx0Y29uc3QgcG9pbnRzID0ge307XHJcblx0XHRjb25zdCBnZXR0ZXIgPSBmb3JYID8gJCQuZ2V0WEZvclRleHQgOiAkJC5nZXRZRm9yVGV4dDtcclxuXHJcblx0XHQkJC5oYXNUeXBlKFwicmFkYXJcIikgJiYgdHlwZXMucHVzaChcInJhZGFyXCIpO1xyXG5cclxuXHRcdHR5cGVzLmZvckVhY2godiA9PiB7XHJcblx0XHRcdHBvaW50c1t2XSA9ICQkW2BnZW5lcmF0ZUdldCR7Y2FwaXRhbGl6ZSh2KX1Qb2ludHNgXShpbmRpY2VzW3ZdLCBmYWxzZSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRjb25zdCB0eXBlID0gKCQkLmlzQXJlYVR5cGUoZCkgJiYgXCJhcmVhXCIpIHx8XHJcblx0XHRcdFx0KCQkLmlzQmFyVHlwZShkKSAmJiBcImJhclwiKSB8fFxyXG5cdFx0XHRcdCgkJC5pc1JhZGFyVHlwZShkKSAmJiBcInJhZGFyXCIpIHx8IFwibGluZVwiO1xyXG5cclxuXHRcdFx0cmV0dXJuIGdldHRlci5jYWxsKCQkLCBwb2ludHNbdHlwZV0oZCwgaSksIGQsIHRoaXMpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgY2VudGVyaXplZCB0ZXh0IHBvc2l0aW9uIGZvciBiYXIgdHlwZSBkYXRhLmxhYmVsLnRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIERhdGEgcG9pbnRzIHBvc2l0aW9uXHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGV4dEVsZW1lbnQgRGF0YSBsYWJlbCB0ZXh0IGVsZW1lbnRcclxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBQb3NpdGlvbiB2YWx1ZVxyXG5cdCAqL1xyXG5cdGdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHRpZiAoY29uZmlnLmRhdGFfbGFiZWxzLmNlbnRlcmVkICYmICQkLmlzQmFyVHlwZShkKSkge1xyXG5cdFx0XHRjb25zdCByZWN0ID0gZ2V0Qm91bmRpbmdSZWN0KHRleHRFbGVtZW50KTtcclxuXHRcdFx0Y29uc3QgaXNQb3NpdGl2ZSA9IGQudmFsdWUgPj0gMDtcclxuXHJcblx0XHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0XHRjb25zdCB3ID0gKFxyXG5cdFx0XHRcdFx0aXNQb3NpdGl2ZSA/XHJcblx0XHRcdFx0XHRcdHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXSA6XHJcblx0XHRcdFx0XHRcdHBvaW50c1swXVsxXSAtIHBvaW50c1sxXVsxXVxyXG5cdFx0XHRcdCkgLyAyICsgKHJlY3Qud2lkdGggLyAyKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGlzUG9zaXRpdmUgPyAtdyAtIDMgOiB3ICsgMjtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjb25zdCBoID0gKFxyXG5cdFx0XHRcdFx0aXNQb3NpdGl2ZSA/XHJcblx0XHRcdFx0XHRcdHBvaW50c1swXVsxXSAtIHBvaW50c1sxXVsxXSA6XHJcblx0XHRcdFx0XHRcdHBvaW50c1sxXVsxXSAtIHBvaW50c1swXVsxXVxyXG5cdFx0XHRcdCkgLyAyICsgKHJlY3QuaGVpZ2h0IC8gMik7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpc1Bvc2l0aXZlID8gaCA6IC1oIC0gMjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAwO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhLmxhYmVscy5wb3NpdGlvbiB2YWx1ZVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpZCBEYXRhIGlkIHZhbHVlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgeCB8IHlcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IFBvc2l0aW9uIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUZXh0UG9zKGlkLCB0eXBlKSB7XHJcblx0XHRjb25zdCBwb3MgPSB0aGlzLmNvbmZpZy5kYXRhX2xhYmVsc19wb3NpdGlvbjtcclxuXHJcblx0XHRyZXR1cm4gKGlkIGluIHBvcyA/IHBvc1tpZF0gOiBwb3MpW3R5cGVdIHx8IDA7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0cyB0aGUgeCBjb29yZGluYXRlIG9mIHRoZSB0ZXh0XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnRzXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGRhdGFcclxuXHQgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XHJcblx0ICogQHJldHVybnMge051bWJlcn0geCBjb29yZGluYXRlXHJcblx0ICovXHJcblx0Z2V0WEZvclRleHQocG9pbnRzLCBkLCB0ZXh0RWxlbWVudCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0bGV0IHhQb3M7XHJcblx0XHRsZXQgcGFkZGluZztcclxuXHJcblx0XHRpZiAoaXNSb3RhdGVkKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAkJC5pc0JhclR5cGUoZCkgPyA0IDogNjtcclxuXHRcdFx0eFBvcyA9IHBvaW50c1syXVsxXSArIHBhZGRpbmcgKiAoZC52YWx1ZSA8IDAgPyAtMSA6IDEpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eFBvcyA9ICQkLmhhc1R5cGUoXCJiYXJcIikgPyAocG9pbnRzWzJdWzBdICsgcG9pbnRzWzBdWzBdKSAvIDIgOiBwb2ludHNbMF1bMF07XHJcblx0XHR9XHJcblx0XHQvLyBzaG93IGxhYmVscyByZWdhcmRsZXNzIG9mIHRoZSBkb21haW4gaWYgdmFsdWUgaXMgbnVsbFxyXG5cdFx0aWYgKGQudmFsdWUgPT09IG51bGwpIHtcclxuXHRcdFx0aWYgKHhQb3MgPiBzdGF0ZS53aWR0aCkge1xyXG5cdFx0XHRcdGNvbnN0IHt3aWR0aH0gPSBnZXRCb3VuZGluZ1JlY3QodGV4dEVsZW1lbnQpO1xyXG5cclxuXHRcdFx0XHR4UG9zID0gc3RhdGUud2lkdGggLSB3aWR0aDtcclxuXHRcdFx0fSBlbHNlIGlmICh4UG9zIDwgMCkge1xyXG5cdFx0XHRcdHhQb3MgPSA0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKGlzUm90YXRlZCkge1xyXG5cdFx0XHR4UG9zICs9ICQkLmdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geFBvcyArICQkLmdldFRleHRQb3MoZC5pZCwgXCJ4XCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldHMgdGhlIHkgY29vcmRpbmF0ZSBvZiB0aGUgdGV4dFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHBvaW50c1xyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IHkgY29vcmRpbmF0ZVxyXG5cdCAqL1xyXG5cdGdldFlGb3JUZXh0KHBvaW50cywgZCwgdGV4dEVsZW1lbnQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IHIgPSBjb25maWcucG9pbnRfcjtcclxuXHRcdGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ1JlY3QodGV4dEVsZW1lbnQpO1xyXG5cdFx0bGV0IGJhc2VZID0gMztcclxuXHRcdGxldCB5UG9zO1xyXG5cclxuXHRcdGlmIChpc1JvdGF0ZWQpIHtcclxuXHRcdFx0eVBvcyA9IChwb2ludHNbMF1bMF0gKyBwb2ludHNbMl1bMF0gKyByZWN0LmhlaWdodCAqIDAuNikgLyAyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0eVBvcyA9IHBvaW50c1syXVsxXTtcclxuXHJcblx0XHRcdGlmIChpc051bWJlcihyKSAmJiByID4gNSAmJiAoJCQuaXNMaW5lVHlwZShkKSB8fCAkJC5pc1NjYXR0ZXJUeXBlKGQpKSkge1xyXG5cdFx0XHRcdGJhc2VZICs9IGNvbmZpZy5wb2ludF9yIC8gMi4zO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoZC52YWx1ZSA8IDAgfHwgKGQudmFsdWUgPT09IDAgJiYgIXN0YXRlLmhhc1Bvc2l0aXZlVmFsdWUgJiYgc3RhdGUuaGFzTmVnYXRpdmVWYWx1ZSkpIHtcclxuXHRcdFx0XHR5UG9zICs9IHJlY3QuaGVpZ2h0ICsgKCQkLmlzQmFyVHlwZShkKSA/IC1iYXNlWSA6IGJhc2VZKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgZGlmZiA9IC1iYXNlWSAqIDI7XHJcblxyXG5cdFx0XHRcdGlmICgkJC5pc0JhclR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdGRpZmYgPSAtYmFzZVk7XHJcblx0XHRcdFx0fSBlbHNlIGlmICgkJC5pc0J1YmJsZVR5cGUoZCkpIHtcclxuXHRcdFx0XHRcdGRpZmYgPSBiYXNlWTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHlQb3MgKz0gZGlmZjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNob3cgbGFiZWxzIHJlZ2FyZGxlc3Mgb2YgdGhlIGRvbWFpbiBpZiB2YWx1ZSBpcyBudWxsXHJcblx0XHRpZiAoZC52YWx1ZSA9PT0gbnVsbCAmJiAhaXNSb3RhdGVkKSB7XHJcblx0XHRcdGNvbnN0IGJveEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG5cclxuXHRcdFx0aWYgKHlQb3MgPCBib3hIZWlnaHQpIHtcclxuXHRcdFx0XHR5UG9zID0gYm94SGVpZ2h0O1xyXG5cdFx0XHR9IGVsc2UgaWYgKHlQb3MgPiB0aGlzLmhlaWdodCkge1xyXG5cdFx0XHRcdHlQb3MgPSB0aGlzLmhlaWdodCAtIDQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWlzUm90YXRlZCkge1xyXG5cdFx0XHR5UG9zICs9ICQkLmdldENlbnRlcmVkVGV4dFBvcyhkLCBwb2ludHMsIHRleHRFbGVtZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4geVBvcyArICQkLmdldFRleHRQb3MoZC5pZCwgXCJ5XCIpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGN1bGF0ZSBpZiB0d28gb3IgbW9yZSB0ZXh0IG5vZGVzIGFyZSBvdmVybGFwcGluZ1xyXG5cdCAqIE1hcmsgb3ZlcmxhcHBpbmcgdGV4dCBub2RlcyB3aXRoIFwidGV4dC1vdmVybGFwcGluZ1wiIGNsYXNzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAcGFyYW0ge251bWJlcn0gaWRcclxuXHQgKiBAcGFyYW0ge0NoYXJ0SW50ZXJuYWx9ICQkXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXHJcblx0ICovXHJcblx0bWFya092ZXJsYXBwZWQoaWQsICQkLCBzZWxlY3Rvcikge1xyXG5cdFx0Y29uc3QgdGV4dE5vZGVzID0gJCQuJGVsLmFyY3Muc2VsZWN0QWxsKHNlbGVjdG9yKTtcclxuXHRcdGNvbnN0IGZpbHRlcmVkVGV4dE5vZGVzID0gdGV4dE5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUuZGF0YS5pZCAhPT0gaWQpO1xyXG5cdFx0Y29uc3QgdGV4dE5vZGUgPSB0ZXh0Tm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5kYXRhLmlkID09PSBpZCk7XHJcblx0XHRjb25zdCB0cmFuc2xhdGUgPSBnZXRUcmFuc2xhdGlvbih0ZXh0Tm9kZS5ub2RlKCkpO1xyXG5cclxuXHRcdC8vIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGUgaHlwb3RlbnVzZVxyXG5cdFx0Y29uc3QgY2FsY0h5cG8gPSAoeCwgeSkgPT4gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpO1xyXG5cclxuXHRcdHRleHROb2RlLm5vZGUoKSAmJiBmaWx0ZXJlZFRleHROb2Rlcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRjb25zdCBjb29yZGluYXRlID0gZ2V0VHJhbnNsYXRpb24odGhpcyk7XHJcblx0XHRcdGNvbnN0IGZpbHRlcmVkVGV4dE5vZGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0Y29uc3Qgbm9kZUZvcldpZHRoID0gY2FsY0h5cG8odHJhbnNsYXRlLmUsIHRyYW5zbGF0ZS5mKSA+IGNhbGNIeXBvKGNvb3JkaW5hdGUuZSwgY29vcmRpbmF0ZS5mKSA/XHJcblx0XHRcdFx0dGV4dE5vZGUgOiBmaWx0ZXJlZFRleHROb2RlO1xyXG5cclxuXHRcdFx0Y29uc3Qgb3ZlcmxhcHNYID0gTWF0aC5jZWlsKE1hdGguYWJzKHRyYW5zbGF0ZS5lIC0gY29vcmRpbmF0ZS5lKSkgPFxyXG5cdFx0XHRcdE1hdGguY2VpbChub2RlRm9yV2lkdGgubm9kZSgpLmdldENvbXB1dGVkVGV4dExlbmd0aCgpKTtcclxuXHRcdFx0Y29uc3Qgb3ZlcmxhcHNZID0gTWF0aC5jZWlsKE1hdGguYWJzKHRyYW5zbGF0ZS5mIC0gY29vcmRpbmF0ZS5mKSkgPFxyXG5cdFx0XHRcdHBhcnNlSW50KHRleHROb2RlLnN0eWxlKFwiZm9udC1zaXplXCIpLCAwKTtcclxuXHJcblx0XHRcdGZpbHRlcmVkVGV4dE5vZGUuY2xhc3NlZChDTEFTUy5UZXh0T3ZlcmxhcHBpbmcsIG92ZXJsYXBzWCAmJiBvdmVybGFwc1kpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsY3VsYXRlIGlmIHR3byBvciBtb3JlIHRleHQgbm9kZXMgYXJlIG92ZXJsYXBwaW5nXHJcblx0ICogUmVtb3ZlIFwidGV4dC1vdmVybGFwcGluZ1wiIGNsYXNzIG9uIHNlbGVjdGVkIHRleHQgbm9kZXNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEBwYXJhbSB7Q2hhcnRJbnRlcm5hbH0gJCRcclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcclxuXHQgKi9cclxuXHR1bmRvTWFya092ZXJsYXBwZWQoJCQsIHNlbGVjdG9yKSB7XHJcblx0XHQkJC4kZWwuYXJjcy5zZWxlY3RBbGwoc2VsZWN0b3IpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGQzU2VsZWN0QWxsKFt0aGlzLCB0aGlzLnByZXZpb3VzU2libGluZ10pXHJcblx0XHRcdFx0XHQuY2xhc3NlZChDTEFTUy5UZXh0T3ZlcmxhcHBpbmcsIGZhbHNlKTtcclxuXHRcdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNOdW1iZXIsIHNldFRleHRWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgdGhlIHRleHQgcG9zaXRpb25cclxuICogQHBhcmFtIHtTdHJpbmd9IHBvcyByaWdodCwgbGVmdCBvciBjZW50ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIGNoYXJ0IHdpZHRoXHJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9IHRleHQtYW5jaG9yIHZhbHVlIG9yIHBvc2l0aW9uIGluIHBpeGVsXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUZXh0UG9zKHBvcyA9IFwibGVmdFwiLCB3aWR0aD86IG51bWJlcikge1xyXG5cdGNvbnN0IGlzTnVtID0gaXNOdW1iZXIod2lkdGgpO1xyXG5cdGxldCBwb3NpdGlvbjtcclxuXHJcblx0aWYgKHBvcy5pbmRleE9mKFwiY2VudGVyXCIpID4gLTEpIHtcclxuXHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdHBvc2l0aW9uID0gaXNOdW0gPyB3aWR0aCAvIDIgOiBcIm1pZGRsZVwiO1xyXG5cdH0gZWxzZSBpZiAocG9zLmluZGV4T2YoXCJyaWdodFwiKSA+IC0xKSB7XHJcblx0XHRwb3NpdGlvbiA9IGlzTnVtID8gd2lkdGggOiBcImVuZFwiO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRwb3NpdGlvbiA9IGlzTnVtID8gMCA6IFwic3RhcnRcIjtcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb3NpdGlvbjtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEluaXRpYWxpemVzIHRoZSB0aXRsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aW5pdFRpdGxlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcudGl0bGVfdGV4dCkge1xyXG5cdFx0XHQkZWwudGl0bGUgPSAkZWwuc3ZnLmFwcGVuZChcImdcIik7XHJcblxyXG5cdFx0XHRjb25zdCB0ZXh0ID0gJGVsLnRpdGxlXHJcblx0XHRcdFx0LmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBnZXRUZXh0UG9zKGNvbmZpZy50aXRsZV9wb3NpdGlvbikpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy50aXRsZSk7XHJcblxyXG5cdFx0XHRzZXRUZXh0VmFsdWUodGV4dCwgY29uZmlnLnRpdGxlX3RleHQsIFswLjMsIDEuNV0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJlZHJhdyB0aXRsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmVkcmF3VGl0bGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge2N1cnJlbnRXaWR0aH0sICRlbDoge3RpdGxlfX0gPSAkJDtcclxuXHJcblx0XHRpZiAodGl0bGUpIHtcclxuXHRcdFx0Y29uc3QgeSA9ICQkLnlGb3JUaXRsZS5jYWxsKCQkKTtcclxuXHJcblx0XHRcdGlmICgvZy9pLnRlc3QodGl0bGUubm9kZSgpLnRhZ05hbWUpKSB7XHJcblx0XHRcdFx0dGl0bGUuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7Z2V0VGV4dFBvcyhjb25maWcudGl0bGVfcG9zaXRpb24sIGN1cnJlbnRXaWR0aCl9LCAke3l9KWApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRpdGxlLmF0dHIoXCJ4XCIsICQkLnhGb3JUaXRsZS5jYWxsKCQkKSkuYXR0cihcInlcIiwgeSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZXR1cm5zIHRoZSB4IGF0dHJpYnV0ZSB2YWx1ZSBvZiB0aGUgdGl0bGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IHggYXR0cmlidXRlIHZhbHVlXHJcblx0ICovXHJcblx0eEZvclRpdGxlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtjdXJyZW50V2lkdGh9fSA9ICQkO1xyXG5cdFx0Y29uc3QgcG9zaXRpb24gPSBjb25maWcudGl0bGVfcG9zaXRpb24gfHwgXCJsZWZ0XCI7XHJcblx0XHRjb25zdCB0ZXh0UmVjdFdpZHRoID0gJCQuZ2V0VGV4dFJlY3QoJCQuJGVsLnRpdGxlLCBDTEFTUy50aXRsZSkud2lkdGg7XHJcblx0XHRsZXQgeDtcclxuXHJcblx0XHRpZiAoLyhyaWdodHxjZW50ZXIpLy50ZXN0KHBvc2l0aW9uKSkge1xyXG5cdFx0XHR4ID0gY3VycmVudFdpZHRoIC0gdGV4dFJlY3RXaWR0aDtcclxuXHJcblx0XHRcdGlmIChwb3NpdGlvbi5pbmRleE9mKFwicmlnaHRcIikgPj0gMCkge1xyXG5cdFx0XHRcdHggPSBjdXJyZW50V2lkdGggLSB0ZXh0UmVjdFdpZHRoIC0gY29uZmlnLnRpdGxlX3BhZGRpbmcucmlnaHQ7XHJcblx0XHRcdH0gZWxzZSBpZiAocG9zaXRpb24uaW5kZXhPZihcImNlbnRlclwiKSA+PSAwKSB7XHJcblx0XHRcdFx0eCA9IChjdXJyZW50V2lkdGggLSB0ZXh0UmVjdFdpZHRoKSAvIDI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7IC8vIGxlZnRcclxuXHRcdFx0eCA9IChjb25maWcudGl0bGVfcGFkZGluZy5sZWZ0IHx8IDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB4O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHkgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSB0aXRsZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHJldHVybnMge051bWJlcn0geSBhdHRyaWJ1dGUgdmFsdWVcclxuXHQgKi9cclxuXHR5Rm9yVGl0bGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICgkJC5jb25maWcudGl0bGVfcGFkZGluZy50b3AgfHwgMCkgK1xyXG5cdFx0XHQkJC5nZXRUZXh0UmVjdCgkJC4kZWwudGl0bGUsIENMQVNTLnRpdGxlKS5oZWlnaHQ7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRpdGxlIHBhZGRpbmdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IHBhZGRpbmcgdmFsdWVcclxuXHQgKi9cclxuXHRnZXRUaXRsZVBhZGRpbmcoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLnlGb3JUaXRsZSgpICsgKCQkLmNvbmZpZy50aXRsZV9wYWRkaW5nLmJvdHRvbSB8fCAwKTtcclxuXHR9LFxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdG1vdXNlIGFzIGQzTW91c2VcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7ZG9jdW1lbnR9IGZyb20gXCIuLi8uLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7aXNGdW5jdGlvbiwgaXNPYmplY3QsIGlzU3RyaW5nLCBpc1ZhbHVlLCBjYWxsRm4sIHNhbml0aXNlLCB0cGxQcm9jZXNzLCBpc1VuZGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXMgdGhlIHRvb2x0aXBcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRUb29sdGlwKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cdFx0Y29uc3QgYmluZHRvID0gY29uZmlnLnRvb2x0aXBfY29udGVudHMuYmluZHRvO1xyXG5cclxuXHRcdCRlbC50b29sdGlwID0gZDNTZWxlY3QoYmluZHRvKTtcclxuXHJcblx0XHRpZiAoJGVsLnRvb2x0aXAuZW1wdHkoKSkge1xyXG5cdFx0XHQkZWwudG9vbHRpcCA9ICRlbC5jaGFydFxyXG5cdFx0XHRcdC5zdHlsZShcInBvc2l0aW9uXCIsIFwicmVsYXRpdmVcIilcclxuXHRcdFx0XHQuYXBwZW5kKFwiZGl2XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy50b29sdGlwQ29udGFpbmVyKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJwb2ludGVyLWV2ZW50c1wiLCBcIm5vbmVcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTaG93IHRvb2x0aXAgaWYgbmVlZGVkXHJcblx0XHRpZiAoY29uZmlnLnRvb2x0aXBfaW5pdF9zaG93KSB7XHJcblx0XHRcdGlmICgkJC5pc1RpbWVTZXJpZXMoKSAmJiBpc1N0cmluZyhjb25maWcudG9vbHRpcF9pbml0X3gpKSB7XHJcblx0XHRcdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0c1swXTtcclxuXHRcdFx0XHRsZXQgaTtcclxuXHRcdFx0XHRsZXQgdmFsO1xyXG5cclxuXHRcdFx0XHRjb25maWcudG9vbHRpcF9pbml0X3ggPSAkJC5wYXJzZURhdGUoY29uZmlnLnRvb2x0aXBfaW5pdF94KTtcclxuXHJcblx0XHRcdFx0Zm9yIChpID0gMDsgKHZhbCA9IHRhcmdldHMudmFsdWVzW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAoKHZhbC54IC0gY29uZmlnLnRvb2x0aXBfaW5pdF94KSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbmZpZy50b29sdGlwX2luaXRfeCA9IGk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCRlbC50b29sdGlwLmh0bWwoJCQuZ2V0VG9vbHRpcEhUTUwoXHJcblx0XHRcdFx0JCQuZGF0YS50YXJnZXRzLm1hcChkID0+ICQkLmFkZE5hbWUoZC52YWx1ZXNbY29uZmlnLnRvb2x0aXBfaW5pdF94XSkpLFxyXG5cdFx0XHRcdCQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCksXHJcblx0XHRcdFx0JCQuZ2V0WUZvcm1hdCgkJC5oYXNBcmNUeXBlKG51bGwsIFtcInJhZGFyXCJdKSksXHJcblx0XHRcdFx0JCQuY29sb3JcclxuXHRcdFx0KSk7XHJcblxyXG5cdFx0XHRpZiAoIWJpbmR0bykge1xyXG5cdFx0XHRcdCRlbC50b29sdGlwLnN0eWxlKFwidG9wXCIsIGNvbmZpZy50b29sdGlwX2luaXRfcG9zaXRpb24udG9wKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwibGVmdFwiLCBjb25maWcudG9vbHRpcF9pbml0X3Bvc2l0aW9uLmxlZnQpXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIHRvb2x0aXAgSFRNTCBzdHJpbmdcclxuXHQgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3NcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gRm9ybWF0dGVkIEhUTUwgc3RyaW5nXHJcblx0ICovXHJcblx0Z2V0VG9vbHRpcEhUTUwoLi4uYXJncykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihjb25maWcudG9vbHRpcF9jb250ZW50cykgP1xyXG5cdFx0XHRjb25maWcudG9vbHRpcF9jb250ZW50cy5jYWxsKCQkLCAuLi5hcmdzKSA6ICQkLmdldFRvb2x0aXBDb250ZW50KC4uLmFyZ3MpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFJldHVybnMgdGhlIHRvb2x0aXAgY29udGVudChIVE1MIHN0cmluZylcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBkYXRhXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFRpdGxlRm9ybWF0IERlZmF1bHQgdGl0bGUgZm9ybWF0XHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZGVmYXVsdFZhbHVlRm9ybWF0IERlZmF1bHQgZm9ybWF0IGZvciBlYWNoIGRhdGEgdmFsdWUgaW4gdGhlIHRvb2x0aXAuXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY29sb3IgQ29sb3IgZnVuY3Rpb25cclxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBodG1sXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUb29sdGlwQ29udGVudChkLCBkZWZhdWx0VGl0bGVGb3JtYXQsIGRlZmF1bHRWYWx1ZUZvcm1hdCwgY29sb3IpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0aXRsZUZvcm1hdCA9IGNvbmZpZy50b29sdGlwX2Zvcm1hdF90aXRsZSB8fCBkZWZhdWx0VGl0bGVGb3JtYXQ7XHJcblx0XHRjb25zdCBuYW1lRm9ybWF0ID0gY29uZmlnLnRvb2x0aXBfZm9ybWF0X25hbWUgfHwgKG5hbWUgPT4gbmFtZSk7XHJcblx0XHRjb25zdCB2YWx1ZUZvcm1hdCA9IGNvbmZpZy50b29sdGlwX2Zvcm1hdF92YWx1ZSB8fCAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSA/ICgodiwgcmF0aW8pID0+IGAkeyhyYXRpbyAqIDEwMCkudG9GaXhlZCgyKX0lYCkgOiBkZWZhdWx0VmFsdWVGb3JtYXQpO1xyXG5cdFx0Y29uc3Qgb3JkZXIgPSBjb25maWcudG9vbHRpcF9vcmRlcjtcclxuXHRcdGNvbnN0IGdldFJvd1ZhbHVlID0gcm93ID0+ICgkJC5pc0J1YmJsZVpUeXBlKHJvdykgPyAkJC5nZXRCdWJibGVaRGF0YShyb3cudmFsdWUsIFwielwiKSA6ICQkLmdldEJhc2VWYWx1ZShyb3cpKTtcclxuXHRcdGNvbnN0IGdldEJnQ29sb3IgPSAkJC5sZXZlbENvbG9yID8gcm93ID0+ICQkLmxldmVsQ29sb3Iocm93LnZhbHVlKSA6IHJvdyA9PiBjb2xvcihyb3cpO1xyXG5cdFx0Y29uc3QgY29udGVudHMgPSBjb25maWcudG9vbHRpcF9jb250ZW50cztcclxuXHRcdGNvbnN0IHRwbFN0ciA9IGNvbnRlbnRzLnRlbXBsYXRlO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHMoKTtcclxuXHJcblx0XHRpZiAob3JkZXIgPT09IG51bGwgJiYgY29uZmlnLmRhdGFfZ3JvdXBzLmxlbmd0aCkge1xyXG5cdFx0XHQvLyBmb3Igc3RhY2tlZCBkYXRhLCBvcmRlciBzaG91bGQgYWxpZ25lZCB3aXRoIHRoZSB2aXN1YWxseSBkaXNwbGF5ZWQgZGF0YVxyXG5cdFx0XHRjb25zdCBpZHMgPSAkJC5vcmRlclRhcmdldHMoJCQuZGF0YS50YXJnZXRzKVxyXG5cdFx0XHRcdC5tYXAoaTIgPT4gaTIuaWQpXHJcblx0XHRcdFx0LnJldmVyc2UoKTtcclxuXHJcblx0XHRcdGQuc29ydCgoYSwgYikgPT4ge1xyXG5cdFx0XHRcdGxldCB2MSA9IGEgPyBhLnZhbHVlIDogbnVsbDtcclxuXHRcdFx0XHRsZXQgdjIgPSBiID8gYi52YWx1ZSA6IG51bGw7XHJcblxyXG5cdFx0XHRcdGlmICh2MSA+IDAgJiYgdjIgPiAwKSB7XHJcblx0XHRcdFx0XHR2MSA9IGEuaWQgPyBpZHMuaW5kZXhPZihhLmlkKSA6IG51bGw7XHJcblx0XHRcdFx0XHR2MiA9IGIuaWQgPyBpZHMuaW5kZXhPZihiLmlkKSA6IG51bGw7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdjEgLSB2MjtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKC9eKGFzY3xkZXNjKSQvLnRlc3Qob3JkZXIpKSB7XHJcblx0XHRcdGNvbnN0IGlzQXNjZW5kaW5nID0gb3JkZXIgPT09IFwiYXNjXCI7XHJcblxyXG5cdFx0XHRkLnNvcnQoKGEsIGIpID0+IHtcclxuXHRcdFx0XHRjb25zdCB2MSA9IGEgPyBnZXRSb3dWYWx1ZShhKSA6IG51bGw7XHJcblx0XHRcdFx0Y29uc3QgdjIgPSBiID8gZ2V0Um93VmFsdWUoYikgOiBudWxsO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gaXNBc2NlbmRpbmcgPyB2MSAtIHYyIDogdjIgLSB2MTtcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2UgaWYgKGlzRnVuY3Rpb24ob3JkZXIpKSB7XHJcblx0XHRcdGQuc29ydChvcmRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgdHBsID0gJCQuZ2V0VG9vbHRpcENvbnRlbnRUZW1wbGF0ZSh0cGxTdHIpO1xyXG5cdFx0Y29uc3QgbGVuID0gZC5sZW5ndGg7XHJcblx0XHRsZXQgdGV4dDtcclxuXHRcdGxldCByb3c7XHJcblx0XHRsZXQgcGFyYW07XHJcblx0XHRsZXQgdmFsdWU7XHJcblx0XHRsZXQgaTtcclxuXHJcblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0cm93ID0gZFtpXTtcclxuXHJcblx0XHRcdGlmICghcm93IHx8ICEoZ2V0Um93VmFsdWUocm93KSB8fCBnZXRSb3dWYWx1ZShyb3cpID09PSAwKSkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaXNVbmRlZmluZWQodGV4dCkpIHtcclxuXHRcdFx0XHRjb25zdCB0aXRsZSA9IHNhbml0aXNlKHRpdGxlRm9ybWF0ID8gdGl0bGVGb3JtYXQocm93LngpIDogcm93LngpO1xyXG5cclxuXHRcdFx0XHR0ZXh0ID0gdHBsUHJvY2Vzcyh0cGxbMF0sIHtcclxuXHRcdFx0XHRcdENMQVNTX1RPT0xUSVA6IENMQVNTLnRvb2x0aXAsXHJcblx0XHRcdFx0XHRUSVRMRTogaXNWYWx1ZSh0aXRsZSkgPyAoXHJcblx0XHRcdFx0XHRcdHRwbFN0ciA/IHRpdGxlIDogYDx0cj48dGggY29sc3Bhbj1cIjJcIj4ke3RpdGxlfTwvdGg+PC90cj5gXHJcblx0XHRcdFx0XHQpIDogXCJcIlxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRwYXJhbSA9IFtyb3cucmF0aW8sIHJvdy5pZCwgcm93LmluZGV4LCBkXTtcclxuXHRcdFx0dmFsdWUgPSBzYW5pdGlzZSh2YWx1ZUZvcm1hdChnZXRSb3dWYWx1ZShyb3cpLCAuLi5wYXJhbSkpO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzQXJlYVJhbmdlVHlwZShyb3cpKSB7XHJcblx0XHRcdFx0Y29uc3QgW2hpZ2gsIGxvd10gPSBbXCJoaWdoXCIsIFwibG93XCJdLm1hcCh2ID0+IHNhbml0aXNlKFxyXG5cdFx0XHRcdFx0dmFsdWVGb3JtYXQoJCQuZ2V0QXJlYVJhbmdlRGF0YShyb3csIHYpLCAuLi5wYXJhbSlcclxuXHRcdFx0XHQpKTtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSBgPGI+TWlkOjwvYj4gJHt2YWx1ZX0gPGI+SGlnaDo8L2I+ICR7aGlnaH0gPGI+TG93OjwvYj4gJHtsb3d9YDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHQvLyBTa2lwIGVsZW1lbnRzIHdoZW4gdGhlaXIgbmFtZSBpcyBzZXQgdG8gbnVsbFxyXG5cdFx0XHRcdGlmIChyb3cubmFtZSA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBuYW1lID0gc2FuaXRpc2UobmFtZUZvcm1hdChyb3cubmFtZSwgLi4ucGFyYW0pKTtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9IGdldEJnQ29sb3Iocm93KTtcclxuXHRcdFx0XHRjb25zdCBjb250ZW50VmFsdWUgPSB7XHJcblx0XHRcdFx0XHRDTEFTU19UT09MVElQX05BTUU6IENMQVNTLnRvb2x0aXBOYW1lICsgJCQuZ2V0VGFyZ2V0U2VsZWN0b3JTdWZmaXgocm93LmlkKSxcclxuXHRcdFx0XHRcdENPTE9SOiAodHBsU3RyIHx8ICEkJC5wYXR0ZXJucykgPyBjb2xvciA6IGA8c3ZnPjxyZWN0IHN0eWxlPVwiZmlsbDoke2NvbG9yfVwiIHdpZHRoPVwiMTBcIiBoZWlnaHQ9XCIxMFwiPjwvcmVjdD48L3N2Zz5gLFxyXG5cdFx0XHRcdFx0TkFNRTogbmFtZSxcclxuXHRcdFx0XHRcdFZBTFVFOiB2YWx1ZVxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdGlmICh0cGxTdHIgJiYgaXNPYmplY3QoY29udGVudHMudGV4dCkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdGFyZ2V0SWRzLmluZGV4T2Yocm93LmlkKTtcclxuXHJcblx0XHRcdFx0XHRPYmplY3Qua2V5cyhjb250ZW50cy50ZXh0KS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRcdFx0XHRcdGNvbnRlbnRWYWx1ZVtrZXldID0gY29udGVudHMudGV4dFtrZXldW2luZGV4XTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dCArPSB0cGxQcm9jZXNzKHRwbFsxXSwgY29udGVudFZhbHVlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBgJHt0ZXh0fTwvdGFibGU+YDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGNvbnRlbnQgdGVtcGxhdGUgc3RyaW5nXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRwbFN0clxyXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gVGVtcGxhdGUgc3RyaW5nXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRUb29sdGlwQ29udGVudFRlbXBsYXRlKHRwbFN0cikge1xyXG5cdFx0cmV0dXJuICh0cGxTdHIgfHwgYDx0YWJsZSBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUH1cIj48dGJvZHk+XHJcblx0XHRcdFx0ez1USVRMRX1cclxuXHRcdFx0XHR7ezx0ciBjbGFzcz1cIns9Q0xBU1NfVE9PTFRJUF9OQU1FfVwiPlxyXG5cdFx0XHRcdFx0PHRkIGNsYXNzPVwibmFtZVwiPiR7dGhpcy5wYXR0ZXJucyA/IGB7PUNPTE9SfWAgOiBgPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOns9Q09MT1J9XCI+PC9zcGFuPmB9ez1OQU1FfTwvdGQ+XHJcblx0XHRcdFx0XHQ8dGQgY2xhc3M9XCJ2YWx1ZVwiPns9VkFMVUV9PC90ZD5cclxuXHRcdFx0XHQ8L3RyPn19XHJcblx0XHRcdDwvdGJvZHk+PC90YWJsZT5gKVxyXG5cdFx0XHQucmVwbGFjZSgvKFxccj9cXG58XFx0KS9nLCBcIlwiKVxyXG5cdFx0XHQuc3BsaXQoL3t7KC4qKX19Lyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmV0dXJucyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXBcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZGF0YVRvU2hvdyBkYXRhXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRXaWR0aCBXaWR0aCB2YWx1ZSBvZiB0b29sdGlwIGVsZW1lbnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdEhlaWdodCBIZWlnaHQgdmFsdWUgb2YgdG9vbHRpcCBlbGVtZW50XHJcblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxyXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IHRvcCwgbGVmdCB2YWx1ZVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dG9vbHRpcFBvc2l0aW9uKGRhdGFUb1Nob3csIHRXaWR0aCwgdEhlaWdodCwgZWxlbWVudCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCB7d2lkdGgsIGhlaWdodCwgY3VycmVudFdpZHRoLCBjdXJyZW50SGVpZ2h0LCBpc0xlZ2VuZFJpZ2h0LCBpbnB1dFR5cGV9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiAhY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGU7XHJcblx0XHRjb25zdCBzdmdMZWZ0ID0gJCQuZ2V0U3ZnTGVmdCh0cnVlKTtcclxuXHRcdGxldCBbbGVmdCwgdG9wXSA9IGQzTW91c2UoZWxlbWVudCk7XHJcblx0XHRsZXQgY2hhcnRSaWdodCA9IHN2Z0xlZnQgKyBjdXJyZW50V2lkdGggLSAkJC5nZXRDdXJyZW50UGFkZGluZ1JpZ2h0KCk7XHJcblxyXG5cdFx0dG9wICs9IDIwO1xyXG5cclxuXHRcdC8vIERldGVybWluZSB0b29sdGlwIHBvc2l0aW9uXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdGNvbnN0IHJhdyA9IGlucHV0VHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcclxuXHJcblx0XHRcdGlmICghcmF3KSB7XHJcblx0XHRcdFx0dG9wICs9IGhhc0dhdWdlID8gaGVpZ2h0IDogaGVpZ2h0IC8gMjtcclxuXHRcdFx0XHRsZWZ0ICs9ICh3aWR0aCAtIChpc0xlZ2VuZFJpZ2h0ID8gJCQuZ2V0TGVnZW5kV2lkdGgoKSA6IDApKSAvIDI7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbnN0IGRhdGFTY2FsZSA9IHNjYWxlLngoZGF0YVRvU2hvd1swXS54KTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuYXhpc19yb3RhdGVkKSB7XHJcblx0XHRcdFx0dG9wID0gZGF0YVNjYWxlICsgMjA7XHJcblx0XHRcdFx0bGVmdCArPSBzdmdMZWZ0ICsgMTAwO1xyXG5cdFx0XHRcdGNoYXJ0UmlnaHQgLT0gc3ZnTGVmdDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0b3AgLT0gNTtcclxuXHRcdFx0XHRsZWZ0ID0gc3ZnTGVmdCArICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCh0cnVlKSArIDIwICsgKHNjYWxlLnpvb20gPyBsZWZ0IDogZGF0YVNjYWxlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJpZ2h0ID0gbGVmdCArIHRXaWR0aDtcclxuXHJcblx0XHRpZiAocmlnaHQgPiBjaGFydFJpZ2h0KSB7XHJcblx0XHRcdC8vIDIwIGlzIG5lZWRlZCBmb3IgRmlyZWZveCB0byBrZWVwIHRvb2x0aXAgd2lkdGhcclxuXHRcdFx0bGVmdCAtPSByaWdodCAtIGNoYXJ0UmlnaHQgKyAyMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodG9wICsgdEhlaWdodCA+IGN1cnJlbnRIZWlnaHQpIHtcclxuXHRcdFx0dG9wIC09IGhhc0dhdWdlID8gdEhlaWdodCAqIDMgOiB0SGVpZ2h0ICsgMzA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRvcCA8IDApIHtcclxuXHRcdFx0dG9wID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge3RvcCwgbGVmdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2hvdyB0aGUgdG9vbHRpcFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHNlbGVjdGVkRGF0YVxyXG5cdCAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuXHQgKi9cclxuXHRzaG93VG9vbHRpcChzZWxlY3RlZERhdGEsIGVsZW1lbnQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge3Rvb2x0aXB9fSA9ICQkO1xyXG5cdFx0Y29uc3QgYmluZHRvID0gY29uZmlnLnRvb2x0aXBfY29udGVudHMuYmluZHRvO1xyXG5cdFx0Y29uc3QgZm9yQXJjID0gJCQuaGFzQXJjVHlwZShudWxsLCBbXCJyYWRhclwiXSk7XHJcblx0XHRjb25zdCBkYXRhVG9TaG93ID0gc2VsZWN0ZWREYXRhLmZpbHRlcihkID0+IGQgJiYgaXNWYWx1ZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcclxuXHRcdGNvbnN0IHBvc2l0aW9uRnVuY3Rpb24gPSBjb25maWcudG9vbHRpcF9wb3NpdGlvbiB8fCAkJC50b29sdGlwUG9zaXRpb247XHJcblxyXG5cdFx0aWYgKGRhdGFUb1Nob3cubGVuZ3RoID09PSAwIHx8ICFjb25maWcudG9vbHRpcF9zaG93KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBkYXR1bSA9IHRvb2x0aXAuZGF0dW0oKTtcclxuXHRcdGNvbnN0IGRhdGFTdHIgPSBKU09OLnN0cmluZ2lmeShzZWxlY3RlZERhdGEpO1xyXG5cdFx0bGV0IHdpZHRoID0gKGRhdHVtICYmIGRhdHVtLndpZHRoKSB8fCAwO1xyXG5cdFx0bGV0IGhlaWdodCA9IChkYXR1bSAmJiBkYXR1bS5oZWlnaHQpIHx8IDA7XHJcblxyXG5cdFx0aWYgKCFkYXR1bSB8fCBkYXR1bS5jdXJyZW50ICE9PSBkYXRhU3RyKSB7XHJcblx0XHRcdGNvbnN0IGluZGV4ID0gc2VsZWN0ZWREYXRhLmNvbmNhdCgpLnNvcnQoKVswXS5pbmRleDtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3csICQkLCAkJC5hcGksIHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0XHQvLyBzZXQgdG9vbHRpcCBjb250ZW50XHJcblx0XHRcdHRvb2x0aXBcclxuXHRcdFx0XHQuaHRtbCgkJC5nZXRUb29sdGlwSFRNTChcclxuXHRcdFx0XHRcdHNlbGVjdGVkRGF0YSxcclxuXHRcdFx0XHRcdCQkLmF4aXMuZ2V0WEF4aXNUaWNrRm9ybWF0KCksXHJcblx0XHRcdFx0XHQkJC5nZXRZRm9ybWF0KGZvckFyYyksXHJcblx0XHRcdFx0XHQkJC5jb2xvclxyXG5cdFx0XHRcdCkpXHJcblx0XHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCBudWxsKVxyXG5cdFx0XHRcdC5zdHlsZShcInZpc2liaWxpdHlcIiwgbnVsbCkgLy8gZm9yIElFOVxyXG5cdFx0XHRcdC5kYXR1bSh7XHJcblx0XHRcdFx0XHRpbmRleCxcclxuXHRcdFx0XHRcdGN1cnJlbnQ6IGRhdGFTdHIsXHJcblx0XHRcdFx0XHR3aWR0aDogd2lkdGggPSB0b29sdGlwLnByb3BlcnR5KFwib2Zmc2V0V2lkdGhcIiksXHJcblx0XHRcdFx0XHRoZWlnaHQ6IGhlaWdodCA9IHRvb2x0aXAucHJvcGVydHkoXCJvZmZzZXRIZWlnaHRcIilcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbnNob3duLCAkJCwgJCQuYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cdFx0XHQkJC5faGFuZGxlTGlua2VkQ2hhcnRzKHRydWUsIGluZGV4KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIWJpbmR0bykge1xyXG5cdFx0XHQvLyBHZXQgdG9vbHRpcCBkaW1lbnNpb25zXHJcblx0XHRcdGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25GdW5jdGlvbi5jYWxsKHRoaXMsIGRhdGFUb1Nob3csIHdpZHRoLCBoZWlnaHQsIGVsZW1lbnQpO1xyXG5cclxuXHRcdFx0Ly8gU2V0IHRvb2x0aXAgcG9zaXRpb25cclxuXHRcdFx0dG9vbHRpcFxyXG5cdFx0XHRcdC5zdHlsZShcInRvcFwiLCBgJHtwb3NpdGlvbi50b3B9cHhgKVxyXG5cdFx0XHRcdC5zdHlsZShcImxlZnRcIiwgYCR7cG9zaXRpb24ubGVmdH1weGApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgdGhlIHRvb2x0aXBcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcmNlIEZvcmNlIHRvIGhpZGVcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGhpZGVUb29sdGlwKGZvcmNlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHt0b29sdGlwfX0gPSAkJDtcclxuXHJcblx0XHRpZiAodG9vbHRpcC5zdHlsZShcImRpc3BsYXlcIikgIT09IFwibm9uZVwiICYmICghY29uZmlnLnRvb2x0aXBfZG9Ob3RIaWRlIHx8IGZvcmNlKSkge1xyXG5cdFx0XHRjb25zdCBzZWxlY3RlZERhdGEgPSBKU09OLnBhcnNlKHRvb2x0aXAuZGF0dW0oKS5jdXJyZW50KTtcclxuXHJcblx0XHRcdGNhbGxGbihjb25maWcudG9vbHRpcF9vbmhpZGUsICQkLCAkJC5hcGksIHNlbGVjdGVkRGF0YSk7XHJcblxyXG5cdFx0XHQvLyBoaWRlIHRvb2x0aXBcclxuXHRcdFx0dG9vbHRpcFxyXG5cdFx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJub25lXCIpXHJcblx0XHRcdFx0LnN0eWxlKFwidmlzaWJpbGl0eVwiLCBcImhpZGRlblwiKSAvLyBmb3IgSUU5XHJcblx0XHRcdFx0LmRhdHVtKG51bGwpO1xyXG5cclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy50b29sdGlwX29uaGlkZGVuLCAkJCwgJCQuYXBpLCBzZWxlY3RlZERhdGEpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRvZ2dsZSBkaXNwbGF5IGZvciBsaW5rZWQgY2hhcnQgaW5zdGFuY2VzXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBzaG93IHRydWU6IHNob3csIGZhbHNlOiBoaWRlXHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IHggQXhpcyBpbmRleFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0X2hhbmRsZUxpbmtlZENoYXJ0cyhzaG93LCBpbmRleCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGNoYXJ0cyA9ICQkLmNoYXJ0cztcclxuXHJcblx0XHRpZiAoY29uZmlnLnRvb2x0aXBfbGlua2VkICYmIGNoYXJ0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdGNvbnN0IGxpbmtlZE5hbWUgPSBjb25maWcudG9vbHRpcF9saW5rZWRfbmFtZTtcclxuXHJcblx0XHRcdGNoYXJ0cy5mb3JFYWNoKGMgPT4ge1xyXG5cdFx0XHRcdGlmIChjICE9PSAkJC5hcGkpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHtjb25maWd9ID0gYy5pbnRlcm5hbDtcclxuXHRcdFx0XHRcdGNvbnN0IGlzTGlua2VkID0gY29uZmlnLnRvb2x0aXBfbGlua2VkO1xyXG5cdFx0XHRcdFx0Y29uc3QgbmFtZSA9IGNvbmZpZy50b29sdGlwX2xpbmtlZF9uYW1lO1xyXG5cdFx0XHRcdFx0Y29uc3QgaXNJbkRvbSA9IGRvY3VtZW50LmJvZHkuY29udGFpbnMoYy5lbGVtZW50KTtcclxuXHJcblx0XHRcdFx0XHRpZiAoaXNMaW5rZWQgJiYgbGlua2VkTmFtZSA9PT0gbmFtZSAmJiBpc0luRG9tKSB7XHJcblx0XHRcdFx0XHRcdGNvbnN0IGRhdGEgPSBjLmludGVybmFsLiRlbC50b29sdGlwLmRhdGEoKVswXTtcclxuXHRcdFx0XHRcdFx0Y29uc3QgaXNOb3RTYW1lSW5kZXggPSBpbmRleCAhPT0gKGRhdGEgJiYgZGF0YS5pbmRleCk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBwcmV2ZW50IHRocm93aW5nIGVycm9yIGZvciBub24tcGFpcmVkIGxpbmtlZCBpbmRleGVzXHJcblx0XHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdFx0aWYgKHNob3cgJiYgaXNOb3RTYW1lSW5kZXgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5zaG93KHtpbmRleH0pO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIXNob3cpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGMudG9vbHRpcC5oaWRlKCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9IGNhdGNoIChlKSB7fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNTdHJpbmcsIGlzQXJyYXl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLy8gZGVmaW5lZCBjaGFydCB0eXBlcyBhcyBjYXRlZ29yeVxyXG5jb25zdCBUWVBFUzoge1trZXk6IHN0cmluZ106IHN0cmluZ1tdfSA9IHtcclxuXHRBcmVhOiBbXCJhcmVhXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiLCBcImFyZWEtc3RlcFwiXSxcclxuXHRBcmVhUmFuZ2U6IFtcImFyZWEtc3BsaW5lLXJhbmdlXCIsIFwiYXJlYS1saW5lLXJhbmdlXCJdLFxyXG5cdEFyYzogW1wicGllXCIsIFwiZG9udXRcIiwgXCJnYXVnZVwiLCBcInJhZGFyXCJdLFxyXG5cdExpbmU6IFtcImxpbmVcIiwgXCJzcGxpbmVcIiwgXCJhcmVhXCIsIFwiYXJlYS1zcGxpbmVcIiwgXCJhcmVhLXNwbGluZS1yYW5nZVwiLCBcImFyZWEtbGluZS1yYW5nZVwiLCBcInN0ZXBcIiwgXCJhcmVhLXN0ZXBcIl0sXHJcblx0U3RlcDogW1wic3RlcFwiLCBcImFyZWEtc3RlcFwiXSxcclxuXHRTcGxpbmU6IFtcInNwbGluZVwiLCBcImFyZWEtc3BsaW5lXCIsIFwiYXJlYS1zcGxpbmUtcmFuZ2VcIl1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRzZXRUYXJnZXRUeXBlKHRhcmdldElkcywgdHlwZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHt3aXRob3V0RmFkZUlufX0gPSAkJDtcclxuXHJcblx0XHQkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHR3aXRob3V0RmFkZUluW2lkXSA9ICh0eXBlID09PSBjb25maWcuZGF0YV90eXBlc1tpZF0pO1xyXG5cdFx0XHRjb25maWcuZGF0YV90eXBlc1tpZF0gPSB0eXBlO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYgKCF0YXJnZXRJZHMpIHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfdHlwZSA9IHR5cGU7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aGFzVHlwZSh0eXBlLCB0YXJnZXRzVmFsdWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB0eXBlcyA9IGNvbmZpZy5kYXRhX3R5cGVzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9IHRhcmdldHNWYWx1ZSB8fCAkJC5kYXRhLnRhcmdldHM7XHJcblx0XHRsZXQgaGFzID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKHRhcmdldHMgJiYgdGFyZ2V0cy5sZW5ndGgpIHtcclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKHRhcmdldCA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdCA9IHR5cGVzW3RhcmdldC5pZF07XHJcblxyXG5cdFx0XHRcdGlmICgodCAmJiB0LmluZGV4T2YodHlwZSkgPj0gMCkgfHwgKCF0ICYmIHR5cGUgPT09IFwibGluZVwiKSkge1xyXG5cdFx0XHRcdFx0aGFzID0gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmIChPYmplY3Qua2V5cyh0eXBlcykubGVuZ3RoKSB7XHJcblx0XHRcdE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0XHRpZiAodHlwZXNbaWRdID09PSB0eXBlKSB7XHJcblx0XHRcdFx0XHRoYXMgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoYXMgPSBjb25maWcuZGF0YV90eXBlID09PSB0eXBlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBoYXM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQ2hlY2sgaWYgY29udGFpbnMgZ2l2ZW4gY2hhcnQgdHlwZXNcclxuXHQgKiBAcGFybWEge1N0cmluZ30gdHlwZSBUeXBlIGtleVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZXhjbHVkZSBFeGNsdWRlZCB0eXBlc1xyXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRoYXNUeXBlT2YodHlwZSwgdGFyZ2V0cywgZXhjbHVkZSA9IFtdKSB7XHJcblx0XHRyZXR1cm4gIVRZUEVTW3R5cGVdXHJcblx0XHRcdC8vIEB0cy1pZ25vcmVcclxuXHRcdFx0LmZpbHRlcih2ID0+IGV4Y2x1ZGUuaW5kZXhPZih2KSA9PT0gLTEpXHJcblx0XHRcdC5ldmVyeSh2ID0+ICF0aGlzLmhhc1R5cGUodiwgdGFyZ2V0cykpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIENoZWNrIGlmIGdpdmVuIGRhdGEgaXMgY2VydGFpbiBjaGFydCB0eXBlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdHlwZSBjaGFydCB0eXBlXHJcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGlzVHlwZU9mKGQsIHR5cGUpIHtcclxuXHRcdGNvbnN0IGlkID0gaXNTdHJpbmcoZCkgPyBkIDogZC5pZDtcclxuXHRcdGNvbnN0IGRhdGFUeXBlID0gdGhpcy5jb25maWcuZGF0YV90eXBlc1tpZF07XHJcblxyXG5cdFx0cmV0dXJuIGlzQXJyYXkodHlwZSkgP1xyXG5cdFx0XHR0eXBlLmluZGV4T2YoZGF0YVR5cGUpID49IDAgOiBkYXRhVHlwZSA9PT0gdHlwZTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBDaGVjayBpZiBjb250YWlucyBhcmMgdHlwZXMgY2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0c1xyXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGV4Y2x1ZGUgRXhjbHVkZWQgdHlwZXNcclxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aGFzQXJjVHlwZSh0YXJnZXRzLCBleGNsdWRlKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5oYXNUeXBlT2YoXCJBcmNcIiwgdGFyZ2V0cywgZXhjbHVkZSk7XHJcblx0fSxcclxuXHJcblx0aGFzTXVsdGlBcmNHYXVnZSgpIHtcclxuXHRcdHJldHVybiB0aGlzLmhhc1R5cGUoXCJnYXVnZVwiKSAmJiB0aGlzLmNvbmZpZy5nYXVnZV90eXBlID09PSBcIm11bHRpXCI7XHJcblx0fSxcclxuXHJcblx0aXNMaW5lVHlwZShkKSB7XHJcblx0XHRjb25zdCBpZCA9IGlzU3RyaW5nKGQpID8gZCA6IGQuaWQ7XHJcblxyXG5cdFx0cmV0dXJuICF0aGlzLmNvbmZpZy5kYXRhX3R5cGVzW2lkXSB8fFxyXG5cdFx0XHR0aGlzLmlzVHlwZU9mKGlkLCBUWVBFUy5MaW5lKTtcclxuXHR9LFxyXG5cclxuXHRpc1N0ZXBUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLlN0ZXApO1xyXG5cdH0sXHJcblxyXG5cdGlzU3BsaW5lVHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBUWVBFUy5TcGxpbmUpO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJlYVR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgVFlQRVMuQXJlYSk7XHJcblx0fSxcclxuXHJcblx0aXNBcmVhUmFuZ2VUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFRZUEVTLkFyZWFSYW5nZSk7XHJcblx0fSxcclxuXHJcblx0aXNCYXJUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwiYmFyXCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzQnViYmxlVHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImJ1YmJsZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc1NjYXR0ZXJUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwic2NhdHRlclwiKTtcclxuXHR9LFxyXG5cclxuXHRpc1BpZVR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJwaWVcIik7XHJcblx0fSxcclxuXHJcblx0aXNHYXVnZVR5cGUoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaXNUeXBlT2YoZCwgXCJnYXVnZVwiKTtcclxuXHR9LFxyXG5cclxuXHRpc0RvbnV0VHlwZShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc1R5cGVPZihkLCBcImRvbnV0XCIpO1xyXG5cdH0sXHJcblxyXG5cdGlzUmFkYXJUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzVHlwZU9mKGQsIFwicmFkYXJcIik7XHJcblx0fSxcclxuXHJcblx0aXNBcmNUeXBlKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzUGllVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzRG9udXRUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNHYXVnZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1JhZGFyVHlwZShkKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXRlcm1pbmUgaWYgaXMgJ2NpcmNsZScgZGF0YSBwb2ludFxyXG5cdGlzQ2lyY2xlUG9pbnQoKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblx0XHRjb25zdCBwYXR0ZXJuID0gY29uZmlnLnBvaW50X3BhdHRlcm47XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5wb2ludF90eXBlID09PSBcImNpcmNsZVwiICYmXHJcblx0XHRcdCghcGF0dGVybiB8fCAoaXNBcnJheShwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMCkpO1xyXG5cdH0sXHJcblxyXG5cdGxpbmVEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzTGluZVR5cGUoZCkgPyBbZF0gOiBbXTtcclxuXHR9LFxyXG5cclxuXHRhcmNEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQXJjVHlwZShkLmRhdGEpID8gW2RdIDogW107XHJcblx0fSxcclxuXHJcblx0YmFyRGF0YShkKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pc0JhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhIGFkYXB0IGZvciBkYXRhIGxhYmVsIHNob3dpbmdcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0bGFiZWxpc2hEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fFxyXG5cdFx0XHR0aGlzLmlzTGluZVR5cGUoZCkgfHxcclxuXHRcdFx0dGhpcy5pc1NjYXR0ZXJUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNCdWJibGVUeXBlKGQpIHx8XHJcblx0XHRcdHRoaXMuaXNSYWRhclR5cGUoZCkgPyBkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdGJhckxpbmVCdWJibGVEYXRhKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmlzQmFyVHlwZShkKSB8fCB0aGlzLmlzTGluZVR5cGUoZCkgfHwgdGhpcy5pc0J1YmJsZVR5cGUoZCkgP1xyXG5cdFx0XHRkLnZhbHVlcyA6IFtdO1xyXG5cdH0sXHJcblxyXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1zaGFwZSNjdXJ2ZXNcclxuXHRpc0ludGVycG9sYXRpb25UeXBlKHR5cGU6IHN0cmluZyk6IGJvb2xlYW4ge1xyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0XCJiYXNpc1wiLFxyXG5cdFx0XHRcImJhc2lzLWNsb3NlZFwiLFxyXG5cdFx0XHRcImJhc2lzLW9wZW5cIixcclxuXHRcdFx0XCJidW5kbGVcIixcclxuXHRcdFx0XCJjYXJkaW5hbFwiLFxyXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiLFxyXG5cdFx0XHRcImNhcmRpbmFsLW9wZW5cIixcclxuXHRcdFx0XCJjYXRtdWxsLXJvbVwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLW9wZW5cIixcclxuXHRcdFx0XCJsaW5lYXJcIixcclxuXHRcdFx0XCJsaW5lYXItY2xvc2VkXCIsXHJcblx0XHRcdFwibW9ub3RvbmUteFwiLFxyXG5cdFx0XHRcIm1vbm90b25lLXlcIixcclxuXHRcdFx0XCJuYXR1cmFsXCJcclxuXHRcdF0uaW5kZXhPZih0eXBlKSA+PSAwO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQge1xyXG5cdGFyYyBhcyBkM0FyYyxcclxuXHRwaWUgYXMgZDNQaWVcclxufSBmcm9tIFwiZDMtc2hhcGVcIjtcclxuaW1wb3J0IHtpbnRlcnBvbGF0ZSBhcyBkM0ludGVycG9sYXRlfSBmcm9tIFwiZDMtaW50ZXJwb2xhdGVcIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgc2V0VGV4dFZhbHVlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHRpbml0UGllKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRhdGFUeXBlID0gY29uZmlnLmRhdGFfdHlwZTtcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcucGllX3BhZGRpbmc7XHJcblx0XHRjb25zdCBzdGFydGluZ0FuZ2xlID0gY29uZmlnW2Ake2RhdGFUeXBlfV9zdGFydGluZ0FuZ2xlYF0gfHwgMDtcclxuXHRcdGNvbnN0IHBhZEFuZ2xlID0gKFxyXG5cdFx0XHQkJC5oYXNUeXBlKFwicGllXCIpICYmIHBhZGRpbmcgPyBwYWRkaW5nICogMC4wMSA6XHJcblx0XHRcdFx0Y29uZmlnW2Ake2RhdGFUeXBlfV9wYWRBbmdsZWBdXHJcblx0XHQpIHx8IDA7XHJcblx0XHRjb25zdCBzb3J0VmFsdWU6IGFueSA9ICQkLmlzT3JkZXJBc2MoKSB8fCAkJC5pc09yZGVyRGVzYygpID9cclxuXHRcdFx0KGEsIGIpID0+ICgkJC5pc09yZGVyQXNjKCkgPyBhIC0gYiA6IGIgLSBhKSA6IG51bGw7XHJcblxyXG5cdFx0JCQucGllID0gZDNQaWUoKVxyXG5cdFx0XHQuc3RhcnRBbmdsZShzdGFydGluZ0FuZ2xlKVxyXG5cdFx0XHQuZW5kQW5nbGUoc3RhcnRpbmdBbmdsZSArICgyICogTWF0aC5QSSkpXHJcblx0XHRcdC5wYWRBbmdsZShwYWRBbmdsZSlcclxuXHRcdFx0LnNvcnRWYWx1ZXMoc29ydFZhbHVlKVxyXG5cdFx0XHQudmFsdWUoKGQ6IGFueSkgPT4gZC52YWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYi52YWx1ZSwgMCkpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGl1cygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgcmFkaXVzID0gY29uZmlnLnBpZV9pbm5lclJhZGl1cztcclxuXHRcdGNvbnN0IHBhZGRpbmcgPSBjb25maWcucGllX3BhZGRpbmc7XHJcblx0XHRjb25zdCB3ID0gY29uZmlnLmdhdWdlX3dpZHRoIHx8IGNvbmZpZy5kb251dF93aWR0aDtcclxuXHRcdGNvbnN0IGdhdWdlQXJjV2lkdGggPSAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoICpcclxuXHRcdFx0Y29uZmlnLmdhdWdlX2FyY3NfbWluV2lkdGg7XHJcblxyXG5cdFx0c3RhdGUucmFkaXVzRXhwYW5kZWQgPSBNYXRoLm1pbihzdGF0ZS5hcmNXaWR0aCwgc3RhdGUuYXJjSGVpZ2h0KSAvIDIgKiAoJCQuaGFzTXVsdGlBcmNHYXVnZSgpID8gMC44NSA6IDEpO1xyXG5cdFx0c3RhdGUucmFkaXVzID0gc3RhdGUucmFkaXVzRXhwYW5kZWQgKiAwLjk1O1xyXG5cdFx0c3RhdGUuaW5uZXJSYWRpdXNSYXRpbyA9IHcgPyAoc3RhdGUucmFkaXVzIC0gdykgLyBzdGF0ZS5yYWRpdXMgOiAwLjY7XHJcblx0XHRzdGF0ZS5nYXVnZUFyY1dpZHRoID0gdyB8fCAoXHJcblx0XHRcdGdhdWdlQXJjV2lkdGggPD0gc3RhdGUucmFkaXVzIC0gc3RhdGUuaW5uZXJSYWRpdXMgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzIDpcclxuXHRcdFx0XHQoZ2F1Z2VBcmNXaWR0aCA8PSBzdGF0ZS5yYWRpdXMgPyBnYXVnZUFyY1dpZHRoIDogc3RhdGUucmFkaXVzKVxyXG5cdFx0KTtcclxuXHJcblx0XHRjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cyB8fCAoXHJcblx0XHRcdHBhZGRpbmcgPyBwYWRkaW5nICogKHN0YXRlLmlubmVyUmFkaXVzUmF0aW8gKyAwLjEpIDogMFxyXG5cdFx0KTtcclxuXHJcblx0XHQvLyBOT1RFOiBpbm5lclJhZGl1cyBjYW4gYmUgYW4gb2JqZWN0IGJ5IHVzZXIgc2V0dGluZywgb25seSBmb3IgJ3BpZScgdHlwZVxyXG5cdFx0c3RhdGUuaW5uZXJSYWRpdXMgPSAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgJCQuaGFzVHlwZShcImdhdWdlXCIpID9cclxuXHRcdFx0c3RhdGUucmFkaXVzICogc3RhdGUuaW5uZXJSYWRpdXNSYXRpbyA6IGlubmVyUmFkaXVzO1xyXG5cdH0sXHJcblxyXG5cdGdldElubmVyUmFkaXVzKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCByYWRpdXMgPSAkJC5zdGF0ZS5pbm5lclJhZGl1cztcclxuXHJcblx0XHRpZiAoIWlzTnVtYmVyKHJhZGl1cykgJiYgZCkge1xyXG5cdFx0XHRyYWRpdXMgPSByYWRpdXNbZC5kYXRhLmlkXSB8fCAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByYWRpdXM7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJjKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLnN2Z0FyYyA9ICQkLmdldFN2Z0FyYygpO1xyXG5cdFx0JCQuc3ZnQXJjRXhwYW5kZWQgPSAkJC5nZXRTdmdBcmNFeHBhbmRlZCgpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFuZ2xlKGRWYWx1ZSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCBwaWUgPSAkJC5waWU7XHJcblx0XHRsZXQgZCA9IGRWYWx1ZTtcclxuXHRcdGxldCBmb3VuZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmICghY29uZmlnKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHJhZGl1cyA9IE1hdGguUEkgKiAoY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGUgPyAyIDogMSk7XHJcblx0XHRjb25zdCBnU3RhcnQgPSBjb25maWcuZ2F1Z2Vfc3RhcnRpbmdBbmdsZTtcclxuXHJcblx0XHRpZiAoZC5kYXRhICYmICQkLmlzR2F1Z2VUeXBlKGQuZGF0YSkpIHtcclxuXHRcdFx0Y29uc3QgdG90YWxTdW0gPSAkJC5nZXRUb3RhbERhdGFTdW0oKTtcclxuXHJcblx0XHRcdC8vIGlmIGdhdWdlX21heCBsZXNzIHRoYW4gdG90YWxTdW0sIG1ha2UgdG90YWxTdW0gdG8gbWF4IHZhbHVlXHJcblx0XHRcdGlmICh0b3RhbFN1bSA+IGNvbmZpZy5nYXVnZV9tYXgpIHtcclxuXHRcdFx0XHRjb25maWcuZ2F1Z2VfbWF4ID0gdG90YWxTdW07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNvbnN0IGdFbmQgPSByYWRpdXMgKiAodG90YWxTdW0gLyAoY29uZmlnLmdhdWdlX21heCAtIGNvbmZpZy5nYXVnZV9taW4pKTtcclxuXHJcblx0XHRcdHBpZSA9IHBpZVxyXG5cdFx0XHRcdC5zdGFydEFuZ2xlKGdTdGFydClcclxuXHRcdFx0XHQuZW5kQW5nbGUoZ0VuZCArIGdTdGFydCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cGllKCQkLmZpbHRlclRhcmdldHNUb1Nob3coKSlcclxuXHRcdFx0LmZvckVhY2goKHQsIGkpID0+IHtcclxuXHRcdFx0XHRpZiAoIWZvdW5kICYmIHQuZGF0YS5pZCA9PT0gZC5kYXRhLmlkKSB7XHJcblx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRkID0gdDtcclxuXHRcdFx0XHRcdGQuaW5kZXggPSBpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0aWYgKGlzTmFOKGQuc3RhcnRBbmdsZSkpIHtcclxuXHRcdFx0ZC5zdGFydEFuZ2xlID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaXNOYU4oZC5lbmRBbmdsZSkpIHtcclxuXHRcdFx0ZC5lbmRBbmdsZSA9IGQuc3RhcnRBbmdsZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoZC5kYXRhICYmICQkLmhhc011bHRpQXJjR2F1Z2UoKSkge1xyXG5cdFx0XHRjb25zdCBtYXhWYWx1ZSA9ICQkLmdldE1pbk1heERhdGEoKS5tYXhbMF0udmFsdWU7XHJcblxyXG5cdFx0XHQvLyBpZiBnYXVnZV9tYXggbGVzcyB0aGFuIG1heFZhbHVlLCBtYWtlIG1heFZhbHVlIHRvIG1heCB2YWx1ZVxyXG5cdFx0XHRpZiAobWF4VmFsdWUgPiBjb25maWcuZ2F1Z2VfbWF4KSB7XHJcblx0XHRcdFx0Y29uZmlnLmdhdWdlX21heCA9IG1heFZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjb25zdCBnTWluID0gY29uZmlnLmdhdWdlX21pbjtcclxuXHRcdFx0Y29uc3QgZ01heCA9IGNvbmZpZy5nYXVnZV9tYXg7XHJcblx0XHRcdGNvbnN0IGdUaWMgPSByYWRpdXMgLyAoZ01heCAtIGdNaW4pO1xyXG5cdFx0XHRjb25zdCBnVmFsdWUgPSBkLnZhbHVlIDwgZ01pbiA/IDAgOiBkLnZhbHVlIDwgZ01heCA/IGQudmFsdWUgLSBnTWluIDogKGdNYXggLSBnTWluKTtcclxuXHJcblx0XHRcdGQuc3RhcnRBbmdsZSA9IGdTdGFydDtcclxuXHRcdFx0ZC5lbmRBbmdsZSA9IGdTdGFydCArIGdUaWMgKiBnVmFsdWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZvdW5kID8gZCA6IG51bGw7XHJcblx0fSxcclxuXHJcblx0Z2V0U3ZnQXJjKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXIgPSAkJC5nZXRJbm5lclJhZGl1cygpO1xyXG5cdFx0Y29uc3Qgc2luZ2xlQXJjV2lkdGggPSBzdGF0ZS5nYXVnZUFyY1dpZHRoIC8gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpLmxlbmd0aDtcclxuXHRcdGNvbnN0IGhhc011bHRpQXJjR2F1Z2UgPSAkJC5oYXNNdWx0aUFyY0dhdWdlKCk7XHJcblxyXG5cdFx0bGV0IGFyYyA9IGQzQXJjKClcclxuXHRcdFx0Lm91dGVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID8gKHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogZC5pbmRleCkgOiBzdGF0ZS5yYWRpdXMpKVxyXG5cdFx0XHQuaW5uZXJSYWRpdXMoKGQ6IGFueSkgPT4gKGhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogKGQuaW5kZXggKyAxKSA6XHJcblx0XHRcdFx0aXNOdW1iZXIoaXIpID8gaXIgOiAwKSk7XHJcblxyXG5cdFx0Y29uc3QgbmV3QXJjID0gZnVuY3Rpb24oZCwgd2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRsZXQgcGF0aDogc3RyaW5nIHwgbnVsbCA9IFwiTSAwIDBcIjtcclxuXHJcblx0XHRcdGlmIChkLnZhbHVlIHx8IGQuZGF0YSkge1xyXG5cdFx0XHRcdGlmICghaXNOdW1iZXIoaXIpKSB7XHJcblx0XHRcdFx0XHRhcmMgPSBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICF3aXRob3V0VXBkYXRlICYmICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cclxuXHRcdFx0XHRpZiAod2l0aG91dFVwZGF0ZSkge1xyXG5cdFx0XHRcdFx0cGF0aCA9IGFyYyhkKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKHVwZGF0ZWQpIHtcclxuXHRcdFx0XHRcdHBhdGggPSBhcmModXBkYXRlZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aDtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gVE9ETzogZXh0ZW5kcyBhbGwgZnVuY3Rpb25cclxuXHRcdG5ld0FyYy5jZW50cm9pZCA9IGFyYy5jZW50cm9pZDtcclxuXHJcblx0XHRyZXR1cm4gbmV3QXJjO1xyXG5cdH0sXHJcblxyXG5cdGdldFN2Z0FyY0V4cGFuZGVkKHJhdGUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IG5ld1JhdGUgPSByYXRlIHx8IDE7XHJcblx0XHRjb25zdCBzaW5nbGVBcmNXaWR0aCA9IHN0YXRlLmdhdWdlQXJjV2lkdGggLyAkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykubGVuZ3RoO1xyXG5cdFx0Y29uc3QgaGFzTXVsdGlBcmNHYXVnZSA9ICQkLmhhc011bHRpQXJjR2F1Z2UoKTtcclxuXHRcdGNvbnN0IGV4cGFuZFdpZHRoID0gTWF0aC5taW4oc3RhdGUucmFkaXVzRXhwYW5kZWQgKiBuZXdSYXRlIC0gc3RhdGUucmFkaXVzLFxyXG5cdFx0XHRzaW5nbGVBcmNXaWR0aCAqIDAuOCAtICgxIC0gbmV3UmF0ZSkgKiAxMDBcclxuXHRcdCk7XHJcblxyXG5cdFx0Y29uc3QgYXJjID0gZDNBcmMoKVxyXG5cdFx0XHQub3V0ZXJSYWRpdXMoKGQ6IGFueSkgPT4gKGhhc011bHRpQXJjR2F1Z2UgP1xyXG5cdFx0XHRcdHN0YXRlLnJhZGl1cyAtIHNpbmdsZUFyY1dpZHRoICogZC5pbmRleCArIGV4cGFuZFdpZHRoIDpcclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXNFeHBhbmRlZCAqIG5ld1JhdGUpXHJcblx0XHRcdClcclxuXHRcdFx0LmlubmVyUmFkaXVzKChkOiBhbnkpID0+IChoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRzdGF0ZS5yYWRpdXMgLSBzaW5nbGVBcmNXaWR0aCAqIChkLmluZGV4ICsgMSkgOiBzdGF0ZS5pbm5lclJhZGl1cykpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihkKSB7XHJcblx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHJcblx0XHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdFx0cmV0dXJuIChcclxuXHRcdFx0XHRcdGhhc011bHRpQXJjR2F1Z2UgPyBhcmMgOiBhcmMuaW5uZXJSYWRpdXMoJCQuZ2V0SW5uZXJSYWRpdXMoZCkpXHJcblx0XHRcdFx0KSh1cGRhdGVkKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm4gXCJNIDAgMFwiO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldEFyYyhkLCB3aXRob3V0VXBkYXRlLCBmb3JjZSkge1xyXG5cdFx0cmV0dXJuIGZvcmNlIHx8IHRoaXMuaXNBcmNUeXBlKGQuZGF0YSkgPyB0aGlzLnN2Z0FyYyhkLCB3aXRob3V0VXBkYXRlKSA6IFwiTSAwIDBcIjtcclxuXHR9LFxyXG5cclxuXHR0cmFuc2Zvcm1Gb3JBcmNMYWJlbChkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZToge3JhZGl1cywgcmFkaXVzRXhwYW5kZWR9fSA9ICQkO1xyXG5cclxuXHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHRcdGxldCB0cmFuc2xhdGUgPSBcIlwiO1xyXG5cclxuXHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdGlmICgkJC5oYXNNdWx0aUFyY0dhdWdlKCkpIHtcclxuXHRcdFx0XHRjb25zdCB5MSA9IE1hdGguc2luKHVwZGF0ZWQuZW5kQW5nbGUgLSBNYXRoLlBJIC8gMik7XHJcblxyXG5cdFx0XHRcdGNvbnN0IHggPSBNYXRoLmNvcyh1cGRhdGVkLmVuZEFuZ2xlIC0gTWF0aC5QSSAvIDIpICogKHJhZGl1c0V4cGFuZGVkICsgMjUpO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSB5MSAqIChyYWRpdXNFeHBhbmRlZCArIDE1IC0gTWF0aC5hYnMoeTEgKiAxMCkpICsgMztcclxuXHJcblx0XHRcdFx0dHJhbnNsYXRlID0gYHRyYW5zbGF0ZSgke3h9LCR7eX0pYDtcclxuXHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVHlwZShcImdhdWdlXCIpIHx8ICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0Y29uc3QgYyA9IHRoaXMuc3ZnQXJjLmNlbnRyb2lkKHVwZGF0ZWQpO1xyXG5cdFx0XHRcdGNvbnN0IHggPSBpc05hTihjWzBdKSA/IDAgOiBjWzBdO1xyXG5cdFx0XHRcdGNvbnN0IHkgPSBpc05hTihjWzFdKSA/IDAgOiBjWzFdO1xyXG5cdFx0XHRcdGNvbnN0IGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblxyXG5cdFx0XHRcdGxldCByYXRpbyA9ICgkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgY29uZmlnLmRvbnV0X2xhYmVsX3JhdGlvKSB8fFxyXG5cdFx0XHRcdFx0KCQkLmhhc1R5cGUoXCJwaWVcIikgJiYgY29uZmlnLnBpZV9sYWJlbF9yYXRpbyk7XHJcblxyXG5cdFx0XHRcdGlmIChyYXRpbykge1xyXG5cdFx0XHRcdFx0cmF0aW8gPSBpc0Z1bmN0aW9uKHJhdGlvKSA/IHJhdGlvKGQsIHJhZGl1cywgaCkgOiByYXRpbztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0cmF0aW8gPSByYWRpdXMgJiYgKFxyXG5cdFx0XHRcdFx0XHRoID8gKDM2IC8gcmFkaXVzID4gMC4zNzUgPyAxLjE3NSAtIDM2IC8gcmFkaXVzIDogMC44KSAqIHJhZGl1cyAvIGggOiAwXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dHJhbnNsYXRlID0gYHRyYW5zbGF0ZSgke3ggKiByYXRpb30sJHt5ICogcmF0aW99KWA7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJhbnNsYXRlO1xyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRUb0FyY0RhdGEoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTmFtZSh7XHJcblx0XHRcdGlkOiBkLmRhdGEuaWQsXHJcblx0XHRcdHZhbHVlOiBkLnZhbHVlLFxyXG5cdFx0XHRyYXRpbzogdGhpcy5nZXRSYXRpbyhcImFyY1wiLCBkKSxcclxuXHRcdFx0aW5kZXg6IGQuaW5kZXgsXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR0ZXh0Rm9yQXJjTGFiZWwoc2VsZWN0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0aWYgKCQkLnNob3VsZFNob3dBcmNMYWJlbCgpKSB7XHJcblx0XHRcdHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBub2RlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gdXBkYXRlZCA/IHVwZGF0ZWQudmFsdWUgOiBkLnZhbHVlO1xyXG5cdFx0XHRcdGNvbnN0IHJhdGlvID0gJCQuZ2V0UmF0aW8oXCJhcmNcIiwgdXBkYXRlZCk7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSBkLmRhdGEuaWQ7XHJcblx0XHRcdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblx0XHRcdFx0Y29uc3QgaXNVbmRlclRocmVzaG9sZCA9ICEoXHJcblx0XHRcdFx0XHQhaGFzR2F1Z2UgJiYgISQkLm1lZXRzQXJjTGFiZWxUaHJlc2hvbGQocmF0aW8pXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0aWYgKGlzVW5kZXJUaHJlc2hvbGQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IHRleHQgPSAoXHJcblx0XHRcdFx0XHRcdCQkLmdldEFyY0xhYmVsRm9ybWF0KCkgfHwgJCQuZGVmYXVsdEFyY1ZhbHVlRm9ybWF0XHJcblx0XHRcdFx0XHQpKHZhbHVlLCByYXRpbywgaWQpLnRvU3RyaW5nKCk7XHJcblxyXG5cdFx0XHRcdFx0c2V0VGV4dFZhbHVlKG5vZGUsIHRleHQsIFstMSwgMV0sIGhhc0dhdWdlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHRleHRGb3JHYXVnZU1pbk1heCh2YWx1ZSwgaXNNYXgpIHtcclxuXHRcdGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0R2F1Z2VMYWJlbEV4dGVudHMoKTtcclxuXHJcblx0XHRyZXR1cm4gZm9ybWF0ID8gZm9ybWF0KHZhbHVlLCBpc01heCkgOiB2YWx1ZTtcclxuXHR9LFxyXG5cclxuXHRleHBhbmRBcmModGFyZ2V0SWRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7c3RhdGU6IHt0cmFuc2l0aW5nfSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdC8vIE1FTU86IGF2b2lkIHRvIGNhbmNlbCB0cmFuc2l0aW9uXHJcblx0XHRpZiAodHJhbnNpdGluZykge1xyXG5cdFx0XHRjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcclxuXHRcdFx0XHRpZiAoIXRyYW5zaXRpbmcpIHtcclxuXHRcdFx0XHRcdGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG5cclxuXHRcdFx0XHRcdCRlbC5sZWdlbmQuc2VsZWN0QWxsKGAuJHtDTEFTUy5sZWdlbmRJdGVtRm9jdXNlZH1gKS5zaXplKCkgPiAwICYmXHJcblx0XHRcdFx0XHRcdCQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgMTApO1xyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG5ld1RhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0JGVsLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKG5ld1RhcmdldElkcywgYC4ke0NMQVNTLmNoYXJ0QXJjfWApKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0aWYgKCEkJC5zaG91bGRFeHBhbmQoZC5kYXRhLmlkKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y29uc3QgZXhwYW5kRHVyYXRpb24gPSAkJC5nZXRFeHBhbmRDb25maWcoZC5kYXRhLmlkLCBcImR1cmF0aW9uXCIpO1xyXG5cdFx0XHRcdGNvbnN0IHN2Z0FyY0V4cGFuZGVkU3ViID0gJCQuZ2V0U3ZnQXJjRXhwYW5kZWQoJCQuZ2V0RXhwYW5kQ29uZmlnKGQuZGF0YS5pZCwgXCJyYXRlXCIpKTtcclxuXHJcblx0XHRcdFx0ZDNTZWxlY3QodGhpcykuc2VsZWN0QWxsKFwicGF0aFwiKVxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHRcdFx0LmR1cmF0aW9uKGV4cGFuZER1cmF0aW9uKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsICQkLnN2Z0FyY0V4cGFuZGVkKVxyXG5cdFx0XHRcdFx0LnRyYW5zaXRpb24oKVxyXG5cdFx0XHRcdFx0LmR1cmF0aW9uKGV4cGFuZER1cmF0aW9uICogMilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZFwiLCBzdmdBcmNFeHBhbmRlZFN1Yik7XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHVuZXhwYW5kQXJjKHRhcmdldElkcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3N0YXRlOiB7dHJhbnNpdGluZ30sICRlbDoge3N2Z319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpbmcpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG5ld1RhcmdldElkcyA9ICQkLm1hcFRvVGFyZ2V0SWRzKHRhcmdldElkcyk7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHMobmV3VGFyZ2V0SWRzLCBgLiR7Q0xBU1MuY2hhcnRBcmN9YCkpXHJcblx0XHRcdC5zZWxlY3RBbGwoXCJwYXRoXCIpXHJcblx0XHRcdC50cmFuc2l0aW9uKClcclxuXHRcdFx0LmR1cmF0aW9uKGQgPT4gJCQuZ2V0RXhwYW5kQ29uZmlnKGQuZGF0YS5pZCwgXCJkdXJhdGlvblwiKSlcclxuXHRcdFx0LmF0dHIoXCJkXCIsICQkLnN2Z0FyYyk7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdEFsbChgJHtDTEFTUy5hcmN9YClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGV4cGFuZCBjb25maWcgdmFsdWVcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgZGF0YSBJRFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgY29uZmlnIGtleTogJ2R1cmF0aW9uIHwgcmF0ZSdcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRFeHBhbmRDb25maWcoaWQsIGtleSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGRlZiA9IHtcclxuXHRcdFx0ZHVyYXRpb246IDUwLFxyXG5cdFx0XHRyYXRlOiAwLjk4XHJcblx0XHR9O1xyXG5cdFx0bGV0IHR5cGU7XHJcblxyXG5cdFx0aWYgKCQkLmlzRG9udXRUeXBlKGlkKSkge1xyXG5cdFx0XHR0eXBlID0gXCJkb251dFwiO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5pc0dhdWdlVHlwZShpZCkpIHtcclxuXHRcdFx0dHlwZSA9IFwiZ2F1Z2VcIjtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNQaWVUeXBlKGlkKSkge1xyXG5cdFx0XHR0eXBlID0gXCJwaWVcIjtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHlwZSA/IGNvbmZpZ1tgJHt0eXBlfV9leHBhbmRfJHtrZXl9YF0gOiBkZWZba2V5XTtcclxuXHR9LFxyXG5cclxuXHRzaG91bGRFeHBhbmQoaWQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuICgkJC5pc0RvbnV0VHlwZShpZCkgJiYgY29uZmlnLmRvbnV0X2V4cGFuZCkgfHxcclxuXHRcdFx0KCQkLmlzR2F1Z2VUeXBlKGlkKSAmJiBjb25maWcuZ2F1Z2VfZXhwYW5kKSB8fFxyXG5cdFx0XHQoJCQuaXNQaWVUeXBlKGlkKSAmJiBjb25maWcucGllX2V4cGFuZCk7XHJcblx0fSxcclxuXHJcblx0c2hvdWxkU2hvd0FyY0xhYmVsKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRyZXR1cm4gW1wicGllXCIsIFwiZG9udXRcIiwgXCJnYXVnZVwiXVxyXG5cdFx0XHQuc29tZSh2ID0+ICQkLmhhc1R5cGUodikgJiYgY29uZmlnW2Ake3Z9X2xhYmVsX3Nob3dgXSk7XHJcblx0fSxcclxuXHJcblx0bWVldHNBcmNMYWJlbFRocmVzaG9sZChyYXRpbykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IHRocmVzaG9sZCA9ICQkLmhhc1R5cGUoXCJkb251dFwiKSA/IGNvbmZpZy5kb251dF9sYWJlbF90aHJlc2hvbGQgOiBjb25maWcucGllX2xhYmVsX3RocmVzaG9sZDtcclxuXHJcblx0XHRyZXR1cm4gcmF0aW8gPj0gdGhyZXNob2xkO1xyXG5cdH0sXHJcblxyXG5cdGdldEFyY0xhYmVsRm9ybWF0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGxldCBmb3JtYXQgPSBjb25maWcucGllX2xhYmVsX2Zvcm1hdDtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcImdhdWdlXCIpKSB7XHJcblx0XHRcdGZvcm1hdCA9IGNvbmZpZy5nYXVnZV9sYWJlbF9mb3JtYXQ7XHJcblx0XHR9IGVsc2UgaWYgKCQkLmhhc1R5cGUoXCJkb251dFwiKSkge1xyXG5cdFx0XHRmb3JtYXQgPSBjb25maWcuZG9udXRfbGFiZWxfZm9ybWF0O1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmb3JtYXQ7XHJcblx0fSxcclxuXHJcblx0Z2V0R2F1Z2VMYWJlbEV4dGVudHMoKSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5nYXVnZV9sYWJlbF9leHRlbnRzO1xyXG5cdH0sXHJcblxyXG5cdGdldEFyY1RpdGxlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdHlwZSA9ICgkJC5oYXNUeXBlKFwiZG9udXRcIikgJiYgXCJkb251dFwiKSB8fCAoJCQuaGFzVHlwZShcImdhdWdlXCIpICYmIFwiZ2F1Z2VcIik7XHJcblxyXG5cdFx0cmV0dXJuIHR5cGUgPyAkJC5jb25maWdbYCR7dHlwZX1fdGl0bGVgXSA6IFwiXCI7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlVGFyZ2V0c0ZvckFyYyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkJC4kZWw7XHJcblx0XHRjb25zdCBoYXNHYXVnZSA9ICQkLmhhc1R5cGUoXCJnYXVnZVwiKTtcclxuXHRcdGNvbnN0IGNsYXNzQ2hhcnRBcmMgPSAkJC5jbGFzc0NoYXJ0QXJjLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NBcmNzID0gJCQuY2xhc3NBcmNzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NGb2N1cyA9ICQkLmNsYXNzRm9jdXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBtYWluUGllVXBkYXRlID0gbWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaGFydEFyY31gKVxyXG5cdFx0XHQuZGF0YSgkJC5waWUodGFyZ2V0cykpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0QXJjKGQpICsgY2xhc3NGb2N1cyhkLmRhdGEpKTtcclxuXHJcblx0XHRjb25zdCBtYWluUGllRW50ZXIgPSBtYWluUGllVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRBcmMpO1xyXG5cclxuXHRcdG1haW5QaWVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBcmNzKVxyXG5cdFx0XHQubWVyZ2UobWFpblBpZVVwZGF0ZSk7XHJcblxyXG5cdFx0bWFpblBpZUVudGVyLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0LmF0dHIoXCJkeVwiLCBoYXNHYXVnZSAmJiAhJCQuaGFzTXVsdGlUYXJnZXRzKCkgPyBcIi0uMWVtXCIgOiBcIi4zNWVtXCIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHRcdC8vIE1FTU86IGNhbiBub3Qga2VlcCBzYW1lIGNvbG9yLi4uLCBidXQgbm90IGJhZCB0byB1cGRhdGUgY29sb3IgaW4gcmVkcmF3XHJcblx0XHQvLyBtYWluUGllVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHR9LFxyXG5cclxuXHRpbml0QXJjKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgeyRlbH0gPSAkJDtcclxuXHJcblx0XHQkZWwuYXJjcyA9ICRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YClcclxuXHRcdFx0LmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5jaGFydEFyY3MpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcImFyY1wiKSk7XHJcblxyXG5cdFx0JCQuc2V0QXJjVGl0bGUoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgYXJjIHRpdGxlIHRleHRcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEFyY1RpdGxlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGl0bGUgPSAkJC5nZXRBcmNUaXRsZSgpO1xyXG5cdFx0Y29uc3QgaGFzR2F1Z2UgPSAkJC5oYXNUeXBlKFwiZ2F1Z2VcIik7XHJcblxyXG5cdFx0aWYgKHRpdGxlKSB7XHJcblx0XHRcdGNvbnN0IHRleHQgPSAkJC4kZWwuYXJjcy5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTU1toYXNHYXVnZSA/IFwiY2hhcnRBcmNzR2F1Z2VUaXRsZVwiIDogXCJjaGFydEFyY3NUaXRsZVwiXSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKTtcclxuXHJcblx0XHRcdGlmIChoYXNHYXVnZSkge1xyXG5cdFx0XHRcdHRleHRcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCItMC4zZW1cIilcclxuXHRcdFx0XHRcdC5zdHlsZShcImZvbnQtc2l6ZVwiLCBcIjI3cHhcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNldFRleHRWYWx1ZSh0ZXh0LCB0aXRsZSwgaGFzR2F1Z2UgPyB1bmRlZmluZWQgOiBbLTAuNiwgMS4zNV0sIHRydWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyYyhkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCB3aXRoVHJhbnNmb3JtKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsOiB7bWFpbn19ID0gJCQ7XHJcblx0XHRjb25zdCBoYXNJbnRlcmFjdGlvbiA9IGNvbmZpZy5pbnRlcmFjdGlvbl9lbmFibGVkO1xyXG5cclxuXHRcdGxldCBtYWluQXJjID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY3N9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MuYXJjfWApXHJcblx0XHRcdC5kYXRhKCQkLmFyY0RhdGEuYmluZCgkJCkpO1xyXG5cclxuXHRcdG1haW5BcmMuZXhpdCgpLnRyYW5zaXRpb24oKVxyXG5cdFx0XHQuZHVyYXRpb24oZHVyYXRpb25Gb3JFeGl0KVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0bWFpbkFyYyA9IG1haW5BcmMuZW50ZXIoKS5hcHBlbmQoXCJwYXRoXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NBcmMuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcImZpbGxcIiwgZCA9PiAkJC5jb2xvcihkLmRhdGEpKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiAoaGFzSW50ZXJhY3Rpb24gJiYgY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5lYWNoKGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRpZiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSkge1xyXG5cdFx0XHRcdFx0ZC5zdGFydEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XHJcblx0XHRcdFx0XHRkLmVuZEFuZ2xlID0gY29uZmlnLmdhdWdlX3N0YXJ0aW5nQW5nbGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLl9jdXJyZW50ID0gZDtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm1lcmdlKG1haW5BcmMpO1xyXG5cclxuXHRcdCQkLmhhc011bHRpQXJjR2F1Z2UoKSAmJiAkJC5yZWRyYXdNdWx0aUFyY0dhdWdlKCk7XHJcblxyXG5cdFx0bWFpbkFyY1xyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBkID0+ICghJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSAmJiB3aXRoVHJhbnNmb3JtID8gXCJzY2FsZSgwKVwiIDogXCJcIikpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdHJldHVybiBkID09PSB0aGlzLl9jdXJyZW50ID8gXCIwXCIgOiBcIjFcIjtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmVhY2goKCkgPT4ge1xyXG5cdFx0XHRcdHN0YXRlLnRyYW5zaXRpbmcgPSB0cnVlO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbilcclxuXHRcdFx0LmF0dHJUd2VlbihcImRcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdGNvbnN0IHVwZGF0ZWQgPSAkJC51cGRhdGVBbmdsZShkKTtcclxuXHJcblx0XHRcdFx0aWYgKCF1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gKCkgPT4gXCJNIDAgMFwiO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGlzTmFOKHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnQuc3RhcnRBbmdsZSA9IDA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNOYU4odGhpcy5fY3VycmVudC5lbmRBbmdsZSkpIHtcclxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnQuZW5kQW5nbGUgPSB0aGlzLl9jdXJyZW50LnN0YXJ0QW5nbGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBpbnRlcnBvbGF0ZSA9IGQzSW50ZXJwb2xhdGUodGhpcy5fY3VycmVudCwgdXBkYXRlZCk7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2N1cnJlbnQgPSBpbnRlcnBvbGF0ZSgwKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcclxuXHRcdFx0XHRcdGNvbnN0IGludGVycG9sYXRlZCA9IGludGVycG9sYXRlKHQpO1xyXG5cclxuXHRcdFx0XHRcdGludGVycG9sYXRlZC5kYXRhID0gZC5kYXRhOyAvLyBkYXRhLmlkIHdpbGwgYmUgdXBkYXRlZCBieSBpbnRlcnBvcmF0b3JcclxuXHRcdFx0XHRcdHJldHVybiAkJC5nZXRBcmMoaW50ZXJwb2xhdGVkLCB0cnVlKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB3aXRoVHJhbnNmb3JtID8gXCJzY2FsZSgxKVwiIDogXCJcIilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+IHtcclxuXHRcdFx0XHRsZXQgY29sb3I7XHJcblxyXG5cdFx0XHRcdGlmICgkJC5sZXZlbENvbG9yKSB7XHJcblx0XHRcdFx0XHRjb2xvciA9ICQkLmxldmVsQ29sb3IoZC5kYXRhLnZhbHVlc1swXS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXBkYXRlIGRhdGEncyBjb2xvclxyXG5cdFx0XHRcdFx0Y29uZmlnLmRhdGFfY29sb3JzW2QuZGF0YS5pZF0gPSBjb2xvcjtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Y29sb3IgPSAkJC5jb2xvcihkLmRhdGEuaWQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGNvbG9yO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQvLyBXaGVyZSBnYXVnZSByZWFkaW5nIGNvbG9yIHdvdWxkIHJlY2VpdmUgY3VzdG9taXphdGlvbi5cclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIilcclxuXHRcdFx0LmNhbGwoJCQuZW5kYWxsLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoJCQubGV2ZWxDb2xvcikge1xyXG5cdFx0XHRcdFx0Y29uc3QgcGF0aCA9IGQzU2VsZWN0KHRoaXMpO1xyXG5cdFx0XHRcdFx0Y29uc3QgZDogYW55ID0gcGF0aC5kYXR1bSgpO1xyXG5cclxuXHRcdFx0XHRcdCQkLnVwZGF0ZUxlZ2VuZEl0ZW1Db2xvcihkLmRhdGEuaWQsIHBhdGguc3R5bGUoXCJmaWxsXCIpKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHN0YXRlLnRyYW5zaXRpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRjYWxsRm4oY29uZmlnLm9ucmVuZGVyZWQsICQkLCAkJC5hcGkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHQvLyBiaW5kIGFyYyBldmVudHNcclxuXHRcdGhhc0ludGVyYWN0aW9uICYmICQkLmJpbmRBcmNFdmVudChtYWluQXJjKTtcclxuXHJcblx0XHQkJC5yZWRyYXdBcmNUZXh0KGR1cmF0aW9uKTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdNdWx0aUFyY0dhdWdlKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbH0gPSAkJDtcclxuXHRcdGNvbnN0IGhpZGRlblRhcmdldElkcyA9ICQkLnN0YXRlLmhpZGRlblRhcmdldElkcztcclxuXHJcblx0XHRjb25zdCBhcmNMYWJlbExpbmVzID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmNzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmFyY0xhYmVsTGluZX1gKVxyXG5cdFx0XHQuZGF0YSgkJC5hcmNEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluQXJjTGFiZWxMaW5lID0gYXJjTGFiZWxMaW5lcy5lbnRlcigpXHJcblx0XHRcdC5hcHBlbmQoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBgJHtDTEFTUy5hcmNMYWJlbExpbmV9ICR7Q0xBU1MudGFyZ2V0fSAke0NMQVNTLnRhcmdldH0tJHtkLmRhdGEuaWR9YClcclxuXHRcdFx0Lm1lcmdlKGFyY0xhYmVsTGluZXMpO1xyXG5cclxuXHRcdG1haW5BcmNMYWJlbExpbmVcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICgkJC5sZXZlbENvbG9yID8gJCQubGV2ZWxDb2xvcihkLmRhdGEudmFsdWVzWzBdLnZhbHVlKSA6ICQkLmNvbG9yKGQuZGF0YSkpKVxyXG5cdFx0XHQuc3R5bGUoXCJkaXNwbGF5XCIsIGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gXCJcIiA6IFwibm9uZVwiKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0bGV0IGxpbmVMZW5ndGggPSAwO1xyXG5cdFx0XHRcdGNvbnN0IGxpbmVUaGlja25lc3MgPSAyO1xyXG5cdFx0XHRcdGxldCB4ID0gMDtcclxuXHRcdFx0XHRsZXQgeSA9IDA7XHJcblx0XHRcdFx0bGV0IHRyYW5zZm9ybSA9IFwiXCI7XHJcblxyXG5cdFx0XHRcdGlmIChoaWRkZW5UYXJnZXRJZHMuaW5kZXhPZihkLmRhdGEuaWQpIDwgMCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgaW5uZXJMaW5lTGVuZ3RoID0gc3RhdGUuZ2F1Z2VBcmNXaWR0aCAvICQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzKS5sZW5ndGggKlxyXG5cdFx0XHRcdFx0XHQodXBkYXRlZC5pbmRleCArIDEpO1xyXG5cdFx0XHRcdFx0Y29uc3QgbGluZUFuZ2xlID0gdXBkYXRlZC5lbmRBbmdsZSAtIE1hdGguUEkgLyAyO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjSW5uZXJSYWRpdXMgPSBzdGF0ZS5yYWRpdXMgLSBpbm5lckxpbmVMZW5ndGg7XHJcblx0XHRcdFx0XHRjb25zdCBsaW5lUG9zaXRpb25pbmdBbmdsZSA9IGxpbmVBbmdsZSAtIChhcmNJbm5lclJhZGl1cyA9PT0gMCA/IDAgOiAoMSAvIGFyY0lubmVyUmFkaXVzKSk7XHJcblxyXG5cdFx0XHRcdFx0bGluZUxlbmd0aCA9IHN0YXRlLnJhZGl1c0V4cGFuZGVkIC0gc3RhdGUucmFkaXVzICsgaW5uZXJMaW5lTGVuZ3RoO1xyXG5cdFx0XHRcdFx0eCA9IE1hdGguY29zKGxpbmVQb3NpdGlvbmluZ0FuZ2xlKSAqIGFyY0lubmVyUmFkaXVzO1xyXG5cdFx0XHRcdFx0eSA9IE1hdGguc2luKGxpbmVQb3NpdGlvbmluZ0FuZ2xlKSAqIGFyY0lubmVyUmFkaXVzO1xyXG5cdFx0XHRcdFx0dHJhbnNmb3JtID0gYHJvdGF0ZSgke2xpbmVBbmdsZSAqIDE4MCAvIE1hdGguUEl9LCAke3h9LCAke3l9KWA7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkM1NlbGVjdCh0aGlzKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4XCIsIHgpXHJcblx0XHRcdFx0XHQuYXR0cihcInlcIiwgeSlcclxuXHRcdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgbGluZUxlbmd0aClcclxuXHRcdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIGxpbmVUaGlja25lc3MpXHJcblx0XHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0pXHJcblx0XHRcdFx0XHQuc3R5bGUoXCJzdHJva2UtZGFzaGFycmF5XCIsIGAwLCAke2xpbmVMZW5ndGggKyBsaW5lVGhpY2tuZXNzfSwgMGApO1xyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRiaW5kQXJjRXZlbnQoYXJjKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZX0gPSAkJDtcclxuXHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHRcdGNvbnN0IGlzTW91c2UgPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwibW91c2VcIjtcclxuXHJcblx0XHRmdW5jdGlvbiBzZWxlY3RBcmMoX3RoaXMsIGFyY0RhdGEsIGlkKSB7XHJcblx0XHRcdC8vIHRyYW5zaXRpb25zXHJcblx0XHRcdCQkLmV4cGFuZEFyYyhpZCk7XHJcblx0XHRcdCQkLmFwaS5mb2N1cyhpZCk7XHJcblx0XHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKGlkLCB0cnVlKTtcclxuXHRcdFx0JCQuc2hvd1Rvb2x0aXAoW2FyY0RhdGFdLCBfdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gdW5zZWxlY3RBcmMoYXJjRGF0YT8pIHtcclxuXHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHQkJC51bmV4cGFuZEFyYyhpZCk7XHJcblx0XHRcdCQkLmFwaS5yZXZlcnQoKTtcclxuXHRcdFx0JCQucmV2ZXJ0TGVnZW5kKCk7XHJcblx0XHRcdCQkLmhpZGVUb29sdGlwKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0YXJjXHJcblx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0bGV0IGFyY0RhdGE7XHJcblxyXG5cdFx0XHRcdGlmICh1cGRhdGVkKSB7XHJcblx0XHRcdFx0XHRhcmNEYXRhID0gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKTtcclxuXHJcblx0XHRcdFx0XHQkJC50b2dnbGVTaGFwZSAmJiAkJC50b2dnbGVTaGFwZSh0aGlzLCBhcmNEYXRhLCBpKTtcclxuXHRcdFx0XHRcdGNvbmZpZy5kYXRhX29uY2xpY2suY2FsbCgkJC5hcGksIGFyY0RhdGEsIHRoaXMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0Ly8gbW91c2UgZXZlbnRzXHJcblx0XHRpZiAoaXNNb3VzZSkge1xyXG5cdFx0XHRhcmNcclxuXHRcdFx0XHQub24oXCJtb3VzZW92ZXJcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0aWYgKHN0YXRlLnRyYW5zaXRpbmcpIHsgLy8gc2tpcCB3aGlsZSB0cmFuc2l0aW5nXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRjb25zdCB1cGRhdGVkID0gJCQudXBkYXRlQW5nbGUoZCk7XHJcblx0XHRcdFx0XHRjb25zdCBhcmNEYXRhID0gdXBkYXRlZCA/ICQkLmNvbnZlcnRUb0FyY0RhdGEodXBkYXRlZCkgOiBudWxsO1xyXG5cdFx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdFx0c2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcclxuXHRcdFx0XHRcdCQkLnNldE92ZXJPdXQodHJ1ZSwgYXJjRGF0YSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW91dFwiLCBkID0+IHtcclxuXHRcdFx0XHRcdGlmIChzdGF0ZS50cmFuc2l0aW5nKSB7IC8vIHNraXAgd2hpbGUgdHJhbnNpdGluZ1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpO1xyXG5cdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgYXJjRGF0YSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oXCJtb3VzZW1vdmVcIiwgZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0Y29uc3QgdXBkYXRlZCA9ICQkLnVwZGF0ZUFuZ2xlKGQpO1xyXG5cdFx0XHRcdFx0Y29uc3QgYXJjRGF0YSA9IHVwZGF0ZWQgPyAkJC5jb252ZXJ0VG9BcmNEYXRhKHVwZGF0ZWQpIDogbnVsbDtcclxuXHJcblx0XHRcdFx0XHQkJC5zaG93VG9vbHRpcChbYXJjRGF0YV0sIHRoaXMpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHRvdWNoIGV2ZW50c1xyXG5cdFx0aWYgKGlzVG91Y2ggJiYgJCQuaGFzQXJjVHlwZSgpICYmICEkJC5yYWRhcnMpIHtcclxuXHRcdFx0Y29uc3QgZ2V0RXZlbnRBcmMgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgdG91Y2ggPSBkM0V2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZDNTZWxlY3QoZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBldmVudEFyYztcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoc3RhdGUudHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbnN0IGV2ZW50QXJjID0gZ2V0RXZlbnRBcmMoKTtcclxuXHRcdFx0XHRjb25zdCBkYXR1bTogYW55ID0gZXZlbnRBcmMuZGF0dW0oKTtcclxuXHRcdFx0XHRjb25zdCB1cGRhdGVkID0gKGRhdHVtICYmIGRhdHVtLmRhdGEgJiYgZGF0dW0uZGF0YS5pZCkgPyAkJC51cGRhdGVBbmdsZShkYXR1bSkgOiBudWxsO1xyXG5cdFx0XHRcdGNvbnN0IGFyY0RhdGEgPSB1cGRhdGVkID8gJCQuY29udmVydFRvQXJjRGF0YSh1cGRhdGVkKSA6IG51bGw7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSAoYXJjRGF0YSAmJiBhcmNEYXRhLmlkKSB8fCB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goYXJjRGF0YSk7XHJcblxyXG5cdFx0XHRcdGlzVW5kZWZpbmVkKGlkKSA/XHJcblx0XHRcdFx0XHR1bnNlbGVjdEFyYygpIDogc2VsZWN0QXJjKHRoaXMsIGFyY0RhdGEsIGlkKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdCQkLiRlbC5zdmdcclxuXHRcdFx0XHQub24oXCJ0b3VjaHN0YXJ0XCIsIGhhbmRsZXIpXHJcblx0XHRcdFx0Lm9uKFwidG91Y2htb3ZlXCIsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyY1RleHQoZHVyYXRpb24pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWw6IHttYWluLCBhcmNzfX0gPSAkJDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0Y29uc3QgaGFzTXVsdGlBcmNHYXVnZSA9ICQkLmhhc011bHRpQXJjR2F1Z2UoKTtcclxuXHRcdGxldCB0ZXh0O1xyXG5cclxuXHRcdC8vIGZvciBnYXVnZSB0eXBlLCB1cGRhdGUgdGV4dCB3aGVuIGhhcyBubyB0aXRsZSAmIG11bHRpIGRhdGFcclxuXHRcdGlmICghKGhhc0dhdWdlICYmICQkLmRhdGEudGFyZ2V0cy5sZW5ndGggPT09IDEgJiYgY29uZmlnLmdhdWdlX3RpdGxlKSkge1xyXG5cdFx0XHR0ZXh0ID0gbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QXJjfWApXHJcblx0XHRcdFx0LnNlbGVjdChcInRleHRcIilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiAoJCQuaXNHYXVnZVR5cGUoZC5kYXRhKSA/IENMQVNTLmdhdWdlVmFsdWUgOiBudWxsKSlcclxuXHRcdFx0XHQuY2FsbCgkJC50ZXh0Rm9yQXJjTGFiZWwuYmluZCgkJCkpXHJcblx0XHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQudHJhbnNmb3JtRm9yQXJjTGFiZWwuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwiZm9udC1zaXplXCIsIGQgPT4gKFxyXG5cdFx0XHRcdFx0JCQuaXNHYXVnZVR5cGUoZC5kYXRhKSAmJiAkJC5kYXRhLnRhcmdldHMubGVuZ3RoID09PSAxICYmICFoYXNNdWx0aUFyY0dhdWdlID9cclxuXHRcdFx0XHRcdFx0YCR7TWF0aC5yb3VuZChzdGF0ZS5yYWRpdXMgLyA1KX1weGAgOiBudWxsXHJcblx0XHRcdFx0KSlcclxuXHRcdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdFx0LmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZCA9PiAoJCQuaXNUYXJnZXRUb1Nob3coZC5kYXRhLmlkKSAmJiAkJC5pc0FyY1R5cGUoZC5kYXRhKSA/IFwiMVwiIDogXCIwXCIpKTtcclxuXHJcblx0XHRcdGhhc011bHRpQXJjR2F1Z2UgJiYgdGV4dC5hdHRyKFwiZHlcIiwgXCItLjFlbVwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRtYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzVGl0bGV9YClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCAkJC5oYXNUeXBlKFwiZG9udXRcIikgfHwgaGFzR2F1Z2UgPyBcIjFcIiA6IFwiMFwiKTtcclxuXHJcblx0XHRpZiAoaGFzR2F1Z2UpIHtcclxuXHRcdFx0Y29uc3QgaXNGdWxsQ2lyY2xlID0gY29uZmlnLmdhdWdlX2Z1bGxDaXJjbGU7XHJcblx0XHRcdGNvbnN0IHN0YXJ0QW5nbGUgPSAtMSAqIE1hdGguUEkgLyAyO1xyXG5cdFx0XHRjb25zdCBlbmRBbmdsZSA9IChpc0Z1bGxDaXJjbGUgPyAtNCA6IC0xKSAqIHN0YXJ0QW5nbGU7XHJcblxyXG5cdFx0XHRpc0Z1bGxDaXJjbGUgJiYgdGV4dCAmJiB0ZXh0LmF0dHIoXCJkeVwiLCBgJHtNYXRoLnJvdW5kKHN0YXRlLnJhZGl1cyAvIDE0KX1gKTtcclxuXHJcblx0XHRcdGxldCBiYWNrZ3JvdW5kQXJjID0gJCQuJGVsLmFyY3Muc2VsZWN0KFxyXG5cdFx0XHRcdGAke2hhc011bHRpQXJjR2F1Z2UgPyBcImdcIiA6IFwiXCJ9LiR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH1gXHJcblx0XHRcdCk7XHJcblxyXG5cdFx0XHRpZiAoaGFzTXVsdGlBcmNHYXVnZSkge1xyXG5cdFx0XHRcdGxldCBpbmRleCA9IDA7XHJcblxyXG5cdFx0XHRcdGJhY2tncm91bmRBcmMgPSBiYWNrZ3JvdW5kQXJjXHJcblx0XHRcdFx0XHQuc2VsZWN0QWxsKGBwYXRoLiR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH1gKVxyXG5cdFx0XHRcdFx0LmRhdGEoJCQuZGF0YS50YXJnZXRzKTtcclxuXHJcblx0XHRcdFx0YmFja2dyb3VuZEFyYy5lbnRlcigpXHJcblx0XHRcdFx0XHQuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCAoZCwgaSkgPT4gYCR7Q0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZH0gJHtDTEFTUy5jaGFydEFyY3NCYWNrZ3JvdW5kfS0ke2l9YClcclxuXHRcdFx0XHRcdC5tZXJnZShiYWNrZ3JvdW5kQXJjKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJkXCIsIGQxID0+IHtcclxuXHRcdFx0XHRcdFx0aWYgKHN0YXRlLmhpZGRlblRhcmdldElkcy5pbmRleE9mKGQxLmlkKSA+PSAwKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFwiTSAwIDBcIjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Y29uc3QgZCA9IHtcclxuXHRcdFx0XHRcdFx0XHRkYXRhOiBbe3ZhbHVlOiBjb25maWcuZ2F1Z2VfbWF4fV0sXHJcblx0XHRcdFx0XHRcdFx0c3RhcnRBbmdsZSxcclxuXHRcdFx0XHRcdFx0XHRlbmRBbmdsZSxcclxuXHRcdFx0XHRcdFx0XHRpbmRleDogaW5kZXgrK1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhkLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmV4aXQoKS5yZW1vdmUoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRiYWNrZ3JvdW5kQXJjLmF0dHIoXCJkXCIsICgpID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGQgPSB7XHJcblx0XHRcdFx0XHRcdGRhdGE6IFt7dmFsdWU6IGNvbmZpZy5nYXVnZV9tYXh9XSxcclxuXHRcdFx0XHRcdFx0c3RhcnRBbmdsZSxcclxuXHRcdFx0XHRcdFx0ZW5kQW5nbGVcclxuXHRcdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuICQkLmdldEFyYyhkLCB0cnVlLCB0cnVlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0dhdWdlVW5pdH1gKVxyXG5cdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCIuNzVlbVwiKVxyXG5cdFx0XHRcdC50ZXh0KGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gY29uZmlnLmdhdWdlX3VuaXRzIDogXCJcIik7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdhdWdlX2xhYmVsX3Nob3cpIHtcclxuXHRcdFx0XHRhcmNzLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRBcmNzR2F1Z2VNaW59YClcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHhcIiwgYCR7LTEgKiAoc3RhdGUuaW5uZXJSYWRpdXMgKyAoKHN0YXRlLnJhZGl1cyAtIHN0YXRlLmlubmVyUmFkaXVzKSAvIChpc0Z1bGxDaXJjbGUgPyAxIDogMikpKX1weGApXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcclxuXHRcdFx0XHRcdC50ZXh0KCQkLnRleHRGb3JHYXVnZU1pbk1heChjb25maWcuZ2F1Z2VfbWluLCBmYWxzZSkpO1xyXG5cclxuXHRcdFx0XHQvLyBzaG93IG1heCB0ZXh0IHdoZW4gaXNuJ3QgZnVsbENpcmNsZVxyXG5cdFx0XHRcdCFpc0Z1bGxDaXJjbGUgJiYgYXJjcy5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc0dhdWdlTWF4fWApXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIGAke3N0YXRlLmlubmVyUmFkaXVzICsgKChzdGF0ZS5yYWRpdXMgLSBzdGF0ZS5pbm5lclJhZGl1cykgLyAyKX1weGApXHJcblx0XHRcdFx0XHQuYXR0cihcImR5XCIsIFwiMS4yZW1cIilcclxuXHRcdFx0XHRcdC50ZXh0KCQkLnRleHRGb3JHYXVnZU1pbk1heChjb25maWcuZ2F1Z2VfbWF4LCB0cnVlKSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRpbml0R2F1Z2UoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCAkZWw6IHthcmNzfX0gPSAkJDtcclxuXHRcdGNvbnN0IGFwcGVuZFRleHQgPSBjbGFzc05hbWUgPT4ge1xyXG5cdFx0XHRhcmNzLmFwcGVuZChcInRleHRcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzTmFtZSlcclxuXHRcdFx0XHQuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJnYXVnZVwiKSkge1xyXG5cdFx0XHRhcmNzLmFwcGVuZCgkJC5oYXNNdWx0aUFyY0dhdWdlKCkgPyBcImdcIiA6IFwicGF0aFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRBcmNzQmFja2dyb3VuZCk7XHJcblxyXG5cdFx0XHRjb25maWcuZ2F1Z2VfdW5pdHMgJiYgYXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZVVuaXQpO1xyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5nYXVnZV9sYWJlbF9zaG93KSB7XHJcblx0XHRcdFx0YXBwZW5kVGV4dChDTEFTUy5jaGFydEFyY3NHYXVnZU1pbik7XHJcblx0XHRcdFx0IWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlICYmIGFwcGVuZFRleHQoQ0xBU1MuY2hhcnRBcmNzR2F1Z2VNYXgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0R2F1Z2VMYWJlbEhlaWdodCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5nYXVnZV9sYWJlbF9zaG93ID8gMjAgOiAwO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge21vdXNlIGFzIGQzTW91c2V9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge2dldFJhbmRvbSwgZ2V0UmVjdFNlZ0xpc3QsIGlzTnVtYmVyLCBpc09iamVjdFR5cGUsIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRCYXIoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydH1gKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRCYXJzKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBjbGFzc0NoYXJ0QmFyID0gJCQuY2xhc3NDaGFydEJhci5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFycyA9ICQkLmNsYXNzQmFycy5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzRm9jdXMgPSAkJC5jbGFzc0ZvY3VzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgbWFpbkJhclVwZGF0ZSA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnRCYXJzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0QmFyfWApXHJcblx0XHRcdC5kYXRhKHRhcmdldHMpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZCA9PiBjbGFzc0NoYXJ0QmFyKGQpICsgY2xhc3NGb2N1cyhkKSk7XHJcblx0XHRjb25zdCBtYWluQmFyRW50ZXIgPSBtYWluQmFyVXBkYXRlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGNsYXNzQ2hhcnRCYXIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHQvLyBCYXJzIGZvciBlYWNoIGRhdGFcclxuXHRcdG1haW5CYXJFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NCYXJzKVxyXG5cdFx0XHQuc3R5bGUoXCJjdXJzb3JcIiwgZCA9PiAoY29uZmlnLmRhdGFfc2VsZWN0aW9uX2lzc2VsZWN0YWJsZShkKSA/IFwicG9pbnRlclwiIDogbnVsbCkpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUJhcihkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblx0XHRjb25zdCBiYXJEYXRhID0gJCQuYmFyRGF0YS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzQmFyID0gJCQuY2xhc3NCYXIuYmluZCgkJCk7XHJcblx0XHRjb25zdCBpbml0aWFsT3BhY2l0eSA9ICQkLmluaXRpYWxPcGFjaXR5LmJpbmQoJCQpO1xyXG5cclxuXHRcdCRlbC5iYXIgPSAkZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9YCkuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9YClcclxuXHRcdFx0LmRhdGEoYmFyRGF0YSk7XHJcblxyXG5cdFx0JGVsLmJhci5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwuYmFyID0gJGVsLmJhci5lbnRlcigpLmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0JhcilcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC5jb2xvcilcclxuXHRcdFx0Lm1lcmdlKCRlbC5iYXIpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgaW5pdGlhbE9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0JhcihkcmF3QmFyLCB3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3Qge2Jhcn0gPSB0aGlzLiRlbDtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHQod2l0aFRyYW5zaXRpb24gPyBiYXIudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiBiYXIpXHJcblx0XHRcdFx0LmF0dHIoXCJkXCIsIGRyYXdCYXIpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCB0aGlzLmNvbG9yKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIxXCIpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdGdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBtYXhEYXRhQ291bnQgPSAkJC5nZXRNYXhEYXRhQ291bnQoKTtcclxuXHRcdGNvbnN0IGlzR3JvdXBlZCA9IGNvbmZpZy5kYXRhX2dyb3Vwcy5sZW5ndGg7XHJcblx0XHRjb25zdCB0aWNrSW50ZXJ2YWwgPSAoc2NhbGUuem9vbSB8fCAkJCkgJiYgISQkLmlzQ2F0ZWdvcml6ZWQoKSA/XHJcblx0XHRcdCQkLnh4KHNjYWxlLnN1YlguZG9tYWluKClbMV0pIC8gbWF4RGF0YUNvdW50IDogYXhpcy50aWNrSW50ZXJ2YWwobWF4RGF0YUNvdW50KTtcclxuXHRcdGxldCByZXN1bHQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0V2lkdGggPSAoaWQ/OiBzdHJpbmcpID0+IHtcclxuXHRcdFx0Y29uc3Qgd2lkdGggPSBpZCA/IGNvbmZpZy5iYXJfd2lkdGhbaWRdIDogY29uZmlnLmJhcl93aWR0aDtcclxuXHRcdFx0Y29uc3QgcmF0aW8gPSBpZCA/IHdpZHRoLnJhdGlvIDogY29uZmlnLmJhcl93aWR0aF9yYXRpbztcclxuXHRcdFx0Y29uc3QgbWF4ID0gaWQgPyB3aWR0aC5tYXggOiBjb25maWcuYmFyX3dpZHRoX21heDtcclxuXHRcdFx0Y29uc3QgdyA9IGlzTnVtYmVyKHdpZHRoKSA/XHJcblx0XHRcdFx0d2lkdGggOiBiYXJUYXJnZXRzTnVtID8gKHRpY2tJbnRlcnZhbCAqIHJhdGlvKSAvIGJhclRhcmdldHNOdW0gOiAwO1xyXG5cclxuXHRcdFx0cmV0dXJuIG1heCAmJiB3ID4gbWF4ID8gbWF4IDogdztcclxuXHRcdH07XHJcblxyXG5cdFx0cmVzdWx0ID0gZ2V0V2lkdGgoKTtcclxuXHJcblx0XHRpZiAoIWlzR3JvdXBlZCAmJiBpc09iamVjdFR5cGUoY29uZmlnLmJhcl93aWR0aCkpIHtcclxuXHRcdFx0cmVzdWx0ID0ge3dpZHRoOiByZXN1bHQsIHRvdGFsOiBbXX07XHJcblxyXG5cdFx0XHQkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cykuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRpZiAoY29uZmlnLmJhcl93aWR0aFt2LmlkXSkge1xyXG5cdFx0XHRcdFx0cmVzdWx0W3YuaWRdID0gZ2V0V2lkdGgodi5pZCk7XHJcblx0XHRcdFx0XHRyZXN1bHQudG90YWwucHVzaChyZXN1bHRbdi5pZF0gfHwgcmVzdWx0LndpZHRoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fSxcclxuXHJcblx0Z2V0QmFycyhpLCBpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge21haW59ID0gJCQuJGVsO1xyXG5cdFx0Y29uc3Qgc3VmZml4ID0gKGlzVmFsdWUoaSkgPyBgLSR7aX1gIDogYGApO1xyXG5cclxuXHRcdHJldHVybiAoaWQgPyBtYWluXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmJhcnN9JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChpZCl9YCkgOiBtYWluKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5iYXJ9JHtzdWZmaXh9YCk7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQmFycyhpLCBpZCwgcmVzZXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRyZXNldCAmJiAkJC51bmV4cGFuZEJhcnMoKTtcclxuXHRcdCQkLmdldEJhcnMoaSwgaWQpLmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdHVuZXhwYW5kQmFycyhpKSB7XHJcblx0XHR0aGlzLmdldEJhcnMoaSkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgZmFsc2UpO1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlRHJhd0JhcihiYXJJbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBpc0dyb3VwZWQgPSBjb25maWcuZGF0YV9ncm91cHMubGVuZ3RoO1xyXG5cdFx0Y29uc3QgYmFyUmFkaXVzID0gY29uZmlnLmJhcl9yYWRpdXM7XHJcblx0XHRjb25zdCBiYXJSYWRpdXNSYXRpbyA9IGNvbmZpZy5iYXJfcmFkaXVzX3JhdGlvO1xyXG5cclxuXHRcdC8vIGdldCB0aGUgYmFyIHJhZGl1c1xyXG5cdFx0Y29uc3QgZ2V0UmFkaXVzID0gaXNOdW1iZXIoYmFyUmFkaXVzKSAmJiBiYXJSYWRpdXMgPiAwID9cclxuXHRcdFx0KCkgPT4gYmFyUmFkaXVzIDogKFxyXG5cdFx0XHRcdGlzTnVtYmVyKGJhclJhZGl1c1JhdGlvKSA/IHcgPT4gdyAqIGJhclJhZGl1c1JhdGlvIDogbnVsbFxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdHJldHVybiAoZCwgaSkgPT4ge1xyXG5cdFx0XHQvLyA0IHBvaW50cyB0aGF0IG1ha2UgYSBiYXJcclxuXHRcdFx0Y29uc3QgcG9pbnRzID0gZ2V0UG9pbnRzKGQsIGkpO1xyXG5cclxuXHRcdFx0Ly8gc3dpdGNoIHBvaW50cyBpZiBheGlzIGlzIHJvdGF0ZWQsIG5vdCBhcHBsaWNhYmxlIGZvciBzdWIgY2hhcnRcclxuXHRcdFx0Y29uc3QgaW5kZXhYID0gK2lzUm90YXRlZDtcclxuXHRcdFx0Y29uc3QgaW5kZXhZID0gKyFpbmRleFg7XHJcblxyXG5cdFx0XHRjb25zdCBpc05lZ2F0aXZlID0gZC52YWx1ZSA8IDA7XHJcblx0XHRcdGNvbnN0IHBhdGhSYWRpdXMgPSBbXCJcIiwgXCJcIl07XHJcblx0XHRcdGxldCByYWRpdXMgPSAwO1xyXG5cclxuXHRcdFx0aWYgKGdldFJhZGl1cyAmJiAhaXNHcm91cGVkKSB7XHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBpc1JvdGF0ZWQgPyBpbmRleFkgOiBpbmRleFg7XHJcblx0XHRcdFx0Y29uc3QgYmFyVyA9IHBvaW50c1syXVtpbmRleF0gLSBwb2ludHNbMF1baW5kZXhdO1xyXG5cclxuXHRcdFx0XHRyYWRpdXMgPSBnZXRSYWRpdXMoYmFyVyk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGFyYyA9IGBhJHtyYWRpdXN9LCR7cmFkaXVzfSAke2lzTmVnYXRpdmUgPyBgMSAwIDBgIDogYDAgMCAxYH0gYDtcclxuXHJcblx0XHRcdFx0cGF0aFJhZGl1c1srIWlzUm90YXRlZF0gPSBgJHthcmN9JHtyYWRpdXN9LCR7cmFkaXVzfWA7XHJcblx0XHRcdFx0cGF0aFJhZGl1c1sraXNSb3RhdGVkXSA9IGAke2FyY30ke1stcmFkaXVzLCByYWRpdXNdW2lzUm90YXRlZCA/IFwic29ydFwiIDogXCJyZXZlcnNlXCJdKCl9YDtcclxuXHJcblx0XHRcdFx0aXNOZWdhdGl2ZSAmJiBwYXRoUmFkaXVzLnJldmVyc2UoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcGF0aCBzdHJpbmcgZGF0YSBzaG91bGRuJ3QgYmUgY29udGFpbmluZyBuZXcgbGluZSBjaGFyc1xyXG5cdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vbmF2ZXIvYmlsbGJvYXJkLmpzL2lzc3Vlcy81MzBcclxuXHRcdFx0Y29uc3QgcGF0aCA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0YEgke3BvaW50c1sxXVtpbmRleFhdIC0gcmFkaXVzfSAke3BhdGhSYWRpdXNbMF19ViR7cG9pbnRzWzJdW2luZGV4WV0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1sxXX1IJHtwb2ludHNbM11baW5kZXhYXX1gIDpcclxuXHRcdFx0XHRgViR7cG9pbnRzWzFdW2luZGV4WV0gKyAoaXNOZWdhdGl2ZSA/IC1yYWRpdXMgOiByYWRpdXMpfSAke3BhdGhSYWRpdXNbMF19SCR7cG9pbnRzWzJdW2luZGV4WF0gLSByYWRpdXN9ICR7cGF0aFJhZGl1c1sxXX1WJHtwb2ludHNbM11baW5kZXhZXX1gO1xyXG5cclxuXHRcdFx0cmV0dXJuIGBNJHtwb2ludHNbMF1baW5kZXhYXX0sJHtwb2ludHNbMF1baW5kZXhZXX0ke3BhdGh9emA7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0QmFyUG9pbnRzKGJhckluZGljZXMsIGlzU3ViKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgYXhpcyA9IGlzU3ViID8gJCQuYXhpcy5zdWJYIDogJCQuYXhpcy54O1xyXG5cdFx0Y29uc3QgYmFyVGFyZ2V0c051bSA9ICQkLmdldEluZGljZXNNYXgoYmFySW5kaWNlcykgKyAxO1xyXG5cdFx0Y29uc3QgYmFyVyA9ICQkLmdldEJhclcoYXhpcywgYmFyVGFyZ2V0c051bSk7XHJcblx0XHRjb25zdCBiYXJYID0gJCQuZ2V0U2hhcGVYKGJhclcsIGJhckluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgYmFyWSA9ICQkLmdldFNoYXBlWSghIWlzU3ViKTtcclxuXHRcdGNvbnN0IGJhck9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzQmFyVHlwZSwgYmFySW5kaWNlcywgISFpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGJhck9mZnNldChkLCBpKSB8fCB5MDsgLy8gb2Zmc2V0IGlzIGZvciBzdGFja2VkIGJhciBjaGFydFxyXG5cdFx0XHRjb25zdCB3aWR0aCA9IGlzTnVtYmVyKGJhclcpID8gYmFyVyA6IGJhcldbZC5pZF0gfHwgYmFyVy53aWR0aDtcclxuXHRcdFx0Y29uc3QgcG9zWCA9IGJhclgoZCk7XHJcblx0XHRcdGxldCBwb3NZID0gYmFyWShkKTtcclxuXHJcblx0XHRcdC8vIGZpeCBwb3NZIG5vdCB0byBvdmVyZmxvdyBvcHBvc2l0ZSBxdWFkcmFudFxyXG5cdFx0XHRpZiAoY29uZmlnLmF4aXNfcm90YXRlZCAmJiAoXHJcblx0XHRcdFx0KGQudmFsdWUgPiAwICYmIHBvc1kgPCB5MCkgfHwgKGQudmFsdWUgPCAwICYmIHkwIDwgcG9zWSlcclxuXHRcdFx0KSkge1xyXG5cdFx0XHRcdHBvc1kgPSB5MDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cG9zWSAtPSAoeTAgLSBvZmZzZXQpO1xyXG5cclxuXHRcdFx0Ly8gNCBwb2ludHMgdGhhdCBtYWtlIGEgYmFyXHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0sXHJcblx0XHRcdFx0W3Bvc1gsIHBvc1ldLFxyXG5cdFx0XHRcdFtwb3NYICsgd2lkdGgsIHBvc1ldLFxyXG5cdFx0XHRcdFtwb3NYICsgd2lkdGgsIG9mZnNldF1cclxuXHRcdFx0XTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0aXNXaXRoaW5CYXIodGhhdCkge1xyXG5cdFx0Y29uc3QgbW91c2UgPSBkM01vdXNlKHRoYXQpO1xyXG5cdFx0Y29uc3QgbGlzdCA9IGdldFJlY3RTZWdMaXN0KHRoYXQpO1xyXG5cdFx0Y29uc3QgW3NlZzAsIHNlZzFdID0gbGlzdDtcclxuXHRcdGNvbnN0IHggPSBNYXRoLm1pbihzZWcwLngsIHNlZzEueCk7XHJcblx0XHRjb25zdCB5ID0gTWF0aC5taW4oc2VnMC55LCBzZWcxLnkpO1xyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gdGhpcy5jb25maWcuYmFyX3NlbnNpdGl2aXR5O1xyXG5cdFx0Y29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdGhhdC5nZXRCQm94KCk7XHJcblx0XHRjb25zdCBzeCA9IHggLSBvZmZzZXQ7XHJcblx0XHRjb25zdCBleCA9IHggKyB3aWR0aCArIG9mZnNldDtcclxuXHRcdGNvbnN0IHN5ID0geSArIGhlaWdodCArIG9mZnNldDtcclxuXHRcdGNvbnN0IGV5ID0geSAtIG9mZnNldDtcclxuXHJcblx0XHRyZXR1cm4gc3ggPCBtb3VzZVswXSAmJlxyXG5cdFx0XHRtb3VzZVswXSA8IGV4ICYmXHJcblx0XHRcdGV5IDwgbW91c2VbMV0gJiZcclxuXHRcdFx0bW91c2VbMV0gPCBzeTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtnZXRNaW5NYXgsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBpc09iamVjdH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogSW5pdGlhbGl6ZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGluaXRCdWJibGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwiYnViYmxlXCIpKSB7XHJcblx0XHRcdGNvbmZpZy5wb2ludF9zaG93ID0gdHJ1ZTtcclxuXHRcdFx0Y29uZmlnLnBvaW50X3R5cGUgPSBcImNpcmNsZVwiO1xyXG5cdFx0XHRjb25maWcucG9pbnRfc2Vuc2l0aXZpdHkgPSAyNTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdXNlciBhZ2VudCdzIGNvbXB1dGVkIHZhbHVlIGZvciB0aGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBwYXRoIGluIHVzZXIgdW5pdHNcclxuXHQgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU1ZHR2VvbWV0cnlFbGVtZW50L2dldFRvdGFsTGVuZ3RoXHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0QmFzZUxlbmd0aCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtheGlzfSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IGNhY2hlS2V5ID0gXCIkYmFzZUxlbmd0aFwiO1xyXG5cdFx0bGV0IGJhc2VMZW5ndGggPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGlmICghYmFzZUxlbmd0aCkge1xyXG5cdFx0XHQkJC5jYWNoZS5hZGQoY2FjaGVLZXksIGJhc2VMZW5ndGggPSBnZXRNaW5NYXgoXCJtaW5cIiwgW1xyXG5cdFx0XHRcdGF4aXMueC5zZWxlY3QoXCJwYXRoXCIpLm5vZGUoKVxyXG5cdFx0XHRcdFx0LmdldFRvdGFsTGVuZ3RoKCksXHJcblx0XHRcdFx0YXhpcy55LnNlbGVjdChcInBhdGhcIikubm9kZSgpXHJcblx0XHRcdFx0XHQuZ2V0VG90YWxMZW5ndGgoKVxyXG5cdFx0XHRdKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJhc2VMZW5ndGg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSByYWRpdXMgdmFsdWUgZm9yIGJ1YmJsZSBjaXJjbGVcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gZFxyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cclxuXHQgKiBAcHJpdmF0ZVxyXG4gXHQgKi9cclxuXHRnZXRCdWJibGVSKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGxldCBtYXhSID0gJCQuY29uZmlnLmJ1YmJsZV9tYXhSO1xyXG5cclxuXHRcdGlmIChpc0Z1bmN0aW9uKG1heFIpKSB7XHJcblx0XHRcdG1heFIgPSBtYXhSKGQpO1xyXG5cdFx0fSBlbHNlIGlmICghaXNOdW1iZXIobWF4UikpIHtcclxuXHRcdFx0bWF4UiA9ICgkJC5nZXRCYXNlTGVuZ3RoKCkgLyAoJCQuZ2V0TWF4RGF0YUNvdW50KCkgKiAyKSkgKyAxMjtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYXggPSBnZXRNaW5NYXgoXCJtYXhcIiwgJCQuZ2V0TWluTWF4RGF0YSgpLm1heC5tYXAoZCA9PiAoXHJcblx0XHRcdCQkLmlzQnViYmxlWlR5cGUoZCkgP1xyXG5cdFx0XHRcdCQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwieVwiKSA6IChcclxuXHRcdFx0XHRcdGlzT2JqZWN0KGQudmFsdWUpID8gZC52YWx1ZS5taWQgOiBkLnZhbHVlXHJcblx0XHRcdFx0KVxyXG5cdFx0KSkpO1xyXG5cdFx0Y29uc3QgbWF4QXJlYSA9IG1heFIgKiBtYXhSICogTWF0aC5QSTtcclxuXHRcdGNvbnN0IGFyZWEgPSAoJCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwielwiKSA6IGQudmFsdWUpICogKG1heEFyZWEgLyBtYXgpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoYXJlYSAvIE1hdGguUEkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBidWJibGUgZGltZW5zaW9uIGRhdGFcclxuXHQgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gZCBkYXRhIHZhbHVlXHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSB5IG9yIHpcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRCdWJibGVaRGF0YShkLCB0eXBlKSB7XHJcblx0XHRyZXR1cm4gaXNPYmplY3QoZCkgPyBkW3R5cGVdIDogZFt0eXBlID09PSBcInlcIiA/IDAgOiAxXTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlcm1pbmUgaWYgYnViYmxlIGhhcyBkaW1lbnNpb24gZGF0YVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fGFycmF5fSBkIGRhdGEgdmFsdWVcclxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0aXNCdWJibGVaVHlwZShkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0cmV0dXJuICQkLmlzQnViYmxlVHlwZShkKSAmJiAoXHJcblx0XHRcdChpc09iamVjdChkLnZhbHVlKSAmJiAoXCJ6XCIgaW4gZC52YWx1ZSB8fCBcInlcIiBpbiBkLnZhbHVlKSkgfHxcclxuXHRcdFx0KGlzQXJyYXkoZC52YWx1ZSkgJiYgZC52YWx1ZS5sZW5ndGggPT09IDIpXHJcblx0XHQpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdGFyZWEgYXMgZDNBcmVhLFxyXG5cdGxpbmUgYXMgZDNMaW5lXHJcbn0gZnJvbSBcImQzLXNoYXBlXCI7XHJcbmltcG9ydCB7XHJcblx0bW91c2UgYXMgZDNNb3VzZSxcclxuXHRzZWxlY3QgYXMgZDNTZWxlY3RcclxufSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtnZXRSYW5kb20sIGlzQXJyYXksIGlzRGVmaW5lZCwgaXNGdW5jdGlvbiwgaXNVbmRlZmluZWQsIGlzVmFsdWV9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGluaXRMaW5lKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLmNoYXJ0TGluZXMpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbDoge21haW59fSA9ICQkO1xyXG5cdFx0Y29uc3QgY2xhc3NDaGFydExpbmUgPSAkJC5jbGFzc0NoYXJ0TGluZS5iaW5kKCQkKTtcclxuXHRcdGNvbnN0IGNsYXNzTGluZXMgPSAkJC5jbGFzc0xpbmVzLmJpbmQoJCQpO1xyXG5cdFx0Y29uc3QgY2xhc3NBcmVhcyA9ICQkLmNsYXNzQXJlYXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0NpcmNsZXMgPSAkJC5jbGFzc0NpcmNsZXMuYmluZCgkJCk7XHJcblx0XHRjb25zdCBjbGFzc0ZvY3VzID0gJCQuY2xhc3NGb2N1cy5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCBtYWluTGluZVVwZGF0ZSA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5jaGFydExpbmVzfWApXHJcblx0XHRcdC5zZWxlY3RBbGwoYC4ke0NMQVNTLmNoYXJ0TGluZX1gKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gY2xhc3NDaGFydExpbmUoZCkgKyBjbGFzc0ZvY3VzKGQpKTtcclxuXHJcblx0XHRjb25zdCBtYWluTGluZUVudGVyID0gbWFpbkxpbmVVcGRhdGUuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaGFydExpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHQvLyBMaW5lcyBmb3IgZWFjaCBkYXRhXHJcblx0XHRtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBjbGFzc0xpbmVzKTtcclxuXHJcblx0XHQvLyBBcmVhc1xyXG5cdFx0bWFpbkxpbmVFbnRlci5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NBcmVhcyk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdC8vIENpcmNsZXMgZm9yIGVhY2ggZGF0YSBwb2ludCBvbiBsaW5lc1xyXG5cdFx0XHRjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCAmJiBtYWluTGluZUVudGVyLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIGQgPT4gJCQuZ2VuZXJhdGVDbGFzcyhDTEFTUy5zZWxlY3RlZENpcmNsZXMsIGQuaWQpKTtcclxuXHJcblx0XHRcdG1haW5MaW5lRW50ZXIuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgY2xhc3NDaXJjbGVzKVxyXG5cdFx0XHRcdC5zdHlsZShcImN1cnNvclwiLCBkID0+IChjb25maWcuZGF0YV9zZWxlY3Rpb25faXNzZWxlY3RhYmxlKGQpID8gXCJwb2ludGVyXCIgOiBudWxsKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGRhdGUgZm9yIHNlbGVjdGVkIGNpcmNsZXNcclxuXHRcdHRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0bWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHQuaWQpfWApXHJcblx0XHRcdFx0LnNlbGVjdEFsbChgJHtDTEFTUy5zZWxlY3RlZENpcmNsZX1gKVxyXG5cdFx0XHRcdC5lYWNoKGQgPT4ge1xyXG5cdFx0XHRcdFx0ZC52YWx1ZSA9IHQudmFsdWVzW2QuaW5kZXhdLnZhbHVlO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2FuIG5vdCBrZWVwIHNhbWUgY29sb3IuLi5cclxuXHRcdC8vIG1haW5MaW5lVXBkYXRlLmV4aXQoKS5yZW1vdmUoKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVMaW5lKGR1cmF0aW9uRm9yRXhpdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2Zvcm1hdDoge2V4dHJhTGluZUNsYXNzZXN9LCAkZWx9ID0gJCQ7XHJcblxyXG5cdFx0JGVsLmxpbmUgPSAkZWwubWFpblxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5saW5lfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwubGluZS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwubGluZSA9ICRlbC5saW5lLmVudGVyKClcclxuXHRcdFx0LmFwcGVuZChcInBhdGhcIilcclxuXHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBkID0+IGAkeyQkLmNsYXNzTGluZS5iaW5kKCQkKShkKX0gJHtleHRyYUxpbmVDbGFzc2VzKGQpIHx8IFwiXCJ9YClcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQubWVyZ2UoJGVsLmxpbmUpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgJCQuaW5pdGlhbE9wYWNpdHkuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcInNoYXBlLXJlbmRlcmluZ1wiLCBkID0+ICgkJC5pc1N0ZXBUeXBlKGQpID8gXCJjcmlzcEVkZ2VzXCIgOiBcIlwiKSlcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgbnVsbCk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3TGluZShkcmF3TGluZSwgd2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdGNvbnN0IHtsaW5lfSA9IHRoaXMuJGVsO1xyXG5cclxuXHRcdHJldHVybiBbXHJcblx0XHRcdCh3aXRoVHJhbnNpdGlvbiA/IGxpbmUudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiBsaW5lKVxyXG5cdFx0XHRcdC5hdHRyKFwiZFwiLCBkcmF3TGluZSlcclxuXHRcdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgdGhpcy5jb2xvcilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMVwiKVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGN1cnZlIGludGVycG9sYXRlXHJcblx0ICogQHBhcmFtIHtBcnJheX0gZCBEYXRhIG9iamVjdFxyXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2V0Q3VydmUoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkU3RlcFR5cGUgPSAkJC5jb25maWcuYXhpc19yb3RhdGVkICYmICQkLmlzU3RlcFR5cGUoZCk7XHJcblxyXG5cdFx0Ly8gd2hlbiBpcyBzdGVwICYgcm90YXRlZCwgc2hvdWxkIGJlIGNvbXB1dGVkIGluIGRpZmZlcmVudCB3YXlcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9uYXZlci9iaWxsYm9hcmQuanMvaXNzdWVzLzQ3MVxyXG5cdFx0cmV0dXJuIGlzUm90YXRlZFN0ZXBUeXBlID8gY29udGV4dCA9PiB7XHJcblx0XHRcdGNvbnN0IHN0ZXAgPSAkJC5nZXRJbnRlcnBvbGF0ZShkKShjb250ZXh0KTtcclxuXHJcblx0XHRcdC8vIGtlZXAgdGhlIG9yaWdpbmFsIG1ldGhvZFxyXG5cdFx0XHRzdGVwLm9yZ1BvaW50ID0gc3RlcC5wb2ludDtcclxuXHJcblx0XHRcdC8vIHRvIGdldCByb3RhdGVkIHBhdGggZGF0YVxyXG5cdFx0XHRzdGVwLnBvaW50Um90YXRlZCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuXHRcdFx0XHR0aGlzLl9wb2ludCA9PT0gMSAmJiAodGhpcy5fcG9pbnQgPSAyKTtcclxuXHJcblx0XHRcdFx0Y29uc3QgeTEgPSB0aGlzLl95ICogKDEgLSB0aGlzLl90KSArIHkgKiB0aGlzLl90O1xyXG5cclxuXHRcdFx0XHR0aGlzLl9jb250ZXh0LmxpbmVUbyh0aGlzLl94LCB5MSk7XHJcblx0XHRcdFx0dGhpcy5fY29udGV4dC5saW5lVG8oeCwgeTEpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl94ID0geDtcclxuXHRcdFx0XHR0aGlzLl95ID0geTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHN0ZXAucG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XHJcblx0XHRcdFx0dGhpcy5fcG9pbnQgPT09IDAgPyB0aGlzLm9yZ1BvaW50KHgsIHkpIDogdGhpcy5wb2ludFJvdGF0ZWQoeCwgeSk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRyZXR1cm4gc3RlcDtcclxuXHRcdH0gOiAkJC5nZXRJbnRlcnBvbGF0ZShkKTtcclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZURyYXdMaW5lKGxpbmVJbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRMaW5lUG9pbnRzKGxpbmVJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGVHZXR0ZXIgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cdFx0Y29uc3QgeVZhbHVlID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHR5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCkoJCQuZ2V0QmFzZVZhbHVlKGQpKVxyXG5cdFx0KTtcclxuXHJcblx0XHRsZXQgbGluZSA9IGQzTGluZSgpO1xyXG5cclxuXHRcdGxpbmUgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRsaW5lLngoeVZhbHVlKS55KHhWYWx1ZSkgOiBsaW5lLngoeFZhbHVlKS55KHlWYWx1ZSk7XHJcblxyXG5cdFx0aWYgKCFsaW5lQ29ubmVjdE51bGwpIHtcclxuXHRcdFx0bGluZSA9IGxpbmUuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgeCA9IGlzU3ViID8gc2NhbGUuc3ViWCA6IHNjYWxlLng7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRjb25zdCB5ID0geVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpO1xyXG5cdFx0XHRsZXQgdmFsdWVzID0gbGluZUNvbm5lY3ROdWxsID8gJCQuZmlsdGVyUmVtb3ZlTnVsbChkLnZhbHVlcykgOiBkLnZhbHVlcztcclxuXHRcdFx0bGV0IHgwID0gMDtcclxuXHRcdFx0bGV0IHkwID0gMDtcclxuXHRcdFx0bGV0IHBhdGg7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNMaW5lVHlwZShkKSkge1xyXG5cdFx0XHRcdGNvbnN0IHJlZ2lvbnMgPSBjb25maWcuZGF0YV9yZWdpb25zW2QuaWRdO1xyXG5cclxuXHRcdFx0XHRpZiAocmVnaW9ucykge1xyXG5cdFx0XHRcdFx0cGF0aCA9ICQkLmxpbmVXaXRoUmVnaW9ucyh2YWx1ZXMsIHgsIHksIHJlZ2lvbnMpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xyXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHZhbHVlcyk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cGF0aCA9IGxpbmUuY3VydmUoJCQuZ2V0Q3VydmUoZCkpKHZhbHVlcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICh2YWx1ZXNbMF0pIHtcclxuXHRcdFx0XHRcdHgwID0geCh2YWx1ZXNbMF0ueCk7XHJcblx0XHRcdFx0XHR5MCA9IHkodmFsdWVzWzBdLnZhbHVlKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHBhdGggPSBpc1JvdGF0ZWQgPyBgTSAke3kwfSAke3gwfWAgOiBgTSAke3gwfSAke3kwfWA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBwYXRoIHx8IFwiTSAwIDBcIjtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVHZXRMaW5lUG9pbnRzKGxpbmVJbmRpY2VzLCBpc1N1YlZhbHVlKSB7IC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1N1YiA9ICEhaXNTdWJWYWx1ZTtcclxuXHRcdGNvbnN0IHggPSAkJC5nZXRTaGFwZVgoMCwgbGluZUluZGljZXMsIGlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoaXNTdWIpO1xyXG5cdFx0Y29uc3QgbGluZU9mZnNldCA9ICQkLmdldFNoYXBlT2Zmc2V0KCQkLmlzTGluZVR5cGUsIGxpbmVJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGUgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGxpbmVPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XHJcblx0XHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xyXG5cdFx0XHRsZXQgcG9zWSA9IHkoZCk7XHJcblxyXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxyXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXHJcblx0XHRcdCkpIHtcclxuXHRcdFx0XHRwb3NZID0geTA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgbGluZSBwb3NpdGlvblxyXG5cdFx0XHRjb25zdCBwb2ludCA9IFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV07XHJcblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdHBvaW50LFxyXG5cdFx0XHRcdHBvaW50LCAvLyBmcm9tIGhlcmUgYW5kIGJlbG93LCBuZWVkZWQgZm9yIGNvbXBhdGliaWxpdHlcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRsaW5lV2l0aFJlZ2lvbnMoZCwgeCwgeSwgX3JlZ2lvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XHJcblx0XHRjb25zdCB4T2Zmc2V0ID0gJCQuaXNDYXRlZ29yaXplZCgpID8gMC41IDogMDtcclxuXHRcdGNvbnN0IHJlZ2lvbnM6IGFueVtdID0gW107XHJcblx0XHRjb25zdCBkYXNoYXJyYXkgPSBcIjIgMlwiOyAvLyBkZWZhdWx0IHZhbHVlXHJcblxyXG5cdFx0bGV0IHhwO1xyXG5cdFx0bGV0IHlwO1xyXG5cdFx0bGV0IGRpZmY7XHJcblx0XHRsZXQgZGlmZngyO1xyXG5cclxuXHRcdC8vIGNoZWNrIHdlYXRoZXIgZGF0YSBpcyB3aXRoaW4gcmVnaW9uXHJcblx0XHRjb25zdCBpc1dpdGhpblJlZ2lvbnMgPSAod2l0aGluWCwgd2l0aGluUmVnaW9ucykgPT4ge1xyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgcmVnOyAocmVnID0gd2l0aGluUmVnaW9uc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdGlmIChyZWcuc3RhcnQgPCB3aXRoaW5YICYmIHdpdGhpblggPD0gcmVnLmVuZCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJlZy5zdHlsZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gQ2hlY2sgc3RhcnQvZW5kIG9mIHJlZ2lvbnNcclxuXHRcdGlmIChpc0RlZmluZWQoX3JlZ2lvbnMpKSB7XHJcblx0XHRcdGNvbnN0IGdldFZhbHVlID0gKHY6IERhdGUgfCBhbnksIGRlZjogbnVtYmVyKTogRGF0ZSB8IGFueSA9PiAoXHJcblx0XHRcdFx0aXNVbmRlZmluZWQodikgPyBkZWYgOiAoaXNUaW1lU2VyaWVzID8gJCQucGFyc2VEYXRlKHYpIDogdilcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdGZvciAobGV0IGkgPSAwLCByZWc7IChyZWcgPSBfcmVnaW9uc1tpXSk7IGkrKykge1xyXG5cdFx0XHRcdGNvbnN0IHN0YXJ0ID0gZ2V0VmFsdWUocmVnLnN0YXJ0LCBkWzBdLngpO1xyXG5cdFx0XHRcdGNvbnN0IGVuZCA9IGdldFZhbHVlKHJlZy5lbmQsIGRbZC5sZW5ndGggLSAxXS54KTtcclxuXHRcdFx0XHRjb25zdCBzdHlsZSA9IHJlZy5zdHlsZSB8fCB7ZGFzaGFycmF5fTtcclxuXHJcblx0XHRcdFx0cmVnaW9uc1tpXSA9IHtzdGFydCwgZW5kLCBzdHlsZX07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgc2NhbGVzXHJcblx0XHRjb25zdCB4VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB5KGR0LnZhbHVlKSA6IGR0ID0+IHgoZHQueCk7XHJcblx0XHRjb25zdCB5VmFsdWUgPSBpc1JvdGF0ZWQgPyBkdCA9PiB4KGR0LngpIDogZHQgPT4geShkdC52YWx1ZSk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIHN2ZyBnZW5lcmF0b3IgZnVuY3Rpb24gZm9yIHJlZ2lvblxyXG5cdFx0Y29uc3QgZ2VuZXJhdGVNID0gcG9pbnRzID0+IGBNJHtwb2ludHNbMF1bMF19LCR7cG9pbnRzWzBdWzFdfUwke3BvaW50c1sxXVswXX0sJHtwb2ludHNbMV1bMV19YDtcclxuXHJcblx0XHRjb25zdCBzV2l0aFJlZ2lvbiA9IGlzVGltZVNlcmllcyA/IChkMCwgZDEsIGssIHRpbWVzZXJpZXNEaWZmKSA9PiB7XHJcblx0XHRcdGNvbnN0IHgwID0gZDAueC5nZXRUaW1lKCk7XHJcblx0XHRcdGNvbnN0IHhEaWZmID0gZDEueCAtIGQwLng7XHJcblx0XHRcdGNvbnN0IHh2MCA9IG5ldyBEYXRlKHgwICsgeERpZmYgKiBrKTtcclxuXHRcdFx0Y29uc3QgeHYxID0gbmV3IERhdGUoeDAgKyB4RGlmZiAqIChrICsgdGltZXNlcmllc0RpZmYpKTtcclxuXHJcblx0XHRcdGNvbnN0IHBvaW50cyA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0W1t5KHlwKGspKSwgeCh4djApXSwgW3koeXAoayArIGRpZmYpKSwgeCh4djEpXV0gOlxyXG5cdFx0XHRcdFtbeCh4djApLCB5KHlwKGspKV0sIFt4KHh2MSksIHkoeXAoayArIGRpZmYpKV1dO1xyXG5cclxuXHRcdFx0cmV0dXJuIGdlbmVyYXRlTShwb2ludHMpO1xyXG5cdFx0fSA6IChkMCwgZDEsIGssIG90aGVyRGlmZikgPT4ge1xyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBpc1JvdGF0ZWQgP1xyXG5cdFx0XHRcdFtbeSh5cChrKSwgdHJ1ZSksIHgoeHAoaykpXSwgW3koeXAoayArIG90aGVyRGlmZiksIHRydWUpLCB4KHhwKGsgKyBvdGhlckRpZmYpKV1dIDpcclxuXHRcdFx0XHRbW3goeHAoayksIHRydWUpLCB5KHlwKGspKV0sIFt4KHhwKGsgKyBvdGhlckRpZmYpLCB0cnVlKSwgeSh5cChrICsgb3RoZXJEaWZmKSldXTtcclxuXHJcblx0XHRcdHJldHVybiBnZW5lcmF0ZU0ocG9pbnRzKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGVcclxuXHRcdGxldCBwYXRoID0gXCJcIjtcclxuXHJcblx0XHRmb3IgKGxldCBpID0gMCwgZGF0YTsgKGRhdGEgPSBkW2ldKTsgaSsrKSB7XHJcblx0XHRcdGNvbnN0IHByZXZEYXRhID0gZFtpIC0gMV07XHJcblx0XHRcdGNvbnN0IGhhc1ByZXZEYXRhID0gcHJldkRhdGEgJiYgaXNWYWx1ZShwcmV2RGF0YS52YWx1ZSk7XHJcblx0XHRcdGxldCBzdHlsZSA9IGlzV2l0aGluUmVnaW9ucyhkYXRhLngsIHJlZ2lvbnMpO1xyXG5cclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvMTE3MlxyXG5cdFx0XHRpZiAoIWlzVmFsdWUoZGF0YS52YWx1ZSkpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRHJhdyBhcyBub3JtYWxcclxuXHRcdFx0aWYgKGlzVW5kZWZpbmVkKHJlZ2lvbnMpIHx8ICFzdHlsZSB8fCAhaGFzUHJldkRhdGEpIHtcclxuXHRcdFx0XHRwYXRoICs9IGAke2kgJiYgaGFzUHJldkRhdGEgPyBcIkxcIiA6IFwiTVwifSR7eFZhbHVlKGRhdGEpfSwke3lWYWx1ZShkYXRhKX1gO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGhhc1ByZXZEYXRhKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHN0eWxlID0gc3R5bGUuZGFzaGFycmF5LnNwbGl0KFwiIFwiKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRzdHlsZSA9IGRhc2hhcnJheS5zcGxpdChcIiBcIik7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBEcmF3IHdpdGggcmVnaW9uIC8vIFRPRE86IEZpeCBmb3IgaG9yaXpvdGFsIGNoYXJ0c1xyXG5cdFx0XHRcdHhwID0gJCQuZ2V0U2NhbGUocHJldkRhdGEueCArIHhPZmZzZXQsIGRhdGEueCArIHhPZmZzZXQsIGlzVGltZVNlcmllcyk7XHJcblx0XHRcdFx0eXAgPSAkJC5nZXRTY2FsZShwcmV2RGF0YS52YWx1ZSwgZGF0YS52YWx1ZSk7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGR4ID0geChkYXRhLngpIC0geChwcmV2RGF0YS54KTtcclxuXHRcdFx0XHRjb25zdCBkeSA9IHkoZGF0YS52YWx1ZSkgLSB5KHByZXZEYXRhLnZhbHVlKTtcclxuXHRcdFx0XHRjb25zdCBkZCA9IE1hdGguc3FydChNYXRoLnBvdyhkeCwgMikgKyBNYXRoLnBvdyhkeSwgMikpO1xyXG5cclxuXHRcdFx0XHRkaWZmID0gc3R5bGVbMF0gLyBkZDtcclxuXHRcdFx0XHRkaWZmeDIgPSBkaWZmICogc3R5bGVbMV07XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGogPSBkaWZmOyBqIDw9IDE7IGogKz0gZGlmZngyKSB7XHJcblx0XHRcdFx0XHRwYXRoICs9IHNXaXRoUmVnaW9uKHByZXZEYXRhLCBkYXRhLCBqLCBkaWZmKTtcclxuXHJcblx0XHRcdFx0XHQvLyB0byBtYWtlIHN1cmUgY29ycmVjdCBsaW5lIGRyYXdpbmdcclxuXHRcdFx0XHRcdGlmIChqICsgZGlmZngyID49IDEpIHtcclxuXHRcdFx0XHRcdFx0cGF0aCArPSBzV2l0aFJlZ2lvbihwcmV2RGF0YSwgZGF0YSwgMSwgMCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhdGg7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQXJlYUdyYWRpZW50KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtkYXRldGltZUlkfSwgJGVsOiB7ZGVmc319ID0gJCQ7XHJcblxyXG5cdFx0JCQuZGF0YS50YXJnZXRzLmZvckVhY2goZCA9PiB7XHJcblx0XHRcdGNvbnN0IGlkID0gYCR7ZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX1gO1xyXG5cclxuXHRcdFx0aWYgKCQkLmlzQXJlYVR5cGUoZCkgJiYgZGVmcy5zZWxlY3QoYCMke2lkfWApLmVtcHR5KCkpIHtcclxuXHRcdFx0XHRjb25zdCBjb2xvciA9ICQkLmNvbG9yKGQpO1xyXG5cdFx0XHRcdGNvbnN0IHtcclxuXHRcdFx0XHRcdHggPSBbMCwgMF0sXHJcblx0XHRcdFx0XHR5ID0gWzAsIDFdLFxyXG5cdFx0XHRcdFx0c3RvcHMgPSBbWzAsIGNvbG9yLCAxXSwgWzEsIGNvbG9yLCAwXV1cclxuXHRcdFx0XHR9ID0gY29uZmlnLmFyZWFfbGluZWFyR3JhZGllbnQ7XHJcblxyXG5cdFx0XHRcdGNvbnN0IGxpbmVhckdyYWRpZW50ID0gZGVmcy5hcHBlbmQoXCJsaW5lYXJHcmFkaWVudFwiKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJpZFwiLCBgJHtpZH1gKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB4WzBdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ4MlwiLCB4WzFdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MVwiLCB5WzBdKVxyXG5cdFx0XHRcdFx0LmF0dHIoXCJ5MlwiLCB5WzFdKTtcclxuXHJcblx0XHRcdFx0c3RvcHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IHN0b3BDb2xvciA9IGlzRnVuY3Rpb24odlsxXSkgPyB2WzFdKGQuaWQpIDogdlsxXTtcclxuXHJcblx0XHRcdFx0XHRsaW5lYXJHcmFkaWVudC5hcHBlbmQoXCJzdG9wXCIpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwib2Zmc2V0XCIsIHZbMF0pXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwic3RvcC1jb2xvclwiLCBzdG9wQ29sb3IgfHwgY29sb3IpXHJcblx0XHRcdFx0XHRcdC5hdHRyKFwic3RvcC1vcGFjaXR5XCIsIHZbMl0pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVBcmVhQ29sb3IoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdHJldHVybiAkJC5jb25maWcuYXJlYV9saW5lYXJHcmFkaWVudCA/XHJcblx0XHRcdGB1cmwoIyR7JCQuc3RhdGUuZGF0ZXRpbWVJZH0tYXJlYUdyYWRpZW50JHskJC5nZXRUYXJnZXRTZWxlY3RvclN1ZmZpeChkLmlkKX0pYCA6XHJcblx0XHRcdCQkLmNvbG9yKGQpO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0KSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzdGF0ZSwgJGVsfSA9ICQkO1xyXG5cclxuXHRcdGNvbmZpZy5hcmVhX2xpbmVhckdyYWRpZW50ICYmICQkLnVwZGF0ZUFyZWFHcmFkaWVudCgpO1xyXG5cclxuXHRcdCRlbC5hcmVhID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5hcmVhfWApXHJcblx0XHRcdC5kYXRhKCQkLmxpbmVEYXRhLmJpbmQoJCQpKTtcclxuXHJcblx0XHQkZWwuYXJlYS5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgXCIwXCIpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHQkZWwuYXJlYSA9ICRlbC5hcmVhLmVudGVyKCkuYXBwZW5kKFwicGF0aFwiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQXJlYS5iaW5kKCQkKSlcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c3RhdGUub3JnQXJlYU9wYWNpdHkgPSBkM1NlbGVjdCh0aGlzKS5zdHlsZShcIm9wYWNpdHlcIik7XHJcblx0XHRcdFx0cmV0dXJuIFwiMFwiO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQubWVyZ2UoJGVsLmFyZWEpO1xyXG5cclxuXHRcdCRlbC5hcmVhXHJcblx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgc3RhdGUub3JnQXJlYU9wYWNpdHkpO1xyXG5cdH0sXHJcblxyXG5cdHJlZHJhd0FyZWEoZHJhd0FyZWEsIHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7b3JnQXJlYU9wYWNpdHl9ID0gJCQuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0KHdpdGhUcmFuc2l0aW9uID8gJCQuJGVsLmFyZWEudHJhbnNpdGlvbihnZXRSYW5kb20oKSkgOiAkJC4kZWwuYXJlYSlcclxuXHRcdFx0XHQuYXR0cihcImRcIiwgZHJhd0FyZWEpXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCAkJC51cGRhdGVBcmVhQ29sb3IuYmluZCgkJCkpXHJcblx0XHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBkID0+IFN0cmluZygkJC5pc0FyZWFSYW5nZVR5cGUoZCkgPyBvcmdBcmVhT3BhY2l0eSAvIDEuNzUgOiBvcmdBcmVhT3BhY2l0eSkpXHJcblx0XHRdO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGFyZWEgcGF0aCBkYXRhXHJcblx0ICogQHBhcmFtIGFyZWFJbmRpY2VzXHJcblx0ICogQHBhcmFtIGlzU3ViXHJcblx0ICogQHJldHVybiB7ZnVuY3Rpb24oKj0pOiAoKnxzdHJpbmcpfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVEcmF3QXJlYShhcmVhSW5kaWNlcywgaXNTdWIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBsaW5lQ29ubmVjdE51bGwgPSBjb25maWcubGluZV9jb25uZWN0TnVsbDtcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9IGNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblxyXG5cdFx0Y29uc3QgZ2V0UG9pbnRzID0gJCQuZ2VuZXJhdGVHZXRBcmVhUG9pbnRzKGFyZWFJbmRpY2VzLCBpc1N1Yik7XHJcblx0XHRjb25zdCB5U2NhbGVHZXR0ZXIgPSBpc1N1YiA/ICQkLmdldFN1YllTY2FsZSA6ICQkLmdldFlTY2FsZTtcclxuXHJcblx0XHRjb25zdCB4VmFsdWUgPSBkID0+IChpc1N1YiA/ICQkLnN1Ynh4IDogJCQueHgpLmNhbGwoJCQsIGQpO1xyXG5cdFx0Y29uc3QgdmFsdWUwID0gKGQsIGkpID0+ICgkJC5pc0dyb3VwZWQoZC5pZCkgP1xyXG5cdFx0XHRnZXRQb2ludHMoZCwgaSlbMF1bMV0gOlxyXG5cdFx0XHR5U2NhbGVHZXR0ZXIuY2FsbCgkJCwgZC5pZCkoXHJcblx0XHRcdFx0JCQuaXNBcmVhUmFuZ2VUeXBlKGQpID9cclxuXHRcdFx0XHRcdCQkLmdldEFyZWFSYW5nZURhdGEoZCwgXCJoaWdoXCIpIDogMFxyXG5cdFx0XHQpKTtcclxuXHRcdGNvbnN0IHZhbHVlMSA9IChkLCBpKSA9PiAoJCQuaXNHcm91cGVkKGQuaWQpID9cclxuXHRcdFx0Z2V0UG9pbnRzKGQsIGkpWzFdWzFdIDpcclxuXHRcdFx0eVNjYWxlR2V0dGVyLmNhbGwoJCQsIGQuaWQpKFxyXG5cdFx0XHRcdCQkLmlzQXJlYVJhbmdlVHlwZShkKSA/XHJcblx0XHRcdFx0XHQkJC5nZXRBcmVhUmFuZ2VEYXRhKGQsIFwibG93XCIpIDogZC52YWx1ZVxyXG5cdFx0XHQpKTtcclxuXHJcblx0XHRyZXR1cm4gZCA9PiB7XHJcblx0XHRcdGxldCB2YWx1ZXMgPSBsaW5lQ29ubmVjdE51bGwgPyAkJC5maWx0ZXJSZW1vdmVOdWxsKGQudmFsdWVzKSA6IGQudmFsdWVzO1xyXG5cdFx0XHRsZXQgeDAgPSAwO1xyXG5cdFx0XHRsZXQgeTAgPSAwO1xyXG5cdFx0XHRsZXQgcGF0aDtcclxuXHJcblx0XHRcdGlmICgkJC5pc0FyZWFUeXBlKGQpKSB7XHJcblx0XHRcdFx0bGV0IGFyZWEgPSBkM0FyZWEoKTtcclxuXHJcblx0XHRcdFx0YXJlYSA9IGlzUm90YXRlZCA/XHJcblx0XHRcdFx0XHRhcmVhLnkoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQueDAodmFsdWUwKVxyXG5cdFx0XHRcdFx0XHQueDEodmFsdWUxKSA6XHJcblx0XHRcdFx0XHRhcmVhLngoeFZhbHVlKVxyXG5cdFx0XHRcdFx0XHQvLyBAdHMtaWdub3JlXHJcblx0XHRcdFx0XHRcdC55MChjb25maWcuYXJlYV9hYm92ZSA/IDAgOiB2YWx1ZTApXHJcblx0XHRcdFx0XHRcdC55MSh2YWx1ZTEpO1xyXG5cclxuXHRcdFx0XHRpZiAoIWxpbmVDb25uZWN0TnVsbCkge1xyXG5cdFx0XHRcdFx0YXJlYSA9IGFyZWEuZGVmaW5lZChkID0+ICQkLmdldEJhc2VWYWx1ZShkKSAhPT0gbnVsbCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoJCQuaXNTdGVwVHlwZShkKSkge1xyXG5cdFx0XHRcdFx0dmFsdWVzID0gJCQuY29udmVydFZhbHVlc1RvU3RlcCh2YWx1ZXMpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cGF0aCA9IGFyZWEuY3VydmUoJCQuZ2V0Q3VydmUoZCkpKHZhbHVlcyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYgKHZhbHVlc1swXSkge1xyXG5cdFx0XHRcdFx0eDAgPSAkJC5zY2FsZS54KHZhbHVlc1swXS54KTtcclxuXHRcdFx0XHRcdHkwID0gJCQuZ2V0WVNjYWxlKGQuaWQpKHZhbHVlc1swXS52YWx1ZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwYXRoID0gaXNSb3RhdGVkID8gYE0gJHt5MH0gJHt4MH1gIDogYE0gJHt4MH0gJHt5MH1gO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0aCB8fCBcIk0gMCAwXCI7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0QXJlYVBvaW50cyhhcmVhSW5kaWNlcywgaXNTdWIpIHtcclxuXHRcdC8vIHBhcnRpYWwgZHVwbGljYXRpb24gb2YgZ2VuZXJhdGVHZXRCYXJQb2ludHNcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCB4ID0gJCQuZ2V0U2hhcGVYKDAsIGFyZWFJbmRpY2VzLCAhIWlzU3ViKTtcclxuXHRcdGNvbnN0IHkgPSAkJC5nZXRTaGFwZVkoISFpc1N1Yik7XHJcblx0XHRjb25zdCBhcmVhT2Zmc2V0ID0gJCQuZ2V0U2hhcGVPZmZzZXQoJCQuaXNBcmVhVHlwZSwgYXJlYUluZGljZXMsICEhaXNTdWIpO1xyXG5cdFx0Y29uc3QgeVNjYWxlID0gaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUgOiAkJC5nZXRZU2NhbGU7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGQsIGkpIHtcclxuXHRcdFx0Y29uc3QgeTAgPSB5U2NhbGUuY2FsbCgkJCwgZC5pZCkoMCk7XHJcblx0XHRcdGNvbnN0IG9mZnNldCA9IGFyZWFPZmZzZXQoZCwgaSkgfHwgeTA7IC8vIG9mZnNldCBpcyBmb3Igc3RhY2tlZCBhcmVhIGNoYXJ0XHJcblx0XHRcdGNvbnN0IHBvc1ggPSB4KGQpO1xyXG5cdFx0XHRsZXQgcG9zWSA9IHkoZCk7XHJcblxyXG5cdFx0XHQvLyBmaXggcG9zWSBub3QgdG8gb3ZlcmZsb3cgb3Bwb3NpdGUgcXVhZHJhbnRcclxuXHRcdFx0aWYgKGNvbmZpZy5heGlzX3JvdGF0ZWQgJiYgKFxyXG5cdFx0XHRcdChkLnZhbHVlID4gMCAmJiBwb3NZIDwgeTApIHx8IChkLnZhbHVlIDwgMCAmJiB5MCA8IHBvc1kpXHJcblx0XHRcdCkpIHtcclxuXHRcdFx0XHRwb3NZID0geTA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIDEgcG9pbnQgdGhhdCBtYXJrcyB0aGUgYXJlYSBwb3NpdGlvblxyXG5cdFx0XHRyZXR1cm4gW1xyXG5cdFx0XHRcdFtwb3NYLCBvZmZzZXRdLFxyXG5cdFx0XHRcdFtwb3NYLCBwb3NZIC0gKHkwIC0gb2Zmc2V0KV0sXHJcblx0XHRcdFx0W3Bvc1gsIHBvc1kgLSAoeTAgLSBvZmZzZXQpXSwgLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XHJcblx0XHRcdFx0W3Bvc1gsIG9mZnNldF0gLy8gbmVlZGVkIGZvciBjb21wYXRpYmlsaXR5XHJcblx0XHRcdF07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZUNpcmNsZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsICRlbH0gPSAkJDtcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuY2lyY2xlID0gJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfWApLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlfWApXHJcblx0XHRcdC5kYXRhKGQgPT4gISQkLmlzQmFyVHlwZShkKSAmJiAoXHJcblx0XHRcdFx0ISQkLmlzTGluZVR5cGUoZCkgfHwgJCQuc2hvdWxkRHJhd1BvaW50c0ZvckxpbmUoZClcclxuXHRcdFx0KSAmJiAkJC5sYWJlbGlzaERhdGEoZCkpO1xyXG5cclxuXHRcdCRlbC5jaXJjbGUuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdGNvbnN0IGZuID0gJCQucG9pbnQoXCJjcmVhdGVcIiwgdGhpcywgJCQucG9pbnRSLmJpbmQoJCQpLCAkJC5jb2xvcik7XHJcblxyXG5cdFx0JGVsLmNpcmNsZSA9ICRlbC5jaXJjbGUuZW50ZXIoKVxyXG5cdFx0XHQuYXBwZW5kKGZuKVxyXG5cdFx0XHQubWVyZ2UoJGVsLmNpcmNsZSlcclxuXHRcdFx0LnN0eWxlKFwic3Ryb2tlXCIsICQkLmNvbG9yKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsICQkLmluaXRpYWxPcGFjaXR5Rm9yQ2lyY2xlLmJpbmQoJCQpKTtcclxuXHR9LFxyXG5cclxuXHRyZWRyYXdDaXJjbGUoY3gsIGN5LCB3aXRoVHJhbnNpdGlvbiwgZmxvdykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc2VsZWN0ZWRDaXJjbGVzID0gJCQuJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zZWxlY3RlZENpcmNsZX1gKTtcclxuXHJcblx0XHRpZiAoISQkLmNvbmZpZy5wb2ludF9zaG93KSB7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHJcblx0XHRjb25zdCBtYWluQ2lyY2xlczogYW55W10gPSBbXTtcclxuXHJcblx0XHQkJC4kZWwuY2lyY2xlLmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRjb25zdCBmbiA9ICQkLnBvaW50KFwidXBkYXRlXCIsICQkLCBjeCwgY3ksICQkLm9wYWNpdHlGb3JDaXJjbGUuYmluZCgkJCksICQkLmNvbG9yLCB3aXRoVHJhbnNpdGlvbiwgZmxvdywgc2VsZWN0ZWRDaXJjbGVzKS5iaW5kKHRoaXMpO1xyXG5cdFx0XHRjb25zdCByZXN1bHQgPSBmbihkKTtcclxuXHJcblx0XHRcdG1haW5DaXJjbGVzLnB1c2gocmVzdWx0KTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnN0IHBvc0F0dHIgPSAkJC5pc0NpcmNsZVBvaW50KCkgPyBcImNcIiA6IFwiXCI7XHJcblxyXG5cdFx0cmV0dXJuIFtcclxuXHRcdFx0bWFpbkNpcmNsZXMsXHJcblx0XHRcdHNlbGVjdGVkQ2lyY2xlc1xyXG5cdFx0XHRcdC5hdHRyKGAke3Bvc0F0dHJ9eGAsIGN4KVxyXG5cdFx0XHRcdC5hdHRyKGAke3Bvc0F0dHJ9eWAsIGN5KVxyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHRjaXJjbGVYKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHt4LCB6b29tfSA9ICQkLnNjYWxlO1xyXG5cdFx0Y29uc3QgaGFzVmFsdWUgPSBpc1ZhbHVlKGQueCk7XHJcblxyXG5cdFx0cmV0dXJuICQkLmNvbmZpZy56b29tX2VuYWJsZWQgJiYgem9vbSA/XHJcblx0XHRcdChoYXNWYWx1ZSA/IHpvb20oZC54KSA6IG51bGwpIDpcclxuXHRcdFx0KGhhc1ZhbHVlID8geChkLngpIDogbnVsbCk7XHJcblx0fSxcclxuXHJcblx0dXBkYXRlQ2lyY2xlWSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGdldFBvaW50cyA9ICQkLmdlbmVyYXRlR2V0TGluZVBvaW50cygkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNMaW5lVHlwZSksIGZhbHNlKTtcclxuXHJcblx0XHQkJC5jaXJjbGVZID0gKGQsIGkpID0+IHtcclxuXHRcdFx0Y29uc3QgaWQgPSBkLmlkO1xyXG5cclxuXHRcdFx0cmV0dXJuICQkLmlzR3JvdXBlZChpZCkgP1xyXG5cdFx0XHRcdGdldFBvaW50cyhkLCBpKVswXVsxXSA6XHJcblx0XHRcdFx0JCQuZ2V0WVNjYWxlKGlkKSgkJC5nZXRCYXNlVmFsdWUoZCkpO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRnZXRDaXJjbGVzKGksIGlkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCBzdWZmaXggPSAoaXNWYWx1ZShpKSA/IGAtJHtpfWAgOiBgYCk7XHJcblxyXG5cdFx0cmV0dXJuIChpZCA/ICQkLiRlbC5tYWluLnNlbGVjdEFsbChgLiR7Q0xBU1MuY2lyY2xlc30keyQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KGlkKX1gKSA6ICQkLiRlbC5tYWluKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGV9JHtzdWZmaXh9YCk7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQ2lyY2xlcyhpLCBpZCwgcmVzZXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHIgPSAkJC5wb2ludEV4cGFuZGVkUi5iaW5kKCQkKTtcclxuXHJcblx0XHRyZXNldCAmJiAkJC51bmV4cGFuZENpcmNsZXMoKTtcclxuXHJcblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpLCBpZCkuY2xhc3NlZChDTEFTUy5FWFBBTkRFRCwgdHJ1ZSk7XHJcblx0XHRjb25zdCBzY2FsZSA9IHIoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcjtcclxuXHRcdGNvbnN0IHJhdGlvID0gMSAtIHNjYWxlO1xyXG5cclxuXHRcdGlmICgkJC5pc0NpcmNsZVBvaW50KCkpIHtcclxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwiclwiLCByKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHRyYW5zZm9ybSBtdXN0IGJlIGFwcGxpZWQgdG8gZWFjaCBub2RlIGluZGl2aWR1YWxseVxyXG5cdFx0XHRjaXJjbGVzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y29uc3QgcG9pbnQgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHJcblx0XHRcdFx0aWYgKHRoaXMudGFnTmFtZSA9PT0gXCJjaXJjbGVcIikge1xyXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInJcIiwgcik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuZ2V0QkJveCgpO1xyXG5cdFx0XHRcdFx0Y29uc3QgeCA9IHJhdGlvICogKCtwb2ludC5hdHRyKFwieFwiKSArIHdpZHRoIC8gMik7XHJcblx0XHRcdFx0XHRjb25zdCB5ID0gcmF0aW8gKiAoK3BvaW50LmF0dHIoXCJ5XCIpICsgaGVpZ2h0IC8gMik7XHJcblxyXG5cdFx0XHRcdFx0cG9pbnQuYXR0cihcInRyYW5zZm9ybVwiLCBgdHJhbnNsYXRlKCR7eH0gJHt5fSkgc2NhbGUoJHtzY2FsZX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1bmV4cGFuZENpcmNsZXMoaSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgciA9ICQkLnBvaW50Ui5iaW5kKCQkKTtcclxuXHJcblx0XHRjb25zdCBjaXJjbGVzID0gJCQuZ2V0Q2lyY2xlcyhpKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLkVYUEFOREVEKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmNsYXNzZWQoQ0xBU1MuRVhQQU5ERUQsIGZhbHNlKTtcclxuXHJcblx0XHRjaXJjbGVzLmF0dHIoXCJyXCIsIHIpO1xyXG5cclxuXHRcdCEkJC5pc0NpcmNsZVBvaW50KCkgJiZcclxuXHRcdFx0Y2lyY2xlcy5hdHRyKFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3IoY2lyY2xlcykgLyAkJC5jb25maWcucG9pbnRfcn0pYCk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRSKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBwb2ludFIgPSBjb25maWcucG9pbnRfcjtcclxuXHRcdGxldCByID0gcG9pbnRSO1xyXG5cclxuXHRcdGlmICgkJC5pc1N0ZXBUeXBlKGQpKSB7XHJcblx0XHRcdHIgPSAwO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5pc0J1YmJsZVR5cGUoZCkpIHtcclxuXHRcdFx0ciA9ICQkLmdldEJ1YmJsZVIoZCk7XHJcblx0XHR9IGVsc2UgaWYgKGlzRnVuY3Rpb24ocG9pbnRSKSkge1xyXG5cdFx0XHRyID0gcG9pbnRSKGQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50RXhwYW5kZWRSKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBzY2FsZSA9ICQkLmlzQnViYmxlVHlwZShkKSA/IDEuMTUgOiAxLjc1O1xyXG5cclxuXHRcdHJldHVybiBjb25maWcucG9pbnRfZm9jdXNfZXhwYW5kX2VuYWJsZWQgP1xyXG5cdFx0XHQoY29uZmlnLnBvaW50X2ZvY3VzX2V4cGFuZF9yIHx8ICQkLnBvaW50UihkKSAqIHNjYWxlKSA6ICQkLnBvaW50UihkKTtcclxuXHR9LFxyXG5cclxuXHRwb2ludFNlbGVjdFIoZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qgc2VsZWN0UiA9ICQkLmNvbmZpZy5wb2ludF9zZWxlY3RfcjtcclxuXHJcblx0XHRyZXR1cm4gaXNGdW5jdGlvbihzZWxlY3RSKSA/XHJcblx0XHRcdHNlbGVjdFIoZCkgOiAoc2VsZWN0UiB8fCAkJC5wb2ludFIoZCkgKiA0KTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpbkNpcmNsZShub2RlLCByKSB7XHJcblx0XHRjb25zdCBtb3VzZSA9IGQzTW91c2Uobm9kZSk7XHJcblx0XHRjb25zdCBlbGVtZW50ID0gZDNTZWxlY3Qobm9kZSk7XHJcblx0XHRjb25zdCBwcmVmaXggPSB0aGlzLmlzQ2lyY2xlUG9pbnQoKSA/IFwiY1wiIDogXCJcIjtcclxuXHJcblx0XHRsZXQgY3ggPSArZWxlbWVudC5hdHRyKGAke3ByZWZpeH14YCk7XHJcblx0XHRsZXQgY3kgPSArZWxlbWVudC5hdHRyKGAke3ByZWZpeH15YCk7XHJcblxyXG5cdFx0Ly8gaWYgbm9kZSBkb24ndCBoYXZlIGN4L3kgb3IgeC95IGF0dHJpYnV0ZSB2YWx1ZVxyXG5cdFx0aWYgKCEoY3ggfHwgY3kpICYmIG5vZGUubm9kZVR5cGUgPT09IDEpIHtcclxuXHRcdFx0Y29uc3Qge3gsIHl9ID0gbm9kZS5nZXRCQm94ID8gbm9kZS5nZXRCQm94KCkgOiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRcdFx0Y3ggPSB4O1xyXG5cdFx0XHRjeSA9IHk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydChcclxuXHRcdFx0TWF0aC5wb3coY3ggLSBtb3VzZVswXSwgMikgKyBNYXRoLnBvdyhjeSAtIG1vdXNlWzFdLCAyKVxyXG5cdFx0KSA8IChyIHx8IHRoaXMuY29uZmlnLnBvaW50X3NlbnNpdGl2aXR5KTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpblN0ZXAodGhhdCwgeSkge1xyXG5cdFx0cmV0dXJuIE1hdGguYWJzKHkgLSBkM01vdXNlKHRoYXQpWzFdKSA8IDMwO1xyXG5cdH0sXHJcblxyXG5cdHNob3VsZERyYXdQb2ludHNGb3JMaW5lKGQpIHtcclxuXHRcdGNvbnN0IGxpbmVQb2ludCA9IHRoaXMuY29uZmlnLmxpbmVfcG9pbnQ7XHJcblxyXG5cdFx0cmV0dXJuIGxpbmVQb2ludCA9PT0gdHJ1ZSB8fFxyXG5cdFx0XHQoaXNBcnJheShsaW5lUG9pbnQpICYmIGxpbmVQb2ludC5pbmRleE9mKGQuaWQpICE9PSAtMSk7XHJcblx0fSxcclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdG5hbWVzcGFjZXMgYXMgZDNOYW1lc3BhY2VzLFxyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7Z2V0UmFuZG9tLCBpc0Z1bmN0aW9uLCBpc09iamVjdCwgaXNPYmplY3RUeXBlLCB0b0FycmF5LCBub3RFbXB0eX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aGFzVmFsaWRQb2ludFR5cGUodHlwZSkge1xyXG5cdFx0cmV0dXJuIC9eKGNpcmNsZXxyZWN0KGFuZ2xlKT98cG9seWdvbnxlbGxpcHNlfHVzZSkkL2kudGVzdCh0eXBlIHx8IHRoaXMuY29uZmlnLnBvaW50X3R5cGUpO1xyXG5cdH0sXHJcblxyXG5cdGhhc1ZhbGlkUG9pbnREcmF3TWV0aG9kcyh0eXBlKSB7XHJcblx0XHRjb25zdCBwb2ludFR5cGUgPSB0eXBlIHx8IHRoaXMuY29uZmlnLnBvaW50X3R5cGU7XHJcblxyXG5cdFx0cmV0dXJuIGlzT2JqZWN0VHlwZShwb2ludFR5cGUpICYmXHJcblx0XHRcdGlzRnVuY3Rpb24ocG9pbnRUeXBlLmNyZWF0ZSkgJiYgaXNGdW5jdGlvbihwb2ludFR5cGUudXBkYXRlKTtcclxuXHR9LFxyXG5cclxuXHRpbnNlcnRQb2ludEluZm9EZWZzKHBvaW50LCBpZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgY29weUF0dHIgPSAoZnJvbSwgdGFyZ2V0KSA9PiB7XHJcblx0XHRcdGNvbnN0IGF0dHJpYnMgPSBmcm9tLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMCwgbmFtZTsgKG5hbWUgPSBhdHRyaWJzW2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0bmFtZSA9IG5hbWUubmFtZTtcclxuXHRcdFx0XHR0YXJnZXQuc2V0QXR0cmlidXRlKG5hbWUsIGZyb20uZ2V0QXR0cmlidXRlKG5hbWUpKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBkb2MgPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHBvaW50LCBcImltYWdlL3N2Zyt4bWxcIik7XHJcblx0XHRjb25zdCBub2RlID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHRcdGNvbnN0IGNsb25lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGQzTmFtZXNwYWNlcy5zdmcsIG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XHJcblxyXG5cdFx0Y2xvbmUuaWQgPSBpZDtcclxuXHRcdGNsb25lLnN0eWxlLmZpbGwgPSBcImluaGVyaXRcIjtcclxuXHRcdGNsb25lLnN0eWxlLnN0cm9rZSA9IFwiaW5oZXJpdFwiO1xyXG5cclxuXHRcdGNvcHlBdHRyKG5vZGUsIGNsb25lKTtcclxuXHJcblx0XHRpZiAobm9kZS5jaGlsZE5vZGVzICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0Y29uc3QgcGFyZW50ID0gZDNTZWxlY3QoY2xvbmUpO1xyXG5cclxuXHRcdFx0aWYgKFwiaW5uZXJIVE1MXCIgaW4gY2xvbmUpIHtcclxuXHRcdFx0XHRwYXJlbnQuaHRtbChub2RlLmlubmVySFRNTCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dG9BcnJheShub2RlLmNoaWxkTm9kZXMpLmZvckVhY2godiA9PiB7XHJcblx0XHRcdFx0XHRjb3B5QXR0cih2LCBwYXJlbnQuYXBwZW5kKHYudGFnTmFtZSkubm9kZSgpKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCQkLiRlbC5kZWZzLm5vZGUoKS5hcHBlbmRDaGlsZChjbG9uZSk7XHJcblx0fSxcclxuXHJcblx0cG9pbnRGcm9tRGVmcyhpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuJGVsLmRlZnMuc2VsZWN0KGAjJHtpZH1gKTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVQb2ludENsYXNzKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjaXJjbGV9ID0gJCQuJGVsO1xyXG5cdFx0bGV0IHBvaW50Q2xhc3MgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QoZCkgfHwgY2lyY2xlKSB7XHJcblx0XHRcdHBvaW50Q2xhc3MgPSBkID09PSB0cnVlID9cclxuXHRcdFx0XHRjaXJjbGUuYXR0cihcImNsYXNzXCIsICQkLmNsYXNzQ2lyY2xlLmJpbmQoJCQpKSA6XHJcblx0XHRcdFx0JCQuY2xhc3NDaXJjbGUoZCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50Q2xhc3M7XHJcblx0fSxcclxuXHJcblx0Z2VuZXJhdGVQb2ludCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7ZGF0ZXRpbWVJZH19ID0gJCQ7XHJcblx0XHRjb25zdCBpZHM6IHN0cmluZ1tdID0gW107XHJcblx0XHRjb25zdCBwYXR0ZXJuID0gbm90RW1wdHkoY29uZmlnLnBvaW50X3BhdHRlcm4pID8gY29uZmlnLnBvaW50X3BhdHRlcm4gOiBbY29uZmlnLnBvaW50X3R5cGVdO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbihtZXRob2QsIGNvbnRleHQsIC4uLmFyZ3MpIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGQpIHtcclxuXHRcdFx0XHRjb25zdCBpZDogc3RyaW5nID0gZC5pZCB8fCAoZC5kYXRhICYmIGQuZGF0YS5pZCkgfHwgZDtcclxuXHRcdFx0XHRjb25zdCBlbGVtZW50ID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdGlkcy5pbmRleE9mKGlkKSA8IDAgJiYgaWRzLnB1c2goaWQpO1xyXG5cclxuXHRcdFx0XHRsZXQgcG9pbnQgPSBwYXR0ZXJuW2lkcy5pbmRleE9mKGlkKSAlIHBhdHRlcm4ubGVuZ3RoXTtcclxuXHJcblx0XHRcdFx0aWYgKCQkLmhhc1ZhbGlkUG9pbnRUeXBlKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0cG9pbnQgPSAkJFtwb2ludF07XHJcblx0XHRcdFx0fSBlbHNlIGlmICghJCQuaGFzVmFsaWRQb2ludERyYXdNZXRob2RzKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0Y29uc3QgcG9pbnRJZCA9IGAke2RhdGV0aW1lSWR9LXBvaW50LSR7aWR9YDtcclxuXHRcdFx0XHRcdGNvbnN0IHBvaW50RnJvbURlZnMgPSAkJC5wb2ludEZyb21EZWZzKHBvaW50SWQpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChwb2ludEZyb21EZWZzLnNpemUoKSA8IDEpIHtcclxuXHRcdFx0XHRcdFx0JCQuaW5zZXJ0UG9pbnRJbmZvRGVmcyhwb2ludCwgcG9pbnRJZCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKG1ldGhvZCA9PT0gXCJjcmVhdGVcIikge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJCQuY3VzdG9tLmNyZWF0ZS5iaW5kKGNvbnRleHQpKGVsZW1lbnQsIHBvaW50SWQsIC4uLmFyZ3MpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChtZXRob2QgPT09IFwidXBkYXRlXCIpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuICQkLmN1c3RvbS51cGRhdGUuYmluZChjb250ZXh0KShlbGVtZW50LCAuLi5hcmdzKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBwb2ludFttZXRob2RdLmJpbmQoY29udGV4dCkoZWxlbWVudCwgLi4uYXJncyk7XHJcblx0XHRcdH07XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldFRyYW5zaXRpb25OYW1lKCkge1xyXG5cdFx0cmV0dXJuIGdldFJhbmRvbSgpO1xyXG5cdH0sXHJcblxyXG5cdGN1c3RvbToge1xyXG5cdFx0Y3JlYXRlKGVsZW1lbnQsIGlkLCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcInVzZVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieGxpbms6aHJlZlwiLCBgIyR7aWR9YClcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIHRoaXMudXBkYXRlUG9pbnRDbGFzcy5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0XHRjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBlbGVtZW50Lm5vZGUoKS5nZXRCQm94KCk7XHJcblxyXG5cdFx0XHRjb25zdCB4UG9zRm4yID0gZCA9PiB4UG9zRm4oZCkgLSB3aWR0aCAvIDI7XHJcblx0XHRcdGNvbnN0IHlQb3NGbjIgPSBkID0+IHlQb3NGbihkKSAtIGhlaWdodCAvIDI7XHJcblx0XHRcdGxldCBtYWluQ2lyY2xlcyA9IGVsZW1lbnQ7XHJcblxyXG5cdFx0XHRpZiAod2l0aFRyYW5zaXRpb24pIHtcclxuXHRcdFx0XHRjb25zdCB0cmFuc2l0aW9uTmFtZSA9ICQkLmdldFRyYW5zaXRpb25OYW1lKCk7XHJcblxyXG5cdFx0XHRcdGZsb3cgJiYgbWFpbkNpcmNsZXMuYXR0cihcInhcIiwgeFBvc0ZuMik7XHJcblxyXG5cdFx0XHRcdG1haW5DaXJjbGVzID0gbWFpbkNpcmNsZXMudHJhbnNpdGlvbih0cmFuc2l0aW9uTmFtZSk7XHJcblx0XHRcdFx0c2VsZWN0ZWRDaXJjbGVzLnRyYW5zaXRpb24oJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYWluQ2lyY2xlc1xyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCB4UG9zRm4yKVxyXG5cdFx0XHRcdC5hdHRyKFwieVwiLCB5UG9zRm4yKVxyXG5cdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgb3BhY2l0eVN0eWxlRm4pXHJcblx0XHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBmaWxsU3R5bGVGbik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gJ2NpcmNsZScgZGF0YSBwb2ludFxyXG5cdGNpcmNsZToge1xyXG5cdFx0Y3JlYXRlKGVsZW1lbnQsIHNpemVGbiwgZmlsbFN0eWxlRm4pIHtcclxuXHRcdFx0cmV0dXJuIGVsZW1lbnQuYXBwZW5kKFwiY2lyY2xlXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCB0aGlzLnVwZGF0ZVBvaW50Q2xhc3MuYmluZCh0aGlzKSlcclxuXHRcdFx0XHQuYXR0cihcInJcIiwgc2l6ZUZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0Ly8gd2hlbiAnLmxvYWQoKScgY2FsbGVkLCBidWJibGUgc2l6ZSBzaG91bGQgYmUgdXBkYXRlZFxyXG5cdFx0XHRpZiAoJCQuaGFzVHlwZShcImJ1YmJsZVwiKSkge1xyXG5cdFx0XHRcdG1haW5DaXJjbGVzLmF0dHIoXCJyXCIsICQkLnBvaW50Ui5iaW5kKCQkKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdGNvbnN0IHRyYW5zaXRpb25OYW1lID0gJCQuZ2V0VHJhbnNpdGlvbk5hbWUoKTtcclxuXHJcblx0XHRcdFx0ZmxvdyAmJiBtYWluQ2lyY2xlcy5hdHRyKFwiY3hcIiwgeFBvc0ZuKTtcclxuXHJcblx0XHRcdFx0aWYgKG1haW5DaXJjbGVzLmF0dHIoXCJjeFwiKSkge1xyXG5cdFx0XHRcdFx0bWFpbkNpcmNsZXMgPSBtYWluQ2lyY2xlcy50cmFuc2l0aW9uKHRyYW5zaXRpb25OYW1lKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKCQkLmdldFRyYW5zaXRpb25OYW1lKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihcImN4XCIsIHhQb3NGbilcclxuXHRcdFx0XHQuYXR0cihcImN5XCIsIHlQb3NGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHlTdHlsZUZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vICdyZWN0YW5nbGUnIGRhdGEgcG9pbnRcclxuXHRyZWN0YW5nbGU6IHtcclxuXHRcdGNyZWF0ZShlbGVtZW50LCBzaXplRm4sIGZpbGxTdHlsZUZuKSB7XHJcblx0XHRcdGNvbnN0IHJlY3RTaXplRm4gPSBkID0+IHNpemVGbihkKSAqIDIuMDtcclxuXHJcblx0XHRcdHJldHVybiBlbGVtZW50LmFwcGVuZChcInJlY3RcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIHRoaXMudXBkYXRlUG9pbnRDbGFzcy5iaW5kKHRoaXMpKVxyXG5cdFx0XHRcdC5hdHRyKFwid2lkdGhcIiwgcmVjdFNpemVGbilcclxuXHRcdFx0XHQuYXR0cihcImhlaWdodFwiLCByZWN0U2l6ZUZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pXHJcblx0XHRcdFx0Lm5vZGUoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0dXBkYXRlKGVsZW1lbnQsIHhQb3NGbiwgeVBvc0ZuLCBvcGFjaXR5U3R5bGVGbiwgZmlsbFN0eWxlRm4sXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uLCBmbG93LCBzZWxlY3RlZENpcmNsZXMpIHtcclxuXHRcdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0XHRjb25zdCByID0gJCQuY29uZmlnLnBvaW50X3I7XHJcblx0XHRcdGNvbnN0IHJlY3RYUG9zRm4gPSBkID0+IHhQb3NGbihkKSAtIHI7XHJcblx0XHRcdGNvbnN0IHJlY3RZUG9zRm4gPSBkID0+IHlQb3NGbihkKSAtIHI7XHJcblxyXG5cdFx0XHRsZXQgbWFpbkNpcmNsZXMgPSBlbGVtZW50O1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0Y29uc3QgdHJhbnNpdGlvbk5hbWUgPSAkJC5nZXRUcmFuc2l0aW9uTmFtZSgpO1xyXG5cclxuXHRcdFx0XHRmbG93ICYmIG1haW5DaXJjbGVzLmF0dHIoXCJ4XCIsIHJlY3RYUG9zRm4pO1xyXG5cclxuXHRcdFx0XHRtYWluQ2lyY2xlcyA9IG1haW5DaXJjbGVzLnRyYW5zaXRpb24odHJhbnNpdGlvbk5hbWUpO1xyXG5cdFx0XHRcdHNlbGVjdGVkQ2lyY2xlcy50cmFuc2l0aW9uKCQkLmdldFRyYW5zaXRpb25OYW1lKCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWFpbkNpcmNsZXNcclxuXHRcdFx0XHQuYXR0cihcInhcIiwgcmVjdFhQb3NGbilcclxuXHRcdFx0XHQuYXR0cihcInlcIiwgcmVjdFlQb3NGbilcclxuXHRcdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIG9wYWNpdHlTdHlsZUZuKVxyXG5cdFx0XHRcdC5zdHlsZShcImZpbGxcIiwgZmlsbFN0eWxlRm4pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge1xyXG5cdHNlbGVjdCBhcyBkM1NlbGVjdCxcclxuXHRldmVudCBhcyBkM0V2ZW50XHJcbn0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0TWluTWF4LCBnZXRSYW5nZSwgaXNEZWZpbmVkLCBpc0VtcHR5LCBpc051bWJlciwgaXNVbmRlZmluZWQsIHNldFRleHRWYWx1ZSwgdG9BcnJheX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogR2V0IHRoZSBwb3NpdGlvbiB2YWx1ZVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQ2xvY2t3aXNlIElmIHRoZSBkaXJlY3Rpb24gaXMgY2xvY2t3aXNlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIENvb3JkaW5hdGUgdHlwZSAneCcgb3IgJ3knXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBlZGdlIE51bWJlciBvZiBlZGdlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgVGhlIGluZGV4ZWQgcG9zaXRpb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhbmdlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYXRpb1xyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihpc0Nsb2Nrd2lzZSwgdHlwZSwgZWRnZSwgcG9zLCByYW5nZSwgcmF0aW8pIHtcclxuXHRjb25zdCBpbmRleCA9IGlzQ2xvY2t3aXNlICYmIHBvcyA+IDAgPyBlZGdlIC0gcG9zIDogcG9zO1xyXG5cdGNvbnN0IHIgPSAyICogTWF0aC5QSTtcclxuXHRjb25zdCBmdW5jID0gdHlwZSA9PT0gXCJ4XCIgPyBNYXRoLnNpbiA6IE1hdGguY29zO1xyXG5cclxuXHRyZXR1cm4gcmFuZ2UgKiAoMSAtIHJhdGlvICogZnVuYyhpbmRleCAqIHIgLyBlZGdlKSk7XHJcbn1cclxuXHJcbi8vIGNhY2hlIGtleVxyXG5jb25zdCBjYWNoZUtleSA9IFwiJHJhZGFyUG9pbnRzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0aW5pdFJhZGFyKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoJCQuaGFzVHlwZShcInJhZGFyXCIpKSB7XHJcblx0XHRcdCQkLnJhZGFycyA9ICQkLiRlbC5tYWluLnNlbGVjdChgLiR7Q0xBU1MuY2hhcnR9YCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnRSYWRhcnMpO1xyXG5cclxuXHRcdFx0Ly8gbGV2ZWxcclxuXHRcdFx0JCQucmFkYXJzLmxldmVscyA9ICQkLnJhZGFycy5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5sZXZlbHMpO1xyXG5cclxuXHRcdFx0Ly8gYXhpc1xyXG5cdFx0XHQkJC5yYWRhcnMuYXhlcyA9ICQkLnJhZGFycy5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJjbGFzc1wiLCBDTEFTUy5heGlzKTtcclxuXHJcblx0XHRcdC8vIHNoYXBlc1xyXG5cdFx0XHQkJC5yYWRhcnMuc2hhcGVzID0gJCQucmFkYXJzLmFwcGVuZChcImdcIilcclxuXHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIENMQVNTLnNoYXBlcyk7XHJcblxyXG5cdFx0XHQkJC5tYXhWYWx1ZSA9IGNvbmZpZy5yYWRhcl9heGlzX21heCB8fCAkJC5nZXRNaW5NYXhEYXRhKCkubWF4WzBdLnZhbHVlO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldFJhZGFyU2l6ZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7YXJjV2lkdGgsIGFyY0hlaWdodH19ID0gJCQ7XHJcblx0XHRjb25zdCBwYWRkaW5nID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aCA8IDQgPyAtMjAgOiAxMDtcclxuXHRcdGNvbnN0IHNpemUgPSAoTWF0aC5taW4oYXJjV2lkdGgsIGFyY0hlaWdodCkgLSBwYWRkaW5nKSAvIDI7XHJcblxyXG5cdFx0cmV0dXJuIFtzaXplLCBzaXplXTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVUYXJnZXRzRm9yUmFkYXIodGFyZ2V0cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoaXNFbXB0eShjb25maWcuYXhpc194X2NhdGVnb3JpZXMpKSB7XHJcblx0XHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGdldFJhbmdlKDAsIGdldE1pbk1heChcIm1heFwiLCB0YXJnZXRzLm1hcCh2ID0+IHYudmFsdWVzLmxlbmd0aCkpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5nZW5lcmF0ZVJhZGFyUG9pbnRzKCk7XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkYXJQb3NpdGlvbih0eXBlLCBpbmRleCwgcmFuZ2UsIHJhdGlvKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgW3dpZHRoLCBoZWlnaHRdID0gJCQuZ2V0UmFkYXJTaXplKCk7XHJcblx0XHRjb25zdCBlZGdlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IGlzQ2xvY2t3aXNlID0gY29uZmlnLnJhZGFyX2RpcmVjdGlvbl9jbG9ja3dpc2U7XHJcblxyXG5cdFx0Y29uc3QgcG9zID0gdG9BcnJheSh0eXBlKS5tYXAodiA9PiBnZXRQb3NpdGlvbihcclxuXHRcdFx0aXNDbG9ja3dpc2UsXHJcblx0XHRcdHYsXHJcblx0XHRcdGVkZ2UsXHJcblx0XHRcdGluZGV4LFxyXG5cdFx0XHRpc0RlZmluZWQocmFuZ2UpID8gcmFuZ2UgOiAodHlwZSA9PT0gXCJ4XCIgPyB3aWR0aCA6IGhlaWdodCksXHJcblx0XHRcdGlzTnVtYmVyKHJhdGlvKSA/IHJhdGlvIDogY29uZmlnLnJhZGFyX3NpemVfcmF0aW9cclxuXHRcdCkpO1xyXG5cclxuXHRcdHJldHVybiBwb3MubGVuZ3RoID09PSAxID8gcG9zWzBdIDogcG9zO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGRhdGEgcG9pbnRzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZW5lcmF0ZVJhZGFyUG9pbnRzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLmRhdGEudGFyZ2V0cztcclxuXHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IHBvaW50cyA9ICQkLmNhY2hlLmdldChjYWNoZUtleSkgfHwge307XHJcblx0XHRjb25zdCBzaXplID0gcG9pbnRzLl9zaXplO1xyXG5cclxuXHRcdC8vIHJlY2FsY3VsYXRlIHBvc2l0aW9uIG9ubHkgd2hlbiB0aGUgcHJldmlvdXMgZGltZW5zaW9uIGhhcyBiZWVuIGNoYW5nZWRcclxuXHRcdGlmICghc2l6ZSB8fCAoc2l6ZS53aWR0aCAhPT0gd2lkdGggJiYgc2l6ZS5oZWlnaHQgIT09IGhlaWdodCkpIHtcclxuXHRcdFx0dGFyZ2V0cy5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRcdHBvaW50c1tkLmlkXSA9IGQudmFsdWVzLm1hcCgodiwgaSkgPT4gKFxyXG5cdFx0XHRcdFx0JCQuZ2V0UmFkYXJQb3NpdGlvbihbXCJ4XCIsIFwieVwiXSwgaSwgdW5kZWZpbmVkLCAkJC5nZXRSYXRpbyhcInJhZGFyXCIsIHYpKVxyXG5cdFx0XHRcdCkpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHBvaW50cy5fc2l6ZSA9IHt3aWR0aCwgaGVpZ2h0fTtcclxuXHRcdFx0JCQuY2FjaGUuYWRkKGNhY2hlS2V5LCBwb2ludHMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlZHJhd1JhZGFyKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHRcdGNvbnN0IHRyYW5zbGF0ZSA9ICQkLmdldFRyYW5zbGF0ZShcInJhZGFyXCIpO1xyXG5cclxuXHRcdC8vIEFkanVzdCByYWRhciwgY2lyY2xlcyBhbmQgdGV4dHMnIHBvc2l0aW9uXHJcblx0XHRpZiAodHJhbnNsYXRlKSB7XHJcblx0XHRcdCQkLnJhZGFycy5hdHRyKFwidHJhbnNmb3JtXCIsIHRyYW5zbGF0ZSk7XHJcblx0XHRcdG1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5jaXJjbGVzfWApLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNsYXRlKTtcclxuXHRcdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0VGV4dHN9YCkuYXR0cihcInRyYW5zZm9ybVwiLCB0cmFuc2xhdGUpO1xyXG5cclxuXHRcdFx0JCQuZ2VuZXJhdGVSYWRhclBvaW50cygpO1xyXG5cdFx0XHQkJC51cGRhdGVSYWRhckxldmVsKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVJhZGFyQXhlcygpO1xyXG5cdFx0XHQkJC51cGRhdGVSYWRhclNoYXBlKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdlbmVyYXRlR2V0UmFkYXJQb2ludHMoKSB7XHJcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLmNhY2hlLmdldChjYWNoZUtleSk7XHJcblxyXG5cdFx0cmV0dXJuIChkLCBpKSA9PiB7XHJcblx0XHRcdGNvbnN0IHBvaW50ID0gcG9pbnRzW2QuaWRdW2ldO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludCxcclxuXHRcdFx0XHRwb2ludFxyXG5cdFx0XHRdO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHR1cGRhdGVSYWRhckxldmVsKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9ICQkLmdldFJhZGFyU2l6ZSgpO1xyXG5cdFx0Y29uc3QgZGVwdGggPSBjb25maWcucmFkYXJfbGV2ZWxfZGVwdGg7XHJcblx0XHRjb25zdCBlZGdlID0gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzLmxlbmd0aDtcclxuXHRcdGNvbnN0IHNob3dUZXh0ID0gY29uZmlnLnJhZGFyX2xldmVsX3RleHRfc2hvdztcclxuXHJcblx0XHRjb25zdCByYWRhckxldmVscyA9ICQkLnJhZGFycy5sZXZlbHM7XHJcblx0XHRjb25zdCBsZXZlbERhdGEgPSBnZXRSYW5nZSgwLCBkZXB0aCk7XHJcblxyXG5cdFx0Y29uc3QgcmFkaXVzID0gY29uZmlnLnJhZGFyX3NpemVfcmF0aW8gKiBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KTtcclxuXHRcdGNvbnN0IGxldmVsUmF0aW8gPSBsZXZlbERhdGEubWFwKGwgPT4gcmFkaXVzICogKChsICsgMSkgLyBkZXB0aCkpO1xyXG5cdFx0Y29uc3QgbGV2ZWxUZXh0Rm9ybWF0ID0gY29uZmlnLnJhZGFyX2xldmVsX3RleHRfZm9ybWF0O1xyXG5cclxuXHRcdC8vIEdlbmVyYXRlIHBvaW50c1xyXG5cdFx0Y29uc3QgcG9pbnRzID0gbGV2ZWxEYXRhLm1hcCh2ID0+IHtcclxuXHRcdFx0Y29uc3QgcmFuZ2UgPSBsZXZlbFJhdGlvW3ZdO1xyXG5cdFx0XHRjb25zdCBwb3MgPSBnZXRSYW5nZSgwLCBlZGdlKS5tYXAoaSA9PiAoXHJcblx0XHRcdFx0JCQuZ2V0UmFkYXJQb3NpdGlvbihbXCJ4XCIsIFwieVwiXSwgaSwgcmFuZ2UsIDEpKS5qb2luKFwiLFwiKVxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0cmV0dXJuIHBvcy5qb2luKFwiIFwiKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnN0IGxldmVsID0gcmFkYXJMZXZlbHNcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1MubGV2ZWx9YClcclxuXHRcdFx0LmRhdGEobGV2ZWxEYXRhKTtcclxuXHJcblx0XHRsZXZlbC5leGl0KCkucmVtb3ZlKCk7XHJcblxyXG5cdFx0Y29uc3QgbGV2ZWxFbnRlciA9IGxldmVsLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxyXG5cdFx0XHQuYXR0cihcImNsYXNzXCIsIChkLCBpKSA9PiBgJHtDTEFTUy5sZXZlbH0gJHtDTEFTUy5sZXZlbH0tJHtpfWApO1xyXG5cclxuXHRcdGxldmVsRW50ZXIuYXBwZW5kKFwicG9seWdvblwiKVxyXG5cdFx0XHQuc3R5bGUoXCJ2aXNpYmlsaXR5XCIsIGNvbmZpZy5yYWRhcl9sZXZlbF9zaG93ID8gbnVsbCA6IFwiaGlkZGVuXCIpO1xyXG5cclxuXHRcdGlmIChzaG93VGV4dCkge1xyXG5cdFx0XHRpZiAocmFkYXJMZXZlbHMuc2VsZWN0KFwidGV4dFwiKS5lbXB0eSgpKSB7XHJcblx0XHRcdFx0cmFkYXJMZXZlbHNcclxuXHRcdFx0XHRcdC5hcHBlbmQoXCJ0ZXh0XCIpXHJcblx0XHRcdFx0XHQuYXR0cihcImR4XCIsIFwiLS41ZW1cIilcclxuXHRcdFx0XHRcdC5hdHRyKFwiZHlcIiwgXCItLjdlbVwiKVxyXG5cdFx0XHRcdFx0LnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJlbmRcIilcclxuXHRcdFx0XHRcdC50ZXh0KCgpID0+IGxldmVsVGV4dEZvcm1hdCgwKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxldmVsRW50ZXIuYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiZHhcIiwgXCItLjVlbVwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXHJcblx0XHRcdFx0LnRleHQoZCA9PiBsZXZlbFRleHRGb3JtYXQoXHJcblx0XHRcdFx0XHQkJC5tYXhWYWx1ZSAvIGxldmVsRGF0YS5sZW5ndGggKiAoZCArIDEpXHJcblx0XHRcdFx0KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0bGV2ZWxFbnRlclxyXG5cdFx0XHQubWVyZ2UobGV2ZWwpXHJcblx0XHRcdC5hdHRyKFwidHJhbnNmb3JtXCIsIGQgPT4gYHRyYW5zbGF0ZSgke3dpZHRoIC0gbGV2ZWxSYXRpb1tkXX0sICR7aGVpZ2h0IC0gbGV2ZWxSYXRpb1tkXX0pYClcclxuXHRcdFx0LnNlbGVjdEFsbChcInBvbHlnb25cIilcclxuXHRcdFx0LmF0dHIoXCJwb2ludHNcIiwgZCA9PiBwb2ludHNbZF0pO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBsZXZlbCB0ZXh0IHBvc2l0aW9uXHJcblx0XHRpZiAoc2hvd1RleHQpIHtcclxuXHRcdFx0cmFkYXJMZXZlbHMuc2VsZWN0QWxsKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwieFwiLCBkID0+IChpc1VuZGVmaW5lZChkKSA/IHdpZHRoIDogcG9pbnRzW2RdLnNwbGl0KFwiLFwiKVswXSkpXHJcblx0XHRcdFx0LmF0dHIoXCJ5XCIsIGQgPT4gKGlzVW5kZWZpbmVkKGQpID8gaGVpZ2h0IDogMCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZVJhZGFyQXhlcygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRjb25zdCBbd2lkdGgsIGhlaWdodF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHRcdGNvbnN0IGNhdGVnb3JpZXMgPSBjb25maWcuYXhpc194X2NhdGVnb3JpZXM7XHJcblxyXG5cdFx0bGV0IGF4aXMgPSAkJC5yYWRhcnMuYXhlcy5zZWxlY3RBbGwoXCJnXCIpXHJcblx0XHRcdC5kYXRhKGNhdGVnb3JpZXMpO1xyXG5cclxuXHRcdGF4aXMuZXhpdCgpLnJlbW92ZSgpO1xyXG5cclxuXHRcdGNvbnN0IGF4aXNFbnRlciA9IGF4aXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgKGQsIGkpID0+IGAke0NMQVNTLmF4aXN9LSR7aX1gKTtcclxuXHJcblx0XHRjb25maWcucmFkYXJfYXhpc19saW5lX3Nob3cgJiYgYXhpc0VudGVyLmFwcGVuZChcImxpbmVcIik7XHJcblx0XHRjb25maWcucmFkYXJfYXhpc190ZXh0X3Nob3cgJiYgYXhpc0VudGVyLmFwcGVuZChcInRleHRcIik7XHJcblxyXG5cdFx0YXhpcyA9IGF4aXNFbnRlci5tZXJnZShheGlzKTtcclxuXHJcblx0XHQvLyBheGlzIGxpbmVcclxuXHRcdGlmIChjb25maWcucmFkYXJfYXhpc19saW5lX3Nob3cpIHtcclxuXHRcdFx0YXhpcy5zZWxlY3QoXCJsaW5lXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJ4MVwiLCB3aWR0aClcclxuXHRcdFx0XHQuYXR0cihcInkxXCIsIGhlaWdodClcclxuXHRcdFx0XHQuYXR0cihcIngyXCIsIChkLCBpKSA9PiAkJC5nZXRSYWRhclBvc2l0aW9uKFwieFwiLCBpKSlcclxuXHRcdFx0XHQuYXR0cihcInkyXCIsIChkLCBpKSA9PiAkJC5nZXRSYWRhclBvc2l0aW9uKFwieVwiLCBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYXhpcyB0ZXh0XHJcblx0XHRpZiAoY29uZmlnLnJhZGFyX2F4aXNfdGV4dF9zaG93KSB7XHJcblx0XHRcdGNvbnN0IHt4ID0gMCwgeSA9IDB9ID0gY29uZmlnLnJhZGFyX2F4aXNfdGV4dF9wb3NpdGlvbjtcclxuXHJcblx0XHRcdGF4aXMuc2VsZWN0KFwidGV4dFwiKVxyXG5cdFx0XHRcdC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpXHJcblx0XHRcdFx0LmF0dHIoXCJkeVwiLCBcIi41ZW1cIilcclxuXHRcdFx0XHQuY2FsbChzZWxlY3Rpb24gPT4ge1xyXG5cdFx0XHRcdFx0c2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZCkge1xyXG5cdFx0XHRcdFx0XHRzZXRUZXh0VmFsdWUoZDNTZWxlY3QodGhpcyksIFN0cmluZyhkKSwgWy0wLjYsIDEuMl0pO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQuZGF0dW0oKGQsIGkpID0+ICh7aW5kZXg6IGl9KSlcclxuXHRcdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7XHJcblx0XHRcdFx0XHRpZiAoaXNVbmRlZmluZWQodGhpcy53aWR0aCkpIHtcclxuXHRcdFx0XHRcdFx0Ly8gY2FjaGUgZXZhbHVhdGVkIGF4aXMgdGV4dCB3aWR0aFxyXG5cdFx0XHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAvIDI7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bGV0IHBvc1ggPSAkJC5nZXRSYWRhclBvc2l0aW9uKFwieFwiLCBkLmluZGV4LCB1bmRlZmluZWQsIDEpO1xyXG5cdFx0XHRcdFx0bGV0IHBvc1kgPSBNYXRoLnJvdW5kKCQkLmdldFJhZGFyUG9zaXRpb24oXCJ5XCIsIGQuaW5kZXgsIHVuZGVmaW5lZCwgMSkpO1xyXG5cclxuXHRcdFx0XHRcdGlmIChwb3NYID4gd2lkdGgpIHtcclxuXHRcdFx0XHRcdFx0cG9zWCArPSB0aGlzLndpZHRoICsgeDtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoTWF0aC5yb3VuZChwb3NYKSA8IHdpZHRoKSB7XHJcblx0XHRcdFx0XHRcdHBvc1ggLT0gdGhpcy53aWR0aCArIHg7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKHBvc1kgPiBoZWlnaHQpIHtcclxuXHRcdFx0XHRcdFx0Ly8gdXBkYXRlIHZlcnRpY2FsIGNlbnRlcmVkIGVkZ2UgYXhpcyB0ZXh0IGR5IHBvc2l0aW9uXHJcblx0XHRcdFx0XHRcdGlmIChwb3NZIC8gMiA9PT0gaGVpZ2h0ICYmIHRoaXMuZmlyc3RDaGlsZC50YWdOYW1lID09PSBcInRzcGFuXCIpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFwiZHlcIiwgXCIwZW1cIik7XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdHBvc1kgKz0geTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAocG9zWSA8IGhlaWdodCkge1xyXG5cdFx0XHRcdFx0XHRwb3NZIC09IHk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGB0cmFuc2xhdGUoJHtwb3NYfSAke3Bvc1l9KWA7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuYmluZEV2ZW50KCk7XHJcblx0fSxcclxuXHJcblx0YmluZEV2ZW50KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGU6IHtpbnB1dFR5cGUsIHRyYW5zaXRpbmd9LCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCkge1xyXG5cdFx0XHRjb25zdCBpc01vdXNlID0gaW5wdXRUeXBlID09PSBcIm1vdXNlXCI7XHJcblx0XHRcdGNvbnN0IGdldEluZGV4ID0gKCkgPT4ge1xyXG5cdFx0XHRcdGxldCB0YXJnZXQgPSBkM0V2ZW50LnRhcmdldDtcclxuXHJcblx0XHRcdFx0Ly8gaW4gY2FzZSBvZiBtdWx0aWxpbmVkIGF4aXMgdGV4dFxyXG5cdFx0XHRcdGlmICgvdHNwYW4vaS50ZXN0KHRhcmdldC50YWdOYW1lKSkge1xyXG5cdFx0XHRcdFx0dGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb25zdCBkOiBhbnkgPSBkM1NlbGVjdCh0YXJnZXQpLmRhdHVtKCk7XHJcblxyXG5cdFx0XHRcdHJldHVybiBkICYmIE9iamVjdC5rZXlzKGQpLmxlbmd0aCA9PT0gMSA/IGQuaW5kZXggOiB1bmRlZmluZWQ7XHJcblx0XHRcdH07XHJcblx0XHRcdGNvbnN0IGhpZGUgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgaW5kZXggPSBnZXRJbmRleCgpO1xyXG5cdFx0XHRcdGNvbnN0IG5vSW5kZXggPSBpc1VuZGVmaW5lZChpbmRleCk7XHJcblxyXG5cdFx0XHRcdGlmIChpc01vdXNlIHx8IG5vSW5kZXgpIHtcclxuXHRcdFx0XHRcdHRoaXMuaGlkZVRvb2x0aXAoKTtcclxuXHRcdFx0XHRcdHRoaXMudW5leHBhbmRDaXJjbGVzKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKGlzTW91c2UpIHtcclxuXHRcdFx0XHRcdFx0JCQuc2V0T3Zlck91dChmYWxzZSwgaW5kZXgpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChub0luZGV4KSB7XHJcblx0XHRcdFx0XHRcdCQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHQkJC5yYWRhcnMuc2VsZWN0KGAuJHtDTEFTUy5heGlzfWApXHJcblx0XHRcdFx0Lm9uKGlzTW91c2UgPyBcIm1vdXNlb3ZlciBcIiA6IFwidG91Y2hzdGFydFwiLCAoKSA9PiB7XHJcblx0XHRcdFx0XHRpZiAodHJhbnNpdGluZykgeyAvLyBza2lwIHdoaWxlIHRyYW5zaXRpbmdcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gZ2V0SW5kZXgoKTtcclxuXHJcblx0XHRcdFx0XHQkJC5zZWxlY3RSZWN0Rm9yU2luZ2xlKHN2Zy5ub2RlKCksIG51bGwsIGluZGV4KTtcclxuXHRcdFx0XHRcdGlzTW91c2UgPyAkJC5zZXRPdmVyT3V0KHRydWUsIGluZGV4KSA6ICQkLmNhbGxPdmVyT3V0Rm9yVG91Y2goaW5kZXgpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VvdXRcIiwgaXNNb3VzZSA/IGhpZGUgOiBudWxsKTtcclxuXHJcblx0XHRcdGlmICghaXNNb3VzZSkge1xyXG5cdFx0XHRcdHN2Zy5vbihcInRvdWNoc3RhcnRcIiwgaGlkZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVSYWRhclNoYXBlKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHM7XHJcblx0XHRjb25zdCBwb2ludHMgPSAkJC5jYWNoZS5nZXQoY2FjaGVLZXkpO1xyXG5cclxuXHRcdGNvbnN0IGFyZWFzID0gJCQucmFkYXJzLnNoYXBlc1xyXG5cdFx0XHQuc2VsZWN0QWxsKFwicG9seWdvblwiKVxyXG5cdFx0XHQuZGF0YSh0YXJnZXRzKTtcclxuXHJcblx0XHRjb25zdCBhcmVhc0VudGVyID0gYXJlYXMuZW50ZXIoKS5hcHBlbmQoXCJnXCIpXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgJCQuY2xhc3NDaGFydFJhZGFyLmJpbmQoJCQpKTtcclxuXHJcblx0XHRhcmVhcy5leGl0KCkudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbihkdXJhdGlvbkZvckV4aXQpXHJcblx0XHRcdC5yZW1vdmUoKTtcclxuXHJcblx0XHRhcmVhc0VudGVyXHJcblx0XHRcdC5hcHBlbmQoXCJwb2x5Z29uXCIpXHJcblx0XHRcdC5tZXJnZShhcmVhcylcclxuXHRcdFx0LnN0eWxlKFwiZmlsbFwiLCBkID0+ICQkLmNvbG9yKGQpKVxyXG5cdFx0XHQuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiAkJC5jb2xvcihkKSlcclxuXHRcdFx0LmF0dHIoXCJwb2ludHNcIiwgZCA9PiBwb2ludHNbZC5pZF0uam9pbihcIiBcIikpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBkYXRhIHBvaW50IHggY29vcmRpbmF0ZVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkIERhdGEgb2JqZWN0XHJcblx0ICogQHJldHVybiB7TnVtYmVyfVxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0cmFkYXJDaXJjbGVYKGQpIHtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlLmdldChjYWNoZUtleSlbZC5pZF1bZC5pbmRleF1bMF07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgcG9pbnQgeSBjb29yZGluYXRlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGQgRGF0YSBvYmplY3RcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRyYWRhckNpcmNsZVkoZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGNhY2hlS2V5KVtkLmlkXVtkLmluZGV4XVsxXTtcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtcclxuXHRjdXJ2ZVN0ZXBCZWZvcmUgYXMgZDNDdXJ2ZVN0ZXBCZWZvcmUsXHJcblx0Y3VydmVTdGVwQWZ0ZXIgYXMgZDNDdXJ2ZVN0ZXBBZnRlcixcclxuXHRjdXJ2ZUJhc2lzQ2xvc2VkIGFzIGQzQ3VydmVCYXNpc0Nsb3NlZCxcclxuXHRjdXJ2ZUJhc2lzT3BlbiBhcyBkM0N1cnZlQmFzaXNPcGVuLFxyXG5cdGN1cnZlQmFzaXMgYXMgZDNDdXJ2ZUJhc2lzLFxyXG5cdGN1cnZlQnVuZGxlIGFzIGQzQ3VydmVCdW5kbGUsXHJcblx0Y3VydmVDYXJkaW5hbENsb3NlZCBhcyBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXHJcblx0Y3VydmVDYXJkaW5hbE9wZW4gYXMgZDNDdXJ2ZUNhcmRpbmFsT3BlbixcclxuXHRjdXJ2ZUNhcmRpbmFsIGFzIGQzQ3VydmVDYXJkaW5hbCxcclxuXHRjdXJ2ZUNhdG11bGxSb21DbG9zZWQgYXMgZDNDdXJ2ZUNhdG11bGxSb21DbG9zZWQsXHJcblx0Y3VydmVDYXRtdWxsUm9tT3BlbiBhcyBkM0N1cnZlQ2F0bXVsbFJvbU9wZW4sXHJcblx0Y3VydmVDYXRtdWxsUm9tIGFzIGQzQ3VydmVDYXRtdWxsUm9tLFxyXG5cdGN1cnZlTGluZWFyQ2xvc2VkIGFzIGQzQ3VydmVMaW5lYXJDbG9zZWQsXHJcblx0Y3VydmVMaW5lYXIgYXMgZDNDdXJ2ZUxpbmVhcixcclxuXHRjdXJ2ZU1vbm90b25lWCBhcyBkM0N1cnZlTW9ub3RvbmVYLFxyXG5cdGN1cnZlTW9ub3RvbmVZIGFzIGQzQ3VydmVNb25vdG9uZVksXHJcblx0Y3VydmVOYXR1cmFsIGFzIGQzQ3VydmVOYXR1cmFsLFxyXG5cdGN1cnZlU3RlcCBhcyBkM0N1cnZlU3RlcFxyXG59IGZyb20gXCJkMy1zaGFwZVwiO1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0VW5pcXVlLCBpc09iamVjdFR5cGUsIGlzTnVtYmVyLCBpc1VuZGVmaW5lZCwgbm90RW1wdHl9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdGdldFNoYXBlSW5kaWNlcyh0eXBlRmlsdGVyKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgeHMgPSBjb25maWcuZGF0YV94cztcclxuXHRcdGNvbnN0IGhhc1hzID0gbm90RW1wdHkoeHMpO1xyXG5cdFx0Y29uc3QgaW5kaWNlcyA9IHt9O1xyXG5cdFx0bGV0IGk6IGFueSA9IGhhc1hzID8ge30gOiAwO1xyXG5cclxuXHRcdGlmIChoYXNYcykge1xyXG5cdFx0XHRnZXRVbmlxdWUoT2JqZWN0LmtleXMoeHMpLm1hcCh2ID0+IHhzW3ZdKSlcclxuXHRcdFx0XHQuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGlbdl0gPSAwO1xyXG5cdFx0XHRcdFx0aW5kaWNlc1t2XSA9IHt9O1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLmZpbHRlclRhcmdldHNUb1Nob3coJCQuZGF0YS50YXJnZXRzLmZpbHRlcih0eXBlRmlsdGVyLCAkJCkpXHJcblx0XHRcdC5mb3JFYWNoKGQgPT4ge1xyXG5cdFx0XHRcdGNvbnN0IHhLZXkgPSBkLmlkIGluIHhzID8geHNbZC5pZF0gOiBcIlwiO1xyXG5cdFx0XHRcdGNvbnN0IGluZCA9IHhLZXkgPyBpbmRpY2VzW3hLZXldIDogaW5kaWNlcztcclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaiA9IDAsIGdyb3VwczsgKGdyb3VwcyA9IGNvbmZpZy5kYXRhX2dyb3Vwc1tqXSk7IGorKykge1xyXG5cdFx0XHRcdFx0aWYgKGdyb3Vwcy5pbmRleE9mKGQuaWQpIDwgMCkge1xyXG5cdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBrID0gMCwgcm93OyAocm93ID0gZ3JvdXBzW2tdKTsgaysrKSB7XHJcblx0XHRcdFx0XHRcdGlmIChyb3cgaW4gaW5kKSB7XHJcblx0XHRcdFx0XHRcdFx0aW5kW2QuaWRdID0gaW5kW3Jvd107XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmIChpc1VuZGVmaW5lZChpbmRbZC5pZF0pKSB7XHJcblx0XHRcdFx0XHRpbmRbZC5pZF0gPSB4S2V5ID8gaVt4S2V5XSsrIDogaSsrO1xyXG5cdFx0XHRcdFx0aW5kLl9fbWF4X18gPSAoeEtleSA/IGlbeEtleV0gOiBpKSAtIDE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gaW5kaWNlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgaW5kaWNlcyB2YWx1ZSBiYXNlZCBvbiBkYXRhIElEIHZhbHVlXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGluZGljZXMgSW5kaWNlcyBvYmplY3RcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgRGF0YSBpZCB2YWx1ZVxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gSW5kaWNlcyBvYmplY3RcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEluZGljZXMoaW5kaWNlcywgaWQpIHtcclxuXHRcdGNvbnN0IHhzID0gdGhpcy5jb25maWcuZGF0YV94cztcclxuXHJcblx0XHRyZXR1cm4gbm90RW1wdHkoeHMpID9cclxuXHRcdFx0aW5kaWNlc1t4c1tpZF1dIDogaW5kaWNlcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgaW5kaWNlcyBtYXggbnVtYmVyXHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGluZGljZXMgSW5kaWNlcyBvYmplY3RcclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IE1heCBudW1iZXJcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldEluZGljZXNNYXgoaW5kaWNlcykge1xyXG5cdFx0cmV0dXJuIG5vdEVtcHR5KHRoaXMuY29uZmlnLmRhdGFfeHMpID9cclxuXHRcdFx0Ly8gaWYgaXMgbXVsdGlwbGUgeHMsIHJldHVybiB0b3RhbCBzdW0gb2YgeHMnIF9fbWF4X18gdmFsdWVcclxuXHRcdFx0T2JqZWN0LmtleXMoaW5kaWNlcylcclxuXHRcdFx0XHQubWFwKHYgPT4gaW5kaWNlc1t2XS5fX21heF9fIHx8IDApXHJcblx0XHRcdFx0LnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgKyBjdXJyKSA6IGluZGljZXMuX19tYXhfXztcclxuXHR9LFxyXG5cclxuXHRnZXRTaGFwZVgob2Zmc2V0LCBpbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc2NhbGV9ID0gJCQ7XHJcblx0XHRjb25zdCBjdXJyU2NhbGUgPSBpc1N1YiA/IHNjYWxlLnN1YlggOiAoc2NhbGUuem9vbSB8fCBzY2FsZS54KTtcclxuXHRcdGNvbnN0IGJhclBhZGRpbmcgPSBjb25maWcuYmFyX3BhZGRpbmc7XHJcblx0XHRjb25zdCBzdW0gPSAocCwgYykgPT4gcCArIGM7XHJcblx0XHRjb25zdCBoYWxmV2lkdGggPSBpc09iamVjdFR5cGUob2Zmc2V0KSAmJiBvZmZzZXQudG90YWwubGVuZ3RoID8gb2Zmc2V0LnRvdGFsLnJlZHVjZShzdW0pIC8gMiA6IDA7XHJcblxyXG5cdFx0cmV0dXJuIGQgPT4ge1xyXG5cdFx0XHRjb25zdCBpbmQgPSAkJC5nZXRJbmRpY2VzKGluZGljZXMsIGQuaWQpO1xyXG5cdFx0XHRjb25zdCBpbmRleCA9IGQuaWQgaW4gaW5kID8gaW5kW2QuaWRdIDogMDtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0c051bSA9IChpbmQuX19tYXhfXyB8fCAwKSArIDE7XHJcblx0XHRcdGxldCB4ID0gMDtcclxuXHJcblx0XHRcdGlmIChub3RFbXB0eShkLngpKSB7XHJcblx0XHRcdFx0Y29uc3QgeFBvcyA9IGN1cnJTY2FsZShkLngpO1xyXG5cclxuXHRcdFx0XHRpZiAoaGFsZldpZHRoKSB7XHJcblx0XHRcdFx0XHR4ID0geFBvcyAtIChvZmZzZXRbZC5pZF0gfHwgb2Zmc2V0LndpZHRoKSArXHJcblx0XHRcdFx0XHRcdG9mZnNldC50b3RhbC5zbGljZSgwLCBpbmRleCArIDEpLnJlZHVjZShzdW0pIC1cclxuXHRcdFx0XHRcdFx0aGFsZldpZHRoO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR4ID0geFBvcyAtIChpc051bWJlcihvZmZzZXQpID8gb2Zmc2V0IDogb2Zmc2V0LndpZHRoKSAqICh0YXJnZXRzTnVtIC8gMiAtIGluZGV4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGFkanVzdCB4IHBvc2l0aW9uIGZvciBiYXIucGFkZGluZyBvcHRpb25xXHJcblx0XHRcdGlmIChvZmZzZXQgJiYgeCAmJiB0YXJnZXRzTnVtID4gMSAmJiBiYXJQYWRkaW5nKSB7XHJcblx0XHRcdFx0aWYgKGluZGV4KSB7XHJcblx0XHRcdFx0XHR4ICs9IGJhclBhZGRpbmcgKiBpbmRleDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICh0YXJnZXRzTnVtID4gMikge1xyXG5cdFx0XHRcdFx0eCAtPSAodGFyZ2V0c051bSAtIDEpICogYmFyUGFkZGluZyAvIDI7XHJcblx0XHRcdFx0fSBlbHNlIGlmICh0YXJnZXRzTnVtID09PSAyKSB7XHJcblx0XHRcdFx0XHR4IC09IGJhclBhZGRpbmcgLyAyO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHg7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGdldFNoYXBlWShpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgaXNTdGFja05vcm1hbGl6ZWQgPSAkJC5pc1N0YWNrTm9ybWFsaXplZCgpO1xyXG5cclxuXHRcdHJldHVybiBkID0+IHtcclxuXHRcdFx0Y29uc3QgdmFsdWUgPSBpc1N0YWNrTm9ybWFsaXplZCA/ICQkLmdldFJhdGlvKFwiaW5kZXhcIiwgZCwgdHJ1ZSkgOiAoXHJcblx0XHRcdFx0JCQuaXNCdWJibGVaVHlwZShkKSA/ICQkLmdldEJ1YmJsZVpEYXRhKGQudmFsdWUsIFwieVwiKSA6IGQudmFsdWVcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHJldHVybiAoaXNTdWIgPyAkJC5nZXRTdWJZU2NhbGUoZC5pZCkgOiAkJC5nZXRZU2NhbGUoZC5pZCkpKHZhbHVlKTtcclxuXHRcdH07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IFNoYXBlJ3Mgb2Zmc2V0IGRhdGFcclxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6IGJvb2xlYW59IHR5cGVGaWx0ZXJcclxuXHQgKiBAcmV0dXJuIHt7c2hhcGVPZmZzZXRUYXJnZXRzOiBTaGFwZU9mZnNldFRhcmdldFtdLCBpbmRleE1hcEJ5VGFyZ2V0SWQ6IG9iamVjdH19XHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRnZXRTaGFwZU9mZnNldERhdGEodHlwZUZpbHRlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3QgdGFyZ2V0cyA9ICQkLm9yZGVyVGFyZ2V0cygkJC5maWx0ZXJUYXJnZXRzVG9TaG93KCQkLmRhdGEudGFyZ2V0cy5maWx0ZXIodHlwZUZpbHRlciwgJCQpKSk7XHJcblx0XHRjb25zdCBzaGFwZU9mZnNldFRhcmdldHMgPSB0YXJnZXRzLm1hcCh0YXJnZXQgPT4ge1xyXG5cdFx0XHRsZXQgcm93VmFsdWVzID0gdGFyZ2V0LnZhbHVlcztcclxuXHJcblx0XHRcdGlmICgkJC5pc1N0ZXBUeXBlKHRhcmdldCkpIHtcclxuXHRcdFx0XHRyb3dWYWx1ZXMgPSAkJC5jb252ZXJ0VmFsdWVzVG9TdGVwKHJvd1ZhbHVlcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y29uc3Qgcm93VmFsdWVNYXBCeVhWYWx1ZSA9IHJvd1ZhbHVlcy5yZWR1Y2UoKG91dCwgdmFsdWUpID0+IHtcclxuXHRcdFx0XHRvdXRbTnVtYmVyKHZhbHVlLngpXSA9IHZhbHVlO1xyXG5cdFx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHRcdH0sIHt9KTtcclxuXHJcblx0XHRcdGxldCB2YWx1ZXM7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNTdGFja05vcm1hbGl6ZWQoKSkge1xyXG5cdFx0XHRcdHZhbHVlcyA9IHJvd1ZhbHVlcy5tYXAodiA9PiAkJC5nZXRSYXRpbyhcImluZGV4XCIsIHYsIHRydWUpKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YWx1ZXMgPSByb3dWYWx1ZXMubWFwKCh7dmFsdWV9KSA9PiB2YWx1ZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0aWQ6IHRhcmdldC5pZCxcclxuXHRcdFx0XHRyb3dWYWx1ZXMsXHJcblx0XHRcdFx0cm93VmFsdWVNYXBCeVhWYWx1ZSxcclxuXHRcdFx0XHR2YWx1ZXMsXHJcblx0XHRcdH07XHJcblx0XHR9KTtcclxuXHRcdGNvbnN0IGluZGV4TWFwQnlUYXJnZXRJZCA9IHRhcmdldHMucmVkdWNlKChvdXQsIHtpZH0sIGluZGV4KSA9PiB7XHJcblx0XHRcdG91dFtpZF0gPSBpbmRleDtcclxuXHRcdFx0cmV0dXJuIG91dDtcclxuXHRcdH0sIHt9KTtcclxuXHJcblx0XHRyZXR1cm4ge2luZGV4TWFwQnlUYXJnZXRJZCwgc2hhcGVPZmZzZXRUYXJnZXRzfTtcclxuXHR9LFxyXG5cclxuXHRnZXRTaGFwZU9mZnNldCh0eXBlRmlsdGVyLCBpbmRpY2VzLCBpc1N1Yikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge3NoYXBlT2Zmc2V0VGFyZ2V0cywgaW5kZXhNYXBCeVRhcmdldElkfSA9ICQkLmdldFNoYXBlT2Zmc2V0RGF0YSh0eXBlRmlsdGVyKTtcclxuXHJcblx0XHRyZXR1cm4gKGQsIGlkeCkgPT4ge1xyXG5cdFx0XHRjb25zdCBpbmQgPSAkJC5nZXRJbmRpY2VzKGluZGljZXMsIGQuaWQpO1xyXG5cdFx0XHRjb25zdCBzY2FsZSA9IGlzU3ViID8gJCQuZ2V0U3ViWVNjYWxlKGQuaWQpIDogJCQuZ2V0WVNjYWxlKGQuaWQpO1xyXG5cdFx0XHRjb25zdCB5MCA9IHNjYWxlKDApO1xyXG5cdFx0XHRjb25zdCBkYXRhWEFzTnVtYmVyID0gTnVtYmVyKGQueCk7XHJcblx0XHRcdGxldCBvZmZzZXQgPSB5MDtcclxuXHJcblx0XHRcdHNoYXBlT2Zmc2V0VGFyZ2V0c1xyXG5cdFx0XHRcdC5mb3JFYWNoKHQgPT4ge1xyXG5cdFx0XHRcdFx0Y29uc3Qgcm93VmFsdWVzID0gdC5yb3dWYWx1ZXM7XHJcblx0XHRcdFx0XHRjb25zdCB2YWx1ZXMgPSB0LnZhbHVlcztcclxuXHJcblx0XHRcdFx0XHRpZiAodC5pZCA9PT0gZC5pZCB8fCBpbmRbdC5pZF0gIT09IGluZFtkLmlkXSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKGluZGV4TWFwQnlUYXJnZXRJZFt0LmlkXSA8IGluZGV4TWFwQnlUYXJnZXRJZFtkLmlkXSkge1xyXG5cdFx0XHRcdFx0XHRsZXQgcm93VmFsdWUgPSByb3dWYWx1ZXNbaWR4XTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGNoZWNrIGlmIHRoZSB4IHZhbHVlcyBsaW5lIHVwXHJcblx0XHRcdFx0XHRcdGlmICghcm93VmFsdWUgfHwgTnVtYmVyKHJvd1ZhbHVlLngpICE9PSBkYXRhWEFzTnVtYmVyKSB7XHJcblx0XHRcdFx0XHRcdFx0cm93VmFsdWUgPSB0LnJvd1ZhbHVlTWFwQnlYVmFsdWVbZGF0YVhBc051bWJlcl07XHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmIChyb3dWYWx1ZSAmJiByb3dWYWx1ZS52YWx1ZSAqIGQudmFsdWUgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSBzY2FsZSh2YWx1ZXNbcm93VmFsdWUuaW5kZXhdKSAtIHkwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRpc1dpdGhpblNoYXBlKHRoYXQsIGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhhdCk7XHJcblx0XHRsZXQgaXNXaXRoaW47XHJcblxyXG5cdFx0aWYgKCEkJC5pc1RhcmdldFRvU2hvdyhkLmlkKSkge1xyXG5cdFx0XHRpc1dpdGhpbiA9IGZhbHNlO1xyXG5cdFx0fSBlbHNlIGlmICgkJC5oYXNWYWxpZFBvaW50VHlwZSh0aGF0Lm5vZGVOYW1lKSkge1xyXG5cdFx0XHRpc1dpdGhpbiA9ICQkLmlzU3RlcFR5cGUoZCkgP1xyXG5cdFx0XHRcdCQkLmlzV2l0aGluU3RlcCh0aGF0LCAkJC5nZXRZU2NhbGUoZC5pZCkoZC52YWx1ZSkpIDpcclxuXHRcdFx0XHQkJC5pc1dpdGhpbkNpcmNsZSh0aGF0LCAkJC5pc0J1YmJsZVR5cGUoZCkgPyAkJC5wb2ludFNlbGVjdFIoZCkgKiAxLjUgOiAwKTtcclxuXHRcdH0gZWxzZSBpZiAodGhhdC5ub2RlTmFtZSA9PT0gXCJwYXRoXCIpIHtcclxuXHRcdFx0aXNXaXRoaW4gPSBzaGFwZS5jbGFzc2VkKENMQVNTLmJhcikgPyAkJC5pc1dpdGhpbkJhcih0aGF0KSA6IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGlzV2l0aGluO1xyXG5cdH0sXHJcblxyXG5cdGdldEludGVycG9sYXRlKGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGludGVycG9sYXRpb24gPSAkJC5nZXRJbnRlcnBvbGF0ZVR5cGUoZCk7XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0XCJiYXNpc1wiOiBkM0N1cnZlQmFzaXMsXHJcblx0XHRcdFwiYmFzaXMtY2xvc2VkXCI6IGQzQ3VydmVCYXNpc0Nsb3NlZCxcclxuXHRcdFx0XCJiYXNpcy1vcGVuXCI6IGQzQ3VydmVCYXNpc09wZW4sXHJcblx0XHRcdFwiYnVuZGxlXCI6IGQzQ3VydmVCdW5kbGUsXHJcblx0XHRcdFwiY2FyZGluYWxcIjogZDNDdXJ2ZUNhcmRpbmFsLFxyXG5cdFx0XHRcImNhcmRpbmFsLWNsb3NlZFwiOiBkM0N1cnZlQ2FyZGluYWxDbG9zZWQsXHJcblx0XHRcdFwiY2FyZGluYWwtb3BlblwiOiBkM0N1cnZlQ2FyZGluYWxPcGVuLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tXCI6IGQzQ3VydmVDYXRtdWxsUm9tLFxyXG5cdFx0XHRcImNhdG11bGwtcm9tLWNsb3NlZFwiOiBkM0N1cnZlQ2F0bXVsbFJvbUNsb3NlZCxcclxuXHRcdFx0XCJjYXRtdWxsLXJvbS1vcGVuXCI6IGQzQ3VydmVDYXRtdWxsUm9tT3BlbixcclxuXHRcdFx0XCJtb25vdG9uZS14XCI6IGQzQ3VydmVNb25vdG9uZVgsXHJcblx0XHRcdFwibW9ub3RvbmUteVwiOiBkM0N1cnZlTW9ub3RvbmVZLFxyXG5cdFx0XHRcIm5hdHVyYWxcIjogZDNDdXJ2ZU5hdHVyYWwsXHJcblx0XHRcdFwibGluZWFyLWNsb3NlZFwiOiBkM0N1cnZlTGluZWFyQ2xvc2VkLFxyXG5cdFx0XHRcImxpbmVhclwiOiBkM0N1cnZlTGluZWFyLFxyXG5cdFx0XHRcInN0ZXBcIjogZDNDdXJ2ZVN0ZXAsXHJcblx0XHRcdFwic3RlcC1hZnRlclwiOiBkM0N1cnZlU3RlcEFmdGVyLFxyXG5cdFx0XHRcInN0ZXAtYmVmb3JlXCI6IGQzQ3VydmVTdGVwQmVmb3JlXHJcblx0XHR9W2ludGVycG9sYXRpb25dO1xyXG5cdH0sXHJcblxyXG5cdGdldEludGVycG9sYXRlVHlwZShkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0Y29uc3QgdHlwZSA9IGNvbmZpZy5zcGxpbmVfaW50ZXJwb2xhdGlvbl90eXBlO1xyXG5cdFx0Y29uc3QgaW50ZXJwb2xhdGlvbiA9ICQkLmlzSW50ZXJwb2xhdGlvblR5cGUodHlwZSkgPyB0eXBlIDogXCJjYXJkaW5hbFwiO1xyXG5cclxuXHRcdHJldHVybiAkJC5pc1NwbGluZVR5cGUoZCkgP1xyXG5cdFx0XHRpbnRlcnBvbGF0aW9uIDogKFxyXG5cdFx0XHRcdCQkLmlzU3RlcFR5cGUoZCkgP1xyXG5cdFx0XHRcdFx0Y29uZmlnLmxpbmVfc3RlcF90eXBlIDogXCJsaW5lYXJcIlxyXG5cdFx0XHQpO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmltcG9ydCB7XHJcblx0dGltZVBhcnNlIGFzIGQzVGltZVBhcnNlLFxyXG5cdHRpbWVGb3JtYXQgYXMgZDNUaW1lRm9ybWF0LFxyXG5cdHV0Y1BhcnNlIGFzIGQzVXRjUGFyc2UsXHJcblx0dXRjRm9ybWF0IGFzIGQzVXRjRm9ybWF0XHJcbn0gZnJvbSBcImQzLXRpbWUtZm9ybWF0XCI7XHJcbmltcG9ydCB7XHJcblx0c2VsZWN0IGFzIGQzU2VsZWN0LFxyXG5cdHNlbGVjdEFsbCBhcyBkM1NlbGVjdEFsbFxyXG59IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHt0cmFuc2l0aW9uIGFzIGQzVHJhbnNpdGlvbn0gZnJvbSBcImQzLXRyYW5zaXRpb25cIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQgU3RvcmUgZnJvbSBcIi4uL2NvbmZpZy9TdG9yZVwiO1xyXG5pbXBvcnQgT3B0aW9ucyBmcm9tIFwiLi4vY29uZmlnL09wdGlvbnMvT3B0aW9uc1wiO1xyXG5pbXBvcnQge2RvY3VtZW50LCB3aW5kb3d9IGZyb20gXCIuLi9tb2R1bGUvYnJvd3NlclwiO1xyXG5pbXBvcnQgQ2FjaGUgZnJvbSBcIi4uL21vZHVsZS9DYWNoZVwiO1xyXG5pbXBvcnQge2V4dGVuZCwgbm90RW1wdHksIGFzSGFsZlBpeGVsLCBnZXRPcHRpb24sIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBpc09iamVjdCwgaXNTdHJpbmcsIGlzVmFsdWUsIGNhbGxGbiwgc29ydFZhbHVlfSBmcm9tIFwiLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8vIEF4aXNcclxuaW1wb3J0IEF4aXMgZnJvbSBcIi4vQXhpcy9BeGlzXCI7XHJcblxyXG4vLyBkYXRhXHJcbmltcG9ydCBkYXRhQ29udmVydCBmcm9tIFwiLi9kYXRhL2RhdGEuY29udmVydFwiO1xyXG5pbXBvcnQgZGF0YSBmcm9tIFwiLi9kYXRhL2RhdGFcIjtcclxuaW1wb3J0IGRhdGFMb2FkIGZyb20gXCIuL2RhdGEvZGF0YS5sb2FkXCI7XHJcblxyXG4vLyBpbnRlcmFjdGlvbnNcclxuaW1wb3J0IGRyYWcgZnJvbSBcIi4vaW50ZXJhY3Rpb25zL2RyYWdcIjtcclxuaW1wb3J0IGZsb3cgZnJvbSBcIi4vaW50ZXJhY3Rpb25zL2Zsb3dcIjtcclxuaW1wb3J0IGludGVyYWN0aW9uIGZyb20gXCIuL2ludGVyYWN0aW9ucy9pbnRlcmFjdGlvblwiO1xyXG5pbXBvcnQgc3ViY2hhcnQgZnJvbSBcIi4vaW50ZXJhY3Rpb25zL3N1YmNoYXJ0XCI7XHJcbmltcG9ydCB6b29tIGZyb20gXCIuL2ludGVyYWN0aW9ucy96b29tXCI7XHJcblxyXG4vLyBpbnRlcm5hbHNcclxuaW1wb3J0IGNhdGVnb3J5IGZyb20gXCIuL2ludGVybmFscy9jYXRlZ29yeVwiO1xyXG5pbXBvcnQgY2xhc3NNb2R1bGUgZnJvbSBcIi4vaW50ZXJuYWxzL2NsYXNzXCI7XHJcbmltcG9ydCBjbGlwIGZyb20gXCIuL2ludGVybmFscy9jbGlwXCI7XHJcbmltcG9ydCBjb2xvciBmcm9tIFwiLi9pbnRlcm5hbHMvY29sb3JcIjtcclxuaW1wb3J0IGRvbWFpbiBmcm9tIFwiLi9pbnRlcm5hbHMvZG9tYWluXCI7XHJcbmltcG9ydCBmb3JtYXQgZnJvbSBcIi4vaW50ZXJuYWxzL2Zvcm1hdFwiO1xyXG5pbXBvcnQgZ3JpZCBmcm9tIFwiLi9pbnRlcm5hbHMvZ3JpZFwiO1xyXG5pbXBvcnQgbGVnZW5kIGZyb20gXCIuL2ludGVybmFscy9sZWdlbmRcIjtcclxuaW1wb3J0IHJlZ2lvbiBmcm9tIFwiLi9pbnRlcm5hbHMvcmVnaW9uXCI7XHJcbmltcG9ydCBzY2FsZSBmcm9tIFwiLi9pbnRlcm5hbHMvc2NhbGVcIjtcclxuaW1wb3J0IHNlbGVjdGlvbiBmcm9tIFwiLi9pbnRlcm5hbHMvc2VsZWN0aW9uXCI7XHJcbmltcG9ydCBzaXplIGZyb20gXCIuL2ludGVybmFscy9zaXplXCI7XHJcbmltcG9ydCB0ZXh0IGZyb20gXCIuL2ludGVybmFscy90ZXh0XCI7XHJcbmltcG9ydCB0aXRsZSBmcm9tIFwiLi9pbnRlcm5hbHMvdGl0bGVcIjtcclxuaW1wb3J0IHRvb2x0aXAgZnJvbSBcIi4vaW50ZXJuYWxzL3Rvb2x0aXBcIjtcclxuaW1wb3J0IHR5cGUgZnJvbSBcIi4vaW50ZXJuYWxzL3R5cGVcIjtcclxuXHJcbi8vIHNoYXBlXHJcbmltcG9ydCBhcmMgZnJvbSBcIi4vc2hhcGUvYXJjXCI7XHJcbmltcG9ydCBiYXIgZnJvbSBcIi4vc2hhcGUvYmFyXCI7XHJcbmltcG9ydCBidWJibGUgZnJvbSBcIi4vc2hhcGUvYnViYmxlXCI7XHJcbmltcG9ydCBsaW5lIGZyb20gXCIuL3NoYXBlL2xpbmVcIjtcclxuaW1wb3J0IHBvaW50IGZyb20gXCIuL3NoYXBlL3BvaW50XCI7XHJcbmltcG9ydCByYWRhciBmcm9tIFwiLi9zaGFwZS9yYWRhclwiO1xyXG5pbXBvcnQgc2hhcGUgZnJvbSBcIi4vc2hhcGUvc2hhcGVcIjtcclxuXHJcbi8qKlxyXG4gKiBJbnRlcm5hbCBjaGFydCBjbGFzcy5cclxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgaW50ZXJuYWxseSwgbm90IGV4cG9zZWQgZm9yIHB1YmxpYy5cclxuICogQGNsYXNzIENoYXJ0SW50ZXJuYWxcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ2hhcnRJbnRlcm5hbCB7XHJcblx0cHVibGljIGFwaTtcdCAgIC8vIEFQSSBpbnRlcmZhY2VcclxuXHRwdWJsaWMgY29uZmlnOyAvLyBjb25maWcgb2JqZWN0XHJcblx0cHVibGljIGNhY2hlOyAgLy8gY2FjaGUgaW5zdGFuY2VcclxuXHRwdWJsaWMgc3RhdGU7ICAvLyBzdGF0ZSB2YXJpYWJsZXNcclxuXHRwdWJsaWMgY2hhcnRzOyAvLyBhbGwgQ2hhcnQgaW5zdGFuY2VzIGFycmF5IHdpdGhpbiBwYWdlIChlcXVpdmFsZW50IG9mICdiYi5pbnN0YW5jZXMnKVxyXG5cclxuXHQvLyBkYXRhIG9iamVjdFxyXG5cdHB1YmxpYyBkYXRhID0ge1xyXG5cdFx0eHM6IHt9LFxyXG5cdFx0dGFyZ2V0czogW11cclxuXHR9O1xyXG5cclxuXHQvLyBzZWxlY3Rpb25zXHJcblx0cHVibGljICRlbCA9IHtcclxuXHRcdGNoYXJ0OiBudWxsLCAvLyRlbC5jaGFydCxcclxuXHRcdG1haW46IG51bGwsXHJcblx0XHRzdmc6IG51bGwsXHJcblx0XHRheGlzOiB7ICAvLyBheGVzXHJcblx0XHRcdHg6IG51bGwsXHJcblx0XHRcdHk6IG51bGwsXHJcblx0XHRcdHkyOiBudWxsLFxyXG5cdFx0XHRzdWJYOiBkM1NlbGVjdEFsbChbXSlcclxuXHRcdH0sXHJcblx0XHRkZWZzOiBudWxsLFxyXG5cdFx0dG9vbHRpcDogbnVsbCxcclxuXHRcdGxlZ2VuZDogbnVsbCxcclxuXHRcdHRpdGxlOiBudWxsLFxyXG5cclxuXHRcdGFyY3M6IG51bGwsXHJcblx0XHRiYXI6IGQzU2VsZWN0QWxsKFtdKSwgLy9tYWluQmFyLFxyXG5cdFx0bGluZTogZDNTZWxlY3RBbGwoW10pLCAvL21haW5MaW5lLFxyXG5cdFx0YXJlYTogZDNTZWxlY3RBbGwoW10pLCAvL21haW5BcmVhLFxyXG5cdFx0Y2lyY2xlOiBkM1NlbGVjdEFsbChbXSksIC8vbWFpbkNpcmNsZSxcclxuXHRcdHRleHQ6IGQzU2VsZWN0QWxsKFtdKSwgLy9tYWluVGV4dCxcclxuXHRcdGdyaWQ6IHtcclxuXHRcdFx0bWFpbjogZDNTZWxlY3RBbGwoW10pLCAgLy9ncmlkXHJcblx0XHRcdHg6IGQzU2VsZWN0QWxsKFtdKSwgLy94Z3JpZCxcclxuXHRcdFx0eTogZDNTZWxlY3RBbGwoW10pLCAvL3lncmlkLFxyXG5cdFx0XHR4TGluZXM6IGQzU2VsZWN0QWxsKFtdKSwgLy94Z3JpZExpbmVzLFxyXG5cdFx0XHR5TGluZXM6IGQzU2VsZWN0QWxsKFtdKSwgLy95Z3JpZExpbmVzLFxyXG5cdFx0fSxcclxuXHRcdHJlZ2lvbjoge1xyXG5cdFx0XHRtYWluOiBkM1NlbGVjdEFsbChbXSksIC8vcmVnaW9uXHJcblx0XHRcdGxpc3Q6IG51bGwgLy8gbWFpblJlZ2lvblxyXG5cdFx0fSxcclxuXHRcdGV2ZW50UmVjdDogbnVsbFxyXG5cdH07XHJcblxyXG5cdC8vIEF4aXNcclxuXHRwdWJsaWMgYXhpczsgLy8gQXhpc1xyXG5cclxuXHQvLyBzY2FsZXNcclxuXHRwdWJsaWMgc2NhbGUgPSB7XHJcblx0XHR4OiBudWxsLFxyXG5cdFx0eTogbnVsbCxcclxuXHRcdHkyOiBudWxsLFxyXG5cdFx0c3ViWDogbnVsbCxcclxuXHRcdHN1Ylk6IG51bGwsXHJcblx0XHRzdWJZMjogbnVsbCxcclxuXHRcdHpvb206IG51bGxcclxuXHR9XHJcblxyXG5cdC8vIG9yaWdpbmFsIHZhbHVlc1xyXG5cdHB1YmxpYyBvcmcgPSB7XHJcblx0XHR4U2NhbGU6IG51bGwsXHJcblx0XHR4RG9tYWluOiBudWxsXHJcblx0fTtcclxuXHJcblx0Ly8gZm9ybWF0dGVyIGZ1bmN0aW9uXHJcblx0cHVibGljIGNvbG9yO1xyXG5cdHB1YmxpYyBwYXR0ZXJucztcclxuXHRwdWJsaWMgbGV2ZWxDb2xvcjtcclxuXHRwdWJsaWMgcG9pbnQ7XHJcblxyXG5cdC8vIGZvcm1hdCBmdW5jdGlvblxyXG5cdHB1YmxpYyBmb3JtYXQgPSB7XHJcblx0XHRleHRyYUxpbmVDbGFzc2VzOiBudWxsLFxyXG5cdFx0eEF4aXNUaWNrOiBudWxsLFxyXG5cdFx0ZGF0YVRpbWU6IG51bGwsIC8vIGRhdGFUaW1lRm9ybWF0XHJcblx0XHRkZWZhdWx0QXhpc1RpbWU6ICgpID0+IHt9LCAvLyBkZWZhdWx0QXhpc1RpbWVGb3JtYXRcclxuXHRcdGF4aXNUaW1lOiAoKSA9PiB7fSAvLyBheGlzVGltZUZvcm1hdFxyXG5cdH07XHJcblxyXG5cdGNvbnN0cnVjdG9yKGFwaSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLmFwaSA9IGFwaTtcclxuXHRcdCQkLmNvbmZpZyA9IG5ldyBPcHRpb25zKCk7XHJcblx0XHQkJC5jYWNoZSA9IG5ldyBDYWNoZSgpO1xyXG5cdFx0JCQuc3RhdGUgPSBuZXcgU3RvcmUoKTsgLy8gc3RhdHVzIHZhcmlhYmxlc1xyXG5cdH1cclxuXHJcblx0YmVmb3JlSW5pdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRiZWZvcmVJbml0XCIpO1xyXG5cclxuXHRcdC8vIGNhbiBkbyBzb21ldGhpbmdcclxuXHRcdGNhbGxGbigkJC5jb25maWcub25iZWZvcmVpbml0LCAkJCwgJCQuYXBpKTtcclxuXHR9XHJcblxyXG5cdGFmdGVySW5pdCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHQkJC5jYWxsUGx1Z2luSG9vayhcIiRhZnRlckluaXRcIik7XHJcblxyXG5cdFx0Ly8gY2FuIGRvIHNvbWV0aGluZ1xyXG5cdFx0Y2FsbEZuKCQkLmNvbmZpZy5vbmFmdGVyaW5pdCwgJCQsICQkLmFwaSk7XHJcblx0fVxyXG5cclxuXHRpbml0KCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLmluaXRQYXJhbXMoKTtcclxuXHJcblx0XHRjb25zdCBiaW5kdG8gPSB7XHJcblx0XHRcdGVsZW1lbnQ6IGNvbmZpZy5iaW5kdG8sXHJcblx0XHRcdGNsYXNzbmFtZTogXCJiYlwiXHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChpc09iamVjdChjb25maWcuYmluZHRvKSkge1xyXG5cdFx0XHRiaW5kdG8uZWxlbWVudCA9IGNvbmZpZy5iaW5kdG8uZWxlbWVudCB8fCBcIiNjaGFydFwiO1xyXG5cdFx0XHRiaW5kdG8uY2xhc3NuYW1lID0gY29uZmlnLmJpbmR0by5jbGFzc25hbWUgfHwgYmluZHRvLmNsYXNzbmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZWxlY3QgYmluZCBlbGVtZW50XHJcblx0XHQkZWwuY2hhcnQgPSBpc0Z1bmN0aW9uKGJpbmR0by5lbGVtZW50Lm5vZGUpID9cclxuXHRcdFx0Y29uZmlnLmJpbmR0by5lbGVtZW50IDogZDNTZWxlY3QoYmluZHRvLmVsZW1lbnQgfHwgW10pO1xyXG5cclxuXHRcdGlmICgkZWwuY2hhcnQuZW1wdHkoKSkge1xyXG5cdFx0XHQkZWwuY2hhcnQgPSBkM1NlbGVjdChkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpKTtcclxuXHRcdH1cclxuXHJcblx0XHQkZWwuY2hhcnQuaHRtbChcIlwiKS5jbGFzc2VkKGJpbmR0by5jbGFzc25hbWUsIHRydWUpO1xyXG5cdFx0JCQuaW5pdFRvUmVuZGVyKCk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbml0aWFsaXplIHRoZSByZW5kZXJpbmcgcHJvY2Vzc1xyXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2VkIEZvcmNlIHRvIHJlbmRlciBwcm9jZXNzXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRpbml0VG9SZW5kZXIoZm9yY2VkPzogYm9vbGVhbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge2NoYXJ0fX0gPSAkJFxyXG5cdFx0Y29uc3QgaXNIaWRkZW4gPSAoKSA9PiBjaGFydC5zdHlsZShcImRpc3BsYXlcIikgPT09IFwibm9uZVwiIHx8IGNoYXJ0LnN0eWxlKFwidmlzaWJpbGl0eVwiKSA9PT0gXCJoaWRkZW5cIjtcclxuXHJcblx0XHRjb25zdCBpc0xhenkgPSBjb25maWcucmVuZGVyLmxhenkgfHwgaXNIaWRkZW4oKTtcclxuXHRcdGNvbnN0IE11dGF0aW9uT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcjtcclxuXHJcblx0XHRpZiAoaXNMYXp5ICYmIE11dGF0aW9uT2JzZXJ2ZXIgJiYgY29uZmlnLnJlbmRlci5vYnNlcnZlICE9PSBmYWxzZSAmJiAhZm9yY2VkKSB7XHJcblx0XHRcdG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbiwgb2JzZXJ2ZXIpID0+IHtcclxuXHRcdFx0XHRpZiAoIWlzSGlkZGVuKCkpIHtcclxuXHRcdFx0XHRcdG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuXHRcdFx0XHRcdCFzdGF0ZS5yZW5kZXJlZCAmJiAkJC5pbml0VG9SZW5kZXIodHJ1ZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KS5vYnNlcnZlKGNoYXJ0Lm5vZGUoKSwge1xyXG5cdFx0XHRcdGF0dHJpYnV0ZXM6IHRydWUsXHJcblx0XHRcdFx0YXR0cmlidXRlRmlsdGVyOiBbXCJjbGFzc1wiLCBcInN0eWxlXCJdXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghaXNMYXp5IHx8IGZvcmNlZCkge1xyXG5cdFx0XHRjb25zdCBjb252ZXJ0ZWREYXRhID0gJCQuY29udmVydERhdGEoY29uZmlnLCAkJC5pbml0V2l0aERhdGEpO1xyXG5cclxuXHRcdFx0Y29udmVydGVkRGF0YSAmJiAkJC5pbml0V2l0aERhdGEoY29udmVydGVkRGF0YSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpbml0UGFyYW1zKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgZm9ybWF0LCBzdGF0ZX0gPSAkJFxyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHJcblx0XHQvLyBkYXRldGltZSB0byBiZSB1c2VkIGZvciB1bmlxdWVuZXNzXHJcblx0XHRzdGF0ZS5kYXRldGltZUlkID0gYGJiLSR7K25ldyBEYXRlKCl9YDtcclxuXHRcdCQkLmluaXRDbGlwKCk7XHJcblxyXG5cdFx0JCQuY29sb3IgPSAkJC5nZW5lcmF0ZUNvbG9yKCk7XHJcblx0XHQkJC5sZXZlbENvbG9yID0gJCQuZ2VuZXJhdGVMZXZlbENvbG9yKCk7XHJcblx0XHQkJC5wb2ludCA9ICQkLmdlbmVyYXRlUG9pbnQoKTtcclxuXHJcblx0XHRmb3JtYXQuZXh0cmFMaW5lQ2xhc3NlcyA9ICQkLmdlbmVyYXRlRXh0cmFMaW5lQ2xhc3MoKTtcclxuXHRcdGZvcm1hdC5kYXRhVGltZSA9IGNvbmZpZy5kYXRhX3hMb2NhbHRpbWUgPyBkM1RpbWVQYXJzZSA6IGQzVXRjUGFyc2U7XHJcblx0XHRmb3JtYXQuYXhpc1RpbWUgPSBjb25maWcuYXhpc194X2xvY2FsdGltZSA/IGQzVGltZUZvcm1hdCA6IGQzVXRjRm9ybWF0O1xyXG5cclxuXHRcdGNvbnN0IGlzRHJhZ1pvb20gPSAkJC5jb25maWcuem9vbV9lbmFibGVkICYmICQkLmNvbmZpZy56b29tX2VuYWJsZWQudHlwZSA9PT0gXCJkcmFnXCI7XHJcblxyXG5cdFx0Zm9ybWF0LmRlZmF1bHRBeGlzVGltZSA9IGQgPT4ge1xyXG5cdFx0XHRjb25zdCB7eCwgem9vbX0gPSAkJC5zY2FsZTtcclxuXHRcdFx0Y29uc3QgaXNab29tZWQgPSBpc0RyYWdab29tID8gem9vbSA6XHJcblx0XHRcdFx0em9vbSAmJiB4Lm9yZ0RvbWFpbigpLnRvU3RyaW5nKCkgIT09IHpvb20uZG9tYWluKCkudG9TdHJpbmcoKTtcclxuXHJcblx0XHRcdGNvbnN0IHNwZWNpZmllciA9IChkLmdldE1pbGxpc2Vjb25kcygpICYmIFwiLiVMXCIpIHx8XHJcblx0XHRcdFx0KGQuZ2V0U2Vjb25kcygpICYmIFwiLjolU1wiKSB8fFxyXG5cdFx0XHRcdChkLmdldE1pbnV0ZXMoKSAmJiBcIiVJOiVNXCIpIHx8XHJcblx0XHRcdFx0KGQuZ2V0SG91cnMoKSAmJiBcIiVJICVwXCIpIHx8XHJcblx0XHRcdFx0KGQuZ2V0RGF0ZSgpICE9PSAxICYmIFwiJWIgJWRcIikgfHxcclxuXHRcdFx0XHQoaXNab29tZWQgJiYgZC5nZXREYXRlKCkgPT09IDEgJiYgXCIlYlxcJyV5XCIpIHx8XHJcblx0XHRcdFx0KGQuZ2V0TW9udGgoKSAmJiBcIiUtbS8lLWRcIikgfHwgXCIlWVwiO1xyXG5cclxuXHRcdFx0cmV0dXJuIGZvcm1hdC5heGlzVGltZShzcGVjaWZpZXIpKGQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRzdGF0ZS5pc0xlZ2VuZFJpZ2h0ID0gY29uZmlnLmxlZ2VuZF9wb3NpdGlvbiA9PT0gXCJyaWdodFwiO1xyXG5cdFx0c3RhdGUuaXNMZWdlbmRJbnNldCA9IGNvbmZpZy5sZWdlbmRfcG9zaXRpb24gPT09IFwiaW5zZXRcIjtcclxuXHJcblx0XHRzdGF0ZS5pc0xlZ2VuZFRvcCA9IGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcInRvcC1sZWZ0XCIgfHxcclxuXHRcdFx0Y29uZmlnLmxlZ2VuZF9pbnNldF9hbmNob3IgPT09IFwidG9wLXJpZ2h0XCI7XHJcblx0XHRzdGF0ZS5pc0xlZ2VuZExlZnQgPSBjb25maWcubGVnZW5kX2luc2V0X2FuY2hvciA9PT0gXCJ0b3AtbGVmdFwiIHx8XHJcblx0XHRcdGNvbmZpZy5sZWdlbmRfaW5zZXRfYW5jaG9yID09PSBcImJvdHRvbS1sZWZ0XCI7XHJcblxyXG5cdFx0c3RhdGUucm90YXRlZFBhZGRpbmdSaWdodCA9IGlzUm90YXRlZCAmJiAhY29uZmlnLmF4aXNfeF9zaG93ID8gMCA6IDMwO1xyXG5cdFx0c3RhdGUuaW5wdXRUeXBlID0gJCQuY29udmVydElucHV0VHlwZSgpO1xyXG5cdH1cclxuXHJcblx0aW5pdFdpdGhEYXRhKGRhdGEpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtcclxuXHRcdFx0Y29uZmlnLCBzdGF0ZSwgJGVsLFxyXG5cdFx0XHRzY2FsZToge1xyXG5cdFx0XHRcdHgsIHksIHkyLCBzdWJYLCBzdWJZLCBzdWJZMlxyXG5cdFx0XHR9LFxyXG5cdFx0XHRvcmdcclxuXHRcdH0gPSAkJDtcclxuXHJcblx0XHQvLyBmb3IgYXJjIHR5cGUsIHNldCBheGVzIHRvIG5vdCBiZSBzaG93blxyXG5cdFx0Ly8gJCQuaGFzQXJjVHlwZSgpICYmIFtcInhcIiwgXCJ5XCIsIFwieTJcIl0uZm9yRWFjaChpZCA9PiAoY29uZmlnW2BheGlzXyR7aWR9X3Nob3dgXSA9IGZhbHNlKSk7XHJcblxyXG5cdFx0JCQuYXhpcyA9IG5ldyBBeGlzKCQkKTtcclxuXHRcdGNvbmZpZy56b29tX2VuYWJsZWQgJiYgJCQuaW5pdFpvb20oKTtcclxuXHJcblx0XHQvLyBJbml0IGRhdGEgYXMgdGFyZ2V0c1xyXG5cdFx0JCQuZGF0YS54cyA9IHt9O1xyXG5cdFx0JCQuZGF0YS50YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5kYXRhX2ZpbHRlcikge1xyXG5cdFx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuZmlsdGVyKGNvbmZpZy5kYXRhX2ZpbHRlcik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IHRhcmdldHMgdG8gaGlkZSBpZiBuZWVkZWRcclxuXHRcdGlmIChjb25maWcuZGF0YV9oaWRlKSB7XHJcblx0XHRcdCQkLmFkZEhpZGRlblRhcmdldElkcyhcclxuXHRcdFx0XHRjb25maWcuZGF0YV9oaWRlID09PSB0cnVlID9cclxuXHRcdFx0XHRcdCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cykgOiBjb25maWcuZGF0YV9oaWRlXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29uZmlnLmxlZ2VuZF9oaWRlKSB7XHJcblx0XHRcdCQkLmFkZEhpZGRlbkxlZ2VuZElkcyhcclxuXHRcdFx0XHRjb25maWcubGVnZW5kX2hpZGUgPT09IHRydWUgP1xyXG5cdFx0XHRcdFx0JCQubWFwVG9JZHMoJCQuZGF0YS50YXJnZXRzKSA6IGNvbmZpZy5sZWdlbmRfaGlkZVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluaXQgc2l6ZXMgYW5kIHNjYWxlc1xyXG5cdFx0JCQudXBkYXRlU2l6ZXMoKTtcclxuXHRcdCQkLnVwZGF0ZVNjYWxlcyh0cnVlKTtcclxuXHJcblx0XHQvLyBTZXQgZG9tYWlucyBmb3IgZWFjaCBzY2FsZVxyXG5cdFx0aWYgKHgpIHtcclxuXHRcdFx0eC5kb21haW4oc29ydFZhbHVlKCQkLmdldFhEb21haW4oJCQuZGF0YS50YXJnZXRzKSkpO1xyXG5cdFx0XHRzdWJYLmRvbWFpbih4LmRvbWFpbigpKTtcclxuXHJcblx0XHRcdC8vIFNhdmUgb3JpZ2luYWwgeCBkb21haW4gZm9yIHpvb20gdXBkYXRlXHJcblx0XHRcdG9yZy54RG9tYWluID0geC5kb21haW4oKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoeSkge1xyXG5cdFx0XHR5LmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5XCIpKTtcclxuXHRcdFx0c3ViWS5kb21haW4oeS5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHkyKSB7XHJcblx0XHRcdHkyLmRvbWFpbigkJC5nZXRZRG9tYWluKCQkLmRhdGEudGFyZ2V0cywgXCJ5MlwiKSk7XHJcblx0XHRcdHN1YlkyICYmIHN1YlkyLmRvbWFpbih5Mi5kb21haW4oKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gLS0gQmFzaWMgRWxlbWVudHMgLS1cclxuXHRcdCRlbC5zdmcgPSAkZWwuY2hhcnQuYXBwZW5kKFwic3ZnXCIpXHJcblx0XHRcdC5zdHlsZShcIm92ZXJmbG93XCIsIFwiaGlkZGVuXCIpXHJcblx0XHRcdC5zdHlsZShcImRpc3BsYXlcIiwgXCJibG9ja1wiKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLmludGVyYWN0aW9uX2VuYWJsZWQgJiYgc3RhdGUuaW5wdXRUeXBlKSB7XHJcblx0XHRcdGNvbnN0IGlzVG91Y2ggPSBzdGF0ZS5pbnB1dFR5cGUgPT09IFwidG91Y2hcIjtcclxuXHJcblx0XHRcdCRlbC5zdmdcclxuXHRcdFx0XHQub24oaXNUb3VjaCA/IFwidG91Y2hzdGFydFwiIDogXCJtb3VzZWVudGVyXCIsICgpID0+IGNhbGxGbihjb25maWcub25vdmVyLCAkJCwgJCQuYXBpKSlcclxuXHRcdFx0XHQub24oaXNUb3VjaCA/IFwidG91Y2hlbmRcIiA6IFwibW91c2VsZWF2ZVwiLCAoKSA9PiBjYWxsRm4oY29uZmlnLm9ub3V0LCAkJCwgJCQuYXBpKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLnN2Z19jbGFzc25hbWUgJiYgJCQuJGVsLnN2Zy5hdHRyKFwiY2xhc3NcIiwgY29uZmlnLnN2Z19jbGFzc25hbWUpO1xyXG5cclxuXHRcdC8vIERlZmluZSBkZWZzXHJcblx0XHQkZWwuZGVmcyA9ICRlbC5zdmcuYXBwZW5kKFwiZGVmc1wiKTtcclxuXHJcblx0XHQkJC5hcHBlbmRDbGlwKCRlbC5kZWZzLCBzdGF0ZS5jbGlwLmlkKTtcclxuXHRcdCQkLmFwcGVuZENsaXAoJGVsLmRlZnMsIHN0YXRlLmNsaXAuaWRYQXhpcyk7XHJcblx0XHQkJC5hcHBlbmRDbGlwKCRlbC5kZWZzLCBzdGF0ZS5jbGlwWUF4aXMpO1xyXG5cdFx0JCQuYXBwZW5kQ2xpcCgkZWwuZGVmcywgc3RhdGUuY2xpcC5pZEdyaWQpO1xyXG5cclxuXHRcdC8vIHNldCBjb2xvciBwYXR0ZXJuc1xyXG5cdFx0aWYgKGlzRnVuY3Rpb24oY29uZmlnLmNvbG9yX3RpbGVzKSAmJiAkJC5wYXR0ZXJucykge1xyXG5cdFx0XHQkJC5wYXR0ZXJucy5mb3JFYWNoKHAgPT4gJGVsLmRlZnMuYXBwZW5kKCgpID0+IHAubm9kZSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgcmVnaW9uc1xyXG5cdFx0Y29uc3QgbWFpbiA9ICRlbC5zdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwidHJhbnNmb3JtXCIsICQkLmdldFRyYW5zbGF0ZShcIm1haW5cIikpO1xyXG5cclxuXHRcdCRlbC5tYWluID0gbWFpbjtcclxuXHJcblx0XHQvLyBpbml0aWFsaXplIHN1YmNoYXJ0IHdoZW4gc3ViY2hhcnQgc2hvdyBvcHRpb24gaXMgc2V0XHJcblx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyAmJiAkJC5pbml0U3ViY2hhcnQoKTtcclxuXHJcblx0XHQkJC5pbml0VG9vbHRpcCAmJiAkJC5pbml0VG9vbHRpcCgpO1xyXG5cdFx0JCQuaW5pdExlZ2VuZCAmJiAkJC5pbml0TGVnZW5kKCk7XHJcblx0XHQkJC5pbml0VGl0bGUgJiYgJCQuaW5pdFRpdGxlKCk7XHJcblxyXG5cdFx0Ly8gLS0gTWFpbiBSZWdpb24gLS1cclxuXHJcblx0XHQvLyB0ZXh0IHdoZW4gZW1wdHlcclxuXHRcdGlmIChjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0KSB7XHJcblx0XHRcdG1haW4uYXBwZW5kKFwidGV4dFwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgYCR7Q0xBU1MudGV4dH0gJHtDTEFTUy5lbXB0eX1gKVxyXG5cdFx0XHRcdC5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikgLy8gaG9yaXpvbnRhbCBjZW50ZXJpbmcgb2YgdGV4dCBhdCB4IHBvc2l0aW9uIGluIGFsbCBicm93c2Vycy5cclxuXHRcdFx0XHQuYXR0cihcImRvbWluYW50LWJhc2VsaW5lXCIsIFwibWlkZGxlXCIpOyAvLyB2ZXJ0aWNhbCBjZW50ZXJpbmcgb2YgdGV4dCBhdCB5IHBvc2l0aW9uIGluIGFsbCBicm93c2VycywgZXhjZXB0IElFLlxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlZ2lvbnNcclxuXHRcdCQkLmluaXRSZWdpb24oKTtcclxuXHJcblx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICdmYWxzZSdcclxuXHRcdCFjb25maWcuY2xpcFBhdGggJiYgJCQuYXhpcy5pbml0KCk7XHJcblxyXG5cdFx0Ly8gRGVmaW5lIGcgZm9yIGNoYXJ0IGFyZWFcclxuXHRcdG1haW4uYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgQ0xBU1MuY2hhcnQpXHJcblx0XHRcdC5hdHRyKFwiY2xpcC1wYXRoXCIsIHN0YXRlLmNsaXAucGF0aCk7XHJcblxyXG5cdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkaW5pdFwiKTtcclxuXHJcblx0XHQvLyBDb3ZlciB3aG9sZSB3aXRoIHJlY3RzIGZvciBldmVudHNcclxuXHRcdCQkLmluaXRFdmVudFJlY3QoKTtcclxuXHJcblx0XHQvLyBEZWZpbmUgZyBmb3IgY2hhcnRcclxuXHRcdCQkLmluaXRDaGFydEVsZW1lbnRzKCk7XHJcblxyXG5cdFx0Ly8gR3JpZHNcclxuXHRcdCQkLmluaXRHcmlkKCk7XHJcblxyXG5cdFx0Ly8gaWYgem9vbSBwcml2aWxlZ2VkLCBpbnNlcnQgcmVjdCB0byBmb3JlZnJvbnRcclxuXHRcdC8vIFRPRE86IGlzIHRoaXMgbmVlZGVkP1xyXG5cdFx0bWFpbi5pbnNlcnQoXCJyZWN0XCIsIGNvbmZpZy56b29tX3ByaXZpbGVnZWQgPyBudWxsIDogYGcuJHtDTEFTUy5yZWdpb25zfWApXHJcblx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgQ0xBU1Muem9vbVJlY3QpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgJCQuc3RhdGUud2lkdGgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsICQkLnN0YXRlLmhlaWdodClcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjBcIilcclxuXHRcdFx0Lm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcclxuXHJcblx0XHQvLyBBZGQgQXhpcyBoZXJlLCB3aGVuIGNsaXBQYXRoIGlzICd0cnVlJ1xyXG5cdFx0Y29uZmlnLmNsaXBQYXRoICYmICQkLmF4aXMuaW5pdCgpO1xyXG5cclxuXHRcdC8vIFNldCB0YXJnZXRzXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzKCQkLmRhdGEudGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gRHJhdyB3aXRoIHRhcmdldHNcclxuXHRcdCQkLnVwZGF0ZURpbWVuc2lvbigpO1xyXG5cclxuXHRcdC8vIG9uaW5pdCBjYWxsYmFja1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy5vbmluaXQsICQkLCAkJC5hcGkpO1xyXG5cclxuXHRcdC8vIFNldCBiYWNrZ3JvdW5kXHJcblx0XHQkJC5zZXRCYWNrZ3JvdW5kKCk7XHJcblxyXG5cdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHR3aXRoVHJhbnNmb3JtOiB0cnVlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFVwZGF0ZU9yZ1hEb21haW46IHRydWUsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yQXhpczogZmFsc2UsXHJcblx0XHRcdGluaXRpYWxpemluZzogdHJ1ZVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gZGF0YS5vbm1pbi9tYXggY2FsbGJhY2tcclxuXHRcdGlmIChjb25maWcuZGF0YV9vbm1pbiB8fCBjb25maWcuZGF0YV9vbm1heCkge1xyXG5cdFx0XHRjb25zdCBtaW5NYXggPSAkJC5nZXRNaW5NYXhEYXRhKCk7XHJcblxyXG5cdFx0XHRjYWxsRm4oY29uZmlnLmRhdGFfb25taW4sICQkLCBtaW5NYXgubWluKTtcclxuXHRcdFx0Y2FsbEZuKGNvbmZpZy5kYXRhX29ubWF4LCAkJCwgbWluTWF4Lm1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQmluZCByZXNpemUgZXZlbnRcclxuXHRcdCQkLmJpbmRSZXNpemUoKTtcclxuXHJcblx0XHQvLyBleHBvcnQgZWxlbWVudCBvZiB0aGUgY2hhcnRcclxuXHRcdCQkLmFwaS5lbGVtZW50ID0gJGVsLmNoYXJ0Lm5vZGUoKTtcclxuXHJcblx0XHRzdGF0ZS5yZW5kZXJlZCA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRpbml0Q2hhcnRFbGVtZW50cygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHJcblx0XHRbXCJCYXJcIiwgXCJSYWRhclwiLCBcIkxpbmVcIiwgXCJCdWJibGVcIiwgXCJBcmNcIiwgXCJHYXVnZVwiLCBcIlBpZVwiXS5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHQkJFtgaW5pdCR7dn1gXSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0bm90RW1wdHkoJCQuY29uZmlnLmRhdGFfbGFiZWxzKSAmJiAkJC5pbml0VGV4dCgpO1xyXG5cdH1cclxuXHJcblx0c2V0Q2hhcnRFbGVtZW50cygpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHskZWx9ID0gJCQ7XHJcblxyXG5cdFx0JCQuYXBpLiQgPSB7XHJcblx0XHRcdGNoYXJ0OiAkZWwuY2hhcnQsXHJcblx0XHRcdHN2ZzogJGVsLnN2ZyxcclxuXHRcdFx0ZGVmczogJGVsLmRlZnMsXHJcblx0XHRcdG1haW46ICRlbC5tYWluLFxyXG5cdFx0XHR0b29sdGlwOiAkZWwudG9vbHRpcCxcclxuXHRcdFx0bGVnZW5kOiAkZWwubGVnZW5kLFxyXG5cdFx0XHR0aXRsZTogJGVsLnRpdGxlLFxyXG5cdFx0XHRncmlkOiAkZWwuZ3JpZCxcclxuXHRcdFx0YXJjOiAkZWwuYXJjcyxcclxuXHRcdFx0YmFyOiB7XHJcblx0XHRcdFx0YmFyczogJGVsLmJhclxyXG5cdFx0XHR9LFxyXG5cdFx0XHRsaW5lOiB7XHJcblx0XHRcdFx0bGluZXM6ICRlbC5saW5lLFxyXG5cdFx0XHRcdGFyZWFzOiAkZWwuYXJlYSxcclxuXHRcdFx0XHRjaXJjbGVzOiAkZWwuY2lyY2xlXHJcblx0XHRcdH0sXHJcblx0XHRcdHRleHQ6IHtcclxuXHRcdFx0XHR0ZXh0czogJGVsLnRleHRcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBiYWNrZ3JvdW5kIGVsZW1lbnQvaW1hZ2VcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNldEJhY2tncm91bmQoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnOiB7YmFja2dyb3VuZDogYmd9LCAkZWw6IHtzdmd9fSA9ICQkO1xyXG5cclxuXHRcdGlmIChub3RFbXB0eShiZykpIHtcclxuXHRcdFx0Y29uc3QgZWxlbWVudCA9IHN2Zy5zZWxlY3QoYC4ke0NMQVNTWyQkLmhhc0FyY1R5cGUoKSA/IFwiY2hhcnRcIiA6IFwicmVnaW9uc1wiXX1gKVxyXG5cdFx0XHRcdC5pbnNlcnQoYmcuaW1nVXJsID8gXCJpbWFnZVwiIDogXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xyXG5cclxuXHRcdFx0aWYgKGJnLmltZ1VybCkge1xyXG5cdFx0XHRcdGVsZW1lbnQuYXR0cihcImhyZWZcIiwgYmcuaW1nVXJsKTtcclxuXHRcdFx0fSBlbHNlIGlmIChiZy5jb2xvcikge1xyXG5cdFx0XHRcdGVsZW1lbnQuc3R5bGUoXCJmaWxsXCIsIGJnLmNvbG9yKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZWxlbWVudFxyXG5cdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgYmcuY2xhc3MgfHwgbnVsbClcclxuXHRcdFx0XHQuYXR0cihcIndpZHRoXCIsIFwiMTAwJVwiKVxyXG5cdFx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHNtb290aExpbmVzKGVsLCB0eXBlKSB7XHJcblx0XHRpZiAodHlwZSA9PT0gXCJncmlkXCIpIHtcclxuXHRcdFx0ZWwuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRjb25zdCBnID0gZDNTZWxlY3QodGhpcyk7XHJcblxyXG5cdFx0XHRcdFtcIngxXCIsIFwieDJcIiwgXCJ5MVwiLCBcInkyXCJdXHJcblx0XHRcdFx0XHQuZm9yRWFjaCh2ID0+IGcuYXR0cih2LCBNYXRoLmNlaWwoK2cuYXR0cih2KSkpKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBVcGRhdGUgc2l6ZSB2YWx1ZXNcclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzSW5pdCBJZiBpcyBjYWxsZWQgYXQgaW5pdGlhbGl6YXRpb25cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHVwZGF0ZVNpemVzKGlzSW5pdCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGUsICRlbDoge2xlZ2VuZH19ID0gJCQ7XHJcblx0XHRjb25zdCBpc1JvdGF0ZWQgPSBjb25maWcuYXhpc19yb3RhdGVkO1xyXG5cdFx0Y29uc3QgaGFzQXJjID0gJCQuaGFzQXJjVHlwZSgpO1xyXG5cclxuXHRcdGNvbnN0IGN1cnJMZWdlbmQgPSB7XHJcblx0XHRcdHdpZHRoOiBsZWdlbmQgPyAkJC5nZXRMZWdlbmRXaWR0aCgpIDogMCxcclxuXHRcdFx0aGVpZ2h0OiBsZWdlbmQgPyAkJC5nZXRMZWdlbmRIZWlnaHQoKSA6IDBcclxuXHRcdH07XHJcblxyXG5cdFx0Y29uc3QgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tID0gc3RhdGUuaXNMZWdlbmRSaWdodCB8fCBzdGF0ZS5pc0xlZ2VuZEluc2V0ID8gMCA6IGN1cnJMZWdlbmQuaGVpZ2h0O1xyXG5cdFx0Y29uc3QgeEF4aXNIZWlnaHQgPSBpc1JvdGF0ZWQgfHwgaGFzQXJjID8gMCA6ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieFwiKTtcclxuXHJcblx0XHRjb25zdCBzdWJjaGFydFhBeGlzSGVpZ2h0ID0gY29uZmlnLnN1YmNoYXJ0X2F4aXNfeF9zaG93ICYmIGNvbmZpZy5zdWJjaGFydF9heGlzX3hfdGlja190ZXh0X3Nob3cgP1xyXG5cdFx0XHR4QXhpc0hlaWdodCA6IDMwO1xyXG5cdFx0Y29uc3Qgc3ViY2hhcnRIZWlnaHQgPSBjb25maWcuc3ViY2hhcnRfc2hvdyAmJiAhaGFzQXJjID9cclxuXHRcdFx0KGNvbmZpZy5zdWJjaGFydF9zaXplX2hlaWdodCArIHN1YmNoYXJ0WEF4aXNIZWlnaHQpIDogMDtcclxuXHJcblx0XHQhaXNJbml0ICYmICQkLnNldENvbnRhaW5lclNpemUoKTtcclxuXHJcblx0XHQvLyBmb3IgbWFpblxyXG5cdFx0c3RhdGUubWFyZ2luID0gaXNSb3RhdGVkID8ge1xyXG5cdFx0XHR0b3A6ICQkLmdldEhvcml6b250YWxBeGlzSGVpZ2h0KFwieTJcIikgKyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpLFxyXG5cdFx0XHRyaWdodDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSxcclxuXHRcdFx0Ym90dG9tOiAkJC5nZXRIb3Jpem9udGFsQXhpc0hlaWdodChcInlcIikgKyBsZWdlbmRIZWlnaHRGb3JCb3R0b20gKyAkJC5nZXRDdXJyZW50UGFkZGluZ0JvdHRvbSgpLFxyXG5cdFx0XHRsZWZ0OiBzdWJjaGFydEhlaWdodCArIChoYXNBcmMgPyAwIDogJCQuZ2V0Q3VycmVudFBhZGRpbmdMZWZ0KCkpXHJcblx0XHR9IDoge1xyXG5cdFx0XHR0b3A6IDQgKyAkJC5nZXRDdXJyZW50UGFkZGluZ1RvcCgpLCAvLyBmb3IgdG9wIHRpY2sgdGV4dFxyXG5cdFx0XHRyaWdodDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nUmlnaHQoKSxcclxuXHRcdFx0Ym90dG9tOiB4QXhpc0hlaWdodCArIHN1YmNoYXJ0SGVpZ2h0ICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tICsgJCQuZ2V0Q3VycmVudFBhZGRpbmdCb3R0b20oKSxcclxuXHRcdFx0bGVmdDogaGFzQXJjID8gMCA6ICQkLmdldEN1cnJlbnRQYWRkaW5nTGVmdCgpXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIGZvciBzdWJjaGFydFxyXG5cdFx0c3RhdGUubWFyZ2luMiA9IGlzUm90YXRlZCA/IHtcclxuXHRcdFx0dG9wOiBzdGF0ZS5tYXJnaW4udG9wLFxyXG5cdFx0XHRyaWdodDogTmFOLFxyXG5cdFx0XHRib3R0b206IDIwICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxyXG5cdFx0XHRsZWZ0OiAkJC5zdGF0ZS5yb3RhdGVkUGFkZGluZy5sZWZ0XHJcblx0XHR9IDoge1xyXG5cdFx0XHR0b3A6IHN0YXRlLmN1cnJlbnRIZWlnaHQgLSBzdWJjaGFydEhlaWdodCAtIGxlZ2VuZEhlaWdodEZvckJvdHRvbSxcclxuXHRcdFx0cmlnaHQ6IE5hTixcclxuXHRcdFx0Ym90dG9tOiBzdWJjaGFydFhBeGlzSGVpZ2h0ICsgbGVnZW5kSGVpZ2h0Rm9yQm90dG9tLFxyXG5cdFx0XHRsZWZ0OiBzdGF0ZS5tYXJnaW4ubGVmdFxyXG5cdFx0fTtcclxuXHJcblx0XHQvLyBmb3IgbGVnZW5kXHJcblx0XHRzdGF0ZS5tYXJnaW4zID0ge1xyXG5cdFx0XHR0b3A6IDAsXHJcblx0XHRcdHJpZ2h0OiBOYU4sXHJcblx0XHRcdGJvdHRvbTogMCxcclxuXHRcdFx0bGVmdDogMFxyXG5cdFx0fTtcclxuXHJcblx0XHQkJC51cGRhdGVTaXplRm9yTGVnZW5kICYmICQkLnVwZGF0ZVNpemVGb3JMZWdlbmQoY3VyckxlZ2VuZCk7XHJcblxyXG5cdFx0c3RhdGUud2lkdGggPSBzdGF0ZS5jdXJyZW50V2lkdGggLSBzdGF0ZS5tYXJnaW4ubGVmdCAtIHN0YXRlLm1hcmdpbi5yaWdodDtcclxuXHRcdHN0YXRlLmhlaWdodCA9IHN0YXRlLmN1cnJlbnRIZWlnaHQgLSBzdGF0ZS5tYXJnaW4udG9wIC0gc3RhdGUubWFyZ2luLmJvdHRvbTtcclxuXHJcblx0XHRpZiAoc3RhdGUud2lkdGggPCAwKSB7XHJcblx0XHRcdHN0YXRlLndpZHRoID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc3RhdGUuaGVpZ2h0IDwgMCkge1xyXG5cdFx0XHRzdGF0ZS5oZWlnaHQgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN0YXRlLndpZHRoMiA9IGlzUm90YXRlZCA/XHJcblx0XHRcdHN0YXRlLm1hcmdpbi5sZWZ0IC0gc3RhdGUucm90YXRlZFBhZGRpbmcubGVmdCAtIHN0YXRlLnJvdGF0ZWRQYWRkaW5nLnJpZ2h0IDogc3RhdGUud2lkdGg7XHJcblxyXG5cdFx0c3RhdGUuaGVpZ2h0MiA9IGlzUm90YXRlZCA/XHJcblx0XHRcdHN0YXRlLmhlaWdodCA6IHN0YXRlLmN1cnJlbnRIZWlnaHQgLSBzdGF0ZS5tYXJnaW4yLnRvcCAtIHN0YXRlLm1hcmdpbjIuYm90dG9tO1xyXG5cclxuXHRcdGlmIChzdGF0ZS53aWR0aDIgPCAwKSB7XHJcblx0XHRcdHN0YXRlLndpZHRoMiA9IDA7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHN0YXRlLmhlaWdodDIgPCAwKSB7XHJcblx0XHRcdHN0YXRlLmhlaWdodDIgPSAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvciBhcmNcclxuXHRcdHN0YXRlLmFyY1dpZHRoID0gc3RhdGUud2lkdGggLSAoc3RhdGUuaXNMZWdlbmRSaWdodCA/IGN1cnJMZWdlbmQud2lkdGggKyAxMCA6IDApO1xyXG5cdFx0c3RhdGUuYXJjSGVpZ2h0ID0gc3RhdGUuaGVpZ2h0IC0gKHN0YXRlLmlzTGVnZW5kUmlnaHQgPyAwIDogMTApO1xyXG5cclxuXHRcdGlmICgkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiYgIWNvbmZpZy5nYXVnZV9mdWxsQ2lyY2xlKSB7XHJcblx0XHRcdHN0YXRlLmFyY0hlaWdodCArPSBzdGF0ZS5oZWlnaHQgLSAkJC5nZXRHYXVnZUxhYmVsSGVpZ2h0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0JCQudXBkYXRlUmFkaXVzICYmICQkLnVwZGF0ZVJhZGl1cygpO1xyXG5cclxuXHRcdGlmIChzdGF0ZS5pc0xlZ2VuZFJpZ2h0ICYmIGhhc0FyYykge1xyXG5cdFx0XHRzdGF0ZS5tYXJnaW4zLmxlZnQgPSBzdGF0ZS5hcmNXaWR0aCAvIDIgKyBzdGF0ZS5yYWRpdXNFeHBhbmRlZCAqIDEuMTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSB0YXJnZXRlZCBlbGVtZW50IHdpdGggZ2l2ZW4gZGF0YVxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzIERhdGEgb2JqZWN0IGZvcm1hdHRlZCBhcyAndGFyZ2V0J1xyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0dXBkYXRlVGFyZ2V0cyh0YXJnZXRzKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblxyXG5cdFx0Ly8gVGV4dFxyXG5cdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclRleHQodGFyZ2V0cyk7XHJcblxyXG5cdFx0Ly8gQmFyXHJcblx0XHQkJC51cGRhdGVUYXJnZXRzRm9yQmFyKHRhcmdldHMpO1xyXG5cclxuXHRcdC8vIExpbmVcclxuXHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JMaW5lKHRhcmdldHMpO1xyXG5cclxuXHRcdC8vIEFyYyAmIFJhZGFyXHJcblx0XHQkJC5oYXNBcmNUeXBlKHRhcmdldHMpICYmIChcclxuXHRcdFx0JCQuaGFzVHlwZShcInJhZGFyXCIpID9cclxuXHRcdFx0XHQkJC51cGRhdGVUYXJnZXRzRm9yUmFkYXIodGFyZ2V0cykgOlxyXG5cdFx0XHRcdCQkLnVwZGF0ZVRhcmdldHNGb3JBcmModGFyZ2V0cylcclxuXHRcdCk7XHJcblxyXG5cdFx0Ly8gU3ViIENoYXJ0XHJcblx0XHQkJC51cGRhdGVUYXJnZXRzRm9yU3ViY2hhcnQgJiZcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0c0ZvclN1YmNoYXJ0KHRhcmdldHMpO1xyXG5cclxuXHRcdC8vIEZhZGUtaW4gZWFjaCBjaGFydFxyXG5cdFx0JCQuc2hvd1RhcmdldHMoKTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERpc3BsYXkgdGFyZ2V0ZWQgZWxlbWVudHNcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdHNob3dUYXJnZXRzKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cclxuXHRcdCQkLiRlbC5zdmcuc2VsZWN0QWxsKGAuJHtDTEFTUy50YXJnZXR9YClcclxuXHRcdFx0LmZpbHRlcihkID0+ICQkLmlzVGFyZ2V0VG9TaG93KGQuaWQpKVxyXG5cdFx0XHQudHJhbnNpdGlvbigpXHJcblx0XHRcdC5kdXJhdGlvbigkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbilcclxuXHRcdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBcIjFcIik7XHJcblx0fVxyXG5cclxuXHRnZXRXaXRoT3B0aW9uKG9wdGlvbnMpIHtcclxuXHRcdGNvbnN0IHdpdGhPcHRpb25zID0ge1xyXG5cdFx0XHRZOiB0cnVlLFxyXG5cdFx0XHRTdWJjaGFydDogdHJ1ZSxcclxuXHRcdFx0VHJhbnNpdGlvbjogdHJ1ZSxcclxuXHRcdFx0RXZlbnRSZWN0OiB0cnVlLFxyXG5cdFx0XHREaW1lbnNpb246IHRydWUsXHJcblx0XHRcdFRyaW1YRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRUcmFuc2Zvcm06IGZhbHNlLFxyXG5cdFx0XHRVcGRhdGVYRG9tYWluOiBmYWxzZSxcclxuXHRcdFx0VXBkYXRlT3JnWERvbWFpbjogZmFsc2UsXHJcblx0XHRcdExlZ2VuZDogZmFsc2UsXHJcblx0XHRcdFVwZGF0ZVhBeGlzOiBcIlVwZGF0ZVhEb21haW5cIixcclxuXHRcdFx0VHJhbnNpdGlvbkZvckV4aXQ6IFwiVHJhbnNpdGlvblwiLFxyXG5cdFx0XHRUcmFuc2l0aW9uRm9yQXhpczogXCJUcmFuc2l0aW9uXCJcclxuXHRcdH07XHJcblxyXG5cdFx0T2JqZWN0LmtleXMod2l0aE9wdGlvbnMpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdFx0bGV0IGRlZlZhbCA9IHdpdGhPcHRpb25zW2tleV07XHJcblxyXG5cdFx0XHRpZiAoaXNTdHJpbmcoZGVmVmFsKSkge1xyXG5cdFx0XHRcdGRlZlZhbCA9IHdpdGhPcHRpb25zW2RlZlZhbF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdpdGhPcHRpb25zW2tleV0gPSBnZXRPcHRpb24ob3B0aW9ucywgYHdpdGgke2tleX1gLCBkZWZWYWwpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0cmV0dXJuIHdpdGhPcHRpb25zO1xyXG5cdH1cclxuXHJcblx0cmVkcmF3KG9wdGlvbnMgPSB7fSwgdHJhbnNpdGlvbnNWYWx1ZT8pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlLCAkZWx9ID0gJCQ7XHJcblx0XHRjb25zdCB7bWFpbn0gPSAkZWw7XHJcblx0XHRjb25zdCB0YXJnZXRzVG9TaG93ID0gJCQuZmlsdGVyVGFyZ2V0c1RvU2hvdygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdGNvbnN0IGluaXRpYWxpemluZyA9IG9wdGlvbnMuaW5pdGlhbGl6aW5nO1xyXG5cdFx0Y29uc3QgZmxvdyA9IG9wdGlvbnMuZmxvdztcclxuXHRcdGNvbnN0IHd0aCA9ICQkLmdldFdpdGhPcHRpb24ob3B0aW9ucyk7XHJcblx0XHRjb25zdCBkdXJhdGlvbiA9IHd0aC5UcmFuc2l0aW9uID8gY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JFeGl0ID0gd3RoLlRyYW5zaXRpb25Gb3JFeGl0ID8gZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgZHVyYXRpb25Gb3JBeGlzID0gd3RoLlRyYW5zaXRpb25Gb3JBeGlzID8gZHVyYXRpb24gOiAwO1xyXG5cdFx0Y29uc3QgdHJhbnNpdGlvbnMgPSB0cmFuc2l0aW9uc1ZhbHVlIHx8ICQkLmF4aXMuZ2VuZXJhdGVUcmFuc2l0aW9ucyhkdXJhdGlvbkZvckF4aXMpO1xyXG5cclxuXHRcdCEoaW5pdGlhbGl6aW5nICYmIGNvbmZpZy50b29sdGlwX2luaXRfc2hvdykgJiZcclxuXHRcdFx0c3RhdGUuaW5wdXRUeXBlID09PSBcInRvdWNoXCIgJiYgJCQuaGlkZVRvb2x0aXAoKTtcclxuXHJcblx0XHQkJC51cGRhdGVTaXplcyhpbml0aWFsaXppbmcpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBsZWdlbmQgYW5kIHRyYW5zZm9ybSBlYWNoIGdcclxuXHJcblx0XHRpZiAod3RoLkxlZ2VuZCAmJiBjb25maWcubGVnZW5kX3Nob3cpIHtcclxuXHRcdFx0JCQudXBkYXRlTGVnZW5kKCQkLm1hcFRvSWRzKCQkLmRhdGEudGFyZ2V0cyksIG9wdGlvbnMsIHRyYW5zaXRpb25zKTtcclxuXHRcdH0gZWxzZSBpZiAod3RoLkRpbWVuc2lvbikge1xyXG5cdFx0XHQvLyBuZWVkIHRvIHVwZGF0ZSBkaW1lbnNpb24gKGUuZy4gYXhpcy55LnRpY2sudmFsdWVzKSBiZWNhdXNlIHkgdGljayB2YWx1ZXMgc2hvdWxkIGNoYW5nZVxyXG5cdFx0XHQvLyBubyBuZWVkIHRvIHVwZGF0ZSBheGlzIGluIGl0IGJlY2F1c2UgdGhleSB3aWxsIGJlIHVwZGF0ZWQgaW4gcmVkcmF3KClcclxuXHRcdFx0JCQudXBkYXRlRGltZW5zaW9uKHRydWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBheGlzXHJcblx0XHQvLyBAVE9ETzogTWFrZSAnaW5pdCcgc3RhdGUgdG8gYmUgYWNjZXNzaWJsZSBldmVyeXdoZXJlIG5vdCBwYXNzaW5nIGFzIGFyZ3VtZW50LlxyXG5cdFx0JCQuYXhpcy5yZWRyYXdBeGlzKHRhcmdldHNUb1Nob3csIHd0aCwgdHJhbnNpdGlvbnMsIGZsb3csIGluaXRpYWxpemluZyk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNpcmNsZVkgYmFzZWQgb24gdXBkYXRlZCBwYXJhbWV0ZXJzXHJcblx0XHQkJC51cGRhdGVDaXJjbGVZKCk7XHJcblxyXG5cdFx0Ly8geGdyaWQgZm9jdXNcclxuXHRcdCQkLnVwZGF0ZWdyaWRGb2N1cygpO1xyXG5cclxuXHRcdC8vIERhdGEgZW1wdHkgbGFiZWwgcG9zaXRpb25pbmcgYW5kIHRleHQuXHJcblx0XHRjb25maWcuZGF0YV9lbXB0eV9sYWJlbF90ZXh0ICYmIG1haW4uc2VsZWN0KGB0ZXh0LiR7Q0xBU1MudGV4dH0uJHtDTEFTUy5lbXB0eX1gKVxyXG5cdFx0XHQuYXR0cihcInhcIiwgc3RhdGUud2lkdGggLyAyKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgc3RhdGUuaGVpZ2h0IC8gMilcclxuXHRcdFx0LnRleHQoY29uZmlnLmRhdGFfZW1wdHlfbGFiZWxfdGV4dClcclxuXHRcdFx0LnN0eWxlKFwiZGlzcGxheVwiLCB0YXJnZXRzVG9TaG93Lmxlbmd0aCA/IFwibm9uZVwiIDogbnVsbCk7XHJcblxyXG5cdFx0Ly8gZ3JpZFxyXG5cdFx0JCQudXBkYXRlR3JpZChkdXJhdGlvbik7XHJcblxyXG5cdFx0Ly8gcmVjdCBmb3IgcmVnaW9uc1xyXG5cdFx0JCQudXBkYXRlUmVnaW9uKGR1cmF0aW9uKTtcclxuXHJcblx0XHQvLyBiYXJzXHJcblx0XHQkJC51cGRhdGVCYXIoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHJcblx0XHQvLyBsaW5lcywgYXJlYXMgYW5kIGNpcmNsZXNcclxuXHRcdCQkLnVwZGF0ZUxpbmUoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdCQkLnVwZGF0ZUFyZWEoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHRcdCQkLnVwZGF0ZUNpcmNsZSgpO1xyXG5cclxuXHRcdC8vIHRleHRcclxuXHRcdCQkLmhhc0RhdGFMYWJlbCgpICYmICQkLnVwZGF0ZVRleHQoZHVyYXRpb25Gb3JFeGl0KTtcclxuXHJcblx0XHQvLyB0aXRsZVxyXG5cdFx0JCQucmVkcmF3VGl0bGUgJiYgJCQucmVkcmF3VGl0bGUoKTtcclxuXHJcblx0XHQvLyBhcmNcclxuXHRcdCRlbC5hcmNzICYmICQkLnJlZHJhd0FyYyhkdXJhdGlvbiwgZHVyYXRpb25Gb3JFeGl0LCB3dGguVHJhbnNmb3JtKTtcclxuXHJcblx0XHQvLyByYWRhclxyXG5cdFx0JCQucmFkYXJzICYmICQkLnJlZHJhd1JhZGFyKGR1cmF0aW9uLCBkdXJhdGlvbkZvckV4aXQpO1xyXG5cclxuXHRcdC8vIGNpcmNsZXMgZm9yIHNlbGVjdFxyXG5cdFx0JGVsLnRleHQgJiYgbWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNlbGVjdGVkQ2lyY2xlc31gKVxyXG5cdFx0XHQuZmlsdGVyKCQkLmlzQmFyVHlwZS5iaW5kKCQkKSlcclxuXHRcdFx0LnNlbGVjdEFsbChcImNpcmNsZVwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0Ly8gZXZlbnQgcmVjdHMgd2lsbCByZWRyYXduIHdoZW4gZmxvdyBjYWxsZWRcclxuXHRcdGlmIChjb25maWcuaW50ZXJhY3Rpb25fZW5hYmxlZCAmJiAhZmxvdyAmJiB3dGguRXZlbnRSZWN0KSB7XHJcblx0XHRcdCQkLmJpbmRab29tRXZlbnQoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpbml0aWFsaXppbmcgJiYgJCQuc2V0Q2hhcnRFbGVtZW50cygpO1xyXG5cclxuXHRcdCQkLmdlbmVyYXRlUmVkcmF3TGlzdCh0YXJnZXRzVG9TaG93LCBmbG93LCBkdXJhdGlvbiwgd3RoLlN1YmNoYXJ0KTtcclxuXHRcdCQkLmNhbGxQbHVnaW5Ib29rKFwiJHJlZHJhd1wiLCBvcHRpb25zLCBkdXJhdGlvbik7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBHZW5lcmF0ZSByZWRyYXcgbGlzdFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRzIHRhcmdldHMgZGF0YSB0byBiZSBzaG93blxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmbG93XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGR1cmF0aW9uXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSB3aXRoU3ViY2hhcnQgd2hldGhlciBvciBub3QgdG8gc2hvdyBzdWJjaGFydFxyXG5cdCAqIEBwcml2YXRlXHJcblx0ICovXHJcblx0Z2VuZXJhdGVSZWRyYXdMaXN0KHRhcmdldHMsIGZsb3csIGR1cmF0aW9uLCB3aXRoU3ViY2hhcnQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3Qgc2hhcGUgPSAkJC5nZXREcmF3U2hhcGUoKTtcclxuXHJcblx0XHQvLyBzdWJjaGFydFxyXG5cdFx0Y29uZmlnLnN1YmNoYXJ0X3Nob3cgJiYgJCQucmVkcmF3U3ViY2hhcnQod2l0aFN1YmNoYXJ0LCBkdXJhdGlvbiwgc2hhcGUpO1xyXG5cclxuXHRcdC8vIGdlbmVyYXRlIGZsb3dcclxuXHRcdGNvbnN0IGZsb3dGbiA9IGZsb3cgJiYgJCQuZ2VuZXJhdGVGbG93KHtcclxuXHRcdFx0dGFyZ2V0cyxcclxuXHRcdFx0ZmxvdyxcclxuXHRcdFx0ZHVyYXRpb246IGZsb3cuZHVyYXRpb24sXHJcblx0XHRcdHNoYXBlLFxyXG5cdFx0XHR4djogJCQueHYuYmluZCgkJClcclxuXHRcdH0pO1xyXG5cdFx0Y29uc3QgaXNUcmFuc2l0aW9uID0gKGR1cmF0aW9uIHx8IGZsb3dGbikgJiYgJCQuaXNUYWJWaXNpYmxlKCk7XHJcblxyXG5cdFx0Ly8gcmVkcmF3IGxpc3RcclxuXHRcdGNvbnN0IHJlZHJhd0xpc3QgPSAkJC5nZXRSZWRyYXdMaXN0KHNoYXBlLCBmbG93LCBmbG93Rm4sIGlzVHJhbnNpdGlvbik7XHJcblxyXG5cdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb24gYWZ0ZXIgcmVkcmF3IGVuZHNcclxuXHRcdGNvbnN0IGFmdGVyUmVkcmF3ID0gZmxvdyB8fCBjb25maWcub25yZW5kZXJlZCA/ICgpID0+IHtcclxuXHRcdFx0Zmxvd0ZuICYmIGZsb3dGbigpO1xyXG5cdFx0XHRjYWxsRm4oY29uZmlnLm9ucmVuZGVyZWQsICQkLCAkJC5hcGkpO1xyXG5cdFx0fSA6IG51bGw7XHJcblxyXG5cdFx0aWYgKGFmdGVyUmVkcmF3KSB7XHJcblx0XHRcdC8vIE9ubHkgdXNlIHRyYW5zaXRpb24gd2hlbiBjdXJyZW50IHRhYiBpcyB2aXNpYmxlLlxyXG5cdFx0XHRpZiAoaXNUcmFuc2l0aW9uICYmIHJlZHJhd0xpc3QubGVuZ3RoKSB7XHJcblx0XHRcdFx0Ly8gV2FpdCBmb3IgZW5kIG9mIHRyYW5zaXRpb25zIGZvciBjYWxsYmFja1xyXG5cdFx0XHRcdGNvbnN0IHdhaXRGb3JEcmF3ID0gJCQuZ2VuZXJhdGVXYWl0KCk7XHJcblxyXG5cdFx0XHRcdC8vIHRyYW5zaXRpb24gc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSBvbmUgdHJhbnNpdGlvblxyXG5cdFx0XHRcdGQzVHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKVxyXG5cdFx0XHRcdFx0LmVhY2goKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRyZWRyYXdMaXN0XHJcblx0XHRcdFx0XHRcdFx0LnJlZHVjZSgoYWNjLCB0MSkgPT4gYWNjLmNvbmNhdCh0MSksIFtdKVxyXG5cdFx0XHRcdFx0XHRcdC5mb3JFYWNoKHQgPT4gd2FpdEZvckRyYXcuYWRkKHQpKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQuY2FsbCh3YWl0Rm9yRHJhdywgYWZ0ZXJSZWRyYXcpO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCFzdGF0ZS50cmFuc2l0aW5nKSB7XHJcblx0XHRcdFx0YWZ0ZXJSZWRyYXcoKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBmYWRlaW4gY29uZGl0aW9uXHJcblx0XHQkJC5tYXBUb0lkcygkJC5kYXRhLnRhcmdldHMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRzdGF0ZS53aXRob3V0RmFkZUluW2lkXSA9IHRydWU7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgc2hhcGUgZHJhdyBmdW5jdGlvblxyXG5cdCAqIEByZXR1cm4ge09iamVjdH1cclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdGdldERyYXdTaGFwZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IGlzUm90YXRlZCA9ICQkLmNvbmZpZy5heGlzX3JvdGF0ZWQ7XHJcblx0XHRjb25zdCBoYXNSYWRhciA9ICQkLmhhc1R5cGUoXCJyYWRhclwiKTtcclxuXHRcdGNvbnN0IHNoYXBlID0ge3R5cGU6IHt9LCBpbmRpY2VzOiB7fSwgcG9zOiB7fX07XHJcblxyXG5cdFx0Ly8gc2V0dXAgZHJhd2VyIC0gTUVNTzogdGhlc2UgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYXhpcyB1cGRhdGVkXHJcblx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiTGluZVwiKSB8fCAkJC5oYXNUeXBlKFwiYnViYmxlXCIpIHx8ICQkLmhhc1R5cGUoXCJzY2F0dGVyXCIpKSB7XHJcblx0XHRcdGNvbnN0IGluZGljZXMgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNMaW5lVHlwZSk7XHJcblxyXG5cdFx0XHRzaGFwZS5pbmRpY2VzLmxpbmUgPSBpbmRpY2VzO1xyXG5cdFx0XHRzaGFwZS50eXBlLmxpbmUgPSAkJC5nZW5lcmF0ZURyYXdMaW5lID8gJCQuZ2VuZXJhdGVEcmF3TGluZShpbmRpY2VzLCBmYWxzZSkgOiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRpZiAoJCQuaGFzVHlwZU9mKFwiQXJlYVwiKSkge1xyXG5cdFx0XHRcdGNvbnN0IGluZGljZXMgPSAkJC5nZXRTaGFwZUluZGljZXMoJCQuaXNBcmVhVHlwZSk7XHJcblxyXG5cdFx0XHRcdHNoYXBlLmluZGljZXMuYXJlYSA9IGluZGljZXM7XHJcblx0XHRcdFx0c2hhcGUudHlwZS5hcmVhID0gJCQuZ2VuZXJhdGVEcmF3QXJlYSA/ICQkLmdlbmVyYXRlRHJhd0FyZWEoaW5kaWNlcywgZmFsc2UpIDogdW5kZWZpbmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCQkLmhhc1R5cGUoXCJiYXJcIikpIHtcclxuXHRcdFx0Y29uc3QgaW5kaWNlcyA9ICQkLmdldFNoYXBlSW5kaWNlcygkJC5pc0JhclR5cGUpO1xyXG5cclxuXHRcdFx0c2hhcGUuaW5kaWNlcy5iYXIgPSBpbmRpY2VzO1xyXG5cdFx0XHRzaGFwZS50eXBlLmJhciA9ICQkLmdlbmVyYXRlRHJhd0JhciA/ICQkLmdlbmVyYXRlRHJhd0JhcihpbmRpY2VzKSA6IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRzaGFwZS5wb3MgPSB7XHJcblx0XHRcdHhGb3JUZXh0OiAkJC5nZW5lcmF0ZVhZRm9yVGV4dChzaGFwZS5pbmRpY2VzLCB0cnVlKSxcclxuXHRcdFx0eUZvclRleHQ6ICQkLmdlbmVyYXRlWFlGb3JUZXh0KHNoYXBlLmluZGljZXMsIGZhbHNlKSxcclxuXHJcblx0XHRcdC8vIGdlbmVyYXRlIGNpcmNsZSB4L3kgZnVuY3Rpb25zIGRlcGVuZGluZyBvbiB1cGRhdGVkIHBhcmFtc1xyXG5cdFx0XHRjeDogKGhhc1JhZGFyID8gJCQucmFkYXJDaXJjbGVYIDogKGlzUm90YXRlZCA/ICQkLmNpcmNsZVkgOiAkJC5jaXJjbGVYKSkuYmluZCgkJCksXHJcblx0XHRcdGN5OiAoaGFzUmFkYXIgPyAkJC5yYWRhckNpcmNsZVkgOiAoaXNSb3RhdGVkID8gJCQuY2lyY2xlWCA6ICQkLmNpcmNsZVkpKS5iaW5kKCQkKVxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gc2hhcGU7XHJcblx0fVxyXG5cclxuXHRnZXRSZWRyYXdMaXN0KHNoYXBlLCBmbG93LCBmbG93Rm4sIGlzVHJhbnNpdGlvbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGhhc0FyY1R5cGUgPSAkJC5oYXNBcmNUeXBlKCk7XHJcblx0XHRjb25zdCB7Y3gsIGN5LCB4Rm9yVGV4dCwgeUZvclRleHR9ID0gc2hhcGUucG9zO1xyXG5cdFx0Y29uc3QgbGlzdCA9IFtdO1xyXG5cclxuXHRcdGlmICghaGFzQXJjVHlwZSkge1xyXG5cdFx0XHRjb25zdCB7YXJlYSwgYmFyLCBsaW5lfSA9IHNoYXBlLnR5cGU7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmdyaWRfeF9saW5lcy5sZW5ndGggfHwgY29uZmlnLmdyaWRfeV9saW5lcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRsaXN0LnB1c2goJCQucmVkcmF3R3JpZChpc1RyYW5zaXRpb24pKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGNvbmZpZy5yZWdpb25zLmxlbmd0aCkge1xyXG5cdFx0XHRcdGxpc3QucHVzaCgkJC5yZWRyYXdSZWdpb24oaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICgkJC5oYXNUeXBlT2YoXCJMaW5lXCIpKSB7XHJcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd0xpbmUobGluZSwgaXNUcmFuc2l0aW9uKSk7XHJcblx0XHRcdFx0JCQuaGFzVHlwZU9mKFwiQXJlYVwiKSAmJiBsaXN0LnB1c2goJCQucmVkcmF3QXJlYShhcmVhLCBpc1RyYW5zaXRpb24pKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JCQuaGFzVHlwZShcImJhclwiKSAmJiBsaXN0LnB1c2goJCQucmVkcmF3QmFyKGJhciwgaXNUcmFuc2l0aW9uKSk7XHJcblxyXG5cdFx0XHRub3RFbXB0eShjb25maWcuZGF0YV9sYWJlbHMpICYmXHJcblx0XHRcdFx0bGlzdC5wdXNoKCQkLnJlZHJhd1RleHQoeEZvclRleHQsIHlGb3JUZXh0LCBmbG93LCBpc1RyYW5zaXRpb24pKTtcclxuXHRcdH1cclxuXHJcblx0XHQoIWhhc0FyY1R5cGUgfHwgJCQuaGFzVHlwZShcInJhZGFyXCIpKSAmJiBsaXN0LnB1c2goJCQucmVkcmF3Q2lyY2xlKGN4LCBjeSwgaXNUcmFuc2l0aW9uLCBmbG93Rm4pKTtcclxuXHJcblx0XHRyZXR1cm4gbGlzdDtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZUFuZFJlZHJhdyhvcHRpb25zID0ge30pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblx0XHRsZXQgdHJhbnNpdGlvbnM7XHJcblxyXG5cdFx0Ly8gc2FtZSB3aXRoIHJlZHJhd1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbiA9IGdldE9wdGlvbihvcHRpb25zLCBcIndpdGhUcmFuc2l0aW9uXCIsIHRydWUpO1xyXG5cdFx0b3B0aW9ucy53aXRoVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zZm9ybVwiLCBmYWxzZSk7XHJcblx0XHRvcHRpb25zLndpdGhMZWdlbmQgPSBnZXRPcHRpb24ob3B0aW9ucywgXCJ3aXRoTGVnZW5kXCIsIGZhbHNlKTtcclxuXHJcblx0XHQvLyBOT1Qgc2FtZSB3aXRoIHJlZHJhd1xyXG5cdFx0b3B0aW9ucy53aXRoVXBkYXRlWERvbWFpbiA9IHRydWU7XHJcblx0XHRvcHRpb25zLndpdGhVcGRhdGVPcmdYRG9tYWluID0gdHJ1ZTtcclxuXHRcdG9wdGlvbnMud2l0aFRyYW5zaXRpb25Gb3JFeGl0ID0gZmFsc2U7XHJcblx0XHRvcHRpb25zLndpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwid2l0aFRyYW5zaXRpb25Gb3JUcmFuc2Zvcm1cIiwgb3B0aW9ucy53aXRoVHJhbnNpdGlvbik7XHJcblxyXG5cdFx0Ly8gTUVNTzogY2FsbGVkIGluIHVwZGF0ZUxlZ2VuZCBpbiByZWRyYXcgaWYgd2l0aExlZ2VuZFxyXG5cdFx0aWYgKCEob3B0aW9ucy53aXRoTGVnZW5kICYmIGNvbmZpZy5sZWdlbmRfc2hvdykpIHtcclxuXHRcdFx0dHJhbnNpdGlvbnMgPSAkJC5heGlzLmdlbmVyYXRlVHJhbnNpdGlvbnMoXHJcblx0XHRcdFx0b3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvckF4aXMgPyBjb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbiA6IDBcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSBzY2FsZXNcclxuXHRcdFx0JCQudXBkYXRlU2NhbGVzKCk7XHJcblx0XHRcdCQkLnVwZGF0ZVN2Z1NpemUoKTtcclxuXHJcblx0XHRcdC8vIFVwZGF0ZSBnIHBvc2l0aW9uc1xyXG5cdFx0XHQkJC50cmFuc2Zvcm1BbGwob3B0aW9ucy53aXRoVHJhbnNpdGlvbkZvclRyYW5zZm9ybSwgdHJhbnNpdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERyYXcgd2l0aCBuZXcgc2l6ZXMgJiBzY2FsZXNcclxuXHRcdCQkLnJlZHJhdyhvcHRpb25zLCB0cmFuc2l0aW9ucyk7XHJcblx0fVxyXG5cclxuXHRyZWRyYXdXaXRob3V0UmVzY2FsZSgpIHtcclxuXHRcdHRoaXMucmVkcmF3KHtcclxuXHRcdFx0d2l0aFk6IGZhbHNlLFxyXG5cdFx0XHR3aXRoU3ViY2hhcnQ6IGZhbHNlLFxyXG5cdFx0XHR3aXRoRXZlbnRSZWN0OiBmYWxzZSxcclxuXHRcdFx0d2l0aFRyYW5zaXRpb25Gb3JBeGlzOiBmYWxzZVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRpc1RpbWVTZXJpZXMoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb25maWcuYXhpc194X3R5cGUgPT09IFwidGltZXNlcmllc1wiO1xyXG5cdH1cclxuXHJcblx0aXNDYXRlZ29yaXplZCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3hfdHlwZS5pbmRleE9mKFwiY2F0ZWdvcnlcIikgPj0gMCB8fCB0aGlzLmhhc1R5cGUoXCJyYWRhclwiKTtcclxuXHR9XHJcblxyXG5cdGlzQ3VzdG9tWCgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0cmV0dXJuICEkJC5pc1RpbWVTZXJpZXMoKSAmJiAoY29uZmlnLmRhdGFfeCB8fCBub3RFbXB0eShjb25maWcuZGF0YV94cykpO1xyXG5cdH1cclxuXHJcblx0aXNUaW1lU2VyaWVzWSgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNvbmZpZy5heGlzX3lfdHlwZSA9PT0gXCJ0aW1lc2VyaWVzXCI7XHJcblx0fVxyXG5cclxuXHRnZXRUcmFuc2xhdGUodGFyZ2V0LCBpbmRleCA9IDApIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgaXNSb3RhdGVkID0gY29uZmlnLmF4aXNfcm90YXRlZDtcclxuXHRcdGNvbnN0IGhhc0dhdWdlID0gJCQuaGFzVHlwZShcImdhdWdlXCIpO1xyXG5cdFx0bGV0IHBhZGRpbmcgPSAwO1xyXG5cdFx0bGV0IHg7XHJcblx0XHRsZXQgeTtcclxuXHJcblx0XHRpZiAoaW5kZXggJiYgL14oeHx5Mj8pJC8udGVzdCh0YXJnZXQpKSB7XHJcblx0XHRcdHBhZGRpbmcgPSAkJC5nZXRBeGlzU2l6ZSh0YXJnZXQpICogaW5kZXg7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRhcmdldCA9PT0gXCJtYWluXCIpIHtcclxuXHRcdFx0eCA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi5sZWZ0KTtcclxuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi50b3ApO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwiY29udGV4dFwiKSB7XHJcblx0XHRcdHggPSBhc0hhbGZQaXhlbChzdGF0ZS5tYXJnaW4yLmxlZnQpO1xyXG5cdFx0XHR5ID0gYXNIYWxmUGl4ZWwoc3RhdGUubWFyZ2luMi50b3ApO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwibGVnZW5kXCIpIHtcclxuXHRcdFx0eCA9IHN0YXRlLm1hcmdpbjMubGVmdDtcclxuXHRcdFx0eSA9IHN0YXRlLm1hcmdpbjMudG9wICsgKGhhc0dhdWdlID8gMTAgOiAwKTtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInhcIikge1xyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gLXBhZGRpbmcgOiAwO1xyXG5cdFx0XHR5ID0gaXNSb3RhdGVkID8gMCA6IHN0YXRlLmhlaWdodCArIHBhZGRpbmc7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJ5XCIpIHtcclxuXHRcdFx0eCA9IGlzUm90YXRlZCA/IDAgOiAtcGFkZGluZztcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IHN0YXRlLmhlaWdodCArIHBhZGRpbmcgOiAwO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwieTJcIikge1xyXG5cdFx0XHR4ID0gaXNSb3RhdGVkID8gMCA6IHN0YXRlLndpZHRoICsgcGFkZGluZztcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDEgLSBwYWRkaW5nIDogMDtcclxuXHRcdH0gZWxzZSBpZiAodGFyZ2V0ID09PSBcInN1YlhcIikge1xyXG5cdFx0XHR4ID0gMDtcclxuXHRcdFx0eSA9IGlzUm90YXRlZCA/IDAgOiBzdGF0ZS5oZWlnaHQyO1xyXG5cdFx0fSBlbHNlIGlmICh0YXJnZXQgPT09IFwiYXJjXCIpIHtcclxuXHRcdFx0eCA9IHN0YXRlLmFyY1dpZHRoIC8gMjtcclxuXHRcdFx0eSA9IHN0YXRlLmFyY0hlaWdodCAvIDI7XHJcblx0XHR9IGVsc2UgaWYgKHRhcmdldCA9PT0gXCJyYWRhclwiKSB7XHJcblx0XHRcdGNvbnN0IFt3aWR0aF0gPSAkJC5nZXRSYWRhclNpemUoKTtcclxuXHJcblx0XHRcdHggPSBzdGF0ZS53aWR0aCAvIDIgLSB3aWR0aDtcclxuXHRcdFx0eSA9IGFzSGFsZlBpeGVsKHN0YXRlLm1hcmdpbi50b3ApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBgdHJhbnNsYXRlKCR7eH0sICR7eX0pYDtcclxuXHR9XHJcblxyXG5cdGluaXRpYWxPcGFjaXR5KGQpIHtcclxuXHRcdGNvbnN0IHt3aXRob3V0RmFkZUlufSA9IHRoaXMuc3RhdGU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0QmFzZVZhbHVlKGQpICE9PSBudWxsICYmXHJcblx0XHRcdHdpdGhvdXRGYWRlSW5bZC5pZF0gPyBcIjFcIiA6IFwiMFwiO1xyXG5cdH1cclxuXHJcblx0aW5pdGlhbE9wYWNpdHlGb3JDaXJjbGUoZCkge1xyXG5cdFx0Y29uc3Qge3dpdGhvdXRGYWRlSW59ID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5nZXRCYXNlVmFsdWUoZCkgIT09IG51bGwgJiZcclxuXHRcdFx0d2l0aG91dEZhZGVJbltkLmlkXSA/IHRoaXMub3BhY2l0eUZvckNpcmNsZShkKSA6IFwiMFwiO1xyXG5cdH1cclxuXHJcblx0b3BhY2l0eUZvckNpcmNsZShkKSB7XHJcblx0XHRjb25zdCBvcGFjaXR5ID0gdGhpcy5jb25maWcucG9pbnRfc2hvdyA/IFwiMVwiIDogXCIwXCI7XHJcblxyXG5cdFx0cmV0dXJuIGlzVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoZCkpID9cclxuXHRcdFx0KHRoaXMuaXNCdWJibGVUeXBlKGQpIHx8IHRoaXMuaXNTY2F0dGVyVHlwZShkKSA/XHJcblx0XHRcdFx0XCIwLjVcIiA6IG9wYWNpdHkpIDogXCIwXCI7XHJcblx0fVxyXG5cclxuXHRvcGFjaXR5Rm9yVGV4dCgpIHtcclxuXHRcdHJldHVybiB0aGlzLmhhc0RhdGFMYWJlbCgpID8gXCIxXCIgOiBcIjBcIjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgem9vbSBvciB1bnpvb21lZCBzY2FsZWQgdmFsdWVcclxuXHQgKiBAcGFyYW0ge0RhdGV8TnVtYmVyfE9iamVjdH0gZCBEYXRhIHZhbHVlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHR4eChkKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBzY2FsZToge3gsIHpvb219fSA9ICQkO1xyXG5cdFx0Y29uc3QgZm4gPSBjb25maWcuem9vbV9lbmFibGVkICYmIHpvb20gP1xyXG5cdFx0XHR6b29tIDogeDtcclxuXHJcblx0XHRyZXR1cm4gZCA/IGZuKGlzVmFsdWUoZC54KSA/IGQueCA6IGQpIDogbnVsbDtcclxuXHR9XHJcblxyXG5cdHh2KGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWcsIHNjYWxlOiB7eH19ID0gJCQ7XHJcblx0XHRsZXQgdmFsdWUgPSAkJC5nZXRCYXNlVmFsdWUoZCk7XHJcblxyXG5cdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdHZhbHVlID0gJCQucGFyc2VEYXRlKHZhbHVlKTtcclxuXHRcdH0gZWxzZSBpZiAoJCQuaXNDYXRlZ29yaXplZCgpICYmIGlzU3RyaW5nKHZhbHVlKSkge1xyXG5cdFx0XHR2YWx1ZSA9IGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcy5pbmRleE9mKHZhbHVlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHgodmFsdWUpKTtcclxuXHR9XHJcblxyXG5cdHl2KGQpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzY2FsZToge3ksIHkyfX0gPSAkJDtcclxuXHRcdGNvbnN0IHlTY2FsZSA9IGQuYXhpcyAmJiBkLmF4aXMgPT09IFwieTJcIiA/IHkyIDogeTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5jZWlsKHlTY2FsZSgkJC5nZXRCYXNlVmFsdWUoZCkpKTtcclxuXHR9XHJcblxyXG5cdHN1Ynh4KGQpIHtcclxuXHRcdHJldHVybiBkID8gdGhpcy5zY2FsZS5zdWJYKGQueCkgOiBudWxsO1xyXG5cdH1cclxuXHJcblx0dHJhbnNmb3JtTWFpbih3aXRoVHJhbnNpdGlvbiwgdHJhbnNpdGlvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHttYWlufSA9ICQkLiRlbDtcclxuXHRcdGxldCB4QXhpcztcclxuXHRcdGxldCB5QXhpcztcclxuXHRcdGxldCB5MkF4aXM7XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNYKSB7XHJcblx0XHRcdHhBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1g7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR4QXhpcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWH1gKTtcclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdHhBeGlzID0geEF4aXMudHJhbnNpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNZKSB7XHJcblx0XHRcdHlBeGlzID0gdHJhbnNpdGlvbnMuYXhpc1k7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR5QXhpcyA9IG1haW4uc2VsZWN0KGAuJHtDTEFTUy5heGlzWX1gKTtcclxuXHJcblx0XHRcdGlmICh3aXRoVHJhbnNpdGlvbikge1xyXG5cdFx0XHRcdHlBeGlzID0geUF4aXMudHJhbnNpdGlvbigpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRyYW5zaXRpb25zICYmIHRyYW5zaXRpb25zLmF4aXNZMikge1xyXG5cdFx0XHR5MkF4aXMgPSB0cmFuc2l0aW9ucy5heGlzWTI7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR5MkF4aXMgPSBtYWluLnNlbGVjdChgLiR7Q0xBU1MuYXhpc1kyfWApO1xyXG5cclxuXHRcdFx0aWYgKHdpdGhUcmFuc2l0aW9uKSB7XHJcblx0XHRcdFx0eTJBeGlzID0geTJBeGlzLnRyYW5zaXRpb24oKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdCh3aXRoVHJhbnNpdGlvbiA/IG1haW4udHJhbnNpdGlvbigpIDogbWFpbilcclxuXHRcdFx0LmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwibWFpblwiKSk7XHJcblxyXG5cdFx0eEF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ4XCIpKTtcclxuXHRcdHlBeGlzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgJCQuZ2V0VHJhbnNsYXRlKFwieVwiKSk7XHJcblx0XHR5MkF4aXMuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJ5MlwiKSk7XHJcblxyXG5cdFx0bWFpbi5zZWxlY3QoYC4ke0NMQVNTLmNoYXJ0QXJjc31gKVxyXG5cdFx0XHQuYXR0cihcInRyYW5zZm9ybVwiLCAkJC5nZXRUcmFuc2xhdGUoXCJhcmNcIikpO1xyXG5cdH1cclxuXHJcblx0dHJhbnNmb3JtQWxsKHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsfSA9ICQkO1xyXG5cclxuXHRcdCQkLnRyYW5zZm9ybU1haW4od2l0aFRyYW5zaXRpb24sIHRyYW5zaXRpb25zKTtcclxuXHJcblx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyAmJlxyXG5cdFx0XHQkJC50cmFuc2Zvcm1Db250ZXh0KHdpdGhUcmFuc2l0aW9uLCB0cmFuc2l0aW9ucyk7XHJcblxyXG5cdFx0JGVsLmxlZ2VuZCAmJiAkJC50cmFuc2Zvcm1MZWdlbmQod2l0aFRyYW5zaXRpb24pO1xyXG5cdH1cclxuXHJcblx0dXBkYXRlU3ZnU2l6ZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtzdGF0ZSwgJGVsOiB7c3ZnfX0gPSAkJDtcclxuXHRcdGNvbnN0IGJydXNoID0gc3ZnLnNlbGVjdChgLiR7Q0xBU1MuYnJ1c2h9IC5vdmVybGF5YCk7XHJcblx0XHRjb25zdCBicnVzaFNpemUgPSB7d2lkdGg6IDAsIGhlaWdodDogMH07XHJcblxyXG5cdFx0aWYgKGJydXNoLnNpemUoKSkge1xyXG5cdFx0XHRicnVzaFNpemUud2lkdGggPSArYnJ1c2guYXR0cihcIndpZHRoXCIpO1xyXG5cdFx0XHRicnVzaFNpemUuaGVpZ2h0ID0gK2JydXNoLmF0dHIoXCJoZWlnaHRcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0c3ZnXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUuY3VycmVudFdpZHRoKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCBzdGF0ZS5jdXJyZW50SGVpZ2h0KTtcclxuXHJcblx0XHRzdmcuc2VsZWN0QWxsKFtgIyR7c3RhdGUuY2xpcC5pZH1gLCBgIyR7c3RhdGUuY2xpcC5pZEdyaWR9YF0pXHJcblx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwid2lkdGhcIiwgc3RhdGUud2lkdGgpXHJcblx0XHRcdC5hdHRyKFwiaGVpZ2h0XCIsIHN0YXRlLmhlaWdodCk7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdChgIyR7c3RhdGUuY2xpcC5pZFhBeGlzfWApXHJcblx0XHRcdC5zZWxlY3QoXCJyZWN0XCIpXHJcblx0XHRcdC5hdHRyKFwieFwiLCAkJC5nZXRYQXhpc0NsaXBYLmJpbmQoJCQpKVxyXG5cdFx0XHQuYXR0cihcInlcIiwgJCQuZ2V0WEF4aXNDbGlwWS5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCAkJC5nZXRYQXhpc0NsaXBXaWR0aC5iaW5kKCQkKSlcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgJCQuZ2V0WEF4aXNDbGlwSGVpZ2h0LmJpbmQoJCQpKTtcclxuXHJcblx0XHRzdmcuc2VsZWN0KGAjJHtzdGF0ZS5jbGlwLmlkWUF4aXN9YClcclxuXHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJ4XCIsICQkLmdldFlBeGlzQ2xpcFguYmluZCgkJCkpXHJcblx0XHRcdC5hdHRyKFwieVwiLCAkJC5nZXRZQXhpc0NsaXBZLmJpbmQoJCQpKVxyXG5cdFx0XHQuYXR0cihcIndpZHRoXCIsICQkLmdldFlBeGlzQ2xpcFdpZHRoLmJpbmQoJCQpKVxyXG5cdFx0XHQuYXR0cihcImhlaWdodFwiLCAkJC5nZXRZQXhpc0NsaXBIZWlnaHQuYmluZCgkJCkpO1xyXG5cclxuXHRcdHN0YXRlLmNsaXAuaWRTdWJjaGFydCAmJiBzdmcuc2VsZWN0KGAjJHtzdGF0ZS5jbGlwLmlkU3ViY2hhcnR9YClcclxuXHRcdFx0LnNlbGVjdChcInJlY3RcIilcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBzdGF0ZS53aWR0aClcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgYnJ1c2hTaXplLmhlaWdodCk7XHJcblxyXG5cdFx0c3ZnLnNlbGVjdChgLiR7Q0xBU1Muem9vbVJlY3R9YClcclxuXHRcdFx0LmF0dHIoXCJ3aWR0aFwiLCBzdGF0ZS53aWR0aClcclxuXHRcdFx0LmF0dHIoXCJoZWlnaHRcIiwgc3RhdGUuaGVpZ2h0KTtcclxuXHR9XHJcblxyXG5cdHVwZGF0ZURpbWVuc2lvbih3aXRob3V0QXhpcykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgJGVsOiB7YXhpc319ID0gJCQ7XHJcblxyXG5cdFx0aWYgKCF3aXRob3V0QXhpcykge1xyXG5cdFx0XHRpZiAoJCQuYXhpcy54ICYmIGNvbmZpZy5heGlzX3JvdGF0ZWQpIHtcclxuXHRcdFx0XHQkJC5heGlzLnguY3JlYXRlKGF4aXMueCk7XHJcblx0XHRcdFx0JCQuYXhpcy5zdWJYLmNyZWF0ZShheGlzLnN1YlgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdCQkLmF4aXMueSAmJiAkJC5heGlzLnkuY3JlYXRlKGF4aXMueSk7XHJcblx0XHRcdFx0JCQuYXhpcy55MiAmJiAkJC5heGlzLnkyLmNyZWF0ZShheGlzLnkyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHBhc3MgJ3dpdGhvdXRBeGlzJyBwYXJhbSB0byBub3QgYW5pbWF0ZSBhdCB0aGUgaW5pdCByZW5kZXJpbmdcclxuXHRcdCQkLnVwZGF0ZVNjYWxlcyh3aXRob3V0QXhpcyk7XHJcblx0XHQkJC51cGRhdGVTdmdTaXplKCk7XHJcblx0XHQkJC50cmFuc2Zvcm1BbGwoZmFsc2UpO1xyXG5cdH1cclxuXHJcblx0YmluZFJlc2l6ZSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcztcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdFx0JCQucmVzaXplRnVuY3Rpb24gPSAkJC5nZW5lcmF0ZVJlc2l6ZSgpO1xyXG5cdFx0JCQucmVzaXplRnVuY3Rpb24uYWRkKCgpID0+IGNhbGxGbihjb25maWcub25yZXNpemUsICQkLCAkJC5hcGkpKTtcclxuXHJcblx0XHRpZiAoY29uZmlnLnJlc2l6ZV9hdXRvKSB7XHJcblx0XHRcdCQkLnJlc2l6ZUZ1bmN0aW9uLmFkZCgoKSA9PiB7XHJcblx0XHRcdFx0aWYgKCQkLnJlc2l6ZVRpbWVvdXQpIHtcclxuXHRcdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoJCQucmVzaXplVGltZW91dCk7XHJcblx0XHRcdFx0XHQkJC5yZXNpemVUaW1lb3V0ID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdCQkLnJlc2l6ZVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcblx0XHRcdFx0XHQkJC5hcGkuZmx1c2goZmFsc2UsIHRydWUpO1xyXG5cdFx0XHRcdH0sIDIwMCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlc2l6ZUZ1bmN0aW9uLmFkZCgoKSA9PiBjYWxsRm4oY29uZmlnLm9ucmVzaXplZCwgJCQsICQkLmFwaSkpO1xyXG5cclxuXHRcdC8vIGF0dGFjaCByZXNpemUgZXZlbnRcclxuXHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsICQkLnJlc2l6ZUZ1bmN0aW9uKTtcclxuXHR9XHJcblxyXG5cdGdlbmVyYXRlUmVzaXplKCkge1xyXG5cdFx0Y29uc3QgcmVzaXplRnVuY3Rpb25zID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gY2FsbFJlc2l6ZUZ1bmN0aW9ucygpIHtcclxuXHRcdFx0cmVzaXplRnVuY3Rpb25zLmZvckVhY2goZiA9PiBmKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMuYWRkID0gZiA9PiByZXNpemVGdW5jdGlvbnMucHVzaChmKTtcclxuXHRcdGNhbGxSZXNpemVGdW5jdGlvbnMucmVtb3ZlID0gZiA9PiByZXNpemVGdW5jdGlvbnMuc3BsaWNlKHJlc2l6ZUZ1bmN0aW9ucy5pbmRleE9mKGYpLCAxKTtcclxuXHJcblx0XHRyZXR1cm4gY2FsbFJlc2l6ZUZ1bmN0aW9ucztcclxuXHR9XHJcblxyXG5cdGVuZGFsbCh0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xyXG5cdFx0bGV0IG4gPSAwO1xyXG5cclxuXHRcdHRyYW5zaXRpb25cclxuXHRcdFx0LmVhY2goKCkgPT4gKytuKVxyXG5cdFx0XHQub24oXCJlbmRcIiwgZnVuY3Rpb24oLi4uYXJncykge1xyXG5cdFx0XHRcdCEtLW4gJiYgY2FsbGJhY2suYXBwbHkodGhpcywgLi4uYXJncyk7XHJcblx0XHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Z2VuZXJhdGVXYWl0KCkge1xyXG5cdFx0bGV0IHRyYW5zaXRpb25zVG9XYWl0ID0gW107XHJcblx0XHRjb25zdCBmID0gZnVuY3Rpb24odCwgY2FsbGJhY2spIHtcclxuXHRcdFx0bGV0IHRpbWVyO1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gbG9vcCgpIHtcclxuXHRcdFx0XHRsZXQgZG9uZSA9IDA7XHJcblxyXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwLCB0OyAodCA9IHRyYW5zaXRpb25zVG9XYWl0W2ldKTsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZiAodC5lbXB0eSgpKSB7XHJcblx0XHRcdFx0XHRcdGRvbmUrKztcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0dC50cmFuc2l0aW9uKCk7XHJcblx0XHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRcdGRvbmUrKztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XHJcblxyXG5cdFx0XHRcdGlmIChkb25lID09PSB0cmFuc2l0aW9uc1RvV2FpdC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dChsb29wLCA1MCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRsb29wKCk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGYuYWRkID0gZnVuY3Rpb24odCkge1xyXG5cdFx0XHRpc0FycmF5KHQpID9cclxuXHRcdFx0XHQodHJhbnNpdGlvbnNUb1dhaXQgPSB0cmFuc2l0aW9uc1RvV2FpdC5jb25jYXQodCkpIDpcclxuXHRcdFx0XHR0cmFuc2l0aW9uc1RvV2FpdC5wdXNoKHQpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gZjtcclxuXHR9XHJcblxyXG5cdHBhcnNlRGF0ZShkYXRlOiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyKTogRGF0ZSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRsZXQgcGFyc2VkRGF0ZTtcclxuXHJcblx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdFx0cGFyc2VkRGF0ZSA9IGRhdGU7XHJcblx0XHR9IGVsc2UgaWYgKGlzU3RyaW5nKGRhdGUpKSB7XHJcblx0XHRcdHBhcnNlZERhdGUgPSAkJC5mb3JtYXQuZGF0YVRpbWUoJCQuY29uZmlnLmRhdGFfeEZvcm1hdCkoZGF0ZSk7XHJcblx0XHR9IGVsc2UgaWYgKGlzTnVtYmVyKGRhdGUpICYmICFpc05hTihkYXRlKSkge1xyXG5cdFx0XHRwYXJzZWREYXRlID0gbmV3IERhdGUoK2RhdGUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghcGFyc2VkRGF0ZSB8fCBpc05hTigrcGFyc2VkRGF0ZSkpIHtcclxuXHRcdFx0Y29uc29sZSAmJiBjb25zb2xlLmVycm9yICYmXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHBhcnNlIHggJyR7ZGF0ZX0nIHRvIERhdGUgb2JqZWN0YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhcnNlZERhdGU7XHJcblx0fVxyXG5cclxuXHRpc1RhYlZpc2libGUoKSB7XHJcblx0XHRyZXR1cm4gIWRvY3VtZW50LmhpZGRlbjtcclxuXHR9XHJcblxyXG5cdGNvbnZlcnRJbnB1dFR5cGUoKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXM7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cdFx0bGV0IGlzTW9iaWxlID0gZmFsc2U7XHJcblxyXG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9Ccm93c2VyX2RldGVjdGlvbl91c2luZ190aGVfdXNlcl9hZ2VudCNNb2JpbGVfVGFibGV0X29yX0Rlc2t0b3BcclxuXHRcdGlmICgvTW9iaS8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgY29uZmlnLmludGVyYWN0aW9uX2lucHV0VHlwZV90b3VjaCkge1xyXG5cdFx0XHQvLyBTb21lIEVkZ2UgZGVza3RvcCByZXR1cm4gdHJ1ZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMjA0MTcwNzQvXHJcblx0XHRcdGNvbnN0IGhhc1RvdWNoUG9pbnRzID0gd2luZG93Lm5hdmlnYXRvciAmJiBcIm1heFRvdWNoUG9pbnRzXCIgaW4gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcclxuXHJcblx0XHRcdC8vIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL3RvdWNoZXZlbnRzLmpzXHJcblx0XHRcdC8vIE9uIElFMTEgd2l0aCBJRTkgZW11bGF0aW9uIG1vZGUsICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpIGlzIHJldHVybmluZyB0cnVlXHJcblx0XHRcdGNvbnN0IGhhc1RvdWNoID0gKFwib250b3VjaG1vdmVcIiBpbiB3aW5kb3cgfHwgKHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpKTtcclxuXHJcblx0XHRcdGlzTW9iaWxlID0gaGFzVG91Y2hQb2ludHMgfHwgaGFzVG91Y2g7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaGFzTW91c2UgPSBjb25maWcuaW50ZXJhY3Rpb25faW5wdXRUeXBlX21vdXNlICYmICFpc01vYmlsZSA/IChcIm9ubW91c2VvdmVyXCIgaW4gd2luZG93KSA6IGZhbHNlO1xyXG5cclxuXHRcdHJldHVybiAoaGFzTW91c2UgJiYgXCJtb3VzZVwiKSB8fCAoaXNNb2JpbGUgJiYgXCJ0b3VjaFwiKSB8fCBudWxsO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbCBwbHVnaW4gaG9va1xyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBwaGFzZSBUaGUgbGlmZWN5Y2xlIHBoYXNlXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRjYWxsUGx1Z2luSG9vayhwaGFzZSwgLi4uYXJncykge1xyXG5cdFx0dGhpcy5jb25maWcucGx1Z2lucy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRpZiAocGhhc2UgPT09IFwiJGJlZm9yZUluaXRcIikge1xyXG5cdFx0XHRcdHYuJCQgPSB0aGlzO1xyXG5cdFx0XHRcdHRoaXMuYXBpLnBsdWdpbnMucHVzaCh2KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dltwaGFzZV0oLi4uYXJncyk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn1cclxuXHJcbmV4dGVuZChDaGFydEludGVybmFsLnByb3RvdHlwZSwgW1xyXG5cdGRhdGFDb252ZXJ0LFxyXG5cdGRhdGEsXHJcblx0ZGF0YUxvYWQsXHJcblx0ZHJhZyxcclxuXHRmbG93LFxyXG5cdGludGVyYWN0aW9uLFxyXG5cdHN1YmNoYXJ0LFxyXG5cdHpvb20sXHJcblx0Y2F0ZWdvcnksXHJcblx0Y2xhc3NNb2R1bGUsXHJcblx0Y2xpcCxcclxuXHRjb2xvcixcclxuXHRkb21haW4sXHJcblx0Zm9ybWF0LFxyXG5cdGdyaWQsXHJcblx0bGVnZW5kLFxyXG5cdHJlZ2lvbixcclxuXHRzY2FsZSxcclxuXHRzZWxlY3Rpb24sXHJcblx0c2l6ZSxcclxuXHR0ZXh0LFxyXG5cdHRpdGxlLFxyXG5cdHRvb2x0aXAsXHJcblx0dHlwZSxcclxuXHRhcmMsXHJcblx0YmFyLFxyXG5cdGJ1YmJsZSxcclxuXHRsaW5lLFxyXG5cdHBvaW50LFxyXG5cdHJhZGFyLFxyXG5cdHNoYXBlXHJcbl0pO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNEZWZpbmVkLCBpc09iamVjdFR5cGV9IGZyb20gXCIuLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IHtsb2FkQ29uZmlnfTtcclxuXHJcbi8qKlxyXG4gKiBMb2FkIGNvbmZpZ3VyYXRpb24gb3B0aW9uXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVXNlcidzIGdlbmVyYXRpb24gY29uZmlnIHZhbHVlXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkQ29uZmlnKGNvbmZpZykge1xyXG5cdGNvbnN0IHRoaXNDb25maWcgPSB0aGlzLmNvbmZpZztcclxuXHRsZXQgdGFyZ2V0O1xyXG5cdGxldCBrZXlzO1xyXG5cdGxldCByZWFkO1xyXG5cclxuXHRjb25zdCBmaW5kID0gKCkgPT4ge1xyXG5cdFx0Y29uc3Qga2V5ID0ga2V5cy5zaGlmdCgpO1xyXG5cclxuXHRcdGlmIChrZXkgJiYgdGFyZ2V0ICYmIGlzT2JqZWN0VHlwZSh0YXJnZXQpICYmIGtleSBpbiB0YXJnZXQpIHtcclxuXHRcdFx0dGFyZ2V0ID0gdGFyZ2V0W2tleV07XHJcblx0XHRcdHJldHVybiBmaW5kKCk7XHJcblx0XHR9IGVsc2UgaWYgKCFrZXkpIHtcclxuXHRcdFx0cmV0dXJuIHRhcmdldDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH07XHJcblxyXG5cdE9iamVjdC5rZXlzKHRoaXNDb25maWcpLmZvckVhY2goa2V5ID0+IHtcclxuXHRcdHRhcmdldCA9IGNvbmZpZztcclxuXHRcdGtleXMgPSBrZXkuc3BsaXQoXCJfXCIpO1xyXG5cdFx0cmVhZCA9IGZpbmQoKTtcclxuXHJcblx0XHRpZiAoaXNEZWZpbmVkKHJlYWQpKSB7XHJcblx0XHRcdHRoaXNDb25maWdba2V5XSA9IHJlYWQ7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzVmFsdWUsIGlzRGVmaW5lZCwgaXNPYmplY3RUeXBlfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG1pbi9tYXggdmFsdWVcclxuICogQHBhcmFtIHtDaGFydH0gJCRcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXHJcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHNldE1pbk1heCgkJCwgdHlwZTogXCJtaW5cIiB8IFwibWF4XCIsIHZhbHVlKSB7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRjb25zdCBheGlzWCA9IGBheGlzX3hfJHt0eXBlfWA7XHJcblx0Y29uc3QgYXhpc1kgPSBgYXhpc195XyR7dHlwZX1gO1xyXG5cdGNvbnN0IGF4aXNZMiA9IGBheGlzX3kyXyR7dHlwZX1gO1xyXG5cclxuXHRpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG5cdFx0aWYgKGlzT2JqZWN0VHlwZSh2YWx1ZSkpIHtcclxuXHRcdFx0aXNWYWx1ZSh2YWx1ZS54KSAmJiAoY29uZmlnW2F4aXNYXSA9IHZhbHVlLngpO1xyXG5cdFx0XHRpc1ZhbHVlKHZhbHVlLnkpICYmIChjb25maWdbYXhpc1ldID0gdmFsdWUueSk7XHJcblx0XHRcdGlzVmFsdWUodmFsdWUueTIpICYmIChjb25maWdbYXhpc1kyXSA9IHZhbHVlLnkyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNvbmZpZ1theGlzWV0gPSB2YWx1ZTtcclxuXHRcdFx0Y29uZmlnW2F4aXNZMl0gPSB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWVcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCB0aGUgbWluL21heCB2YWx1ZVxyXG4gKiBAcGFyYW0ge0NoYXJ0fSAkJFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gKiBAcmV0dXJuIHt7eCwgeSwgeTJ9fVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0TWluTWF4KCQkLCB0eXBlOiBcIm1pblwiIHwgXCJtYXhcIik6IHt4OiBudW1iZXIsIHk6IG51bWJlciwgeTI6IG51bWJlcn0ge1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCQ7XHJcblxyXG5cdHJldHVybiB7XHJcblx0XHR4OiBjb25maWdbYGF4aXNfeF8ke3R5cGV9YF0sXHJcblx0XHR5OiBjb25maWdbYGF4aXNfeV8ke3R5cGV9YF0sXHJcblx0XHR5MjogY29uZmlnW2BheGlzX3kyXyR7dHlwZX1gXVxyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgYXhpc1xyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jb25zdCBheGlzID0ge1xyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbGFiZWxzLlxyXG5cdCAqIEBtZXRob2QgYXhpc+KApGxhYmVsc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsYWJlbHMgc3BlY2lmaWVkIGF4aXMnIGxhYmVsIHRvIGJlIHVwZGF0ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBVcGRhdGUgYXhpcycgbGFiZWxcclxuXHQgKiBjaGFydC5heGlzLmxhYmVscyh7XHJcblx0ICogICB4OiBcIk5ldyBYIEF4aXMgTGFiZWxcIixcclxuXHQgKiAgIHk6IFwiTmV3IFkgQXhpcyBMYWJlbFwiXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bGFiZWxzOiBmdW5jdGlvbihsYWJlbHM6IHt4Pzogc3RyaW5nLCB5Pzogc3RyaW5nLCB5Mj86IHN0cmluZ30pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRPYmplY3Qua2V5cyhsYWJlbHMpLmZvckVhY2goYXhpc0lkID0+IHtcclxuXHRcdFx0XHQkJC5heGlzLnNldExhYmVsVGV4dChheGlzSWQsIGxhYmVsc1theGlzSWRdKTtcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHQkJC5heGlzLnVwZGF0ZUxhYmVscygpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IGF4aXMgbWluIHZhbHVlLlxyXG5cdCAqIEBtZXRob2QgYXhpc+KApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBtaW4gSWYgbWluIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIHZhbHVlIHdpbGwgYmUgdXBkYXRlZC48YnI+XHJcblx0ICogICAgIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGUgbWluIHZhbHVlcyBzZXQgb24gZ2VuZXJhdGluZyBvcHRpb24gZm9yIGVhY2ggYXhpcyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICAgICBJZiBub3Qgc2V0IGFueSBtaW4gdmFsdWVzIG9uIGdlbmVyYXRpb24sIGl0IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gVXBkYXRlIGF4aXMnIG1pblxyXG5cdCAqIGNoYXJ0LmF4aXMubWluKHtcclxuXHQgKiAgIHg6IC0xMCxcclxuXHQgKiAgIHk6IDEwMDAsXHJcblx0ICogICB5MjogMTAwXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbihtaW4/OiBudW1iZXIpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHJcblx0XHRyZXR1cm4gaXNWYWx1ZShtaW4pID9cclxuXHRcdFx0c2V0TWluTWF4KCQkLCBcIm1pblwiLCBtaW4pIDpcclxuXHRcdFx0Z2V0TWluTWF4KCQkLCBcIm1pblwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1heCB2YWx1ZS5cclxuXHQgKiBAbWV0aG9kIGF4aXPigKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbWF4IElmIG1heCBpcyBnaXZlbiwgc3BlY2lmaWVkIGF4aXMnIG1heCB2YWx1ZSB3aWxsIGJlIHVwZGF0ZWQuPGJyPlxyXG5cdCAqICAgICBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG1heCB2YWx1ZXMgc2V0IG9uIGdlbmVyYXRpbmcgb3B0aW9uIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiAgICAgSWYgbm90IHNldCBhbnkgbWF4IHZhbHVlcyBvbiBnZW5lcmF0aW9uLCBpdCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMubWF4KHtcclxuXHQgKiAgICB4OiAxMDAsXHJcblx0ICogICAgeTogMTAwMCxcclxuXHQgKiAgICB5MjogMTAwMDBcclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKG1heD86IG51bWJlcikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID9cclxuXHRcdFx0c2V0TWluTWF4KCQkLCBcIm1heFwiLCBtYXgpIDpcclxuXHRcdFx0Z2V0TWluTWF4KCQkLCBcIm1heFwiKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBheGlzIG1pbiBhbmQgbWF4IHZhbHVlLlxyXG5cdCAqIEBtZXRob2QgYXhpc+KApHJhbmdlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHJhbmdlIElmIHJhbmdlIGlzIGdpdmVuLCBzcGVjaWZpZWQgYXhpcycgbWluIGFuZCBtYXggdmFsdWUgd2lsbCBiZSB1cGRhdGVkLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGN1cnJlbnQgbWluIGFuZCBtYXggdmFsdWVzIGZvciBlYWNoIGF4aXMgd2lsbCBiZSByZXR1cm5lZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIFVwZGF0ZSBheGlzJyBsYWJlbFxyXG5cdCAqIGNoYXJ0LmF4aXMucmFuZ2Uoe1xyXG5cdCAqICAgbWluOiB7XHJcblx0ICogICAgIHg6IC0xMCxcclxuXHQgKiAgICAgeTogLTEwMDAsXHJcblx0ICogICAgIHkyOiAtMTAwMDBcclxuXHQgKiAgIH0sXHJcblx0ICogICBtYXg6IHtcclxuXHQgKiAgICAgeDogMTAwLFxyXG5cdCAqICAgICB5OiAxMDAwLFxyXG5cdCAqICAgICB5MjogMTAwMDBcclxuXHQgKiAgIH0sXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0cmFuZ2U6IGZ1bmN0aW9uKHJhbmdlKSB7XHJcblx0XHRjb25zdCBheGlzID0gdGhpcy5heGlzO1xyXG5cclxuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XHJcblx0XHRcdGlzRGVmaW5lZChyYW5nZS5tYXgpICYmIGF4aXMubWF4KHJhbmdlLm1heCk7XHJcblx0XHRcdGlzRGVmaW5lZChyYW5nZS5taW4pICYmIGF4aXMubWluKHJhbmdlLm1pbik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdG1heDogYXhpcy5tYXgoKSxcclxuXHRcdFx0XHRtaW46IGF4aXMubWluKClcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtheGlzfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogU2V0IHNwZWNpZmllZCBjYXRlZ29yeSBuYW1lIG9uIGNhdGVnb3J5IGF4aXMuXHJcblx0ICogQG1ldGhvZCBjYXRlZ29yeVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpIGluZGV4IG9mIGNhdGVnb3J5IHRvIGJlIGNoYW5nZWRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gY2F0ZWdvcnkgY2F0ZWdvcnkgdmFsdWUgdG8gYmUgY2hhbmdlZFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY2F0ZWdvcnkoMiwgXCJDYXRlZ29yeSAzXCIpO1xyXG5cdCAqL1xyXG5cdGNhdGVnb3J5KGk6IG51bWJlciwgY2F0ZWdvcnk6IHN0cmluZykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHJcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzW2ldID0gY2F0ZWdvcnk7XHJcblx0XHRcdCQkLnJlZHJhdygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb25maWcuYXhpc194X2NhdGVnb3JpZXNbaV07XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IGNhdGVnb3J5IG5hbWVzIG9uIGNhdGVnb3J5IGF4aXMuXHJcblx0ICogQG1ldGhvZCBjYXRlZ29yaWVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gY2F0ZWdvcmllcyBUaGlzIG11c3QgYmUgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBjYXRlZ29yeSBuYW1lcyBpbiBzdHJpbmcuIElmIGNhdGVnb3J5IG5hbWVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgZGF0ZSBieSBkYXRhLnggb3B0aW9uLCB0aGlzIGlzIG5vdCByZXF1aXJlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIGNoYXJ0LmNhdGVnb3JpZXMoW1xyXG5cdCAqICAgICAgXCJDYXRlZ29yeSAxXCIsIFwiQ2F0ZWdvcnkgMlwiLCAuLi5cclxuXHQgKiBdKTtcclxuXHQgKi9cclxuXHRjYXRlZ29yaWVzKGNhdGVnb3JpZXM6IHN0cmluZ1tdKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkO1xyXG5cclxuXHRcdGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG5cdFx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy5heGlzX3hfY2F0ZWdvcmllcyA9IGNhdGVnb3JpZXM7XHJcblx0XHQkJC5yZWRyYXcoKTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3dpbmRvd30gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7bm90RW1wdHksIGlzRGVmaW5lZH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogUmVzaXplIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIHJlc2l6ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzaXplIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgd2lkdGggYW5kIGhlaWdodCBpbiBwaXhlbHMuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBSZXNpemUgdG8gNjQweDQ4MFxyXG5cdCAqIGNoYXJ0LnJlc2l6ZSh7XHJcblx0ICogICAgd2lkdGg6IDY0MCxcclxuXHQgKiAgICBoZWlnaHQ6IDQ4MFxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdHJlc2l6ZShzaXplPzoge3dpZHRoPzogbnVtYmVyLCBoZWlnaHQ/OiBudW1iZXJ9KSB7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9IHRoaXMuaW50ZXJuYWw7XHJcblxyXG5cdFx0Y29uZmlnLnNpemVfd2lkdGggPSBzaXplID8gc2l6ZS53aWR0aCA6IG51bGw7XHJcblx0XHRjb25maWcuc2l6ZV9oZWlnaHQgPSBzaXplID8gc2l6ZS5oZWlnaHQgOiBudWxsO1xyXG5cclxuXHRcdHRoaXMuZmx1c2goZmFsc2UsIHRydWUpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEZvcmNlIHRvIHJlZHJhdy5cclxuXHQgKiBAbWV0aG9kIGZsdXNoXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbc29mdF0gRm9yIHNvZnQgcmVkcmF3LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuZmx1c2goKTtcclxuXHQgKlxyXG5cdCAqIC8vIGZvciBzb2Z0IHJlZHJhd1xyXG5cdCAqIGNoYXJ0LmZsdXNoKHRydWUpO1xyXG5cdCAqL1xyXG5cdGZsdXNoKHNvZnQ/OiBib29sZWFuLCBfaXNGcm9tUmVzaXplPzogYm9vbGVhbikge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHJcblx0XHRpZiAoJCQuc3RhdGUucmVuZGVyZWQpIHtcclxuXHRcdFx0Ly8gcmVzZXQgcG9zc2libGUgem9vbSBzY2FsZSB3aGVuIGlzIGNhbGxlZCBmcm9tIHJlc2l6ZSBldmVudFxyXG5cdFx0XHRpZiAoX2lzRnJvbVJlc2l6ZSkge1xyXG5cdFx0XHRcdCQkLmJydXNoICYmICQkLmJydXNoLnVwZGF0ZVJlc2l6ZSgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHJlLXVwZGF0ZSBjb25maWcgaW5mb1xyXG5cdFx0XHRcdCQkLmF4aXMgJiYgJCQuYXhpcy5zZXRPcmllbnQoKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0JCQuc2NhbGUuem9vbSA9IG51bGw7XHJcblxyXG5cdFx0XHRzb2Z0ID8gJCQucmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoVHJhbnNmb3JtOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWVcclxuXHRcdFx0fSkgOiAkJC51cGRhdGVBbmRSZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhMZWdlbmQ6IHRydWUsXHJcblx0XHRcdFx0d2l0aFRyYW5zaXRpb246IGZhbHNlLFxyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uRm9yVHJhbnNmb3JtOiBmYWxzZSxcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQkJC5pbml0VG9SZW5kZXIodHJ1ZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVzZXQgdGhlIGNoYXJ0IG9iamVjdCBhbmQgcmVtb3ZlIGVsZW1lbnQgYW5kIGV2ZW50cyBjb21wbGV0ZWx5LlxyXG5cdCAqIEBtZXRob2QgZGVzdHJveVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuZGVzdHJveSgpO1xyXG5cdCAqL1xyXG5cdGRlc3Ryb3koKTogbnVsbCB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7JGVsfSA9ICQkO1xyXG5cclxuXHRcdGlmIChub3RFbXB0eSgkJCkpIHtcclxuXHRcdFx0JCQuY2FsbFBsdWdpbkhvb2soXCIkd2lsbERlc3Ryb3lcIik7XHJcblx0XHRcdCQkLmNoYXJ0cy5zcGxpY2UoJCQuY2hhcnRzLmluZGV4T2YodGhpcyksIDEpO1xyXG5cclxuXHRcdFx0Ly8gY2xlYXIgdGltZXJzICYmIHBlbmRpbmcgdHJhbnNpdGlvblxyXG5cdFx0XHQkZWwuc3ZnLnNlbGVjdChcIipcIikuaW50ZXJydXB0KCk7XHJcblx0XHRcdGlzRGVmaW5lZCgkJC5yZXNpemVUaW1lb3V0KSAmJiB3aW5kb3cuY2xlYXJUaW1lb3V0KCQkLnJlc2l6ZVRpbWVvdXQpO1xyXG5cclxuXHRcdFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgJCQucmVzaXplRnVuY3Rpb24pO1xyXG5cdFx0XHQkZWwuY2hhcnQuY2xhc3NlZChcImJiXCIsIGZhbHNlKS5odG1sKFwiXCIpO1xyXG5cclxuXHRcdFx0Ly8gcmVsZWFzaW5nIHJlZmVyZW5jZXNcclxuXHRcdFx0T2JqZWN0LmtleXModGhpcykuZm9yRWFjaChrZXkgPT4ge1xyXG5cdFx0XHRcdGtleSA9PT0gXCJpbnRlcm5hbFwiICYmIE9iamVjdC5rZXlzKCQkKS5mb3JFYWNoKGsgPT4ge1xyXG5cdFx0XHRcdFx0JCRba10gPSBudWxsO1xyXG5cdFx0XHRcdH0pO1xyXG5cclxuXHRcdFx0XHR0aGlzW2tleV0gPSBudWxsO1xyXG5cdFx0XHRcdGRlbGV0ZSB0aGlzW2tleV07XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBvciBzZXQgc2luZ2xlIGNvbmZpZyBvcHRpb24gdmFsdWUuXHJcblx0ICogQG1ldGhvZCBjb25maWdcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgb3B0aW9uIGtleSBuYW1lLlxyXG5cdCAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSBUaGUgdmFsdWUgYWNjZXB0ZWQgZm9yIGluZGljYXRlZCBvcHRpb24uXHJcblx0ICogQHBhcmFtIHtCb29sZWFufSBbcmVkcmF3XSBTZXQgdG8gcmVkcmF3IHdpdGggdGhlIG5ldyBvcHRpb24gY2hhbmdlcy5cclxuXHQgKiAtICoqTk9URToqKiBEb2Vzbid0IGd1YXJhbnRlZSB3b3JrIGluIGFsbCBjaXJjdW1zdGFuY2VzLiBJdCBjYW4gYmUgYXBwbGllZCBmb3IgbGltaXRlZCBvcHRpb25zIG9ubHkuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXR0ZXJcclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIik7XHJcblx0ICpcclxuXHQgKiAvLyBTZXR0ZXJcclxuXHQgKiBjaGFydC5jb25maWcoXCJnYXVnZS5tYXhcIiwgMTAwKTtcclxuXHQgKlxyXG5cdCAqIC8vIFNldHRlciAmIHJlZHJhdyB3aXRoIHRoZSBuZXcgb3B0aW9uXHJcblx0ICogY2hhcnQuY29uZmlnKFwiZ2F1Z2UubWF4XCIsIDEwMCwgdHJ1ZSk7XHJcblx0ICovXHJcblx0Y29uZmlnKG5hbWU6IHN0cmluZywgdmFsdWU/OiBhbnksIHJlZHJhdz86IGJvb2xlYW4pOiBhbnkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJDtcclxuXHRcdGNvbnN0IGtleSA9IG5hbWUgJiYgbmFtZS5yZXBsYWNlKC9cXC4vZywgXCJfXCIpO1xyXG5cdFx0bGV0IHJlcztcclxuXHJcblx0XHRpZiAoa2V5IGluIGNvbmZpZykge1xyXG5cdFx0XHRpZiAoaXNEZWZpbmVkKHZhbHVlKSkge1xyXG5cdFx0XHRcdGNvbmZpZ1trZXldID0gdmFsdWU7XHJcblx0XHRcdFx0cmVzID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdHJlZHJhdyAmJiB0aGlzLmZsdXNoKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzID0gY29uZmlnW2tleV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBjb2xvclxyXG5cdCAqIEBtZXRob2QgY29sb3JcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaWQgaWQgdG8gZ2V0IHRoZSBjb2xvclxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQuY29sb3IoXCJkYXRhMVwiKTtcclxuXHQgKi9cclxuXHRjb2xvcihpZDogc3RyaW5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC5jb2xvcihpZCk7IC8vIG1vcmUgcGF0dGVybnNcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtleHRlbmQsIGlzVW5kZWZpbmVkLCBpc0FycmF5fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBHZXQgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG4gKiBAbWV0aG9kIGRhdGFcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoaXMgQVBJIHJldHVybnMgdGhlIHNwZWNpZmllZCB0YXJnZXQgZGF0YS4gSWYgdGhpcyBhcmd1bWVudCBpcyBub3QgZ2l2ZW4sIGFsbCBvZiBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcclxuICogQGV4YW1wbGVcclxuICogLy8gR2V0IG9ubHkgZGF0YTEgZGF0YVxyXG4gKiBjaGFydC5kYXRhKFwiZGF0YTFcIik7XHJcbiAqIC8vIC0tPiBbe2lkOiBcImRhdGExXCIsIGlkX29yZzogXCJkYXRhMVwiLCB2YWx1ZXM6IEFycmF5KDYpfSwgLi4uXVxyXG4gKlxyXG4gKiAvLyBHZXQgZGF0YTEgYW5kIGRhdGEyIGRhdGFcclxuICogY2hhcnQuZGF0YShbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuICpcclxuICogLy8gR2V0IGFsbCBkYXRhXHJcbiAqIGNoYXJ0LmRhdGEoKTtcclxuICovXHJcbmZ1bmN0aW9uIGRhdGEodGFyZ2V0SWRzKSB7XHJcblx0Y29uc3QgdGFyZ2V0cyA9IHRoaXMuaW50ZXJuYWwuZGF0YS50YXJnZXRzO1xyXG5cclxuXHRpZiAoIWlzVW5kZWZpbmVkKHRhcmdldElkcykpIHtcclxuXHRcdGNvbnN0IGlkcyA9IGlzQXJyYXkodGFyZ2V0SWRzKSA/IHRhcmdldElkcyA6IFt0YXJnZXRJZHNdO1xyXG5cclxuXHRcdHJldHVybiB0YXJnZXRzLmZpbHRlcih0ID0+IGlkcy5zb21lKHYgPT4gdiA9PT0gdC5pZCkpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRhcmdldHM7XHJcbn1cclxuXHJcbmV4dGVuZChkYXRhLCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGRhdGEgc2hvd24gaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBtZXRob2QgZGF0YeKApHNob3duXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkcyBJZiB0aGlzIGFyZ3VtZW50IGlzIGdpdmVuLCB0aGlzIEFQSSBmaWx0ZXJzIHRoZSBkYXRhIHdpdGggc3BlY2lmaWVkIHRhcmdldCBpZHMuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBhbGwgc2hvd24gZGF0YSB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIG9ubHkgZGF0YTEgZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oXCJkYXRhMVwiKTtcclxuXHQgKiAvLyAtLT4gW3tpZDogXCJkYXRhMVwiLCBpZF9vcmc6IFwiZGF0YTFcIiwgdmFsdWVzOiBBcnJheSg2KX0sIC4uLl1cclxuXHQgKlxyXG5cdCAqIC8vIEdldCBzaG93biBkYXRhIGJ5IGZpbHRlcmluZyB0byBpbmNsdWRlIGRhdGExIGFuZCBkYXRhMiBkYXRhXHJcblx0ICogY2hhcnQuZGF0YS5zaG93bihbXCJkYXRhMVwiLCBcImRhdGEyXCJdKTtcclxuXHQgKlxyXG5cdCAqIC8vIEdldCBhbGwgc2hvd24gZGF0YVxyXG5cdCAqIGNoYXJ0LmRhdGEuc2hvd24oKTtcclxuXHQgKi9cclxuXHRzaG93bjogZnVuY3Rpb24odGFyZ2V0SWRzOiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZmlsdGVyVGFyZ2V0c1RvU2hvdyh0aGlzLmRhdGEodGFyZ2V0SWRzKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHZhbHVlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIEBtZXRob2QgZGF0YeKApHZhbHVlc1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHMgVGhpcyBBUEkgcmV0dXJucyB0aGUgdmFsdWVzIG9mIHNwZWNpZmllZCB0YXJnZXQuIElmIHRoaXMgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBudWxsIHdpbGwgYmUgcmV0cnVuZWRcclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSB2YWx1ZXNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBkYXRhMSB2YWx1ZXNcclxuXHQgKiBjaGFydC5kYXRhLnZhbHVlcyhcImRhdGExXCIpO1xyXG5cdCAqIC8vIC0tPiBbMTAsIDIwLCAzMCwgNDBdXHJcblx0ICovXHJcblx0dmFsdWVzOiBmdW5jdGlvbih0YXJnZXRJZD86IHN0cmluZyB8IHN0cmluZ1tdLCBmbGF0OiBib29sZWFuID0gdHJ1ZSkge1xyXG5cdFx0bGV0IHZhbHVlcztcclxuXHJcblx0XHRpZiAodGFyZ2V0SWQpIHtcclxuXHRcdFx0Y29uc3QgdGFyZ2V0cyA9IHRoaXMuZGF0YSh0YXJnZXRJZCk7XHJcblxyXG5cdFx0XHRpZiAodGFyZ2V0cyAmJiBpc0FycmF5KHRhcmdldHMpKSB7XHJcblx0XHRcdFx0dmFsdWVzID0gW107XHJcblxyXG5cdFx0XHRcdHRhcmdldHMuZm9yRWFjaCh2ID0+IHtcclxuXHRcdFx0XHRcdGNvbnN0IGRhdGFWYWx1ZSA9IHYudmFsdWVzLm1hcChkID0+IGQudmFsdWUpO1xyXG5cclxuXHRcdFx0XHRcdGZsYXQgPyAodmFsdWVzID0gdmFsdWVzLmNvbmNhdChkYXRhVmFsdWUpKSA6IHZhbHVlcy5wdXNoKGRhdGFWYWx1ZSk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWVzO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCBhbmQgc2V0IG5hbWVzIG9mIHRoZSBkYXRhIGxvYWRlZCBpbiB0aGUgY2hhcnQuXHJcblx0ICogQG1ldGhvZCBkYXRh4oCkbmFtZXNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gbmFtZXMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIG5hbWVzIG9mIGRhdGEgd2lsbCBiZSB1cGRhdGVkLiBJZiBub3QgZ2l2ZW4sIHRoZSBjdXJyZW50IG5hbWVzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhc1xyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ29ycmVzcG9uZGluZyBuYW1lcyBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZSwgaWYgc3BlY2lmaWVkIG5hbWVzIHZhbHVlcy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IG5hbWVzXHJcblx0ICogY2hhcnQuZGF0YS5uYW1lcygpO1xyXG5cdCAqIC8vIC0tPiB7ZGF0YTE6IFwidGVzdDFcIiwgZGF0YTI6IFwidGVzdDJcIn1cclxuXHQgKlxyXG5cdCAqIC8vIFVwZGF0ZSBuYW1lc1xyXG5cdCAqIGNoYXJ0LmRhdGEubmFtZXMoe1xyXG5cdCAqICBkYXRhMTogXCJOZXcgTmFtZSAxXCIsXHJcblx0ICogIGRhdGEyOiBcIk5ldyBOYW1lIDJcIlxyXG5cdCAqfSk7XHJcblx0ICovXHJcblx0bmFtZXM6IGZ1bmN0aW9uKG5hbWVzPzogQXJyYXk8eyBba2V5OiBzdHJpbmddOiBzdHJpbmc7IH0+KToge1trZXk6IHN0cmluZ106IHN0cmluZ30ge1xyXG5cdFx0dGhpcy5pbnRlcm5hbC5jbGVhckxlZ2VuZEl0ZW1UZXh0Qm94Y2FjaGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5pbnRlcm5hbC51cGRhdGVEYXRhQXR0cmlidXRlcyhcIm5hbWVzXCIsIG5hbWVzKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCBjb2xvcnMgb2YgdGhlIGRhdGEgbG9hZGVkIGluIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIGRhdGHigKRjb2xvcnNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIElmIHRoaXMgYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjb2xvcnMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgY29sb3JzIHdpbGwgYmUgcmV0dXJuZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBbZGF0YS5jb2xvcnNdKC4vT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0Y29sb3JzKS5cclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgZGF0YSBjb2xvciB2YWx1ZSBhY2NvcmRpbmcgaXRzIGtleSB2YWx1ZS5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IGNvbG9yc1xyXG5cdCAqIGNoYXJ0LmRhdGEuY29sb3JzKCk7XHJcblx0ICogLy8gLS0+IHtkYXRhMTogXCIjMDBjNzNjXCIsIGRhdGEyOiBcIiNmYTcxNzFcIn1cclxuXHQgKlxyXG5cdCAqIC8vIFVwZGF0ZSBjb2xvcnNcclxuXHQgKiBjaGFydC5kYXRhLmNvbG9ycyh7XHJcblx0ICogIGRhdGExOiBcIiNGRkZGRkZcIixcclxuXHQgKiAgZGF0YTI6IFwiIzAwMDAwMFwiXHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0Y29sb3JzOiBmdW5jdGlvbihjb2xvcnM/OiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZzsgfT4pIHtcclxuXHRcdHJldHVybiB0aGlzLmludGVybmFsLnVwZGF0ZURhdGFBdHRyaWJ1dGVzKFwiY29sb3JzXCIsIGNvbG9ycyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgYXhlcyBvZiB0aGUgZGF0YSBsb2FkZWQgaW4gdGhlIGNoYXJ0LlxyXG5cdCAqIC0gKipOT1RFOioqIElmIGFsbCBkYXRhIGlzIHJlbGF0ZWQgdG8gb25lIG9mIHRoZSBheGVzLCB0aGUgZG9tYWluIG9mIGF4aXMgd2l0aG91dCByZWxhdGVkIGRhdGEgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgZG9tYWluIGZyb20gdGhlIGF4aXMgd2l0aCByZWxhdGVkIGRhdGFcclxuXHQgKiBAbWV0aG9kIGRhdGHigKRheGVzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGF4ZXMgSWYgdGhpcyBhcmd1bWVudCBpcyBnaXZlbiwgdGhlIGF4ZXMgb2YgZGF0YSB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vdCBnaXZlbiwgdGhlIGN1cnJlbnQgYXhlcyB3aWxsIGJlIHJldHVybmVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXNcclxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IENvcnJlc3BvbmRpbmcgYXhlcyB2YWx1ZSBmb3IgZGF0YSwgaWYgc3BlY2lmaWVkIGF4ZXMgdmFsdWUuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5heGVzKCk7XHJcblx0ICogLy8gLS0+IHtkYXRhMTogXCJ5XCJ9XHJcblx0ICpcclxuXHQgKiAvLyBVcGRhdGUgYXhlc1xyXG5cdCAqIGNoYXJ0LmRhdGEuYXhlcyh7XHJcblx0ICogIGRhdGExOiBcInlcIixcclxuXHQgKiAgZGF0YTI6IFwieTJcIlxyXG5cdCAqIH0pO1xyXG5cdCAqL1xyXG5cdGF4ZXM6IGZ1bmN0aW9uKGF4ZXM/OiBBcnJheTx7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9Pik6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwudXBkYXRlRGF0YUF0dHJpYnV0ZXMoXCJheGVzXCIsIGF4ZXMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgbWluaW11bSBkYXRhIHZhbHVlIGJvdW5kIHRvIHRoZSBjaGFydFxyXG5cdCAqIEBtZXRob2QgZGF0YeKApG1pblxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSBEYXRhIG9iamVjdHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIEdldCBjdXJyZW50IGF4ZXNcclxuXHQgKiBjaGFydC5kYXRhLm1pbigpO1xyXG5cdCAqIC8vIC0tPiBbe3g6IDAsIHZhbHVlOiAzMCwgaWQ6IFwiZGF0YTFcIiwgaW5kZXg6IDB9LCAuLi5dXHJcblx0ICovXHJcblx0bWluOiBmdW5jdGlvbigpOiB7IHg6IG51bWJlciwgdmFsdWU6IG51bWJlciwgaWQ6IHN0cmluZywgaW5kZXg6IG51bWJlciB9W10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1pbjtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIG1heGltdW0gZGF0YSB2YWx1ZSBib3VuZCB0byB0aGUgY2hhcnRcclxuXHQgKiBAbWV0aG9kIGRhdGHigKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gRGF0YSBvYmplY3RzXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBHZXQgY3VycmVudCBheGVzXHJcblx0ICogY2hhcnQuZGF0YS5tYXgoKTtcclxuXHQgKiAvLyAtLT4gW3t4OiAzLCB2YWx1ZTogNDAwLCBpZDogXCJkYXRhMVwiLCBpbmRleDogM30sIC4uLl1cclxuXHQgKi9cclxuXHRtYXg6IGZ1bmN0aW9uKCk6IHt4OiBudW1iZXIsIHZhbHVlOiBudW1iZXIsIGlkOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9W10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW50ZXJuYWwuZ2V0TWluTWF4RGF0YSgpLm1heDtcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge2RhdGF9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7bmFtZXNwYWNlcyBhcyBkM05hbWVzcGFjZXN9IGZyb20gXCJkMy1zZWxlY3Rpb25cIjtcclxuaW1wb3J0IHtkb2N1bWVudH0gZnJvbSBcIi4uLy4uL21vZHVsZS9icm93c2VyXCI7XHJcbmltcG9ydCB7aXNGdW5jdGlvbiwgdG9BcnJheSwgZ2V0Q3NzUnVsZXN9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIEVuY29kZSB0byBiYXNlNjRcclxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcva28vZG9jcy9XZWIvQVBJL1dpbmRvd0Jhc2U2NC9CYXNlNjRfZW5jb2RpbmdfYW5kX2RlY29kaW5nXHJcbiAqL1xyXG5jb25zdCBiNjRFbmNvZGVVbmljb2RlID0gKHN0cjogc3RyaW5nKTogc3RyaW5nID0+IGJ0b2EoXHJcblx0ZW5jb2RlVVJJQ29tcG9uZW50KHN0cilcclxuXHRcdC5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCAobWF0Y2gsIHA6IG51bWJlciB8IHN0cmluZyk6IHN0cmluZyA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKE51bWJlcihgMHgke3B9YCkpKVxyXG4pO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnQgc3ZnIG5vZGUgdG8gZGF0YSB1cmxcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxyXG4gKiBAcGFyYW0ge29iamVjdH0gc2l6ZVxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBub2RlVG9TdmdEYXRhVXJsKG5vZGUsIHNpemUpIHtcclxuXHRjb25zdCBzZXJpYWxpemVyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcclxuXHRjb25zdCBjbG9uZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpO1xyXG5cdGNvbnN0IGNzc1RleHQgPSBnZXRDc3NSdWxlcyh0b0FycmF5KGRvY3VtZW50LnN0eWxlU2hlZXRzKSlcclxuXHRcdC5maWx0ZXIoKHI6IGFueSk6IGFueVtdID0+IHIuY3NzVGV4dClcclxuXHRcdC5tYXAoKHI6IGFueSk6IGFueVtdPT4gci5jc3NUZXh0KTtcclxuXHJcblx0Y2xvbmUuc2V0QXR0cmlidXRlKFwieG1sbnNcIiwgZDNOYW1lc3BhY2VzLnhodG1sKTtcclxuXHJcblx0Y29uc3Qgbm9kZVhtbCA9IHNlcmlhbGl6ZXIuc2VyaWFsaXplVG9TdHJpbmcoY2xvbmUpO1xyXG5cclxuXHQvLyBlc2NhcGUgY3NzIGZvciBYTUxcclxuXHRjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcclxuXHJcblx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzVGV4dC5qb2luKFwiXFxuXCIpKSk7XHJcblxyXG5cdGNvbnN0IHN0eWxlWG1sID0gc2VyaWFsaXplci5zZXJpYWxpemVUb1N0cmluZyhzdHlsZSk7XHJcblxyXG5cdC8vIGZvcmVpZ25PYmplY3Qgbm90IHN1cHBvcnRlZCBpbiBJRTExIGFuZCBiZWxvd1xyXG5cdC8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4MzQ2NzUodj12cy44NSkuYXNweFxyXG5cdGNvbnN0IGRhdGFTdHIgPSBgPHN2ZyB4bWxucz1cIiR7ZDNOYW1lc3BhY2VzLnN2Z31cIiB3aWR0aD1cIiR7c2l6ZS53aWR0aH1cIiBoZWlnaHQ9XCIke3NpemUuaGVpZ2h0fVwiPlxyXG5cdFx0XHQ8Zm9yZWlnbk9iamVjdCB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCI+XHJcblx0XHRcdFx0JHtzdHlsZVhtbH1cclxuXHRcdFx0XHQke25vZGVYbWwucmVwbGFjZSgvKHVybFxcKClbXiNdKy9nLCBcIiQxXCIpfVxyXG5cdFx0XHQ8L2ZvcmVpZ25PYmplY3Q+PC9zdmc+YFxyXG5cdFx0LnJlcGxhY2UoXCIvXFxuL2dcIiwgXCIlMEFcIik7XHJcblxyXG5cdHJldHVybiBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2I2NEVuY29kZVVuaWNvZGUoZGF0YVN0cil9YDtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIEV4cG9ydCBjaGFydCBhcyBhbiBpbWFnZS5cclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgLSBJRTExIGFuZCBiZWxvdyBub3Qgd29yayBwcm9wZXJseSBkdWUgdG8gdGhlIGxhY2sgb2YgdGhlIGZlYXR1cmUoPGEgaHJlZj1cImh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaGg4MzQ2NzUodj12cy44NSkuYXNweFwiPmZvcmVpZ25PYmplY3Q8L2E+KSBzdXBwb3J0XHJcblx0ICogICAtIFRoZSBiYXNpYyBDU1MgZmlsZShleC4gYmlsbGJvYXJkLmNzcykgc2hvdWxkIGJlIGF0IHNhbWUgZG9tYWluIGFzIEFQSSBjYWxsIGNvbnRleHQgdG8gZ2V0IGNvcnJlY3Qgc3R5bGVkIGV4cG9ydCBpbWFnZS5cclxuXHQgKiBAbWV0aG9kIGV4cG9ydFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBbbWltZVR5cGU9aW1hZ2UvcG5nXSBUaGUgZGVzaXJlZCBvdXRwdXQgaW1hZ2UgZm9ybWF0LiAoZXguICdpbWFnZS9wbmcnIGZvciBwbmcsICdpbWFnZS9qcGVnJyBmb3IganBlZyBmb3JtYXQpXHJcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBUaGUgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGV4cG9ydCBpcyByZWFkeS5cclxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGFVUklcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICBjaGFydC5leHBvcnQoKTtcclxuXHQgKiAgLy8gLS0+IFwiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4uLi5cIlxyXG5cdCAqXHJcblx0ICogIC8vIEluaXRpYWxpemUgdGhlIGRvd25sb2FkIGF1dG9tYXRpY2FsbHlcclxuXHQgKiAgY2hhcnQuZXhwb3J0KFwiaW1hZ2UvcG5nXCIsIGRhdGFVcmwgPT4ge1xyXG5cdCAqICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcblx0ICpcclxuXHQgKiAgICAgbGluay5kb3dubG9hZCA9IGAke0RhdGUubm93KCl9LnBuZ2A7XHJcblx0ICogICAgIGxpbmsuaHJlZiA9IGRhdGFVcmw7XHJcblx0ICogICAgIGxpbmsuaW5uZXJIVE1MID0gXCJEb3dubG9hZCBjaGFydCBhcyBpbWFnZVwiO1xyXG5cdCAqXHJcblx0ICogICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdGV4cG9ydChtaW1lVHlwZT86IHN0cmluZywgY2FsbGJhY2s/OiAoZGF0YVVybDogc3RyaW5nKSA9PiB2b2lkKTogc3RyaW5nIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjdXJyZW50V2lkdGgsIGN1cnJlbnRIZWlnaHR9ID0gJCQuc3RhdGU7XHJcblx0XHRjb25zdCBzaXplID0ge3dpZHRoOiBjdXJyZW50V2lkdGgsIGhlaWdodDogY3VycmVudEhlaWdodH07XHJcblx0XHRjb25zdCBzdmdEYXRhVXJsID0gbm9kZVRvU3ZnRGF0YVVybCh0aGlzLmVsZW1lbnQsIHNpemUpO1xyXG5cclxuXHRcdGlmIChjYWxsYmFjayAmJiBpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xyXG5cdFx0XHRjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuXHJcblx0XHRcdGltZy5jcm9zc09yaWdpbiA9IFwiQW5vbnltb3VzXCI7XHJcblx0XHRcdGltZy5vbmxvYWQgPSAoKSA9PiB7XHJcblx0XHRcdFx0Y29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcclxuXHRcdFx0XHRjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xyXG5cclxuXHRcdFx0XHRjYW52YXMud2lkdGggPSBzaXplLndpZHRoO1xyXG5cdFx0XHRcdGNhbnZhcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcclxuXHRcdFx0XHRjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XHJcblxyXG5cdFx0XHRcdGNhbGxiYWNrKGNhbnZhcy50b0RhdGFVUkwobWltZVR5cGUpKTtcclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGltZy5zcmMgPSBzdmdEYXRhVXJsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzdmdEYXRhVXJsO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzRGVmaW5lZCwgaXNWYWx1ZX0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogRmxvdyBkYXRhIHRvIHRoZSBjaGFydC48YnI+PGJyPlxyXG5cdCAqIEJ5IHRoaXMgQVBJLCB5b3UgY2FuIGFwcGVuZCBuZXcgZGF0YSBwb2ludHMgdG8gdGhlIGNoYXJ0LlxyXG5cdCAqIEBtZXRob2QgZmxvd1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhcmdzIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwganNvbiB8IE9iamVjdCB8IERhdGEgYXMgSlNPTiBmb3JtYXQgKEBzZWUgW2RhdGHigKRqc29uXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRqc29uKSkgfFxyXG5cdCAqICAgIHwgcm93cyB8IEFycmF5IHwgRGF0YSBpbiBhcnJheSBhcyByb3cgZm9ybWF0IChAc2VlIFtkYXRh4oCkcm93c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0anNvbikpIHxcclxuXHQgKiAgICB8IGNvbHVtbnMgfCBBcnJheSB8IERhdGEgaW4gYXJyYXkgYXMgY29sdW1uIGZvcm1hdCAoQHNlZSBbZGF0YeKApGNvbHVtbnNdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNGNvbHVtbnMpKSB8XHJcblx0ICogICAgfCB0byB8IFN0cmluZyB8IFRoZSBsb3dlciB4IGVkZ2Ugd2lsbCBtb3ZlIHRvIHRoYXQgcG9pbnQuIElmIG5vdCBnaXZlbiwgdGhlIGxvd2VyIHggZWRnZSB3aWxsIG1vdmUgYnkgdGhlIG51bWJlciBvZiBnaXZlbiBkYXRhIHBvaW50cyB8XHJcblx0ICogICAgfCBsZW5ndGggfCBOdW1iZXIgfCBUaGUgbG93ZXIgeCBlZGdlIHdpbGwgbW92ZSBieSB0aGUgbnVtYmVyIG9mIHRoaXMgYXJndW1lbnQgfFxyXG5cdCAqICAgIHwgZHVyYXRpb24gfCBOdW1iZXIgfCBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gd2lsbCBiZSBzcGVjaWZpZWQgdmFsdWUuIElmIG5vdCBnaXZlbiwgdHJhbnNpdGlvbi5kdXJhdGlvbiB3aWxsIGJlIHVzZWQgYXMgZGVmYXVsdCB8XHJcblx0ICogICAgfCBkb25lIHwgRnVuY3Rpb24gfCBUaGUgc3BlY2lmaWVkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gZmxvdyBlbmRzIHxcclxuXHQgKlxyXG5cdCAqIC0gKipOT1RFOioqXHJcblx0ICogICAtIElmIGpzb24sIHJvd3MgYW5kIGNvbHVtbnMgZ2l2ZW4sIHRoZSBkYXRhIHdpbGwgYmUgbG9hZGVkLlxyXG5cdCAqICAgLSBJZiBkYXRhIHRoYXQgaGFzIHRoZSBzYW1lIHRhcmdldCBpZCBpcyBnaXZlbiwgdGhlIGNoYXJ0IHdpbGwgYmUgYXBwZW5kZWQuXHJcblx0ICogICAtIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkLiBPbmUgb2YgdGhlc2UgaXMgcmVxdWlyZWQgd2hlbiBjYWxsaW5nLlxyXG5cdCAqICAgLSBJZiBqc29uIHNwZWNpZmllZCwga2V5cyBpcyByZXF1aXJlZCBhcyB3ZWxsIGFzIGRhdGEuanNvbi5cclxuXHQgKiBcdCAtIElmIHRhYiBpc24ndCB2aXNpYmxlKGJ5IGV2YWx1YXRpbmcgYGRvY3VtZW50LmhpZGRlbmApLCB3aWxsIG5vdCBiZSBleGVjdXRlZCB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHdvcmsuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyAyIGRhdGEgcG9pbnRzIHdpbGwgYmUgYXBwcmVuZGVkIHRvIHRoZSB0YWlsIGFuZCBwb3BwZWQgZnJvbSB0aGUgaGVhZC5cclxuXHQgKiAvLyBBZnRlciB0aGF0LCA0IGRhdGEgcG9pbnRzIHdpbGwgYmUgYXBwZW5kZWQgYW5kIG5vIGRhdGEgcG9pbnRzIHdpbGwgYmUgcG9wcG9lZC5cclxuXHQgKiBjaGFydC5mbG93KHtcclxuXHQgKiAgY29sdW1uczogW1xyXG5cdCAqICAgIFtcInhcIiwgXCIyMDE4LTAxLTExXCIsIFwiMjAxOC0wMS0yMVwiXSxcclxuXHQgKiAgICBbXCJkYXRhMVwiLCA1MDAsIDIwMF0sXHJcblx0ICogICAgW1wiZGF0YTJcIiwgMTAwLCAzMDBdLFxyXG5cdCAqICAgIFtcImRhdGEzXCIsIDIwMCwgMTIwXVxyXG5cdCAqICBdLFxyXG5cdCAqICB0bzogXCIyMDEzLTAxLTExXCIsXHJcblx0ICogIGRvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHQgKiAgICBjaGFydC5mbG93KHtcclxuXHQgKiAgICAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgICAgW1wieFwiLCBcIjIwMTgtMDItMTFcIiwgXCIyMDE4LTAyLTEyXCIsIFwiMjAxOC0wMi0xM1wiLCBcIjIwMTgtMDItMTRcIl0sXHJcblx0ICogICAgICAgIFtcImRhdGExXCIsIDIwMCwgMzAwLCAxMDAsIDI1MF0sXHJcblx0ICogICAgICAgIFtcImRhdGEyXCIsIDEwMCwgOTAsIDQwLCAxMjBdLFxyXG5cdCAqICAgICAgICBbXCJkYXRhM1wiLCAxMDAsIDEwMCwgMzAwLCA1MDBdXHJcblx0ICogICAgICBdLFxyXG5cdCAqICAgICAgbGVuZ3RoOiAyLFxyXG4gICAgICogICAgICBkdXJhdGlvbjogMTUwMFxyXG5cdCAqICAgIH0pO1xyXG5cdCAqICB9XHJcblx0ICogfSk7XHJcblx0ICovXHJcblx0ZmxvdyhhcmdzOiBhbnkpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGxldCBkYXRhO1xyXG5cdFx0bGV0IGRvbWFpbjtcclxuXHRcdGxldCBsZW5ndGg6IG51bWJlciA9IDA7XHJcblx0XHRsZXQgdGFpbCA9IDA7XHJcblx0XHRsZXQgZGlmZjtcclxuXHRcdGxldCB0bztcclxuXHJcblx0XHRpZiAoYXJncy5qc29uIHx8IGFyZ3Mucm93cyB8fCBhcmdzLmNvbHVtbnMpIHtcclxuXHRcdFx0ZGF0YSA9ICQkLmNvbnZlcnREYXRhKGFyZ3MpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICghZGF0YSB8fCAhJCQuaXNUYWJWaXNpYmxlKCkpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IG5vdGZvdW5kSWRzOiBzdHJpbmdbXSA9IFtdO1xyXG5cdFx0Y29uc3Qgb3JnRGF0YUNvdW50ID0gJCQuZ2V0TWF4RGF0YUNvdW50KCk7XHJcblx0XHRjb25zdCB0YXJnZXRzID0gJCQuY29udmVydERhdGFUb1RhcmdldHMoZGF0YSwgdHJ1ZSk7XHJcblxyXG5cdFx0Ly8gVXBkYXRlL0FkZCBkYXRhXHJcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodC5pZCA9PT0gdGFyZ2V0c1tpXS5pZCkge1xyXG5cdFx0XHRcdFx0Zm91bmQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICh0LnZhbHVlc1t0LnZhbHVlcy5sZW5ndGggLSAxXSkge1xyXG5cdFx0XHRcdFx0XHR0YWlsID0gdC52YWx1ZXNbdC52YWx1ZXMubGVuZ3RoIC0gMV0uaW5kZXggKyAxO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGxlbmd0aCA9IHRhcmdldHNbaV0udmFsdWVzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHRhcmdldHNbaV0udmFsdWVzW2pdLmluZGV4ID0gdGFpbCArIGo7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoISQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGFyZ2V0c1tpXS52YWx1ZXNbal0ueCA9IHRhaWwgKyBqO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dC52YWx1ZXMgPSB0LnZhbHVlcy5jb25jYXQodGFyZ2V0c1tpXS52YWx1ZXMpO1xyXG5cdFx0XHRcdFx0dGFyZ2V0cy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdCFmb3VuZCAmJiBub3Rmb3VuZElkcy5wdXNoKHQuaWQpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gQXBwZW5kIG51bGwgZm9yIG5vdCBmb3VuZCB0YXJnZXRzXHJcblx0XHQkJC5kYXRhLnRhcmdldHMuZm9yRWFjaCh0ID0+IHtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBub3Rmb3VuZElkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdGlmICh0LmlkID09PSBub3Rmb3VuZElkc1tpXSkge1xyXG5cdFx0XHRcdFx0dGFpbCA9IHQudmFsdWVzW3QudmFsdWVzLmxlbmd0aCAtIDFdLmluZGV4ICsgMTtcclxuXHJcblx0XHRcdFx0XHRmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0XHRcdHQudmFsdWVzLnB1c2goe1xyXG5cdFx0XHRcdFx0XHRcdGlkOiB0LmlkLFxyXG5cdFx0XHRcdFx0XHRcdGluZGV4OiB0YWlsICsgaixcclxuXHRcdFx0XHRcdFx0XHR4OiAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLmdldE90aGVyVGFyZ2V0WCh0YWlsICsgaikgOiB0YWlsICsgaixcclxuXHRcdFx0XHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIEdlbmVyYXRlIG51bGwgdmFsdWVzIGZvciBuZXcgdGFyZ2V0XHJcblx0XHRpZiAoJCQuZGF0YS50YXJnZXRzLmxlbmd0aCkge1xyXG5cdFx0XHR0YXJnZXRzLmZvckVhY2godCA9PiB7XHJcblx0XHRcdFx0Y29uc3QgbWlzc2luZzogYW55W10gPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yIChsZXQgaSA9ICQkLmRhdGEudGFyZ2V0c1swXS52YWx1ZXNbMF0uaW5kZXg7IGkgPCB0YWlsOyBpKyspIHtcclxuXHRcdFx0XHRcdG1pc3NpbmcucHVzaCh7XHJcblx0XHRcdFx0XHRcdGlkOiB0LmlkLFxyXG5cdFx0XHRcdFx0XHRpbmRleDogaSxcclxuXHRcdFx0XHRcdFx0eDogJCQuaXNUaW1lU2VyaWVzKCkgPyAkJC5nZXRPdGhlclRhcmdldFgoaSkgOiBpLFxyXG5cdFx0XHRcdFx0XHR2YWx1ZTogbnVsbFxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdFx0di5pbmRleCArPSB0YWlsO1xyXG5cclxuXHRcdFx0XHRcdGlmICghJCQuaXNUaW1lU2VyaWVzKCkpIHtcclxuXHRcdFx0XHRcdFx0di54ICs9IHRhaWw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHQudmFsdWVzID0gbWlzc2luZy5jb25jYXQodC52YWx1ZXMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC5kYXRhLnRhcmdldHMgPSAkJC5kYXRhLnRhcmdldHMuY29uY2F0KHRhcmdldHMpOyAvLyBhZGQgcmVtYWluZWRcclxuXHJcblx0XHQvLyBjaGVjayBkYXRhIGNvdW50IGJlY2F1c2UgYmVoYXZpb3IgbmVlZHMgdG8gY2hhbmdlIHdoZW4gaXRcInMgb25seSBvbmVcclxuXHRcdC8vIGNvbnN0IGRhdGFDb3VudCA9ICQkLmdldE1heERhdGFDb3VudCgpO1xyXG5cdFx0Y29uc3QgYmFzZVRhcmdldCA9ICQkLmRhdGEudGFyZ2V0c1swXTtcclxuXHRcdGNvbnN0IGJhc2VWYWx1ZSA9IGJhc2VUYXJnZXQudmFsdWVzWzBdO1xyXG5cclxuXHRcdC8vIFVwZGF0ZSBsZW5ndGggdG8gZmxvdyBpZiBuZWVkZWRcclxuXHRcdGlmIChpc0RlZmluZWQoYXJncy50bykpIHtcclxuXHRcdFx0bGVuZ3RoID0gMDtcclxuXHRcdFx0dG8gPSAkJC5pc1RpbWVTZXJpZXMoKSA/ICQkLnBhcnNlRGF0ZShhcmdzLnRvKSA6IGFyZ3MudG87XHJcblxyXG5cdFx0XHRiYXNlVGFyZ2V0LnZhbHVlcy5mb3JFYWNoKHYgPT4ge1xyXG5cdFx0XHRcdHYueCA8IHRvICYmIGxlbmd0aCsrO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSBpZiAoaXNEZWZpbmVkKGFyZ3MubGVuZ3RoKSkge1xyXG5cdFx0XHRsZW5ndGggPSBhcmdzLmxlbmd0aDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiBvbmx5IG9uZSBkYXRhLCB1cGRhdGUgdGhlIGRvbWFpbiB0byBmbG93IGZyb20gbGVmdCBlZGdlIG9mIHRoZSBjaGFydFxyXG5cdFx0aWYgKCFvcmdEYXRhQ291bnQpIHtcclxuXHRcdFx0aWYgKCQkLmlzVGltZVNlcmllcygpKSB7XHJcblx0XHRcdFx0ZGlmZiA9IGJhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCA+IDEgP1xyXG5cdFx0XHRcdFx0YmFzZVRhcmdldC52YWx1ZXNbYmFzZVRhcmdldC52YWx1ZXMubGVuZ3RoIC0gMV0ueCAtIGJhc2VWYWx1ZS54IDpcclxuXHRcdFx0XHRcdGJhc2VWYWx1ZS54IC0gJCQuZ2V0WERvbWFpbigkJC5kYXRhLnRhcmdldHMpWzBdO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRpZmYgPSAxO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRkb21haW4gPSBbYmFzZVZhbHVlLnggLSBkaWZmLCBiYXNlVmFsdWUueF07XHJcblx0XHR9IGVsc2UgaWYgKG9yZ0RhdGFDb3VudCA9PT0gMSAmJiAkJC5pc1RpbWVTZXJpZXMoKSkge1xyXG5cdFx0XHRkaWZmID0gKGJhc2VUYXJnZXQudmFsdWVzW2Jhc2VUYXJnZXQudmFsdWVzLmxlbmd0aCAtIDFdLnggLSBiYXNlVmFsdWUueCkgLyAyO1xyXG5cdFx0XHRkb21haW4gPSBbbmV3IERhdGUoK2Jhc2VWYWx1ZS54IC0gZGlmZiksIG5ldyBEYXRlKCtiYXNlVmFsdWUueCArIGRpZmYpXTtcclxuXHRcdH1cclxuXHJcblx0XHRkb21haW4gJiYgJCQudXBkYXRlWERvbWFpbihudWxsLCB0cnVlLCB0cnVlLCBmYWxzZSwgZG9tYWluKTtcclxuXHJcblx0XHQvLyBTZXQgdGFyZ2V0c1xyXG5cdFx0JCQudXBkYXRlVGFyZ2V0cygkJC5kYXRhLnRhcmdldHMpO1xyXG5cclxuXHRcdC8vIFJlZHJhdyB3aXRoIG5ldyB0YXJnZXRzXHJcblx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRmbG93OiB7XHJcblx0XHRcdFx0aW5kZXg6IGJhc2VWYWx1ZS5pbmRleCxcclxuXHRcdFx0XHRsZW5ndGg6IGxlbmd0aCxcclxuXHRcdFx0XHRkdXJhdGlvbjogaXNWYWx1ZShhcmdzLmR1cmF0aW9uKSA/IGFyZ3MuZHVyYXRpb24gOiAkJC5jb25maWcudHJhbnNpdGlvbl9kdXJhdGlvbixcclxuXHRcdFx0XHRkb25lOiBhcmdzLmRvbmUsXHJcblx0XHRcdFx0b3JnRGF0YUNvdW50OiBvcmdEYXRhQ291bnQsXHJcblx0XHRcdH0sXHJcblx0XHRcdHdpdGhMZWdlbmQ6IHRydWUsXHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiBvcmdEYXRhQ291bnQgPiAxLFxyXG5cdFx0XHR3aXRoVHJpbVhEb21haW46IGZhbHNlLFxyXG5cdFx0XHR3aXRoVXBkYXRlWEF4aXM6IHRydWVcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3NlbGVjdCBhcyBkM1NlbGVjdH0gZnJvbSBcImQzLXNlbGVjdGlvblwiO1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogVGhpcyBBUEkgaGlnaGxpZ2h0cyBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgZmFkZSBvdXQgdGhlIG90aGVycy48YnI+PGJyPlxyXG5cdCAqIFlvdSBjYW4gc3BlY2lmeSBtdWx0aXBsZSB0YXJnZXRzIGJ5IGdpdmluZyBhbiBhcnJheSB0aGF0IGluY2x1ZGVzIGlkIGFzIFN0cmluZy4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXRzIHdpbGwgYmUgaGlnaGxpZ2h0ZWQuXHJcblx0ICogQG1ldGhvZCBmb2N1c1xyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0YXJnZXRJZHNWYWx1ZSBUYXJnZXQgaWRzIHRvIGJlIGhpZ2hsaWdodGVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIGRhdGExIHdpbGwgYmUgaGlnaGxpZ2h0ZWQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSBmYWRlZCBvdXRcclxuXHQgKiAgY2hhcnQuZm9jdXMoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIGRhdGExIGFuZCBkYXRhMiB3aWxsIGJlIGhpZ2hsaWdodGVkIGFuZCB0aGUgb3RoZXJzIHdpbGwgYmUgZmFkZWQgb3V0XHJcblx0ICogY2hhcnQuZm9jdXMoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBhbGwgdGFyZ2V0cyB3aWxsIGJlIGhpZ2hsaWdodGVkXHJcblx0ICogY2hhcnQuZm9jdXMoKTtcclxuXHQgKi9cclxuXHRmb2N1cyh0YXJnZXRJZHNWYWx1ZT86IHN0cmluZyB8IHN0cmluZ1tdKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7c3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuJGVsLnN2Zy5zZWxlY3RBbGwoXHJcblx0XHRcdCQkLnNlbGVjdG9yVGFyZ2V0cyh0YXJnZXRJZHMuZmlsdGVyKCQkLmlzVGFyZ2V0VG9TaG93LCAkJCkpXHJcblx0XHQpO1xyXG5cclxuXHRcdHRoaXMucmV2ZXJ0KCk7XHJcblx0XHR0aGlzLmRlZm9jdXMoKTtcclxuXHJcblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgdHJ1ZSkuY2xhc3NlZChDTEFTUy5kZWZvY3VzZWQsIGZhbHNlKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdCQkLmV4cGFuZEFyYyh0YXJnZXRJZHMpO1xyXG5cclxuXHRcdFx0JCQuaGFzVHlwZShcImdhdWdlXCIpICYmXHJcblx0XHRcdFx0JCQubWFya092ZXJsYXBwZWQodGFyZ2V0SWRzVmFsdWUsICQkLCBgLiR7Q0xBU1MuZ2F1Z2VWYWx1ZX1gKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC50b2dnbGVGb2N1c0xlZ2VuZCh0YXJnZXRJZHMsIHRydWUpO1xyXG5cclxuXHRcdHN0YXRlLmZvY3VzZWRUYXJnZXRJZHMgPSB0YXJnZXRJZHM7XHJcblx0XHRzdGF0ZS5kZWZvY3VzZWRUYXJnZXRJZHMgPSBzdGF0ZS5kZWZvY3VzZWRUYXJnZXRJZHMuZmlsdGVyKGlkID0+IHRhcmdldElkcy5pbmRleE9mKGlkKSA8IDApO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRoaXMgQVBJIGZhZGVzIG91dCBzcGVjaWZpZWQgdGFyZ2V0cyBhbmQgcmV2ZXJ0cyB0aGUgb3RoZXJzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSBmYWRlZCBvdXQuXHJcblx0ICogQG1ldGhvZCBkZWZvY3VzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFRhcmdldCBpZHMgdG8gYmUgZmFkZWQgb3V0LlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gZGF0YTEgd2lsbCBiZSBmYWRlZCBvdXQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5kZWZvY3VzKFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAvLyBkYXRhMSBhbmQgZGF0YTIgd2lsbCBiZSBmYWRlZCBvdXQgYW5kIHRoZSBvdGhlcnMgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5kZWZvY3VzKFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogLy8gYWxsIHRhcmdldHMgd2lsbCBiZSBmYWRlZCBvdXQuXHJcblx0ICogY2hhcnQuZGVmb2N1cygpO1xyXG5cdCAqL1xyXG5cdGRlZm9jdXModGFyZ2V0SWRzVmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge3N0YXRlfSA9ICQkO1xyXG5cdFx0Y29uc3QgdGFyZ2V0SWRzID0gJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzVmFsdWUpO1xyXG5cdFx0Y29uc3QgY2FuZGlkYXRlcyA9ICQkLiRlbC5zdmcuc2VsZWN0QWxsKFxyXG5cdFx0XHQkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzLmZpbHRlcigkJC5pc1RhcmdldFRvU2hvdywgJCQpKVxyXG5cdFx0KTtcclxuXHJcblx0XHRjYW5kaWRhdGVzLmNsYXNzZWQoQ0xBU1MuZm9jdXNlZCwgZmFsc2UpLmNsYXNzZWQoQ0xBU1MuZGVmb2N1c2VkLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoJCQuaGFzQXJjVHlwZSgpKSB7XHJcblx0XHRcdCQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0XHQkJC5oYXNUeXBlKFwiZ2F1Z2VcIikgJiZcclxuXHRcdFx0XHQkJC51bmRvTWFya092ZXJsYXBwZWQoJCQsIGAuJHtDTEFTUy5nYXVnZVZhbHVlfWApO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnRvZ2dsZUZvY3VzTGVnZW5kKHRhcmdldElkcywgZmFsc2UpO1xyXG5cclxuXHRcdHN0YXRlLmZvY3VzZWRUYXJnZXRJZHMgPSBzdGF0ZS5mb2N1c2VkVGFyZ2V0SWRzLmZpbHRlcihpZCA9PiB0YXJnZXRJZHMuaW5kZXhPZihpZCkgPCAwKTtcclxuXHRcdHN0YXRlLmRlZm9jdXNlZFRhcmdldElkcyA9IHRhcmdldElkcztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGlzIEFQSSByZXZlcnRzIHNwZWNpZmllZCB0YXJnZXRzLjxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBAbWV0aG9kIHJldmVydFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBUYXJnZXQgaWRzIHRvIGJlIHJldmVydGVkXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBkYXRhMSB3aWxsIGJlIHJldmVydGVkLlxyXG5cdCAqIGNoYXJ0LnJldmVydChcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgcmV2ZXJ0ZWQuXHJcblx0ICogY2hhcnQucmV2ZXJ0KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogLy8gYWxsIHRhcmdldHMgd2lsbCBiZSByZXZlcnRlZC5cclxuXHQgKiBjaGFydC5yZXZlcnQoKTtcclxuXHQgKi9cclxuXHRyZXZlcnQodGFyZ2V0SWRzVmFsdWU/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZywgc3RhdGV9ID0gJCQ7XHJcblx0XHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblx0XHRjb25zdCBjYW5kaWRhdGVzID0gJCQuJGVsLnN2Zy5zZWxlY3RBbGwoJCQuc2VsZWN0b3JUYXJnZXRzKHRhcmdldElkcykpOyAvLyBzaG91bGQgYmUgZm9yIGFsbCB0YXJnZXRzXHJcblxyXG5cdFx0Y2FuZGlkYXRlcy5jbGFzc2VkKENMQVNTLmZvY3VzZWQsIGZhbHNlKS5jbGFzc2VkKENMQVNTLmRlZm9jdXNlZCwgZmFsc2UpO1xyXG5cdFx0JCQuaGFzQXJjVHlwZSgpICYmICQkLnVuZXhwYW5kQXJjKHRhcmdldElkcyk7XHJcblxyXG5cdFx0aWYgKGNvbmZpZy5sZWdlbmRfc2hvdykge1xyXG5cdFx0XHQkJC5zaG93TGVnZW5kKHRhcmdldElkcy5maWx0ZXIoJCQuaXNMZWdlbmRUb1Nob3cuYmluZCgkJCkpKTtcclxuXHRcdFx0JCQuJGVsLmxlZ2VuZC5zZWxlY3RBbGwoJCQuc2VsZWN0b3JMZWdlbmRzKHRhcmdldElkcykpXHJcblx0XHRcdFx0LmZpbHRlcihmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5jbGFzc2VkKENMQVNTLmxlZ2VuZEl0ZW1Gb2N1c2VkLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0c3RhdGUuZm9jdXNlZFRhcmdldElkcyA9IFtdO1xyXG5cdFx0c3RhdGUuZGVmb2N1c2VkVGFyZ2V0SWRzID0gW107XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgeCBncmlkIGxpbmVzLlxyXG4gKiBAbWV0aG9kIHhncmlkc1xyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGdyaWRzIFggZ3JpZCBsaW5lcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueC5saW5lcy5cclxuICogQGV4YW1wbGVcclxuICogIC8vIFNob3cgMiB4IGdyaWQgbGluZXNcclxuICogY2hhcnQueGdyaWRzKFtcclxuICogICAge3ZhbHVlOiAxLCB0ZXh0OiBcIkxhYmVsIDFcIn0sXHJcbiAqICAgIHt2YWx1ZTogNCwgdGV4dDogXCJMYWJlbCA0XCJ9XHJcbiAqIF0pO1xyXG4gKi9cclxuZnVuY3Rpb24geGdyaWRzKGdyaWRzOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10pIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJFxyXG5cclxuXHRpZiAoIWdyaWRzKSB7XHJcblx0XHRyZXR1cm4gY29uZmlnLmdyaWRfeF9saW5lcztcclxuXHR9XHJcblxyXG5cdGNvbmZpZy5ncmlkX3hfbGluZXMgPSBncmlkcztcclxuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRyZXR1cm4gY29uZmlnLmdyaWRfeF9saW5lcztcclxufVxyXG5cclxuZXh0ZW5kKHhncmlkcywge1xyXG5cdC8qKlxyXG5cdCAqIEFkZCB4IGdyaWQgbGluZXMuPGJyPlxyXG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHggZ3JpZCBsaW5lcyBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHhncmlkcy5cclxuXHQgKiBAbWV0aG9kIHhncmlkc+KApGFkZFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBncmlkcyBOZXcgeCBncmlkIGxpbmVzIHdpbGwgYmUgYWRkZWQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyBncmlkLngubGluZXMgYW5kIGl0J3MgcG9zc2libGUgdG8gZ2l2ZSBhbiBPYmplY3QgaWYgb25seSBvbmUgbGluZSB3aWxsIGJlIGFkZGVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEFkZCBhIG5ldyB4IGdyaWQgbGluZVxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoXHJcblx0ICogICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqICk7XHJcblx0ICpcclxuXHQgKiAvLyBBZGQgbmV3IHggZ3JpZCBsaW5lc1xyXG5cdCAqIGNoYXJ0Lnhncmlkcy5hZGQoW1xyXG5cdCAqICAge3ZhbHVlOiAyLCB0ZXh0OiBcIkxhYmVsIDJcIn0sXHJcblx0ICogICB7dmFsdWU6IDQsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqIF0pO1xyXG5cdCAqL1xyXG5cdGFkZDogZnVuY3Rpb24oZ3JpZHM6IHt2YWx1ZT86IG51bWJlciwgdGV4dD86IHN0cmluZ31bXSkge1xyXG5cdFx0cmV0dXJuIHRoaXMueGdyaWRzKFxyXG5cdFx0XHR0aGlzLmludGVybmFsLmNvbmZpZy5ncmlkX3hfbGluZXNcclxuXHRcdFx0XHQuY29uY2F0KGdyaWRzIHx8IFtdKVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgeCBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHggZ3JpZCBsaW5lcy5cclxuXHQgKiBAbWV0aG9kIHhncmlkc+KApHJlbW92ZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSB2YWx1ZSBvciBjbGFzcy4gSWYgdmFsdWUgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCB4IHZhbHVlIHdpbGwgYmUgcmVtb3ZlZC4gSWYgY2xhc3MgaXMgZ2l2ZW4sIHRoZSB4IGdyaWQgbGluZXMgdGhhdCBoYXZlIHNwZWNpZmllZCBjbGFzcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgeCBncmlkIGxpbmVzIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHggZ3JpZCBsaW5lIG9uIHggPSAyIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe3ZhbHVlOiAyfSk7XHJcblx0ICpcclxuXHQgKiAvLyB4IGdyaWQgbGluZXMgdGhhdCBoYXZlICdncmlkLUEnIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnhncmlkcy5yZW1vdmUoe1xyXG5cdCAqICAgY2xhc3M6IFwiZ3JpZC1BXCJcclxuXHQgKiB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCBvZiB4IGdyaWQgbGluZXMgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueGdyaWRzLnJlbW92ZSgpO1xyXG5cdCAqL1xyXG5cdHJlbW92ZTogZnVuY3Rpb24ocGFyYW1zPzoge3ZhbHVlPzogbnVtYmVyLCBjbGFzcz86IHN0cmluZ30pIHsgLy8gVE9ETzogbXVsdGlwbGVcclxuXHRcdHRoaXMuaW50ZXJuYWwucmVtb3ZlR3JpZExpbmVzKHBhcmFtcywgdHJ1ZSk7XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHt4Z3JpZHN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7ZXh0ZW5kfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBVcGRhdGUgeSBncmlkIGxpbmVzLlxyXG4gKiBAbWV0aG9kIHlncmlkc1xyXG4gKiBAaW5zdGFuY2VcclxuICogQG1lbWJlcm9mIENoYXJ0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IGdyaWRzIFkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhpcyBhcmd1bWVudC4gVGhlIGZvcm1hdCBvZiB0aGlzIGFyZ3VtZW50IGlzIHRoZSBzYW1lIGFzIGdyaWQueS5saW5lcy5cclxuICogQGV4YW1wbGVcclxuICogIC8vIFNob3cgMiB5IGdyaWQgbGluZXNcclxuICogY2hhcnQueWdyaWRzKFtcclxuICogICAge3ZhbHVlOiAxMDAsIHRleHQ6IFwiTGFiZWwgMVwifSxcclxuICogICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG4gKiBdKTtcclxuICovXHJcbmZ1bmN0aW9uIHlncmlkcyhncmlkczoge3ZhbHVlPzogbnVtYmVyLCB0ZXh0Pzogc3RyaW5nfVtdKSB7XHJcblx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdGNvbnN0IHtjb25maWd9ID0gJCRcclxuXHJcblx0aWYgKCFncmlkcykge1xyXG5cdFx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XHJcblx0fVxyXG5cclxuXHRjb25maWcuZ3JpZF95X2xpbmVzID0gZ3JpZHM7aHR0cDovL2ppbmRvLmNvbS9naXQvYmlsbGJvYXJkLmpzL2RlbW8vd29yay9jaGFydC5odG1sXHJcblx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcclxuXHJcblx0cmV0dXJuIGNvbmZpZy5ncmlkX3lfbGluZXM7XHJcbn1cclxuXHJcbmV4dGVuZCh5Z3JpZHMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgeSBncmlkIGxpbmVzLjxicj5cclxuXHQgKiBUaGlzIEFQSSBhZGRzIG5ldyB5IGdyaWQgbGluZXMgaW5zdGVhZCBvZiByZXBsYWNpbmcgbGlrZSB5Z3JpZHMuXHJcblx0ICogQG1ldGhvZCB5Z3JpZHPigKRhZGRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gZ3JpZHMgTmV3IHkgZ3JpZCBsaW5lcyB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgZ3JpZC55LmxpbmVzIGFuZCBpdCdzIHBvc3NpYmxlIHRvIGdpdmUgYW4gT2JqZWN0IGlmIG9ubHkgb25lIGxpbmUgd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBBZGQgYSBuZXcgeCBncmlkIGxpbmVcclxuXHQgKiBjaGFydC55Z3JpZHMuYWRkKFxyXG5cdCAqICAge3ZhbHVlOiA0MDAsIHRleHQ6IFwiTGFiZWwgNFwifVxyXG5cdCAqICk7XHJcblx0ICpcclxuXHQgKiAvLyBBZGQgbmV3IHggZ3JpZCBsaW5lc1xyXG5cdCAqIGNoYXJ0Lnlncmlkcy5hZGQoW1xyXG5cdCAqICAge3ZhbHVlOiAyMDAsIHRleHQ6IFwiTGFiZWwgMlwifSxcclxuXHQgKiAgIHt2YWx1ZTogNDAwLCB0ZXh0OiBcIkxhYmVsIDRcIn1cclxuXHQgKiBdKTtcclxuXHQgKi9cclxuXHRhZGQ6IGZ1bmN0aW9uKGdyaWRzOiB7dmFsdWU/OiBudW1iZXIsIHRleHQ/OiBzdHJpbmd9W10pIHtcclxuXHRcdHJldHVybiB0aGlzLnlncmlkcyhcclxuXHRcdFx0dGhpcy5pbnRlcm5hbC5jb25maWcuZ3JpZF95X2xpbmVzXHJcblx0XHRcdFx0LmNvbmNhdChncmlkcyB8fCBbXSlcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHkgZ3JpZCBsaW5lcy48YnI+XHJcblx0ICogVGhpcyBBUEkgcmVtb3ZlcyB4IGdyaWQgbGluZXMuXHJcblx0ICogQG1ldGhvZCB5Z3JpZHPigKRyZW1vdmVcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIFRoaXMgYXJndW1lbnQgc2hvdWxkIGluY2x1ZGUgdmFsdWUgb3IgY2xhc3MuIElmIHZhbHVlIGlzIGdpdmVuLCB0aGUgeSBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgeSB2YWx1ZSB3aWxsIGJlIHJlbW92ZWQuIElmIGNsYXNzIGlzIGdpdmVuLCB0aGUgeSBncmlkIGxpbmVzIHRoYXQgaGF2ZSBzcGVjaWZpZWQgY2xhc3Mgd2lsbCBiZSByZW1vdmVkLiBJZiBhcmdzIGlzIG5vdCBnaXZlbiwgYWxsIG9mIHkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyB5IGdyaWQgbGluZSBvbiB5ID0gMjAwIHdpbGwgYmUgcmVtb3ZlZFxyXG5cdCAqIGNoYXJ0Lnlncmlkcy5yZW1vdmUoe3ZhbHVlOiAyMDB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIHkgZ3JpZCBsaW5lcyB0aGF0IGhhdmUgJ2dyaWQtQScgd2lsbCBiZSByZW1vdmVkXHJcblx0ICogY2hhcnQueWdyaWRzLnJlbW92ZSh7XHJcblx0ICogICBjbGFzczogXCJncmlkLUFcIlxyXG5cdCAqIH0pO1xyXG5cdCAqXHJcblx0ICogLy8gYWxsIG9mIHkgZ3JpZCBsaW5lcyB3aWxsIGJlIHJlbW92ZWRcclxuXHQgKiBjaGFydC55Z3JpZHMucmVtb3ZlKCk7XHJcblx0ICovXHJcblx0cmVtb3ZlOiBmdW5jdGlvbihwYXJhbXM/OiB7dmFsdWU/OiBudW1iZXIsIGNsYXNzPzogc3RyaW5nfSkgeyAvLyBUT0RPOiBtdWx0aXBsZVxyXG5cdFx0dGhpcy5pbnRlcm5hbC5yZW1vdmVHcmlkTGluZXMocGFyYW1zLCBmYWxzZSk7XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHt5Z3JpZHN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNVbmRlZmluZWR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cdC8qKlxyXG5cdCAqIFVwZGF0ZSBncm91cHMgZm9yIHRoZSB0YXJnZXRzLlxyXG5cdCAqIEBtZXRob2QgZ3JvdXBzXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheX0gZ3JvdXBzIFRoaXMgYXJndW1lbnQgbmVlZHMgdG8gYmUgYW4gQXJyYXkgdGhhdCBpbmNsdWRlcyBvbmUgb3IgbW9yZSBBcnJheSB0aGF0IGluY2x1ZGVzIHRhcmdldCBpZHMgdG8gYmUgZ3JvdXBlZC5cclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gR3JvdXBlZCBkYXRhIG5hbWVzIGFycmF5XHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gZGF0YTEgYW5kIGRhdGEyIHdpbGwgYmUgYSBuZXcgZ3JvdXAuXHJcblx0ICogIGNoYXJ0Lmdyb3VwcyhbXHJcblx0ICogICAgIFtcImRhdGExXCIsIFwiZGF0YTJcIl1cclxuXHQgKiAgXSk7XHJcblx0ICovXHJcblx0Z3JvdXBzKGdyb3Vwczogc3RyaW5nW11bXSk6IHN0cmluZ1tdW10ge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJFxyXG5cclxuXHRcdGlmIChpc1VuZGVmaW5lZChncm91cHMpKSB7XHJcblx0XHRcdHJldHVybiBjb25maWcuZGF0YV9ncm91cHM7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uZmlnLmRhdGFfZ3JvdXBzID0gZ3JvdXBzO1xyXG5cdFx0JCQucmVkcmF3KCk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy5kYXRhX2dyb3VwcztcclxuXHR9XHJcbn07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuLyoqXHJcbiAqIERlZmluZSBsZWdlbmRcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY29uc3QgbGVnZW5kID0ge1xyXG5cdC8qKlxyXG5cdCAqIFNob3cgbGVnZW5kIGZvciBlYWNoIHRhcmdldC5cclxuXHQgKiBAbWV0aG9kIGxlZ2VuZOKApHNob3dcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gdGFyZ2V0SWRzXHJcblx0ICogLSBJZiB0YXJnZXRJZHMgaXMgZ2l2ZW4sIHNwZWNpZmllZCB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBzaG93bi5cclxuXHQgKiAtIElmIG9ubHkgb25lIHRhcmdldCBpcyB0aGUgY2FuZGlkYXRlLCBTdHJpbmcgY2FuIGJlIHBhc3NlZC5cclxuXHQgKiAtIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgc2hvd24uXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBTaG93IGxlZ2VuZCBmb3IgZGF0YTEuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIFNob3cgbGVnZW5kIGZvciBkYXRhMSBhbmQgZGF0YTIuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBTaG93IGFsbCBsZWdlbmQuXHJcblx0ICogY2hhcnQubGVnZW5kLnNob3coKTtcclxuXHQgKi9cclxuXHRzaG93OiBmdW5jdGlvbih0YXJnZXRJZHM/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdCQkLnNob3dMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XHJcblx0XHQkJC51cGRhdGVBbmRSZWRyYXcoe3dpdGhMZWdlbmQ6IHRydWV9KTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBIaWRlIGxlZ2VuZCBmb3IgZWFjaCB0YXJnZXQuXHJcblx0ICogQG1ldGhvZCBsZWdlbmTigKRoaWRlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHRhcmdldElkc1xyXG5cdCAqIC0gSWYgdGFyZ2V0SWRzIGlzIGdpdmVuLCBzcGVjaWZpZWQgdGFyZ2V0J3MgbGVnZW5kIHdpbGwgYmUgaGlkZGVuLlxyXG5cdCAqIC0gSWYgb25seSBvbmUgdGFyZ2V0IGlzIHRoZSBjYW5kaWRhdGUsIFN0cmluZyBjYW4gYmUgcGFzc2VkLlxyXG5cdCAqIC0gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGFsbCBvZiB0YXJnZXQncyBsZWdlbmQgd2lsbCBiZSBoaWRkZW4uXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBIaWRlIGxlZ2VuZCBmb3IgZGF0YTEuXHJcblx0ICogY2hhcnQubGVnZW5kLmhpZGUoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIEhpZGUgbGVnZW5kIGZvciBkYXRhMSBhbmQgZGF0YTIuXHJcblx0ICogY2hhcnQubGVnZW5kLmhpZGUoW1wiZGF0YTFcIiwgXCJkYXRhMlwiXSk7XHJcblx0ICpcclxuXHQgKiAvLyBIaWRlIGFsbCBsZWdlbmQuXHJcblx0ICogY2hhcnQubGVnZW5kLmhpZGUoKTtcclxuXHQgKi9cclxuXHRoaWRlOiBmdW5jdGlvbih0YXJnZXRJZHM/OiBzdHJpbmcgfCBzdHJpbmdbXSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdCQkLmhpZGVMZWdlbmQoJCQubWFwVG9UYXJnZXRJZHModGFyZ2V0SWRzKSk7XHJcblx0XHQkJC51cGRhdGVBbmRSZWRyYXcoe3dpdGhMZWdlbmQ6IHRydWV9KTtcclxuXHR9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7bGVnZW5kfTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge2lzU3RyaW5nLCBpc0FycmF5fSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBMb2FkIGRhdGEgdG8gdGhlIGNoYXJ0Ljxicj48YnI+XHJcblx0ICogWW91IGNhbiBzcGVjaWZ5IG11bHRpcGxlIHRhcmdldHMgYnkgZ2l2aW5nIGFuIGFycmF5IHRoYXQgaW5jbHVkZXMgaWQgYXMgU3RyaW5nLiBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgYWxsIG9mIHRhcmdldHMgd2lsbCBiZSB0b2dnbGVzLlxyXG5cdCAqIC0gPGI+Tm90ZTo8L2I+XHJcblx0ICogICAtIHVubG9hZCBzaG91bGQgYmUgdXNlZCBpZiBzb21lIGRhdGEgbmVlZHMgdG8gYmUgdW5sb2FkZWQgc2ltdWx0YW5lb3VzbHkuXHJcblx0ICogICAgIElmIHlvdSBjYWxsIHVubG9hZCBBUEkgc29vbiBhZnRlci9iZWZvcmUgbG9hZCBpbnN0ZWFkIG9mIHVubG9hZCBwYXJhbSwgY2hhcnQgd2lsbCBub3QgYmUgcmVuZGVyZWQgcHJvcGVybHkgYmVjYXVzZSBvZiBjYW5jZWwgb2YgYW5pbWF0aW9uLjxicj5cclxuXHQgKiAgIC0gZG9uZSB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZCwgYnV0IGl0J3Mgbm90IGFmdGVyIHJlbmRlcmluZy5cclxuXHQgKiAgICAgSXQncyBiZWNhdXNlIHJlbmRlcmluZyB3aWxsIGZpbmlzaCBhZnRlciBzb21lIHRyYW5zaXRpb24gYW5kIHRoZXJlIGlzIHNvbWUgdGltZSBsYWcgYmV0d2VlbiBsb2FkaW5nIGFuZCByZW5kZXJpbmdcclxuXHQgKiBAbWV0aG9kIGxvYWRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgLSB1cmw8YnI+LSBqc29uPGJyPi0gcm93czxicj4tIGNvbHVtbnMgfCBUaGUgZGF0YSB3aWxsIGJlIGxvYWRlZC4gSWYgZGF0YSB0aGF0IGhhcyB0aGUgc2FtZSB0YXJnZXQgaWQgaXMgZ2l2ZW4sIHRoZSBjaGFydCB3aWxsIGJlIHVwZGF0ZWQuIE90aGVyd2lzZSwgbmV3IHRhcmdldCB3aWxsIGJlIGFkZGVkIHxcclxuXHQgKiAgICB8IGRhdGEgfCBEYXRhIG9iamVjdHMgdG8gYmUgbG9hZGVkLiBDaGVja291dCB0aGUgZXhhbXBsZS4gfFxyXG5cdCAqICAgIHwgbmFtZXMgfCBTYW1lIGFzIGRhdGEubmFtZXMoKSB8XHJcblx0ICogICAgfCB4cyB8IFNhbWUgYXMgZGF0YS54cyBvcHRpb24gIHxcclxuXHQgKiAgICB8IGNsYXNzZXMgfCBUaGUgY2xhc3NlcyBzcGVjaWZpZWQgYnkgZGF0YS5jbGFzc2VzIHdpbGwgYmUgdXBkYXRlZC4gY2xhc3NlcyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxyXG5cdCAqICAgIHwgY2F0ZWdvcmllcyB8IFRoZSBjYXRlZ29yaWVzIHNwZWNpZmllZCBieSBheGlzLnguY2F0ZWdvcmllcyBvciBkYXRhLnggd2lsbCBiZSB1cGRhdGVkLiBjYXRlZ29yaWVzIG11c3QgYmUgQXJyYXkuIHxcclxuXHQgKiAgICB8IGF4ZXMgfCBUaGUgYXhlcyBzcGVjaWZpZWQgYnkgZGF0YS5heGVzIHdpbGwgYmUgdXBkYXRlZC4gYXhlcyBtdXN0IGJlIE9iamVjdCB0aGF0IGhhcyB0YXJnZXQgaWQgYXMga2V5cy4gfFxyXG5cdCAqICAgIHwgY29sb3JzIHwgVGhlIGNvbG9ycyBzcGVjaWZpZWQgYnkgZGF0YS5jb2xvcnMgd2lsbCBiZSB1cGRhdGVkLiBjb2xvcnMgbXVzdCBiZSBPYmplY3QgdGhhdCBoYXMgdGFyZ2V0IGlkIGFzIGtleXMuIHxcclxuXHQgKiAgICB8IGhlYWRlcnMgfCAgU2V0IHJlcXVlc3QgaGVhZGVyIGlmIGxvYWRpbmcgdmlhIGBkYXRhLnVybGAuPGJyPkBzZWUgW2RhdGHigKRoZWFkZXJzXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRoZWFkZXJzKSB8XHJcblx0ICogICAgfCBrZXlzIHwgIENob29zZSB3aGljaCBKU09OIG9iamVjdHMga2V5cyBjb3JyZXNwb25kIHRvIGRlc2lyZWQgZGF0YS48YnI+KipOT1RFOioqIE9ubHkgZm9yIEpTT04gb2JqZWN0IGdpdmVuIGFzIGFycmF5Ljxicj5Ac2VlIFtkYXRh4oCka2V5c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0a2V5cykgfFxyXG5cdCAqICAgIHwgbWltZVR5cGUgfCAgU2V0ICdqc29uJyBpZiBsb2FkaW5nIEpTT04gdmlhIHVybC48YnI+QHNlZSBbZGF0YeKApG1pbWVUeXBlXShPcHRpb25zLmh0bWwjLmRhdGElMjVFMiUyNTgwJTI1QTRtaW1lVHlwZSkgfFxyXG5cdCAqICAgIHwgLSB0eXBlPGJyPi0gdHlwZXMgfCBUaGUgdHlwZSBvZiB0YXJnZXRzIHdpbGwgYmUgdXBkYXRlZC4gdHlwZSBtdXN0IGJlIFN0cmluZyBhbmQgdHlwZXMgbXVzdCBiZSBPYmplY3QuIHxcclxuXHQgKiAgICB8IHVubG9hZCB8IFNwZWNpZnkgdGhlIGRhdGEgd2lsbCBiZSB1bmxvYWRlZCBiZWZvcmUgbG9hZGluZyBuZXcgZGF0YS4gSWYgdHJ1ZSBnaXZlbiwgYWxsIG9mIGRhdGEgd2lsbCBiZSB1bmxvYWRlZC4gSWYgdGFyZ2V0IGlkcyBnaXZlbiBhcyBTdHJpbmcgb3IgQXJyYXksIHNwZWNpZmllZCB0YXJnZXRzIHdpbGwgYmUgdW5sb2FkZWQuIElmIGFic2VudCBvciBmYWxzZSBnaXZlbiwgdW5sb2FkIHdpbGwgbm90IG9jY3VyLiB8XHJcblx0ICogICAgfCBkb25lIHwgVGhlIHNwZWNpZmllZCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBkYXRhIGxvYWRlZC58XHJcblx0ICogQHNlZSBbRGVtb10oaHR0cHM6Ly9uYXZlci5naXRodWIuaW8vYmlsbGJvYXJkLmpzL2RlbW8vI0RhdGEuRGF0YUZyb21VUkwpXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyBMb2FkIGRhdGExIGFuZCB1bmxvYWQgZGF0YTIgYW5kIGRhdGEzXHJcblx0ICogY2hhcnQubG9hZCh7XHJcblx0ICogICAgIGNvbHVtbnM6IFtcclxuXHQgKiAgICAgICAgW1wiZGF0YTFcIiwgMTAwLCAyMDAsIDE1MCwgLi4uXSxcclxuXHQgKiAgICAgICAgLi4uXHJcblx0ICogICAgXSxcclxuXHQgKiAgICB1bmxvYWQ6IFtcImRhdGEyXCIsIFwiZGF0YTNcIl0sXHJcblx0ICogICAgdXJsOiBcIi4uLlwiLFxyXG5cdCAqICAgIGRvbmU6IGZ1bmN0aW9uKCkgeyAuLi4gfVxyXG5cdCAqIH0pO1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gbXlBUEkuanNvblxyXG5cdCAqIC8vIHtcclxuXHQgKiAvLyAgIFwiZGF0YTFcIjogWzIyMCwgMjQwLCAyNzAsIDI1MCwgMjgwXSxcclxuXHQgKiAvLyAgIFwiZGF0YTJcIjogWzE4MCwgMTUwLCAzMDAsIDcwLCAxMjBdXHJcblx0ICogLy8gfVxyXG5cdCAqXHJcblx0ICogY2hhcnQubG9hZCh7XHJcblx0ICogICAgIHVybDogJy4vZGF0YS9teUFQSS5qc29uJyxcclxuXHQgKiAgICAgbWltZVR5cGU6IFwianNvblwiLFxyXG5cdCAqXHJcblx0ICogICAgIC8vIHNldCByZXF1ZXN0IGhlYWRlciBpZiBpcyBuZWVkZWRcclxuXHQgKiAgICAgaGVhZGVyczoge1xyXG5cdCAqICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9qc29uXCJcclxuXHQgKiAgICAgfVxyXG5cdCAqIH0pO1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogY2hhcnQubG9hZCh7XHJcblx0ICogICAgIGRhdGE6IFtcclxuXHQgKiAgICAgICAvLyBlcXVpdmFsZW50IGFzOiBjb2x1bW5zOiBbW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwXV1cclxuXHQgKiAgICAgICB7XCJkYXRhMVwiOiAzMH0sIHtcImRhdGExXCI6IDIwMH0sIHtcImRhdGExXCI6IDEwMH1cclxuXHQgKlxyXG5cdCAqICAgICAgIC8vIG9yXHJcblx0ICogICAgICAgLy8gZXF1aXZhbGVudCBhczogY29sdW1uczogW1tcImRhdGExXCIsIDEwLCAyMF0sIFtcImRhdGEyXCIsIDEzLCAzMF1dXHJcblx0ICogICAgICAgLy8ge1wiZGF0YTFcIjogMTAsIFwiZGF0YTJcIjogMTN9LCB7XCJkYXRhMVwiOiAyMCwgXCJkYXRhMlwiOiAzMH19XHJcblx0ICogICAgIF1cclxuXHQgKiB9KTtcclxuXHQgKi9cclxuXHRsb2FkKGFyZ3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCRcclxuXHJcblx0XHQvLyB1cGRhdGUgeHMgaWYgc3BlY2lmaWVkXHJcblx0XHRhcmdzLnhzICYmICQkLmFkZFhzKGFyZ3MueHMpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBuYW1lcyBpZiBleGlzdHNcclxuXHRcdFwibmFtZXNcIiBpbiBhcmdzICYmIHRoaXMuZGF0YS5uYW1lcyhhcmdzLm5hbWVzKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY2xhc3NlcyBpZiBleGlzdHNcclxuXHRcdFwiY2xhc3Nlc1wiIGluIGFyZ3MgJiYgT2JqZWN0LmtleXMoYXJncy5jbGFzc2VzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfY2xhc3Nlc1tpZF0gPSBhcmdzLmNsYXNzZXNbaWRdO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNhdGVnb3JpZXMgaWYgZXhpc3RzXHJcblx0XHRpZiAoXCJjYXRlZ29yaWVzXCIgaW4gYXJncyAmJiAkJC5pc0NhdGVnb3JpemVkKCkpIHtcclxuXHRcdFx0Y29uZmlnLmF4aXNfeF9jYXRlZ29yaWVzID0gYXJncy5jYXRlZ29yaWVzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBheGVzIGlmIGV4aXN0c1xyXG5cdFx0XCJheGVzXCIgaW4gYXJncyAmJiBPYmplY3Qua2V5cyhhcmdzLmF4ZXMpLmZvckVhY2goaWQgPT4ge1xyXG5cdFx0XHRjb25maWcuZGF0YV9heGVzW2lkXSA9IGFyZ3MuYXhlc1tpZF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyB1cGRhdGUgY29sb3JzIGlmIGV4aXN0c1xyXG5cdFx0XCJjb2xvcnNcIiBpbiBhcmdzICYmIE9iamVjdC5rZXlzKGFyZ3MuY29sb3JzKS5mb3JFYWNoKGlkID0+IHtcclxuXHRcdFx0Y29uZmlnLmRhdGFfY29sb3JzW2lkXSA9IGFyZ3MuY29sb3JzW2lkXTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIHVubG9hZCBpZiBuZWVkZWRcclxuXHRcdGlmIChcInVubG9hZFwiIGluIGFyZ3MgJiYgYXJncy51bmxvYWQgIT09IGZhbHNlKSB7XHJcblx0XHRcdC8vIFRPRE86IGRvIG5vdCB1bmxvYWQgaWYgdGFyZ2V0IHdpbGwgbG9hZCAoaW5jbHVkZWQgaW4gdXJsL3Jvd3MvY29sdW1ucylcclxuXHRcdFx0JCQudW5sb2FkKCQkLm1hcFRvVGFyZ2V0SWRzKGFyZ3MudW5sb2FkID09PSB0cnVlID8gbnVsbCA6IGFyZ3MudW5sb2FkKSwgKCkgPT5cclxuXHRcdFx0XHQkJC5sb2FkRnJvbUFyZ3MoYXJncylcclxuXHRcdFx0KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdCQkLmxvYWRGcm9tQXJncyhhcmdzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBVbmxvYWQgZGF0YSB0byB0aGUgY2hhcnQuPGJyPjxicj5cclxuXHQgKiBZb3UgY2FuIHNwZWNpZnkgbXVsdGlwbGUgdGFyZ2V0cyBieSBnaXZpbmcgYW4gYXJyYXkgdGhhdCBpbmNsdWRlcyBpZCBhcyBTdHJpbmcuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBhbGwgb2YgdGFyZ2V0cyB3aWxsIGJlIHRvZ2dsZXMuXHJcblx0ICogLSA8Yj5Ob3RlOjwvYj5cclxuXHQgKiBJZiB5b3UgY2FsbCBsb2FkIEFQSSBzb29uIGFmdGVyL2JlZm9yZSB1bmxvYWQsIHVubG9hZCBwYXJhbSBvZiBsb2FkIHNob3VsZCBiZSB1c2VkLiBPdGhlcndpc2UgY2hhcnQgd2lsbCBub3QgYmUgcmVuZGVyZWQgcHJvcGVybHkgYmVjYXVzZSBvZiBjYW5jZWwgb2YgYW5pbWF0aW9uLjxicj5cclxuXHQgKiBgZG9uZWAgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgZGF0YSBsb2FkZWQsIGJ1dCBpdCdzIG5vdCBhZnRlciByZW5kZXJpbmcuIEl0J3MgYmVjYXVzZSByZW5kZXJpbmcgd2lsbCBmaW5pc2ggYWZ0ZXIgc29tZSB0cmFuc2l0aW9uIGFuZCB0aGVyZSBpcyBzb21lIHRpbWUgbGFnIGJldHdlZW4gbG9hZGluZyBhbmQgcmVuZGVyaW5nLlxyXG5cdCAqIEBtZXRob2QgdW5sb2FkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IGFyZ3NcclxuXHQgKiAgfCBrZXkgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICB8IC0tLSB8IC0tLSB8IC0tLSB8XHJcblx0ICogIHwgaWRzIHwgU3RyaW5nICZ2ZXJ0OyBBcnJheSB8IFRhcmdldCBpZCBkYXRhIHRvIGJlIHVubG9hZGVkLiBJZiBub3QgZ2l2ZW4sIGFsbCBkYXRhIHdpbGwgYmUgdW5sb2FkZWQuIHxcclxuXHQgKiAgfCBkb25lIHwgRnVjdGlvbiB8IENhbGxiYWNrIGFmdGVyIGRhdGEgaXMgdW5sb2FkZWQuIHxcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBVbmxvYWQgZGF0YTIgYW5kIGRhdGEzXHJcblx0ICogIGNoYXJ0LnVubG9hZCh7XHJcblx0ICogICAgaWRzOiBbXCJkYXRhMlwiLCBcImRhdGEzXCJdLFxyXG5cdCAqICAgIGRvbmU6IGZ1bmN0aW9uKCkge1xyXG5cdCAqICAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgdW5sb2FkZWRcclxuXHQgKiAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdHVubG9hZChhcmdzVmFsdWUpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGxldCBhcmdzID0gYXJnc1ZhbHVlIHx8IHt9O1xyXG5cclxuXHRcdGlmIChpc0FycmF5KGFyZ3MpKSB7XHJcblx0XHRcdGFyZ3MgPSB7aWRzOiBhcmdzfTtcclxuXHRcdH0gZWxzZSBpZiAoaXNTdHJpbmcoYXJncykpIHtcclxuXHRcdFx0YXJncyA9IHtpZHM6IFthcmdzXX07XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgaWRzID0gJCQubWFwVG9UYXJnZXRJZHMoYXJncy5pZHMpO1xyXG5cclxuXHRcdCQkLnVubG9hZChpZHMsICgpID0+IHtcclxuXHRcdFx0JCQucmVkcmF3KHtcclxuXHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoVXBkYXRlWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0JCQuY2FjaGUucmVtb3ZlKGlkcyk7XHJcblx0XHRcdGFyZ3MuZG9uZSAmJiBhcmdzLmRvbmUoKTtcclxuXHRcdH0pO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ0xBU1MgZnJvbSBcIi4uLy4uL2NvbmZpZy9jbGFzc2VzXCI7XHJcbmltcG9ydCB7Z2V0T3B0aW9uLCBleHRlbmR9IGZyb20gXCIuLi8uLi9tb2R1bGUvdXRpbFwiO1xyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSByZWdpb25zLlxyXG4gKiBAbWV0aG9kIHJlZ2lvbnNcclxuICogQGluc3RhbmNlXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAcGFyYW0ge0FycmF5fSByZWdpb25zIFJlZ2lvbnMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoaXMgYXJndW1lbnQuIFRoZSBmb3JtYXQgb2YgdGhpcyBhcmd1bWVudCBpcyB0aGUgc2FtZSBhcyByZWdpb25zLlxyXG4gKiBAcmV0dXJuIHtBcnJheX0gcmVnaW9uc1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBTaG93IDIgcmVnaW9uc1xyXG4gKiBjaGFydC5yZWdpb25zKFtcclxuICogICAge2F4aXM6IFwieFwiLCBzdGFydDogNSwgY2xhc3M6IFwicmVnaW9uWFwifSxcclxuICogICAge2F4aXM6IFwieVwiLCBlbmQ6IDUwLCBjbGFzczogXCJyZWdpb25ZXCJ9XHJcbiAqIF0pO1xyXG4gKi9cclxuZnVuY3Rpb24gcmVnaW9ucyhyZWdpb25zOiB7YXhpcz86IHN0cmluZywgc3RhcnQ/OiBudW1iZXIsIGVuZD86IG51bWJlciwgY2xhc3M/OiBzdHJpbmd9W10pOiB7fVtdIHtcclxuXHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0Y29uc3Qge2NvbmZpZ30gPSAkJFxyXG5cclxuXHRpZiAoIXJlZ2lvbnMpIHtcclxuXHRcdHJldHVybiBjb25maWcucmVnaW9ucztcclxuXHR9XHJcblxyXG5cdGNvbmZpZy5yZWdpb25zID0gcmVnaW9ucztcclxuXHQkJC5yZWRyYXdXaXRob3V0UmVzY2FsZSgpO1xyXG5cclxuXHRyZXR1cm4gcmVnaW9ucztcclxufVxyXG5cclxuZXh0ZW5kKHJlZ2lvbnMsIHtcclxuXHQvKipcclxuXHQgKiBBZGQgbmV3IHJlZ2lvbi48YnI+PGJyPlxyXG5cdCAqIFRoaXMgQVBJIGFkZHMgbmV3IHJlZ2lvbiBpbnN0ZWFkIG9mIHJlcGxhY2luZyBsaWtlIHJlZ2lvbnMuXHJcblx0ICogQG1ldGhvZCByZWdpb25z4oCkYWRkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtBcnJheXxPYmplY3R9IHJlZ2lvbnMgTmV3IHJlZ2lvbiB3aWxsIGJlIGFkZGVkLiBUaGUgZm9ybWF0IG9mIHRoaXMgYXJndW1lbnQgaXMgdGhlIHNhbWUgYXMgcmVnaW9ucyBhbmQgaXQncyBwb3NzaWJsZSB0byBnaXZlIGFuIE9iamVjdCBpZiBvbmx5IG9uZSByZWdpb24gd2lsbCBiZSBhZGRlZC5cclxuXHQgKiBAcmV0dXJuIHtBcnJheX0gcmVnaW9uc1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gQWRkIGEgbmV3IHJlZ2lvblxyXG5cdCAqIGNoYXJ0LnJlZ2lvbnMuYWRkKFxyXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn1cclxuXHQgKiApO1xyXG5cdCAqXHJcblx0ICogLy8gQWRkIG5ldyByZWdpb25zXHJcblx0ICogY2hhcnQucmVnaW9ucy5hZGQoW1xyXG5cdCAqICAgIHtheGlzOiBcInhcIiwgc3RhcnQ6IDUsIGNsYXNzOiBcInJlZ2lvblhcIn0sXHJcblx0ICogICAge2F4aXM6IFwieVwiLCBlbmQ6IDUwLCBjbGFzczogXCJyZWdpb25ZXCJ9XHJcblx0ICpdKTtcclxuXHQgKi9cclxuXHRhZGQ6IGZ1bmN0aW9uKHJlZ2lvbnMpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCRcclxuXHJcblx0XHRpZiAoIXJlZ2lvbnMpIHtcclxuXHRcdFx0cmV0dXJuIGNvbmZpZy5yZWdpb25zO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbmZpZy5yZWdpb25zID0gY29uZmlnLnJlZ2lvbnMuY29uY2F0KHJlZ2lvbnMpO1xyXG5cdFx0JCQucmVkcmF3V2l0aG91dFJlc2NhbGUoKTtcclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLnJlZ2lvbnM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIHJlZ2lvbnMuPGJyPjxicj5cclxuXHQgKiBUaGlzIEFQSSByZW1vdmVzIHJlZ2lvbnMuXHJcblx0ICogQG1ldGhvZCByZWdpb25z4oCkcmVtb3ZlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtPYmplY3R9IHJlZ2lvbnMgVGhpcyBhcmd1bWVudCBzaG91bGQgaW5jbHVkZSBjbGFzc2VzLiBJZiBjbGFzc2VzIGlzIGdpdmVuLCB0aGUgcmVnaW9ucyB0aGF0IGhhdmUgb25lIG9mIHRoZSBzcGVjaWZpZWQgY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuIElmIGFyZ3MgaXMgbm90IGdpdmVuLCBhbGwgb2YgcmVnaW9ucyB3aWxsIGJlIHJlbW92ZWQuXHJcblx0ICogQHJldHVybiB7QXJyYXl9IHJlZ2lvbnMgUmVtb3ZlZCByZWdpb25zXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAvLyByZWdpb25zIHRoYXQgaGF2ZSAncmVnaW9uLUEnIG9yICdyZWdpb24tQicgd2lsbCBiZSByZW1vdmVkLlxyXG5cdCAqIGNoYXJ0LnJlZ2lvbnMucmVtb3ZlKHtcclxuXHQgKiAgIGNsYXNzZXM6IFtcclxuXHQgKiAgICAgXCJyZWdpb24tQVwiLCBcInJlZ2lvbi1CXCJcclxuXHQgKiAgIF1cclxuXHQgKiB9KTtcclxuXHQgKlxyXG5cdCAqIC8vIGFsbCBvZiByZWdpb25zIHdpbGwgYmUgcmVtb3ZlZC5cclxuXHQgKiBjaGFydC5yZWdpb25zLnJlbW92ZSgpO1xyXG5cdCAqL1xyXG5cdHJlbW92ZTogZnVuY3Rpb24ob3B0aW9uc1ZhbHVlKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkXHJcblxyXG5cdFx0Y29uc3Qgb3B0aW9ucyA9IG9wdGlvbnNWYWx1ZSB8fCB7fTtcclxuXHRcdGNvbnN0IGR1cmF0aW9uID0gZ2V0T3B0aW9uKG9wdGlvbnMsIFwiZHVyYXRpb25cIiwgY29uZmlnLnRyYW5zaXRpb25fZHVyYXRpb24pO1xyXG5cdFx0Y29uc3QgY2xhc3NlcyA9IGdldE9wdGlvbihvcHRpb25zLCBcImNsYXNzZXNcIiwgW0NMQVNTLnJlZ2lvbl0pO1xyXG5cdFx0bGV0IHJlZ2lvbnMgPSAkJC4kZWwubWFpbi5zZWxlY3QoYC4ke0NMQVNTLnJlZ2lvbnN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChjbGFzc2VzLm1hcChjID0+IGAuJHtjfWApKTtcclxuXHJcblx0XHQoZHVyYXRpb24gPyByZWdpb25zLnRyYW5zaXRpb24oKS5kdXJhdGlvbihkdXJhdGlvbikgOiByZWdpb25zKVxyXG5cdFx0XHQuc3R5bGUoXCJvcGFjaXR5XCIsIFwiMFwiKVxyXG5cdFx0XHQucmVtb3ZlKCk7XHJcblxyXG5cdFx0cmVnaW9ucyA9IGNvbmZpZy5yZWdpb25zO1xyXG5cclxuXHRcdGlmIChPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGgpIHtcclxuXHRcdFx0cmVnaW9ucyA9IHJlZ2lvbnMuZmlsdGVyKHJlZ2lvbiA9PiB7XHJcblx0XHRcdFx0bGV0IGZvdW5kID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmICghcmVnaW9uLmNsYXNzKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJlZ2lvbi5jbGFzcy5zcGxpdChcIiBcIikuZm9yRWFjaChjID0+IHtcclxuXHRcdFx0XHRcdGlmIChjbGFzc2VzLmluZGV4T2YoYykgPj0gMCkge1xyXG5cdFx0XHRcdFx0XHRmb3VuZCA9IHRydWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHRcdHJldHVybiAhZm91bmQ7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSByZWdpb25zO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y29uZmlnLnJlZ2lvbnMgPSBbXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcmVnaW9ucztcclxuXHR9XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge3JlZ2lvbnN9O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7c2VsZWN0IGFzIGQzU2VsZWN0fSBmcm9tIFwiZDMtc2VsZWN0aW9uXCI7XHJcbmltcG9ydCB7aXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuaW1wb3J0IENMQVNTIGZyb20gXCIuLi8uLi9jb25maWcvY2xhc3Nlc1wiO1xyXG5pbXBvcnQge0RhdGFJdGVtfSBmcm9tIFwiLi4vLi4vLi4vdHlwZXMvdHlwZXNcIjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBHZXQgc2VsZWN0ZWQgZGF0YSBwb2ludHMuPGJyPjxicj5cclxuXHQgKiBCeSB0aGlzIEFQSSwgeW91IGNhbiBnZXQgc2VsZWN0ZWQgZGF0YSBwb2ludHMgaW5mb3JtYXRpb24uIFRvIHVzZSB0aGlzIEFQSSwgZGF0YS5zZWxlY3Rpb24uZW5hYmxlZCBuZWVkcyB0byBiZSBzZXQgdHJ1ZS5cclxuXHQgKiBAbWV0aG9kIHNlbGVjdGVkXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd9IFt0YXJnZXRJZF0gWW91IGNhbiBmaWx0ZXIgdGhlIHJlc3VsdCBieSBnaXZpbmcgdGFyZ2V0IGlkIHRoYXQgeW91IHdhbnQgdG8gZ2V0LiBJZiBub3QgZ2l2ZW4sIGFsbCBvZiBkYXRhIHBvaW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqIEByZXR1cm4ge0FycmF5fSBkYXRhUG9pbnQgQXJyYXkgb2YgdGhlIGRhdGEgcG9pbnRzLjxicj5leC4pIGBbe3g6IDEsIHZhbHVlOiAyMDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAxLCBuYW1lOiBcImRhdGExXCJ9LCAuLi5dYFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICBjaGFydC5zZWxlY3RlZCgpO1xyXG5cdCAqICAvLyAtLT4gZXguKSBbe3g6IDEsIHZhbHVlOiAyMDAsIGlkOiBcImRhdGExXCIsIGluZGV4OiAxLCBuYW1lOiBcImRhdGExXCJ9LCAuLi4gXVxyXG5cdCAqXHJcblx0ICogIC8vIGFsbCBzZWxlY3RlZCBkYXRhIHBvaW50cyBvZiBkYXRhMSB3aWxsIGJlIHJldHVybmVkLlxyXG5cdCAqICBjaGFydC5zZWxlY3RlZChcImRhdGExXCIpO1xyXG5cdCAqL1xyXG5cdHNlbGVjdGVkKHRhcmdldElkPzogc3RyaW5nKTogRGF0YUl0ZW1bXSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCBkYXRhUG9pbnQ6IERhdGFJdGVtW10gPSBbXTtcclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlcyArICQkLmdldFRhcmdldFNlbGVjdG9yU3VmZml4KHRhcmdldElkKX1gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiBkM1NlbGVjdCh0aGlzKS5jbGFzc2VkKENMQVNTLlNFTEVDVEVEKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LmVhY2goZCA9PiBkYXRhUG9pbnQucHVzaChkKSk7XHJcblxyXG5cdFx0cmV0dXJuIGRhdGFQb2ludDtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgZGF0YSBwb2ludHMgdG8gYmUgc2VsZWN0ZWQuIChgW2RhdGEuc2VsZWN0aW9uLmVuYWJsZWRdKE9wdGlvbnMuaHRtbCMuZGF0YSUyNUUyJTI1ODAlMjVBNHNlbGVjdGlvbiUyNUUyJTI1ODAlMjVBNGVuYWJsZWQpIG9wdGlvbiBzaG91bGQgYmUgc2V0IHRydWUgdG8gdXNlIHRoaXMgbWV0aG9kKWBcclxuXHQgKiBAbWV0aG9kIHNlbGVjdFxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbaWRzXSBpZCB2YWx1ZSB0byBnZXQgc2VsZWN0ZWQuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gW2luZGljZXNdIFRoZSBpbmRleCBhcnJheSBvZiBkYXRhIHBvaW50cy4gSWYgZmFsc3kgdmFsdWUgZ2l2ZW4sIHdpbGwgc2VsZWN0IGFsbCBkYXRhIHBvaW50cy5cclxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZXNldE90aGVyXSBVbnNlbGVjdCBhbHJlYWR5IHNlbGVjdGVkLlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIHNlbGVjdCBhbGwgZGF0YSBwb2ludHNcclxuXHQgKiAgY2hhcnQuc2VsZWN0KCk7XHJcblx0ICpcclxuXHQgKiAgLy8gc2VsZWN0IGFsbCBmcm9tICdkYXRhMidcclxuXHQgKiAgY2hhcnQuc2VsZWN0KFwiZGF0YTJcIik7XHJcblx0ICpcclxuXHQgKiAgLy8gc2VsZWN0IGFsbCBmcm9tICdkYXRhMScgYW5kICdkYXRhMidcclxuXHQgKiAgY2hhcnQuc2VsZWN0KFtcImRhdGExXCIsIFwiZGF0YTJcIl0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHNlbGVjdCBmcm9tICdkYXRhMScsIGluZGljZXMgMiBhbmQgdW5zZWxlY3Qgb3RoZXJzIHNlbGVjdGVkXHJcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGExXCIsIFsyXSwgdHJ1ZSk7XHJcblx0ICpcclxuXHQgKiAgLy8gc2VsZWN0IGZyb20gJ2RhdGExJywgaW5kaWNlcyAwLCAzIGFuZCA1XHJcblx0ICogIGNoYXJ0LnNlbGVjdChcImRhdGExXCIsIFswLCAzLCA1XSk7XHJcblx0ICovXHJcblx0c2VsZWN0KGlkcz86IHN0cmluZ1tdIHwgc3RyaW5nLCBpbmRpY2VzPzogbnVtYmVyW10sIHJlc2V0T3RoZXI/OiBib29sZWFuKSB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnfSA9ICQkXHJcblxyXG5cdFx0aWYgKCFjb25maWcuZGF0YV9zZWxlY3Rpb25fZW5hYmxlZCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0JCQuJGVsLm1haW4uc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZXN9YClcclxuXHRcdFx0LnNlbGVjdEFsbChgLiR7Q0xBU1Muc2hhcGV9YClcclxuXHRcdFx0LmVhY2goZnVuY3Rpb24oZCwgaSkge1xyXG5cdFx0XHRcdGNvbnN0IHNoYXBlID0gZDNTZWxlY3QodGhpcyk7XHJcblx0XHRcdFx0Y29uc3QgaWQgPSBkLmRhdGEgPyBkLmRhdGEuaWQgOiBkLmlkO1xyXG5cdFx0XHRcdGNvbnN0IHRvZ2dsZSA9ICQkLmdldFRvZ2dsZSh0aGlzLCBkKS5iaW5kKCQkKTtcclxuXHRcdFx0XHRjb25zdCBpc1RhcmdldElkID0gY29uZmlnLmRhdGFfc2VsZWN0aW9uX2dyb3VwZWQgfHwgIWlkcyB8fCBpZHMuaW5kZXhPZihpZCkgPj0gMDtcclxuXHRcdFx0XHRjb25zdCBpc1RhcmdldEluZGV4ID0gIWluZGljZXMgfHwgaW5kaWNlcy5pbmRleE9mKGkpID49IDA7XHJcblx0XHRcdFx0Y29uc3QgaXNTZWxlY3RlZCA9IHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQpO1xyXG5cclxuXHRcdFx0XHQvLyBsaW5lL2FyZWEgc2VsZWN0aW9uIG5vdCBzdXBwb3J0ZWQgeWV0XHJcblx0XHRcdFx0aWYgKHNoYXBlLmNsYXNzZWQoQ0xBU1MubGluZSkgfHwgc2hhcGUuY2xhc3NlZChDTEFTUy5hcmVhKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKGlzVGFyZ2V0SWQgJiYgaXNUYXJnZXRJbmRleCkge1xyXG5cdFx0XHRcdFx0aWYgKGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgJiYgIWlzU2VsZWN0ZWQpIHtcclxuXHRcdFx0XHRcdFx0dG9nZ2xlKHRydWUsIHNoYXBlLmNsYXNzZWQoQ0xBU1MuU0VMRUNURUQsIHRydWUpLCBkLCBpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChyZXNldE90aGVyKSAmJiByZXNldE90aGVyICYmIGlzU2VsZWN0ZWQpIHtcclxuXHRcdFx0XHRcdHRvZ2dsZShmYWxzZSwgc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCwgZmFsc2UpLCBkLCBpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBkYXRhIHBvaW50cyB0byBiZSB1bi1zZWxlY3RlZC5cclxuXHQgKiBAbWV0aG9kIHVuc2VsZWN0XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFtpZHNdIGlkIHZhbHVlIHRvIGJlIHVuc2VsZWN0ZWQuXHJcblx0ICogQHBhcmFtIHtBcnJheX0gW2luZGljZXNdIFRoZSBpbmRleCBhcnJheSBvZiBkYXRhIHBvaW50cy4gSWYgZmFsc3kgdmFsdWUgZ2l2ZW4sIHdpbGwgc2VsZWN0IGFsbCBkYXRhIHBvaW50cy5cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyB1bnNlbGVjdCBhbGwgZGF0YSBwb2ludHNcclxuXHQgKiAgY2hhcnQudW5zZWxlY3QoKTtcclxuXHQgKlxyXG5cdCAqICAvLyB1bnNlbGVjdCBhbGwgZnJvbSAnZGF0YTEnXHJcblx0ICogIGNoYXJ0LnVuc2VsZWN0KFwiZGF0YTFcIik7XHJcblx0ICpcclxuXHQgKiAgLy8gdW5zZWxlY3QgZnJvbSAnZGF0YTEnLCBpbmRpY2VzIDJcclxuXHQgKiAgY2hhcnQudW5zZWxlY3QoXCJkYXRhMVwiLCBbMl0pO1xyXG5cdCAqL1xyXG5cdHVuc2VsZWN0KGlkcz86IHN0cmluZyB8IHN0cmluZ1tdLCBpbmRpY2VzPzogbnVtYmVyW10pIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCRcclxuXHJcblx0XHRpZiAoIWNvbmZpZy5kYXRhX3NlbGVjdGlvbl9lbmFibGVkKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQkJC4kZWwubWFpbi5zZWxlY3RBbGwoYC4ke0NMQVNTLnNoYXBlc31gKVxyXG5cdFx0XHQuc2VsZWN0QWxsKGAuJHtDTEFTUy5zaGFwZX1gKVxyXG5cdFx0XHQuZWFjaChmdW5jdGlvbihkLCBpKSB7XHJcblx0XHRcdFx0Y29uc3Qgc2hhcGUgPSBkM1NlbGVjdCh0aGlzKTtcclxuXHRcdFx0XHRjb25zdCBpZCA9IGQuZGF0YSA/IGQuZGF0YS5pZCA6IGQuaWQ7XHJcblx0XHRcdFx0Y29uc3QgdG9nZ2xlID0gJCQuZ2V0VG9nZ2xlKHRoaXMsIGQpLmJpbmQoJCQpO1xyXG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SWQgPSBjb25maWcuZGF0YV9zZWxlY3Rpb25fZ3JvdXBlZCB8fCAhaWRzIHx8IGlkcy5pbmRleE9mKGlkKSA+PSAwO1xyXG5cdFx0XHRcdGNvbnN0IGlzVGFyZ2V0SW5kZXggPSAhaW5kaWNlcyB8fCBpbmRpY2VzLmluZGV4T2YoaSkgPj0gMDtcclxuXHRcdFx0XHRjb25zdCBpc1NlbGVjdGVkID0gc2hhcGUuY2xhc3NlZChDTEFTUy5TRUxFQ1RFRCk7XHJcblxyXG5cdFx0XHRcdC8vIGxpbmUvYXJlYSBzZWxlY3Rpb24gbm90IHN1cHBvcnRlZCB5ZXRcclxuXHRcdFx0XHRpZiAoc2hhcGUuY2xhc3NlZChDTEFTUy5saW5lKSB8fCBzaGFwZS5jbGFzc2VkKENMQVNTLmFyZWEpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoaXNUYXJnZXRJZCAmJiBpc1RhcmdldEluZGV4ICYmIGNvbmZpZy5kYXRhX3NlbGVjdGlvbl9pc3NlbGVjdGFibGUoZCkgJiYgaXNTZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0dG9nZ2xlKGZhbHNlLCBzaGFwZS5jbGFzc2VkKENMQVNTLlNFTEVDVEVELCBmYWxzZSksIGQsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fVxyXG59O1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcblxyXG4vKipcclxuICogU2hvdy9IaWRlIGRhdGEgc2VyaWVzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5mdW5jdGlvbiBzaG93SGlkZShzaG93LCB0YXJnZXRJZHNWYWx1ZSwgb3B0aW9ucykge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB0YXJnZXRJZHMgPSAkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHNWYWx1ZSk7XHJcblxyXG5cdCQkW2Ake3Nob3cgPyBcInJlbW92ZVwiIDogXCJhZGRcIn1IaWRkZW5UYXJnZXRJZHNgXSh0YXJnZXRJZHMpO1xyXG5cdGNvbnN0IHRhcmdldHMgPSAkJC4kZWwuc3ZnLnNlbGVjdEFsbCgkJC5zZWxlY3RvclRhcmdldHModGFyZ2V0SWRzKSk7XHJcblx0Y29uc3Qgb3BhY2l0eSA9IHNob3cgPyBcIjFcIiA6IFwiMFwiO1xyXG5cclxuXHR0YXJnZXRzLnRyYW5zaXRpb24oKVxyXG5cdFx0LnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5LCBcImltcG9ydGFudFwiKVxyXG5cdFx0LmNhbGwoJCQuZW5kYWxsLCAoKSA9PiB7XHJcblx0XHRcdHRhcmdldHMuc3R5bGUoXCJvcGFjaXR5XCIsIG51bGwpLnN0eWxlKFwib3BhY2l0eVwiLCBvcGFjaXR5KTtcclxuXHRcdH0pO1xyXG5cclxuXHRvcHRpb25zLndpdGhMZWdlbmQgJiYgJCRbYCR7c2hvdyA/IFwic2hvd1wiIDogXCJoaWRlXCJ9TGVnZW5kYF0odGFyZ2V0SWRzKTtcclxuXHJcblx0JCQucmVkcmF3KHtcclxuXHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0d2l0aFVwZGF0ZVhEb21haW46IHRydWUsXHJcblx0XHR3aXRoTGVnZW5kOiB0cnVlXHJcblx0fSk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHQvKipcclxuXHQgKiBTaG93IGRhdGEgc2VyaWVzIG9uIGNoYXJ0XHJcblx0ICogQG1ldGhvZCBzaG93XHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IFt0YXJnZXRJZHNWYWx1ZV0gVGhlIHRhcmdldCBpZCB2YWx1ZS5cclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvYmplY3QgY2FuIGNvbnNpc3Qgd2l0aCBmb2xsb3dpbmcgbWVtYmVyczo8YnI+XHJcblx0ICpcclxuXHQgKiAgICB8IEtleSB8IFR5cGUgfCBkZWZhdWx0IHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IHdpdGhMZWdlbmQgfCBCb29sZWFuIHwgZmFsc2UgfCB3aGV0aGVyIG9yIG5vdCBkaXNwbGF5IGxlZ2VuZCB8XHJcblx0ICpcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqIC8vIHNob3cgJ2RhdGExJ1xyXG5cdCAqIGNoYXJ0LnNob3coXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIHNob3cgJ2RhdGExJyBhbmQgJ2RhdGEzJ1xyXG5cdCAqIGNoYXJ0LnNob3coW1wiZGF0YTFcIiwgXCJkYXRhM1wiXSk7XHJcblx0ICovXHJcblx0c2hvdyh0YXJnZXRJZHNWYWx1ZT86IHN0cmluZ1tdIHwgc3RyaW5nLCBvcHRpb25zID0ge30pIHtcclxuXHRcdHNob3dIaWRlLmNhbGwodGhpcywgdHJ1ZSwgdGFyZ2V0SWRzVmFsdWUsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIEhpZGUgZGF0YSBzZXJpZXMgZnJvbSBjaGFydFxyXG5cdCAqIEBtZXRob2QgaGlkZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWU9YWxsXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgd2l0aExlZ2VuZCB8IEJvb2xlYW4gfCBmYWxzZSB8IHdoZXRoZXIgb3Igbm90IGRpc3BsYXkgbGVnZW5kIHxcclxuXHQgKlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gaGlkZSAnZGF0YTEnXHJcblx0ICogY2hhcnQuaGlkZShcImRhdGExXCIpO1xyXG5cdCAqXHJcblx0ICogLy8gaGlkZSAnZGF0YTEnIGFuZCAnZGF0YTMnXHJcblx0ICogY2hhcnQuaGlkZShbXCJkYXRhMVwiLCBcImRhdGEzXCJdKTtcclxuXHQgKi9cclxuXHRoaWRlKHRhcmdldElkc1ZhbHVlLCBvcHRpb25zID0ge30pIHtcclxuXHRcdHNob3dIaWRlLmNhbGwodGhpcywgZmFsc2UsIHRhcmdldElkc1ZhbHVlLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBUb2dnbGUgZGF0YSBzZXJpZXMgb24gY2hhcnQuIFdoZW4gdGFyZ2V0IGRhdGEgaXMgaGlkZGVuLCBpdCB3aWxsIHNob3cuIElmIGlzIHNob3duLCBpdCB3aWxsIGhpZGUgaW4gdmljZSB2ZXJzYS5cclxuXHQgKiBAbWV0aG9kIHRvZ2dsZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbdGFyZ2V0SWRzVmFsdWU9YWxsXSBUaGUgdGFyZ2V0IGlkIHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9iamVjdCBjYW4gY29uc2lzdCB3aXRoIGZvbGxvd2luZyBtZW1iZXJzOjxicj5cclxuXHQgKlxyXG5cdCAqICAgIHwgS2V5IHwgVHlwZSB8IGRlZmF1bHQgfCBEZXNjcmlwdGlvbiB8XHJcblx0ICogICAgfCAtLS0gfCAtLS0gfCAtLS0gfCAtLS0gfFxyXG5cdCAqICAgIHwgd2l0aExlZ2VuZCB8IEJvb2xlYW4gfCBmYWxzZSB8IHdoZXRoZXIgb3Igbm90IGRpc3BsYXkgbGVnZW5kIHxcclxuXHQgKlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gdG9nZ2xlICdkYXRhMSdcclxuXHQgKiBjaGFydC50b2dnbGUoXCJkYXRhMVwiKTtcclxuXHQgKlxyXG5cdCAqIC8vIHRvZ2dsZSAnZGF0YTEnIGFuZCAnZGF0YTMnXHJcblx0ICogY2hhcnQudG9nZ2xlKFtcImRhdGExXCIsIFwiZGF0YTNcIl0pO1xyXG5cdCAqL1xyXG5cdHRvZ2dsZSh0YXJnZXRJZHMsIG9wdGlvbnMgPSB7fSkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3QgdGFyZ2V0czogYW55ID0ge3Nob3c6IFtdLCBoaWRlOiBbXX07XHJcblxyXG5cdFx0Ly8gc29ydCBzaG93ICYgaGlkZSB0YXJnZXQgaWRzXHJcblx0XHQkJC5tYXBUb1RhcmdldElkcyh0YXJnZXRJZHMpXHJcblx0XHRcdC5mb3JFYWNoKChpZDogc3RyaW5nKSA9PiB0YXJnZXRzWyQkLmlzVGFyZ2V0VG9TaG93KGlkKSA/IFwiaGlkZVwiIDogXCJzaG93XCJdLnB1c2goaWQpKTtcclxuXHJcblx0XHQvLyBwZXJmb3JtIHNob3cgJiBoaWRlIHRhc2sgc2VwYXJhdGVseVxyXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL25hdmVyL2JpbGxib2FyZC5qcy9pc3N1ZXMvNDU0XHJcblx0XHR0YXJnZXRzLnNob3cubGVuZ3RoICYmIHRoaXMuc2hvdyh0YXJnZXRzLnNob3csIG9wdGlvbnMpO1xyXG5cdFx0dGFyZ2V0cy5oaWRlLmxlbmd0aCAmJiBzZXRUaW1lb3V0KCgpID0+IHRoaXMuaGlkZSh0YXJnZXRzLmhpZGUsIG9wdGlvbnMpLCAwKTtcclxuXHR9XHJcbn07XHJcblxyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQuanMgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCB7aXNWYWx1ZSwgaXNEZWZpbmVkfSBmcm9tIFwiLi4vLi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbi8qKlxyXG4gKiBEZWZpbmUgdG9vbHRpcFxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG5jb25zdCB0b29sdGlwID0ge1xyXG5cdC8qKlxyXG5cdCAqIFNob3cgdG9vbHRpcFxyXG5cdCAqIEBtZXRob2QgdG9vbHRpcOKApHNob3dcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gYXJncyBUaGUgb2JqZWN0IGNhbiBjb25zaXN0IHdpdGggZm9sbG93aW5nIG1lbWJlcnM6PGJyPlxyXG5cdCAqXHJcblx0ICogICAgfCBLZXkgfCBUeXBlIHwgRGVzY3JpcHRpb24gfFxyXG5cdCAqICAgIHwgLS0tIHwgLS0tIHwgLS0tIHxcclxuXHQgKiAgICB8IGluZGV4IHwgTnVtYmVyIHwgRGV0ZXJtaW5lIGZvY3VzIGJ5IGluZGV4IHxcclxuXHQgKiAgICB8IHggfCBOdW1iZXIgJnZlcnQ7IERhdGUgfCBEZXRlcm1pbmUgZm9jdXMgYnkgeCBBeGlzIGluZGV4IHxcclxuXHQgKiAgICB8IG1vdXNlIHwgQXJyYXkgfCBEZXRlcm1pbmUgeCBhbmQgeSBjb29yZGluYXRlIHZhbHVlIHJlbGF0aXZlIHRoZSB0YXJnZXRlZCAnLmJiLWV2ZW50LXJlY3QnIHggQXhpcy48YnI+SXQgc2hvdWxkIGJlIHVzZWQgYWxvbmcgd2l0aCBgZGF0YWAsIGBpbmRleGAgb3IgYHhgIHZhbHVlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBzZXQgYXMgYFswLDBdYCB8XHJcblx0ICogICAgfCBkYXRhIHwgT2JqZWN0IHwgV2hlbiBbZGF0YS54c10oT3B0aW9ucy5odG1sIy5kYXRhJTI1RTIlMjU4MCUyNUE0eHMpIG9wdGlvbiBpcyB1c2VkIG9yIFt0b29sdGlwLmdyb3VwZWRdKE9wdGlvbnMuaHRtbCMudG9vbHRpcCkgc2V0IHRvICdmYWxzZScsIGBzaG91bGQgYmUgdXNlZCBnaXZpbmcgdGhpcyBwYXJhbWAuPGJyPjxicj4qKktleToqKjxicj4tIHgge051bWJlciAmdmVyYmFyOyBEYXRlfTogeCBBeGlzIHZhbHVlPGJyPi0gaW5kZXgge051bWJlcn06IHggQXhpcyBpbmRleCAodXNlbGVzcyBmb3IgZGF0YS54cyk8YnI+LSBpZCB7U3RyaW5nfTogZGF0YSBpZDxicj4tIHZhbHVlIHtOdW1iZXJ9OiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmb3IgdG9vbHRpcC4gfFxyXG5cdCAqXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gc2hvdyB0aGUgMm5kIHggQXhpcyBjb29yZGluYXRlIHRvb2x0aXBcclxuXHQgKiAgY2hhcnQudG9vbHRpcC5zaG93KHtcclxuXHQgKiAgICBpbmRleDogMVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRoZSAzcmQgeCBBeGlzIGluIHg6NTAgYW5kIHk6MTAwIGNvb3JkaW5hdGUgb2YgJy5iYi1ldmVudC1yZWN0JyBvZiB0aGUgeCBBeGlzLlxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIHg6IDIsXHJcblx0ICogICAgbW91c2U6IFs1MCwgMTAwXVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBzaG93IHRvb2x0aXAgZm9yIHRpbWVzZXJpZXMgeCBheGlzXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgeDogbmV3IERhdGUoXCIyMDE4LTAxLTAyIDAwOjAwXCIpXHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHdoZW4gZGF0YS54cyBpcyB1c2VkXHJcblx0ICogIGNoYXJ0LnRvb2x0aXAuc2hvdyh7XHJcblx0ICogICAgZGF0YToge1xyXG5cdCAqICAgICAgICB4OiAzLCAgLy8geCBBeGlzIHZhbHVlXHJcblx0ICogICAgICAgIGlkOiBcImRhdGExXCIsICAvLyBkYXRhIGlkXHJcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcclxuXHQgKiAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqXHJcblx0ICogIC8vIHdoZW4gZGF0YS54cyBpc24ndCB1c2VkLCBidXQgdG9vbHRpcC5ncm91cGVkPWZhbHNlIGlzIHNldFxyXG5cdCAqICBjaGFydC50b29sdGlwLnNob3coe1xyXG5cdCAqICAgIGRhdGE6IHtcclxuXHQgKiAgICAgICAgaW5kZXg6IDMsICAvLyBvciAneCcga2V5IHZhbHVlXHJcblx0ICogICAgICAgIGlkOiBcImRhdGExXCIsICAvLyBkYXRhIGlkXHJcblx0ICogICAgICAgIHZhbHVlOiA1MDAgIC8vIGRhdGEgdmFsdWVcclxuXHQgKiAgICB9XHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdHNob3c6IGZ1bmN0aW9uKGFyZ3MpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIHN0YXRlOiB7aW5wdXRUeXBlfX0gPSAkJDtcclxuXHRcdGxldCBpbmRleDtcclxuXHRcdGxldCBtb3VzZTtcclxuXHJcblx0XHQvLyBkZXRlcm1pbmUgbW91c2UgcG9zaXRpb24gb24gdGhlIGNoYXJ0XHJcblx0XHRpZiAoYXJncy5tb3VzZSkge1xyXG5cdFx0XHRtb3VzZSA9IGFyZ3MubW91c2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZGV0ZXJtaW5lIGZvY3VzIGRhdGFcclxuXHRcdGlmIChhcmdzLmRhdGEpIHtcclxuXHRcdFx0Y29uc3QgeSA9ICQkLmdldFlTY2FsZShhcmdzLmRhdGEuaWQpKGFyZ3MuZGF0YS52YWx1ZSk7XHJcblxyXG5cdFx0XHRpZiAoJCQuaXNNdWx0aXBsZVgoKSkge1xyXG5cdFx0XHRcdC8vIGlmIG11bHRpcGxlIHhzLCB0YXJnZXQgcG9pbnQgd2lsbCBiZSBkZXRlcm1pbmVkIGJ5IG1vdXNlXHJcblx0XHRcdFx0bW91c2UgPSBbJCQuc2NhbGUueChhcmdzLmRhdGEueCksIHldO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmICghY29uZmlnLnRvb2x0aXBfZ3JvdXBlZCkge1xyXG5cdFx0XHRcdFx0bW91c2UgPSBbMCwgeV07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpbmRleCA9IGlzVmFsdWUoYXJncy5kYXRhLmluZGV4KSA/IGFyZ3MuZGF0YS5pbmRleCA6ICQkLmdldEluZGV4QnlYKGFyZ3MuZGF0YS54KTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmIChpc0RlZmluZWQoYXJncy54KSkge1xyXG5cdFx0XHRpbmRleCA9ICQkLmdldEluZGV4QnlYKGFyZ3MueCk7XHJcblx0XHR9IGVsc2UgaWYgKGlzRGVmaW5lZChhcmdzLmluZGV4KSkge1xyXG5cdFx0XHRpbmRleCA9IGFyZ3MuaW5kZXg7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZW11bGF0ZSBldmVudHMgdG8gc2hvd1xyXG5cdFx0KGlucHV0VHlwZSA9PT0gXCJtb3VzZVwiID9cclxuXHRcdFx0W1wibW91c2VvdmVyXCIsIFwibW91c2Vtb3ZlXCJdIDogW1widG91Y2hzdGFydFwiXVxyXG5cdFx0KS5mb3JFYWNoKGV2ZW50TmFtZSA9PiB7XHJcblx0XHRcdCQkLmRpc3BhdGNoRXZlbnQoZXZlbnROYW1lLCBpbmRleCwgbW91c2UpO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogSGlkZSB0b29sdGlwXHJcblx0ICogQG1ldGhvZCB0b29sdGlw4oCkaGlkZVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqL1xyXG5cdGhpZGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdCQkLmhpZGVUb29sdGlwKHRydWUpO1xyXG5cdFx0JCQuaGlkZUdyaWRGb2N1cygpO1xyXG5cdFx0JCQudW5leHBhbmRDaXJjbGVzKCk7XHJcblx0XHQkJC51bmV4cGFuZEJhcnMoKTtcclxuXHR9XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7dG9vbHRpcH07XHJcbiIsIi8qKlxyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgfiBwcmVzZW50IE5BVkVSIENvcnAuXHJcbiAqIGJpbGxib2FyZC5qcyBwcm9qZWN0IGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKi9cclxuaW1wb3J0IHtpc0FycmF5LCBpc09iamVjdH0gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcblx0LyoqXHJcblx0ICogR2V0IGFuZCBzZXQgeCB2YWx1ZXMgZm9yIHRoZSBjaGFydC5cclxuXHQgKiBAbWV0aG9kIHhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB4IElmIHggaXMgZ2l2ZW4sIHggdmFsdWVzIG9mIGV2ZXJ5IHRhcmdldCB3aWxsIGJlIHVwZGF0ZWQuIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCBjdXJyZW50IHggdmFsdWVzIHdpbGwgYmUgcmV0dXJuZWQgYXMgYW4gT2JqZWN0IHdob3NlIGtleXMgYXJlIHRoZSB0YXJnZXQgaWRzLlxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0geHNcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBHZXQgY3VycmVudCB4IHZhbHVlc1xyXG5cdCAqICBjaGFydC54KCk7XHJcblx0ICpcclxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xyXG5cdCAqICBjaGFydC54KFsxMDAsIDIwMCwgMzAwLCA0MDAsIC4uLl0pO1xyXG5cdCAqL1xyXG5cdHgoeCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3QgaXNDYXRlZ29yaXplZCA9ICQkLmlzQ3VzdG9tWCgpICYmICQkLmlzQ2F0ZWdvcml6ZWQoKTtcclxuXHJcblx0XHRpZiAoaXNBcnJheSh4KSkge1xyXG5cdFx0XHRpZiAoaXNDYXRlZ29yaXplZCkge1xyXG5cdFx0XHRcdHRoaXMuY2F0ZWdvcmllcyh4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQkJC51cGRhdGVUYXJnZXRYKCQkLmRhdGEudGFyZ2V0cywgeCk7XHJcblxyXG5cdFx0XHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdFx0XHR3aXRoVXBkYXRlT3JnWERvbWFpbjogdHJ1ZSxcclxuXHRcdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaXNDYXRlZ29yaXplZCA/IHRoaXMuY2F0ZWdvcmllcygpIDogJCQuZGF0YS54cztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgYW5kIHNldCB4IHZhbHVlcyBmb3IgdGhlIGNoYXJ0LlxyXG5cdCAqIEBtZXRob2QgeHNcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge0FycmF5fSB4cyBJZiB4cyBpcyBnaXZlbiwgc3BlY2lmaWVkIHRhcmdldCdzIHggdmFsdWVzIHdpbGwgYmUgdXBkYXRlZC4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIGN1cnJlbnQgeCB2YWx1ZXMgd2lsbCBiZSByZXR1cm5lZCBhcyBhbiBPYmplY3Qgd2hvc2Uga2V5cyBhcmUgdGhlIHRhcmdldCBpZHMuXHJcblx0ICogQHJldHVybiB7T2JqZWN0fSB4c1xyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIEdldCBjdXJyZW50IHggdmFsdWVzXHJcblx0ICogIGNoYXJ0LnhzKCk7XHJcblx0ICpcclxuXHQgKiAgLy8gVXBkYXRlIHggdmFsdWVzIGZvciBhbGwgdGFyZ2V0c1xyXG5cdCAqICBjaGFydC54cyh7XHJcblx0ICogICAgZGF0YTE6IFsxMCwgMjAsIDMwLCA0MCwgLi4uXSxcclxuXHQgKiAgICBkYXRhMjogWzEwMCwgMjAwLCAzMDAsIDQwMCwgLi4uXVxyXG5cdCAqICB9KTtcclxuXHQgKi9cclxuXHR4cyh4cykge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cclxuXHRcdGlmIChpc09iamVjdCh4cykpIHtcclxuXHRcdFx0JCQudXBkYXRlVGFyZ2V0WHMoJCQuZGF0YS50YXJnZXRzLCB4cyk7XHJcblxyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAkJC5kYXRhLnhzO1xyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQge3pvb21JZGVudGl0eSBhcyBkM1pvb21JZGVudGl0eSwgem9vbVRyYW5zZm9ybSBhcyBkM1pvb21UcmFuc2Zvcm19IGZyb20gXCJkMy16b29tXCI7XHJcbmltcG9ydCBDTEFTUyBmcm9tIFwiLi4vLi4vY29uZmlnL2NsYXNzZXNcIjtcclxuaW1wb3J0IHtjYWxsRm4sIGV4dGVuZCwgZ2V0TWluTWF4LCBpc0RlZmluZWQsIGlzT2JqZWN0LCBpc1N0cmluZ30gZnJvbSBcIi4uLy4uL21vZHVsZS91dGlsXCI7XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGRvbWFpbiBpcyB3aXRoaW4gem9vbSByYW5nZVxyXG4gKiBAcGFyYW0ge0FycmF5fSBkb21haW5cclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQHByaXZhdGVcclxuICovXHJcbmZ1bmN0aW9uIHdpdGhpblJhbmdlKGRvbWFpbjogbnVtYmVyW10sIHJhbmdlOiBudW1iZXJbXSk6IGJvb2xlYW4ge1xyXG5cdGNvbnN0IFttaW4sIG1heF0gPSByYW5nZTtcclxuXHJcblx0cmV0dXJuIGRvbWFpbi5ldmVyeSgodiwgaSkgPT4gKFxyXG5cdFx0aSA9PT0gMCA/ICh2ID49IG1pbikgOiAodiA8PSBtYXgpXHJcblx0KSk7XHJcbn07XHJcblxyXG4vKipcclxuICogWm9vbSBieSBnaXZpbmcgeCBkb21haW4uXHJcbiAqIC0gKipOT1RFOioqXHJcbiAqICAtIEZvciBgd2hlZWxgIHR5cGUgem9vbSwgdGhlIG1pbmltdW0gem9vbSByYW5nZSB3aWxsIGJlIHNldCBhcyB0aGUgZ2l2ZW4gZG9tYWluLiBUbyBnZXQgdGhlIGluaXRpYWwgc3RhdGUsIFsudW56b29tKCldKCN1bnpvb20pIHNob3VsZCBiZSBjYWxsZWQuXHJcbiAqICAtIFRvIGJlIHVzZWQgW3pvb20uZW5hYmxlZF0oT3B0aW9ucy5odG1sIy56b29tKSBvcHRpb24gc2hvdWxkIGJlIHNldCBhcyBgdHJ1dGh5YC5cclxuICogQG1ldGhvZCB6b29tXHJcbiAqIEBpbnN0YW5jZVxyXG4gKiBAbWVtYmVyb2YgQ2hhcnRcclxuICogQHBhcmFtIHtBcnJheX0gZG9tYWluVmFsdWUgSWYgZG9tYWluIGlzIGdpdmVuLCB0aGUgY2hhcnQgd2lsbCBiZSB6b29tZWQgdG8gdGhlIGdpdmVuIGRvbWFpbi4gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBjdXJyZW50IHpvb21lZCBkb21haW4gd2lsbCBiZSByZXR1cm5lZC5cclxuICogQHJldHVybiB7QXJyYXl9IGRvbWFpbiB2YWx1ZSBpbiBhcnJheVxyXG4gKiBAZXhhbXBsZVxyXG4gKiAgLy8gWm9vbSB0byBzcGVjaWZpZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKFsxMCwgMjBdKTtcclxuICpcclxuICogIC8vIEdldCB0aGUgY3VycmVudCB6b29tZWQgZG9tYWluXHJcbiAqICBjaGFydC56b29tKCk7XHJcbiAqL1xyXG5jb25zdCB6b29tID0gZnVuY3Rpb24oZG9tYWluVmFsdWU/OiBudW1iZXJbXSkge1xyXG5cdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRjb25zdCB7Y29uZmlnLCBzY2FsZX0gPSAkJDtcclxuXHRsZXQgZG9tYWluID0gZG9tYWluVmFsdWU7XHJcblx0bGV0IHJlc3VsdERvbWFpbjtcclxuXHJcblx0aWYgKGNvbmZpZy56b29tX2VuYWJsZWQgJiYgZG9tYWluICYmIHdpdGhpblJhbmdlKGRvbWFpbiwgJCQuZ2V0Wm9vbURvbWFpbigpKSkge1xyXG5cdFx0Y29uc3QgaXNUaW1lU2VyaWVzID0gJCQuaXNUaW1lU2VyaWVzKCk7XHJcblxyXG5cdFx0aWYgKGlzVGltZVNlcmllcykge1xyXG5cdFx0XHRkb21haW4gPSBkb21haW4ubWFwKHggPT4gJCQucGFyc2VEYXRlKHgpKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoY29uZmlnLnN1YmNoYXJ0X3Nob3cpIHtcclxuXHRcdFx0Y29uc3QgeFNjYWxlID0gc2NhbGUuem9vbSB8fCBzY2FsZS54O1xyXG5cclxuXHRcdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBbeFNjYWxlKGRvbWFpblswXSksIHhTY2FsZShkb21haW5bMV0pXSk7XHJcblx0XHRcdHJlc3VsdERvbWFpbiA9IGRvbWFpbjtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHNjYWxlLnguZG9tYWluKGRvbWFpbik7XHJcblx0XHRcdHNjYWxlLnpvb20gPSBzY2FsZS54O1xyXG5cdFx0XHQkJC5heGlzLnguc2NhbGUoc2NhbGUuem9vbSk7XHJcblxyXG5cdFx0XHRyZXN1bHREb21haW4gPSBzY2FsZS56b29tLm9yZ0RvbWFpbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdCQkLnJlZHJhdyh7XHJcblx0XHRcdHdpdGhUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHR3aXRoWTogY29uZmlnLnpvb21fcmVzY2FsZSxcclxuXHRcdFx0d2l0aERpbWVuc2lvbjogZmFsc2VcclxuXHRcdH0pO1xyXG5cclxuXHRcdCQkLnNldFpvb21SZXNldEJ1dHRvbigpO1xyXG5cdFx0Y2FsbEZuKGNvbmZpZy56b29tX29uem9vbSwgdGhpcywgcmVzdWx0RG9tYWluKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0cmVzdWx0RG9tYWluID0gc2NhbGUuem9vbSA/XHJcblx0XHRcdHNjYWxlLnpvb20uZG9tYWluKCkgOiBzY2FsZS54Lm9yZ0RvbWFpbigpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJlc3VsdERvbWFpbjtcclxufTtcclxuXHJcbmV4dGVuZCh6b29tLCB7XHJcblx0LyoqXHJcblx0ICogRW5hYmxlIGFuZCBkaXNhYmxlIHpvb21pbmcuXHJcblx0ICogQG1ldGhvZCB6b29t4oCkZW5hYmxlXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gZW5hYmxlZCBQb3NzaWJsZSBzdHJpbmcgdmFsdWVzIGFyZSBcIndoZWVsXCIgb3IgXCJkcmFnXCIuIElmIGVuYWJsZWQgaXMgdHJ1ZSwgXCJ3aGVlbFwiIHdpbGwgYmUgdXNlZC4gSWYgZmFsc2UgaXMgZ2l2ZW4sIHpvb21pbmcgd2lsbCBiZSBkaXNhYmxlZC48YnI+V2hlbiBzZXQgdG8gZmFsc2UsIHRoZSBjdXJyZW50IHpvb21pbmcgc3RhdHVzIHdpbGwgYmUgcmVzZXQuXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gRW5hYmxlIHpvb21pbmcgdXNpbmcgdGhlIG1vdXNlIHdoZWVsXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKHRydWUpO1xyXG5cdCAqICAvLyBPclxyXG5cdCAqICBjaGFydC56b29tLmVuYWJsZShcIndoZWVsXCIpO1xyXG5cdCAqXHJcblx0ICogIC8vIEVuYWJsZSB6b29taW5nIGJ5IGRyYWdnaW5nXHJcblx0ICogIGNoYXJ0Lnpvb20uZW5hYmxlKFwiZHJhZ1wiKTtcclxuXHQgKlxyXG5cdCAqICAvLyBEaXNhYmxlIHpvb21pbmdcclxuXHQgKiAgY2hhcnQuem9vbS5lbmFibGUoZmFsc2UpO1xyXG5cdCAqL1xyXG5cdGVuYWJsZTogZnVuY3Rpb24oZW5hYmxlZCkge1xyXG5cdFx0Y29uc3QgJCQgPSB0aGlzLmludGVybmFsO1xyXG5cdFx0Y29uc3Qge2NvbmZpZ30gPSAkJFxyXG5cdFx0bGV0IGVuYWJsZVR5cGU6IGFueSA9IGVuYWJsZWQ7XHJcblxyXG5cdFx0aWYgKGVuYWJsZWQpIHtcclxuXHRcdFx0ZW5hYmxlVHlwZSA9IGlzU3RyaW5nKGVuYWJsZWQpICYmIC9eKGRyYWd8d2hlZWwpJC8udGVzdChlbmFibGVkKSA/XHJcblx0XHRcdFx0e3R5cGU6IGVuYWJsZWR9IDogZW5hYmxlZDtcclxuXHRcdH1cclxuXHJcblx0XHRjb25maWcuem9vbV9lbmFibGVkID0gZW5hYmxlVHlwZTtcclxuXHJcblx0XHRpZiAoISQkLnpvb20pIHtcclxuXHRcdFx0JCQuaW5pdFpvb20oKTtcclxuXHRcdFx0JCQuYmluZFpvb21FdmVudCgpO1xyXG5cdFx0fSBlbHNlIGlmIChlbmFibGVkID09PSBmYWxzZSkge1xyXG5cdFx0XHQkJC5iaW5kWm9vbUV2ZW50KGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHQkJC51cGRhdGVBbmRSZWRyYXcoKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXQgb3IgZ2V0IHggQXhpcyBtYXhpbXVtIHpvb20gcmFuZ2UgdmFsdWVcclxuXHQgKiBAbWV0aG9kIHpvb23igKRtYXhcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge051bWJlcn0gW21heF0gbWF4aW11bSB2YWx1ZSB0byBzZXQgZm9yIHpvb21cclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHpvb20gbWF4IHZhbHVlXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgLy8gU2V0IG1heGltdW0gcmFuZ2UgdmFsdWVcclxuXHQgKiAgY2hhcnQuem9vbS5tYXgoMjApO1xyXG5cdCAqL1xyXG5cdG1heDogZnVuY3Rpb24obWF4PzogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWcsIG9yZzoge3hEb21haW59fSA9ICQkO1xyXG5cclxuXHRcdGlmIChtYXggPT09IDAgfHwgbWF4KSB7XHJcblx0XHRcdGNvbmZpZy56b29tX3hfbWF4ID0gZ2V0TWluTWF4KFwibWF4XCIsIFt4RG9tYWluWzFdLCBtYXhdKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY29uZmlnLnpvb21feF9tYXg7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0IG9yIGdldCB4IEF4aXMgbWluaW11bSB6b29tIHJhbmdlIHZhbHVlXHJcblx0ICogQG1ldGhvZCB6b29t4oCkbWluXHJcblx0ICogQGluc3RhbmNlXHJcblx0ICogQG1lbWJlcm9mIENoYXJ0XHJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IFttaW5dIG1pbmltdW0gdmFsdWUgdG8gc2V0IGZvciB6b29tXHJcblx0ICogQHJldHVybiB7TnVtYmVyfSB6b29tIG1pbiB2YWx1ZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFNldCBtaW5pbXVtIHJhbmdlIHZhbHVlXHJcblx0ICogIGNoYXJ0Lnpvb20ubWluKC0xKTtcclxuXHQgKi9cclxuXHRtaW46IGZ1bmN0aW9uKG1pbj86IG51bWJlcik6IG51bWJlciB7XHJcblx0XHRjb25zdCAkJCA9IHRoaXMuaW50ZXJuYWw7XHJcblx0XHRjb25zdCB7Y29uZmlnLCBvcmc6IHt4RG9tYWlufX0gPSAkJDtcclxuXHJcblx0XHRpZiAobWluID09PSAwIHx8IG1pbikge1xyXG5cdFx0XHRjb25maWcuem9vbV94X21pbiA9IGdldE1pbk1heChcIm1pblwiLCBbeERvbWFpblswXSwgbWluXSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbmZpZy56b29tX3hfbWluO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCB6b29tIHJhbmdlXHJcblx0ICogQG1ldGhvZCB6b29t4oCkcmFuZ2VcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3JhbmdlXVxyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gem9vbSByYW5nZSB2YWx1ZVxyXG5cdCAqIHtcclxuXHQgKiAgIG1pbjogMCxcclxuXHQgKiAgIG1heDogMTAwXHJcblx0ICogfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGNoYXJ0Lnpvb20ucmFuZ2Uoe1xyXG5cdCAqICAgICAgbWluOiAxMCxcclxuXHQgKiAgICAgIG1heDogMTAwXHJcblx0ICogIH0pO1xyXG5cdCAqL1xyXG5cdHJhbmdlOiBmdW5jdGlvbihyYW5nZSkge1xyXG5cdFx0Y29uc3Qgem9vbSA9IHRoaXMuem9vbTtcclxuXHJcblx0XHRpZiAoaXNPYmplY3QocmFuZ2UpKSB7XHJcblx0XHRcdGNvbnN0IHttaW4sIG1heH0gPSByYW5nZTtcclxuXHJcblx0XHRcdGlzRGVmaW5lZChtaW4pICYmIHpvb20ubWluKG1pbik7XHJcblx0XHRcdGlzRGVmaW5lZChtYXgpICYmIHpvb20ubWF4KG1heCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0bWluOiB6b29tLm1pbigpLFxyXG5cdFx0XHRtYXg6IHpvb20ubWF4KClcclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuXHR6b29tLFxyXG5cclxuXHQvKipcclxuXHQgKiBVbnpvb20gem9vbWVkIGFyZWFcclxuXHQgKiBAbWV0aG9kIHVuem9vbVxyXG5cdCAqIEBpbnN0YW5jZVxyXG5cdCAqIEBtZW1iZXJvZiBDaGFydFxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIGNoYXJ0LnVuem9vbSgpO1xyXG5cdCAqL1xyXG5cdHVuem9vbSgpIHtcclxuXHRcdGNvbnN0ICQkID0gdGhpcy5pbnRlcm5hbDtcclxuXHRcdGNvbnN0IHtjb25maWd9ID0gJCRcclxuXHJcblx0XHRpZiAoJCQuc2NhbGUuem9vbSkge1xyXG5cdFx0XHRjb25maWcuc3ViY2hhcnRfc2hvdyA/XHJcblx0XHRcdFx0JCQuYnJ1c2guZ2V0U2VsZWN0aW9uKCkuY2FsbCgkJC5icnVzaC5tb3ZlLCBudWxsKSA6XHJcblx0XHRcdFx0JCQuem9vbS51cGRhdGVUcmFuc2Zvcm1TY2FsZShkM1pvb21JZGVudGl0eSk7XHJcblxyXG5cdFx0XHQkJC51cGRhdGVab29tKHRydWUpO1xyXG5cdFx0XHQkJC56b29tLnJlc2V0QnRuICYmICQkLnpvb20ucmVzZXRCdG4uc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcclxuXHJcblx0XHRcdC8vIHJlc2V0IHRyYW5zZm9ybVxyXG5cdFx0XHRjb25zdCBldmVudFJlY3RzID0gJCQuJGVsLm1haW4uc2VsZWN0KGAuJHtDTEFTUy5ldmVudFJlY3RzfWApO1xyXG5cclxuXHRcdFx0aWYgKGQzWm9vbVRyYW5zZm9ybShldmVudFJlY3RzLm5vZGUoKSkgIT09IGQzWm9vbUlkZW50aXR5KSB7XHJcblx0XHRcdFx0JCQuem9vbS50cmFuc2Zvcm0oZXZlbnRSZWN0cywgZDNab29tSWRlbnRpdHkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQkJC5yZWRyYXcoe1xyXG5cdFx0XHRcdHdpdGhUcmFuc2l0aW9uOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhVcGRhdGVPcmdYRG9tYWluOiB0cnVlLFxyXG5cdFx0XHRcdHdpdGhZOiBjb25maWcuem9vbV9yZXNjYWxlXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuIiwiLyoqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNyB+IHByZXNlbnQgTkFWRVIgQ29ycC5cclxuICogYmlsbGJvYXJkLmpzIHByb2plY3QgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqL1xyXG5pbXBvcnQgQ2hhcnRJbnRlcm5hbCBmcm9tIFwiLi4vQ2hhcnRJbnRlcm5hbC9DaGFydEludGVybmFsXCI7XHJcbmltcG9ydCB7bG9hZENvbmZpZ30gZnJvbSBcIi4uL2NvbmZpZy9jb25maWdcIjtcclxuaW1wb3J0IHtleHRlbmQsIGlzRnVuY3Rpb259IGZyb20gXCIuLi9tb2R1bGUvdXRpbFwiO1xyXG5pbXBvcnQgUGx1Z2luIGZyb20gXCIuLi9QbHVnaW4vUGx1Z2luXCI7XHJcblxyXG5pbXBvcnTCoGFwaUF4aXMgZnJvbSBcIi4vYXBpL2F4aXNcIjtcclxuaW1wb3J0wqBhcGlDYXRlZ29yeSBmcm9tIFwiLi9hcGkvY2F0ZWdvcnlcIjtcclxuaW1wb3J0IGFwaUNoYXJ0IGZyb20gXCIuL2FwaS9jaGFydFwiO1xyXG5pbXBvcnTCoGFwaUNvbG9yIGZyb20gXCIuL2FwaS9jb2xvclwiO1xyXG5pbXBvcnTCoGFwaURhdGEgZnJvbSBcIi4vYXBpL2RhdGFcIjtcclxuaW1wb3J0wqBhcGlFeHBvcnQgZnJvbSBcIi4vYXBpL2V4cG9ydFwiO1xyXG5pbXBvcnTCoGFwaUZsb3cgZnJvbSBcIi4vYXBpL2Zsb3dcIjtcclxuaW1wb3J0wqBhcGlGb2N1cyBmcm9tIFwiLi9hcGkvZm9jdXNcIjtcclxuaW1wb3J0wqBhcGlYR3JpZCBmcm9tIFwiLi9hcGkvZ3JpZC54XCI7XHJcbmltcG9ydMKgYXBpWUdyaWQgZnJvbSBcIi4vYXBpL2dyaWQueVwiO1xyXG5pbXBvcnTCoGFwaUdyb3VwIGZyb20gXCIuL2FwaS9ncm91cFwiO1xyXG5pbXBvcnTCoGFwaUxlZ2VuZCBmcm9tIFwiLi9hcGkvbGVnZW5kXCI7XHJcbmltcG9ydMKgYXBpTG9hZCBmcm9tIFwiLi9hcGkvbG9hZFwiO1xyXG5pbXBvcnTCoGFwaVJlZ2lvbiBmcm9tIFwiLi9hcGkvcmVnaW9uc1wiO1xyXG5pbXBvcnTCoGFwaVNlbGVjdGlvbiBmcm9tIFwiLi9hcGkvc2VsZWN0aW9uXCI7XHJcbmltcG9ydMKgYXBpU2hvdyBmcm9tIFwiLi9hcGkvc2hvd1wiO1xyXG5pbXBvcnTCoGFwaVRvb2x0aXAgZnJvbSBcIi4vYXBpL3Rvb2x0aXBcIjtcclxuaW1wb3J0wqBhcGlYIGZyb20gXCIuL2FwaS94XCI7XHJcbmltcG9ydCBhcGlab29tIGZyb20gXCIuL2FwaS96b29tXCI7XHJcblxyXG4vKipcclxuICogTWFpbiBjaGFydCBjbGFzcy5cclxuICogLSBOb3RlOiBJbnN0YW50aWF0ZWQgdmlhIGBiYi5nZW5lcmF0ZSgpYC5cclxuICogQGNsYXNzIENoYXJ0XHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBjaGFydCA9IGJiLmdlbmVyYXRlKHtcclxuICogIGRhdGE6IHtcclxuICogICAgY29sdW1uczogW1xyXG4gKlx0ICAgIFtcInhcIiwgXCIyMDE1LTExLTAyXCIsIFwiMjAxNS0xMi0wMVwiLCBcIjIwMTYtMDEtMDFcIiwgXCIyMDE2LTAyLTAxXCIsIFwiMjAxNi0wMy0wMVwiXSxcclxuICogXHQgICAgW1wiY291bnQxXCIsIDExLCA4LCA3LCA2LCA1IF0sXHJcbiAqXHQgICAgW1wiY291bnQyXCIsIDksIDMsIDYsIDIsIDggXVxyXG4gKiAgIF19XHJcbiAqIH1cclxuICogQHNlZSB7QGxpbmsgYmIuZ2VuZXJhdGV9IGZvciB0aGUgaW5pdGlhbGl6YXRpb24uXHJcbiovXHJcbi8qKlxyXG4gKiBBY2Nlc3MgaW5zdGFuY2UncyBwcmltYXJ5IG5vZGUgZWxlbWVudHNcclxuICogQG1lbWJlciB7T2JqZWN0fSAkXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAkXHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmNoYXJ0IFdyYXBwZXIgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5zdmcgTWFpbiBzdmcgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5kZWZzIERlZmluaXRpb24gZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5tYWluIE1haW4gZ3JvdXBpbmcgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC50b29sdGlwIFRvb2x0aXAgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5sZWdlbmQgTGVnZW5kIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtkMy5zZWxlY3Rpb259ICQudGl0bGUgVGl0bGUgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5ncmlkIEdyaWQgZWxlbWVudFxyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5hcmMgQXJjIGVsZW1lbnRcclxuICogQHByb3BlcnR5IHtPYmplY3R9ICQuYmFyXHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmJhci5iYXJzIEJhciBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gJC5saW5lXHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUubGluZXMgTGluZSBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge2QzLnNlbGVjdGlvbn0gJC5saW5lLmFyZWFzIEFyZWFzIGVsZW1lbnRzXHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLmxpbmUuY2lyY2xlcyBEYXRhIHBvaW50IGNpcmNsZSBlbGVtZW50c1xyXG4gKiBAcHJvcGVydHkge09iamVjdH0gJC50ZXh0XHJcbiAqIEBwcm9wZXJ0eSB7ZDMuc2VsZWN0aW9ufSAkLnRleHQudGV4dHMgRGF0YSBsYWJlbCB0ZXh0IGVsZW1lbnRzXHJcbiAqIEBtZW1iZXJvZiBDaGFydFxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7IC4uLiB9KTtcclxuICpcclxuICogY2hhcnQuJC5jaGFydDsgLy8gd3JhcHBlciBlbGVtZW50XHJcbiAqIGNoYXJ0LiQubGluZS5jaXJjbGVzOyAgLy8gYWxsIGRhdGEgcG9pbnQgY2lyY2xlIGVsZW1lbnRzXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaGFydCB7XHJcblx0LyoqXHJcblx0ICogUGx1Z2luIGluc3RhbmNlIGFycmF5XHJcblx0ICogQG1lbWJlciB7QXJyYXl9IHBsdWdpbnNcclxuXHQgKiBAbWVtYmVyb2YgQ2hhcnRcclxuXHQgKiBAaW5zdGFuY2VcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICB2YXIgY2hhcnQgPSBiYi5nZW5lcmF0ZSh7XHJcblx0ICogICAgIC4uLlxyXG5cdCAqICAgICBwbHVnaW5zOiBbXHJcblx0ICogICAgICAgIG5ldyBiYi5wbHVnaW4uc3RhbmZvcmQoeyAuLi4gfSksXHJcblx0ICogICAgICAgIG5ldyBQbHVnaW5BKClcclxuXHQgKiAgICAgXVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICBjaGFydC5wbHVnaW5zOyAvLyBbU3RhbmZvcmQsIFBsdWdpbkFdIC0gaW5zdGFuY2UgYXJyYXlcclxuXHQgKi9cclxuXHRwdWJsaWMgcGx1Z2luczogUGx1Z2luW10gPSBbXTtcclxuXHRwdWJsaWMgaW50ZXJuYWw6IENoYXJ0SW50ZXJuYWw7XHJcblxyXG5cdGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuXHRcdGNvbnN0IGN0eCA9IHRoaXM7XHJcblx0XHRjb25zdCAkJCA9IG5ldyBDaGFydEludGVybmFsKGN0eCk7XHJcblxyXG5cdFx0dGhpcy5pbnRlcm5hbCA9ICQkO1xyXG5cclxuXHRcdGJpbmRUaGlzKENoYXJ0LnByb3RvdHlwZSwgdGhpcywgdGhpcyk7XHJcblx0XHRsb2FkQ29uZmlnLmNhbGwoJCQsIG9wdGlvbnMpO1xyXG5cclxuXHRcdCQkLmJlZm9yZUluaXQoKTtcclxuXHRcdCQkLmluaXQoKTtcclxuXHRcdCQkLmFmdGVySW5pdCgpO1xyXG5cdH1cclxufVxyXG5cclxuLy8gYmluZCB0byBuYW1lc3BhY2VkIEFQSXNcclxuZnVuY3Rpb24gYmluZFRoaXMoZm4sIHRhcmdldCwgYXJnVGhpcykge1xyXG5cdE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGtleSA9PiB7XHJcblx0XHRjb25zdCBpc0Z1bmMgPSBpc0Z1bmN0aW9uKGZuW2tleV0pO1xyXG5cdFx0Y29uc3QgaXNDaGlsZCA9IHRhcmdldCAhPT0gYXJnVGhpcztcclxuXHRcdGNvbnN0IGhhc0NoaWxkID0gT2JqZWN0LmtleXMoZm5ba2V5XSkubGVuZ3RoID4gMDtcclxuXHJcblx0XHRpZiAoaXNGdW5jICYmICghaXNDaGlsZCAmJiBoYXNDaGlsZCB8fCBpc0NoaWxkKSkge1xyXG5cdFx0XHR0YXJnZXRba2V5XSA9IGZuW2tleV0uYmluZChhcmdUaGlzKTtcclxuXHRcdH0gZWxzZSBpZiAoIWlzRnVuYykge1xyXG5cdFx0XHR0YXJnZXRba2V5XSA9IHt9XHJcblx0XHR9XHJcblxyXG5cdFx0aGFzQ2hpbGQgJiYgYmluZFRoaXMoZm5ba2V5XSwgdGFyZ2V0W2tleV0sIGFyZ1RoaXMpO1xyXG5cdH0pO1xyXG59O1xyXG5cclxuLy8gZXh0ZW5kIEFQSSBhcyBwYXJ0IG9mIENoYXJ0IGNsYXNzXHJcbmV4dGVuZChDaGFydC5wcm90b3R5cGUsIFtcclxuXHRhcGlBeGlzLFxyXG5cdGFwaUNhdGVnb3J5LFxyXG5cdGFwaUNoYXJ0LFxyXG5cdGFwaUNvbG9yLFxyXG5cdGFwaURhdGEsXHJcblx0YXBpRXhwb3J0LFxyXG5cdGFwaUZsb3csXHJcblx0YXBpRm9jdXMsXHJcblx0YXBpWEdyaWQsXHJcblx0YXBpWUdyaWQsXHJcblx0YXBpR3JvdXAsXHJcblx0YXBpTGVnZW5kLFxyXG5cdGFwaUxvYWQsXHJcblx0YXBpUmVnaW9uLFxyXG5cdGFwaVNlbGVjdGlvbixcclxuXHRhcGlTaG93LFxyXG5cdGFwaVRvb2x0aXAsXHJcblx0YXBpWCxcclxuXHRhcGlab29tXHJcbl0pO1xyXG4iLCIvKipcclxuICogQ29weXJpZ2h0IChjKSAyMDE3IH4gcHJlc2VudCBOQVZFUiBDb3JwLlxyXG4gKiBiaWxsYm9hcmQgcHJvamVjdCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcclxuICovXHJcbmltcG9ydCBDaGFydCBmcm9tIFwiLi9jaGFydC9DaGFydFwiO1xyXG5pbXBvcnQge2lzT2JqZWN0LCBtZXJnZU9ian0gZnJvbSBcIi4vbW9kdWxlL3V0aWxcIjtcclxuXHJcbmV4cG9ydCB7YmIsIGJiIGFzIGRlZmF1bHR9O1xyXG5cclxubGV0IGRlZmF1bHRzID0ge307XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBiYlxyXG4gKiBAdmVyc2lvbiAyLjAuMC1hbHBoYVxyXG4gKi9cclxuY29uc3QgYmIgPSB7XHJcblx0LyoqXHJcblx0ICogVmVyc2lvbiBpbmZvcm1hdGlvblxyXG5cdCAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB2ZXJzaW9uIHZlcnNpb25cclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAgIGJiLnZlcnNpb247ICAvLyBcIjEuMC4wXCJcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKi9cclxuXHR2ZXJzaW9uOiBcIjIuMC4wLWFscGhhXCIsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEdlbmVyYXRlIGNoYXJ0XHJcblx0ICogQHBhcmFtIHtPcHRpb25zfSBvcHRpb25zIGNoYXJ0IG9wdGlvbnNcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKiBAcmV0dXJuIHtDaGFydH1cclxuXHQgKiBAc2VlIHtAbGluayBPcHRpb25zfSBmb3IgZGlmZmVyZW50IGdlbmVyYXRpb24gb3B0aW9uc1xyXG5cdCAqIEBzZWUge0BsaW5rIENoYXJ0fSBmb3IgZGlmZmVyZW50IG1ldGhvZHMgQVBJXHJcblx0ICogQGV4YW1wbGVcclxuXHQgKiAgPCEtLSBjaGFydCBob2xkZXIgLS0+XHJcblx0ICogPGRpdiBpZD1cIkxpbmVDaGFydFwiPjwvZGl2PlxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogICAvLyBnZW5lcmF0ZSBjaGFydCB3aXRoIG9wdGlvbnNcclxuXHQgKiAgdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoe1xyXG5cdCAqICAgICAgXCJiaW5kdG9cIjogXCIjTGluZUNoYXJ0XCJcclxuXHQgKiAgICAgIFwiZGF0YVwiOiB7XHJcblx0ICogICAgICAgICAgXCJjb2x1bW5zXCI6IFtcclxuXHQgKiAgICAgICAgICAgICAgW1wiZGF0YTFcIiwgMzAsIDIwMCwgMTAwLCA0MDAsIDE1MCwgMjUwXSxcclxuXHQgKiAgICAgICAgICAgICAgW1wiZGF0YTJcIiwgNTAsIDIwLCAxMCwgNDAsIDE1LCAyNV1cclxuXHQgKiAgICAgICAgICAgXVxyXG5cdCAqICAgICAgfVxyXG5cdCAqICB9KTtcclxuXHQgKlxyXG5cdCAqICAvLyBjYWxsIHNvbWUgQVBJXHJcblx0ICogIC8vIGV4KSBnZXQgdGhlIGRhdGEgb2YgJ2RhdGExJ1xyXG5cdCAqICBjaGFydC5kYXRhKFwiZGF0YTFcIik7XHJcblx0ICovXHJcblx0Z2VuZXJhdGUoY29uZmlnKSB7XHJcblx0XHRjb25zdCBvcHRpb25zID0gbWVyZ2VPYmooe30sIGRlZmF1bHRzLCBjb25maWcpO1xyXG5cdFx0Y29uc3QgaW5zdCA9IG5ldyBDaGFydChvcHRpb25zKTtcclxuXHJcblxyXG5cdFx0aW5zdC5pbnRlcm5hbC5jaGFydHMgPSB0aGlzLmluc3RhbmNlO1xyXG5cdFx0dGhpcy5pbnN0YW5jZS5wdXNoKGluc3QpO1xyXG5cclxuXHRcdHJldHVybiBpbnN0O1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIFNldCBvciBnZXQgZ2xvYmFsIGRlZmF1bHQgb3B0aW9ucy5cclxuXHQgKiAtICoqTk9URToqKlxyXG5cdCAqICAgLSBUaGUgb3B0aW9ucyB2YWx1ZXMgc2V0dGluZ3MgYXJlIHZhbGlkIHdpdGhpbiBwYWdlIGNvbnRleHQgb25seS5cclxuXHQgKiAgIC0gSWYgaXMgY2FsbGVkIG11bHRpcGxlIHRpbWVzLCB3aWxsIG92ZXJyaWRlIHRoZSBsYXN0IHZhbHVlLlxyXG5cdCAqIEBwYXJhbSB7T3B0aW9uc30gb3B0aW9ucyBjaGFydCBvcHRpb25zXHJcblx0ICogQG1lbWJlcm9mIGJiXHJcblx0ICogQHJldHVybiB7T3B0aW9uc31cclxuXHQgKiBAc2VlIHtAbGluayBPcHRpb25zfVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogLy8gU2V0IHNhbWUgb3B0aW9uIHZhbHVlIGFzIGZvciBgLmdlbmVyYXRlKClgXHJcblx0ICogYmIuZGVmYXVsdHMoe1xyXG5cdCAqICAgZGF0YToge1xyXG5cdCAqICAgICB0eXBlOiBcImJhclwiXHJcblx0ICogICB9XHJcblx0ICogfSk7XHJcblx0ICpcclxuXHQgKiBiYi5kZWZhdWx0cygpOyAgLy8ge2RhdGE6e3R5cGU6IFwiYmFyXCJ9fVxyXG5cdCAqXHJcblx0ICogLy8gZGF0YS50eXBlIGRlZmF1bHRzIHRvICdiYXInXHJcblx0ICogdmFyIGNoYXJ0ID0gYmIuZ2VuZXJhdGUoeyAuLi4gfSk7XHJcblx0ICovXHJcblx0ZGVmYXVsdHMob3B0aW9ucykge1xyXG5cdFx0aWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XHJcblx0XHRcdGRlZmF1bHRzID0gb3B0aW9ucztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGVmYXVsdHM7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQW4gYXJyYXkgY29udGFpbmluZyBpbnN0YW5jZSBjcmVhdGVkXHJcblx0ICogQHByb3BlcnR5IHtBcnJheX0gaW5zdGFuY2UgaW5zdGFuY2UgYXJyYXlcclxuXHQgKiBAZXhhbXBsZVxyXG5cdCAqICAvLyBnZW5lcmF0ZSBjaGFydHNcclxuXHQgKiAgdmFyIGNoYXJ0MSA9IGJiLmdlbmVyYXRlKC4uLik7XHJcblx0ICogIHZhciBjaGFydDIgPSBiYi5nZW5lcmF0ZSguLi4pO1xyXG5cdCAqXHJcblx0ICogIGJiLmluc3RhbmNlOyAgLy8gWyBjaGFydDEsIGNoYXJ0MiwgLi4uIF1cclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKi9cclxuXHRpbnN0YW5jZTogW10sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE5hbWVzcGFjZSBmb3IgcGx1Z2luc1xyXG5cdCAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBwbHVnaW4gcGx1Z2luIG5hbWVzcGFjZVxyXG5cdCAqIEBleGFtcGxlXHJcblx0ICogIC8vIFN0YW5mb3JkIGRpYWdyYW0gcGx1Z2luXHJcblx0ICogIGJiLnBsdWdpbi5zdGFuZm9yZDtcclxuXHQgKiBAbWVtYmVyb2YgYmJcclxuXHQgKi9cclxuXHRwbHVnaW46IHt9XHJcbn07XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=